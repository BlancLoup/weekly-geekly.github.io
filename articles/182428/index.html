<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development and execution speeds not reachable in C</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the continuation of the article on cross-platform and cross-hardware optimization, using the example of a search task with a full pass through a ta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development and execution speeds not reachable in C</h1><div class="post__text post__text-html js-mediator-article">  In the continuation of the <a href="http://habrahabr.ru/post/182356/">article</a> on cross-platform and cross-hardware optimization, using the example of a search task with a full pass through a table of 5 fields and 10,000,000 rows, and the inevitability of this task even during an index search, I will show how to speed up such a search <b>3.5-5.3</b> times using <b>C ++ is</b> independent of the hardware platform. <br>  In the previous article, we were able to speed up the search by 1.3 times: <a href="">GitHub.com</a> <br>  We will not simply describe the language constructs, but show the advantages of C ++ in solving one of the stages of the real problem. <br>  We still write cross-platform for MSVC11 (MSVS2012) and GCC 4.7.2, and use C and the partially implemented C ++ 11 standard in them. <br>  To simplify the understanding, we still write without an index search, but this solution will later be used in an index search. <br><a name="habracut"></a><br><h4>  1. Hardcore C ++ solution </h4><br>  This would be a really hardcore solution on C. This is because, unfortunately for C-developers, you have to create 3840 functions and never make a mistake in them.  As long as C-developers write them, we will treat them with great respect, and I will show you how the C ++ compiler can write these 3840 functions for you.  He will not do it quickly, but much faster and more accurately than C-developers will write them. <br>  Everything is very simple, in the theory of a DBMS there is such a thing as a predicate <code>selectivity</code> ( <code>selectivity</code> ) - the percentage of matching rows of a table under one of the conditions (predicate).  The lower the selectivity of the condition, the earlier it should be compared, and the sooner we understand that the line is not suitable.  Those.  let's get rid of comparisons for the following conditions. <br>  In real DBMS, statistics for this are collected by the optimizer and the necessary formula for calculating the selectivity depending on the data distribution graph is selected.  I think discrete mathematics and combinatorics with brute force fields are enough for you today, so for simplicity we will consider cardinality selectivity based on uniform data distribution.  (Cardinality column - the percentage of unique values ‚Äã‚Äãin the column.) <br>  Selectivity (number of rows) will be equal to: <br> <code>selectivity = c_array_size * (1 + field.end ‚Äì field.begin) / cardinality;</code> <br>  The size of the array and cardinality for evenly distributed data are known to us at the compilation stage.  And we find the limits of the search conditions for each field during execution and calculate the selectivity. <br>  Then we select the fields in ascending order of selectivity starting from the lowest.  And depending on the order of the selected field numbers, we form a numerical index of the most optimal function, which we then call to search. <br>  We generate the optimized functions for each variant of the search conditions, or rather the polymorphic classes, with two nested promotion templates: <br><ol><li>  Brute force search options (as was the case with the <a href="http://habrahabr.ru/post/182356/">previous C ++ solution</a> ) </li><li>  Enumerate all variants of the order of search conditions </li></ol><br>  The total is created and filled with an array of <code>(2^5)*5! = 32*120 = 3840</code>  <code>(2^5)*5! = 32*120 = 3840</code> objects with different implementations, but with a common base abstract ancestor. <br>  Checks of the range for more and less for one field always go together.  We will not rearrange the minimum and maximum values ‚Äã‚Äãfor one field independently or change the order so as not to delay the compilation time. <br>  Now let's look at how the code will look. <br><br><h4>  2. Reducing dependencies </h4><br>  First, to implement our solution, we will have to implement access to the fields of the string through the template compile-time-getters.  It will also add a nice bonus - reducing dependencies - now any changes in types and the number of fields in the code will affect only the structure of the <code>T_cash_account_row.</code> line <code>T_cash_account_row.</code> <br>  The interface of our search class itself will remain unchanged, and the implementation of a search on an arbitrary table will be instantiated by a template search class. <br>  This is how the line structure code with fields will look like: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Row */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T_cash_account_row</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// Fields: enum T_field_enum { amount_of_money_e, gender_e, age_e, code_e, height_e, /*&lt;&lt;&lt;&lt;&lt;- add fields here (with index) */ last_e /*&lt;&lt;&lt;&lt;&lt;- add included fields here (without index) */ }; static_assert(last_e &gt; 0, "Number of indexed fields in enum of T_cash_account_row must be greater than 0!"); unsigned code:20; // 0 - 1000000 unsigned gender:1; // 0 - 1 unsigned age:7; // 0 - 100 unsigned amount_of_money:20; // 0 - 1000000 unsigned height:9; // 0 ‚Äì 300 // Get field value template&lt;int field_enum&gt; inline typename std::enable_if&lt;field_enum == code_e, decltype(code)&gt;::type get_field_value() const { return code; } template&lt;int field_enum&gt; inline typename std::enable_if&lt;field_enum == gender_e, decltype(gender)&gt;::type get_field_value() const { return gender; } template&lt;int field_enum&gt; inline typename std::enable_if&lt;field_enum == age_e, decltype(age)&gt;::type get_field_value() const { return age; } template&lt;int field_enum&gt; inline typename std::enable_if&lt;field_enum == amount_of_money_e, decltype(amount_of_money)&gt;::type get_field_value() const { return amount_of_money; } template&lt;int field_enum&gt; inline typename std::enable_if&lt;field_enum == height_e, decltype(height)&gt;::type get_field_value() const { return height; } template&lt;int field_enum&gt; inline typename std::enable_if&lt;field_enum == last_e, bool&gt;::type get_field_value() const { return true; } static_assert(5 == last_e, "Add/delete new field-case and correct this assert!"); }; /* ----------------------------------------------------------------------- */</span></span></code> </pre><br>  <code>enum T_field_enum</code> always have default values ‚Äã‚Äãin ascending order starting with 0 ( <a href="https://code.google.com/p/openassist/downloads/detail%3Fname%3DC%252B%252B%2520Standard%2520-%2520ANSI%2520ISO%2520IEC%252014882%25202003.pdf">C ++ 03 7.2 Enumeration declarations</a> ). <br>  The <code>std::enable_if&lt;&gt;</code> from the <code>#include &lt;type_traits&gt;</code> library allows you to get instances of functions / classes only for certain values ‚Äã‚Äãof the template parameter.  Otherwise, a substitution error occurs during instantiation, and according to the <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">SFINAE</a> principle <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">(substitution-failure-is-not-an-error)</a> , if there is a substitution error, no compilation error occurs, and an instance of the function is simply not created.  More in detail in the standard ( <a href="https://code.google.com/p/openassist/downloads/detail%3Fname%3DC%252B%252B%2520Standard%2520-%2520ANSI%2520ISO%2520IEC%252014882%25202003.pdf">C ++ 03 14.8.2 Template argument deduction</a> ). <br>  This is necessary to access the required fields of different types through the parameters of the getter template, for example: <br> <code>auto code = row-&gt;get_field_value&lt;T_cash_account_row::code_e&gt;();</code> <br>  In our case, all 5 fields are of the same type and one could do without <code>std::enable_if&lt;&gt;</code> , but we think ahead.  In my example, you can change the type of any of the 5 fields, and the getters will compile and work fine.  Suppose if we made them through the specialization of the template function, we would get errors when accessing different types, for example, such code will not compile: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Row */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T_cash_account_row</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// Fields: enum T_field_enum { amount_of_money_e, gender_e, age_e, code_e, height_e, /*&lt;&lt;&lt;&lt;&lt;- add fields here (with index) */ last_e /*&lt;&lt;&lt;&lt;&lt;- add included fields here (without index) */ }; static_assert(last_e &gt; 0, "Number of indexed fields in enum of T_user_row must be greater than 0!"); unsigned code:20; // 0 - 1000000 unsigned gender:1; // 0 - 1 unsigned age:7; // 0 - 100 unsigned amount_of_money:20; // 0 - 1000000 int height; // 0 ‚Äì 300 // Get field value template&lt;int field_enum&gt; inline unsigned get_field_value(); template&lt;int field_enum&gt; inline int get_field_value(); static_assert(5 == last_e, "Add/delete new field-case and correct this assert!"); }; template&lt;&gt; inline unsigned T_cash_account_row::get_field_value&lt;T_cash_account_row::code_e&gt;() { return code; } template&lt;&gt; inline unsigned T_cash_account_row::get_field_value&lt;T_cash_account_row::gender_e&gt;() { return gender; } template&lt;&gt; inline unsigned T_cash_account_row::get_field_value&lt;T_cash_account_row::age_e&gt;() { return age; } template&lt;&gt; inline unsigned T_cash_account_row::get_field_value&lt;T_cash_account_row::amount_of_money_e&gt;() { return amount_of_money; } template&lt;&gt; inline int T_cash_account_row::get_field_value&lt;T_cash_account_row::height_e&gt;() { return height; } template&lt;&gt; inline unsigned T_cash_account_row::get_field_value&lt;T_cash_account_row::last_e&gt;() { return 1; } /* ----------------------------------------------------------------------- */ int main() { T_cash_account_row *row = new T_cash_account_row; auto code = row-&gt;get_field_value&lt;T_cash_account_row::code_e&gt;(); return 0; }</span></span></code> </pre><br>  The compiler will naturally generate an error about an ambiguous <code>get_field_value&lt;&gt;()</code> function call.  <a href="http://ideone.com/QgW7tH">Ideone.com</a> <br>  Our version is perfectly compiled: <a href="http://ideone.com/9yahUB">ideone.com</a> <br>  You have figured out the getters, now let's apply the unrolling of template similar to the one from the previous article, but not for the designer, but for the functor (the functor is a class with the overloaded call <code>operator()(‚Ä¶)</code> ): <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// The templated functor of unrolling of the input templated functor (reusable) template&lt;unsigned unroll_count, template&lt;unsigned&gt; class T&gt; struct T_unroll_functor { T_unroll_functor&lt;unroll_count-1, T&gt; next_unroll; T&lt;unroll_count-1&gt; functor; template&lt;typename T1, typename T2&gt; inline bool operator()(T1 const&amp; val1, T2 const&amp; val2) { return next_unroll(val1, val2) &amp;&amp; functor(val1, val2); } }; // End of unroll template&lt;template&lt;unsigned&gt; class T&gt; struct T_unroll_functor&lt;0, T&gt; { template&lt;typename T1, typename T2&gt; inline bool operator()(T1 const&amp;, T2 const&amp;) { return true; } }; // -------------------------------------------------------------------------</span></span></code> </pre><br>  <code>last_e</code> such promotion, we expand the comparisons for each field, based on the value of the <code>last_e</code> enumeration and access to the fields through our sample getters. <br>  And we will expand the functor <code>struct T_test_pred</code> as follows: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// The filters for each search variant (range_filters) template&lt;typename T_row, unsigned index_pred&gt; struct T_custom_filter : T_filter&lt;T_row&gt; { // Test predicates functor for unrolling template&lt;unsigned field_num&gt; struct T_test_pred { bool inline operator()(T_row *const __restrict row, T_range_filters *const __restrict range_filters) const { typedef typename T_row::T_field_enum T_field_enum; // Without fields where use_filter==0 return ( T_filter&lt;T_row&gt;::template T_get_use_filter&lt;index_pred, field_num&gt;::value || (row-&gt;template get_field_value&lt;static_cast&lt;T_field_enum&gt;(field_num)&gt;() &gt;= range_filters-&gt;begin.template get_field_value&lt;static_cast&lt;T_field_enum&gt;(field_num)&gt;()&amp;&amp; row-&gt;template get_field_value&lt;static_cast&lt;T_field_enum&gt;(field_num)&gt;() &lt;= range_filters-&gt;end.template get_field_value&lt;static_cast&lt;T_field_enum&gt;(field_num)&gt;()) ); } }; // ----------------------------------------------------------------------- // search virtual size_t search(T_row *const __restrict array_ptr, const size_t c_array_size, T_row *const __restrict result_ptr, T_range_filters *const __restrict range_filters) final { size_t result_size = 0; size_t i; // loop index T_unroll_functor&lt;T_row::last_e, T_test_pred&gt; test_predicate; for(i = 0; i &lt; c_array_size; ++i) { if(test_predicate(array_ptr + i, range_filters)) result_ptr[result_size] = array_ptr[i], ++result_size; } return result_size; } }; // -------------------------------------------------------------------------</span></span></code> </pre><br>  I also note that now in the <code>T_filter&lt;&gt;, T_custom_filter&lt;&gt;  T_optimized_search&lt;&gt;</code> <code>T_row</code> , the template parameter <code>T_row</code> , into which the row type of the table is transferred - in our case <code>T_cash_account_row</code> . <br>  Now all changes in the number, names and types of table fields are concentrated solely inside <code>T_cash_account_row</code> , and the entire search code is generated automatically from the template classes; you just need to instantiate the template with the type of the necessary string: <br> <code>T_optimized_search&lt;T_cash_account_row&gt; optimized_search; // C++ optimized search</code> <br>  Here is the link to the resulting working code: <a href="">GitHub.com</a> <br>  This example clearly shows why in critical parts of the code team-lead and performance-architect should pay attention not only to the external interfaces of the modules, but also to the types of objects transmitted through these interfaces.  In our case, these are: <code>T_cash_account_row  T_range_filters</code> .  Having set the opportunity in <code>T_cash_account_row</code> pass parameters through template getters, we predetermine a more flexible implementation by the developer of the module through template promotion, as well as a more flexible implementation of tests when using development techniques through TDD testing, which I will show in the next article. <br>  On the MSVC11 compiler (MSVS2012) and one CPU Core i5 K750 core, the result is: <br><blockquote>  Generated rows: 10,000,000 <br>  C ++ - Searching ... <br>  C ++ - optimized search took 0.056000 seconds. <br>  Found rows: 38 <br>  C-Searching ... <br>  C-search took 0.074000 seconds. <br>  The C ++ faster than C: 1.321429 times <br>  Found rows: 38 </blockquote><br>  As you can see, the C ++ code is still 1.3 times faster than the C code. The resulting assembler code of the <code>test_predicate</code> function is still identical to the previous C ++ version, <a href="https://github.com/AlexeyAB/cpp_find_order/tree/7d0e5d577cafe6ec840475e64f8e8121dcee1379/msvc11_disasm">test_pradicate_enum_cpp.asm</a> . <br>  ‚ÄúPicture disasm of TortoiseDiff‚Äù <br><img src="http://s2.ipicture.ru/uploads/20130607/qVT1Iu4v.png" alt="test_pradicate_enum_cpp.asm"><br>  But now we have focused all the changes in one place, which will greatly facilitate the use of this search module. <br>  In addition, we prepared the code for another, more efficient optimization. <br><br><h4>  3. Acceleration 3.5 - 5.3 times </h4><br>  Quite often there are articles on C ++, where compile-time calculations are considered or, for example, the <a href="http://habrahabr.ru/post/124476/">search for primes on templates.</a>  The articles are interesting, but as the authors themselves note: ‚ÄúI will tell you how to do a completely useless thing.‚Äù <br>  I will tell you how to get a noticeable acceleration of the search from compile-time calculations and optimizations using templates. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  3.1 Simple calculations on templates </h5><br>  Let's start with the simplest of what we need, let's implement the compile-time factorial calculation: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> N&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">factorial</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>, N * factorial&lt;N<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;::value&gt; {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">factorial</span></span></span><span class="hljs-class">&lt;0&gt; :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; {};</code> </pre><br>  Calculation of factorial we need to create a static array <code>std::array&lt;&gt;</code> with the number of elements equal to <code>(2^5)*5! = 3840</code>  <code>(2^5)*5! = 3840</code> . <br>  From discrete mathematics and combinatorics it is known that the number of different permutations of unique elements is equal to the factorial of their number.  A number of options for the presence of elements is 2 in the degree of the number of elements.  (Of course, it doesn‚Äôt matter to us how the missing elements are rearranged, and the absence of redundant options could speed up the compilation, but I try to simplify this article as much as possible.) <br>  Now let's see what optimizations will be inside the structure. <br>  <code>struct T_custom_filter</code> when instantiating it. <br>  First, it now also takes the <code>index_order</code> parameter.  And secondly, the searchable functor has changed in it. <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// The filters for each search variant (range_filters) template&lt;typename T_row, unsigned index_pred, unsigned index_order = 0&gt; struct T_custom_filter : T_filter&lt;T_row&gt; { // Test predicates functor for unrolling template&lt;unsigned field_num&gt; struct T_test_pred { bool inline operator()(T_row *const __restrict row, T_range_filters *const __restrict range_filters) const { typedef typename T_row::T_field_enum T_field_enum; // Without fields where use_filter==0 enum { ordered_field_number = T_filter&lt;T_row&gt;::template T_number_field&lt;index_order, field_num&gt;::value }; return ( T_filter&lt;T_row&gt;::template T_get_use_filter&lt;index_pred, ordered_field_number&gt;::value || (row-&gt;template get_field_value&lt;static_cast&lt;T_field_enum&gt;(ordered_field_number)&gt;() &gt;= range_filters-&gt;begin.template get_field_value&lt;static_cast&lt;T_field_enum&gt;(ordered_field_number)&gt;() &amp;&amp; row-&gt;template get_field_value&lt;static_cast&lt;T_field_enum&gt;(ordered_field_number)&gt;() &lt;= range_filters-&gt;end.template get_field_value&lt;static_cast&lt;T_field_enum&gt;(ordered_field_number)&gt;()) ); } }; // ----------------------------------------------------------------------- // search virtual size_t search(T_row *const __restrict array_ptr, const size_t c_array_size, T_row *const __restrict result_ptr, T_range_filters *const __restrict range_filters) final; }; // -------------------------------------------------------------------------</span></span></code> </pre><br>  As before, the <code>T_get_use_filter</code> template returns a flag of using (or not using) a filter by the <code>number_filter</code> field for a given index_pred index. <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// whether to use the filter for a given predicate? (strictly at compile time) template &lt;unsigned index_pred, unsigned number_filter&gt; struct T_get_use_filter : std::integral_constant&lt;bool, !(index_pred &amp; 1&lt;&lt;number_filter)&gt; {};</span></span></code> </pre><br>  From the <code>T_number_field&lt;&gt;</code> template, based on the <code>index_order</code> - the index of the order of comparing fields and the sequence number of the field <code>field_num</code> , we get the field number <code>ordered_field_number</code> to get its value from the getter <code>get_field_value&lt;static_cast&lt;T_field_enum&gt;(ordered_field_number)&gt;()</code> . <br><br><h5>  3.2 More complex calculations on templates </h5><br>  Now more difficult.  Implement the calculation of the order of the field in the template class <code>T_number_field&lt;&gt;</code> .  The index of the order of the fields <code>index_order</code> is formed as follows - for example, the index for 5 fields is composed of the following formula: <br> <code>index_order = field0 + 5*field1 + 5*4*field2 + 5*4*3*field3 + 5*4*3*2*field4;</code> <br>  where <code>field1</code> is the number of the field from 0 to 4 (out of 5 available), going first when comparing;  field2 - field number from 0 to 3 (out of 4 remaining ones), coming second when comparing;  ...;  and field5 is the field number from 0 to 0 (of the 1 remaining one) going last, since  it is always 0, then it can be omitted: <br> <code>index_order = field0 + 5*field1 + 5*4*field2 + 5*4*3*field3;</code> <br>  or, which is the same: <br> <code>index_order = field0 + 5*(field1 + 4*(field2 + 3*(field3)));</code> <br>  It may be easier for someone to represent the value of index_order as a number with a variable basis of the calculus system, where <code>field0</code> is the first digit with a base 5 (can take 5 values ‚Äã‚Äã0-4), in <code>field1</code> is the second digit with a base 4 (it can take 4 values ‚Äã‚Äã0 -3), and so on.  Thus, in (5!) Combinations, we can encode any field permutations.  For a better understanding, it is advisable to familiarize yourself with the basics of the theory of probability or a search from discrete mathematics. <br>  Visually, this can be represented as follows: with round brackets () we denote the lowest priority value from the available ones (the most priority), square [] - its number from the existing ones, and curly {} - the real field number.  For example, initially we have 5 fields with such priorities: 5, 3, 1, 2, 4 <br><pre> Field number: 0 1 2 3 4
 Comparison priority: 5 3 (1) 2 4 - [2] - current field number (field0) {2}
 Comparison priority: 5 3 (2) 4 - [2] - current field number (field1) {3}
 Comparison priority: 5 (3) 4 - [1] - current field number (field2) {1}
 Comparison priority: 5 (4) - [1] - current field number (field3) {4}
 Comparison priority: (5) - [0] - current field number (field4) {0}
</pre><br>  Substituting the numbers in: <code>index_order = field0 + 5*(field1 + 4*(field2 + 3*(field3)));</code> <br>  We get the index value: <code>index_order = 2 + 5*(2 + 4*(1 + 3*(1))) = 92;</code> <br>  Later we will show how this is implemented in the run-time function <code>T_optimized_search::get_index_order().</code> <br>  Now, as a result of the promotion, this index is known to us at the compilation stage, and there is an inverse problem of how to get a sequence number from it for each field in the compile-time. <br>  First, learn to get the numbers in square brackets [].  In our particular case, the ‚Äúcurrent field numbers‚Äù are as follows, for the <code>index_order = 2 + 5*(2 + 4*(1 + 3*(1))) = 92</code> we <code>index_order = 2 + 5*(2 + 4*(1 + 3*(1))) = 92</code> : <br><pre> field0 = index_order% 5 = 92% 5 = 2;
 field1 = (index_order / 5)% 4 = (92/5)% 4 = 2;
 field2 = (index_order / (5 * 4))% 3 = (92/5 * 4)% 3 = 1;
 field3 = (index_order / (5 * 4 * 3))% 2 = (92/5 * 4 * 3)% 2 = 1;
 field4 = 0;
</pre><br>  In compile-time, this makes the following template class: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Get the sequence number the remaining field for the number_filter, after removal of all previous template &lt;unsigned index_order, unsigned number_filter, unsigned index = T_row::last_e&gt; struct T_number_remaining_field : std::integral_constant&lt;unsigned, T_number_remaining_field&lt;index_order / index, number_filter - 1, index - 1&gt;::value&gt; {}; // End of unroll template &lt;unsigned index_order, unsigned index&gt; struct T_number_remaining_field&lt;index_order, 0, index&gt; : std::integral_constant&lt;unsigned, index_order % index&gt; {}; // -------------------------------------------------------------------------</span></span></code> </pre><br>  And we get the value of the ‚Äúcurrent field number‚Äù equal to number_filter, by instantiating the template in this way <code>T_number_remaining_field&lt;index_order, number_filter&gt;::value</code> . <br>  There is a moment where some may get confused: someone might think that with ( <code>number_filter=0</code> ), i.e.  <code>T_number_remaining_field&lt;index_order, 0&gt;::value</code> immediately causes partial specialization with two parameters: <br> <code>template &lt;unsigned index_order, unsigned index&gt; struct T_number_remaining_field&lt;index_order, 0, index&gt;</code> <br>  Where <code>index_order</code> substituted in <code>index_order</code> , and 0 is substituted in <code>index</code> .  But it is not so! <br>  According to the standard ( <a href="https://code.google.com/p/openassist/downloads/detail%3Fname%3DC%252B%252B%2520Standard%2520-%2520ANSI%2520ISO%2520IEC%252014882%25202003.pdf">C ++ 03 14.8.2 Template argument deduction</a> ), first the default template is substituted from the common template <code>index = T_row::last_e</code> and in fact our instantiation is converted to <code>T_number_remaining_field&lt;index_order, 0, T_row::last_e&gt;::value</code> .  And then there is an appeal to the specialization: <br> <code>template &lt;unsigned index_order, unsigned index&gt; struct T_number_remaining_field&lt;index_order, 0, index&gt;</code> <br>  And for a zero current field number of 5 fields ( <code>T_row::last_e=5</code> ), we get <code>index_order % 5</code> , as required. <br>  We implemented a way to find the "current field numbers" of those in square brackets.  Now we need to implement getting real field numbers for those in curly braces {}. <br>  As we saw from our visual presentation, the ‚Äúcurrent field numbers‚Äù in square brackets [] do not always coincide with the real field numbers in curly brackets {}.  If you present a deck of numbered cards in ascending order from bottom to top, then initially their numbers will coincide with their order in the deck.  But removing cards from the middle of those cards that lie above them, each time will decrease by one the ordinal number in the deck relative to their real number. <br>  In our case, this leads to the fact that all fields with a smaller real number {} and a smaller priority value () (higher priority, which are previously withdrawn), reduce by one the ‚Äúcurrent field value‚Äù [], whose real number and priority value more.  These offsets are calculated by the following template classes: <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Get 1 or 0 offset if current_field (for number_filter) affect to number_field template &lt;unsigned index_order, unsigned number_filter, unsigned number_field&gt; struct T_offset { enum { current_field = T_number_remaining_field&lt;index_order, number_filter&gt;::value, value = (current_field &lt;= number_field)?1:0 }; }; // Get offset of number_field (enum in row-type) for number_filter template &lt;unsigned index_order, unsigned number_filter, unsigned number_field&gt; struct T_offset_number_field { enum { offset = T_offset&lt;index_order, number_filter-1, number_field&gt;::value, value = T_offset_number_field&lt;index_order, number_filter-1, number_field + offset&gt;::value + offset }; }; // End of unroll template &lt;unsigned index_order, unsigned number_field&gt; struct T_offset_number_field&lt;index_order, 0, number_field&gt; : std::integral_constant&lt;unsigned, 0&gt; {};</span></span></code> </pre><br>  Finally, we get the real field numbers in the following template class: <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// (Main) Get number of field (enum in row-type) for number_filter template &lt;unsigned index_order, unsigned number_filter&gt; struct T_number_field { enum { remaining_field = T_number_remaining_field&lt;index_order, number_filter&gt;::value, value = remaining_field + T_offset_number_field&lt;index_order, number_filter, remaining_field&gt;::value }; }; // -------------------------------------------------------------------------</span></span></code> </pre><br>  Is done. <br><br><h5>  3.3 Nested template promotion </h5><br>  Now we need to instantiate the <code>T_custom_filter&lt;&gt;</code> filter template by the presence of search fields and by their order.  To do this, we apply the nested promotion templates: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_row&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T_optimized_search</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// unroll tamplates template&lt;unsigned index_pred&gt; struct T_unroll_find { template&lt;unsigned index_order&gt; struct T_unroll_order { template&lt;typename T&gt; T_unroll_order(T &amp;filters) { filters[index_pred + index_order*(1&lt;&lt;T_row::last_e)].reset( new T_custom_filter&lt;T_row, index_pred, index_order&gt;() ); } }; T_unroll_constructor&lt;factorial&lt;T_row::last_e&gt;::value, T_unroll_order&gt; fill_ordered_filter; template&lt;typename T&gt; T_unroll_find(T &amp;filters) : fill_ordered_filter(filters) {} }; // ------------------------------------------------------------------------- std::array&lt;std::unique_ptr&lt;T_filter&lt;T_row&gt;&gt;, (1&lt;&lt;T_row::last_e)*factorial&lt;T_row::last_e&gt;::value&gt; filters; T_unroll_constructor&lt; 1&lt;&lt;T_row::last_e, T_unroll_find&gt; fill_filter; public: T_optimized_search() : fill_filter(filters) {} // C++ optimized search inline size_t search(T_row *const __restrict array_ptr, const size_t c_array_size, T_row *const __restrict result_ptr, T_range_filters *const __restrict range_filters) { auto const&amp; filter = filters[T_filter&lt;T_row&gt;::get_index_pred(range_filters) + T_filter&lt;T_row&gt;::get_index_order(range_filters)*(1&lt;&lt;T_row::last_e)]; return filter-&gt;search(array_ptr, c_array_size, result_ptr, range_filters); } }; // -------------------------------------------------------------------------</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we used the compile-time promotion of the presence of field comparisons </font></font><code>struct T_unroll_find&lt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and inside it we used the promotion of the field comparison order </font></font><code>struct T_unroll_order&lt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And in the search function, we use the run-time function </font></font><code>get_index_pred()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äî retrieve an index depending on the need to compare fields, and function </font></font><code>get_index_order()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äî retrieve an index depending on the required order of comparison of fields. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first function remains the same:</font></font><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Get index of T_test_pred version for current search range static inline const unsigned get_index_pred(T_range_filters *const __restrict range_filters) { unsigned result = 0; for(size_t i = 0; i &lt; T_row::last_e; ++i) result |= range_filters-&gt;use_filter[i]?(1&lt;&lt;i):0; return result; } // -------------------------------------------------------------------------</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the second one was added </font></font><code>get_index_order()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">First, I‚Äôll clarify that </font></font><code>struct T_cash_account_row</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a function appeared </font><font style="vertical-align: inherit;">in the structure of the line </font></font><code>get_bitf_size()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äî getting cardinality (it is in this form, and not through switch / case, it can act as constexpr, that is, compile-time, but MSVC11 does not yet support this):</font></font><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Row */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T_cash_account_row</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-comment"><span class="hljs-comment">// Get cardinality template&lt;int field_enum&gt; // constexpr // not supported in the MSVS2012(MVCC11) static inline const unsigned int get_bitf_size() { return (field_enum == gender_e)? 1: (field_enum == age_e)? 100: (field_enum == height_e)? 300: (field_enum == code_e)? 1000000: (field_enum == amount_of_money_e)?1000000: 0; static_assert(5 == last_e, "Add/delete new field-case and correct this assert!"); } };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And once again I will remind the selectivity formula (number of lines): </font></font><br> <code>selectivity = c_array_size * (1 + field.end ‚Äì field.begin) / cardinality;</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And now the function itself for obtaining the index, depending on the order of comparison of the fields, using the template promotion of the constructor to calculate the selectivity for each condition / field:</font></font><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// The unrolling filling of selectivity in a compile-time template&lt;unsigned field_num&gt; struct T_selectivity_fill { T_selectivity_fill(std::map&lt;unsigned, unsigned&gt; *const __restrict ordered_filters, T_range_filters *const __restrict range_filters) { // selectivity for each field-filter const unsigned selectivity = range_filters-&gt;use_filter[field_num]? ((1 + range_filters-&gt;end.template get_field_value&lt;field_num&gt;() - range_filters-&gt;begin.template get_field_value&lt;field_num&gt;() )*c_array_size / T_row::template get_bitf_size&lt;field_num&gt;()) // cardinality :c_array_size; ordered_filters-&gt;insert(std::make_pair(field_num, selectivity)); } }; // Get index of T_test_pred version for current search range static inline const unsigned get_index_order( T_range_filters *const __restrict range_filters) { unsigned result = 0; std::map&lt;unsigned, unsigned&gt; ordered_filters; T_unroll_constructor&lt;T_row::last_e, T_selectivity_fill&gt; selectivity_fill(&amp;ordered_filters, range_filters); unsigned multiplexor = 1; for(size_t i = 0; i &lt; T_row::last_e; ++i) { unsigned cur_index = 0, min_index = 0; unsigned field_num = ordered_filters.cbegin()-&gt;first; unsigned min = c_array_size; for(auto const&amp; it : ordered_filters) { if (it.second &lt; min) min = it.second, field_num = it.first, min_index = cur_index; ++cur_index; } ordered_filters.erase(field_num); result += min_index*multiplexor; multiplexor *= (T_row::last_e - i); } return result; } // -------------------------------------------------------------------------</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here the key is </font></font><code>std::map&lt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">filled with the field numbers, and the value is filled with the expected selectivity. Then in the cycle we find the minimum selectivity, take the corresponding field number from the key, delete the record from it </font></font><code>std::map&lt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and use this field number to compile the index. And so in the loop for each field. We have already described how this index returned by the function is obtained </font></font><code>get_index_order</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mathematically: </font></font><br> <code>index_order = field1 + 5*(field2 + 4*(field3 + 3*(field4)));</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So we were able to unwind the search pattern </font></font><code>3840</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">once, populate a static array with these objects and get the index of the necessary object with a search function optimized for the given search conditions at run-time. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The resulting assembly code function</font></font><code>test_predicate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">changed compared to the previous version in C ++ - two comparisons are reversed, the first of them is now the last: </font></font><a href="https://github.com/AlexeyAB/cpp_find_order/tree/7d0e5d577cafe6ec840475e64f8e8121dcee1379/msvc11_disasm"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com asm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Picture from TortoiseDiff"</font></font><br><img src="http://s1.ipicture.ru/uploads/20130607/2N6j1ic6.png" alt="image"><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4. Test results </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is a fully working version of this solution in C ++: </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub.com</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> On GCC4.7.2 with the ‚ÄìO3 ‚Äìmarch = native key, CPU Core i5 K750 and the size of the exe file of 1.3MB is the result:</font></font><br><blockquote>  Generated rows: 10,000,000 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ - Searching ... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ - optimized search took 0.017000 seconds.</font></font><br>  Found rows: 38 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C-Searching ... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C-search took 0.090000 seconds. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The C ++ faster than C: 5.294118 times</font></font><br>  Found rows: 38 </blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And on MSVC11 (MSVS2012) with the / O2 / Ob2 / Oi key, CPU Core i5 K750 and exe-file size of 1.42MB, the result is: </font></font><br><blockquote>  Generated rows: 10,000,000 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ - Searching ... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ - optimized search took 0.021000 seconds.</font></font><br>  Found rows: 38 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C-Searching ... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C-search took 0.074000 seconds. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The C ++ is faster than C: 3.523809 times</font></font><br>  Found rows: 38 </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As we see, the execution time fell from 74ms to C, to 21ms to C ++, i.e. </font><font style="vertical-align: inherit;">speed increased </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.5 times</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font> Fine.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And as you can see, GCC shows an even more noticeable difference in speed, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.3 times</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . And this is absolutely a cross-hardware solution, unlike SIMD instructions and cache-prefetch. Unlike </font></font><a href="http://habrahabr.ru/post/138132/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PGO</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which creates one optimized program execution path, we have created 3840 paths optimized for all cases of input data. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maybe this solution will seem difficult to you, but now it is clear what it means to really know C ++. If you don‚Äôt know C ++ well, then the only alternative you have is to write in C. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To dispel doubts that this can be solved in C through an array of function pointers, I‚Äôll give an example.</font></font> Since<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I know that a good optimization on C in this case will not work, then I will not implement the mechanism for calculating selectivity and rearrangement of conditions, but simply with my hands will optimally change the functions of places when filling in an array of pointers. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is a working version of this solution on C: </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub.com</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> How it differs from the C-optimization example from the previous article can be viewed in diff with the previous version: </font></font><a href="https://github.com/AlexeyAB/cpp_find_order/commit/ba568e1f9652ae106d4e50f978ff074269d16bc9"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub.com</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> On GCC4.7.2 with the ‚ÄìO3 key ‚Äìmarch = native, CPU Core i5 K750 result is as follows:</font></font><br><blockquote>  Generated rows: 10,000,000 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C-optimized-Searching ... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C-optimized-search took 0.049000 seconds.</font></font><br>  Found rows: 38 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C-Searching ... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C-search took 0.086000 seconds. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The C ++ is faster than C: 1.755102 times</font></font><br>  Found rows: 38 </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And on MSVC11 with the / O2 / Ob2 / Oi key, CPU Core i5 K750 the result is: </font></font><br><blockquote>  Generated rows: 10,000,000 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C-optimized-Searching ... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C-optimized-search took 0.045000 seconds.</font></font><br>  Found rows: 38 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C-Searching ... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C-search took 0.074000 seconds. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The C ++ is faster than C: 1.644444 times</font></font><br>  Found rows: 38 </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As we can see, the result with optimization in C lags behind our optimization in C ++ by more than </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 to 3 times</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acceleration on GCC on C by </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> times versus </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> times on C ++, and acceleration on MSVC on C by </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.6</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> times versus </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.5</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> times on C ++. </font><font style="vertical-align: inherit;">Moreover, C optimization is easily compiled by the C ++ compiler without a single change, but not vice versa.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5. Conclusion </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I showed how using C ++ templates to implement computations and cross-hardware optimization at compile time to get acceleration </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.5-5.3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> times for a real task. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are no such optimizations in C that could not be applied in C ++, since there is almost complete backward compatibility. But in C - the only alternative to C ++ - templates for such optimizations is to write dozens, hundreds and thousands of functions - this is where copy-paste really is. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let me remind you that this optimization is not applicable in Java and C #, since in generics it is impossible to use values ‚Äã‚Äãin parameters, and only types are possible. Java and C # have other advantages - these are advanced libraries and protection against stupid bugs.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the following articles, I will describe the index search option that is most suitable for this task, why the multi-index connections Index Hash Join and Bitmap AND will not work here, but the Index Organized Tables data access strategy and the Index Only Scan data access strategy should be used. I will describe the shortcomings of the binary search, and why in our case an ordered hash index will do. We will reach speeds of 0.15 to 3.6 million requests per second on a single Core i5 K750 core, and then we will show how this is implemented in a multi-threaded version with weak competitive access and rare changes. We will speed up this search on the GPU and show why the future is behind a multithreaded pattern - distributed states, with one memory barrier per group of records. Then come close to the search task in a high-load web project and compare its implementation using FastCGI and boost :: asio.But not all at once.</font></font></div><p>Source: <a href="https://habr.com/ru/post/182428/">https://habr.com/ru/post/182428/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../182412/index.html">NASA moves Mars to Russia</a></li>
<li><a href="../182414/index.html">Diablo III will be released for PS3 and Xbox 360 in September</a></li>
<li><a href="../182416/index.html">Hetzner reported detecting backdoor in their systems</a></li>
<li><a href="../182422/index.html">Swivl is a personal robot operator. Made by KickStarter</a></li>
<li><a href="../182424/index.html">Escaping (or what you need to know to work with text in the text)</a></li>
<li><a href="../182430/index.html">Nuances of using APIs from AddThis and Ya.share</a></li>
<li><a href="../182432/index.html">Programming, fast and slow: the developers and the psychology of self-confidence</a></li>
<li><a href="../182434/index.html">Physicists have learned how to lose in diffraction pockets up to 46% of traffic</a></li>
<li><a href="../182438/index.html">Customize standard IOS icons without JailBreak</a></li>
<li><a href="../182440/index.html">Computex 2013: Cover InkCase with a second screen on the E Ink</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>