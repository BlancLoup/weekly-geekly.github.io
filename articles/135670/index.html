<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>D2 language and metaprogramming: everything is stranger and stranger</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not long ago, Monnoroch published some excellent introductory articles on the D2 language, and that was good. But, having read the last article devote...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>D2 language and metaprogramming: everything is stranger and stranger</h1><div class="post__text post__text-html js-mediator-article">  Not long ago, <a href="http://habrahabr.ru/users/monnoroch/" class="user_link">Monnoroch</a> published some excellent introductory articles on the D2 language, and that was good.  But, having read the last <a href="http://habrahabr.ru/blogs/programming/135248/">article</a> devoted to metaprogramming, I wanted to do even better and open the topic in a bit more detail.  The devil, as we know, is in the details - and it is precisely the attention to detail that makes the implementation of the meta-paradigm in D2 so convenient.  If you have not read the <a href="http://habrahabr.ru/blogs/programming/135248/">article</a> <a href="http://habrahabr.ru/users/monnoroch/" class="user_link">Monnoroch</a> , I recommend first to get acquainted with it, because  In this framework, I would not like to spend time on basic things. <br><br>  So, if you already know some of the features of templates in D2, I would like to tell you more about what accompanies them - the tools of static introspection, the nuances of CTFE, and even such a forbidden but attractive thing as mixin. <br><br>  The goal is more visual code examples with comments and fewer words. <br><a name="habracut"></a><br><h4>  Introspection tools </h4><br><h5>  <i>is</i> expression </h5><br>  <i>is</i> is the main tool for getting a boolean value at compile time.  Its name was chosen, perhaps, not too successfully and can be misleading - in fact, it <i>is</i> responsible for all sorts of comparisons and type checking.  Take a look at this little program: <br><pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> main() { //     <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( !<span class="hljs-keyword"><span class="hljs-keyword">is</span></span>(garbage[id]) ); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( !<span class="hljs-keyword"><span class="hljs-keyword">is</span></span>(x) ); <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>(x) ); //     <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>(x : long) ); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( !<span class="hljs-keyword"><span class="hljs-keyword">is</span></span>( x : string ) ); //     <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>( x == <span class="hljs-type"><span class="hljs-type">int</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( !<span class="hljs-keyword"><span class="hljs-keyword">is</span></span>( x == long) ); //    + pattern matching + <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> declaration <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> long[<span class="hljs-type"><span class="hljs-type">char</span></span>[]] AA; static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>( AA T : T[U], U : const <span class="hljs-type"><span class="hljs-type">char</span></span>[]) ) <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> T key; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> key; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>(key == long) ); }</code> </pre> <br>  The last example is especially interesting - <i>is</i> used simultaneously to <br><ul><li>  check the type reducibility to an associative container storing <i>const char []</i> </li><li>  on pattern to isolate the type of the key from the container type </li><li>  create alias for the nested scope </li></ul><br>  However, much more often you will see <i>is</i> in the context of <i>is (typeof (...))</i> .  Speaking of <i>typeof</i> : 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  <i>typeof</i> expression </h5><br>  <i>typeof is</i> very simple - takes an expression as an argument, returns its type if the expression is semantically correct.  If not, it gives a compile-time error.  But in combination with is, a slightly non-obvious effect is obtained - the expression inside typeof does not compile as such, since  is only checks the validity of the type, and all error messages are suppressed.  It turns out a stable idiom D2 to check the semantic correctness of an arbitrary expression at the compilation stage.  Something similar was assumed constraints, and not included in the standard C ++ 11. <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> func(); <span class="hljs-type"><span class="hljs-type">void</span></span> main() { //  ,     <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> typeof(func()) ret_type; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>( ret_type == <span class="hljs-type"><span class="hljs-type">int</span></span> ) ); <span class="hljs-type"><span class="hljs-type">double</span></span> func_prim() { //  ,       <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>( typeof(<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>) == <span class="hljs-type"><span class="hljs-type">double</span></span> ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } //    <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> "      &lt;" <span class="hljs-type"><span class="hljs-type">void</span></span> template_func(T)( T t ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>(typeof( T.init &lt; T.init )) ) { } template_func(<span class="hljs-number"><span class="hljs-number">20</span></span>); // struct S {} // template_func(S.init); // error }</code> </pre> <br><h5>  traits / std.traits </h5><br>  All that was said above is very, very nice, but if we are going to write good, beautiful libraries using template constraints, then it would be nice to have a more extensive toolkit for understanding what a certain type of data is.  And it is in two whole copies: <br>  <a href="http://d-programming-language.org/traits">Traits</a> - a set of directives to the compiler for type integration.  Here are some examples: <br><pre> <code class="hljs pgsql">abstract <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> C { } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> B { <span class="hljs-type"><span class="hljs-type">int</span></span> a; } <span class="hljs-type"><span class="hljs-type">void</span></span> main() { <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( __traits(isAbstractClass, C ) ); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(! __traits(isAbstractClass, B ) ); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(! __traits(isAbstractClass, <span class="hljs-type"><span class="hljs-type">int</span></span> ) ); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( __traits(hasMember, B, "a") ); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( !__traits(hasMember, C, "a") ); // offtopic:      [ ] - allMembers   ,         auto a = [ __traits(allMembers, B) ]; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( a == ["a", "toString", "toHash", "opCmp", "opEquals", "Monitor", "factory"] ); }</code> </pre> <br>  <a href="http://d-programming-language.org/phobos/std_traits.html">std.traits</a> is a module of a standard library for similar purposes, written using the previously mentioned tools.  Some utilitarian functions are very interesting, for example, mangledName: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.traits; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.stdio; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> ( C ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// _D9stdtraits5func1FZv writeln( mangledName!(func1) ); // func2 writeln( mangledName!(func2) ); }</span></span></code> </pre> <br><br><h5>  type tuples </h5><br>  D2 can create tuples of both values ‚Äã‚Äãand types, but we, of course, are primarily interested in the latter.  The reason why I mention tuples in the context of instrospecting tools is a special compiler support that allows you to use tuples obtained using the same <i>std.traits</i> for further compilation. <br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.typetuple; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.traits; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.stdio; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     void func1( int, double, string ) { } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      <span class="hljs-string"><span class="hljs-string">" "</span></span> alias TypeTuple!( int, double, string ) tp_same; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,     ,   func1! void func2( tp_same tp ) { assert( <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(tp[<span class="hljs-number"><span class="hljs-number">0</span></span>]) == int ) ); assert( <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(tp[<span class="hljs-number"><span class="hljs-number">1</span></span>]) == double ) ); assert( <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(tp[<span class="hljs-number"><span class="hljs-number">2</span></span>]) == string ) ); } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ,     ? alias ParameterTypeTuple!(func1) tp_func1_copy; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ...      . void func3( tp_func1_copy tp ) { foreach( i; tp) { writeln(typeid( <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(i) ), <span class="hljs-string"><span class="hljs-string">" "</span></span>, i); } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> : <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> int <span class="hljs-number"><span class="hljs-number">2</span></span> // double <span class="hljs-number"><span class="hljs-number">2</span></span> // immutable(char)[] <span class="hljs-number"><span class="hljs-number">2</span></span> } void main() { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        func1( <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-string"><span class="hljs-string">"2"</span></span>); func2( <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-string"><span class="hljs-string">"2"</span></span>); func3( <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-string"><span class="hljs-string">"2"</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ! assert( <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(func1) == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(func2) ) ); assert( <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(func2) == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(func3) ) ); }</code> </pre> <br>  This may not seem very impressive, but you should not forget that you can perform any actions on compile-time over a type tuple, creating different signatures for functions in different conditions, conveniently manipulating functions / templates with a variable number of arguments and indulging in other excesses. <br><br><h4>  CTFE Unleashed </h4><br>  <i>CTFE</i> (Compile-Time Field Evaluation) is a topic that is very easy to describe briefly and immense if you try to consider all the details.  The fact that some functions / expressions can be calculated at compile time is not a new concept and is quite familiar to the same C ++ programmers.  What is unusual is that there are so few restrictions on the performance of CTFE functions in D2.  Here is a description from the official documentation: <br><ul><li>  Must have source code fully accessible to the compiler (no extern) </li><li>  Should not refer to global or static variables. </li><li>  Should not use inline asm </li><li>  Non-portable type conversions (for example, int [] to float []), including conversions dependent on byte order, are prohibited.  Conversions between signed and unsigned numbers are allowed.  Conversion of pointers to data and vice versa is prohibited. </li><li>  Actions with pointers are allowed only for pointers to array elements. </li><li>  assert and others like him do not create an exception, but simply stop interpreting </li></ul><br>  Strictly speaking, everything.  Loops, dynamic memory allocation, work with strings, associative arrays are all allowed during compilation.  Here, for example, is the solution for a typical problem of prediscounting a table of square roots for a previously known range of integers: <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.math; enum PrecomputedSqrtIndex { Min = <span class="hljs-number"><span class="hljs-number">1</span></span>, Max = <span class="hljs-number"><span class="hljs-number">10</span></span> } // pure, nothrow  <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> , ,  ,         :) pure nothrow <span class="hljs-type"><span class="hljs-type">double</span></span>[<span class="hljs-type"><span class="hljs-type">int</span></span>] precompute_sqrt_lookup( <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ) { <span class="hljs-type"><span class="hljs-type">double</span></span>[<span class="hljs-type"><span class="hljs-type">int</span></span>] result; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( i; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>..<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span> ) result[i] = sqrt(i); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } enum sqrt_lookup = precompute_sqrt_lookup( PrecomputedSqrtIndex.Min, PrecomputedSqrtIndex.Max ); <span class="hljs-type"><span class="hljs-type">void</span></span> main() { }</code> </pre> <br>  Alas, some restrictions are really neat, especially the first.  So, once, I was disappointed by the inability to convert double to string with the standard library ‚Äî it turned out that it was linked to the standard C library somewhere in the depths. But as we work on improving phobos and improving <i>CTFE</i> support in the compiler, the situation improves. - not so long ago associative arrays were included in the forbidden list.  And this is one of the areas of development of D2, on which work right now, if you look through commits on github. <br><br>  But what about <i>CTFE</i> in the context of True Metaprogramming?  I'll come back to them after I introduce you to mixin. <br><br><h4>  Mixin </h4><br><h5>  Template mixin </h5><br>  I'll start from afar, with a bit more approximate to the real conditions (but still contrived) example.  Suppose we have a number of classes that, deep in their private depths, store an associative array and, in addition, remember the order of adding elements.  There is a task - to add an interface to all these classes for iterating over the array elements in this order.  What can be done?  Multiple inheritance?  Copy-paste?  Interface inheritance and implementation class encapsulation?  Ah, no idea about aesthetics. <br><br>  To come to the aid of D2 come <i>template mixin</i> - a tool for "smart" copy-paste.  The substitution patterns are declared through the mixin template keywords (suddenly!) And look similar to any regular D2 pattern.  The interesting begins when a similar template is instantiated by the <i>mixin TemplateName! (Parameters)</i> directive - the resulting code is inserted into the context where mixin was applied. <br><br>  Here is a somewhat longer piece of code, which is already much more similar to what can be written in a real project: <br><pre> <code class="hljs perl">import std.range : isForwardRange; import std.stdio : writeln; import std.typecons : Tuple; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> mixin,      mixin template AddForwardRangeMethods( alias data_container, alias order_container ) // ,      data_container <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( is(typeof( data_container.length ) : <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ) &amp;&amp; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ...  order_container     data_container is(typeof( data_container[ order_container[<span class="hljs-number"><span class="hljs-number">0</span></span>] ] )) //    - ,     - :) ) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ..             ,  //         . private struct Result { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       private <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> last_index; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    -   ,    //     typeof(data_container) ref_data; typeof(order_container) ref_order; alias typeof(order_container[<span class="hljs-number"><span class="hljs-number">0</span></span>]) Key_t; static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( is( typeof(data_container) T : T[U], U : Key_t ) ) { alias T Value_t; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static assert(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Wrong data_container / order_container data_container types"</span></span> ); this(typeof(data_container) data, typeof(order_container) order) { last_index = <span class="hljs-number"><span class="hljs-number">0</span></span>; ref_data = data; ref_order = order; } //  ,  forward range bool empty() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> last_index &gt;= ref_data.length; } Tuple!(Key_t, Value_t) popFront() { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    scope   , ,  //        scope (<span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>) last_index++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> front(); } Tuple!(Key_t, Value_t) front() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> typeof(<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>)( ref_order[last_index], ref_data[ref_order[last_index]] ); } Result save() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result( ref_data, ref_order ); } } public Result fwdRange() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result( data_container, order_container ); } } //  ,  mixin class A { private <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>] a; private <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] order; this() { a = [ <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> : <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> : <span class="hljs-number"><span class="hljs-number">9</span></span> ]; order = [ <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> ]; } //   ! mixin AddForwardRangeMethods!(a, order); } void main() { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    -    forward range,  duck typing assert(isForwardRange!(A.Result)); auto a = new A(); auto r = a.fwdRange; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( i; r ) writeln( i ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Tuple!(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) // Tuple!(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>) // Tuple!(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>) }</code> </pre> <br><br>  This approach may seem a bit monstrous, but think about it - this code declares a template ready for use through mixin in any of your classes where there are containers with suitable properties.  At the same time, there is a check that the conditions required from the class are actually fulfilled - and all this is exclusively on compile-time!  Any changes concerning the implementation of the forward range access to your classes will affect only this place, and the hierarchy of the main architecture will remain without unnecessary changes. <br><br><h6>  String mixin </h6><br>  And finally, we got to one of the most powerful and ambiguous features of D2 metaprogramming.  By entering this territory you lose most of the convenient error messages provided by the type system, and you are a step closer to the macro hell C - but your possibilities are almost endless. <br>  string mixin works in something like eval from scripting languages, its syntax is very simple: <br><pre> <code class="hljs lisp">mixin(<span class="hljs-string"><span class="hljs-string">"some string here"</span></span>)</code> </pre> <br>  ‚ÄúSome string here‚Äù will substitute mixin and will be compiled.  In this case, of course, it will not be, since hardly ‚Äúsome string here‚Äù will turn out to be a valid program code, but nothing prevents you from using a more useful string. <br><br>  ... for example the one that returns some CTFE-function.  In fact, you have the opportunity to define DSL and, having written the corresponding CTFE translator in the code on D2, use this DSL as strings directly in the D2 modules.  A good example is the standard library module std.range.  In one of the modes, he is able to generate the code of regular expression parsers at the compilation stage, based on the regularity string specified in the usual form.  It is for the authors of libraries, in my opinion, that this opportunity of D2 is of the greatest practical interest. <br><br>  In order not to clutter up an already overgrown article, I will cite a link to the funny trick of a certain Daniel Keep as a vivid example: <a href="http://www.prowiki.org/wiki4d/wiki.cgi%3FDanielKeep/shfmt">www.prowiki.org/wiki4d/wiki.cgi?DanielKeep/shfmt</a> <br>  Daniel yearned whenever possible in the style of PHP to do like this: <br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">3</span></span>; writeln(<span class="hljs-string"><span class="hljs-string">"a = $a"</span></span>);</code> </pre> <br>  ... and implemented it with the help of string mixin in D :) I warn you - listing by reference is dangerous for the eyes, and this, unfortunately, is for the time being the inevitable price for great features. <br>  If you have ever used the algorithm module from the Phobos standard library, the convenient short lambda format for map, reduce &amp; co also works in the end thanks to the magic string mixin. <br><br><h4>  Instead of an epilogue </h4><br>  Initially, I wanted to stop at every opportunity in more detail and analyze the various successful and undesirable methods of application.  But as I wrote, it turned out that the size of the article was growing at an indecent rate for something so richly flavored with code examples.  In the end, I tried to just give the broadest possible picture of the whole set of tools that D2 provides for metaprogramming.  If you at least once thought, ‚ÄúWow, and with the help of this you can do &lt;feature of my dream&gt;‚Äù, then the goal was accomplished. <br><br>  Often, newbies in D2 are simply lost from the abundance of opportunities to do anything at the compilation stage and these capabilities require considerable discipline in order to be useful and not turn your code into a mess.  So try to observe moderation in architectural temptations.  Enjoy your meal :) <br><br>  On typos and stylistic blunders, please report in private. <br><br>  All examples were tested on dmd version 2.057 </div><p>Source: <a href="https://habr.com/ru/post/135670/">https://habr.com/ru/post/135670/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../135662/index.html">Four sinister hexadecimal digits on error pages - and how to overcome them</a></li>
<li><a href="../135665/index.html">Teaching practice</a></li>
<li><a href="../135667/index.html">Usability Review Habra (wishes)</a></li>
<li><a href="../135668/index.html">Agile is simple</a></li>
<li><a href="../135669/index.html">New Year's zip quest 2012</a></li>
<li><a href="../135671/index.html">Digital HiNote VP TS30G</a></li>
<li><a href="../135672/index.html">Screensaver on J2ME or Back to the past. Part one</a></li>
<li><a href="../135673/index.html">"Kiev-20" - the flagship of Ukrainian photographic</a></li>
<li><a href="../135674/index.html">RIM tends to appoint new chairman</a></li>
<li><a href="../135675/index.html">VKontakte holds a tender for the creation of smiles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>