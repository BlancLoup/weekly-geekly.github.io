<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Notes on the Python object system part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The second part of the notes about the python object system (the first part is here ). This article tells you what classes are, metaclasses, type, obj...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Notes on the Python object system part 2</h1><div class="post__text post__text-html js-mediator-article">  The second part of the notes about the python object system (the first part is <a href="http://habrahabr.ru/blogs/python/114576/">here</a> ).  This article tells you what classes are, metaclasses, type, object, and how attributes are searched for in a class. <br><br><a name="habracut"></a><br><h4>  Classes </h4><br>  Classes (types) are object factories.  Their main task is to create objects with specific behavior. <br><br>  Classes define the behavior of objects using their attributes (which are stored in the __dict__ class): methods, properties, class variables, descriptors, as well as using attributes inherited from the parent classes. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The instantiation of a regular object occurs in 2 stages: first, its creation, then initialization.  Accordingly, the class __new__ class method is first launched, which returns an object of this class, then the class __init__ method is executed, which initializes the already created object. <br><br>  def __new __ (cls, ...) is a static method (but you can not declare it as such), which creates an object of class cls. <br><br>  def __init __ (self, ...) is a class method that initializes the created object. <br><br>  For example, declare a class: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>A</strong></font> ( <font color="#008000">object</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>pass</strong></font> <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000000">&gt;&gt;&gt;</font></code> <br> <br>  For class A, neither __new__ nor __init__ is defined.  In accordance with the attribute search algorithm for a class (type), which is not to be confused with the attribute search algorithm for ordinary objects, when the class does not find them in its __ dict__, it will look for these methods in __ ict __ <b>its</b> base (parent) classes. <br><br>  Class A has a built-in object class as a parent.  So he will look for them in object .__ dict__ <br><br>  And find: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">object</font> <font color="#666666">.</font> __dict__[ <font color="#BA2121">'__init__'</font> ] <br> <font color="#000000">&lt;slot wrapper '__init__' of 'object' objects&gt; <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">object</font> <font color="#666666">.</font> __dict__[ <font color="#BA2121">'__new__'</font> ] <br> <font color="#000000">&lt;built-in method __new__ of type object at 0x82e780&gt; <br> &gt;&gt;&gt;</font></code> <br> <br>  Since there are such methods, it means that a = A () is similar to a sequence of calls: <br><br>  a = object .__ new __ (A) <br>  object .__ init __ (a) <br><br>  In general, using super, which implements the attribute search algorithm for parent classes [1]: <br><br>  a = super (A, A) .__ new __ (A) <br>  super (A, A) .__ init __ (a) <br><br>  Example. <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>A</strong></font> ( <font color="#008000">object</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">__new__</font> (cls): <br> <font color="#000080"><strong>...</strong></font> obj <font color="#666666">=</font> <font color="#008000">super</font> (A, cls) <font color="#666666">.</font> __new__(cls) <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>print</strong></font> <font color="#BA2121">'created object'</font> , obj <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>return</strong></font> obj <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">__init__</font> ( <font color="#008000">self</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>print</strong></font> <font color="#BA2121">'initing object'</font> , <font color="#008000">self</font> <br> <font color="#000080"><strong>...</strong></font></code> <br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> A() <br> <font color="#000000">created object &lt;__main__.A object at 0x1620ed0&gt; <br> initing object &lt;__main__.A object at 0x1620ed0&gt; <br> &lt;__main__.A object at 0x1620ed0&gt; <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font></code> <br> <br><h4>  Singleton v.1 </h4><br>  Understanding how the object is created, you can write the implementation of the loner pattern. <br><br>  We need to ensure that the class has only one instance.  Those.  when calling a class constructor, always return the same instance of the class. <br><br>  And this means that when calling the __new__ method, the same object must be returned each time.  You can store the object itself, for example, in the instance class variable. <br><br>  The result is: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>C</strong></font> ( <font color="#008000">object</font> ): <br> <font color="#000080"><strong>...</strong></font> instance <font color="#666666">=</font> <font color="#008000">None</font> <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">__new__</font> (cls): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>if</strong></font> cls <font color="#666666">.</font> instance <font color="#AA22FF"><strong>is</strong></font> <font color="#008000">None</font> : <br> <font color="#000080"><strong>...</strong></font> cls <font color="#666666">.</font> instance <font color="#666666">=</font> <font color="#008000">super</font> (C, cls) <font color="#666666">.</font> __new__(cls) <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>return</strong></font> cls <font color="#666666">.</font> instance <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> C() <font color="#AA22FF"><strong>is</strong></font> C() <br> <font color="#000000">True <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> C() <font color="#666666">.</font> x <font color="#666666">=</font> <font color="#666666">1</font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> c <font color="#666666">=</font> C() <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> d <font color="#666666">=</font> C() <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> c <font color="#666666">.</font> x <br> <font color="#000000">1 <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> d <font color="#666666">.</font> x <br> <font color="#000000">1 <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> c <font color="#666666">.</font> x <font color="#666666">=2</font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> d <font color="#666666">.</font> x <br> <font color="#000000">2 <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> c <font color="#666666">.</font> x <br> <font color="#000000">2</font></code> <br> <br><h4>  Classes and metaclasses. </h4><br>  For a class (type), as well as for a regular object, there is a class (type) that creates classes and defines the behavior of the <b>class</b> .  This class is called a metaclass. <br><br>  Creating a class, just like an ordinary object, happens by calling the constructor, but since  There are several additional special attributes in the class that must be initialized, and the corresponding required parameters are passed to the constructor. <br><br>  XClass = XMetaClass (name, bases, attrs) <br><br>  Then, right after creation <br>  XClass .__ name__ equals name, <br>  XClass .__ bases__ equals bases, <br>  XClass .__ dict__ is equal to attrs, and <br>  XClass .__ class__ is equal to XMetaClass <br><br>  By default, for all classes defined, the metaclass is type. <br><br>  In this way. <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>A</strong></font> ( <font color="#008000">object</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>pass</strong></font> <br> <font color="#000080"><strong>...</strong></font></code> <br> <br>  Equivalently, by analogy with ordinary objects: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">type</font> ( <font color="#BA2121">'A'</font> , ( <font color="#008000">object</font> ,), {}) <br> <font color="#000000">&lt;class '__main__.A'&gt;</font></code> <br> <br>  And this: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>B</strong></font> (A): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">foo</font> ( <font color="#008000">self</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#666666">42</font> <br> <font color="#000080"><strong>...</strong></font></code> <br> <br>  is equivalent to <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">type</font> ( <font color="#BA2121">'B'</font> , (A,), { <font color="#BA2121">'foo'</font> : <font color="#008000"><strong>lambda</strong></font> <font color="#008000">self</font> : <font color="#666666">42</font> })</code> <br> <br>  When defining a class, you can define your metaclass with <br>  class variable __metaclass__: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>A</strong></font> ( <font color="#008000">object</font> ): <br> <font color="#000080"><strong>...</strong></font> __metaclass__ <font color="#666666">=</font> Meta <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000000">&gt;&gt;&gt;</font></code> <br> <br>  Which is equivalent: A = Meta ('A', (object,), {}) <br><br><h4>  About type and object </h4><br>  First of all, type and object are objects.  And, like all decent objects, they have special attributes __class__ and __dict__: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">object</font> <font color="#666666">.</font> __class__ <br> <font color="#000000">&lt;type 'type'&gt; <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">type</font> <font color="#666666">.</font> __class__ <br> <font color="#000000">&lt;type 'type'&gt;</font></code> <br> <br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">object</font> <font color="#666666">.</font> __dict__ <br> <font color="#000000">&lt;dictproxy object at 0x7f7797a1cf30&gt; <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">type</font> <font color="#666666">.</font> __dict__ <br> <font color="#000000">&lt;dictproxy object at 0x7f7797a1cfa0&gt;</font></code> <br> <br>  Moreover, object and type are objects of type (classes), and they also have special attributes __name__, __bases___: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">object</font> <font color="#666666">.</font> __name__ <br> <font color="#000000">'object' <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">type</font> <font color="#666666">.</font> __name__ <br> <font color="#000000">'type' <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">object</font> <font color="#666666">.</font> __bases__ <br> <font color="#000000">() <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">type</font> <font color="#666666">.</font> __bases__ <br> <font color="#000000">(&lt;type 'object'&gt;,) <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font></code> <br> <br>  Instances of the type or class object are objects (any).  Those.  any object is an instance of the object class: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">isinstance</font> ( <font color="#666666">1</font> , <font color="#008000">object</font> ) <br> <font color="#000000">True <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">isinstance</font> ( <font color="#008000">setattr</font> , <font color="#008000">object</font> ) <br> <font color="#000000">True <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">isinstance</font> ( <font color="#BA2121">"foo"</font> , <font color="#008000">object</font> ) <br> <font color="#000000">True <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">isinstance</font> (A, <font color="#008000">object</font> ) <br> <font color="#000000">True</font></code> <br> <br>  Even a function is an object: <br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">bar</font> (): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>pass</strong></font> <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">isinstance</font> (bar, <font color="#008000">object</font> ) <br> <font color="#000000">True</font></code> <br> <br>  In addition, the object class itself is its own instance: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">isinstance</font> ( <font color="#008000">object</font> , <font color="#008000">object</font> ) <br> <font color="#000000">True</font></code> <br> <br>  type is also an instance of it: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">isinstance</font> ( <font color="#008000">type</font> , <font color="#008000">object</font> ) <br> <font color="#000000">True</font></code> <br> <br>  Instantiation - object () returns the simplest and most common object: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> o <font color="#666666">=</font> <font color="#008000">object</font> ()</code> <br> <br>  Which even __dict__ is not, there is only __class__. <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> o <font color="#666666">.</font> __dict__ <br> <font color="#0040D0">Traceback (most recent call last): <br></font> File "&lt;stdin&gt;", line 1, in &lt;module&gt; <br> <font color="#000000">AttributeError: 'object' object has no attribute '__dict__' <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> o <font color="#666666">.</font> __class__ <br> <font color="#000000">&lt;type 'object'&gt; <br> &gt;&gt;&gt;</font></code> <br> <br>  Instances of a class or type type are just other classes or other types: <br><br>  The number is not a class <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">isinstance</font> ( <font color="#666666">1</font> , <font color="#008000">type</font> ) <br> <font color="#000000">False</font></code> <br> <br>  String too <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">isinstance</font> ( <font color="#BA2121">"foo"</font> , <font color="#008000">type</font> ) <br> <font color="#000000">False</font></code> <br> <br>  The built-in setattr function is also not a class. <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">isinstance</font> ( <font color="#008000">setattr</font> , <font color="#008000">type</font> ) <br> <font color="#000000">False</font></code> <br> <br>  A class is a class. <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">isinstance</font> (A, <font color="#008000">type</font> ) <br> <font color="#000000">True</font></code> <br> <br>  The row type is a class. <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">isinstance</font> ( <font color="#BA2121">"foo"</font> <font color="#666666">.</font> __class__, <font color="#008000">type</font> ) <br> <font color="#000000">True</font></code> <br> <br>  Because  object and type are also classes, they are instances of the type class: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">isinstance</font> ( <font color="#008000">object</font> , <font color="#008000">type</font> ) <br> <font color="#000000">True <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">isinstance</font> ( <font color="#008000">type</font> , <font color="#008000">type</font> ) <br> <font color="#000000">True <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font></code> <br> <br>  Because  the set of classes (types) are a subset of the set of objects, it is logical to assume that type is a subclass of object, i.e. <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">issubclass</font> ( <font color="#008000">type</font> , <font color="#008000">object</font> ) <br> <font color="#000000">True <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">issubclass</font> ( <font color="#008000">object</font> , <font color="#008000">type</font> ) <br> <font color="#000000">False</font></code> <br> <br>  type is just a class whose instances are other classes.  (i.e. metaclass).  And the classes themselves can be considered an extension of simple, ordinary objects. <br><br>  Thus, when we inherit a class from object, this class automatically inherits the behavior of the object class, i.e.  when instantiating, it will return a regular object.  And when we inherit from the type class, we also automatically inherit the behavior of the type class, i.e.  when installed, a class will be created.  And the class that creates the class is called the metaclass. <br><br>  So, to define just a class, you need to inherit it from object, to define a metaclass - we inherit it from type. <br><br>  And yet: do not confuse type (a) and type (name, bases, attrs). <br>  type (a) is a call with one argument, returns the type of the object, <br>  a type (name, bases, attrs) - a call with three arguments is a call to the class constructor. <br><br><h4>  About finding attributes in a class </h4><br>  As already noted, the algorithm for finding attributes in a regular object, but there are some subtleties, because  types (classes) have __bases__ - parent classes (types). <br><br>  If the attribute is in __dict__ it is returned, then the search for base classes from __bases__ takes place, and then there is an appeal to __dict__ __class __ 'a (that is, in fact, the metaclass) and its (metaclass) parent classes (metaclasses). <br><br>  A small example: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>Ameta</strong></font> ( <font color="#008000">type</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">foo</font> (cls): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>print</strong></font> <font color="#BA2121">'Ameta.foo'</font> <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>A</strong></font> ( <font color="#008000">object</font> ): <br> <font color="#000080"><strong>...</strong></font> __metaclass__ <font color="#666666">=</font> Ameta <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> A <font color="#666666">.</font> foo() <br> <font color="#000000">Ameta.foo</font></code> <br> <br>  All that is defined in the metaclass is available for the class, but not available for the class instance ‚Äî ordinary objects, since  Attribute search in a regular object is conducted only in class __dict__ dictionaries. <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> a <font color="#666666">=</font> A() <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> a <font color="#666666">.</font> foo <br> <font color="#0040D0">Traceback (most recent call last): <br></font> File <font color="#008000">"&lt;stdin&gt;"</font> , line <font color="#666666">1</font> , in &lt;module&gt; <br> <font color="#0000FF"><strong>AttributeError</strong></font> : 'A' object has no attribute 'foo'</code> <br> <br>  In A .__ dict__ 'foo' is not: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> A <font color="#666666">.</font> __dict__[ <font color="#BA2121">'foo'</font> ] <br> <font color="#0040D0">Traceback (most recent call last): <br></font> File <font color="#008000">"&lt;stdin&gt;"</font> , line <font color="#666666">1</font> , in &lt;module&gt; <br> <font color="#0000FF"><strong>KeyError</strong></font> : 'foo'</code> <br> <br>  But he is in the metaclass, therefore: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> A <font color="#666666">.</font> foo() <br> <font color="#000000">Ameta.foo</font> <br> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>B</strong></font> (A): <br> <font color="#000080"><strong>...</strong></font> <font color="#AA22FF">@classmethod</font> <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">foo</font> (cls): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>print</strong></font> <font color="#BA2121">'B.foo'</font> <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> B <font color="#666666">.</font> foo <font color="#408080"><em># .. foo  B.__dict__   B.__dict__['foo']</em></font> <br> <font color="#000000">&lt;bound method Ameta.foo of &lt;class '__main__.B'&gt;&gt; <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> B <font color="#666666">.</font> foo() <br> <font color="#000000">B.foo</font> <br> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>C</strong></font> (B): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>pass</strong></font> <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> C <font color="#666666">.</font> foo() <font color="#408080"><em>#      B.</em></font> <br> <font color="#000000">B.foo</font> <br> <br>   C    foo   B. <br> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> c <font color="#666666">=</font> C() <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> c <font color="#666666">.</font> foo() <br> <font color="#000000">B.foo <br> <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>D</strong></font> (A): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>pass</strong></font> <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> D <font color="#666666">.</font> foo() <br> <font color="#000000">Ameta.foo</font></code> <br> <br>  And instance D will not find: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> d <font color="#666666">=</font> D() <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> d <font color="#666666">.</font> foo() <br> <font color="#0040D0">Traceback (most recent call last): <br></font> File <font color="#008000">"&lt;stdin&gt;"</font> , line <font color="#666666">1</font> , in &lt;module&gt; <br> <font color="#0000FF"><strong>AttributeError</strong></font> : 'D' object has no attribute 'foo'</code> <br> <br><h4>  Metaclasses </h4><br>  Metaclasses are factories of classes (or types).  The instantiation of a class also takes place in 2 stages - the creation of an object of type (class) and its initialization.  This is also done using two metaclass methods.  First, the __new__ method of the metaclass is called with the parameters necessary to create a class - name, bases, attrs, and then __init__ with the same parameters and the class already created. <br><br>  Example. <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>Meta</strong></font> ( <font color="#008000">type</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>pass</strong></font> <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> Meta( <font color="#BA2121">'A'</font> , ( <font color="#008000">object</font> ,), {}) <br> <font color="#000000">&lt;class '__main__.A'&gt;</font></code> <br> <br>  At the beginning, the metaclass Meta searches for the __new__ method in its __dict__ dictionary, does not find it there, and begins to search in its parental classes __dict__ (i.e., metaclasses, in this case type), i.e.  there is a normal attribute search in the class.  As a result of the execution of __new__ with the appropriate parameters, it receives a new class, which is then initialized by calling the __init__ method of the metaclass. <br><br>  In a completely expanded form it turns out: <br><br>  cls = type .__ dict __ ['__ new __'] (Meta, 'A', (object,), {}) <br>  type .__ dict __ ['__ init __'] (cls, 'A', (object,), {}) <br><br>  Or using super <br><br>  cls = super (Meta, Meta) .__ new __ (Meta, 'A', (object,), {}) <br>  super (Meta, Meta) .__ init __ (cls, 'A', (object,), {}) <br><br>  It should be noted that, in contrast to instantiating ordinary objects, it is not the object .__ new__ and object .__ init__ that is used, but the type .__ new__ and type .__ init__.  Object .__ new__ and type .__ new__ have different signatures, and object .__ new__ returns a regular object (regular object), and type .__ new__ - an object of type (typeobject), i.e.  classroom <br><br>  Let's see how this all works on an example. <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>Meta</strong></font> ( <font color="#008000">type</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">__new__</font> (mcls, name, bases, attrs): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>print</strong></font> <font color="#BA2121">'creating new class'</font> , name <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>return</strong></font> <font color="#008000">super</font> (Meta, mcls) <font color="#666666">.</font> __new__(mcls, name, bases, attrs) <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">__init__</font> (cls, name, bases, attrs): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>print</strong></font> <font color="#BA2121">'initing new class'</font> , name <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>A</strong></font> ( <font color="#008000">object</font> ): <br> <font color="#000080"><strong>...</strong></font> __metaclass__ <font color="#666666">=</font> Meta <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000000">creating new class A <br> initing new class A</font></code> <br> <br>  During the instantiation of a simple object, no label is displayed. <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> a <font color="#666666">=</font> A() <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <br></code> <br>  In addition, respectively, in the methods __new__ and __init__ of the metaclass you can change everything: name, list of superclasses, attributes. <br><h4>  Links </h4><br><ul><li>  <a href="http://www.python.org/download/releases/2.2.3/descrintro/">Unifying types and classes in Python</a> is the main document explaining what, how and why in new classes. </li><li>  <a href="http://www.python.org/dev/peps/pep-0252/">Making Types Look More Like Classes</a> - PEP 252, describing the difference between the old classes and the new ones. </li><li>  <a href="http://docs.python.org/library/functions.html">Built-in functions</a> - a detailed description of the work of all built-in functions. </li><li>  <a href="http://docs.python.org/reference/datamodel.html">Data model</a> - a detailed description of the python data model. </li><li>  <a href="http://www.cafepy.com/article/python_types_and_objects/python_types_and_objects.html">Python types and objects</a> - an explanation of the python object model on simple examples with pictures. </li></ul><br><br><h4>  Notes </h4><br>  [1] For more information about super - <a href="http://docs.python.org/library/functions.html">here</a> . <br><br><h4>  Read more </h4><br>  <a href="http://habrahabr.ru/blogs/python/114587/">Notes on the Python object system part 3</a> </div><p>Source: <a href="https://habr.com/ru/post/114585/">https://habr.com/ru/post/114585/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../114579/index.html">Prospects for the development of central processing units</a></li>
<li><a href="../114580/index.html">A simple click of a button</a></li>
<li><a href="../114581/index.html">STOR.E ART4: with USB 3.0 and beyond</a></li>
<li><a href="../114582/index.html">Desire HD, Desire Z, Desire and Incredible S will get Gingerbread in the second quarter</a></li>
<li><a href="../114583/index.html">Microsoft has allowed employees to make money on applications for Windows Phone 7</a></li>
<li><a href="../114586/index.html">Meet AIR and Flash Player Incubator (including Molehill 3D APIs)</a></li>
<li><a href="../114587/index.html">Notes on the Python object system part 3</a></li>
<li><a href="../114588/index.html">History of C language</a></li>
<li><a href="../114589/index.html">Canny Boundary Detector</a></li>
<li><a href="../114590/index.html">Is DWG format or trademark?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>