<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Node.JS - form the resulting document using other HTTP sources</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Often, servers on Node.JS are used as aggregator services that receive dynamic data from other HTTP sources and form an aggregated response based on t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Node.JS - form the resulting document using other HTTP sources</h1><div class="post__text post__text-html js-mediator-article">  Often, servers on <a href="http://nodejs.org/">Node.JS</a> are used as aggregator services that receive dynamic data from other HTTP sources and form an aggregated response based on this data. <br><br>  For processing the data, it is convenient to use external processes that process the original set of files (for example, ImageMagick or ffmpeg utilities). <br><br>  Consider this on the example of an HTTP server that performs the backend role for the nginx server and generates CSS sprites for a set of images. <br><a name="habracut"></a><br><h4>  Asynchronous read / write </h4><br><h5>  Client Connection Pool </h5><br>  The HTTP client objects in Node.JS each work with one TCP connection, executing requests one by one, so we need to organize a pool of clients (a compromise between creating connections for each other and using one connection) if we want to work really fast ( parallel). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We will make the most primitive pool based on the assumption that we send all initial requests to <a href="http://example.com/">example.com</a> : 80. <br><br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">var</font> ClientPool = <font color="#0000ff">function</font> () <br> { <br> <font color="#0000ff">this</font> .poolSize = 0; <br> <font color="#0000ff">this</font> .freeClients = []; <br> }; <br> <br> ClientPool.prototype.needClient = <font color="#0000ff">function</font> () <br> { <br> <font color="#0000ff">this</font> .freeClients.push( <font color="#0000ff">this</font> .newClient()); <br> <font color="#0000ff">this</font> .poolSize++; <br> }; <br> <br> ClientPool.prototype.newClient = <font color="#0000ff">function</font> () <br> { <br> <font color="#0000ff">return</font> http.createClient(80, <font color="#A31515">'example.com'</font> ); <br> }; <br> <br> ClientPool.prototype.request = <font color="#0000ff">function</font> (method, url, headers) <br> { <br> <font color="#0000ff">if</font> ( <font color="#0000ff">this</font> .freeClients.length == 0) <br> { <br> <font color="#0000ff">this</font> .needClient(); <br> } <br> <font color="#0000ff">var</font> client = <font color="#0000ff">this</font> .freeClients.pop(); <br> <font color="#0000ff">var</font> req = client.request(method, url, headers); <br> <font color="#0000ff">return</font> req; <br> }; <br> <br> ClientPool.prototype.returnToPool = <font color="#0000ff">function</font> (client) <br> { <br> <font color="#0000ff">this</font> .freeClients.push(client); <br> }; <br> <br> <font color="#0000ff">var</font> clientPool = <font color="#0000ff">new</font> ClientPool(); <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  If you wish, you can change the architecture of the pool by allowing connections to several hosts, as well as restricting the size of the pool from above (while scattering requests over the least loaded connections).  I leave it as a homework. <br><br><h5>  Receiving and saving a file </h5><br>  We need an asynchronous function to execute HTTP requests and save the contents to a file.  Its peculiarity is that two streams of asynchronous operations are performed at once - reading the source HTTP stream, and writing to the file.  Moreover, we can successfully close the file and call the callback function only upon completion of all write operations that can be performed not necessarily sequentially. <br><br>  Here is an example implementation: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">var</font> getFile = <font color="#0000ff">function</font> (url, path, callback) <br> { <br> fs.open(path, <font color="#A31515">'w'</font> , 0600, <font color="#0000ff">function</font> (err, fd) <br> { <br> <font color="#0000ff">if</font> (err) <br> { <br> callback(err); <br> <font color="#0000ff">return</font> ; <br> } <br> <font color="#0000ff">var</font> request = clientPool.request( <font color="#A31515">'GET'</font> , url, { <font color="#A31515">'Host'</font> : <font color="#A31515">'example.com'</font> }); <br> request.on( <font color="#A31515">'response'</font> , <font color="#0000ff">function</font> (sourceResponse) <br> { <br> <font color="#0000ff">var</font> statusCode = parseInt(sourceResponse.statusCode); <br> <font color="#0000ff">if</font> (statusCode &lt; 200 || statusCode &gt; 299) <br> { <br> sourceResponse.on( <font color="#A31515">'end'</font> , <font color="#0000ff">function</font> () <br> { <br> clientPool.returnToPool(sourceResponse.client); <br> }); <br> callback( <font color="#A31515">'Bad status code'</font> ); <br> <font color="#0000ff">return</font> ; <br> } <br> <br> <font color="#0000ff">var</font> writeErr = <font color="#0000ff">null</font> ; <br> <font color="#0000ff">var</font> writesPending = 0; <br> <font color="#0000ff">var</font> sourceEnded = <font color="#0000ff">false</font> ; <br> <br> <font color="#0000ff">var</font> checkPendingCallback = <font color="#0000ff">function</font> () <br> { <br> <font color="#0000ff">if</font> (!sourceEnded || writesPending &gt; 0) <br> { <br> <font color="#0000ff">return</font> ; <br> } <br> fs.close(fd, <font color="#0000ff">function</font> (err) <br> { <br> err = err ? err : writeErr; <br> <font color="#0000ff">if</font> (err) <br> { <br> removeFile(path); <br> callback(err); <br> <font color="#0000ff">return</font> ; <br> } <br> <font color="#008000">// No errors and all written</font> <br> callback( <font color="#0000ff">null</font> ); <br> }); <br> }; <br> <br> <font color="#0000ff">var</font> position = 0; <br> sourceResponse.on( <font color="#A31515">'data'</font> , <font color="#0000ff">function</font> (chunk) <br> { <br> writesPending++; <br> fs.write(fd, chunk, 0, chunk.length, position, <font color="#0000ff">function</font> (err, written) <br> { <br> writesPending--; <br> <font color="#0000ff">if</font> (err) <br> { <br> writeErr = err; <br> } <br> checkPendingCallback(); <br> }); <br> position += chunk.length; <br> }); <br> <br> sourceResponse.on( <font color="#A31515">'end'</font> , <font color="#0000ff">function</font> () <br> { <br> sourceEnded = <font color="#0000ff">true</font> ; <br> checkPendingCallback(); <br> clientPool.returnToPool(sourceResponse.client); <br> }); <br> }); <br> request.end(); <br> }); <br> };</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br><h4>  The mechanism of interaction between nginx and our server </h4><br><br>  In order not to generate sprites for each request, we will save the output sprites, removing the oldest of them, for example, by crown.  If the file already exists, nginx will give it away using the try_files rule.  Otherwise, the request will be redirected to our backend, which will create the necessary file, and using X-Accel-Redirect will ask nginx to give the file from the internal location, which leads to the same physical space. <br><br>  In this case, the nginx configuration will look like this somewhere: <br><blockquote><pre>     upstream sprite_gen {
         server 127.0.0.1:14239;
     }

     location / out_folder / {
         alias / var / sprite-gen / out_folder /;
         internal;
     }

     location / {
         alias / var / sprite-gen / out_folder /;
         try_files $ uri @transcoder;
     }

     location @transcoder {
         proxy_pass http: // sprite_gen;
     }
</pre></blockquote><br><br>  This example does not pretend to be perfect, with its help it is good to give out large files, including in parts, with caching. <br><br>  If the files are small and it is desirable for us to better control the regeneration of sprites with missing pictures, then it is better to cache on the nginx side with a rule like proxy_no_cache $ http_pragma. <br><br><h4>  We get several files </h4><br><br>  Here is a fragment of the HTTP server responsible for getting the set of files, forming the sprite and returning the result to nginx. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">var</font> outPath = <font color="#A31515">''</font> ; <font color="#008000">//    </font> <br> <font color="#0000ff">var</font> imageUrls = []; <font color="#008000">//      .</font> <br> <font color="#0000ff">var</font> images  = []; <font color="#008000">//      .</font> <br> <br> <font color="#0000ff">var</font> waitCounter = images.length; <br> <font color="#0000ff">var</font> needCache  = <font color="#0000ff">true</font> ; <font color="#008000">//     ,   ,   </font> <br> <font color="#0000ff">var</font> handlePart = <font color="#0000ff">function</font> (url, pth) <br> { <br> getFile(url, pth, <font color="#0000ff">function</font> (err) <br> { <br> waitCounter--; <br> <font color="#0000ff">if</font> (err) <br> { <br> removeFile(pth); <br> <font color="#0000ff">var</font> pth = placeholder_path; <br> needCache = <font color="#0000ff">false</font> ; <br> } <br> <font color="#0000ff">if</font> (waitCounter == 0) <br> { <br> makeSprite(images, outPath, <font color="#0000ff">function</font> (err) <br> { <br> <font color="#0000ff">if</font> (err) <br> { <br> response.writeHead(500, { <br> <font color="#A31515">'Content-Type'</font> : <font color="#A31515">'text/plain'</font> , <br> }); <br> response.end( <font color="#A31515">'Trouble'</font> ); <br> <font color="#0000ff">return</font> ; <br> } <br> <font color="#0000ff">var</font> headers = { <br> <font color="#A31515">'Content-Type'</font> : <font color="#A31515">'image/png'</font> , <br> <font color="#A31515">'X-Accel-Redirect'</font> : outUrl <br> }; <br> <font color="#0000ff">if</font> (needCache) <br> { <br> headers[ <font color="#A31515">'Cache-Control'</font> ] = <font color="#A31515">'max-age:315360000, public'</font> ; <br> headers[ <font color="#A31515">'Expires'</font> ] = <font color="#A31515">'Thu, 31 Dec 2037 23:55:55 GMT'</font> ; <br> } <br> <font color="#0000ff">else</font> <br> { <br> headers[ <font color="#A31515">'Cache-Control'</font> ] = <font color="#A31515">'no-cache, no-store'</font> ; <br> headers[ <font color="#A31515">'Pragma'</font> ] = <font color="#A31515">'no-cache'</font> ; <br> } <br> response.writeHead(200, headers); <br> response.end(); <br> }); <br> } <br> }); <br> }; <br> <br> <font color="#0000ff">for</font> ( <font color="#0000ff">var</font> i = 0; i &lt; imageUrls.length) <br> { <br> handlePart(imageUrls[i], images[i]); <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br><h4>  We form the output file through an external process </h4><br>  Controlling external processes with Node.JS is easy and convenient.  For convenience of debugging, we will copy the output generated by the external process into our console.  To form a sprite, choose GraphicsMagick (ImageMagick fork, with a stable API and good performance). <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">var</font> spriteScript = <font color="#A31515">'/usr/bin/gm'</font> ; <br> <font color="#0000ff">var</font> placeholder = path.join(__dirname, <font color="#A31515">'placeholder.jpg'</font> ); <br> <br> <font color="#0000ff">var</font> getParams = <font color="#0000ff">function</font> (count) <br> { <br> <font color="#0000ff">return</font> ( <font color="#A31515">'montage +frame +shadow +label -background #000000 -tile '</font> + count + <font color="#A31515">'x1 -geometry +0+0'</font> ).split( <font color="#A31515">' '</font> ); <br> }; <br> <br> <font color="#0000ff">var</font> removeFile = <font color="#0000ff">function</font> (path) <br> { <br> fs.unlink(path, <font color="#0000ff">function</font> (err) <br> { <br> <font color="#0000ff">if</font> (err) <br> { <br> console.log( <font color="#A31515">'Cannot remove '</font> + path); <br> } <br> }); <br> }; <br> <br> <font color="#0000ff">var</font> cleanup = <font color="#0000ff">function</font> (inPaths, placeholder) <br> { <br> <font color="#0000ff">for</font> ( <font color="#0000ff">var</font> i = 0; i &lt; inPaths.length; i++) <br> { <br> <font color="#0000ff">if</font> (inPaths[i] == placeholder) <br> { <br> <font color="#0000ff">continue</font> ; <br> } <br> removeFile(inPaths[i]); <br> } <br> }; <br> <br> <font color="#0000ff">var</font> makeSprite = <font color="#0000ff">function</font> (inPaths, outPath, placeholder, callback) <br> { <br> <font color="#0000ff">var</font> para   = getParams(inPaths.length).concat(inPaths, outPath); <br> console.log([ <font color="#A31515">'run'</font> , spriteScript, para.join( <font color="#A31515">' '</font> )].join( <font color="#A31515">' '</font> )); <br> <font color="#0000ff">var</font> spriter = child_process.spawn(spriteScript, para); <br> <br> spriter.stderr.addListener( <font color="#A31515">'data'</font> , <font color="#0000ff">function</font> (data) <br> { <br> console.log(data); <br> }); <br> spriter.stdout.addListener( <font color="#A31515">'data'</font> , <font color="#0000ff">function</font> (data) <br> { <br> console.log(data); <br> }); <br> spriter.addListener( <font color="#A31515">'exit'</font> , <font color="#0000ff">function</font> (code, signal) <br> { <br> <font color="#0000ff">if</font> (signal != <font color="#0000ff">null</font> ) <br> { <br> callback( <font color="#A31515">'Internal Server Error - Interrupted by signal'</font> + signal.toString()); <br> <font color="#0000ff">return</font> ; <br> } <br> <font color="#0000ff">if</font> (code != 0) <br> { <br> callback( <font color="#A31515">'Internal Server Error - Code is '</font> + code.toString()); <br> <font color="#0000ff">return</font> ; <br> } <br> cleanup(inPaths, placeholder); <br> callback( <font color="#0000ff">null</font> ); <br> }); <br> }; <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br><h4>  Small nuances </h4><br><h5>  Form the name for the temporary file. </h5><br>  To generate the file name, it is better to use Process.pid and a query counter (for example, as path.join ('/ tmp', ['source-file', Process.pid, requestCounter] .join ('-')). At that, the function request processing should receive the request counter as an argument, since the processing of the next request can start before all the steps of the current request are executed. <br><br><h5>  Clean temporary data from past processes </h5><br>  Let all of our temporary files be named source-pid ... or sprite-pid- ...: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">var</font> fileExpr   = /^(?:source|sprite)\-(\d+)\b/; <br> <font color="#0000ff">var</font> storagePath = <font color="#A31515">'/tmp/'</font> ; <br> <br> <font color="#0000ff">var</font> cleanupOldFiles = <font color="#0000ff">function</font> () <br> { <br> fs.readdir(storagePath, <font color="#0000ff">function</font> (err, files) <br> { <br> <font color="#0000ff">if</font> (err) <br> { <br> console.log( <font color="#A31515">'Cannot read '</font> + storagePath + <font color="#A31515">' directory.'</font> ; <br> <font color="#0000ff">return</font> ; <br> } <br> <font color="#0000ff">for</font> ( <font color="#0000ff">var</font> i = 0; i &lt; files.length; i++) <br> { <br> <font color="#0000ff">var</font> fn = files[i]; <br> m = fileExpr.exec(fn); <br> <font color="#0000ff">if</font> (!m) <br> { <br> <font color="#0000ff">continue</font> ; <br> } <br> <font color="#0000ff">var</font> pid = parseInt(m[1]); <br> <font color="#0000ff">if</font> (pid == process.pid) <br> { <br> <font color="#0000ff">continue</font> ; <br> } <br> removeFile(path.join(storagePath, fn)); <br> } <br> }); <br> }; <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br><h5>  Request skeleton </h5><br><br>  Suppose we want to get a sprite on a photo album from a certain point in time (timespec). <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">#!/usr/bin/env node <br> <br> <font color="#0000ff">var</font> child_process = require( <font color="#A31515">'child_process'</font> ); <br> <font color="#0000ff">var</font> http     = require( <font color="#A31515">'http'</font> ); <br> <font color="#0000ff">var</font> path     = require( <font color="#A31515">'path'</font> ); <br> <font color="#0000ff">var</font> fs      = require( <font color="#A31515">'fs'</font> ); <br> <br> <font color="#0000ff">var</font> routeExpr   = /^\/?(\w)\/([^\/]+)\/(\d+)\/(\d+)x(\d+)\.png$/; <br> <font color="#0000ff">var</font> fileCounter = 0; <br> <br> http.createServer( <font color="#0000ff">function</font> (request, response) <br> { <br> <font color="#0000ff">if</font> (request.method != <font color="#A31515">'GET'</font> ) <br> { <br> response.writeHead(405, { <font color="#A31515">'Content-Type'</font> : <font color="#A31515">'text/plain'</font> }); <br> response.end( <font color="#A31515">'Method Not Allowed'</font> ); <br> <font color="#0000ff">return</font> ; <br> } <br> <font color="#0000ff">var</font> m = routeExpr.exec(request.url); <br> <font color="#0000ff">if</font> (!m) <br> { <br> response.writeHead(400, { <font color="#A31515">'Content-Type'</font> : <font color="#A31515">'text/plain'</font> }); <br> response.end( <font color="#A31515">'Bad Request'</font> ); <br> <font color="#0000ff">return</font> ; <br> } <br> <br> <font color="#0000ff">var</font> mode   = m[1]; <br> <font color="#0000ff">var</font> chapter = m[2]; <br> <font color="#0000ff">var</font> timespec = parseInt(m[3]); <br> <font color="#0000ff">var</font> width  = parseInt(m[4]); <br> <font color="#0000ff">var</font> height  = parseInt(m[5]); <br> <br> fileCounter++; <br> <font color="#0000ff">var</font> moments = [timespec]; <br> addWantedMoments(moments, mode) <br> <br> <font color="#0000ff">var</font> runner = <font color="#0000ff">function</font> (moments, fileCounter, width, height) <br> { <br> <font color="#0000ff">var</font> waitCounter = moments.length; <br> <font color="#0000ff">var</font> outPath   = path.join(storagePath, [ <font color="#A31515">'sprite'</font> , process.pid, fileCounter].join( <font color="#A31515">'-'</font> ) + <font color="#A31515">'.png'</font> ); <br> <font color="#0000ff">var</font> needCache  = <font color="#0000ff">true</font> ; <br> <br> <font color="#0000ff">for</font> ( <font color="#0000ff">var</font> i = 0; i &lt; moments.length; i++) <br> { <br> handlePart(i, placeholder); <br> } <br> }; <br> request.connection.setTimeout(0); <br> runner([].concat(moments), fileCounter, width, height); <br> <br> }).listen(8080, <font color="#A31515">'127.0.0.1'</font> ); <br> <br> console.log( <font color="#A31515">'Server running at 127.0.0.1:8080'</font> ); <br> <br> cleanupOldFiles(); <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  Actually, now we have a ready-made application that generates a sprite, as an aggregated result of a set of requests to other sites. <br><br>  It remains to add specifics (algorithms for obtaining links to source images, formation of placeholders, if the sizes are constantly changing), and this can be used. <br><br>  Actually, one of my mini-applications performs the role of a dynamic generator of sprites. <br><br><ul><li>  <b>Node.JS - form the resulting document using other HTTP sources</b> </li><li>  <a href="http://habrahabr.ru/blogs/javasccript/102717/">Node.JS - Fundamentals of Asynchronous Programming, Part 1</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/102722/">https://habr.com/ru/post/102722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../102714/index.html">Anti-Service Center Servicephone</a></li>
<li><a href="../102715/index.html">The lack of copyright contributed to the technological revolution in 19th century Germany</a></li>
<li><a href="../102716/index.html">Conflictology: How to criticize and accept criticism</a></li>
<li><a href="../102717/index.html">Node.JS - Fundamentals of Asynchronous Programming, Part 1</a></li>
<li><a href="../102720/index.html">xCSS: we invent our own CSS specification. Part 1</a></li>
<li><a href="../102725/index.html">Pochtofon: MFP per million</a></li>
<li><a href="../102728/index.html">GLONASS-GPS Navigator Presentation for Lada Cars</a></li>
<li><a href="../102729/index.html">About stereotypes</a></li>
<li><a href="../102733/index.html">Self-motivated team</a></li>
<li><a href="../102734/index.html">Presented color e-book</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>