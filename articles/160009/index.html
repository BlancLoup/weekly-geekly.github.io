<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>O Boost Multi-index Containers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I want to introduce or even remind of such a wonderful Boost module as multi_index_container. We all know and intensively use standard STL classes for...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>O Boost Multi-index Containers</h1><div class="post__text post__text-html js-mediator-article">  I want to introduce or even remind of such a wonderful Boost module as multi_index_container.  We all know and intensively use standard STL classes for storing and accessing data as lists, vectors, maps ?, hashes.  A lot has been said about them and all the features of their applications have been investigated. <br><br>  Everything gets complicated when there is a need for a class for storing and accessing objects by more than one key or their combinations.  Usually, starting with creating two maps or hashes, then as their number grows, everything becomes more complicated and complicated code sections arise to synchronize these hashes, inserts, deletes and renames plus it becomes quite difficult to understand the cost of a particular operation.  And of course the creation of such bikes leads to a lot of bugs, the need for optimizations and so on. <br><br>  Of course, everything is already invented before us and in the Boost library there is already a module for solving these problems - boost :: multi_index.  A huge advantage is speed, multi_index is very fast.  However, the documentation of this module is difficult to understand, for example, and newbies try to bypass this module.  And of course, you can separately tell about compiler messages in case of errors when working with multi_index_container - to disassemble a long message about templates not everyone can do. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We will try to eliminate this gap and show simple examples for a hot start and use of this powerful tool.  I will use a little along with Qt in the examples.  (Just in Qt with their own template system, I often lack a primitive comparable to multi_index) <br><a name="habracut"></a><br><br>  Suppose we have a small structure with fields: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rec</span></span></span><span class="hljs-class"> {</span></span> QString name, phone, addr; };</code> </pre> <br>  multi_index provides a very convenient way to use tags / (tags in the Russian dock) for keys. <br>  We define them directly in Rec so that we don‚Äôt crawl along the code: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rec</span></span></span><span class="hljs-class"> {</span></span> QString name, phone, addr; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByName</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByPhone</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByAddr</span></span></span><span class="hljs-class"> {</span></span>}; };</code> </pre> <br>  We can create the following array: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::multi_index_container&lt;Rec, indexed_by&lt; ordered_unique&lt; tag&lt;Rec::ByName&gt;, member&lt;Rec,QString,&amp;Rec::name&gt; &gt;, ordered_non_unique&lt; tag&lt;Rec::ByPhone&gt;, member&lt;Rec,QString,&amp;Rec::phone&gt; &gt;, ordered_non_unique&lt; tag&lt;Rec::ByAddr&gt;, member&lt;Rec,QString,&amp;Rec::addr&gt; &gt; &gt; &gt; Store;</code> </pre> <br>  We accept that our records are unique by name (name), but non-unique by address and telephone.  The uniqueness of the name is also in the fact that we can not add to the array two records with the same name. <br><pre> <code class="cpp hljs">{ Store store; Rec r1 = { <span class="hljs-string"><span class="hljs-string">"Basilio Pupkinio"</span></span>, <span class="hljs-string"><span class="hljs-string">"022"</span></span>, <span class="hljs-string"><span class="hljs-string">"Neron st"</span></span> }; qDebug() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ok1"</span></span> &lt;&lt; store.insert(r1).second; <span class="hljs-comment"><span class="hljs-comment">// ok1 true qDebug() &lt;&lt; "ok2" &lt;&lt; store.insert(r1).second; // ok2 false }</span></span></code> </pre> <br>  For me, this is an important convenience that the array itself will not allow the appearance of duplicates, and when accessing it I can rely on the content a priori. <br><br>  Find a record by name: <br><pre> <code class="cpp hljs">{ QString find_id = <span class="hljs-string"><span class="hljs-string">"Basilio Pupkinio"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Store::index&lt;Rec::ByName&gt;::type List; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> List &amp; ls = store.get&lt;Rec::ByName&gt;(); List::const_iterator it = ls.find(find_id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( it != ls.end() ) { qDebug() &lt;&lt; (*it).addr; <span class="hljs-comment"><span class="hljs-comment">// "Neron st" } }</span></span></code> </pre> <br>  If we have several entries with the phone 022 <br><pre> <code class="cpp hljs">{ Store store; Rec r1 = { <span class="hljs-string"><span class="hljs-string">"Basilio Pupkinio"</span></span>, <span class="hljs-string"><span class="hljs-string">"022"</span></span>, <span class="hljs-string"><span class="hljs-string">"Pushkina st"</span></span> }; Rec r2 = { <span class="hljs-string"><span class="hljs-string">"Vasya Pupkin"</span></span>, <span class="hljs-string"><span class="hljs-string">"022"</span></span>, <span class="hljs-string"><span class="hljs-string">"Around st"</span></span> }; store.insert(r1) store.insert(r2) }</code> </pre> <br>  Then find all the entries with the phone 022 <br><pre> <code class="cpp hljs">{ QString find_phone = <span class="hljs-string"><span class="hljs-string">"022"</span></span>; Store::index&lt;Rec::ByPhone&gt;::type::iterator it0, it1; tie(it0,it1) = store.get&lt;Rec::ByPhone&gt;().equal_range(find_phone); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(it0 != it1) { qDebug() &lt;&lt; (*it0).name; ++it0; } }</code> </pre> <br>  What if we are interested in searching by a combination of phone and address? <br>  We can add a composite index to our array with such a block: <br><pre> <code class="cpp hljs"> ordered_non_unique&lt; tag&lt;Rec::ByKey&gt;, composite_key&lt; Rec, member&lt;Rec,QString,&amp;Rec::phone&gt;, member&lt;Rec,QString,&amp;Rec::addr&gt; &gt; &gt;,</code> </pre> <br>  (Plus, don't forget to add a struct ByKey {};) <br><pre> <code class="cpp hljs">{ Rec r1 = { <span class="hljs-string"><span class="hljs-string">"Basilio Pupkinio"</span></span>, <span class="hljs-string"><span class="hljs-string">"022"</span></span>, <span class="hljs-string"><span class="hljs-string">"Pushkina st"</span></span> }; Rec r2 = { <span class="hljs-string"><span class="hljs-string">"Vasya Pupkin"</span></span>, <span class="hljs-string"><span class="hljs-string">"022"</span></span>, <span class="hljs-string"><span class="hljs-string">"Around st"</span></span> }; Rec r3 = { <span class="hljs-string"><span class="hljs-string">"Vasilisa Pupkina"</span></span>, <span class="hljs-string"><span class="hljs-string">"022"</span></span>, <span class="hljs-string"><span class="hljs-string">"Around st"</span></span> }; store.insert(r1); store.insert(r2); store.insert(r3); { QString find_phone = <span class="hljs-string"><span class="hljs-string">"022"</span></span>; QString find_addr = <span class="hljs-string"><span class="hljs-string">"Around st"</span></span>; Store::index&lt;Rec::ByKey&gt;::type::iterator it0, it1; tie(it0,it1) = store.get&lt;Rec::ByKey&gt;().equal_range(make_tuple(find_phone, find_addr)); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(it0 != it1) { qDebug() &lt;&lt; (*it0).name; ++it0; } } }</code> </pre> <br>  Again, we understand that for composite keys, we can use both ordered_non_unique and ordered_unique. <br>  In this way it is very convenient to impose some additional conditions on the contents of the allowed keys and their combinations - the array itself will not allow us to add "wrong" objects. <br>  If we want to be able to access the array at the same time as a vector, we can easily add random_access: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::multi_index_container&lt;Rec, indexed_by&lt; random_access&lt;&gt;, ordered_unique&lt; tag&lt;Rec::ByName&gt;, member&lt;Rec,QString,&amp;Rec::name&gt; &gt;, ordered_non_unique&lt; tag&lt;Rec::ByPhone&gt;, member&lt;Rec,QString,&amp;Rec::phone&gt; &gt; &gt; &gt; Store;</code> </pre> <br>  Then we have the ability to access as store [0] and so on, push_back (). <br>  If we want to use an array as a hash to have quick access using the O (1) key, but slower O (log (n)) by insert / remove, then we can use hashed_unique / hashed_non_unique instead of ordered_unique / ordered_non_uniue: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::multi_index_container&lt;Rec, indexed_by&lt; hashed_non_unique&lt; tag&lt;Rec::ByName&gt;, member&lt;Rec,QString,&amp;Rec::name&gt; &gt;, ordered_non_unique&lt; tag&lt;Rec::ByPhone&gt;, member&lt;Rec,QString,&amp;Rec::phone&gt; &gt; &gt; &gt; Store; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> hash_value(QString x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> qHash(x); }</code> </pre> <br>  You can also use hashed_uniqie / hashed_non_unique for composite keys. <br><br>  On the modification of records. <br>  Since the fields of the objects must be synchronized with the indices of the array, you cannot simply change only the field of the object.  Suppose we have a need to change the phone for one of the entries.  In order for our keys to be synchronized with objects, this change must be made through the functor: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rec</span></span></span><span class="hljs-class"> {</span></span> QString name, phone, addr; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByName</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByPhone</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByAddr</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PhoneChange</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unary_function&lt;Rec,<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { QString p; PhoneChange(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;_p) : p(_p) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Rec &amp; r)</span></span></span><span class="hljs-function"> </span></span>{ r.phone = p; } }; };</code> </pre> <br>  We can do a search in an array by name, get an iterator by name, use project () to translate it into an iterator by phone and modify the object and array through the functor: <br><pre> <code class="cpp hljs">{ Store store; Rec r1 = { <span class="hljs-string"><span class="hljs-string">"Basilio Pupkinio"</span></span>, <span class="hljs-string"><span class="hljs-string">"021"</span></span>, <span class="hljs-string"><span class="hljs-string">"Around st"</span></span> }; Rec r2 = { <span class="hljs-string"><span class="hljs-string">"Vasya Pupkin"</span></span>, <span class="hljs-string"><span class="hljs-string">"022"</span></span>, <span class="hljs-string"><span class="hljs-string">"Around st"</span></span> }; Rec r3 = { <span class="hljs-string"><span class="hljs-string">"Vasilisa Pupkina"</span></span>, <span class="hljs-string"><span class="hljs-string">"022"</span></span>, <span class="hljs-string"><span class="hljs-string">"Around st"</span></span> }; store.insert(r1); store.insert(r2); store.insert(r3); QString find_id = <span class="hljs-string"><span class="hljs-string">"Basilio Pupkinio"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Store::index&lt;Rec::ByName&gt;::type NList; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Store::index&lt;Rec::ByPhone&gt;::type PList; NList &amp; ns = store.get&lt;Rec::ByName&gt;(); PList &amp; ps = store.get&lt;Rec::ByPhone&gt;(); NList::const_iterator nit = ns.find(find_id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( nit != ns.end() ) { PList::const_iterator pit = store.project&lt;Rec::ByPhone&gt;(nit); ps.modify(pit, Rec::PhoneChange(<span class="hljs-string"><span class="hljs-string">"022"</span></span>)); } }</code> </pre> <br>  The use of indexes is not limited to fields - you can also use class methods, for example: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rec</span></span></span><span class="hljs-class"> {</span></span> QString n, phone, addr; <span class="hljs-function"><span class="hljs-function">QString </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByName</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByPhone</span></span></span><span class="hljs-class"> {</span></span>}; }; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::multi_index_container&lt;Rec, indexed_by&lt; hashed_unique&lt; tag&lt;Rec::ByName&gt;, const_mem_fun&lt;Rec,QString,&amp;Rec::name&gt; &gt;, ordered_non_unique&lt; tag&lt;Rec::ByPhone&gt;, member&lt;Rec,QString,&amp;Rec::phone&gt; &gt; &gt; &gt; Store;</code> </pre> <br>  We should also mention the use of pointers: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rec</span></span></span><span class="hljs-class"> {</span></span> QString n, phone, addr; <span class="hljs-function"><span class="hljs-function">QString </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByName</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByPhone</span></span></span><span class="hljs-class"> {</span></span>}; }; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Rec&gt; Rec_ptr; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::multi_index_container&lt;Rec_ptr, indexed_by&lt; hashed_non_unique&lt; tag&lt;Rec::ByName&gt;, const_mem_fun&lt;Rec,QString,&amp;Rec::name&gt; &gt;, ordered_non_unique&lt; tag&lt;Rec::ByPhone&gt;, member&lt;Rec,QString,&amp;Rec::phone&gt; &gt;, hashed_non_unique&lt; tag&lt;Rec::ByKey&gt;, composite_key&lt; Rec, member&lt;Rec,QString,&amp;Rec::phone&gt;, member&lt;Rec,QString,&amp;Rec::addr&gt; &gt; &gt;, ordered_non_unique&lt; tag&lt;Rec::ByAddr&gt;, member&lt;Rec,QString,&amp;Rec::addr&gt; &gt; &gt; &gt; Store;</code> </pre> <br>  The rest of the logic remains almost the same (only -&gt; instead of. In a couple of places). <br><pre> <code class="cpp hljs">{ QString find_phone = <span class="hljs-string"><span class="hljs-string">"022"</span></span>; Store::index&lt;Rec::ByPhone&gt;::type::iterator it0, it1; tie(it0,it1) = store.get&lt;Rec::ByPhone&gt;().equal_range(find_phone); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(it0 != it1) { qDebug() &lt;&lt; (*it0)-&gt;name(); ++it0; } }</code> </pre> <br>  Plus it is worth adding for example a block <br><pre> <code class="cpp hljs"> ordered_unique&lt; tag&lt;Rec::ByPtr&gt;, const_mem_fun&lt;Rec_ptr,Rec *,&amp;Rec_ptr::get&gt; &gt;,</code> </pre> <br>  To exclude the addition of duplicate pointers. <br><br>  As a result, it is possible to build very efficient data structures with interconnected information, such as smart pointers, where for each operation it is fairly easy to predict the cost of access to certain data.  In a sense, multi_index_container can be viewed as a very fast database table in memory for access by predefined keys. <br><br>  I hope with simple examples I give the possibility of a ‚Äúhot start‚Äù to use this wonderful tool, since studying the original documentation and trying to make out compiler errors about patterns in using multi_index immediately cause great dismay for beginners and attempts to make something of their own.  It turns out as always. </div><p>Source: <a href="https://habr.com/ru/post/160009/">https://habr.com/ru/post/160009/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../159987/index.html">We write the console alarm clock on BASH-e</a></li>
<li><a href="../159997/index.html">Murphy's Laws in IT</a></li>
<li><a href="../160001/index.html">Modding Angel Eyes</a></li>
<li><a href="../160003/index.html">Ways to create navicon</a></li>
<li><a href="../160007/index.html">The digest of interesting news and materials from the world of ayti for the last week ‚Ññ32 (November 17 - 23, 2012)</a></li>
<li><a href="../160011/index.html">Chip for recognizing 3D gestures through an electric field</a></li>
<li><a href="../160013/index.html">UK cryptographers did not decipher the code transmitted with the pigeon</a></li>
<li><a href="../160017/index.html">STM32 + DHT11</a></li>
<li><a href="../160019/index.html">Seven Stone Age Ghosts or What Should Be the Perfect Online Store</a></li>
<li><a href="../160029/index.html">Bitcoin: Mining reward halving on Thursday morning</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>