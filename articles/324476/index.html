<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Guide for novice programmer graphics shaders</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The ability to write graphic shaders opens up all the power of modern GPUs, which today already contain thousands of cores that can execute your code ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Guide for novice programmer graphics shaders</h1><div class="post__text post__text-html js-mediator-article">  The ability to write graphic shaders opens up all the power of modern GPUs, which today already contain thousands of cores that can execute your code quickly and in parallel.  Programming shaders requires a slightly different look at some things, but the emerging potential is worth some time spent studying it. <br><br>  Virtually every modern graphic scene is the result of some code written specifically for the GPU - from realistic lighting effects in the latest AAA games to 2D effects and fluid simulation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c9/8f2/b1a/9c98f2b1ad8cb268e0bf07770bc7a749.jpg" alt="image"><br>  <i>The scene in Minecraft before and after applying several shaders.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  The purpose of this instruction </h2><br>  Shader programming sometimes seems mysterious black magic.  Here and there you can find separate pieces of shader code that promise you incredible effects and, perhaps, really are able to provide them - but they do not at all explain what they do and how they achieve such impressive results.  This article will try to close this gap.  I will focus on basic things and terms related to writing and understanding shader code, so that later you can change the shader code yourself, combine them, or write your own from scratch. <br><a name="habracut"></a><br><h2>  What is a shader? </h2><br>  A shader is simply a program that runs on one of the graphics cores and tells the video card how to draw each pixel.  Programs are called ‚Äúshaders‚Äù because they are often used to control the effects of <a href="https://www.youtube.com/watch%3Fv%3DG8-ivm3iuKc">lighting</a> and <a href="http://threejs.org/examples/">shading</a> (‚Äúshading‚Äù).  But, of course, there is no reason to limit ourselves to these effects. <br><br>  Shaders are written in a special programming language.  Do not worry, you do not need right now to go and learn from scratch a new programming language.  We will use GLSL (OpenGL Shading Language), which has a C-like syntax.  There are <a href="http://en.wikipedia.org/wiki/Shading_language">other</a> programming languages ‚Äã‚Äãfor shaders for different platforms, but since their ultimate goal is to run the same code on the GPU, they have quite similar principles. <br><br>  This article will tell only about the so-called pixel (or fragment) shaders.  If it became interesting to you, and what they are still - you should read about the graphics pipeline (for example, in the <a href="https://www.khronos.org/opengl/wiki/Shader">OpenGL Wiki</a> ). <br><br><h2>  Go! </h2><br>  For our experiments, we will use <a href="https://www.shadertoy.com/">ShaderToy</a> .  This will allow you to take and start writing shader code here and now, without delaying the matter until later because of the need to install some specific tools or SDK.  The only thing you need is a browser with WebGL support.  It is not necessary to create an account on ShaderToy (only if you want to save your code there). <br><br>  <i>Note</i> : ShaderToy is currently in beta, so at the time you read this article, some of the nuances of its UI may change. <br><br>  So, press the <a href="https://www.shadertoy.com/new">New</a> button in the right corner, which will lead to the creation of a new shader: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22b/b8a/e96/22bb8ae96fd0906d78bd36e470aff88a.jpg" alt="image"><br><br>  The little black arrow under the code compiles and runs the shader. <br><br><h2>  What's going on here? </h2><br>  I will now explain how the shader works, in exactly one sentence.  You are ready?  Here it is.  <b>The only purpose of a shader is to return four numbers: r, g, b, and a.</b> <br>  This is all that a shader can and should do. <br><br>  The function that you see above runs for each pixel on the screen.  And for each of them, it returns the four numbers above, which become the color of this pixel.  This is how pixel shaders work (sometimes also called fragment shaders). <br><br>  So, now we have enough knowledge to, for example, fill the entire screen with a pure red color.  The values ‚Äã‚Äãof each of the rgba components (red, green, blue and ‚Äúalpha‚Äù - that is, ‚Äútransparency‚Äù) can be in the range from 0 to 1, so in our case we will simply return r, g, b, a = 1.0 0.1  ShaderToy expects the final color of the pixel in the fragColor variable. <br><br><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainImage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vec4 fragColor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vec2 fragCoord </span></span></span><span class="hljs-function">)</span></span> { fragColor = vec4(<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><br>  My congratulations!  This is your first working shader! <br>  <b>Mini task</b> : can you fill the entire screen in gray? <br><br>  vec4 is just a data type, so we can declare our color as a variable: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainImage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vec4 fragColor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vec2 fragCoord </span></span></span><span class="hljs-function">)</span></span> { vec4 solidRed = vec4(<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>); fragColor = solidRed; }</code> </pre> <br><br>  This example is not very exciting.  We have the power of hundreds or thousands of processing cores capable of working efficiently and in parallel, and we shoot sparrows from this cannon, filling the entire screen with one color. <br><br>  Let's at least draw a gradient.  To do this, as you can guess, we need to know the position of the current pixel on the screen. <br><br><h2>  Shader Input Parameters </h2><br>  Each pixel shader has at its disposal several useful <a href="https://www.opengl.org/wiki/Built-in_Variable_(GLSL)">variables</a> .  In our case, the most useful will be the fragCoord, which contains the x and y coordinates (and also z, if you need to work in 3D) of the current pixel.  To begin with, let's try to paint all the pixels in the left half of the screen black and on the right half red: <br><br><pre> <code class="hljs ruby">void mainImage( out vec4 fragColor, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec2 fragCoord ) { vec2 xy = fragCoord.xy; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    vec4 solidRed = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>);<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(xy.x &gt; <span class="hljs-number"><span class="hljs-number">300.0</span></span>){<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,       solidRed.r = <span class="hljs-number"><span class="hljs-number">1.0</span></span>;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   } fragColor = solidRed; }</code> </pre> <br><br>  <i>Note</i> : to access the components of variables of type vec4, you can use obj.x, obj.y, obj.z, obj.w or obj.r, obj.g, obj.b, obj.a.  These are equivalent entries.  In this way, we are able to name the vec4 components, depending on what they are in each particular case. <br><br>  Do you already see a problem with the code above?  Try pushing the full screen button.  The proportions of the red and black parts of the screen will change (depending on the size of your screen).  In order to paint over exactly half of the screen, we need to know its size.  Screen size is not a built-in variable, since it is something that the application programmer controls himself.  In our case, it is the responsibility of the ShaderToy developers. <br><br>  If something is not a built-in variable, you can send this information from the CPU (the main code of your application) to the GPU (your shader).  ShaderToy does it for you.  You can view all the variables available to the shader in the Shader Inputs tab.  In GLSL, they are called uniform variables. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b0e/332/b08/b0e332b083e01bda172232919bdfeb2a.png" alt="image"><br><br>  Let's fix our code so that it correctly defines the middle of the screen.  To do this, we need the iResolution uniform variable: <br><br><pre> <code class="hljs ruby">void mainImage( out vec4 fragColor, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec2 fragCoord ) { vec2 xy = fragCoord.xy; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    xy.x = xy.x / iResolution.x; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     xy.y = xy.y / iResolution.y; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-number"><span class="hljs-number">0</span></span>      <span class="hljs-number"><span class="hljs-number">1</span></span>    vec4 solidRed = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(xy.x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>){ solidRed.r = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   } fragColor = solidRed; }</code> </pre> <br><br>  Now, even with an increase in the preview window (or switching to full-screen mode), we get a black and red rectangle divided exactly in half. <br><br><h2>  From screen splitting to gradient </h2><br>  Changing our code to get a gradient fill is easy.  The color components can be in the range from 0 to 1, and our coordinates are now also represented in the same range. <br><br><pre> <code class="hljs ruby">void mainImage( out vec4 fragColor, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec2 fragCoord ) { vec2 xy = fragCoord.xy; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    xy.x = xy.x / iResolution.x; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     xy.y = xy.y / iResolution.y; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-number"><span class="hljs-number">0</span></span>      <span class="hljs-number"><span class="hljs-number">1</span></span>    vec4 solidRed = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   solidRed.r = xy.x; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         fragColor = solidRed; }</code> </pre> <br><br>  Voila! <br><br>  <b>Mini-task</b> : do you try to make a vertical gradient yourself?  Diagonal?  How about switching between more than two colors? <br><br>  If you have not missed the above task with a vertical gradient, then you already know that the upper left corner has coordinates (0; 1), and not (0; 0), as one would assume.  This is important, remember this. <br><br><h2>  Drawing images </h2><br>  Having fun with color shading is, of course, funny, but if we want to realize some truly spectacular effect, our shader should be able to accept a picture at the input and modify it.  Thus, we can write a shader that can affect, for example, the entire frame in the game (draw effects of liquids or color correction) or vice versa, perform only certain operations for some objects of the scene (for example, implement a part of the lighting system). <br><br>  If we wrote shaders on any conventional platform, we would have to transfer the image to the shader as a uniform variable (in the same way as the screen resolution was transmitted).  ShaderToy does it for us.  There are four input channels below: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ed/b8c/037/0edb8c03704878ab16ef8ecf2c7ddd0f.png" alt="image"><br><br>  Click on the iChannel0 channel and select any texture (image).  Now you have a picture that will be transferred to your shader.  But there is one problem: we don‚Äôt have the DrawImage () function.  You remember, all that a shader can do is return the rgba value for one pixel. <br><br>  So, if we can only return the color value, then how do we draw a picture on the screen?  We must somehow relate the pixel in the picture to the pixel for which the shader was called: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/603/e5d/1b5/603e5d1b5519d4c30e7593e4ab4bcb27.png" alt="image"><br><br>  We can do this by using the texture (textureData, coordinates) function, which accepts texture and coordinates (x, y) as input, and returns the color of the texture at this point as a variable of type vec4. <br><br>  You can relate the texture and screen pixels as you like.  You can, for example, stretch the texture to a quarter of the screen or draw only a part of it.  In our case, we just want to see the original image: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainImage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vec4 fragColor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vec2 fragCoord </span></span></span><span class="hljs-function">)</span></span> { vec2 xy = fragCoord.xy / iResolution.xy; <span class="hljs-comment"><span class="hljs-comment">//     vec4 texColor = texture(iChannel0,xy); //     (x;y)   iChannel0 fragColor = texColor; //      }</span></span></code> </pre> <br>  And here it is, our picture! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9a2/010/eea/9a2010eea492a7f0652f3baf85bc03e3.jpg" alt="image"><br><br>  Now, when you can pull data from a texture, you can manipulate it as you like.  You can stretch or compress the image, play with its colors. <br>  Let's add here the gradient we already know: <br><br><pre> <code class="hljs">texColor.b = xy.x;</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/206/fa1/568/206fa15688f131bc33ad27ed3c89a6f5.jpg" alt="image"><br><br>  Congratulations, you just wrote your first post-processing effect! <br><br>  <b>Mini-task</b> : can you write a shader that converts the input image into a black and white image? <br><br>  Notice, although we use a static image, what you see on the screen is rendered in real time, many times per second.  You can verify this by replacing the static image on the video in the input channel (just click on the iChannel0 channel and select the video). <br><br><h3>  Add a little movement </h3><br>  Up to this point all our effects were static.  We can do much more interesting things using the input parameters provided by the ShaderToy developers.  iGlobalTime is an ever-increasing variable - we can use it as a basis for periodic effects.  Let's try playing with the colors: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> mainImage( <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> vec4 fragColor, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec2 fragCoord ) { vec2 xy = fragCoord.xy / iResolution.xy; //     vec4 texColor = texture(iChannel0,xy); //     (x;y)   iChannel0 texColor.r *= abs(sin(iGlobalTime)); texColor.g *= abs(cos(iGlobalTime)); texColor.b *= abs(sin(iGlobalTime) * cos(iGlobalTime)); fragColor = texColor; //      }</code> </pre> <br><br>  GLSL has built-in sine and cosine functions (and many other useful ones).  The color components should not be negative, so we use the abs function. <br><br>  <b>Mini-task</b> : can you make a shader, which will periodically smoothly make the picture black and white, and then full color again? <br><br><h2>  Shader Debugging </h2><br>  When writing ordinary programs, you may have used the debugging output or logging, but for shaders this is not very possible.  You can find some debugging tools for your specific platform, but in general, it is best to present the value you need in the form of some graphical information that you can see in the output with the naked eye. <br><br><h2>  Conclusion </h2><br>  We have considered only the basic shader development tools, but you can already experiment with them and try to make something of your own.  Look at the <a href="https://www.shadertoy.com/browse">effects</a> available on ShaderToy and try to understand (or independently reproduce) some of them. <br><br>  One of the (many) things that I did not mention in this article is vertex shaders (Vertex Shaders).  They are written in the same language, but are launched not for pixels, but for vertices, returning, respectively, the new position of the vertex and its color.  Vertex shaders do, for example, display a 3D scene on the screen. <br><br>  The last mini-task: can you write a shader that will replace the green background (available in some videos on ShaderToy) with another picture or video? <br><br>  That's all that I wanted to tell in this article.  In the following, I will try to talk about lighting systems, fluid simulation, and shader design for specific platforms. </div><p>Source: <a href="https://habr.com/ru/post/324476/">https://habr.com/ru/post/324476/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324462/index.html">He tested the most famous methods of personal effectiveness and wrote one of the best books on productivity.</a></li>
<li><a href="../324464/index.html">How work was done to improve navigation in Uber</a></li>
<li><a href="../324466/index.html">Micro-optimizations are important: prevent 20 million system calls</a></li>
<li><a href="../324468/index.html">Google Device Day Video</a></li>
<li><a href="../324470/index.html">Tool for easy code editing right in the browser</a></li>
<li><a href="../324478/index.html">Top 5 jQuery UI Alternatives</a></li>
<li><a href="../324480/index.html">Pwn2Own 2017: the results of the tenth hacker competition</a></li>
<li><a href="../324482/index.html">We invite you to the All-Russian Student Olympiad in Applied Informatics and Cyber ‚Äã‚ÄãSecurity at MEPhI</a></li>
<li><a href="../324484/index.html">A programmer without a diploma: what can and what can not give "home schooling" in IT</a></li>
<li><a href="../324488/index.html">The story of an investigation or how the DLP system revealed a targeted attack.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>