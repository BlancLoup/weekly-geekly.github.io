<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JSON serializer on fast templates</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is the problem of text data exchange formats? They are slow. And not just slow, but monstrously slow. Yes, they are redundant in comparison with ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JSON serializer on fast templates</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/c8c/cda/b29/c8ccdab29a2445e7ab7438051d13c4bd.jpg"><br><br>  What is the problem of text data exchange formats?  They are slow.  And not just slow, but monstrously slow.  Yes, they are redundant in comparison with binary protocols and, in theory, the text serializer should be slower by about as much as it is redundant.  But in practice, it turns out that sometimes textual serializers are orders of magnitude inferior to binary analogues. <br><br>  I will not talk about the advantages of JSON over binary formats - each format has its own scope in which it is good.  But often we are forced to abandon something convenient in favor of the not very comfortable because of the catastrophic inefficiency of the first.  Developers refuse JSON, even if it is perfect for solving a problem, just because it turns out to be a bottleneck in the system.  Of course, it is not JSON itself that is to blame, but the implementation of the corresponding libraries. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article I will talk not only about the problems of text format parsers in general and JSON in particular, but also about our library, which we have been using for many years in the most heavily loaded projects.  It suits us so much both in terms of speed and usability that sometimes we give up the binary format where it would fit better.  Of course, I mean some border conditions, without claims for all occasions. <br><br><a name="habracut"></a><br><br>  To assess the scale of the tragedy, I measured the time of serialization of a not very complex object for a couple of well-known JSON libraries, google :: protobuf, ‚Äúmanual‚Äù JSON serialization, and for the <a href="https://github.com/mambaru/wjson">wjson</a> library, of which I am the developer, and will tell you in detail in this article below. <br><br>  The results are shown in the diagram: <br><img src="https://habrastorage.org/files/3ff/92b/8c3/3ff92b8c325d45bbab81d251c6e67539.png"><br>  I confess that these results at one time, let's say gently, slightly surprised me. <br><br>  The performance of jsoncpp and json_spirit (based on boost :: spirit) catastrophically loses google :: protobuf.  The situation with ‚Äúmanual‚Äù serialization using sprintf / sscanf or std :: stringstream is much better.  But if you use the first two tools, then do not hurry to drop everything, and with a cry: ‚ÄúI told you what to do yourself!‚Äù - to redo your projects.  On the chart, measurements for a single sprintf / sscanf call, into which we stuffed a serializable object without any checks and the ability to rearrange or skip fields in a JSON object.  I will give more detailed figures in the section on object serialization. <br><br>  In this article, I see JSON as a messaging format with an emphasis on performance.  Accordingly, I compare certain technologies in this context.  This also means that the structure of messages at the design stage (compilation) is known to us.  The proposed wjson library was also developed specifically for these tasks.  Of course, it is possible to explore unknown JSON documents, and perhaps wjson will be more efficient than many libraries, in any case, jsoncpp and json_spirit - that's for sure. <br><br>  In fact, wjson is conceptually closer to protobuf than, for example, to the libraries mentioned above.  It also generates serialization / deserialization code by some meta description.  But unlike protobuf, it does not use an external application, but a C ++ compiler.  In the previous article I showed how a compiler can be taught to play <a href="https://habrahabr.ru/post/228367/">tic-tac-toe</a> , and to teach him how to generate a serialization code is a matter of technique. <br><br>  But what I like most is the fact that there is no need to implement any additional functionality in the serializable data structures - flies separately, cutlets separately.  And inheritance is supported, including multiple inheritance, aggregation of any nesting, and some buns, for example, serialization of enums. <br><br>  Initially, wjson was conceived solely for the declarative description of JSON constructs on c ++ templates in order to save the programmer from writing run-time code with a lot of necessary checks.  But it quickly became clear that the compiler was aggressively inline-it-like constructs.  And it took quite a bit of effort to make these structures work quite effectively and reach an acceptable level of performance. <br><br><div class="spoiler">  <b class="spoiler_title">So why is JSON so slow?</b> <div class="spoiler_text"><br><br>  If you worked with XML, then you know that there are two approaches to deserialization ‚Äî the DOM (Document Object Model) and SAX (Simple API for XML).  Recall that in the case of DOM, the text is converted into a tree of nodes that can be explored using the appropriate API.  And the SAX parser works differently - it scans the document and generates certain events that are processed by the user code, implemented, as a rule, in the form of callback functions.  Anyway, most text de-serializers use one of these approaches, or combine them. <br><br>  The main drawback of the DOM is the need to build a tree, which is always expensive.  The process of building such a tree at the stage of deserialization can take much longer than the execution of applied algorithms.  But besides this, it is necessary to search for the required fields and convert them into internal data structures.  And this task falls on the programmer‚Äôs shoulders, which he can realize extremely inefficiently.  In fact, this is not so important, because it is the construction of the DOM trees that eats up the main resources. <br><br>  SAX type parsers are much faster.  By and large, they pass the text once, causing the appropriate handlers.  Implementing a similar parser for JSON is a trivial task, because JSON itself is simple to disgrace, and that‚Äôs its beauty.  But it requires a programmer who uses it, much more effort to extract data.  And this is more work for the programmer, more errors and inefficient code, which can negate the effectiveness of SAX. <br><br>  In general, the topic of efficient serialization is very interesting from the point of view of developing some kind of universal solution.  But from the perspective of application programming, this is extremely tedious and boring, and as a result, huge amounts of inefficient govnokod.  It is much more interesting for a programmer to optimize an application code, and the fact that deserialization occurs an order of magnitude slower and its optimization in this context does not make much sense, it does not bother him much. <br><br>  But if most of the existing solutions for some reason do not suit us, let's do it manually, the benefit of JSON is a very simple format.  And here I have watched a very interesting story several times.  If a programmer works with binary protocols, he scrupulously shifts bits, optimizes the code and gets pleasure from it.  But if he is offered to work with the text format in the same context, it seems that something is turned off in his brain.  More precisely, on the contrary, he turns on protection against a high-order bicycle industry, which he did not particularly suffer from when working with a binary format.  It connects heaps of libraries for working with text for the sake of a couple of beautiful (but, as a rule, not very effective) functions, in order to somehow improve their JSON code.  And the result is still deplorable. <br><br>  Few people would think to write their own implementation of atoi, but we still try: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P&gt; <span class="hljs-function"><span class="hljs-function">P </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_atoi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T&amp; v, P beg, P end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( beg==end) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> end; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> neg = ( *beg==<span class="hljs-string"><span class="hljs-string">'-'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neg ) ++beg; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( beg == end || *beg &lt; <span class="hljs-string"><span class="hljs-string">'0'</span></span> || *beg &gt; <span class="hljs-string"><span class="hljs-string">'9'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*beg==<span class="hljs-string"><span class="hljs-string">'0'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ++beg; v = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ;beg!=end; ++beg ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*beg &lt; <span class="hljs-string"><span class="hljs-string">'0'</span></span> || *beg &gt; <span class="hljs-string"><span class="hljs-string">'9'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; v = v*<span class="hljs-number"><span class="hljs-number">10</span></span> + (*beg - <span class="hljs-string"><span class="hljs-string">'0'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neg) v = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T&gt;(-v); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> beg; }</code> </pre> <br><br>  In fact, everything is simple, but more universal and more convenient (in my opinion) than the classical atoi.  But the most interesting thing is that it works twice as fast.  Yes, of course, mostly due to inline substitutions, but this is not the point.  By the way, sscanf / sprintf fulfills% s parameters faster than% d, with comparable string length. <br><br>  I will not now talk about the danger of sscanf / sprintf, they have already written about it many times and, in addition, there are safe alternatives, for example, std :: stringstream or boost :: lexical_cast &lt;&gt;.  Unfortunately, many programmers, including C ++, are guided by the myth that labor C is faster, and with enviable persistence begin to use sscanf / sprintf.  But the problem, in this context, is not in the language, but in the implementation of one or another functional.  For example, std :: stringstream, if used properly, may be no worse than C alternatives, but let's say boost :: lexical_cast &lt;&gt; may be significantly inferior in this regard. <br><br>  Therefore, you need to thoroughly test the performance of not only third-party libraries, but also familiar tools.  But it will often be quicker to bridle by looking at the necessary implementations on the Internet. <br><br>  The code for my_atoi is almost unchanged from wjson, maybe someone will come in handy.  The serialization code is a bit more confused: <br><br><div class="spoiler">  <b class="spoiler_title">itoa</b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//         template&lt;typename T&gt; struct integer_buffer_size { enum { value = sizeof(T)*2 + sizeof(T)/2 + sizeof(T)%2 + is_signed_integer&lt;T&gt;::value }; }; //       template&lt;typename T, int &gt; struct is_signed_integer_base { enum { value = 1 }; static bool is_less_zero(T v) { return v &lt; 0; } }; //    ,  false template&lt;typename T&gt; struct is_signed_integer_base&lt;T, false&gt; { enum { value = 0 }; static bool is_less_zero(T ) { return false; } }; template&lt;typename T&gt; struct is_signed_integer: is_signed_integer_base&lt; T, ( T(-1) &lt; T(1) ) &gt; { }; template&lt;typename T, typename P&gt; P my_itoa(T v, P itr) { char buf[integer_buffer_size&lt;T&gt;::value]; char *beg = buf; char *end = buf; if (v==0) *(end++) = '0'; else { //      if (false) //     .    //      if ( is_signed_integer&lt;T&gt;::is_less_zero(v) ) { for( ; v!=0 ; ++end, v/=10) *end = '0' - v%10; *(end++)='-'; } else { for( ; v!=0 ; ++end, v/=10) *end = '0' + v%10; } } do { *(itr++)=*(--end); } while( end != beg ); return itr; }</span></span></code> </pre><br></div></div><br><br>  Due to such one byte brute force for other JSON and inline substitution constructions, faster deserialization can be achieved.  If we assemble them in any way into a single structure, we get a kind of SAX parser, which is also very fast. <br></div></div><br><br><h4>  Simple types </h4><br><br>  Let's take an example of serialization right away: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">12345</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> bufjson[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* ptr = wjson::value&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::serializer()(value, bufjson); *ptr = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; bufjson &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br><br>  Here, wjson :: value &lt;int&gt; is a JSON description of an integer type that contains a serializer definition for this type.  Next, we create a serializer object and call the overloaded operator ().  Such a record may seem strange to someone, but we will use it to emphasize that the JSON serializer object has no state and does not make sense to create its instance. <br><br>  I will immediately answer the question why serializer is not a static function.  Firstly, the compiler does not like static elements in terms of compilation time, and secondly, it is just more convenient, at least for me.  In fact, there will be a complete substitution of the code that I showed under the spoiler above, using the example of my_itoa. <br><br>  The value &lt;&gt; construct is used not only for integers, but also for real, strings, and boolean.  Definition: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> R = <span class="hljs-number"><span class="hljs-number">-1</span></span>&gt; struct value { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T target; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> implementation_defined serializer; };</code> </pre><br>  For Boolean and integer types, the argument R is not used.  For lines of type std :: string or std :: vector &lt;char&gt; is the size of the reserve, and for real lines, the format of the presentation. <br><br>  The serializer class, in addition to serialization, provides de-serialization functionality, i.e.  two overloaded operator (): <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implementation_defined</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P&gt; <span class="hljs-function"><span class="hljs-function">P </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; v, P itr)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P&gt; <span class="hljs-function"><span class="hljs-function">P </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T&amp; v, P beg, P end, json_error* e )</span></span></span></span>; };</code> </pre><br>  The serialization function takes as input, in addition to the reference to the type being serialized, the output iterator, for example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">12345</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> strjson; wjson::value&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::serializer()(value, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter(strjson)); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; strjson &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> ssjson; wjson::value&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::serializer()(value, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostreambuf_iterator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;(ssjson)); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; ssjson.str() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; wjson::value&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::serializer()(value, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostreambuf_iterator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  The serializer accepts random access iterators at the input, indicating the beginning and end of the buffer, as well as an error object pointer, which may be zero: <br><pre> <code class="cpp hljs">value = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> bufjson[<span class="hljs-number"><span class="hljs-number">100</span></span>]=‚Äù<span class="hljs-number"><span class="hljs-number">12345</span></span>‚Äù; wjson::value&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::serializer()(value, bufjson, bufjson + <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(bufjson), <span class="hljs-number"><span class="hljs-number">0</span></span> ); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; value &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; value = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> strjson=‚Äù<span class="hljs-number"><span class="hljs-number">12345</span></span>‚Äù; wjson::value&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::serializer()(value, strjson.begin(), strjson.end(), <span class="hljs-number"><span class="hljs-number">0</span></span> ); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; value &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Both the serializer and deserializer return iterators.  In the first case, it indicates the place where the serialization ended, and in the second, the place in the input buffer, where deserialization ended, if there were no errors.  In case of an error, returns a pointer to the end of the buffer, and an error code if a non-null pointer was passed.  About error handling a bit later, and now we will finish simple types. <br><br>  Supported integers: char, unsigned char, short, unsigned short, int, unsigned int, long int, unsigned long, long long, unsigned long long.  C boolean (bool), all the same, serializes to ‚Äútrue‚Äù or ‚Äúfalse‚Äù and back.  Automatic conversion from other types during deserialization is not supported. <br><br>  The only type with which I didn‚Äôt bother too much in terms of performance is real (float, double, long double), there is the usual std :: stringstream.  First of all, this is due to the fact that in real projects I worked with, it could always be replaced with either integer types (for example, transmitting meters in millimeters) or a load within 10K to the CPU core, which is not significant.  If you have the bulk of traffic - it is real and can‚Äôt get away from it, then it makes sense to be confused with optimization.  By default, real ones are serialized with a mantissa.  When R&gt; = 0, as with a fixed comma: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> value = <span class="hljs-number"><span class="hljs-number">12345.12345</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> json; wjson::value&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;::serializer()(value, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter(json)); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; json &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; json.clear(); wjson::value&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>&gt;::serializer()(value, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter(json)); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; json &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br><br>  Result: <br><pre> <code class="bash hljs">1.234512e+04 12345.1234</code> </pre><br>  With strings, at first glance, everything should be simple if you use utf-8, but you need to pay attention to the following points: <br><ul><li>  serialization <br><ul><li>  all utf-8 characters with a code of 32 (space) are copied as is </li><li>  the characters '‚Äú', '\', '/', '\ t', '\ b', '\ r', '\ n', '\ f' are escaped by '\' according to the JSON specification </li><li>  the remaining characters, with a code less than 32, are serialized in hexadecimal format (\ uXXX) </li><li>  not utf-8 is serialized byte-byte in the \ xXX format, which does not conform to the JSON specification, which works exclusively with utf-8, but wjson deserializer understands this format </li></ul><br></li><li>  deserialization <br><ul><li>  escaped characters unscreened </li><li>  combinations of the \ uXXXX type are converted to utf-8, with the exception of some values ‚Äã‚Äãless than 32 (if XXXX does not encode '\ t', '\ b', '\ r', '\ n', '\ f', then no conversion) </li><li>  combinations of the form \ xXX are unscreened without checks </li><li>  all other utf-8 characters are copied as is </li></ul></li></ul><br><br>  Some third-party libraries, especially without straining, serialize everything that is not included in the ASCII range (codes&gt; 127) in the \ uXXXX format.  But when deserializing a similar string with wjson, this is decoded into utf-8.  When wjson is re-serialized, this screening will no longer exist. <br><br>  Sometimes, as a rule, due to a program error, in the middle of the line it turns out to be '\ 0', which by most serializers, including wjson, is converted to \ u0000, but when deserialized, it is not converted to \ 0, but remains as it is. <br><br>  Support for the \ xXX format is dictated solely by limiting the concept of wjson serialization, which does not imply invalid data (either serialized or not compiled).  To serialize binary data, use, for example, Base64. <br><br><div class="spoiler">  <b class="spoiler_title">String serialization example</b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;wjson/json.hpp&gt; #include &lt;iostream&gt; #include &lt;cstring&gt; int main() { const char* english = "\"hello world!\""; const char* russian = "\"\\u041F\\u0440\\u0438\\u0432\\u0435\\u0442\\u0020\\u043C\\u0438\\u0440\\u0021\""; const char* chinese = "\"\\u4E16\\u754C\\u4F60\\u597D!\""; typedef char str_t[128]; typedef wjson::value&lt; std::string, 128 &gt;::serializer sser_t; typedef wjson::value&lt; std::vector&lt;char&gt; &gt;::serializer vser_t; typedef wjson::value&lt; str_t &gt;::serializer aser_t; std::string sstr; std::vector&lt;char&gt; vstr; str_t astr={'\0'}; //  sser_t()( sstr, english, english + std::strlen(english), 0); vser_t()( vstr, russian, russian + std::strlen(russian), 0); aser_t()( astr, chinese, chinese + std::strlen(chinese), 0); //  std::cout &lt;&lt; "English: " &lt;&lt; sstr &lt;&lt; "\tfrom JSON: " &lt;&lt; english &lt;&lt; std::endl; std::cout &lt;&lt; "Russian: " &lt;&lt; std::string(vstr.begin(), vstr.end() ) &lt;&lt; "\tfrom JSON: " &lt;&lt; russian &lt;&lt; std::endl; std::cout &lt;&lt; "Chinese: " &lt;&lt; astr &lt;&lt; "\tfrom JSON: " &lt;&lt; chinese &lt;&lt; std::endl; //  english  stdout std::cout &lt;&lt; std::endl &lt;&lt; "English JSON: "; sser_t()( sstr, std::ostream_iterator&lt;char&gt;( std::cout) ); std::cout &lt;&lt; "\tfrom: " &lt;&lt; sstr; //  russian  stdout std::cout &lt;&lt; std::endl &lt;&lt; "Russian JSON: "; vser_t()( vstr, std::ostream_iterator&lt;char&gt;( std::cout) ); std::cout &lt;&lt; "\tfrom: " &lt;&lt; std::string(vstr.begin(), vstr.end() ); //  chinese  stdout std::cout &lt;&lt; std::endl &lt;&lt; "Chinese JSON: "; aser_t()( astr, std::ostream_iterator&lt;char&gt;( std::cout) ); std::cout &lt;&lt; "\tfrom: " &lt;&lt; astr; std::cout &lt;&lt; std::endl; }</span></span></span></span></code> </pre> <br></div></div><br>  Result: <br> <code>English: hello world! from JSON: "hello world!" <br> Russian:  ! from JSON: "\u041F\u0440\u0438\u0432\u0435\u0442\u0020\u043C\u0438\u0440\u0021" <br> Chinese: ‰∏ñÁïå‰Ω†Â•Ω! from JSON: "\u4E16\u754C\u4F60\u597D!" <br> <br> English JSON: "hello world!" from: hello world! <br> Russian JSON: " !" from:  ! <br> Chinese JSON: "‰∏ñÁïå‰Ω†Â•Ω!" from: ‰∏ñÁïå‰Ω†Â•Ω! <br></code> <br><br><h4>  Arrays </h4><br>  To describe JSON arrays, we use a similar construction with wjson :: value: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> R = <span class="hljs-number"><span class="hljs-number">-1</span></span>&gt; struct <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T target; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> implementation_defined serializer; };</code> </pre><br>  Here T is the container being serialized, and R is the size of the reserve for stl containers that support this method.  It seems everything is simple, but a record like: wjson :: array &lt;std :: vector &lt;int &gt;&gt; does not work, because  we don't know how to serialize a container element, in this case an int.  The correct entry will look like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> wjson::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; wjson::value&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; &gt; &gt; vint_json;</code> </pre> <br>  As a parameter T, we pass the container we need, but instead of the type of the container element, we pass its JSON description.  Supported: <br><ul><li>  V [n] </li><li>  std :: vector </li><li>  std :: deque </li><li>  std :: array </li><li>  std :: list </li><li>  std :: set </li><li>  std :: multiset </li><li>  std :: unordered_set </li><li>  std :: unordered_multiset </li></ul><br>  Of course, maximum performance is provided by the first four options.  Filling lists and associative containers is too expensive by itself. <br>  Example for classic C-arrays: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> wjson::value&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; int_json; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">vint_t</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> wjson::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt; int_json[3] &gt; vint_json;</code> </pre><br>  And, of course, multidimensional arrays are supported (for example, vectors of vectors, etc.), as shown in the example: <br><br><div class="spoiler">  <b class="spoiler_title">An example for a vector of vectors</b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;wjson/json.hpp&gt; #include &lt;wjson/strerror.hpp&gt; #include &lt;iostream&gt; int main() { //   typedef wjson::value&lt;int&gt; int_json; typedef std::vector&lt;int&gt; vint_t; typedef wjson::array&lt; std::vector&lt;int_json&gt; &gt; vint_json; std::string json="[ 1,\t2,\r3,\n4, /**/ 5 ]"; vint_t vint; vint_json::serializer()(vint, json.begin(), json.end(), NULL); json.clear(); vint_json::serializer()(vint, std::back_inserter(json)); std::cout &lt;&lt; json &lt;&lt; std::endl; //   (  ) typedef std::vector&lt; vint_t &gt; vvint_t; typedef wjson::array&lt; std::vector&lt;vint_json&gt; &gt; vvint_json; json="[ [], [1], [2, 3], [4, 5, 6] ]"; vvint_t vvint; vvint_json::serializer()(vvint, json.begin(), json.end(), NULL); json.clear(); vvint_json::serializer()(vvint, std::back_inserter(json)); std::cout &lt;&lt; json &lt;&lt; std::endl; //   (   ) typedef std::vector&lt; vvint_t &gt; vvvint_t; typedef wjson::array&lt; std::vector&lt;vvint_json&gt; &gt; vvvint_json; json="[ [[]], [[1]], [[2], [3]], [[4], [5, 6] ] ]"; vvvint_t vvvint; vvvint_json::serializer()(vvvint, json.begin(), json.end(), NULL); json.clear(); vvvint_json::serializer()(vvvint, std::back_inserter(json)); std::cout &lt;&lt; json &lt;&lt; std::endl; }</span></span></span></span></code> </pre><br></div></div><br>  Here we take a JSON string, deserialize it into a container, clear it, serialize it into the same string, and output: <br><pre> <code class="bash hljs">[1,2,3,4,5] [[],[1],[2,3],[4,5,6]] [[[]],[[1]],[[2],[3]],[[4],[5,6]]]</code> </pre><br>  The ‚Äújson‚Äù line shows that between the elements of the array there can be any whitespace characters, including a line feed, as well as comments in the C-style, which is very convenient when implementing the json-configuration. <br><br>  The maximum size for dynamic containers is unlimited, and for C-arrays and std :: array the limitation is the actual size of the array.  If the incoming JSON elements are smaller, the rest are filled with the default value, and if more, the extra ones are simply discarded. <br><br><div class="spoiler">  <b class="spoiler_title">If JSON arrays contain elements of different types</b> <div class="spoiler_text"><br>  If JSON arrays contain elements of different types, they are serialized and deserialized in two stages.  First you need to describe a container of strings that will contain arbitrary non-deserialized JSON constructs, for example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; vstr;</code> </pre> <br>  To describe the raw JSON: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> R = <span class="hljs-number"><span class="hljs-number">-1</span></span>&gt; struct raw_value;</code> </pre><br>  Which copies the JSON string as it is to the T container. And then, using the parser, you need to determine the type of the JSON element and deserialize it accordingly.  In the example below, we try to read an array of numbers [1, ‚Äú2‚Äù, [3]] increment all elements and serialize it, keeping the format: <br><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;wjson/json.hpp&gt; #include &lt;wjson/strerror.hpp&gt; #include &lt;iostream&gt; int main() { typedef std::vector&lt; std::string &gt; vect_t; typedef ::wjson::array&lt; std::vector&lt; ::wjson::raw_value&lt;std::string&gt; &gt; &gt; vect_json; vect_t inv; vect_t outv; std::string json = "[1,\"2\",[3]]"; std::cout &lt;&lt; json &lt;&lt; std::endl; vect_json::serializer()( inv, json.begin(), json.end(), 0 ); for ( auto&amp; v : inv ) { outv.push_back(""); if ( wjson::parser::is_number(v.begin(), v.end()) ) { int num = 0; wjson::value&lt;int&gt;::serializer()( num, v.begin(), v.end(), 0); ++num; wjson::value&lt;int&gt;::serializer()( num, std::back_inserter(outv.back()) ); } else if ( wjson::parser::is_string(v.begin(), v.end()) ) { std::string snum; wjson::value&lt;std::string&gt;::serializer()( snum, v.begin(), v.end(), 0); int num = 0; wjson::value&lt;int&gt;::serializer()( num, snum.begin(), snum.end(), 0); ++num; snum.clear(); wjson::value&lt;int&gt;::serializer()( num, std::back_inserter(snum) ); wjson::value&lt;std::string&gt;::serializer()( snum, std::back_inserter(outv.back()) ); } else if ( wjson::parser::is_array(v.begin(), v.end()) ) { std::vector&lt;int&gt; vnum; wjson::array&lt; std::vector&lt; wjson::value&lt;int&gt; &gt; &gt;::serializer()( vnum, v.begin(), v.end(), 0); ++vnum[0]; wjson::array&lt; std::vector&lt; wjson::value&lt;int&gt; &gt; &gt;::serializer()( vnum, std::back_inserter(outv.back()) ); } else { outv.back()="null"; } } json.clear(); vect_json::serializer()( outv, std::back_inserter(json) ); std::cout &lt;&lt; json &lt;&lt; std::endl; }</span></span></span></span></code> </pre><br></div></div><br>  Result: <br><pre> <code class="bash hljs">[1,<span class="hljs-string"><span class="hljs-string">"2"</span></span>,[3]] [2,<span class="hljs-string"><span class="hljs-string">"3"</span></span>,[4]]</code> </pre><br>  It also works with objects and dictionaries, which will be discussed further.  If the numbers you can be represented by only two options, a string or, in fact, a number, then you can use a wrapper: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> J, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> SerQ = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ReqQ = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> R = <span class="hljs-number"><span class="hljs-number">-1</span></span>&gt; struct quoted;</code> </pre><br><ul><li>  J - original JSON description </li><li>  SerQ - pre-serialize to string </li><li>  ReqQ - JSON input must be a "string" </li><li>  R reserve for intermediate buffer (line) </li></ul><br>  In fact, this construction works for any JSON description.  The SerQ parameter enables dual serialization.  For example, for numbers, this simply means framing in quotes.  The ReqQ parameter includes dual de-serialization, i.e.  it requires a JSON string at the input.  If it is turned off, then the rules are a little more complicated.  If the input is not a JSON string, then it simply starts the J deserializer without first deserializing it.  If the input is a JSON string, then it deserializes into an intermediate std :: string.  If J describes a non-string entity, then re-serialize from intermediate std :: string.  For string entities, determine the need for re-deserialization.  This means that if, after the first deserialization, the intermediate line begins with a quotation mark, then it is a double-serialized string and deserialized again, otherwise just copy. <br><br>  It is clear that wjson :: quoted &lt;&gt; gives an additional overhead and should be considered as a temporary crutch, in case, for whatever reason, the client began to ‚Äúfreak out‚Äù and serialize numbers with terms or do double serialization of nested objects. <br></div></div><br><br><h4>  Parser </h4><br>  In wjson, there is a class parser, which contains only static methods that can be divided into two types.  This is a test for compliance with one or another JSON type and, accordingly, the methods are parsers.  For each JSON type there is a method: <br><br><div class="spoiler">  <b class="spoiler_title">list of methods</b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parser</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> P </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_space</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( P beg, P end, json_error* e)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> P </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_null</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( P beg, P end, json_error* e )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> P </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( P beg, P end, json_error* e )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> P </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_number</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( P beg, P end, json_error* e )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> P </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( P beg, P end, json_error* e )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> P </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( P beg, P end, json_error* e )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> P </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( P beg, P end, json_error* e )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> P </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( P beg, P end, json_error* e )</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> };</code> </pre><br></div></div><br>  As well as for the deserializer, here beg is the beginning of the buffer, the end-end of the buffer, and in ‚Äúe‚Äù, if not equal to nullptr, the error code will be written.  If successful, a pointer will be returned to the character following the last character of the current entity.  And in case of an error, end will be returned, and e will be initialized. <br><br>  Suppose you have a string with several JSON objects of a certain structure that are separated by a newline or other whitespace entities, then you can work it out (without error handling): <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;beg!=end;) { beg = wjson::parser::parse_space(beg, end, <span class="hljs-number"><span class="hljs-number">0</span></span>); beg=my_json::serializer()(dict, beg, end, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* ‚Ä¶. */</span></span> }</code> </pre><br>  All serializers assume that the first character should be the character of the object being deserialized, otherwise there will be an error.  But, as I said, there can be whitespace characters inside the objects and arrays, including comments that the deserializer parses with the same parse_space.  An example of parsing a string with several JSON entities: <br><pre> <code class="cpp hljs">wjson::json_error e; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;beg!=end;) { beg = wjson::parser::parse_space(beg, end, &amp;e); beg = wjson::parser::parse_value(beg, end, &amp;e); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( e ) <span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); }</code> </pre><br>  Here parse_value checks any JSON entity for validity.  If the input parse_space is not a whitespace, it will simply return beg.  It may return an error if, for example, an unclosed C-style comment is detected, but additional verification is redundant here.  If an initialized error object arrives at the parser (as well as the deserializer), then it simply returns end. <br><br>  To define a specific JSON entity, there is the following set of methods: <br><br><div class="spoiler">  <b class="spoiler_title">list of methods</b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parser</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_space</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( P beg, P end )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_null</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( P beg, P end )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( P beg, P end )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_number</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( P beg, P end )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( P beg, P end )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( P beg, P end )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( P beg, P end )</span></span></span></span>; };</code> </pre><br></div></div><br>  Despite the fact that they receive pointers to the beginning and end of the buffer, these methods determine the essence by the first character: {is an object, [is an array, ‚Äúis a string, any digit is a number, and t, f or n is true , false or null, respectively.  Therefore, if, for example, is_object, returns true to us, then to make sure that this is a valid object, you need to call parse_object and check that there are no errors. <br><br><h4>  Error processing </h4><br>  It is almost always necessary to check errors during deserialization.  In the examples, I do not do this solely for clarity.  Consider an example where a foreign character is embedded in the source array: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;wjson/json.hpp&gt; #include &lt;wjson/strerror.hpp&gt; #include &lt;iostream&gt; int main() { typedef wjson::array&lt; std::vector&lt; wjson::value&lt;int&gt; &gt; &gt;::serializer serializer_t; std::vector&lt; int &gt; value; std::string json = "[1,2,3}5,6]"; wjson::json_error e; serializer_t()(value, json.begin(), json.end(), &amp;e ); if ( e ) { std::cout &lt;&lt; "Error code: " &lt;&lt; e.code() &lt;&lt; std::endl; std::cout &lt;&lt; "Error tail of: " &lt;&lt; e.tail_of() &lt;&lt; std::endl; if ( e.type() == wjson::error_code::ExpectedOf ) std::cout &lt;&lt; "Error expected_of: " &lt;&lt; e.expected_of() &lt;&lt; std::endl; std::cout &lt;&lt; "Error position: " &lt;&lt; wjson::strerror::where(e, json.begin(), json.end() ) &lt;&lt; std::endl; std::cout &lt;&lt; "Error message: " &lt;&lt; wjson::strerror::message(e) &lt;&lt; std::endl; std::cout &lt;&lt; "Error trace: " &lt;&lt; wjson::strerror::trace(e, json.begin(), json.end()) &lt;&lt; std::endl; std::cout &lt;&lt; "Error message &amp; trace: " &lt;&lt; wjson::strerror::message_trace(e, json.begin(), json.end()) &lt;&lt; std::endl; } }</span></span></span></span></code> </pre><br>  Actually, the object of the error wjson :: json_error contains information about the error code and the position relative to the end of the buffer where the parser has detected any inconsistency.  For the special errors of the ‚ÄúExpected of‚Äù type, the symbol he expected. <br><br>  To get readable messages, use the wjson :: strerror class.  In the example above, the symbol} is found in the JSON array, and the parser expects a comma (or a square bracket), which is what it says.  The example shows all available methods for analyzing the error.  The result is as follows: <br><pre> <code class="bash hljs"> Error code: 3 Error tail of: 5 Error expected_of: , Error position: 6 Error message: Expected Of <span class="hljs-string"><span class="hljs-string">','</span></span> Error trace: [1,2,3&gt;&gt;&gt;}5,6] Error message &amp; trace: Expected Of <span class="hljs-string"><span class="hljs-string">','</span></span>: [1,2,3&gt;&gt;&gt;}5,6]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, you can get not only the error code, readable message, but also the place where it occurred. </font><font style="vertical-align: inherit;">The trace uses the combination ‚Äú&gt;&gt;&gt;‚Äù.</font></font><br><br><h3> <font color="#FFA500"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JSON Objects</font></font></b></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deserializing JSON objects directly into data structures is what wjson was designed for. </font><font style="vertical-align: inherit;">Consider a simple structure:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> flag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Which needs to be serialized in JSON type: </font></font><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"flag"</span></span>:<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>:<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-attr"><span class="hljs-attr">"string"</span></span>:<span class="hljs-string"><span class="hljs-string">" !"</span></span>}</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A JSON object is simply an enumeration of a list of fields that consist of a name and a value (any JSON), separated by a colon. </font><font style="vertical-align: inherit;">To serialize a separate field, copy the name that is known at the compilation stage, add a colon, and serialize the value. </font><font style="vertical-align: inherit;">This concept is implemented by the construction:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M, MT::* m, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> J = value&lt;M&gt; &gt; struct member;</code> </pre><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N - field name </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> T - structure type </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> M - field type </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> m - pointer to the structure field </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> J - JSON field description </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But explicitly passing strings to template parameters is problematic. </font><font style="vertical-align: inherit;">Therefore, we use the following trick. </font><font style="vertical-align: inherit;">For each name of the structure field we will create a structure of the form:</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">name for flag</font></font></b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n_flag</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ‚Äúflag‚Äù; } };</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Which we will be able to pass the template parameter. </font><font style="vertical-align: inherit;">Of course, to produce such structures for each name is not very convenient, so the rare case when I allowed myself a macro substitution. </font><font style="vertical-align: inherit;">To do this, you can use the macro:</font></font><br><pre> <code class="cpp hljs">JSON_NAME(flag)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which will create about the same structure. </font><font style="vertical-align: inherit;">The prefix n_ is used for historical reasons. </font><font style="vertical-align: inherit;">But if you do not like it, you can use the second option:</font></font><br><pre> <code class="cpp hljs">JSON_NAME2(n_flag, ‚Äúflag‚Äù)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which allows you to create a structure with an arbitrary name and string. </font><font style="vertical-align: inherit;">An example to describe a separate field:</font></font><br><pre> <code class="cpp hljs">wjson::member&lt; n_flag, foo, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, &amp;foo::flag&gt;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For simple types, the JSON description (wjson :: value &lt;&gt;) can be omitted, but for all others it is required. </font><font style="vertical-align: inherit;">By itself, the serialization of the structure field does not make much sense, so you need to combine the descriptions of all the fields into a list as follows:</font></font><br><pre> <code class="cpp hljs">wjson::member_list&lt; wjson::member&lt;n_flag, foo, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, &amp;foo::flag&gt;, wjson::member&lt;n_value, foo, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, &amp;foo::value&gt;, wjson::member&lt;n_string, foo, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, &amp;foo::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For C ++ 11, the number of fields is unlimited; for C ++ 03, the limit is 26 elements, which is easy to get around using the nested member_list. </font><font style="vertical-align: inherit;">The rules for serializing a JSON object into structures are given by the construction:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T target; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> implementation_defined serializer; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> implementation_defined member_list; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here T is the data structure type, and L is the list of fields to be serialized (member_list). </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of serializing and deserializing a JSON object</font></font></b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;wjson/json.hpp&gt; #include &lt;wjson/strerror.hpp&gt; #include &lt;iostream&gt; struct foo { bool flag = false; int value = 0; std::string string; }; JSON_NAME(flag) JSON_NAME(value) JSON_NAME(string) typedef wjson::object&lt; foo, wjson::member_list&lt; wjson::member&lt;n_flag, foo,bool, &amp;foo::flag&gt;, wjson::member&lt;n_value, foo,int, &amp;foo::value&gt;, wjson::member&lt;n_string, foo,std::string, &amp;foo::string&gt; &gt; &gt; foo_json; int main() { std::string json="{\"flag\":false,\"value\":0,\"string\":\" \"}"; foo f; foo_json::serializer()( f, json.begin(), json.end(), nullptr ); f.flag = true; f.string = " "; std::cout &lt;&lt; json &lt;&lt; std::endl; foo_json::serializer()( f, std::ostream_iterator&lt;char&gt;(std::cout) ); }</span></span></span></span></code> </pre><br></div></div><br>  Result: <br><pre> <code class="hljs json">{<span class="hljs-attr"><span class="hljs-attr">"flag"</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>,<span class="hljs-attr"><span class="hljs-attr">"value"</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-attr"><span class="hljs-attr">"string"</span></span>:<span class="hljs-string"><span class="hljs-string">" "</span></span>} {<span class="hljs-attr"><span class="hljs-attr">"flag"</span></span>:<span class="hljs-literal"><span class="hljs-literal">true</span></span>,<span class="hljs-attr"><span class="hljs-attr">"value"</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-attr"><span class="hljs-attr">"string"</span></span>:<span class="hljs-string"><span class="hljs-string">" "</span></span>}</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What I would like to draw your attention to: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There is no mention in the source structure (foo) that it is persistent. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fields are serialized exactly in the order they are described in member_list. </font></font></li><li>   JSON         ,   member_list </li><li>      .     </li><li>      JSON  </li><li>  member_list          </li><li>  ,      (       ) </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the order of fields in the input JSON coincides with the order in the JSON description, then deserialization occurs as quickly as possible, in fact, in one pass. Field omissions or extra items do not greatly affect performance (they are simply ignored). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But what happens if the fields in JSON come in a random order? Of course, this affects the performance, because the parser gets off and starts searching the fields from the beginning. But I recommend not to bother with the topic of field ordering at all.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even before the moment when it really begins to be felt, you will encounter a problem not of de-serialization time, but of JSON redundancy, and you will need to think about changing the format of data exchange. </font><font style="vertical-align: inherit;">This does not necessarily mean switching to binary protocols. </font><font style="vertical-align: inherit;">For example, you can transfer objects in the form of JSON arrays, in which the position rigidly corresponds to some field of the structure. </font><font style="vertical-align: inherit;">In particular cases, when many zeros are transmitted, such a format can be both smaller and faster than protobuf. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Not to be unsubstantiated, I drove the deserialization of the following structure into performance:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> field1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> field2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> field3 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; field5; };</code> </pre><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JSON description for foo</font></font></b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"> JSON_NAME(field1) JSON_NAME(field2) JSON_NAME(field3) JSON_NAME(field5) <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> wjson::object&lt; foo, wjson::member_list&lt; wjson::member&lt;n_field1, foo, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, &amp;foo::field1&gt;, wjson::member&lt;n_field2, foo, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, &amp;foo::field2&gt;, wjson::member&lt;n_field3, foo, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, &amp;foo::field3&gt;, wjson::member&lt;n_field5, foo, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;, &amp;foo::field5, ::wjson::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; ::wjson::value&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; &gt; &gt; &gt; &gt; &gt; foo_json;</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With direct and inverse (most unsuccessful) sequences of fields in the input JSON. </font><font style="vertical-align: inherit;">But then I noticed that the names of the fields were chosen not quite honestly, because </font><font style="vertical-align: inherit;">match the last character, therefore also made a measurement for the variant:</font></font><br><pre> <code class="cpp hljs"> JSON_NAME2(n_field1, <span class="hljs-string"><span class="hljs-string">"1field"</span></span>) JSON_NAME2(n_field2, <span class="hljs-string"><span class="hljs-string">"2field"</span></span>) JSON_NAME2(n_field3, <span class="hljs-string"><span class="hljs-string">"3field"</span></span>) JSON_NAME2(n_field5, <span class="hljs-string"><span class="hljs-string">"5field"</span></span>)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when all fields are distinguished by the first character. </font><font style="vertical-align: inherit;">As a result, for JSON:</font></font><br><pre> <code class="hljs json">{<span class="hljs-attr"><span class="hljs-attr">"field1"</span></span>:<span class="hljs-number"><span class="hljs-number">12345</span></span>,<span class="hljs-attr"><span class="hljs-attr">"field2"</span></span>:<span class="hljs-number"><span class="hljs-number">23456</span></span>,<span class="hljs-attr"><span class="hljs-attr">"field3"</span></span>:<span class="hljs-number"><span class="hljs-number">34567</span></span>,<span class="hljs-attr"><span class="hljs-attr">"field5"</span></span>:[<span class="hljs-number"><span class="hljs-number">45678</span></span>,<span class="hljs-number"><span class="hljs-number">56789</span></span>,<span class="hljs-number"><span class="hljs-number">67890</span></span>,<span class="hljs-number"><span class="hljs-number">78901</span></span>,<span class="hljs-number"><span class="hljs-number">89012</span></span>]} {<span class="hljs-attr"><span class="hljs-attr">"5field"</span></span>:[<span class="hljs-number"><span class="hljs-number">45678</span></span>,<span class="hljs-number"><span class="hljs-number">56789</span></span>,<span class="hljs-number"><span class="hljs-number">67890</span></span>,<span class="hljs-number"><span class="hljs-number">78901</span></span>,<span class="hljs-number"><span class="hljs-number">89012</span></span>],<span class="hljs-attr"><span class="hljs-attr">"1field"</span></span>:<span class="hljs-number"><span class="hljs-number">12345</span></span>,<span class="hljs-attr"><span class="hljs-attr">"2field"</span></span>:<span class="hljs-number"><span class="hljs-number">23456</span></span>,<span class="hljs-attr"><span class="hljs-attr">"3field"</span></span>:<span class="hljs-number"><span class="hljs-number">34567</span></span>} {<span class="hljs-attr"><span class="hljs-attr">"field5"</span></span>:[<span class="hljs-number"><span class="hljs-number">45678</span></span>,<span class="hljs-number"><span class="hljs-number">56789</span></span>,<span class="hljs-number"><span class="hljs-number">67890</span></span>,<span class="hljs-number"><span class="hljs-number">78901</span></span>,<span class="hljs-number"><span class="hljs-number">89012</span></span>],<span class="hljs-attr"><span class="hljs-attr">"field1"</span></span>:<span class="hljs-number"><span class="hljs-number">12345</span></span>,<span class="hljs-attr"><span class="hljs-attr">"field2"</span></span>:<span class="hljs-number"><span class="hljs-number">23456</span></span>,<span class="hljs-attr"><span class="hljs-attr">"field3"</span></span>:<span class="hljs-number"><span class="hljs-number">34567</span></span>}</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Got the following results: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Serialization time: 151321 ns (6608468 persec), now it doesn't matter </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Deserialization for ‚Äúoptimal‚Äù JSON: 204113 ns (4899246 persec) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚ÄúWorse‚Äù order of fields with optimal names: 221140 ns (4522022 persec) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The ‚Äúworst‚Äù order of fields with ‚Äúbad‚Äù names: 237616 ns (4208470 persec) </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For clarity and to close the topic sprintf / sscanf, raised at the beginning of the article, I also measured the execution time of this design: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">sscanf</span></span>( str, <span class="hljs-string"><span class="hljs-string">"{\"field1\":%d,\"field2\":%d,\"field3\":%d,\"field5\":[%d,%d,%d,%d,%d]}"</span></span>, &amp;(f.field1), &amp;(f.field2), &amp;(f.field3), &amp;(f.field5[<span class="hljs-number"><span class="hljs-number">0</span></span>]), &amp;(f.field5[<span class="hljs-number"><span class="hljs-number">1</span></span>]), &amp;(f.field5[<span class="hljs-number"><span class="hljs-number">2</span></span>]),&amp;(f.field5[<span class="hljs-number"><span class="hljs-number">3</span></span>]), &amp;(f.field5[<span class="hljs-number"><span class="hljs-number">4</span></span>]) );</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is clear that here there can be no talk of full de-serialization - any discrepancy to the pattern can lead to disastrous results. Nevertheless, the result is 2477942 ns (403560 persec), which is ten times worse than that of wjson with all checks, with ‚Äúbad‚Äù order and ‚Äúnot successful‚Äù field names: </font></font><br><img src="https://habrastorage.org/files/46a/758/ece/46a758ece6764891a7ddf262c9029acb.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For those who could not believe their eyes and want to check These figures (which is commendable), without having read the article (and this is difficult for me to welcome), I will immediately warn you that this only works with optimization turned on. In debug mode, get the numbers exactly the opposite and even worse. You always have to sacrifice something.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The question in terms of the speed of serialization of such entities for me is already several years, but the problem of JSON redundancy sometimes pops up. </font><font style="vertical-align: inherit;">To solve this problem, it is possible to serialize the structure into an array, whose fields are rigidly tied to the index:</font></font><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> wjson::object_array&lt; foo, wjson::member_list&lt; wjson::member_array&lt;foo, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, &amp;foo::field1&gt;, wjson::member_array&lt;foo, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, &amp;foo::field2&gt;, wjson::member_array&lt;foo, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, &amp;foo::field3&gt;, wjson::member_array&lt;foo, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;, &amp;foo::field5, ::wjson::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; ::wjson::value&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; &gt; &gt; &gt; &gt; &gt; foo_json;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As a result, the same structure is serialized into an array: </font></font><br><pre> <code class="hljs json">[<span class="hljs-number"><span class="hljs-number">12345</span></span>,<span class="hljs-number"><span class="hljs-number">23456</span></span>,<span class="hljs-number"><span class="hljs-number">34567</span></span>,[<span class="hljs-number"><span class="hljs-number">45678</span></span>,<span class="hljs-number"><span class="hljs-number">56789</span></span>,<span class="hljs-number"><span class="hljs-number">67890</span></span>,<span class="hljs-number"><span class="hljs-number">78901</span></span>,<span class="hljs-number"><span class="hljs-number">89012</span></span>]]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for 139856 ns (7150211 persec), and deserialization occurs for 131282 ns (7617190) </font></font><br><img src="https://habrastorage.org/files/a76/c3f/b20/a76c3fb207b240509ca52739a07ddea0.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yes, there is a difference in speed, but first of all it is more compact. </font><font style="vertical-align: inherit;">In one of the projects, in which the server returns data for plotting, where each point is described by eight fields, of which there are about 3000 for each graph, and there can be several dozen graphs on the screen, the resulting JSON could be several megabytes. </font><font style="vertical-align: inherit;">Serializing the initial structures into arrays of eight elements, we not only significantly reduce the volume of transmitted traffic, but also increase its readability. </font><font style="vertical-align: inherit;">But, in general, of course, translating all APIs into arrays is not the best idea.</font></font><br><br><h4>  Inheritance </h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Consider inheritance on the example of the following structures: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> flag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bar</span></span></span><span class="hljs-class">:</span></span> foo { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; data; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There are two ways to describe inheritance. Option one: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ::wjson::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; ::wjson::value&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; &gt; &gt; vint_json; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> wjson::object&lt; bar, wjson::member_list&lt; wjson::member&lt;n_flag, foo,<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, &amp;foo::flag&gt;, wjson::member&lt;n_value, foo,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, &amp;foo::value&gt;, wjson::member&lt;n_string, foo,<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, &amp;foo::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;, wjson::member&lt;n_data, bar, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;, &amp;bar::data, vint_json&gt; &gt; &gt; bar_json;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we can position the fields of the parent (or parents) and the heir in any order. </font><font style="vertical-align: inherit;">Option two, more visual:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> wjson::object&lt; foo, wjson::member_list&lt; wjson::member&lt;n_flag, foo,<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, &amp;foo::flag&gt;, wjson::member&lt;n_value, foo,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, &amp;foo::value&gt;, wjson::member&lt;n_string, foo,<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, &amp;foo::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; &gt; &gt; foo_json; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> wjson::object&lt; bar, wjson::member_list&lt; wjson::base&lt;foo_json&gt;, wjson::member&lt;n_data, bar, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;, &amp;bar::data, vint_json&gt; &gt; &gt; bar_json;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We make a separate JSON description for the base class and implement it using the wjson :: base &lt;foo_json&gt; construct, which is a pseudonym for foo_json :: member_list, anywhere in the list. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Great example, with all the elements</font></font></b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;wjson/json.hpp&gt; #include &lt;wjson/strerror.hpp&gt; #include &lt;iostream&gt; struct foo { bool flag = false; int value = 0; std::string string; }; struct bar: foo { std::shared_ptr&lt;foo&gt; pfoo; std::vector&lt;foo&gt; vfoo; }; struct foo_json { JSON_NAME(flag) JSON_NAME(value) JSON_NAME(string) typedef wjson::object&lt; foo, wjson::member_list&lt; wjson::member&lt;n_flag, foo,bool, &amp;foo::flag&gt;, wjson::member&lt;n_value, foo,int, &amp;foo::value&gt;, wjson::member&lt;n_string, foo,std::string, &amp;foo::string&gt; &gt; &gt; type; typedef type::serializer serializer; typedef type::target target; typedef type::member_list member_list; }; struct bar_json { JSON_NAME(pfoo) JSON_NAME(vfoo) typedef wjson::array&lt; std::vector&lt; foo_json &gt; &gt; vfoo_json; typedef wjson::pointer&lt; std::shared_ptr&lt;foo&gt;, foo_json &gt; pfoo_json; typedef wjson::object&lt; bar, wjson::member_list&lt; wjson::base&lt;foo_json&gt;, wjson::member&lt;n_vfoo, bar, std::vector&lt;foo&gt;, &amp;bar::vfoo, vfoo_json&gt;, wjson::member&lt;n_pfoo, bar, std::shared_ptr&lt;foo&gt;, &amp;bar::pfoo, pfoo_json&gt; &gt; &gt; type; typedef type::serializer serializer; typedef type::target target; typedef type::member_list member_list; }; int main() { std::string json="{\"flag\":true,\"value\":0,\"string\":\" \",\"vfoo\":[],\"pfoo\":null}"; bar b; bar_json::serializer()( b, json.begin(), json.end(), nullptr ); b.flag = true; b.vfoo.push_back( static_cast&lt;const foo&amp;&gt;(b)); b.pfoo = std::make_shared&lt;foo&gt;(static_cast&lt;const foo&amp;&gt;(b)); std::cout &lt;&lt; json &lt;&lt; std::endl; bar_json::serializer()(b, std::ostream_iterator&lt;char&gt;(std::cout) ); std::cout &lt;&lt; std::endl; }</span></span></span></span></code> </pre><br></div></div><br>  Result: <br><pre> <code class="hljs json">{<span class="hljs-attr"><span class="hljs-attr">"flag"</span></span>:<span class="hljs-literal"><span class="hljs-literal">true</span></span>,<span class="hljs-attr"><span class="hljs-attr">"value"</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-attr"><span class="hljs-attr">"string"</span></span>:<span class="hljs-string"><span class="hljs-string">" "</span></span>,<span class="hljs-attr"><span class="hljs-attr">"vfoo"</span></span>:[],<span class="hljs-attr"><span class="hljs-attr">"pfoo"</span></span>:<span class="hljs-literal"><span class="hljs-literal">null</span></span>} {<span class="hljs-attr"><span class="hljs-attr">"flag"</span></span>:<span class="hljs-literal"><span class="hljs-literal">true</span></span>,<span class="hljs-attr"><span class="hljs-attr">"value"</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-attr"><span class="hljs-attr">"string"</span></span>:<span class="hljs-string"><span class="hljs-string">" "</span></span>,<span class="hljs-attr"><span class="hljs-attr">"vfoo"</span></span>:[{<span class="hljs-attr"><span class="hljs-attr">"flag"</span></span>:<span class="hljs-literal"><span class="hljs-literal">true</span></span>,<span class="hljs-attr"><span class="hljs-attr">"value"</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-attr"><span class="hljs-attr">"string"</span></span>:<span class="hljs-string"><span class="hljs-string">" "</span></span>}],<span class="hljs-attr"><span class="hljs-attr">"pfoo"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"flag"</span></span>:<span class="hljs-literal"><span class="hljs-literal">true</span></span>,<span class="hljs-attr"><span class="hljs-attr">"value"</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-attr"><span class="hljs-attr">"string"</span></span>:<span class="hljs-string"><span class="hljs-string">" "</span></span>}}</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is a slightly different description of JSON objects, but first about pointers. </font><font style="vertical-align: inherit;">You can serialize any pointers. </font><font style="vertical-align: inherit;">If it is zero, then it is serialized as null, otherwise by value. </font><font style="vertical-align: inherit;">And deserialization is implemented only for std :: shared_ptr &lt;&gt;. </font><font style="vertical-align: inherit;">If in JSON is null, then this is nullptr, otherwise an object is created and deserialization occurs into it. </font><font style="vertical-align: inherit;">For any elements that we did not describe as wjson :: pointer, if null is input, then it is created with the default value. </font><font style="vertical-align: inherit;">This also applies to arrays and simple types.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why screen template classes with a large number of parameters</font></font></b> <div class="spoiler_text"><br>  JSON- ,    ,     .        ,   ,        . ,    : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> J&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">deserealizer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> J::deserializer type; };</code> </pre><br>      : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> deserealizer&lt;bar_json&gt;::type deser;</code> </pre><br>  Since  deserializer     ,   : <br><pre> <code class="bash hljs">error: no <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> named <span class="hljs-string"><span class="hljs-string">'deserializer'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">'struct bar_json'</span></span></code> </pre><br>  foo_json  bar_json   typedef, : <br><pre> <code class="bash hljs">error: no <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> named <span class="hljs-string"><span class="hljs-string">'deserializer'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">'struct wjson::object&lt;bar, fas::type_list&lt;wjson::member&lt;n_flag, foo, bool, &amp;foo::flag&gt;, fas::type_list&lt;wjson::member&lt;n_value, foo, int, &amp;foo::value&gt;, fas::type_list&lt;wjson::member&lt;n_string, foo, std::basic_string&lt;char&gt;, &amp;foo::string&gt;, fas::type_list&lt;wjson::member&lt;n_vfoo, bar, std::vector&lt;foo&gt;, &amp;bar::vfoo, wjson::array&lt;std::vector&lt;wjson::object&lt;foo, fas::type_list&lt;wjson::member&lt;n_flag, foo, bool, &amp;foo::flag&gt;, fas::type_list&lt;wjson::member&lt;n_value, foo, int, &amp;foo::value&gt;, fas::type_list&lt;wjson::member&lt;n_string, foo, std::basic_string&lt;char&gt;, &amp;foo::string&gt;, fas::empty_list&gt; &gt; &gt; &gt; &gt; &gt; &gt;, fas::type_list&lt;wjson::member&lt;n_pfoo, bar, std::shared_ptr&lt;foo&gt;, &amp;bar::pfoo, wjson::pointer&lt;std::shared_ptr&lt;foo&gt;, wjson::object&lt;foo, fas::type_list&lt;wjson::member&lt;n_flag, foo, bool, &amp;foo::flag&gt;, fas::type_list&lt;wjson::member&lt;n_value, foo, int, &amp;foo::value&gt;, fas::type_list&lt;wjson::member&lt;n_string, foo, std::basic_string&lt;char&gt;, &amp;foo::string&gt;, fas::empty_list&gt; &gt; &gt; &gt; &gt; &gt;, fas::empty_list&gt; &gt; &gt; &gt; &gt; &gt;'</span></span></code> </pre><br>  ,  .       ,   ,      .,             ,     typeid(T).name(). ,   ,      ,   ,      .            , , : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> J&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">deserealizer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">:</span></span> J::deserializer {}; };</code> </pre><br>      ,       .     .        ,              ,   ,     (  ). <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Well and, of course, no one bothers to make the same foo_json template and pass as a parameter, for example, the type of the value field, which can be used to serialize template structures. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dictionaries </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dictionaries are needed to serialize associative arrays (key-value), for example, std :: map &lt;&gt;. </font><font style="vertical-align: inherit;">Most JSON libraries work according to this scheme ‚Äî an object is deserialized into a tree, and then you examine it, search for the required fields, etc. </font><font style="vertical-align: inherit;">And for serialization you need to dynamically fill it. </font><font style="vertical-align: inherit;">From the point of view of performance is not the most effective method. </font><font style="vertical-align: inherit;">Therefore, before using that std :: map &lt;&gt; in data structures, consider whether it is possible somehow without it. </font><font style="vertical-align: inherit;">Of course, this is not the case if you use JSON for configuration:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> R = <span class="hljs-number"><span class="hljs-number">-1</span></span>&gt; struct dict { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> implementation_defined target; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> implementation_defined serializer; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here, the concept is the same as for arrays - T is an associative stl container, which has JSON descriptions for the key and value as parameters. </font></font> For example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> wjson::dict&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt; wjson::value&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;, wjson::value&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; &gt; &gt; dict_json;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be used to serialize std :: map &lt;std :: string, int&gt;. </font><font style="vertical-align: inherit;">The construction is rather complicated, but given the fact that strings are used as the key most often, there is a simpler option for std :: map &lt;std :: string, JSON&gt;:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> wjson::dict_map&lt; wjson::value&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; &gt; dict_json;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, any JSON entity described earlier in this article can be used as a value. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The R parameter defines the size of the reserve for consecutive containers of pairs of the type std :: vector &lt;std :: pair &lt;&gt;&gt; or std :: deque &lt;std :: pair &lt;&gt;&gt;. </font><font style="vertical-align: inherit;">To describe a key-value pair, the field construction is used:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> K, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> V&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field</span></span></span><span class="hljs-class">;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here K and V are JSON descriptions of the key and value, respectively. </font></font> For example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> wjson::dict&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; wjson::field&lt; wjson::value&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;, wjson::value&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; &gt; &gt;, <span class="hljs-number"><span class="hljs-number">128</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> &gt; dict_json;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to serialize the vector pairs std :: vector &lt;std :: pair &lt;std :: string, int&gt;&gt;. This design can be used where high de-serialization is needed. The steam vector is filled much faster than std :: map (of course, if the necessary reserve was made). This design is even more complicated, and is used more often, so for it there is a simple option:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> wjson::dict_vector&lt; ::wjson::value&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; &gt; dict_json; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> wjson::dict_deque&lt; ::wjson::value&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; &gt; dict_json;</code> </pre><br><br>  For example: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; &gt; dict; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> wjson::dict_vector&lt; wjson::value&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; &gt; dict_json; dict d; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> json = <span class="hljs-string"><span class="hljs-string">"{\"\":1,\"\":2,\"\":3}"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; json &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; dict_json::serializer()( d, json.begin(), json.end(), <span class="hljs-number"><span class="hljs-number">0</span></span> ); d.push_back( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_pair(<span class="hljs-string"><span class="hljs-string">""</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>)); json.clear(); dict_json::serializer()( d, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter(json) ); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; json &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br>  Result: <br><pre> <code class="hljs json">{<span class="hljs-attr"><span class="hljs-attr">""</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-attr"><span class="hljs-attr">""</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-attr"><span class="hljs-attr">""</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>} {<span class="hljs-attr"><span class="hljs-attr">""</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-attr"><span class="hljs-attr">""</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-attr"><span class="hljs-attr">""</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-attr"><span class="hljs-attr">""</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>}</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dictionaries are useful for configurations. </font><font style="vertical-align: inherit;">In the simplest case, it is a simple key-value array, where the key will contain the name of the configured component. </font><font style="vertical-align: inherit;">But if you don‚Äôt be lazy, put the component configuration into a separate structure and make a JSON description for it, then you will get rid of unnecessary runtime code, and, therefore, of initialization error handles. </font><font style="vertical-align: inherit;">In addition, you can generate a configuration with the current set of fields to the delight of yourself (at the design stage) and the user, so that he can be convinced of the relevance of the documentation, which tends to become obsolete.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enumerations and Flags </font></font></h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It makes sense to serialize enumerations in their textual representation for the same reason why textual data presentation formats were created in general - this is readability. </font><font style="vertical-align: inherit;">If you do not abuse the long names, it can turn out at least no slower than serialization as a number and is not very expensive in size. </font><font style="vertical-align: inherit;">If you have read this line, then, most likely, the overall concept is generally understandable, so for example at once:</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enum serialization example</font></font></b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;wjson/json.hpp&gt; #include &lt;wjson/strerror.hpp&gt; #include &lt;iostream&gt; struct counter { typedef enum { one = 1, four = 4, five = 5, two = 2, three = 3, six = 6 } type; }; struct counter_json { JSON_NAME(one) JSON_NAME(two) JSON_NAME(three) JSON_NAME(four) JSON_NAME(five) JSON_NAME2(n_six, " !") typedef wjson::enumerator&lt; counter::type, wjson::member_list&lt; wjson::enum_value&lt; n_one, counter::type, counter::one&gt;, wjson::enum_value&lt; n_two, counter::type, counter::two&gt;, wjson::enum_value&lt; n_three,counter::type, counter::three&gt;, wjson::enum_value&lt; n_four, counter::type, counter::four&gt;, wjson::enum_value&lt; n_five, counter::type, counter::five&gt;, wjson::enum_value&lt; n_six, counter::type, counter::six&gt; &gt; &gt; type; typedef type::serializer serializer; typedef type::target target; typedef type::member_list member_list; }; int main() { typedef wjson::array&lt; std::vector&lt; counter_json &gt; &gt; array_counter_json; std::vector&lt; counter::type &gt; cl; std::string json = "[\"one\",\"two\",\"three\"]"; std::cout &lt;&lt; json &lt;&lt; std::endl; array_counter_json::serializer()( cl, json.begin(), json.end(), 0 ); cl.push_back(counter::four); cl.push_back(counter::five); cl.push_back(counter::six); array_counter_json::serializer()(cl, std::ostream_iterator&lt;char&gt;(std::cout) ); std::cout &lt;&lt; std::endl; }</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As shown in the example, enumerations are not necessarily serialized one-on-one, but you can in an arbitrary string. </font></font> Result: <br><pre> <code class="hljs json">[<span class="hljs-string"><span class="hljs-string">"one"</span></span>,<span class="hljs-string"><span class="hljs-string">"two"</span></span>,<span class="hljs-string"><span class="hljs-string">"three"</span></span>] [<span class="hljs-string"><span class="hljs-string">"one"</span></span>,<span class="hljs-string"><span class="hljs-string">"two"</span></span>,<span class="hljs-string"><span class="hljs-string">"three"</span></span>,<span class="hljs-string"><span class="hljs-string">"four"</span></span>,<span class="hljs-string"><span class="hljs-string">"five"</span></span>,<span class="hljs-string"><span class="hljs-string">" !"</span></span>]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, the enums here are just for convenience, and you can use any integer types. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider this JSON:</font></font><br><pre> <code class="hljs json">{<span class="hljs-attr"><span class="hljs-attr">"code"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-attr"><span class="hljs-attr">"message"</span></span>:<span class="hljs-string"><span class="hljs-string">"Invalid JSON."</span></span>}</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is some kind of JSON-RPC error message. </font><font style="vertical-align: inherit;">Obviously, the message message is directly related to the code. </font><font style="vertical-align: inherit;">Therefore, there is no need to create a structure with a text field and fill it in; it is enough:</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Two in one and not even enum</font></font></b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;wjson/json.hpp&gt; #include &lt;wjson/strerror.hpp&gt; #include &lt;iostream&gt; enum class error_code { ValidJSON = 0, InvalidJSON = 1, ParseError = 2 }; struct error { int code = 0; }; struct code_json { JSON_NAME2(ValidJSON, "Valid JSON.") JSON_NAME2(InvalidJSON, "Invalid JSON.") JSON_NAME2(ParseError, "Parse Error.") typedef wjson::enumerator&lt; int, wjson::member_list&lt; wjson::enum_value&lt; ValidJSON, int, static_cast&lt;int&gt;(error_code::ValidJSON)&gt;, wjson::enum_value&lt; InvalidJSON, int, static_cast&lt;int&gt;(error_code::InvalidJSON)&gt;, wjson::enum_value&lt; ParseError, int, static_cast&lt;int&gt;(error_code::ParseError)&gt; &gt; &gt; type; typedef type::serializer serializer; typedef type::target target; typedef type::member_list member_list; }; struct error_json { JSON_NAME(code) JSON_NAME(message) typedef wjson::object&lt; error, wjson::member_list&lt; wjson::member&lt; n_code, error, int, &amp;error::code&gt;, wjson::member&lt; n_message, error, int, &amp;error::code, code_json&gt; &gt; &gt; type; typedef type::serializer serializer; typedef type::target target; typedef type::member_list member_list; }; int main() { error e; e.code = static_cast&lt;int&gt;(error_code::InvalidJSON); error_json::serializer()(e, std::ostream_iterator&lt;char&gt;(std::cout) ); std::cout &lt;&lt; std::endl; }</span></span></span></span></code> </pre><br></div></div><br>  Result: <br><pre> <code class="hljs json">{<span class="hljs-attr"><span class="hljs-attr">"code"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-attr"><span class="hljs-attr">"message"</span></span>:<span class="hljs-string"><span class="hljs-string">"Invalid JSON."</span></span>}</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serialization looks quite funny, but what about deserialization? </font><font style="vertical-align: inherit;">It turns out that ‚Äúcode‚Äù is deserialized twice: once from the ‚Äúcode‚Äù field, and the second time from the ‚Äúmessage‚Äù field. </font><font style="vertical-align: inherit;">You can make a separate error_json variant specifically for deserialization without the ‚Äúmessage‚Äù field, but this will not have a significant impact on performance, since it will always be parsed during serialization. </font><font style="vertical-align: inherit;">And you can use this feature to double check that the code is strictly consistent. </font><font style="vertical-align: inherit;">For example, if you replace the point in the message with a question mark:</font></font><br><pre> <code class="cpp hljs"> e = error(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> json = <span class="hljs-string"><span class="hljs-string">"{\"code\":1,\"message\":\"Invalid JSON?\"}"</span></span>; wjson::json_error ec; error_json::serializer()(e, json.begin(), json.end(), &amp;ec );</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then we get an error: </font></font><br><pre> <code class="cpp hljs">Invalid Enum: {<span class="hljs-string"><span class="hljs-string">"code"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"message"</span></span>:<span class="hljs-string"><span class="hljs-string">"&gt;&gt;&gt;Invalid JSON?"</span></span>}</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Often, enumerations are used for various flag combinations, they can also be serialized. </font><font style="vertical-align: inherit;">But in what form? </font><font style="vertical-align: inherit;">Two methods are proposed: in the form of an array or in the form of a string with a specified separator. </font><font style="vertical-align: inherit;">The delimiter is specified by the last flags parameter. </font><font style="vertical-align: inherit;">Any character except a comma will be serialized to a string, and for a comma to an array. </font><font style="vertical-align: inherit;">In the humorous example below, both options are used:</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">my grandmother had a gray goat</font></font></b> <div class="spoiler_text"><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;wjson/json.hpp&gt; #include &lt;wjson/strerror.hpp&gt; #include &lt;iostream&gt; template&lt;char S&gt; struct flags_json { JSON_NAME2(w1, "") JSON_NAME2(w2, "") JSON_NAME2(w4, "") JSON_NAME2(w8, "") JSON_NAME2(w16, "") JSON_NAME2(w32, "") typedef ::wjson::flags&lt; int, wjson::member_list&lt; wjson::enum_value&lt; w1, int, 1&gt;, wjson::enum_value&lt; w2, int, 2&gt;, wjson::enum_value&lt; w4, int, 4&gt;, wjson::enum_value&lt; w8, int, 8&gt;, wjson::enum_value&lt; w16, int, 16&gt;, wjson::enum_value&lt; w32, int, 32&gt; &gt;, S &gt; type; typedef typename type::serializer serializer; typedef typename type::target target; typedef typename type::member_list member_list; }; int main() { std::string json = "\"   \""; int val = 0; flags_json&lt;' '&gt;::serializer()(val, json.begin(), json.end(), 0 ); std::cout &lt;&lt; json &lt;&lt; " = " &lt;&lt; val &lt;&lt; std::endl; std::cout &lt;&lt; 63 &lt;&lt; " = "; flags_json&lt;' '&gt;::serializer()(63, std::ostream_iterator&lt;char&gt;(std::cout) ); std::cout &lt;&lt; std::endl; std::cout &lt;&lt; 48 &lt;&lt; " = "; flags_json&lt;','&gt;::serializer()(48, std::ostream_iterator&lt;char&gt;(std::cout) ); std::cout &lt;&lt; std::endl; std::cout &lt;&lt; 49 &lt;&lt; " = "; flags_json&lt;'|'&gt;::serializer()(49, std::ostream_iterator&lt;char&gt;(std::cout) ); std::cout &lt;&lt; std::endl; }</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The idea here is simple. We use each word from the line of the children's song as a flag with the corresponding meaning. Combining flags, we get various options. And if we use a space as a separator, it is not at all obvious that this is a set of flags. First, we deserialize the string ‚Äúthere was a gray goat‚Äù, which corresponds to the combination 1 | 2 | 16 | 32 = 51, with a separator as a space. And below are examples of serialization with various delimiters. Obviously, you can use all the numbers up to 63 - this is the whole phrase.</font></font><br>  Result: <br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"   "</span></span> = <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">63</span></span> = <span class="hljs-string"><span class="hljs-string">"     "</span></span> <span class="hljs-number"><span class="hljs-number">48</span></span> = [<span class="hljs-string"><span class="hljs-string">""</span></span>,<span class="hljs-string"><span class="hljs-string">""</span></span>] <span class="hljs-number"><span class="hljs-number">49</span></span> = <span class="hljs-string"><span class="hljs-string">"||"</span></span></code> </pre><br><br><h4>  Conclusion </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is rather difficult not to succumb to the temptation, in order not to begin a long and tedious justifiable narration about the history of the development of this creation. Therefore, briefly. Written on the knee in 2008 just to practice some of the concepts of faslib on which it is built. In 2009, wjson (then it was just a set of code that copied) was used in experimental projects. Then it became clear that the interface is not flexible and generally sucks. In 2011, there was an attempt to do something global, comprehensive and correct. And it almost happened, but it was abandoned, because In the same year, we began to transfer all our projects to JSON, and it turned out that the current capabilities cover all our needs, and the interface is simple and straightforward, even for beginners. Since 2013 all our projects, including very high-loaded ones, work with wjson. For example,A comet daemon can support up to 1 million simultaneous active connections, and the statistics collection system grinds more than 1.5 GB of JSON-RPC notifications on one host, recording up to 4.5 million values ‚Äã‚Äãof various metrics per second.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We use JSON for configurations, all sorts of dumps and, of course, together JSON-RPC engine, which works on the same principle, and which I will discuss in the next article very soon. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Both wjson and </font></font><a href="https://habrahabr.ru/post/228367/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">faslib</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , on which wjson depends, are the header-only libraries. </font><font style="vertical-align: inherit;">To compile examples and tests:</font></font><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/migashko/faslib.git git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/mambaru/wjson.git <span class="hljs-comment"><span class="hljs-comment">#      wjson cd faslib mkdir build cd build cmake .. #     cd ../../wjson mkdir build cd build cmake -DWJSON_BUILD_ALL=ON .. make cd ./tests ctest</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wjson on github: </font></font><a href="https://github.com/mambaru/wjson"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/mambaru/wjson</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/311262/">https://habr.com/ru/post/311262/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../311250/index.html">Using drag-and-drop between different Activities in Android 7 Nougat</a></li>
<li><a href="../311252/index.html">Applicants for the Nobel Prize 2016</a></li>
<li><a href="../311254/index.html">‚ÄúGoing onto the stage is my way of keeping up with the technologies‚Äù: interview with Baruh Sadogursky from JFrog</a></li>
<li><a href="../311256/index.html">Using a single IoC Container as part of an HTTP request between the Web API and the OWIN Middleware</a></li>
<li><a href="../311258/index.html">Raising the stakes: Who should get a share in your startup and which one?</a></li>
<li><a href="../311264/index.html">How to debug Android core without UART, JTAG and others</a></li>
<li><a href="../311266/index.html">In search of mutual understanding - 2: ‚ÄúBad advice‚Äù for my IT colleagues</a></li>
<li><a href="../311268/index.html">[systemd / udev] ppp: correct autostart of the system wide daemon</a></li>
<li><a href="../311270/index.html">Boilerplate for WordPress</a></li>
<li><a href="../311278/index.html">Three steps that will increase the noise of the digital converter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>