<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Draft FAQ: Why do C ++ standards come out every three years?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="WG21 has a strict schedule (see P1000 ) for issuing a standard every three years. And no delays. 

 During each cycle, we regularly receive questions ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Draft FAQ: Why do C ++ standards come out every three years?</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/u2/9v/zg/u29vzg2wz-7letn3lbp4ulyk9um.jpeg" width="400"></div><br>  WG21 has a strict schedule (see <a href="https://wg21.link/p1000">P1000</a> ) for issuing a standard every three years.  And no delays. <br><br>  During each cycle, we regularly receive questions ‚Äúwhy so strictly?‚Äù, Especially from new committee members who are not familiar with its history and the reasons for the current state of affairs.  And during the preliminary conference call with the administration of Cologne, several people recommended describing why we are doing this and how the decision was made to accept this schedule. <br><br>  I wrote all this in the form of questions and answers for the next draft of P1000, and sent a copy to the committee members who were heading to Cologne.  This material will be published in the next public version of the P1000, we will distribute it in a few weeks from now. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      However, the draft FAQ may be of interest to the public, therefore I offer you a copy of it.  I hope it will be for the most part useful for you, in some ways it will enlighten, and maybe even entertain you a little. <br><br><a name="habracut"></a><br><h2>  There are bugs in the standard, should you postpone C ++ 20? </h2><br>  Of course, yes and no. <br><br>  We are moving in a given direction at the selected speed: bug fixes are scheduled for this last year, so the schedule in early C ++ "19" (Kona) sets a deadline for feature freeze in C ++ "20" to we had a year to fix bugs, including working with comments from different countries this summer.  Before the beginning of 2020 (meetings in Cologne, Belfast and Prague) we must give feedback and apply any other solutions to the problems, as well as fix bugs. <br><br><h2>  If you hold another one or two meetings, you could add a &lt;name_of_bychi&gt; that is almost ready, so should you delay C ++ 20? </h2><br>  Of course, yes and no. <br><br>  Wait for another couple of meetings to take place (after Prague), and C ++ 23 will be open for business, and first of all we will vote to add &lt;name of the name&gt; to the working draft of C ++ 23.  So we did with the concepts: they were not ready to move from TS directly to C ++ 17.  Therefore, at the first meeting in C ++ 20 (in Toronto), they voted to transfer the main functionality of the concepts to the draft C ++ 20, which gave a lot of time to improve and refine the rest of the controversial part of the TS (non-"template" syntax) next year (San Diego).  Now all the functionality is ready. <br><br><h2>  It seems too strict.  Why release IS releases at fixed intervals (three years)? </h2><br>  Because in the case of the C ++ IS release, this is one of the two main options for project management, and experience shows that this option is better than the second. <br><br><h2>  What are two project management options for C ++ IS release? </h2><br>  Glad you asked. <br><br>  In the case of a release, there are two main options: select features or release dates, and when you choose one, you lose control over the definition of the other.  It is impossible to simultaneously control both.  In short: <br><br><div class="scrollable-table"><table><tbody><tr><th>  If we control it <br></th><th>  We will stop controlling it. <br></th><th>  Can we work on "big" multi-year features? <br></th><th>  When do we add features to a working IS draft? <br></th><th>  What do we do if we find problems with added feature? <br></th></tr><tr><td>  <b>"What": features that we ship</b> <br></td><td>  ‚ÄúWhen‚Äù: release date. <br></td><td>  Yes, in the proposal papers and the working draft IS. <br></td><td>  Usually earlier in order to conduct more integration tests ‚Üí the average stability of a working draft decreases. <br></td><td>  We delay the release of the standard. <br></td></tr><tr><td>  <b>"When": release date</b> <br></td><td>  "What": features that we ship <br></td><td>  Yes, in documents with sentences and feature branches in TS. <br></td><td>  Usually later, when the feature is better developed ‚Üí the average stability of the working draft increases. <br></td><td>  We remove the feature, later we can add it again, if it is ready for the moment of departure of the next "train¬ª IS. <br></td></tr></tbody></table></div><br>  I explain: <br><br>  <b>(1) ‚ÄúWhat‚Äù: we choose features and ship as soon as they are ready, no need to choose the release time</b> .  If it turns out that you need more time to finalize the features of the draft standard, then the whole world will have to wait for you.  You work on big features that require several years of development, and then you try to stop working on new features altogether while you stabilize the release. <br><br>  This was the case with C ++ 98 (it was waited around 1994, Bjorn said that the release will not work by that time, it will be a failure) from C ++ 11 (it was called 0x, because x was waiting for 2007) .  This is the ‚Äúleave the patient unprotected‚Äù approach for an indefinite period, which has led to a delay in integration testing and release.  And this, in turn, led to great uncertainty in the market regarding the timing of the next standard, and whether it will come out at all (yes, not only the participants of the development, but even some members of the committee seriously doubted in 1996 and 2009, whether any relevant releases).  For several years, most compilers did not meet the standard, because no one knew how many incompatible changes would the committee roll out in a new release, or when to wait for it at all?  This has led to a lot of diversity and fragmentation of C ++ support in compilers available to the community. <br><br>  Why did we do that, are we idiots?  Not really, just inexperienced and ... let's say, "optimistic."  It was a road paved with the best of intentions.  In 1994-1996 and in 2007-2009 we really believed that now we would move on to another one or two or three meetings, and we would do everything, and each time we transferred them for periods of up to four years.  And now, in my own experience, we were convinced that there can be no transfer for a year or two. <br><br>  Fortunately, everything changed due to option (2). <br><br>  <b>(2) "When": choose the release date and ship those features that will be ready, no need to choose a set of features</b> .  If it turns out that you need more time to refine the features of the draft standard, we throw it away and ship what is ready.  You can continue to work on large features, the creation of which takes time like a few releases, but do it in third-party "branches", adding them to the IS master branch as soon as it is ready.  And you constantly work on features, because their development is completely separate from the current release (there is no big connection point). <br><br>  We have been following this approach since 2012 and we don‚Äôt want to give it up.  This is the ‚Äúregularly sew up patient‚Äù approach, which leads to the expectation of higher quality due to compulsory regular integrations and the refusal to add work to the IS draft until it reaches a certain level of stability, usually within the framework of the feature branch.  It also creates a predictable release cycle on which the market can rely.  Over the years, compiler authors have begun to release, after the next release, the standard versions of their products, which has never happened before.  And in 2020, we expect to release fully compliant standard implementations in one year with the release of the standard, which has never happened before either.  This is only for the benefit of the entire market - developers, users, teachers. <br><br>  And also note that since we started to adhere to this approach, we have begun to do more (if we evaluate by large, medium and small features) and with higher quality (if we estimate by strictly reducing the number of bug reports and comments to draft of each standard).  Although we ship what we managed to prepare (and if we didn‚Äôt manage something, we don‚Äôt ship it). <br><br><h2>  How seriously do you take approach (2)?  If, in the opinion of an authoritative member of the committee, some big feature is ‚Äúalmost ready‚Äù, then you will be tempted to wait a bit, right? </h2><br>  We take it very seriously, and no. <br><br>  We have statistics: in 2016 in Jacksonville, when we were finally determined with features for C ++ 17, Bjarne Stroustrup made a plenary meeting with a proposal to include concepts in C ++ 17.  When they did not reach consensus, Straustrup was directly asked if he wanted to delay the release of C ++ 17 for a year in order to include concepts in it.  Bj√∂rn answered ‚Äúno‚Äù without hesitation and twisting, and added that C ++ 17 without concepts is more important than C ++ 18 or C ++ 19 with concepts, although Straustrup has worked on them for about 15 years.  The choice was: (2) release C ++ 17 without concepts, and then C ++ 20 with concepts (which we did), or (1) rename C ++ 17 to C ++ 20, which is isomorphic (2) with the exception of skipping C ++ 17 and refusing to release what was already ready for C ++ 17. <br><br><h2>  What about a compromise between (1) and (2)?  Say, we usually stick to (2), but with ‚Äúsmall‚Äù flexibility in terms, in order to get ‚Äúsome‚Äù extra time if you need to refine the feature? </h2><br>  No, because it will (1). <br><br>  Fred Brooks in <i>The Mythical Man-Month</i> popularly explained about the ‚Äúmythical little transference‚Äù and concluded: ‚Äú <a href="https://www.cs.huji.ac.il/labs/parallel/Docs/C%2B%2B/DesignPatterns/smallSlips.html">Do not allow any small translations</a> ‚Äù. <br><br>  Imagine that we transferred C ++ 20.  We would have to return from (2) to (1), regardless of how much we try to avoid it, and at the same time would not receive any benefits.  If we decided to postpone C ++ 20 to polish it, then we would delay the standard for at least two years.  There are no such concepts as transferring one or three meetings, because during this time others will continue (rightly) to say: ‚Äúwell, my feature just needs another meeting, we still have postponed, let's transfer one more‚Äù.  And if we transfer at least for two years, it means that C ++ 20 becomes C ++ 22, and most likely C ++ 23 ... but we are already going to ship C ++ 23!  - That is, in any case, we will ship C ++ 23, and the only difference is that we <b>do not</b> transfer C ++ 20 with a large amount of work done, ready for release, and do not make the whole world wait another three years.  Delay will not benefit these features, most of them or all together. <br><br>  Therefore, the sentence is equivalent to ‚Äúlet's turn C ++ 20 into C ++ 22 or C ++ 23‚Äù, and a simple answer to it: ‚ÄúYes, we will have C ++ 23, but in addition to C ++ 20, but not in its stead. ‚Äù  A delay of C ++ 20 means the omission of C ++ 20 instead of releasing a good, stable, finished product, and there will be no benefit from this. <br><br><h2>  But feature X is broken / needs more time than we have to fix bugs in C ++ 20! </h2><br>  No problem!  We can just cut it. <br><br>  In this case, someone will need to write a letter describing the situation to the EWG or LEWG (depending on the situation), and offer to remove the feature from the working draft IS.  These groups will consider the appeal, and if they decide that the feature is broken (and the plenum will agree with them), they will postpone the feature until the next C ++ release.  We have already done so with the C ++ 0x concepts. <br><br>  But in the case of (1), we will transfer not only this feature, but the <b>entire</b> feature <b>set</b> from C ++ 20 to C ++ 23!  It would be ... bust. <br><br><h2>  Approach (2) means "major / minor" releases? </h2><br>  Not.  At first, we said so, until we realized that (2) only means that you do not need to choose a set of features, even from the point of view of a ‚Äúmain / secondary‚Äù release. <br><br>  Approach (2) means only ‚Äúship what is ready‚Äù.  Releases are obtained: <br><br><ul><li>  the same size (that is, usually medium) for smaller features, because less time is spent on their development (say, less than three years on each), and in general we get the same number of completed features in the release; <br></li><li>  and variable size (not once) for the ‚Äúbigger‚Äù features, which take more time (say, more than three years for each), and each IS release includes as many of these features as they manage to complete for release.  Therefore, in some releases there are more, in others less. <br></li></ul><br>  C ++ 14 and C ++ 17 were relatively small, because a lot of standardization efforts were spent on the long-running features described in the implementation proposals (for example, contracts) and the feature branches in TS (for example, concepts). <br><br><h2>  C ++ 20 is a big release ... </h2><br>  Yes.  In C ++ 20, there are many large features.  Three of the largest begin with ‚Äúko‚Äù (concepts, contracts, cortinis), so we could call it co_cpp20.  Or co_dependent. <br><br><h2>  ... and hasn't too much been done in a three-year cycle for C ++ 20? </h2><br>  No, see above, ‚Äúonce at a time is not necessary‚Äù. <br><br>  C ++ 20 is big, not because we have done more in three years, but because there have been a lot of long development (including at least two, on which we have been working in the current form since 2012 in the form of P-sentences and TS branches) ) reached the stage of readiness and decided to include them in the IS draft of the same release. <br><br>  Almost always, the main features are developed for many years.  The main difference between approach (1) for C ++ 98 and C ++ 11 and approach (2) is that C ++ 98 and C ++ 11 delayed the release until all these features were ready, and now we ship large as ready, and along with them we release much more. <br><br>  C ++ 20 went through the same three-year cycle as C ++ 14 and C ++ 17.  We have not done more than the previous two cycles in the last three years, we just finished more basic features.  If some of them were not ready, then we would have thrown it out and completed it already for C ++ 23.  If this happens, we will inform about it in the proposal for implementation and explain the reasons. <br><br>  C ++ 14 + 17 + 20 made up our third nine-year cycle (2011-2020) after C ++ 98 (1989-1998) and C ++ 11 (2002-2011).  But since we adhered to approach (2), we <b>also</b> released developments that were ready for the end of the three-year and six-year cycles. <br><br><h2>  Isn't it better to catch bugs when the product is in development, and not after it is released? </h2><br>  Of course better. <br><br>  But if we are talking about the reasons for the delay in the release of the C ++ standard, this question implies two false assumptions: <br><br><ul><li>  that before the standard was released, the features did not come out and were not used (many already have experience using in production); <br></li><li>  and that all features can be used together until the standard is released (not allowed). <br></li></ul><br>  I explain: <br><br><ol><li>  Most of the major C ++ 20 features were implemented in the form in which they are reflected in the current draft of the standard, in at least one compiler, and in most cases were already used in the production code (that is, they are already available to users who are very satisfied) .  For example, coroutines (implemented just five months before this article) were used for two years in production at MSVC and for a year at Clang, which turned out to be very welcome for large customers (for example, Azure and Facebook). </li><li>  We are not going to catch many problems of interaction of features until users start using them in production, that is, before the standard is released, because many developers will wait for it to be released in order to implement different projects.  And if we show uncertainty about the timing of the release, then these implementations will also be delayed.  Well, they are still implementing something, but a lot will be paused until the developers are sure that we are ready to release.  Ask the creators of &lt;compiler name&gt; what happened when they implemented &lt;nickname&gt; before it appeared in the published standard.  In many cases, it is necessary to sell repeatedly, and to break off consumers, too, repeatedly.  Therefore, developers prefer to wait for the committee to approve certain features. </li></ol><br>  Finally, do not forget about the problem of the interaction of features.  We not only release them when we are ready, after that we still need time to look for interaction problems between features and to add support for such interactions, which we simply cannot find out before new features become widely used.  And it does not matter how far we delay the release of the standard, there will always be interactions that we will be able to explore only much later.  This risk should be managed with the help of flexible design ensuring compatibility of features, rather than waiting for all risks to be eliminated. <br><br><h2>  The standard will never be perfect ... will you not make mistakes? </h2><br>  Yes. <br><br>  If we see that the feature is not ready, then we must remove it from the release. <br><br>  If we see that the feature can be better, and we know that the change may turn out to be backward compatible, then this is not a reason to refuse to release it now.  It can be released as an extension in the following C ++. <br><br>  We intentionally release features that we plan to improve in the future, while we are sure that we can maintain backward compatibility. <br><br><h2>  But shouldn't you try to minimize errors in releases? </h2><br>  Yes.  We are trying. <br><br>  But we do not try to avoid all risks.  There is also a risk and (possible) price of not releasing what seems ready to us.  And most often we are right. <br><br><h2>  Are you sure that now the quality is better than using approach (1)? </h2><br>  Yes. <br><br>  According to objective metrics, the volume of comments from different countries and error reports, C ++ 14 and C ++ 17 were our most stable releases, and according to these metrics, they exceeded C ++ 98 and C ++ 11 by 3-4 times.  And the reason is precisely the regularity of releases, the placement of large features first in TS branches (including full descriptions of their integration with the main standard) and their subsequent infusion when we are convinced of readiness. <br><br>  Since 2012, the main standard <b>has always been</b> maintained in an almost-ready-to-ship state (so that even working drafts are of the same high quality as releases of the C ++ 98 and C ++ 11 standards).  This has never happened before, when for a long time we kept the patient unstitched, with long lists of problems and organs spread out around, which we are going to shove back soon.  Now we know that we can withstand the schedule with high quality work, because we always remain in a state of close readiness for release.  If they wanted to, they could have released a CD even now, without meeting in Cologne, and still the quality would be much higher than ever with CD C ++ 98 or C ++ 11 (in truth, and their published standards) .  And considering that C ++ 98 and C ++ 11 were successful, the understanding that quality is now even higher means that we are on the right track. <br><br><h2>  C ++ 98 and C ++ 11 were developed for about 9 years and were very good products ... </h2><br>  Yes: 1989-1998 and 2002-2011. <br><br><h2>  ... and C ++ 14 and C ++ 17 were minor releases.  C ++ 20 is the main release? </h2><br>  I repeat, I think it is right to compare C ++ 14 + 17 + 20 as a single whole: this is our nine-year cycle, but since we followed approach (2), we also released some developments that were ready for the completion of the three-year and six-year cycles . <br><br><h2>  Does approach (2) allow achieving feature-based goals like <a href="https://wg21.link/p0592">P0592</a> for the next C ++? </h2><br>  Of course!  While there are no words in it like ‚Äúshould include these features‚Äù, because then it will be an approach (1). <br><br>  Striving for a certain set of features and giving priority to one of them is normal, but then it is a matter of priority.  For now, we will only take what is ready, but we can choose what to work on first of all in order to prepare as soon as possible. </div><p>Source: <a href="https://habr.com/ru/post/460665/">https://habr.com/ru/post/460665/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460651/index.html">Meeting of the Society of Anonymous Testers: TMS, monitoring monitoring, search quality assessment and native iOS tests</a></li>
<li><a href="../460655/index.html">How I broke Telegram</a></li>
<li><a href="../460659/index.html">We use pipe for pivoting</a></li>
<li><a href="../46066/index.html">Sequential - free photo viewer for Mac OS X</a></li>
<li><a href="../460661/index.html">All you need to know about Node.js</a></li>
<li><a href="../460669/index.html">How to ensure the safety of development, saving time and nerves</a></li>
<li><a href="../460671/index.html">Ownership and borrowing in D</a></li>
<li><a href="../460675/index.html">Retrieving machine learning data</a></li>
<li><a href="../46068/index.html">Formatting Long SQL Queries</a></li>
<li><a href="../460683/index.html">Laravel Event Projector and Event Generation Concept</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>