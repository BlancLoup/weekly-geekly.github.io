<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Migrating photos or another queue on MySQL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, we wrote about how for the first time we faced the task of large-scale migration of user data between data centers and how we solved it. 
 T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Migrating photos or another queue on MySQL</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/369/3ac/452/3693ac452e1c3dc6583d2011a0c68911.jpg" align="left">  Recently, we <a href="http://habrahabr.ru/company/badoo/blog/197456/">wrote about</a> how for the first time we faced the task of large-scale migration of user data between data centers and how we solved it. <br>  This time we‚Äôll take a closer look at how the photos of users were migrated and what data structures were used to limit the load on servers with photos. <br>  Badoo users upload approximately 3 million photos daily.  To store them, we have identified a special cluster of servers that also deal with resizing, watermarking, importing photos from other social networks and other file manipulations. <br>  All the machines of this cluster can be divided into three groups.  The first is the servers responsible for the quick delivery of photos to users (you can say, your own CDN implementation).  In the context of migration, these servers will not be interesting to us.  The second group is the repositories with disks, on which, in fact, are all the photos.  And the third group is the servers providing the interface to the second group, let's conditionally call them photoservers.  Disk arrays of storages are mounted on them via optical fiber, photos are loaded on the same machines, and all the scripts that perform any operations with files work here. <br>  Thus, for PHP code it does not matter at all what disk of which repository the photo is on.  All you need to do is transfer the user's photos from one photoserver to another and update this information in the database and some demons.  It is important to note here that all photos of the user are always on the same photoserver. <br><a name="habracut"></a><br><h4>  Formulation of the problem </h4><br>  The total volume of all photos ever uploaded by our users is about 600 TB.  This number includes both originals of photos, as well as a set of photos with resized, necessary for display in one way or another. <br>  A rough estimate shows that if 190 million users downloaded 600 TB of data, then 1.5 million users from Thailand (the largest of the countries transferred between data centers) downloaded 4.7 TB.  The bandwidth between our data centers at the time of the migration was 200 Mbps.  By simple calculations, we get 55 hours to transfer all photos of users from Thailand.  Naturally, this channel is already partially occupied by other data that is constantly circulating between data centers, and in fact it will take more than 55 hours.  And our goal is to make it in 8 hours. <br>  It would be possible to transfer only the originals of the photos and make ‚Äúresize‚Äù for them on the new photoserver, but this would lead to an undesirable increase in the load on the processors.  Therefore, we decided to transfer photos in advance, hoping that users will not have time to upload many new photos in the time required to transfer photos of the whole country. <br>  That is, first we simply copy already existing photos, and during the migration of all user data (when the site is unavailable for it and it is impossible to change something in our photos), we check if there have been any changes after transferring the photos.  If the changes were, then copy the photos again (or rather, make rsync), and only after that we will update the data in the databases and demons so that the user's photos will be shown and loaded on the new photo server. <br>  As practice has shown, our expectations were met, and rsync had to be done a second time for a very small percentage of users. <br>  Another limitation for us was the performance of disk storage.  We found out that even having a channel of hundreds of terabits, we will not be able to use it to its fullest capacity, since photos are constantly being loaded onto the photo servers, various operations are performed with them.  In addition, our CDN "reads" these photos from disks, and the additional load on reading can significantly slow down everyday operations.  That is, the intensity of migration of photos should be artificially limited. <br><br><h4>  Implementation </h4><br>  The first thing that came to our mind was the queue in the database (we use MySQL), which will contain all the users whose photos need to be transferred.  The queue will be processed in multiple processes.  By limiting the number of processes per one photo server, we thereby solve the problem of limiting the load on the disks.  The restriction on the total number of processes will allow us to regulate the load on the channel between data centers. <br>  Suppose we have a table MigrationPhoto of the following structure: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> MigrationPhoto ( user_id <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">updated</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span>, photoserver <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>), <span class="hljs-comment"><span class="hljs-comment">#  c   script_name VARCHAR(255), #  ,   done TINYINT(1), # 1    ,  0 KEY photoserver (photoserver), KEY script_name (script_name) )</span></span></code> </pre> <br>  First, we add all users whose photos we want to transfer to our table: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> MigrationPhoto (user_id,photoserver) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">00000000</span></span>, <span class="hljs-string"><span class="hljs-string">'photoserver1'</span></span>)</code> </pre><br>  The limitation on the total number of processes is easily achieved using the pcntl extension and is not of great interest, therefore, we will consider further one process involved in the transfer. <br>  We need to provide a specific number of processes per photo server.  First, let's figure out which users from which photoservers are in the queue.  In order not to do <i>SELECT photoserver, COUNT (*) FROM MigrationPhoto</i> each time, we will <i>create a</i> separate table: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> MigrationPhotoCounters ( photoserver <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> )</code> </pre><br>  We will fill it in when inserting each user into the MigrationPhoto table: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> MigrationPhotoCounters (photoserver, <span class="hljs-keyword"><span class="hljs-keyword">users</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'photoserver1'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DUPLICATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">users</span></span>)</code> </pre><br>  Or, after filling in the MigrationPhoto, we do this: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> MigrationPhotoCounters (bphotos_server, <span class="hljs-keyword"><span class="hljs-keyword">users</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> photoserver, <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> MigrationPhoto)</code> </pre><br>  Having such a table, at the start of each process we will do <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> photoserver <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> MigrationPhotoCounters <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span>&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RAND</span></span>()</code> </pre><br>  Having received the list of all photoservers, we will determine for which of them you can start the process so as not to exceed the limits.  To do this, we put in the database a lock, whose name consists of the name of the photoserver and the sequence number of the process within this server: <br><br><pre> <code class="php hljs">$processNumber = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($photoservers <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $serverName) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">1</span></span>; $i &lt;= PROCESSES_PER_SERVER; $i++) { $lock = executeQuery(<span class="hljs-string"><span class="hljs-string">"SELECT GET_LOCK('migration"</span></span> . $serverName . <span class="hljs-string"><span class="hljs-string">'_'</span></span> . $processNumber . <span class="hljs-string"><span class="hljs-string">"', 0)"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($lock === <span class="hljs-string"><span class="hljs-string">'1'</span></span>) { $processNumber = $i; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($processNumber) { $serverName = $serverName; $scriptName = <span class="hljs-string"><span class="hljs-string">'migration'</span></span> . $serverName . <span class="hljs-string"><span class="hljs-string">'_'</span></span> . $processNumber; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br>  Thus, in two nested loops we iterate through all the photo servers and process numbers for them.  If all iterations of the inner loop are executed and the <i>$ processNumber</i> variable is not defined, it means that a limit on the number of processes has been reached for this photoserver.  If all iterations of the outer loop have been performed, then this limit has been reached for all photo servers that still have users to be transferred. <br>  Suppose we selected the photoserver photoserver1, and this is the second process for it, that is, the process ID will be <i>$ scriptName = 'migration_photoserver1_2'</i> . <br>  Before proceeding further, we will return to the general queue those users who for one reason or another remained marked with the process identifier <i>($ scriptName)</i> chosen by us during previous launches: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> MIgrationPhoto <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> script_name = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> done = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> script_name = <span class="hljs-string"><span class="hljs-string">'migration_photoserver1_2'</span></span></code> </pre><br>  Mark a portion of users as processed by this process: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> MigrationPhoto script_name=<span class="hljs-string"><span class="hljs-string">'migration_photoserver1_2'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> photoserver=<span class="hljs-string"><span class="hljs-string">'photoserver1'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> done = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> script_name <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><br>  Now let's take several users from the queue that correspond to the selected photoserver and are not yet processed by another process: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> MigrationPhoto <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> script_name=<span class="hljs-string"><span class="hljs-string">'migration_photoserver1_2'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> done=<span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><br>  After that, we can be sure that the records we have selected are not processed by any other process. <br>  We remember when we transferred photos of the user: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> MigrationPhoto <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">updated</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">NOW</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> user_id = <span class="hljs-number"><span class="hljs-number">00000000</span></span></code> </pre><br>  Perform all the operations we need, they can be simplified as rsync.  After successfully transferring the photos, we need to mark this in the database (for each of the selected users): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> MigrationPhotoCounters <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> photoserver = <span class="hljs-string"><span class="hljs-string">'photoserver1'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> MigrationPhoto <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> done = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> user_id = <span class="hljs-number"><span class="hljs-number">00000000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  It may happen that of the 100 users taken for processing, for some it will not be possible to carry out the transfer for a variety of reasons.  These users need to be returned to the queue to transfer them later: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> MigrationPhoto <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> script_name = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> user_id <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (&lt;failed_ids&gt;)</code> </pre><br>  Finishing the process: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RELEASE_LOCK</span></span>(<span class="hljs-string"><span class="hljs-string">'migration_photoserver1_2'</span></span>)</code> </pre><br>  It would seem that this can be finished.  But our scheme has a fundamental flaw. <br>  Suppose that a process has started with <i>$ scriptName = 'migration_photoserver1_10'</i> , while <i>PROCESSES_PER_SERVER = 10</i> .  And this process fell without returning the users it took to the queue.  In order for these users to be selected again, either the process with the same <i>$ scriptName</i> must start again, or someone must put these users in the base <i>script_name = NULL</i> .  Running the process with the same <i>$ scriptName</i> may not happen anymore. <br>  For example, we have 100 photoservers in MigrationPhotoCounters, the limit on the total number of processes is 50, the limit on the number of processes per one is 10, then it is obvious that if at some point there were 10 processes per photoserver, then later this photoserver can receive only one process.  Therefore, we will write another script that, for example, once per minute will set <i>script_name = NULL</i> for those users whose processes are not currently running: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($photoservers <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $serverName) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">1</span></span>; $i &lt;= PROCESSES_PER_SERVER; $i++) { $lock = executeQuery(<span class="hljs-string"><span class="hljs-string">"SELECT GET_LOCK('migration"</span></span> . $serverName . <span class="hljs-string"><span class="hljs-string">'_'</span></span> . $processNumber . <span class="hljs-string"><span class="hljs-string">"', 0)"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($lock === <span class="hljs-string"><span class="hljs-string">'1'</span></span>) { executeQuery(<span class="hljs-string"><span class="hljs-string">"UPDATE MigrationPhoto SET script_name = NULL WHERE done = 0 AND script_name = 'migration"</span></span> . $serverName . <span class="hljs-string"><span class="hljs-string">'_'</span></span> . $processNumber . <span class="hljs-string"><span class="hljs-string">"'"</span></span>); } } }</code> </pre><br>  Now, even if the process crashes, its users will be available for processing by other processes.  In addition, this will allow changing the limit on the number of processes per one photo server on the fly. <br>  When the process is completed and the migration of all other user data begins, it is enough to check that the user's photos have not changed since the time specified in the updated MigrationPhoto table field.  And if you change - just repeat rsync.  It does not take a lot of time, since almost none of the users change all their photos for 2-3 days. <br>  As a result, we had 63 photoservers from which we read photos, and 30 servers to which we wrote.  All this was done by 80 processes, with a limit of no more than 3 processes per photo server.  With such restrictions, traffic was 150 Mbps.  Transferring photos for users from Thailand took a little less than three days.  Given the amount of data, we got an excellent result. <br><br><h4>  Conclusion </h4><br>  Of course, our scheme allows extensions and improvements.  For example, you can limit the number of processing processes for each photoserver individually.  You can adjust this number depending on how many users of a particular photoserver are in the queue.  You can add priorities, a progressive timeout for the next record processing (in case of the current failure), the maximum number of failed processing, logs, graphics, and much more. <br>  But we wanted to convey the very idea of ‚Äã‚Äãparallel processing of a queue with given restrictions, which, of course, can be used not only to transfer files between servers. <br>  Today we did not describe the processing of various errors and exceptions, as well as the mechanism for creating and maintaining a given number of processes, and the implementation of file transfer.  But if it is interesting to you - ask, and we will answer in the comments. <br><br>  <b>Anton Stepanenko, Team Lead, PHP developer</b> </div><p>Source: <a href="https://habr.com/ru/post/204028/">https://habr.com/ru/post/204028/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../204014/index.html">Meet GStreamer: Output Devices</a></li>
<li><a href="../204016/index.html">What if successful startups were just lucky?</a></li>
<li><a href="../204018/index.html">Barnes & Noble readers and tablets sale</a></li>
<li><a href="../204020/index.html">Who got up earlier, that and ... 99 tickets for IDCEE 2014 for ‚Ç¨ 99!</a></li>
<li><a href="../204026/index.html">Example of circuit simulation in Cassandra 2.0 in CQL3</a></li>
<li><a href="../204030/index.html">Custom Checkboxes</a></li>
<li><a href="../204032/index.html">The drama that passed by us, or how Xamarin wanted $ 12,000 a year from a client</a></li>
<li><a href="../204036/index.html">Adapting Windows Phone applications for large screens</a></li>
<li><a href="../204042/index.html">How I stole a million</a></li>
<li><a href="../204044/index.html">Bitcoin: you can‚Äôt take it easy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>