<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reverse engineering of USB device drivers on the example of a radio-controlled car</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of the article DRIVE IT YOURSELF: USB CAR 



 One of the arguments of Windows lovers before Linux lovers is the lack of drivers for hardw...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reverse engineering of USB device drivers on the example of a radio-controlled car</h1><div class="post__text post__text-html js-mediator-article">  <i>Translation of the article <a href="http://www.linuxvoice.com/drive-it-yourself-usb-car-6/">DRIVE IT YOURSELF: USB CAR</a></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c71/e1d/7be/c71e1d7bec576db6d95fd12b25098e03.png" alt="image"><br><br>  One of the arguments of Windows lovers before Linux lovers is the lack of drivers for hardware for this OS.  Over time, the situation is straightened.  Now it is much better than 10 years ago.  But sometimes you can find some device that is not recognized by your favorite distribution.  Usually it will be some kind of USB peripherals. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The beauty of free software is that you can solve this problem yourself (if you are a programmer).  Of course, it all depends on the complexity of the equipment.  With a three-dimensional webcam, you may not succeed - but many USB devices are quite simple, and you don‚Äôt have to dive into the depths of the core or dig in C. In this lesson, you and I will use Python to create a driver for a toy radio-controlled machine . <br><br>  The process will essentially be reverse engineering.  First we will study the device in detail, then save the data it exchanges with the driver in Windows and try to understand what they mean.  For non-trivial protocols, you may need both experience and luck. <br><a name="habracut"></a><br><h4>  Meet USB </h4><br>  USB - bus with host management.  The host (PC) decides which device sends the data over the wire, and when.  Even in the case of an asynchronous event (pressing a button on the keyboard), it is not sent to the host now.  Since there can be up to 127 devices on each bus (and even more if through hubs), such a scheme of work facilitates management. <br><br>  Also, USB has a multi-layer protocol system - just like the Internet.  The lowest level is usually implemented in silicon.  The transport layer works through tunnels (pipe).  Streaming tunnels transmit different data, message tunnels - messages to control devices.  Each device supports at least one message tunnel.  At the top level of an application (or class) there are protocols like USB Mass Storage (flash drives) or Human Interface Devices (HID), devices for human-computer interaction. <br><br><h4>  In wires </h4><br>  A USB device can be thought of as a set of endpoints, or I / O buffers.  Each has a data direction (input or output) and type of transfer.  By type, the buffers are as follows: interrupts, isochronous, control, and packet. <br><br>  Interrupts transmit data in a little bit in real time.  If the user presses a key, the device waits until the host asks ‚Äúhave they pressed buttons there?‚Äù.  The host should not slow down, and these events should not be lost.  Isochronous work in approximately the same way, but not so hard - they allow you to transfer more data, while allowing them to be lost when it is not critical (for example, webcams). <br><br>  Batch designed for large volumes.  So that they do not clog the channel, they are given the entire place, which is now not occupied by other data.  Managers are used to control devices, and only they have a rigidly defined format for requests and responses.  A set of buffers with associated metadata is called an interface. <br><br>  Any USB device has a buffer number zero ‚Äî this is the default tunnel endpoint used for control data.  But how does the host know how many buffers the device has and what type of buffers are they?  For this purpose, different descriptors are used, sent on special requests through the default tunnel.  They can be standard for all, special for specific classes of devices, or proprietary. <br><br>  Descriptors make up a hierarchy that can be viewed with utilities like lsusb.  Upstairs sits a device handle containing the Vendor ID (VID) and Product ID (PID).  This pair is unique for each device, the system finds the necessary driver by it.  A device can have several configurations, each with its own interface (for example, a printer, a scanner and a fax in an MFP).  But usually one configuration with one interface is defined.  They are described by the corresponding descriptors.  Each endpoint has a descriptor containing its address (number), direction (input or output), and type of transmission. <br><br>  Class specifications have their own descriptor types.  The USB HID specification expects data transmission in the form of ‚Äúreports‚Äù that are sent and received via a control buffer or interrupt.  These descriptors define the format of the report (for example, ‚Äú1 field 8 bits long‚Äù) and how it should be used (‚Äúoffset in the X direction‚Äù).  Therefore, the HID device describes itself and can be supported by a universal driver (usbhid in Linux).  Otherwise, I would have to write my own driver for each mouse. <br><br>  I will not try to describe hundreds of pages of specifications in a few paragraphs.  I <a href="http://www.beyondlogic.org/usbnutshell">‚Äôm referring</a> to the book O'Reilly's ‚ÄúUSB in a Nutshell‚Äù, which is available for free at <a href="http://www.beyondlogic.org/usbnutshell">www.beyondlogic.org/usbnutshell</a> .  Let's do something better. <br><br><h4>  Understanding permissions </h4><br>  By default, USB devices can only work from under the root.  To prevent the test program from running this way, add the udev rule: <br><br><pre><code class="bash hljs">SUBSYSTEM==<span class="hljs-string"><span class="hljs-string">"usb"</span></span>, ATTRS{idVendor}==<span class="hljs-string"><span class="hljs-string">"0a81"</span></span>, ATTRS{idProduct}==<span class="hljs-string"><span class="hljs-string">"0702"</span></span>, GROUP=<span class="hljs-string"><span class="hljs-string">"INSERT_HERE"</span></span>, MODE=<span class="hljs-string"><span class="hljs-string">"0660"</span></span></code> </pre> <br><br>  Insert the name of the group to which your user belongs, and add it to /lib/udev/rules.d/99-usbcar.rules. <br><br><h4>  Under the hood </h4><br>  Let's see how the machine looks via USB.  lsusb is a tool for counting devices and decoding their descriptors.  Included in the usbutils kit. <br><br><pre> <code class="bash hljs">[val@y550p ~]$ lsusb Bus 002 Device 036: ID 0a81:0702 Chesen Electronics Corp. Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub ...</code> </pre><br><br>  The machine is a Device 036 (to be sure, you can unplug it and run lsusb again).  The ID field is a pair of VID: PID.  To read the descriptors, run lsusb -v: <br><br><pre> <code class="bash hljs">[val@y550p ~]$ lsusb -vd 0a81:0702 Bus 002 Device 036: ID 0a81:0702 Chesen Electronics Corp. Device Descriptor: idVendor 0x0a81 Chesen Electronics Corp. idProduct 0x0702 ... bNumConfigurations 1 Configuration Descriptor: ... Interface Descriptor: ... bInterfaceClass 3 Human Interface Device ... iInterface 0 HID Device Descriptor: ... Report Descriptors: ** UNAVAILABLE ** Endpoint Descriptor: ... bEndpointAddress 0x81 EP 1 IN bmAttributes 3 Transfer Type Interrupt ...</code> </pre><br><br>  Standard hierarchy.  Like most devices, it has only one configuration and interface.  You can see one interrupt-in endpoint (except for the default point 0, which is always there, and therefore is not displayed in the list).  The bInterfaceClass field indicates that this is a HID device.  This is good - the protocol of communication with HID is open.  It would seem that we will read the report descriptor in order to understand their format and use, and the trick is done.  However, he has a mark ** UNAVAILABLE **.  CHZN?  Since the machine is a HID device, the usbhid driver assigned it to itself, but does not know what to do with it.  We need to untie him from managing it. <br><br>  First you need to find the bus address.  Reconnect it, run dmesg |  grep usb, and look at the last line, starting with usb XY.Z :.  X, Y, and Z are integers that uniquely identify ports on a host.  Then run <br><br><pre> <code class="bash hljs">[root@y550p ~]<span class="hljs-comment"><span class="hljs-comment"># echo -n XY.Z:1.0 &gt; /sys/bus/usb/drivers/usbhid/unbind</span></span></code> </pre><br><br>  1.0 is the configuration and interface that the usbhid driver should release.  To tie everything back, write the same thing in / sys / bus / usb / drivers / usbhid / bind. <br><br>  Now the Report descriptor field provides information: <br><br><pre> <code class="bash hljs">Report Descriptor: (length is 52) Item(Global): Usage Page, data= [ 0xa0 0xff ] 65440 (null) Item(Local ): Usage, data= [ 0x01 ] 1 (null) ... Item(Global): Report Size, data= [ 0x08 ] 8 Item(Global): Report Count, data= [ 0x01 ] 1 Item(Main ): Input, data= [ 0x02 ] 2 ... Item(Global): Report Size, data= [ 0x08 ] 8 Item(Global): Report Count, data= [ 0x01 ] 1 Item(Main ): Output, data= [ 0x02 ] 2 ...</code> </pre><br><br>  Two reports are set.  One reads from the device (input), the second writes (output).  Both are in bytes.  However, their use is not obvious.  For comparison, here is what the mouse report descriptor looks like (not all, but the main lines): <br><br><pre> <code class="bash hljs">Report Descriptor: (length is 75) Item(Global): Usage Page, data= [ 0x01 ] 1 Generic Desktop Controls Item(Local ): Usage, data= [ 0x02 ] 2 Mouse Item(Local ): Usage, data= [ 0x01 ] 1 Pointer Item(Global): Usage Page, data= [ 0x09 ] 9 Buttons Item(Local ): Usage Minimum, data= [ 0x01 ] 1 Button 1 (Primary) Item(Local ): Usage Maximum, data= [ 0x05 ] 5 Button 5 Item(Global): Report Count, data= [ 0x05 ] 5 Item(Global): Report Size, data= [ 0x01 ] 1 Item(Main ): Input, data= [ 0x02 ] 2</code> </pre><br><br>  It's all clear.  It‚Äôs not clear with the machine, and we need to figure out how to use the bits ourselves. <br><br><h4>  Small bonus </h4><br>  Most radio-controlled toys are simple and use standard receivers operating at the same frequencies.  So, our program can be used to control other toys, except this machine. <br><br><h4>  Job for detective </h4><br>  When analyzing network traffic using a sniffer.  And in our case, such a thing is useful.  There are special USB monitors for commercial use, but Wireshark will be suitable for our task. <br><br>  Configure USB interception in Wireshark.  First, enable USB monitoring in the kernel.  Load the usbmon module: <br><br><pre> <code class="bash hljs">[root@y550p ~]<span class="hljs-comment"><span class="hljs-comment"># modprobe usbmon</span></span></code> </pre><br><br>  Mount the special debugfs file system: <br><br><pre> <code class="bash hljs">[root@y550p ~]<span class="hljs-comment"><span class="hljs-comment"># mount -t debugfs none /sys/kernel/debug</span></span></code> </pre><br><br>  The / sys / kernel / debug / usb / usbmon directory will appear, which can be used to record traffic using simple shell tools: <br><br><pre> <code class="bash hljs">[root@y550p ~]<span class="hljs-comment"><span class="hljs-comment"># ls /sys/kernel/debug/usb/usbmon 0s 0u 1s 1t 1u 2s 2t 2u</span></span></code> </pre><br><br>  There are files with mysterious names.  Integer - bus number (the first part of the USB bus address);  0 means all buses on the host.  s - statistics, t - transfers, u - URBs (USB Request Blocks logical entities representing ongoing transactions).  To save all transfers on bus 2, enter: <br><br><pre> <code class="bash hljs">[root@y550p ~]<span class="hljs-comment"><span class="hljs-comment"># cat /sys/kernel/debug/usb/usbmon/2t ffff88007d57cb40 296194404 S Ii:036:01 -115 1 &lt; ffff88007d57cb40 296195649 C Ii:036:01 0 1 = 05 ffff8800446d4840 298081925 S Co:036:00 s 21 09 0200 0000 0001 1 = 01 ffff8800446d4840 298082240 C Co:036:00 0 1 &gt; ffff880114fd1780 298214432 S Co:036:00 s 21 09 0200 0000 0001 1 = 00</span></span></code> </pre><br><br>  For the untrained eye, nothing is clear here.  Good thing Wireshark will decode the data. <br><br>  Now we need Windows, which will work with the original driver.  It‚Äôs best to install everything in VirtualBox (with the Oracle Extension Pack, since we need USB support).  Make sure that VirtualBox can use the device, and launch KeUsbCar, which controls the machine in Windows.  Run Wireshark to see which commands the driver sends to the device.  On the first screen, select the usbmonX interface, where X is the bus to which the machine is connected.  If Wireshark is not started from root, make sure that the / dev / usbmon * nodes have appropriate permissions. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4b/be6/cdb/f4bbe6cdb0df3835d24df07d72dfb357.jpg" alt="image"><br><br>  Click the Forward button in KeUsbCar.  Wireshark will intercept several outgoing control packets.  The screenshot shows the one we need.  Judging by the parameters, this is the SET_REPORT request (bmRequestType = 0x21, bRequest = 0x09), which is usually used to change the status of a device, such as lights on a keyboard.  According to the Report Descriptor we have seen, the data length is 1 byte, and the report itself contains 0x01 (also highlighted). <br><br>  Pressing the Right button results in a similar query.  But the report already contains 0x02.  You can guess that this means the direction of movement.  In the same way, we find out that 0x04 is the right reverse, 0x08 is reverse, and so on.  The rule is simple: the direction code is a binary one, shifted to the left by the position of the button in the KeUsbCar interface, if you count them clockwise. <br><br>  You can also note periodic interrupt requests from Endpoint 1 (0x81, 0x80 means that this is an entry point; 0x01 is its address).  What is it?  In addition to the buttons, KeUsbCar has a charge indicator, so this is possibly battery data.  Their value does not change (0x05) if the car does not leave the garage.  Otherwise, interrupt requests do not occur, but they are renewed if we put it back.  Then, apparently, 005 means "charging is in progress" (the toy is simple, therefore the charge level is not transmitted).  When the battery is charged, the interrupt will begin to return 0x85 (0x05 with 7 bits set).  Apparently, 7 bits means "charged."  What bits 0 and 2, which are 0x05, do is not yet clear. <br><br><h4>  We write almost real driver </h4><br>  Making the program work with a device that was not previously supported is good, but sometimes you need to make sure that the rest of the system works with it.  This means you need to do a driver, and this requires programming at the kernel level (http://www.linuxvoice.com/be-a-kernel-hacker/), and you hardly need it now.  But perhaps we can manage without it, if we are talking about USB. <br><br>  If you have a USB network card, you can use TUN / TAP to connect the PyUSB program to the Linux network stack.  The TUN / TAP interfaces work as usual network, with names like tun0 or tap1, but through them all the packages become available in the / dev / net / tun node.  The pytun module makes working with TUN / TAP simple.  The speed suffers, but you can rewrite the program in C using libusb. <br><br>  Another candidate is a USB display.  Linux has a vfb module that allows you to access the framebuffer as / dev / fbX.  You can use ioctls to redirect the console to it, and upload the contents of / dev / fbX to a USB device.  This is also not fast, but you are not going to play 3D shooters via USB. <br><br><h4>  Write the code </h4><br>  Let's make the same program as for Windows.  6 arrows and charge level, which flashes when the machine is charging.  The code is on GitHub <a href="https://github.com/vsinitsyn/usbcar.py">github.com/vsinitsyn/usbcar.py</a> <br><br>  How do we work in USB under Linux?  This can be done from user space using the libusb library.  It is written in C and requires good USB knowledge.  A simple alternative is PyUSB.  For the user interface, I used PyGame. <br><br>  Download PyUSB sources from <a href="https://github.com/walac/pyusb">github.com/walac/pyusb</a> , and install via setup.py.  You will also need to install the libusb library.  Put the functionality to control the machine in the class with the original name USBCar. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usb.core <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usb.util <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">USBCar</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> VID = <span class="hljs-number"><span class="hljs-number">0x0a81</span></span> PID = <span class="hljs-number"><span class="hljs-number">0x0702</span></span> FORWARD = <span class="hljs-number"><span class="hljs-number">1</span></span> RIGHT = <span class="hljs-number"><span class="hljs-number">2</span></span> REVERSE_RIGHT = <span class="hljs-number"><span class="hljs-number">4</span></span> REVERSE = <span class="hljs-number"><span class="hljs-number">8</span></span> REVERSE_LEFT = <span class="hljs-number"><span class="hljs-number">16</span></span> LEFT = <span class="hljs-number"><span class="hljs-number">32</span></span> STOP = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br><br>  We import the two main modules of PyUSB and insert the values ‚Äã‚Äãto control the machine, which we calculated when viewing traffic.  The VID and PID are the machine id taken from the lsusb output. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._had_driver = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> self._dev = usb.core.find(idVendor=USBCar.VID, idProduct=USBCar.PID) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._dev <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-string"><span class="hljs-string">"Device not found"</span></span>)</code> </pre><br><br>  The usb.core.find () function searches for a device by its ID.  See <a href="">github.com/walac/pyusb/blob/master/docs/tutorial.rst for</a> details. <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._dev.is_kernel_driver_active(<span class="hljs-number"><span class="hljs-number">0</span></span>): self._dev.detach_kernel_driver(<span class="hljs-number"><span class="hljs-number">0</span></span>) self._had_driver = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre><br><br>  We untie the kernel driver, as we did with lsusb.  0 - interface number.  Upon exiting the program, it must be bound back through release (), if it was active.  Therefore, we remember the initial state in self._had_driver. <br><br><pre> <code class="python hljs"> self._dev.set_configuration()</code> </pre><br><br>  Run the configuration.  This code is equivalent to the following code, which PyUSB hides from the programmer: <br><br><pre> <code class="python hljs"> self._dev.set_configuration(<span class="hljs-number"><span class="hljs-number">1</span></span>) usb.util.claim_interface(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> usb.util.release_interface(self._dev, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._had_driver: self._dev.attach_kernel_driver(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre><br><br>  This method must be called before the end of the program.  We release the interface we used and attach the kernel driver back. <br><br>  Moving cars: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, direction)</span></span></span><span class="hljs-function">:</span></span> ret = self._dev.ctrl_transfer(<span class="hljs-number"><span class="hljs-number">0x21</span></span>, <span class="hljs-number"><span class="hljs-number">0x09</span></span>, <span class="hljs-number"><span class="hljs-number">0x0200</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, [direction]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret == <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br><br>  direction is one of the values ‚Äã‚Äãdefined at the beginning of the class.  ctrl_transfer () passes control commands.  Data is transmitted as a string or as a list.  Returns the method the number of bytes written.  Since we have only one byte, we will return True in this case, and False in another. <br><br>  Method for battery status: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">battery_status</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: ret = self._dev.read(<span class="hljs-number"><span class="hljs-number">0x81</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, timeout=self.READ_TIMEOUT) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ret: res = ret.tolist() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> res[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">0x05</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'charging'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> res[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">0x85</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'charged'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'unknown'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> usb.core.USBError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'out of the garage'</span></span></code> </pre><br><br>  The read () method takes the address of the endpoint and the number of bytes to read.  The type of transfer is determined by the end point and is stored in the descriptor.  We also set non-standard timeout time for the program to run faster.  Device.read () returns an array that we convert to the list.  We check its first byte to determine charging status.  If the machine is not in the garage, then the read () call fails and throws usb.core.USBError error.  We assume that this error occurs precisely because of this.  In other cases, we return the status to 'unknown'. <br><br>  The UI class encapsulates the user interface.  Let's go through the main things.  The main loop is in UI.main_loop ().  We set the background with the picture, show the level of charge, if the machine is in the garage, and draw control buttons.  Then we wait for the event - if it is a click, then we move the machine in the given direction via USBCar.move (). <br><br>  The entire program, including the GUI, takes a little more than 200 lines.  Not bad for a device without documentation. <br><br>  Of course, we specifically took a fairly simple device.  But there are quite a few devices in the world that are similar to ours, and many use protocols that are not very different from what we picked.  Reverse engineering of a complex device is not an easy task, but now you can add support for Linux to some kind of trinket like a device that reports received e-mail.  If it is not very useful - at least it is interesting. </div><p>Source: <a href="https://habr.com/ru/post/254251/">https://habr.com/ru/post/254251/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../254237/index.html">From today, Intel is controlled by a computer</a></li>
<li><a href="../254239/index.html">Broadcast Event Messaging in Unity3D</a></li>
<li><a href="../254243/index.html">Setting up IPTV in OpenWRT Asus RT-N13U</a></li>
<li><a href="../254247/index.html">Launch the latest Linux kernel on Intel Edison</a></li>
<li><a href="../254249/index.html">Basics of spatial and frequency image processing. Lectures from Yandex</a></li>
<li><a href="../254255/index.html">Authorization through Chinese social networks</a></li>
<li><a href="../254257/index.html">We make payments iOS AppStore with checking on the server</a></li>
<li><a href="../254259/index.html">Remote control of the Lego Mindstorms robot via JMX and IP Video</a></li>
<li><a href="../254261/index.html">Trinity computer in browser</a></li>
<li><a href="../254263/index.html">Creating a plugin for logical replication in PostgreSQL 9.4+</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>