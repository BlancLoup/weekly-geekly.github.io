<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>My little relays: Brainfuck computer is magic</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 


 A long time ago, when everything was big around, and I was small, I read Wojciechowski‚Äôs ‚ÄúRadio-electronic toys‚Äù book, burning with t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>My little relays: Brainfuck computer is magic</h1><div class="post__text post__text-html js-mediator-article"><h2 id="vvedenie">  Introduction </h2><br><p>  A long time ago, when everything was big around, and I was small, I read Wojciechowski‚Äôs ‚ÄúRadio-electronic toys‚Äù book, burning with the desire to realize one or other devices described in it.  So, in the already distant 2008 year, out of several dozen electromagnetic relays, a 4-bit ALU was assembled ( <a href="https://rln.nnov.ru/index.php%3Find%3Dreviews%26op%3Dentry_view%26iden%3D126">RCVM1 - Relay Digital Computing Machine - version 1</a> ) capable of adding and subtracting.  And I thought then - what if you assemble a substantially larger number of relays and build a full-fledged relay computer?  On the unhurried assembly of the relay, it took here only 8 years to reach the required amount, and I began to create. </p><br><p>  Let me introduce you to your project to create a second version of a relay digital computer, code-named "BrainfuckPC" - a 16-bit computer with Von-Neumann architecture and a set of instructions for the Brainfuck language.  Design work has been completed, and I am in the process of making this monster. <br> <a href="https://geektimes.ru/post/287344/"><img src="https://habrastorage.org/files/47f/633/aca/47f633aca9ef41d2956fbd513c33223e.jpg"></a> </p><br><h2 id="1-tehnicheskie-harakteristiki">  1 Specifications </h2><br><ul><li>  Address bus width: 16 bits </li><li>  Addressing: word for word, 16 bits / word </li><li>  Memory Capacity: 64 kiloslova (128Kbytes) </li><li>  Data bus width: 16 bits </li><li>  Single address code and data space (Von-Neumann architecture) </li><li>  Clock frequency (design): 100 Hz, <strong>1 instruction / cycle</strong> </li><li>  Instruction Set: <a href="https://ru.wikipedia.org/wiki/Brainfuck">Brainfuck</a> ++ </li><li>  Number of relays (design): 792 </li><li>  Used relays: reed, RES55 (1p), RES64 (1h) </li></ul><br><p>  Details tackle </p><a name="habracut"></a><br><h2 id="obschiy-princip-raboty">  General principle of work </h2><br><p>  Consider the generalized structure of the computer: </p><br><img src="https://habrastorage.org/files/119/8ac/780/1198ac780bef4e6780cf3c32552e2d38.jpg"><br><p>  <em>Figure 1: Generalized Computer Structure</em> </p><br><p>  The central element is the adder, and not simple, but with parallel transfer.  Why this is needed - I will tell a little lower. </p><br><p>  The program and data are stored in a block of memory.  They are accessed at the address recorded in the IP instruction register, or in the AP address register, based on what we now want to read ‚Äî the data at the address specified in the AP, or the instruction recorded at the IP address. </p><br><p>  To operate this Turing tape (and Brainfuck, the programming language identifies it), we need to be able to do one of three things: </p><br><ul><li>  To change the value in the current data cell, that is, to do the operations Add / Sub.  In Brainfuck, the value in the cell can only be changed by one, i.e.  +1 or -1.  But having a full adder is a sin not to collapse long chains ++++++++++++ (------------) into one operation <em>AP + = N (</em> AP- = N), significantly speeding up the process calculations.  (also, let's not forget to turn [-] (or [+]) into * AP = 0); </li><li>  Change the number of the currently selected data cell.  I mean, walking through the data memory (AP ++, AP--); </li><li>  Change the current instruction number.  First, we need to increase the value in the IP register by one after the execution of each instruction.  Secondly, to change this value in the presence of branches in the code (the default for the organization of cycles).  The control flag is only one - Z. Accordingly, there are teams JumpIfZero and JumpIfNotZero. </li></ul><br><p>  In total, we need to be able to apply the value of any of the following three blocks to one adder - AP-register, IP-register, DATA-bus.  We will do this through a temporary register in which we will save one of the required values, connecting the required one using 16-bit keys. </p><br><p>  To the second input of the adder we will submit a number, to which one of these values ‚Äã‚Äãshould be changed in plus or minus.  In view of the limited width of the instruction, you can only change to a + -12bit number.  But for Brainfuck it is more than enough ("enough for everyone", yeah). <br>  We will take these 12 bits from the register of commands, in the presence of such commands naturally, because some of the commands do not use an adder at all.  Do not forget that negative numbers will be submitted in the amended code, with the filing of the add.  unit transfer input (i.e., A + invB + 1) </p><br><p>  The result of the calculation is immediately loaded to where we got it from.  Because of the temporary register, we can do this without serious consequences. </p><br><p>  In more detail (I would even say - boring) about the architecture can be found in this video: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Vkg3DC9bF2k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="nabor-instrukciy">  Instruction set </h2><br><p>  Having drawn a general concept, capable of implementing 8 basic Brainfuck instructions, I realized that it has much greater potential.  Therefore, I have developed a wider set of instructions that is compatible with Brainfuck, but requires compiling each original Brainfuck instruction into a 16-bit computer instruction. </p><br><h1 id="obschee-opisanie-instrukcii">  General description of the instruction </h1><br><p>  All instructions are 16-bit.  Formed from several parts. </p><br><ul><li>  Bits 15, 14, 13 - determine the instruction class </li><li>  Bit 12 - Sign bit for sign instructions </li><li>  Bits 11-0 - contain the lower 12 bits of the signed int-a.  The upper 4 bits are formed according to the value of the 12th bit. </li></ul><br><h1 id="tablica-instrukciy">  Instruction table </h1><br><table><thead><tr><th>  Instruction </th><th>  Opcode </th><th>  Operation </th><th>  Equivalent of Brainfuck </th><th>  Description </th></tr></thead><tbody><tr><td>  add m16 </td><td>  0X XX </td><td>  <em>AP ‚Üê</em> AP + m16 </td><td>  '+' (Repeat m16 times) </td><td>  Adds a base to the current value of the selected cell. </td></tr><tr><td>  sub m16 </td><td>  1X XX </td><td>  <em>AP ‚Üê</em> AP - m16 </td><td>  '-' (repeat m16 times) </td><td>  Respectively subtracts the base from the number </td></tr><tr><td>  ada m16 </td><td>  2X XX </td><td>  AP ‚Üê AP + m16 </td><td>  '&gt;' (Repeat m16 times) </td><td>  Increases address value </td></tr><tr><td>  ads m16 </td><td>  3X XX </td><td>  AP ‚Üê AP - m16 </td><td>  '&lt;' (Repeat m16 times) </td><td>  Reduces the value of the address </td></tr><tr><td>  jz m16 </td><td>  4X XX </td><td>  (* AP == 0)?  IP ‚Üê IP + m16: IP ‚Üê IP </td><td>  '[' </td><td>  Go to IP + m16 if the value of the current cell is zero </td></tr><tr><td>  jz m16 </td><td>  5X XX </td><td>  (* AP == 0)?  IP ‚Üê IP - m16: IP ‚Üê IP </td><td>  Not </td><td>  Go to IP - m16 if the value of the current cell is zero </td></tr><tr><td>  jnz m16 </td><td>  6X XX </td><td>  (* AP! = 0)?  IP ‚Üê IP + m16: IP ‚Üê IP </td><td>  Not </td><td>  Go to IP + m16 if the value of the current cell is not zero </td></tr><tr><td>  jnz m16 </td><td>  7X XX </td><td>  (* AP! = 0)?  IP ‚Üê IP - m16: IP ‚Üê IP </td><td>  ']' </td><td>  Go to IP - m16 if the value of the current cell is not zero </td></tr><tr><td>  and m16 </td><td>  8X XX </td><td>  <em>AP ‚Üê</em> AP AND m16 </td><td>  Not </td><td>  Logical AND with a positive number </td></tr><tr><td>  and m16 </td><td>  9X XX </td><td>  <em>AP ‚Üê</em> AP AND m16 </td><td>  Not </td><td>  Logical AND with a negative number (someone must form the upper 4 bits) </td></tr><tr><td>  or m16 </td><td>  aX XX </td><td>  <em>AP ‚Üê</em> AP OR m16 </td><td>  Not </td><td>  Boolean OR with positive constant </td></tr><tr><td>  or m16 </td><td>  bX XX </td><td>  <em>AP ‚Üê</em> AP OR m16 </td><td>  Not </td><td>  Boolean OR with negative constant </td></tr><tr><td>  in </td><td>  c0 00 </td><td>  * AP ‚Üê CIN </td><td>  ',' </td><td>  Read one m8 character from the console.  If the input buffer is empty - wait for it. </td></tr><tr><td>  out </td><td>  c0 01 </td><td>  COUT ‚Üê * AP </td><td>  '.' </td><td>  Print m8 character to console </td></tr><tr><td>  clr.ap </td><td>  d0 01 </td><td>  AP ‚Üê 0 </td><td>  Not </td><td>  Clear AP register.  Command allows combination </td></tr><tr><td>  clr.ip </td><td>  d0 02 </td><td>  IP ‚Üê 0 </td><td>  Not </td><td>  Clear IP register.  Command allows combination </td></tr><tr><td>  clr.dp </td><td>  d0 04 </td><td>  * AP ‚Üê 0 </td><td>  '[+]' or '[-]' </td><td>  Clear the memory cell.  Command allows combination </td></tr><tr><td>  set.ap </td><td>  d0 10 </td><td>  AP ‚Üê * AP </td><td>  Not </td><td>  Write current value to AP register </td></tr><tr><td>  set.ip </td><td>  d0 20 </td><td>  IP ‚Üê * AP </td><td>  Not </td><td>  Write current value to IP register </td></tr><tr><td>  get.ap </td><td>  d1 00 </td><td>  * AP ‚Üê AP </td><td>  Not </td><td>  Read current value from AP register </td></tr><tr><td>  get.ip </td><td>  d2 00 </td><td>  * AP ‚Üê IP </td><td>  Not </td><td>  Read current value from IP register </td></tr><tr><td>  mode.b8 </td><td>  e1 00 </td><td></td><td>  Not </td><td>  Activate 8-bit mode (1) </td></tr><tr><td>  mode.b16 </td><td>  e2 00 </td><td></td><td>  Not </td><td>  16-bit activation </td></tr><tr><td>  halt </td><td>  f0 00 </td><td></td><td>  Not </td><td>  Stop machine </td></tr></tbody></table><br><ul><li>  AP - Address Register </li><li>  IP - Register of Instructions </li><li>  * AP - Current Memory </li><li>  CIN - Console Input </li><li>  COUT - Console output </li></ul><br><ol><li> When activating 8-bit mode, the adder continues to operate in 16-bit mode.  However, the conditional commands (namely, the test value of the current memory cell for equality to zero) becomes 8-bit.  ( <em>AP &amp; 0x00FF == 0)?</em>  <em>and (</em> AP &amp; 0x00FF! = 0)?  Console input and output while decided to leave always 8-bit.  Not in unicode to print in the end? </li></ol><br><p>  In this video, I described in detail (but little understood) what each instruction does and what kind of brainfuck instructions it corresponds to: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mU3KTtWeB-s" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="parallelnyy-summator">  Parallel adder </h2><br><p>  A relay computer must be not only relay, but also fast.  Like any other computer, mine will also be a synchronous machine equipped with a clock generator.  Naturally, I would like not to waste the clocking cycles and try to fit each operation in one cycle - that is, for the rising and falling fronts of the synchronous generator, have time to load a new command and execute it.  It is desirable at the same time that all commands were executed for the same period of time. </p><br><p>  Each relay has a certain delay of operation and release, which we take for 1 conditional unit of time (cu). If we use the relay RES22, 1u.e.  will be equal to 12-15ms (reference), RES64 - 1.3ms (reference).  The most expensive (and most frequent) operation in my car is the adder. <br>  By itself, it is quite simple and fast, but "there is one nuance", which consists in the method of calculating and transmitting the transfer signal. </p><br><img src="https://habrastorage.org/files/a80/76a/c2b/a8076ac2b99b4a96b08530067edebfe6.png"><br><p>  <em>Figure 2: Adder with sequential carry.</em> </p><br><p>  I originally planned to use a sequential transfer adder.  In such an adder, each subsequent discharge depends on the state of the transfer signal of the current discharge.  As a result, the duration of the calculation operation will fluctuate between 2 USD.  - N * 2 AU, where N is the number of digits.  As a result, a 16-bit sequential transfer adder will have a maximum delay of 32 cu. </p><br><p>  Parallel transfer adders have maximum performance.  There are no processes for the spread of hyphenation from discharge to discharge.  Output values ‚Äã‚Äãare simultaneously generated in each digit: </p><br><img src="https://habrastorage.org/files/cce/54f/b48/cce54fb4896d4c2a87710b8f5d117a44.jpg"><br><p>  <em>Figure 3: Parallel Transfer Adder</em> </p><br><p>  The ability to build an adder with the specified properties is based on reproducing the sum and transfer functions that depend only on the values ‚Äã‚Äãof the terms, regardless of the location of the discharge in the discharge grid.  The catch is that the parallel transfer scheme itself becomes more complicated with each successive discharge.  Here, see what happens: </p><br><img src="https://habrastorage.org/files/1fe/89c/432/1fe89c432a5b49b7a45cf4a8223e42fe.png"><br><p>  <em>Figure 4: (Which should have been in the form of a LaTeX formula, but not) The transfer signal calculation equation for the bits.</em>  <em>Where</em> <math> </math><em><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>k</mi><mi>i</mi></msub><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub><mtext>&amp;#xA0;</mtext><mi>c</mi><mi>d</mi><mi>o</mi><mi>t</mi><msub><mi>b</mi><mi>i</mi></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="13.707ex" height="2.419ex" viewBox="0 -780.1 5901.5 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/402629/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjilMLmLjIcl9tVdStXZkZUbD87zQ#MJMATHI-6B" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/402629/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjilMLmLjIcl9tVdStXZkZUbD87zQ#MJMATHI-69" x="737" y="-213"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/402629/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjilMLmLjIcl9tVdStXZkZUbD87zQ#MJMAIN-3D" x="1143" y="0"></use><g transform="translate(2199,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/402629/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjilMLmLjIcl9tVdStXZkZUbD87zQ#MJMATHI-61" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/402629/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjilMLmLjIcl9tVdStXZkZUbD87zQ#MJMATHI-69" x="748" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/402629/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjilMLmLjIcl9tVdStXZkZUbD87zQ#MJMATHI-63" x="3323" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/402629/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjilMLmLjIcl9tVdStXZkZUbD87zQ#MJMATHI-64" x="3757" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/402629/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjilMLmLjIcl9tVdStXZkZUbD87zQ#MJMATHI-6F" x="4280" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/402629/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjilMLmLjIcl9tVdStXZkZUbD87zQ#MJMATHI-74" x="4766" y="0"></use><g transform="translate(5127,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/402629/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjilMLmLjIcl9tVdStXZkZUbD87zQ#MJMATHI-62" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/402629/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjilMLmLjIcl9tVdStXZkZUbD87zQ#MJMATHI-69" x="607" y="-213"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>k</mi><mi>i</mi></msub><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub><mtext>&nbsp;</mtext><mi>c</mi><mi>d</mi><mi>o</mi><mi>t</mi><msub><mi>b</mi><mi>i</mi></msub></math></span></span><script type="math/tex" id="MathJax-Element-1"> k_i = a_i \ cdot b_i </script></em>   <em>- bitwise AND,</em> <math> </math><em><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>h</mi><mi>i</mi></msub><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub><mo>+</mo><msub><mi>b</mi><mi>i</mi></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.904ex" height="2.419ex" viewBox="0 -780.1 5125.4 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/402629/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjilMLmLjIcl9tVdStXZkZUbD87zQ#MJMATHI-68" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/402629/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjilMLmLjIcl9tVdStXZkZUbD87zQ#MJMATHI-69" x="815" y="-213"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/402629/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjilMLmLjIcl9tVdStXZkZUbD87zQ#MJMAIN-3D" x="1198" y="0"></use><g transform="translate(2254,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/402629/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjilMLmLjIcl9tVdStXZkZUbD87zQ#MJMATHI-61" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/402629/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjilMLmLjIcl9tVdStXZkZUbD87zQ#MJMATHI-69" x="748" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/402629/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjilMLmLjIcl9tVdStXZkZUbD87zQ#MJMAIN-2B" x="3350" y="0"></use><g transform="translate(4351,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/402629/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjilMLmLjIcl9tVdStXZkZUbD87zQ#MJMATHI-62" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/402629/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjilMLmLjIcl9tVdStXZkZUbD87zQ#MJMATHI-69" x="607" y="-213"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>h</mi><mi>i</mi></msub><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub><mo>+</mo><msub><mi>b</mi><mi>i</mi></msub></math></span></span><script type="math/tex" id="MathJax-Element-2"> h_i = a_i + b_i </script></em>   <em>- bitwise OR</em> </p><br><p>  As a result, implementing a parallel transfer is quite expensive.  However, it can be noted that the subsequent discharge contains the equation for calculating the previous one (there should be a meme "yes okay" with Nicolas Cage), so in principle it will be enough to make a transfer calculation scheme only for the senior level, and collect the rest from it, providing output intermediate results. </p><br><img src="https://habrastorage.org/files/4df/28d/64b/4df28d64bcdd4e41804483213342fc8a.png"><br><p>  <em>Figure 5: The complete circuit of a 16-bit parallel-transfer adder</em> </p><br><p>  In Figure 5, the first two columns are the adders themselves.  Then come the 2AND and 2OR blocks, which form the intermediate values ‚Äã‚Äãof h and k appearing in Figure 4. Their presence prompted me to expand the list of commands with logical addition and multiplication, for which I need to add only a couple of latches and the corresponding microcode. </p><br><p>  Everything else is 5AND units based on 4 RES64 relays, which can be soldered so that one module can be used, for example, 2AND + 3AND.  These blocks each logical step And output through the diode, which allows you to collect intermediate signals transfer. </p><br><p>  Estimated signal propagation time: adders cope for 1 $, at this time, signals are generated at the outputs of the 2AND / 2OR units, then, 1 $.  - multiplication in 5AND blocks, logical addition on diodes, does not introduce a delay.  Well, the last one cu.  spent on the calculation of the adder. </p><br><p>  Total 3 cu.  suprotiv 32, or not more than 4.5 ms to work the adder. </p><br><h2 id="registry">  Registers </h2><br><p>  In the car, four 16-bit specialized register.  No RON s.  Only a tight binding, only hardcore!  It consists of D-flip-flops, each D-flip-flop is a separate module for 4 RES55 relays with the following scheme: </p><br><img src="https://habrastorage.org/files/67e/b6f/f92/67eb6ff92b294f4a9ac193582e7f2aa0.jpg"><br><p>  <em>Figure 6: Schematic diagram of the module D-trigger.</em>  <em>Somewhere there is another connector, but here it is not important, because everything is signed.</em> </p><br><p>  The data comes to the Data input, the relay of which determines where the synchronization signal goes - to reset the trigger, or to set it (for which two more relays are responsible, one with self-blocking).  The fourth relay gets the switching output Q. A very useful feature. </p><br><h2 id="plata-pamyati">  Memory board </h2><br><img src="https://habrastorage.org/files/b75/f2f/bef/b75f2fbefffd4d12aa1c0d045e18f874.jpg"><br><p>  <em>Figure 7: Memory Board.</em>  <em>Board dimensions 315x200mm</em> </p><br><p>  A very complex and important element, although the memory scheme itself constitutes a small part of the total filling of the block.  The task of this board is, first of all, to carry 64 kilograms of shared memory of programs and data.  It is assembled on the basis of two 64 KB cache chips.  The address input through the protection circuit and the switch connects to the computer address bus, and from the data bus side there is a complex system from the input buffer and the output driver, also with the switch.  Two lines W / R and Sync are responsible for reading and writing to memory.  The first chooses what we will do, the second will actually do it. </p><br><p>  And while this Sync itself is gone, the memory board naturally lives its own life.  On the render you can see two 16x16 LED arrays.  This display displays some memory.  A kind of VideoRAM, determined by software, by the way.  Interrogates the memory chip and controls the output of the Atmega1280 microcontroller. </p><br><p>  For this task, the microcontroller does not end.  It hangs console input and output.  Where it will lead to - I have not decided yet, therefore, the motherboard is divorced with a USB-Serial converter for a regular console and ESp8266 for Wi-Fi.  According to the latest, the most relevant plans are to have a web page with the ability to download programs for a computer into memory and the console itself.  Yes, the tasks of the MC also include the initial download of the program to the RAM, for which it has full access to the RAM, as well as a small 1Mbit EEPROM for storing programs. </p><br><img src="https://habrastorage.org/files/8d3/620/24c/8d362024c8c04df680f8bc2a5a53a6cd.jpg"><br><p>  <em>Figure 8: Schematic diagram of the memory board.</em>  <em>Microcontroller and block circuit not shown</em> </p><br><h2 id="blok-logiki">  Logic block </h2><br><p>  I have no idea how it will look like in the end.  The latest version is present on the general scheme of the computer, but I do not like it.  Most likely I will do a 12-step sequencer and with the help of the keys I will send signals to separate blocks. </p><br><img src="https://habrastorage.org/files/107/480/a84/107480a848914e7286ec88021385dd88.jpg"><br><p>  <em>Figure 9: Everything around the 16-bit blocks is the logic block.</em> </p><br><h2 id="konstrukciya">  Design </h2><br><p>  The machine is modular, block-frame.  On  it is visually shown as the stuffing of the car will settle down.  But first things first: </p><br><h1 id="modul">  Module </h1><br><p>  The basic element of the computer is a 60x44mm module, with a 16-pin connector, carrying 4 relays, their binding, and 4 LEDs for indication: </p><br><img src="https://habrastorage.org/files/650/4da/5d0/6504da5d00ba42ecb3eb272370fd92f8.jpg"><br><p>  <em>Figure 10: 3D model of the module</em> </p><br><p>  Modules of various types: </p><br><ol><li>  1-bit transfer adder - 16; </li><li>  Module 5AND for parallel transfer scheme - 32 pcs; </li><li>  D-flip-flop module - 64 pcs per registers, plus a bit of logic; </li><li>  Module 4x2AND_SW, for the organization of latches.  There are just 4 closing relays; </li><li>  4x2AND module, for the organization of latches.  Here are 3 relays of 4 with a changeover contact.  4 relays did not have enough output connector; </li><li>  Diode module, 8 D226D diodes.  To organize a multi-input OR </li><li>  The universal 2AND / 2OR module allows you to create 2AND-NOT, 2OR-NOT, 4AND, 4AND-NOT, 4OR, 4OR-NOT and any combinations.  Based on 4 relays with switching contacts and common points; </li></ol><br><p>  Since I invented the control logic block, I already rejected it, I don‚Äôt know the exact number of modules of each type.  I'll figure it out on the way.  The estimated number of modules - 192 pieces. </p><br><h1 id="blok">  Block </h1><br><p>  We take a 150x200mm board, solder 32 connectors for 16 pins on it, and not simple ones, but <a href="https://geektimes.ru/post/258798/">install it with wrap</a> and install our modules on an 8x4 matrix, getting such a block: </p><br><img src="https://habrastorage.org/files/012/981/0c4/0129810c41a8415aa3ed543cbc79e47f.jpg"><br><p>  <em>Figure 11: Block</em> </p><br><p>  In my car there will be 6 such units - two blocks for an adder, two for registers and two for logic.  Scratching a turnip for a couple more blocks of latches, but if they do, they will be flat and soldered </p><br><p>  Wrap-up installation was chosen because: firstly, the circuitry of each baseboard is known in advance, but it can be changed and error prone.  Secondly, in principle, it is impossible to dilute a block of logic from the first time correctly, and if everything is clear for the block of registers as a whole and one can make a mistake with, say, a synchronization line, then the logic will have to be redone a thousand and one times.  It will be much better if you build each component of the logic block gradually.  Thirdly, it is a purely mechanical factor - it is physically impossible to separate these blocks on a double-layer board :) 16-bit tires diverge in all directions, which intersect with each other many times. </p><br><p>  Total each block contains 32 modules, with a total number of relays 128 pieces.  Power supply of each unit - 5V 2A. </p><br><h1 id="kompyuter">  Computer </h1><br><p>  On a large frame, 640x480mm in size (in fact a little more, but a beautiful number) six relay blocks and a memory board are placed: </p><br><img src="https://habrastorage.org/files/fe5/217/f56/fe5217f56d15451c890f7f01b86d9c32.jpg"><br><p>  <em>Figure 12: Machine Block Arrangement</em> </p><br><p>  The entire computer is inserted into a wooden frame of precious wood, with glass in front and behind. </p><br><h2 id="izgotovlenie">  Manufacturing </h2><br><p>  Despite today's date, the project actually exists :-) And is not in the most active, but still the manufacturing stage. </p><br><h1 id="rele">  Relay </h1><br><p>  I have them.  In large quantities, but the problem is that out of a more kilo-tight supply there are three hundred - a 27-volt relay and a 5-volt RES55 might not be enough for me.  The scale of the disaster cannot be assessed definitively, but I think in the ensuing time that I will be collecting this hellish machine, the problem will disappear due to the replenishment of stocks from outside. </p><br><img src="https://habrastorage.org/files/d90/065/573/d90065573e5640e9b290f7b623732c17.jpg"><br><p>  <em>Figure 13: Relay Stocks.</em>  <em>800 relay units - new, successfully picked up at the Mitinsky radio market for a penny</em> </p><br><p>  One of the sources of replenishment of stocks are relay boards DAC from laboratory power supplies.  Here are these: </p><br><img src="https://habrastorage.org/files/a7b/4e3/547/a7b4e35475444a50bc1ec89647d20427.jpg"><br><p>  <em>Figure 14: Boards from power supply units of type BP, purchased on the radio market (no, I myself don‚Äôt bother with BPshniki)</em> </p><br><h1 id="pechatnye-platy">  Printed circuit boards </h1><br><p>  All the printed circuit boards I decided to do myself.  I pinned 300 bucks to the Chinese and for 4 months I have been engaged in covering the workpiece with a photoresist, showing through, hounding, covering it with a solder mask, showing it, drilling it in a milling cutter. </p><br><img src="https://habrastorage.org/files/fca/713/a66/fca713a6619b460499051e07f8c2a999.JPG"><br><p>  <em>Figure 15: Etched Panels of Various Types</em> </p><br><p>  I make the boards with plates, 9 modules on a 200x150mm plate.  Rinse 30 plates and stuck on applying a solder mask.  All I can not begin.  My solder mask for me is FSR-8000 blue, two-component and I have already dealt with it earlier. </p><br><p>  Plates 200x150mm were not chosen by chance - on our radio market, in one secret place, such ones have been selling steadily for many years, and all of my adaptations are customized for this format. </p><br><p>  In the word photoresist (MPF-VShch from Diazonium) I began to apply using a laminator and this is just miracles.  The quality of bonding has increased significantly. </p><br><p>  Then it will be necessary to cut and drill these boards, for which I even have a 3D router. </p><br><img src="https://habrastorage.org/files/d40/88f/5dd/d4088f5dd8e54549b4ea8f565b5f075a.jpg"><br><p>  <em>Figure 16: 3D Chinese milling machine DIY 2020CNC</em> </p><br><p>  I took it for a modest $ 175 exclusively for electronics.  Boards to drill and mill will suffice, and I already glance at the sets of ball screw + rails for 3D machines.  Ready to buy such a little expensive, and collect yourself when he begins to be required - the very thing. </p><br><p>  Here in this review you can learn more about my machine: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/0F5jdi7wreg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="programmy">  Programs </h2><br><p>  Programs are loaded into the computer using a microcontroller, which means that he should know what and where to ship.  For this there is a special format (in the state of the draft, of course) of the binary file a la Elf.  The number, size and addresses of sections of code and data (as well as where the contents of these sections lie in the file) are written in the file header.  <em>// TODO Do not forget to add a section of video memory - we also have an LED panel, it is necessary to tell the microcontroller what kind of display it should be</em> . </p><br><p>  Having a microcontroller allows me to: a.  control the correctness of the program, b.  provide a secure memory mode.  You can catch Segmentation Fault! </p><br><p>  In general, you need a compiler.  I tried dozens of different popular interpreters - everyone executes the same program in different ways.  <a href="https://copy.sh/brainfuck/">LeBrainfuck</a> turned out to be the <a href="https://copy.sh/brainfuck/">most stable</a> , it does broadcast the program into its format and executes it correctly. <br>  <a href="https://github.com/radiolok/bfutils">I wrote my compiler</a> , at the moment its code is terrible, but it allows you to translate the usual Brainfuck into a binary format of my machine.  Supports minimizing + - &lt;&gt; commands, but the conversion of the [-] sequence to cell reset is not implemented.  Well, a bunch of other features, including support for add.  instructions are also not made. </p><br><p>  There is a simple emulator.  The emulator at the time of this writing also supports only the basic 8 instructions.  Here is what he does with the fractal program: </p><br><img src="https://habrastorage.org/files/f4e/5b4/e94/f4e5b4e949c94111ab3379b34f7b6923.jpg"><br><p>  Execution time - a little less than 10 seconds.  An adequate LLVM version found in the fields can cope in 0.9 seconds.  About how I using Intel Vtune Amplifier optimized my emulator and clocked from 120 seconds to 10 deserves a separate article. </p><br><p>  But it is not important.  To derive this fractal, it took 3 billion optimized brainfuck instructions.  Taking into account the design frequency of 100 Hz and 50 lines of text, we get 347 machine days - i.e.  almost a YEAR per program, or a line of output per week!  In fact, we will wait for the first line by the end of the first day, but the farther, the slower.  On the other hand, it is the fastest on-off relay computer out of all existing and designed. </p><br><p>  Behind this, the information is essentially over, so I suggest watching a small video review of other relay computers that exist in nature </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/whk8NKAdsB8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <a href="https://hackaday.io/project/11798-relay-based-projects">Here</a> is the most comprehensive in my opinion list of all relay machines at the moment. </p><br><h2 id="myslishki">  Thoughts </h2><br><p>  I want to use a part of stocks of vacuum indicators IV-6 in the form of a long board in the upper part of the machine, which displays in real time the values ‚Äã‚Äãof all the registers, as well as the total number of instructions executed and the total time of the computer.  But here I can not decide on the source of this data - the MK in the memory board is packed to capacity, and it can only emulate some of the values.  The best option is to read the values ‚Äã‚Äãdirectly.  According to the control scheme of IV-shkami themselves, I also cannot come to a unanimous opinion - it is more problematic to make a dynamic display of 30-40 IV-shek than for 6 pieces of a desk clock. </p><br><h2 id="zacheeeem777">  WHY? ???? 777 </h2><br><img src="https://habrastorage.org/files/1fb/f24/c16/1fbf24c164974f8fabba8e7e03e5856b.jpg"><br><h2 id="ssylki">  Links </h2><br><p>  The whole project in openSource.  Therefore, here are the main links on the project: </p><br><ol><li>  <a href="https://github.com/radiolok/RelayComputer2">https://github.com/radiolok/RelayComputer2</a> is a repository with schematics and PCB layout.  A link to the repository of the memory card firmware I will add later </li><li>  <a href="">https://github.com/radiolok/RelayComputer2/blob/master/roadmap.md</a> I will separately note this page with the project roadmap, on which key changes are recorded. </li><li>  <a href="https://hackaday.io/project/18599-brainfuck-relay-computer">https://hackaday.io/project/18599-brainfuck-relay-computer</a> on this page I publish detailed reports about what has been done.  On a set of critical mass, they will turn into an article on the GT. </li><li>  <a href="https://github.com/radiolok/bfutils">https://github.com/radiolok/bfutils</a> compiler and emulator. </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/402629/">https://habr.com/ru/post/402629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../402619/index.html">A robotic vertical farm grows plants 400% more efficient than a regular farm.</a></li>
<li><a href="../402621/index.html">Journey to Mars: what can happen with an astronaut on the way to the planet and on its surface</a></li>
<li><a href="../402623/index.html">CampStove 2: Camping Stove, from which you can charge gadgets</a></li>
<li><a href="../402625/index.html">CO2 Lamp (mh-z19)</a></li>
<li><a href="../402627/index.html">Does Russia have a chance of leadership in the "marathon of artificial intelligence"?</a></li>
<li><a href="../402631/index.html">Which heart rate monitor to choose in the new season: compromise solutions within three or four thousand rubles</a></li>
<li><a href="../402633/index.html">The tale of Battlefield 1 in Full HD on the integrated graphics and assembly console for the "netlenok"</a></li>
<li><a href="../402635/index.html">Uber suspends robots after a crash</a></li>
<li><a href="../402637/index.html">17-year-old schoolboy fixed NASA error</a></li>
<li><a href="../402639/index.html">Peter Watts on the game SOMA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>