<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Regular expressions, a guide for beginners. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first half of this tutorial, we revealed only a small part of the possibilities of regular expressions. In the second, larger half, we will loo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Regular expressions, a guide for beginners. Part 2</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/blogs/python/115825/">first half of</a> this tutorial, we revealed only a small part of the possibilities of regular expressions.  In the second, larger half, we will look at some new metacharacters, how to use groups to get parts of the matched text, break lines, find and replace parts of the text.  In the end, let's talk a little about common mistakes. <br><a name="habracut"></a><br><h4>  More metacharacters </h4><br>  There are some metacharacters that we have not yet learned.  Most of them will be covered in this section. <br><br>  Some of the remaining metacharacters are <i>assertions of zero size</i> .  They do not cause the engine to pass through the line, they do not cover any characters at all, just success or failure is possible.  For example, <code>\b</code> is the statement that the current position is on the boundary ( <i>boundary</i> ) of the word, while the <code>\b</code> character itself does not change the position.  This means that statements of zero size should never be repeated, because if they coincided once in a given place, they will obviously correspond to this place an infinite number of times. <br><br> <code>|</code> <br>  Corresponds to the operator OR.  If A and B are regular expressions, then <code>A|B</code> will match any string that matches A or B. Metacharacter <code>|</code>  has a very low priority in order to make it work intelligently when you alternate several characters of a string.  Crow | Servo will look for a match for either <code>Crow</code> or <code>Servo</code> , not <code>Cro('w'  'S')ervo</code> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <code>^</code> <br>  Searches for a match only at the beginning of a line.  If the <code>MULTILINE</code> flag is <code>MULTILINE</code> , as mentioned in the last part, then a comparison is made for each part after the newline character. <br><br>  For example, if you want to find only those lines that have <code>From</code> at the beginning, then <code>^From</code> written in a regular expression: <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">print</font> <font color="#dc143c">re</font> .  <font>search</font> <font>(</font> <font color="#483d8b">'^ From'</font> , <font color="#483d8b">'From Here to Eternity'</font> <font>)</font> <br>  <font color="#66cc66">&lt;</font> _sre.  <font>SRE_Match</font> <font color="#008000">object</font> at 0x ... <font color="#66cc66">&gt;</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">print</font> <font color="#dc143c">re</font> .  <font>search</font> <font>(</font> <font color="#483d8b">'^ From'</font> , <font color="#483d8b">'Reciting From Memory'</font> <font>)</font> <br>  <font color="#008000">None</font> </blockquote><br><br> <code>$</code> <br>  Same as <code>^</code> , but at the end of a line, which is determined either by the end of the line itself or by the newline character. <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">print</font> <font color="#dc143c">re</font> .  <font>search</font> <font>(</font> <font color="#483d8b">'} $'</font> , <font color="#483d8b">'{block}'</font> <font>)</font> <br>  <font color="#66cc66">&lt;</font> _sre.  <font>SRE_Match</font> <font color="#008000">object</font> at 0x ... <font color="#66cc66">&gt;</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">print</font> <font color="#dc143c">re</font> .  <font>search</font> <font>(</font> <font color="#483d8b">'} $'</font> , <font color="#483d8b">'{block}'</font> <font>)</font> <br>  <font color="#008000">None</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">print</font> <font color="#dc143c">re</font> .  <font>search</font> <font>(</font> <font color="#483d8b">'} $'</font> , <font color="#483d8b">'{block} <font color="#000099">\ n</font> '</font> <font>)</font> <br>  <font color="#66cc66">&lt;</font> _sre.  <font>SRE_Match</font> <font color="#008000">object</font> at 0x ... <font color="#66cc66">&gt;</font> </blockquote><br><br> <code>\A</code> <br>  The match is only at the beginning of the line, that is, the same as <code>^</code> , but does not depend on the <code>MULTILINE</code> flag <br><br> <code>\Z</code> <br>  The match is only at the end of the line, that is, the same as <code>$</code> , but does not depend on the <code>MULTILINE</code> flag <br><br> <code>\b</code> <br>  Word boundary  A word is defined as a sequence of characters of numbers and / or letters, so that word boundaries represent spaces or any characters not related to the above. <br><br>  The following example searches for the word <code>class</code> only when it is a separate word.  If it is contained within another word, there is no match: <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> p = <font color="#dc143c">re</font> .  <font color="#008000">compile</font> <font>(</font> r <font color="#483d8b">' <font color="#000099">\ b</font> class <font color="#000099">\ b</font> '</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">print</font> p.  <font>search</font> <font>(</font> <font color="#483d8b">'no class at all'</font> <font>)</font> <br>  <font color="#66cc66">&lt;</font> _sre.  <font>SRE_Match</font> <font color="#008000">object</font> at 0x ... <font color="#66cc66">&gt;</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">print</font> p.  <font>search</font> <font>(</font> <font color="#483d8b">'the declassified algorithm'</font> <font>)</font> <br>  <font color="#008000">None</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">print</font> p.  <font>search</font> <font>(</font> <font color="#483d8b">'one subclass is'</font> <font>)</font> <br>  <font color="#008000">None</font> </blockquote><br><br>  There are two subtleties that you must remember when using this special sequence.  First, this is one of the worst collisions between Python string literals and regular expression sequences: in Python string literals, <code>\b</code> is the backspace character, ASCII value 8. If you do not use raw strings, Python will convert <code>\b</code> to backspace, and Your regular expression will not be as intended: <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> p = <font color="#dc143c">re</font> .  <font color="#008000">compile</font> <font>(</font> <font color="#483d8b">' <font color="#000099">\ b</font> class <font color="#000099">\ b</font> '</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">print</font> p.  <font>search</font> <font>(</font> <font color="#483d8b">'no class at all'</font> <font>)</font> <br>  <font color="#008000">None</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">print</font> p.  <font>search</font> <font>(</font> <font color="#483d8b">' <font color="#000099">\ b</font> '</font> + <font color="#483d8b">'class'</font> + <font color="#483d8b">' <font color="#000099">\ b</font> '</font> <font>)</font> <br>  <font color="#66cc66">&lt;</font> _sre.  <font>SRE_Match</font> <font color="#008000">object</font> at 0x ... <font color="#66cc66">&gt;</font> </blockquote><br><br>  Secondly, it is impossible to use this combination inside a character class, because the <code>\b</code> combination for compatibility with string literals Python represents the backspace character. <br><br>  \ B <br>  The opposite of the previous combination corresponding to the current position is not on the word boundary. <br><br><h4>  Grouping </h4><br>  It is often necessary to get more information than just to find out if PB is matching or not.  Regular expressions are often used to cut strings by writing regular expressions, divided into several subgroups that correspond to the various components of the query.  For example, in the RFC-822 standard, there are various fields in the header, separated by a colon: <br><br> <code>From: author@example.com <br> User-Agent: Thunderbird 1.5.0.9 (X11/20061227) <br> MIME-Version: 1.0 <br> To: editor@example.com</code> <br> <br>  This can be processed by writing a regular expression that matches the entire header line, and there is one group that corresponds to the name of the header, and another group that corresponds to the value of the title. <br><br>  Groups are indicated by metacharacters in the form of parentheses <code>'(', ')'</code> .  <code>'('</code> and <code>')'</code> have the same meaning as in mathematical expressions;  they group together the expressions contained in them, and you can repeat the contents of the group with repeating qualifiers such as <code>*, +, ?</code>  and <code>{m, n}</code> .  For example, <code>(ab)*</code> will match zero or more <code>ab</code> repetitions. <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> p = <font color="#dc143c">re</font> .  <font color="#008000">compile</font> <font>(</font> <font color="#483d8b">'(ab) *'</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">print</font> p.  <font>match</font> <font>(</font> <font color="#483d8b">'ababababab'</font> <font>)</font> .  <font>span</font> <font>(</font> <font>)</font> <br>  <font>(</font> <font color="#ff4500">0</font> , <font color="#ff4500">10</font> <font>)</font> </blockquote><br><br>  The groups defined by the brackets also capture the starting and ending indices of the matching text;  this can be obtained by passing the argument <code>group(), start(), end()</code> and <code>span()</code> .  Groups are numbered, starting with 0. Group 0 is always present, it is the entire regular expression itself, so <code>MatchObject</code> methods always contain 0 as the default argument: <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> p = <font color="#dc143c">re</font> .  <font color="#008000">compile</font> <font>(</font> <font color="#483d8b">'(a) b'</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> m = p.  <font>match</font> <font>(</font> <font color="#483d8b">'ab'</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> m.  <font>group</font> <font>(</font> <font>)</font> <br>  <font color="#483d8b">'ab'</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> m.  <font>group</font> <font>(</font> <font color="#ff4500">0</font> <font>)</font> <br>  <font color="#483d8b">'ab'</font> </blockquote><br><br>  Subgroups are numbered from left to right, from 1 onwards.  Groups can be nested;  in order to determine the number of attachments, simply count left-to-right symbols of the opening bracket: <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> p = <font color="#dc143c">re</font> .  <font color="#008000">compile</font> <font>(</font> <font color="#483d8b">'(a (b) c) d'</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> m = p.  <font>match</font> <font>(</font> <font color="#483d8b">'abcd'</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> m.  <font>group</font> <font>(</font> <font color="#ff4500">0</font> <font>)</font> <br>  <font color="#483d8b">'abcd'</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> m.  <font>group</font> <font>(</font> <font color="#ff4500">1</font> <font>)</font> <br>  <font color="#483d8b">'abc'</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> m.  <font>group</font> <font>(</font> <font color="#ff4500">2</font> <font>)</font> <br>  <font color="#483d8b">'b'</font> </blockquote><br><br>  <code>group()</code> can simultaneously accept several group numbers in a single request, and a tuple containing the values ‚Äã‚Äãfor the respective groups will be returned: <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> m.  <font>group</font> <font>(</font> <font color="#ff4500">2</font> , <font color="#ff4500">1</font> , <font color="#ff4500">2</font> <font>)</font> <br>  <font>(</font> <font color="#483d8b">'b'</font> , <font color="#483d8b">'abc'</font> , <font color="#483d8b">'b'</font> <font>)</font> </blockquote><br><br>  The <code>groups()</code> method returns a tuple of strings for all subgroups, starting from the 1st: <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> m.  <font>groups</font> <font>(</font> <font>)</font> <br>  <font>(</font> <font color="#483d8b">'abc'</font> , <font color="#483d8b">'b'</font> <font>)</font> </blockquote><br><br>  Backlinks in a template allow you to specify that the content of a previously captured group should also be found at the current line position.  For example, <code>\1</code> corresponds to the fact that the content of group 1 is exactly repeated in the current position. <br><br>  For example, the following PB detects repeated words in a row twice in a row: <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> p = <font color="#dc143c">re</font> .  <font color="#008000">compile</font> <font>(</font> r <font color="#483d8b">'( <font color="#000099">\ b</font> <font color="#000099">\ w</font> +) <font color="#000099">\ s</font> + <font color="#000099">\ 1</font> '</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> p.  <font>search</font> <font>(</font> <font color="#483d8b">'Paris in the spring'</font> <font>)</font> .  <font>group</font> <font>(</font> <font>)</font> <br>  <font color="#483d8b">'the the'</font> </blockquote><br><br>  Backlinks, such as this one, are not often useful for searching a string, but you'll soon find out that they are very useful when performing a string replacement. <br><br><h5>  Capture Groups and Named Groups </h5><br>  Regular expressions can use many groups, both for capturing the required substring, and for grouping and structuring the RVs themselves.  In complex regular expressions, it becomes difficult to keep track of group numbers.  There are two features that help to deal with this problem.  Both of them use a common syntax for extending regular expressions, which we therefore consider first. <br><br>  Several additional functions for standard regular expressions have been added to Perl 5, and the <code>re</code> module supports most of them.  It would be difficult to choose new single-character metacharacters or new sequences with backslashes in order to introduce new features so that Perl regular expressions are different from standard regular expressions without confusion.  If you choose as a new metacharacter, for example, <code>&amp;</code> , then the old regular expressions would accept it as a regular character and you could not escape it <code>\&amp;</code> or <code>[&amp;]</code> . <br><br>  The solution chosen by Perl developers was to use <code>(?...)</code> as an extension of the syntax.  The question mark after the bracket in the case of a normal RV is a syntax error, since <code>?</code>  there is nothing to repeat, so this does not lead to any compatibility problems.  Characters right after <code>?</code>  show what extension is used, so <code>(?=foo)</code> is one thing (a positive statement about the preview), and <code>(?:foo)</code> is something else (a group without content capture, including the subexpression <code>foo</code> ). <br><br>  A native extension is added to the Perl extended syntax in Python.  If the first character is after the question mark <code>P</code> , then this means that a Python-specific extension is used.  Currently there are two such extensions: ( <code>?P&lt;some_name&gt;...</code> ) defines a named group, and ( <code>?P=some_name</code> ) serves as a backward link for it.  If similar features using a different syntax are added in future versions of Perl 5, the <code>re</code> module will be modified to support the new syntax, while maintaining the Python syntax for compatibility. <br><br>  Sometimes you need to use a group to collect parts of a regular expression, but you are not interested in retrieving the contents of the group.  You can do this using a group without capturing content: <code>(?:...)</code> , where you can replace <code>...</code> any other regular expression: <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> m = <font color="#dc143c">re</font> .  <font>match</font> <font>(</font> <font color="#483d8b">"([abc]) +"</font> , <font color="#483d8b">"abc"</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> m.  <font>groups</font> <font>(</font> <font>)</font> <br>  <font>(</font> <font color="#483d8b">'c'</font> , <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> m = <font color="#dc143c">re</font> .  <font>match</font> <font>(</font> <font color="#483d8b">"(?: [abc]) +"</font> , <font color="#483d8b">"abc"</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> m.  <font>groups</font> <font>(</font> <font>)</font> <br>  <font>(</font> <font>)</font> </blockquote><br><br>  Except that you don‚Äôt get the content of what the group matched with, these groups behave just like normal ones;  you can put anything into them, repeat using the appropriate symbol, such as <code>*</code> , and insert them into other groups (data collection or not). <br><br>  A more important feature is the named groups: instead of referring to them by numbers, these groups can be referenced by name. <br><br>  Named group syntax is one of the specific Python extensions: <code>(?P&lt;some_name&gt;...)</code> .  Named groups behave exactly like normal, but in addition to this they are associated with some name.  The <code>MatchObject</code> methods that were used for ordinary groups accept both numbers that refer to the group number, as well as strings containing the name of the required group.  That is, named groups still accept numbers as well, so you can get information about a group in two ways: <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> p = <font color="#dc143c">re</font> .  <font color="#008000">compile</font> <font>(</font> r <font color="#483d8b">'(? P &lt;word&gt; <font color="#000099">\ b</font> <font color="#000099">\ w</font> + <font color="#000099">\ b</font> )'</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> m = p.  <font>search</font> <font>(</font> <font color="#483d8b">'((((Lots of punctuation))))'</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> m.  <font>group</font> <font>(</font> <font color="#483d8b">'word'</font> <font>)</font> <br>  <font color="#483d8b">'Lots'</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> m.  <font>group</font> <font>(</font> <font color="#ff4500">1</font> <font>)</font> <br>  <font color="#483d8b">'Lots'</font> </blockquote><br><br>  Named groups are convenient in that they allow the use of easy-to-remember names instead of numbers.  Here is an example of a regular expression from the <code>imaplib</code> module: <br><br><blockquote>  InternalDate = <font color="#dc143c">re</font> .  <font color="#008000">compile</font> <font>(</font> r <font color="#483d8b">'INTERNALDATE "'</font> <br>  r <font color="#483d8b">'(? P &lt;day&gt; [123] [0-9]) - (? P &lt;mon&gt; [AZ] [az] [az]) -'</font> <br>  r <font color="#483d8b">'(? P &lt;year&gt; [0-9] [0-9] [0-9] [0-9])'</font> <br>  r <font color="#483d8b">'(? P &lt;hour&gt; [0-9] [0-9]) :(? P &lt;min&gt; [0-9] [0-9]) :(? P &lt;sec&gt; [0-9] [ 0-9])</font> <br>  r <font color="#483d8b">'(? P &lt;zonen&gt; [- +]) (? P &lt;zoneh&gt; [0-9] [0-9]) (? P &lt;zonem&gt; [0-9] [0-9])'</font> <br>  r <font color="#483d8b">'"'</font> <font>)</font> </blockquote><br><br>  The syntax of backlinks in a regular expression of the type <code>(...)\1</code> refers to the group number.  It would be more natural to use group names instead of numbers.  Another Python extension: <code>(?P=name)</code> indicates that the contents of the named group must again be matched at the current position.  Our previous regular expression for searching for duplicate words, <code>(\b\w+)\s+\1</code> can also be written as <code>(?P&lt;doble_word&gt;\b\w+)\s+(?P=doble_word)</code> : <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> p = <font color="#dc143c">re</font> .  <font color="#008000">compile</font> <font>(</font> r <font color="#483d8b">'(? P &lt;word&gt; <font color="#000099">\ b</font> <font color="#000099">\ w</font> +) <font color="#000099">\ s</font> + (? P = word)'</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> p.  <font>search</font> <font>(</font> <font color="#483d8b">'Paris in the spring'</font> <font>)</font> .  <font>group</font> <font>(</font> <font>)</font> <br>  <font color="#483d8b">'the the'</font> </blockquote><br><br><h5>  Advance checks </h5><br>  Checks are available in a positive and negative (retrospective) form, and look like this: <br><br> <code>(?=...)</code> <br>  Positive check.  Corresponds to the case when the contained expression, represented here as <code>...</code> , corresponds to the current position.  But, after the contained expression has been tested, the comparing engine does not advance further;  the remainder of the template is compared further to the right of the place where the statement begins. <br><br> <code>(?!...)</code> <br>  A negative check corresponds to the case when the expression contained does not match the current position of the line. <br><br>  For specifics, consider the case in which a preview is useful.  Consider a simple template for comparing a file name and splitting it into parts: the name itself and the extension, separated by a dot. <br><br>  The pattern for this comparison is quite simple: <br><br> <code>.*[.].*$</code> <br> <br>  Note that the symbol <code>.</code>  requires special brackets, since the dot itself is a metacharacter, as seen in the same expression.  Also note the final $;  it is added to ensure that the entire remainder of the string is included in the extension. <br><br>  Now, consider the problem a little wider;  what if you want to compare the names of all files whose extension is not a <code>bat</code> ?  Several incorrect attempts: <br><br> <code>.*[.][^b].*$</code> <br>  The first attempt is to exclude the <code>bat</code> with the requirement that the first character extension be not <code>b</code> .  This is incorrect because the template will also exclude <code>foo.bar</code> . <br><br> <code>.*[.]([^b]..|.[^a].|..[^t])$</code> <br>  The expression will turn out even more sloppy when you decide to correct the first decision by a separate task of the necessary characters: the first character of the extension must not be b;  the second is not a;  the third is not t.  This will enable <code>foo.bar</code> and reject <code>autoexec.bat</code> , but requires a three-letter extension and will not work with two-character file name extensions, like <code>sendmail.cf</code> .  Then we will have to complicate the pattern again to solve this problem: <br><br> <code>.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$</code> <br>  In the third attempt, the second and third letters in order to allow the comparison of extensions that are shorter than three characters are made optional. <br><br>  The template is now really ready, it is difficult to read and understand.  Even worse, if the problem changes and you need to eliminate both the bat and the exe extensions, the template will become even more complicated and confusing. <br><br>  A negative forward check solves all these difficulties: <br><br> <code>.*[.](?!bat$).*$</code> <br>  A negative preview means: if the expression <code>bat</code> does not match this position, compare the rest of the template;  if a match is found for <code>bat$</code> , then the whole template does not suit us.  The <code>$</code> sign that encloses the expression is needed so that an expression such as <code>sample.batch</code> . <br><br>  Eliminating another extension is now also easy;  just add it as an alternative in the same statement.  The following template excludes file names that end with the <code>bat</code> or <code>exe</code> extension: <br><br> <code>.*[.](?!bat$|exe$).*$</code> <br> <br><h4>  Change strings </h4><br>  Up to this point, we simply searched for a static string.  Regular expressions are also often used to change strings in various ways, using the following pattern methods: <br><br><table><tbody><tr><td>  <b>Method / Attribute</b> </td><td>  <b>purpose</b> </td></tr><tr><td>  split () </td><td>  Break a line into a list where there is a PB match </td></tr><tr><td>  sub () </td><td>  Find all substrings of matches with RV and replace them with another string </td></tr><tr><td>  subn () </td><td>  Does the same thing as sub (), but returns a new string and the number of substitutions. </td></tr></tbody></table><br><br><h5>  String splitting </h5><br>  The <code>split()</code> template method splits a string into parts where there is a PB match, returning a list of parts.  This is similar to the <code>split()</code> string method, but provides for universality in the delimiters by which the split occurs;  ordinary <code>split()</code> provides splitting only by whitespace characters or a fixed string.  As expected, there is a modular function <code>re.split()</code> . <br><br>  <b>.split (string [, maxsplit = 0])</b> <br>  Splits a string by regular expression match.  If there are exciting brackets in the RV, then their contents will also be returned as part of the resulting list.  If <code>maxsplit</code> not zero, no more than <code>maxsplit</code> partitions are <code>maxsplit</code> , the remainder of the string will be returned as the last item in the list. <br><br>  In the following example, the delimiter is any sequence of non-alphanumeric characters. <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> p = <font color="#dc143c">re</font> .  <font color="#008000">compile</font> <font>(</font> r <font color="#483d8b">' <font color="#000099">\ W</font> +'</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> p.  <font>split</font> <font>(</font> <font color="#483d8b">'This is a test, short and sweet, of split ().'</font> <font>)</font> <br>  <font>[</font> <font color="#483d8b">'This'</font> , <font color="#483d8b">'is'</font> , <font color="#483d8b">'a'</font> , <font color="#483d8b">'test'</font> , <font color="#483d8b">'short'</font> , <font color="#483d8b">'and'</font> , <font color="#483d8b">'sweet'</font> , <font color="#483d8b">'of'</font> , <font color="#483d8b">'split'</font> , <font color="#483d8b">''</font> <font>]]</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> p.  <font>split</font> <font>(</font> <font color="#483d8b">'This is a test, short and sweet, of split ().'</font> , <font color="#ff4500">3</font> <font>)</font> <br>  <font>[</font> <font color="#483d8b">'This'</font> , <font color="#483d8b">'is'</font> , <font color="#483d8b">'a'</font> , <font color="#483d8b">'test, short and sweet, of split ().'</font>  <font>]</font> </blockquote><br><br>  Sometimes you are not only interested in what text was between delimiters, but also need to know which delimiter was used.  If the RV has exciting parentheses, then these values ‚Äã‚Äãare also returned as part of the list.  Compare: <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> p = <font color="#dc143c">re</font> .  <font color="#008000">compile</font> <font>(</font> r <font color="#483d8b">' <font color="#000099">\ W</font> +'</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> p2 = <font color="#dc143c">re</font> .  <font color="#008000">compile</font> <font>(</font> r <font color="#483d8b">'( <font color="#000099">\ W</font> +)'</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> p.  <font>split</font> <font>(</font> <font color="#483d8b">'This ... is a test.'</font> <font>)</font> <br>  <font>[</font> <font color="#483d8b">'This'</font> , <font color="#483d8b">'is'</font> , <font color="#483d8b">'a'</font> , <font color="#483d8b">'test'</font> , <font color="#483d8b">''</font> <font>]</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> p2.  <font>split</font> <font>(</font> <font color="#483d8b">'This ... is a test.'</font> <font>)</font> <br>  <font>[</font> <font color="#483d8b">'This'</font> , <font color="#483d8b">'...'</font> , <font color="#483d8b">'is'</font> , <font color="#483d8b">''</font> , <font color="#483d8b">'a'</font> , <font color="#483d8b">''</font> , <font color="#483d8b">'test'</font> , <font color="#483d8b">'.'</font>  , <font color="#483d8b">''</font> <font>]</font> </blockquote><br><br>  The function of the <code>re.split()</code> module takes the RV as the first argument, and otherwise behaves also: <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#dc143c">re</font> .  <font>split</font> <font>(</font> <font color="#483d8b">'[ <font color="#000099">\ W</font> ] +'</font> , <font color="#483d8b">'Words, words, words.'</font> <font>)</font> <br>  <font>[</font> <font color="#483d8b">'Words'</font> , <font color="#483d8b">'words'</font> , <font color="#483d8b">'words'</font> , <font color="#483d8b">''</font> <font>]</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#dc143c">re</font> .  <font>split</font> <font>(</font> <font color="#483d8b">'([ <font color="#000099">\ W</font> ] +)'</font> , <font color="#483d8b">'Words, words, words.'</font> <font>)</font> <br>  <font>[</font> <font color="#483d8b">'Words'</font> , <font color="#483d8b">','</font> , <font color="#483d8b">'words'</font> , <font color="#483d8b">','</font> , <font color="#483d8b">'words'</font> , <font color="#483d8b">'.'</font>  , <font color="#483d8b">''</font> <font>]</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#dc143c">re</font> .  <font>split</font> <font>(</font> <font color="#483d8b">'[ <font color="#000099">\ W</font> ] +'</font> , <font color="#483d8b">'Words, words, words.'</font> , <font color="#ff4500">1</font> <font>)</font> <br>  <font>[</font> <font color="#483d8b">'Words'</font> , <font color="#483d8b">'words, words.'</font>  <font>]</font> </blockquote><br><br><h5>  Search and replace </h5><br>  Another common task is to find all matches with the pattern and replace them with another string.  The <code>sub()</code> method takes as its argument the value of the replacement part (which can be both a string and a function) and the string that is to be processed. <br><br>  <b>.sub (replacement, string [, count = 0])</b> <br>  Returns the string resulting from the replacement.  If the pattern is not found, the string is returned unchanged. <br><br>  The optional <code>count</code> argument is the maximum number of matches to replace. <br><br>  A simple example of using the <code>sub()</code> method.  Color names are replaced by the word <code>colour</code> : <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> p = <font color="#dc143c">re</font> .  <font color="#008000">compile</font> <font>(</font> <font color="#483d8b">'(blue | white | red)'</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> p.  <font>sub</font> <font>(</font> <font color="#483d8b">'color'</font> , <font color="#483d8b">'blue socks and red shoes'</font> <font>)</font> <br>  <font color="#483d8b">'color socks and color shoes'</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> p.  <font>sub</font> <font>(</font> <font color="#483d8b">'color'</font> , <font color="#483d8b">'blue socks and red shoes'</font> , count = <font color="#ff4500">1</font> <font>)</font> <br>  <font color="#483d8b">'color socks and red shoes'</font> </blockquote><br><br>  The subn () method does the same, but returns a tuple containing the new string and the number of substitutions made: <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> p = <font color="#dc143c">re</font> .  <font color="#008000">compile</font> <font>(</font> <font color="#483d8b">'(blue | white | red)'</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> p.  <font>subn</font> <font>(</font> <font color="#483d8b">'color'</font> , <font color="#483d8b">'blue socks and red shoes'</font> <font>)</font> <br>  <font>(</font> <font color="#483d8b">'color socks and color shoes'</font> , <font color="#ff4500">2</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> p.  <font>subn</font> <font>(</font> <font color="#483d8b">'color'</font> , <font color="#483d8b">'no colors at all'</font> <font>)</font> <br>  <font>(</font> <font color="#483d8b">'no colors at all'</font> , <font color="#ff4500">0</font> <font>)</font> </blockquote><br><br>  Empty matches are replaced only when they are not adjacent to the previous match: <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> p = <font color="#dc143c">re</font> .  <font color="#008000">compile</font> <font>(</font> <font color="#483d8b">'x *'</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> p.  <font>sub</font> <font>(</font> <font color="#483d8b">'-'</font> , <font color="#483d8b">'abxd'</font> <font>)</font> <br>  <font color="#483d8b">'-abd-'</font> </blockquote><br><br>  If the string is a surrogate, then escaping characters are supported.  So, <code>\n</code> is a single newline character, <code>\r</code> is a carriage return, and so on.  Backlinks, such as <code>\6</code> are replaced by a substring that matches the corresponding group in the RV.  This allows you to include parts of the original text in the result of the replacement line. <br><br>  The example corresponds to the word <code>section</code> in the part of the line preceding the part in curly brackets <code>{, }</code> , and replaces the <code>section</code> with a <code>subsection</code> : <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> p = <font color="#dc143c">re</font> .  <font color="#008000">compile</font> <font>(</font> <font color="#483d8b">'section {([^}] *)}'</font> , <font color="#dc143c">re</font> . <font>VERBOSE</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> p.  <font>sub</font> <font>(</font> r <font color="#483d8b">'subsection { <font color="#000099">\ 1</font> }'</font> , <font color="#483d8b">'section {First} section {second}'</font> <font>)</font> <br>  <font color="#483d8b">'subsection {First} subsection {second}'</font> </blockquote><br><br>  It is also possible to refer to named groups.  To do this, use the sequence <code>\g&lt;...&gt;</code> , where as <code>...</code> can be a number or the name of a group.  <code>\g&lt;2&gt;</code> is equivalent to <code>\2</code> , but it is not ambiguous in terms such as <code>\g&lt;2&gt;0</code> .  ( <code>\20</code> will be interpreted as a reference to group 20, and not as a second group followed by the literal '0'.) The following operations are equivalent, but use three different ways: <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> p = <font color="#dc143c">re</font> .  <font color="#008000">compile</font> <font>(</font> <font color="#483d8b">'section {(? P &lt;name&gt; [^}] *)}'</font> , <font color="#dc143c">re</font> . <font>VERBOSE</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> p.  <font>sub</font> <font>(</font> r <font color="#483d8b">'subsection { <font color="#000099">\ 1</font> }'</font> , <font color="#483d8b">'section {First}'</font> <font>)</font> <br>  <font color="#483d8b">'subsection {First}'</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> p.  <font>sub</font> <font>(</font> r <font color="#483d8b">'subsection { <font color="#000099">\ g</font> &lt;1&gt;}'</font> , <font color="#483d8b">'section {First}'</font> <font>)</font> <br>  <font color="#483d8b">'subsection {First}'</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> p.  <font>sub</font> <font>(</font> r <font color="#483d8b">'subsection { <font color="#000099">\ g</font> &lt;name&gt;}'</font> , <font color="#483d8b">'section {First}'</font> <font>)</font> <br>  <font color="#483d8b">'subsection {First}'</font> </blockquote><br><br>  A Deputy may also be a function that gives you more control.  If so, the function is called for each non-overlapping pattern.  Each time the function is called, it is passed as a <code>MatchObject</code> argument. <br><br>  In the following example, the replacement function converts decimal numbers to hexadecimal numbers: <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">def</font> hexrepl <font>(</font> match <font>)</font> : <br>  ... <font color="#483d8b">"Return the hex string for a decimal number"</font> <br>  ... <font>value</font> = <font color="#008000">int</font> <font>(</font> match. <font>group</font> <font>(</font> <font>)</font> <font>)</font> <br>  ... <font color="#ff7700">return</font> <font color="#008000">hex</font> <font>(</font> value <font>)</font> <br>  ... <br>  <font color="#66cc66">&gt;&gt;&gt;</font> p = <font color="#dc143c">re</font> .  <font color="#008000">compile</font> <font>(</font> r <font color="#483d8b">' <font color="#000099">\ d</font> +'</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> p.  <font>sub</font> <font>(</font> hexrepl, <font color="#483d8b">'Call 65490 for printing, 49152 for user code.'</font> <font>)</font> <br>  <font color="#483d8b">'Call 0xffd2 for printing, 0xc000 for user code.'</font> </blockquote><br><br><h4>  Common problems </h4><br>  Regular expressions are a powerful tool for some applications, but in some respects their behavior is not intuitive, and sometimes they do not behave as you would expect from them.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This section will point out some of the most common mistakes. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Using string methods </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sometimes using a module </font></font><code>re</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is a mistake. </font><font style="vertical-align: inherit;">If you are looking for a fixed string or a single character, and you do not need to use any special features </font></font><code>re</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then all the power of regular expressions is not required for this. </font><font style="vertical-align: inherit;">Strings have several methods for operations with fixed strings and they are usually much faster because they are optimized for this purpose. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine you need to replace one fixed line with another, for example, replace a word </font></font><code>word</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with a word </font></font><code>deed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Here, of course, the function is suitable </font></font><code>re.sub()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but consider the string method </font></font><code>replace()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Note that it </font></font><code>replace()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will also replace </font></font><code>word</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inside words by changing </font></font><code>swordfish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to</font></font><code>sdeedfish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but a simple regular expression will do the same. </font><font style="vertical-align: inherit;">(To avoid performing substitution on parts of words, the template should contain </font></font><code>\bword\b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another common task is to remove a single character from a string or replace it with another character. </font><font style="vertical-align: inherit;">You can do this with something like this </font></font><code>re.sub('\n', ' ', S)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but the </font></font><a href="http://docs.python.org/library/stdtypes.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">translate ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">will handle both tasks and do it faster than any regular expression. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In short, before using the module </font></font><code>re</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, see if the problem can be solved by faster and simpler string methods.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> match () versus search () </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function </font></font><code>match()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">searches for a PB at the beginning of a line, while it </font></font><code>search()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">searches for a match for the entire line. </font><font style="vertical-align: inherit;">It is important to keep in mind this distinction:</font></font><br><br><blockquote> <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">print</font> <font color="#dc143c">re</font> . <font>match</font> <font>(</font> <font color="#483d8b">'super'</font> , <font color="#483d8b">'superstition'</font> <font>)</font> . <font>span</font> <font>(</font> <font>)</font> <br> <font>(</font> <font color="#ff4500">0</font> , <font color="#ff4500">5</font> <font>)</font> <br> <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">print</font> <font color="#dc143c">re</font> . <font>match</font> <font>(</font> <font color="#483d8b">'super'</font> , <font color="#483d8b">'insuperable'</font> <font>)</font> <br>  <font color="#008000">None</font> <br> <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">print</font> <font color="#dc143c">re</font> . <font>search</font> <font>(</font> <font color="#483d8b">'super'</font> , <font color="#483d8b">'superstition'</font> <font>)</font> . <font>span</font> <font>(</font> <font>)</font> <br> <font>(</font> <font color="#ff4500">0</font> , <font color="#ff4500">5</font> <font>)</font> <br> <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">print</font> <font color="#dc143c">re</font> . <font>search</font> <font>(</font> <font color="#483d8b">'super'</font> , <font color="#483d8b">'insuperable'</font> <font>)</font> . <font>span</font> <font>(</font> <font>)</font> <br> <font>(</font> <font color="#ff4500">2</font> , <font color="#ff4500">7</font> <font>)</font> </blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You may be tempted to always use </font></font><code>re.match()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">just adding in front of your regular expression </font></font><code>.*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Resist this temptation, and use it instead </font></font><code>re.search()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The regular expression compiler makes a small analysis of RVs in order to speed up the matching process. One type of analysis is to determine what should be the first match character, for example, a match with a pattern starting with </font></font><code>Crow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">must start with </font></font><code>'C'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This analysis leads to the fact that the engine quickly runs through the string in the search for the initial character, and begins a full comparison only if the character 'C' is found. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adding</font></font><code>.*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">negates this optimization, requiring scanning to the end of the line and then returning to compare the remainder of the regular expression. </font><font style="vertical-align: inherit;">Use instead </font></font><code>re.search()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Greedy against non-greedy </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When repeated in a RT, such as </font></font><code>a*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the resultant action eats as much of the pattern as possible. </font><font style="vertical-align: inherit;">This often burns those who want to find a pair of symmetrical determinants, such as the angle brackets &lt;&gt; surrounding the HTML tags. </font><font style="vertical-align: inherit;">A naive approach to the HTML tag matching pattern will not work because of its ‚Äúgreedy‚Äù nature </font></font><code>.*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><blockquote> <font color="#66cc66"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt;&gt;&gt;</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s = </font></font><font color="#483d8b"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'&lt;html&gt; &lt;head&gt; &lt;title&gt; Title &lt;/ title&gt;' </font></font></font> <br> <font color="#66cc66"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt;&gt;&gt; </font></font></font> <font color="#008000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">len </font></font></font> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s </font></font><font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></font> <br>  <font color="#ff4500">32</font> <br> <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">print</font> <font color="#dc143c">re</font> . <font>match</font> <font>(</font> <font color="#483d8b">'&lt;.*&gt;'</font> , s <font>)</font> . <font>span</font> <font>(</font> <font>)</font> <br> <font>(</font> <font color="#ff4500">0</font> , <font color="#ff4500">32</font> <font>)</font> <br> <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">print</font> <font color="#dc143c">re</font> . <font>match</font> <font>(</font> <font color="#483d8b">'&lt;.*&gt;'</font> , s <font>)</font> . <font>group</font> <font>(</font> <font>)</font> <br> <font color="#66cc66">&lt;</font> html <font color="#66cc66">&gt;&lt;</font> head <font color="#66cc66">&gt;&lt;</font> title <font color="#66cc66">&gt;</font> Title <font color="#66cc66">&lt;</font> /title <font color="#66cc66">&gt;</font> </blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PB matches </font></font><code>'&lt;'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the first tag - html, and </font></font><code>.*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">takes the rest of the line. As a result, the mapping extends from the opening </font></font><code>'&lt;'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tag </font></font><code>html</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to the closing bracket of the </font></font><code>&gt;'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">closing tag </font></font><code>/title</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which, of course, is not what we wanted. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In such a case, the solution is to use non-greedy determinants </font></font><code>*?, +?, ??</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>{m,n}?</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that match as little text as possible. In the example above, the first character '&gt;' after '&lt;' will be selected, and only if it fails, the engine will continue to try to find the character '&gt;' in the next position, depending on how long the tag name is. This gives the desired result:</font></font><br><br><blockquote> <font color="#66cc66"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt;&gt;&gt; </font></font></font> <font color="#ff7700"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">print </font></font></font> <font color="#dc143c"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">re</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">match </font></font></font> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></font> <font color="#483d8b"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'&lt;. *?&gt;'</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , s </font></font><font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">group </font></font></font> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></font> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></font> <br> <font color="#66cc66"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> html </font></font><font color="#66cc66"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt;</font></font></font> </blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Note that parsing HTML or XML using regular expressions is painful. A hastily made template can do some things, but collapses when the page code changes. A well-designed template can be </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">too</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> complicated to try to modify. For such tasks, it is better to use HTML or XML parser modules.)</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Using re.VERBOSE </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By now you‚Äôve probably noticed that PBs are very compact, but sometimes they‚Äôre not very readable. RVs of moderate complexity can be long sequences of slashes, parentheses, metacharacters, which makes them difficult to read and understand. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For such RTs, it may be useful to specify the VERBOSE flag when compiling a regular expression because it allows the regular expression to be formatted in a clearer way. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The VERBOSE flag has several features. Spaces in RVs that are not inside a character class are ignored. This means that expressions such as </font></font><code>dog | cat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">equivalent are less readable, without a string </font></font><code>dog|cat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but [ab] will still match the characters</font></font><code>'a', 'b'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or space. </font><font style="vertical-align: inherit;">In addition, you can also put comments inside a PB that last from a character </font></font><code>#</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to the next line. </font><font style="vertical-align: inherit;">Formatting will be more accurate with triple quotes:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pat = </font></font><font color="#dc143c"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">re</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><font color="#008000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compile </font></font></font> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> r </font></font><font color="#483d8b"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"" " </font></font><br> <font color="#000099"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ s</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * #Skip leading whitespace </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(? P &lt;header&gt; [^:] +) # Header name </font></font><br> <font color="#000099"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ s</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> *: # Whitespace, and a colon </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(? P &lt;value&gt;. *?) # The header's value - *? used to </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lose the following trailing whitespace </font></font><br> <font color="#000099"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ s</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * $ </font><font style="vertical-align: inherit;">trailing </font><font style="vertical-align: inherit;">whitespace to end-of-line </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"" "</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><font color="#dc143c"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">re</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VERBOSE </font></font></font> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></font> </blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It is much easier to read than: </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pat = </font></font><font color="#dc143c"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">re</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><font color="#008000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compile </font></font></font> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> r </font></font><font color="#483d8b"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" </font></font><font color="#000099"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ s</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * (? P &lt;header&gt; [^:] +) </font></font><font color="#000099"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ s</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * :(? P &lt;value&gt;. *?) </font></font><font color="#000099"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ s</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * $" </font></font></font> <font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></font> </blockquote><br><br><h4>  Finally </h4><br> <a href="http://docs.python.org/library/re.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentation of the </font></font></a> <br> <a href="http://habrahabr.ru/blogs/regex/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habrablog ‚ÄúRegular Expressions‚Äù </font></font></a> <br> <a href="http://gskinner.com/RegExr/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">module Regexp editor</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/115436/">https://habr.com/ru/post/115436/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../115428/index.html">The idea of ‚Äã‚ÄãDoctrine I18n in Magento</a></li>
<li><a href="../115430/index.html">Getting money from AdSense through Rapida Online to a bank account</a></li>
<li><a href="../115432/index.html">Profit about MeeGo and robots</a></li>
<li><a href="../115433/index.html">Simple import / export to CSV for PHP & MySQL</a></li>
<li><a href="../115435/index.html">Cowon D3 Review</a></li>
<li><a href="../115437/index.html">The task of the blue-eyed islanders</a></li>
<li><a href="../115438/index.html">VoIP apps available in Samsung Apps Store</a></li>
<li><a href="../115439/index.html">Is TDL4 botnet rented out?</a></li>
<li><a href="../115440/index.html">Opera Widgets - Facts and Figures</a></li>
<li><a href="../115442/index.html">iPhone 4 now unlockable?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>