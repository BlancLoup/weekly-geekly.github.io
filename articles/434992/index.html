<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>IDA Pro Upgrade. Debugger for Sega Mega Drive (part 1)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings 


 Comrades reversers, romhackers: basically this article will be devoted to you. In it, I will tell you how to write your plugin debugger ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>IDA Pro Upgrade. Debugger for Sega Mega Drive (part 1)</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/mj/6l/rl/mj6lrl7zl2pq7itjpw3cr3s15fw.png"></p><br><p>  Greetings </p><br><p> Comrades reversers, romhackers: basically this article will be devoted to you.  In it, I will tell you how to write your plugin debugger for <code>IDA Pro</code> .  Yes, it was already the <a href="https://habr.com/post/262433/">first attempt to start a story</a> , but since then much water has flowed under the bridge, many principles have been revised.  In general, drove! <a name="habracut"></a></p><br><h4 id="liricheskoe-vstuplenie">  Lyrical introduction </h4><br><p>  Actually, from the previous articles ( <a href="https://habr.com/post/339138/">one</a> , <a href="https://habr.com/company/pt/blog/424263/">two</a> , <a href="https://habr.com/company/pt/blog/424457/">three</a> ), I think it will not be a secret that my favorite processor is the <code>Motorola 68000</code> .  By the way, my favorite old woman <code>Sega Mega Drive</code> / <code>Genesis</code> works on it.  And, since it was always interesting to me, how did the Segov games work, I had decided from the first months of owning a computer deeply and for a long time to get into the wilds of disassembling and reversing. </p><br><p>  This is how <a href="https://github.com/lab313ru/smd_ida_tools">Smd IDA Tools appeared</a> . <br>  The project includes various auxiliary things that make the work on the study of roms on Segou much easier: bootloader, debugger, helper on the commands of <code>VDP</code> .  Everything was written for <code>IDA 6.8</code> , and it worked well.  But when I decided to tell the world how I did it all the same, it became clear that it would be very difficult to show such code to people, and, moreover, to describe it.  Therefore, I could not do it then. </p><br><p>  And then <code>IDA 7.0</code> came out.  The desire to port your project under it appeared right away, but the architecture of the <code>Gens</code> emulator, on the basis of which I wrote the debugger, turned out to be unsuitable for porting: assembler inserts for <code>x86</code> , crutches, difficult to understand code, and much more.  And the game <code>Pier Solar and the Great Architects</code> , released on cartridges in 2010, and which I wanted to explore so much (and there are plenty of anti-emulation tricks), did not start in <code>Gens</code> ' e. </p><br><p><img src="https://habrastorage.org/webt/5f/in/pg/5finpgxicxyqorxx1qa50ka7zne.jpeg"></p><br><p>  In search of a suitable emulator source code, which could be adapted for a debugger, I finally came across <code>EkeEke</code> <a href="https://github.com/ekeeke/Genesis-Plus-GX">Genesis Plus GX</a> .  So this article appeared. </p><br><h2 id="chast-pervaya-yadro-otladchika">  Part One: Debugger Core </h2><br><p>  Musashi handles emulation of motorola processor instructions in the <code>Genesis Plus GX</code> .  In its original source code there is already a basic debugging functionality (a hook for executing instructions), but <code>EkeEke</code> decided to remove it as superfluous.  Return. </p><br><p><img src="https://habrastorage.org/webt/qp/1v/ls/qp1vls4m3ghzf3aqmknj-23xulu.png"></p><br><p><img src="https://habrastorage.org/webt/tr/wp/rw/trwprwbfno8tkajpbfaftwyqyu8.png"></p><br><p>  Now the most important thing: you need to decide on the debugger architecture.  The requirements are as follows: </p><br><ul><li>  Breakpoints (breakpoints) for execution, reading and writing to memory </li><li>  Functional <code>Step Into</code> , <code>Step Over</code> </li><li>  Pause, Continue ( <code>Resume</code> ) Emulation </li><li>  Read / set registers, read / write memory </li></ul><br><p>  If these four points are the work of the debugger from the inside, then you need to think about access to this functionality from the outside.  Add one more item: </p><br><ul><li>  Protocol of debugger-server (kernel) communication with debugger-client (GUI, user) </li></ul><br><h3 id="yadro-otladchika-spisok-bryakov">  Debugger Kernel: Break List </h3><br><p>  To implement the list we have the following structure: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">breakpoint_s</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">breakpoint_s</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">, *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> enabled; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; <span class="hljs-keyword"><span class="hljs-keyword">bpt_type_t</span></span> type; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> address; } <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span>;</code> </pre> <br><p>  The <code>next</code> and <code>prev</code> fields will store pointers to the next and previous element, respectively. <br>  The <code>enabled</code> field will store <code>0</code> if you want to skip this breakpoint in the triggers. <br>  <code>width</code> - the number of bytes starting from the address in the <code>address</code> field that the breakpoint covers. <br>  Well, in the <code>type</code> field we will keep the type of the breach (execution, reading, writing).  More details below. </p><br><p>  To work with the list of breakpoints, I added the following functions: </p><br><div class="spoiler">  <b class="spoiler_title">Functions for working with breakpoints</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *first_bp = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> breakpoint_t *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_bpt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bpt_type_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *bp = (<span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span>)); bp-&gt;type = type; bp-&gt;address = address; bp-&gt;width = width; bp-&gt;enabled = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first_bp) { bp-&gt;next = first_bp; bp-&gt;prev = first_bp-&gt;prev; first_bp-&gt;prev = bp; bp-&gt;prev-&gt;next = bp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { first_bp = bp; bp-&gt;next = bp; bp-&gt;prev = bp; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bp; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete_breakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">breakpoint_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * bp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bp == first_bp) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bp-&gt;next == bp) { first_bp = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { first_bp = bp-&gt;next; } } bp-&gt;next-&gt;prev = bp-&gt;prev; bp-&gt;prev-&gt;next = bp-&gt;next; <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(bp); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> breakpoint_t *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next_breakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">breakpoint_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bp-&gt;next != first_bp ? bp-&gt;next : <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> breakpoint_t *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_breakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bpt_type_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *p; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (p = first_bp; p; p = next_breakpoint(p)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((p-&gt;address == address) &amp;&amp; ((p-&gt;type == BPT_ANY) || (p-&gt;type &amp; type))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove_bpt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bpt_type_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *bpt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((bpt = find_breakpoint(address, type))) delete_breakpoint(bpt); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count_bpt_list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *p; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (p = first_bp; p; p = next_breakpoint(p)) { ++i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_bpt_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bpt_data_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *p; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (p = first_bp; p; p = next_breakpoint(p)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == index) { data-&gt;address = p-&gt;address; data-&gt;width = p-&gt;width; data-&gt;type = p-&gt;type; data-&gt;enabled = p-&gt;enabled; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } ++i; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear_bpt_list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (first_bp != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) delete_breakpoint(first_bp); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_bpt_list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first_bp) clear_bpt_list(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check_breakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bpt_type_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dbg_req || !dbg_req-&gt;dbg_active || dbg_dont_check_bp) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *bp; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (bp = first_bp; bp; bp = next_breakpoint(bp)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(bp-&gt;type &amp; type) || !bp-&gt;enabled) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((address &lt;= (bp-&gt;address + bp-&gt;width)) &amp;&amp; ((address + width) &gt;= bp-&gt;address)) { dbg_req-&gt;dbg_paused = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre> </div></div><br><h3 id="yadro-otladchika-osnovnye-peremennye">  Debugger Core: Main Variables </h3><br><p>  Actually, I spied this implementation in another <a href="https://archive.codeplex.com/%3Fp%3Dpcsxr">PCSXR</a> debugger. </p><br><p>  Add variables that will store the emulation state: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dbg_first_paused, dbg_trace, dbg_dont_check_bp; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dbg_step_over; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dbg_last_pc; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dbg_step_over_addr; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dbg_active, dbg_paused;</code> </pre> <br><p>  The <code>dbg_first_paused</code> variable will be responsible for stopping the emulation at the start of debugging.  If <code>0</code> - then you need to pause the emulation and send a message to the client that the emulation has started.  After the first pause, set to <code>1</code> . </p><br><p>  <code>dbg_trace</code> we need to execute one instruction at a time ( <code>Step Into</code> functionality).  If it is equal to <code>1</code> , we execute one instruction, we pause, and reset the value to <code>0</code> . </p><br><p>  I started the variable <code>dbg_dont_check_bp</code> so that the read / write memory breaks do not work if the debugger does. </p><br><p>  We will store <code>dbg_step_over</code> <code>1</code> if we are in <code>Step Over</code> mode until the current <code>PC</code> ( <em>Program Counter</em> , also <em>Instruction Pointer</em> ) becomes equal to the address in <code>dbg_step_over_addr</code> .  After that both variables are reset.  I‚Äôll tell you about the calculation of the <code>dbg_step_over_addr</code> value later. </p><br><p>  I <code>dbg_last_pc</code> variable for one specific case: when we are already on the breakpoint and the client requests <code>Resume</code> .  To prevent the bryak from working again, I compare the address of the last <code>PC</code> in this variable with the new one, and if the values ‚Äã‚Äãare different, you can check the breakpoint on the current <code>PC</code> . </p><br><p>  <code>dbg_active</code> - in fact, it stores state <code>1</code> when debugging is active and you need to check the breakpoints, process requests from the client. </p><br><p>  With the <code>dbg_paused</code> variable, I think everything is clear: <code>1</code> - we are paused (for example, after the breakpoint has triggered) and we expect commands from the client, <code>0</code> - we follow the instructions. </p><br><p>  We write functions for working with these variables: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pause_debugger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ dbg_trace = <span class="hljs-number"><span class="hljs-number">1</span></span>; dbg_paused = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resume_debugger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ dbg_trace = <span class="hljs-number"><span class="hljs-number">0</span></span>; dbg_paused = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detach_debugger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ clear_bpt_list(); resume_debugger(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">activate_debugger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ dbg_active = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deactivate_debugger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ dbg_active = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  We see that in the implementation of <code>detach_debugger()</code> I used to clear the list of bryaks.  This is to ensure that after disconnecting the client, the old breakpoints do not continue to operate. </p><br><h3 id="yadro-otladchika-realizuem-huk-na-instrukcii">  Debugger kernel: implement the instructions hook </h3><br><p>  Actually, the main work with pause, continuation of emulation, <code>Step Into</code> , <code>Step Over</code> will take place here. </p><br><p>  This is the code for the <code>process_breakpoints()</code> function: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_breakpoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> handled_event = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> is_step_over = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> is_step_in = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dbg_active) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pc = m68k_get_reg(M68K_REG_PC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dbg_paused &amp;&amp; dbg_first_paused &amp;&amp; !dbg_trace) longjmp(jmp_env, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dbg_first_paused) { dbg_first_paused = <span class="hljs-number"><span class="hljs-number">1</span></span>; dbg_paused = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Send emulation started event } if (dbg_trace) { is_step_in = 1; dbg_trace = 0; dbg_paused = 1; // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Send event that Step Into has been triggered handled_event = 1; } if (!dbg_paused) { if (dbg_step_over &amp;&amp; pc == dbg_step_over_addr) { is_step_over = 1; dbg_step_over = 0; dbg_step_over_addr = 0; dbg_paused = 1; } if (dbg_last_pc != pc) check_breakpoint(BPT_M68K_E, 1, pc, pc); if (dbg_paused) { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Send event about Step Over or breakpoint has been triggered handled_event = 1; } } if (dbg_first_paused &amp;&amp; (!handled_event) &amp;&amp; dbg_paused) { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Send paused event } dbg_last_pc = pc; if (dbg_paused &amp;&amp; (!is_step_in || is_step_over)) { longjmp(jmp_env, 1); } }</span></span></code> </pre> <br><p>  Let's understand: </p><br><ol><li>  If debugging is not enabled, just exit the hook </li><li>  The trick with <code>setjmp</code> / <code>longjmp</code> needed because the <code>RetroArch</code> shell <code>RetroArch</code> , for which its own version of <code>Genesis Plus GX</code> was written, with which we start the emulation, hangs waiting for the output from the frame rendering function, which the emulator implements.  I will show the second part of the trick later, because  it concerns already the shell over the emulator, rather than the core. </li><li>  If this is our first triggering of the hook, and, accordingly, the beginning of the emulation, pause and send the event to start the emulation to the client. </li><li>  If the client previously sent the <code>Step Into</code> command, reset the value of the <code>dbg_trace</code> variable and pause the emulation.  We send to the client the corresponding event. </li><li>  If we are not on a pause, the <code>Step Over</code> mode is enabled, and the current <code>PC</code> is equal to the destination address <code>dbg_step_over_addr</code> , <code>dbg_step_over_addr</code> necessary variables and paused. </li><li>  We check breakpoint if we are not on it now, and if the breakpoint has worked, we pause and send a <code>Step Over</code> or Breakpoint event to the client. </li><li>  If this is not a breakpoint, not <code>Step Into</code> , and not <code>Step Over</code> , then the client has asked for a pause.  We send event about the pause. </li><li>  We implement a trick with <code>longjump</code> as the implementation of an infinite loop of waiting for actions from the client during a pause. </li></ol><br><p>  The code for calculating the address for <code>Step Over</code> was not as simple as it might have been supposed at first.  A motorol processor has different lengths of instructions, so you have to read the address of the next one manually, depending on the opcode.  In addition, one should avoid instructions like <code>bra</code> , <code>jmp</code> , <code>rts</code> conditional jumps forward, and follow them as <code>Step Into</code> .  The implementation is as follows: </p><br><div class="spoiler">  <b class="spoiler_title">Calc_step_over () function code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calc_step_over</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pc = m68k_get_reg(M68K_REG_PC); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sp = m68k_get_reg(M68K_REG_SP); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> opc = m68ki_read_imm_16(); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dest_pc = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// jsr if ((opc &amp; 0xFFF8) == 0x4E90) { m68k_op_jsr_32_ai(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFF8) == 0x4EA8) { m68k_op_jsr_32_di(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFF8) == 0x4EB0) { m68k_op_jsr_32_ix(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EB8) { m68k_op_jsr_32_aw(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EB9) { m68k_op_jsr_32_al(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EBA) { m68k_op_jsr_32_pcdi(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EBB) { m68k_op_jsr_32_pcix(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } // bsr else if ((opc &amp; 0xFFFF) == 0x6100) { m68k_op_bsr_16(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x61FF) { m68k_op_bsr_32(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFF00) == 0x6100) { m68k_op_bsr_8(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } // dbf else if ((opc &amp; 0xfff8) == 0x51C8) { dest_pc = m68k_get_reg(M68K_REG_PC) + 2; } m68k_set_reg(M68K_REG_PC, pc); m68k_set_reg(M68K_REG_SP, sp); return dest_pc;</span></span></code> </pre> </div></div><br><h3 id="yadro-otladchika-inicializaciya-i-ostanovka-otladki">  Debugger kernel: initialize and stop debugging </h3><br><p>  Everything is simple: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop_debugging</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Send Stopped event to client detach_debugger(); deactivate_debugger(); dbg_first_paused = dbg_paused = dbg_trace = dbg_dont_check_bp = dbg_step_over = dbg_step_over_addr = dbg_last_pc = 0; } void start_debugging() { if (dbg_active) return; activate_debugger(); init_bpt_list(); dbg_first_paused = dbg_paused = dbg_trace = dbg_dont_check_bp = dbg_step_over = dbg_step_over_addr = dbg_last_pc = 0; }</span></span></code> </pre> <br><h3 id="yadro-otladchika-realizaciya-protokola">  Debugger kernel: protocol implementation </h3><br><p>  The communication protocol between the debug server and the client user can be called the second heart of the debugging process, since  it implements the functionality of processing requests from the client, and reactions to them. <br>  It was decided to implement on the basis of <em>Shared Memory</em> , because you need to send large blocks of memory: <code>VRAM</code> , <code>RAM</code> , <code>ROM</code> , and over the network it will be all the more enjoyable. </p><br><p>  The essence is this: the kernel creates shared memory with a predetermined structure, and waits for incoming requests from the client.  After processing the request, the response is stored in the same memory, and the corresponding information is added to the debugger's event list in the same memory. </p><br><p>  The prototype was chosen as follows: </p><br><div class="spoiler">  <b class="spoiler_title">Source code debug_wrap.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _DEBUG_WRAP_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _DEBUG_WRAP_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __cplusplus extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Windows.h&gt; #define SHARED_MEM_NAME "GX_PLUS_SHARED_MEM" #define MAX_BREAKPOINTS 1000 #define MAX_DBG_EVENTS 20 #ifndef MAXROMSIZE #define MAXROMSIZE ((unsigned int)0xA00000) #endif #pragma pack(push, 4) typedef enum { BPT_ANY = (0 &lt;&lt; 0), // M68K BPT_M68K_E = (1 &lt;&lt; 0), BPT_M68K_R = (1 &lt;&lt; 1), BPT_M68K_W = (1 &lt;&lt; 2), BPT_M68K_RW = BPT_M68K_R | BPT_M68K_W, // VDP BPT_VRAM_R = (1 &lt;&lt; 3), BPT_VRAM_W = (1 &lt;&lt; 4), BPT_VRAM_RW = BPT_VRAM_R | BPT_VRAM_W, BPT_CRAM_R = (1 &lt;&lt; 5), BPT_CRAM_W = (1 &lt;&lt; 6), BPT_CRAM_RW = BPT_CRAM_R | BPT_CRAM_W, BPT_VSRAM_R = (1 &lt;&lt; 7), BPT_VSRAM_W = (1 &lt;&lt; 8), BPT_VSRAM_RW = BPT_VSRAM_R | BPT_VSRAM_W, // Z80 BPT_Z80_E = (1 &lt;&lt; 11), BPT_Z80_R = (1 &lt;&lt; 12), BPT_Z80_W = (1 &lt;&lt; 13), BPT_Z80_RW = BPT_Z80_R | BPT_Z80_W, // REGS BPT_VDP_REG = (1 &lt;&lt; 9), BPT_M68K_REG = (1 &lt;&lt; 10), } bpt_type_t; typedef enum { REQ_NO_REQUEST, REQ_GET_REGS, REQ_SET_REGS, REQ_GET_REG, REQ_SET_REG, REQ_READ_68K_ROM, REQ_READ_68K_RAM, REQ_WRITE_68K_ROM, REQ_WRITE_68K_RAM, REQ_READ_Z80, REQ_WRITE_Z80, REQ_ADD_BREAK, REQ_TOGGLE_BREAK, REQ_DEL_BREAK, REQ_CLEAR_BREAKS, REQ_LIST_BREAKS, REQ_ATTACH, REQ_PAUSE, REQ_RESUME, REQ_STOP, REQ_STEP_INTO, REQ_STEP_OVER, } request_type_t; typedef enum { REG_TYPE_M68K = (1 &lt;&lt; 0), REG_TYPE_S80 = (1 &lt;&lt; 1), REG_TYPE_Z80 = (1 &lt;&lt; 2), REG_TYPE_VDP = (1 &lt;&lt; 3), } register_type_t; typedef enum { DBG_EVT_NO_EVENT, DBG_EVT_STARTED, DBG_EVT_PAUSED, DBG_EVT_BREAK, DBG_EVT_STEP, DBG_EVT_STOPPED, } dbg_event_type_t; typedef struct { dbg_event_type_t type; unsigned int pc; char msg[256]; } debugger_event_t; typedef struct { int index; unsigned int val; } reg_val_t; typedef struct { unsigned int d0, d1, d2, d3, d4, d5, d6, d7; unsigned int a0, a1, a2, a3, a4, a5, a6, a7; unsigned int pc, sr, sp, usp, isp, ppc, ir; } regs_68k_data_t; typedef enum { REG_68K_D0, REG_68K_D1, REG_68K_D2, REG_68K_D3, REG_68K_D4, REG_68K_D5, REG_68K_D6, REG_68K_D7, REG_68K_A0, REG_68K_A1, REG_68K_A2, REG_68K_A3, REG_68K_A4, REG_68K_A5, REG_68K_A6, REG_68K_A7, REG_68K_PC, REG_68K_SR, REG_68K_SP, REG_68K_USP, REG_68K_ISP, REG_68K_PPC, REG_68K_IR, REG_VDP_00, REG_VDP_01, REG_VDP_02, REG_VDP_03, REG_VDP_04, REG_VDP_05, REG_VDP_06, REG_VDP_07, REG_VDP_08, REG_VDP_09, REG_VDP_0A, REG_VDP_0B, REG_VDP_0C, REG_VDP_0D, REG_VDP_0E, REG_VDP_0F, REG_VDP_10, REG_VDP_11, REG_VDP_12, REG_VDP_13, REG_VDP_14, REG_VDP_15, REG_VDP_16, REG_VDP_17, REG_VDP_18, REG_VDP_19, REG_VDP_1A, REG_VDP_1B, REG_VDP_1C, REG_VDP_1D, REG_VDP_1E, REG_VDP_1F, REG_VDP_DMA_LEN, REG_VDP_DMA_SRC, REG_VDP_DMA_DST, REG_Z80_PC, REG_Z80_SP, REG_Z80_AF, REG_Z80_BC, REG_Z80_DE, REG_Z80_HL, REG_Z80_IX, REG_Z80_IY, REG_Z80_WZ, REG_Z80_AF2, REG_Z80_BC2, REG_Z80_DE2, REG_Z80_HL2, REG_Z80_R, REG_Z80_R2, REG_Z80_IFFI1, REG_Z80_IFFI2, REG_Z80_HALT, REG_Z80_IM, REG_Z80_I, } regs_all_t; typedef struct { unsigned int pc, sp, af, bc, de, hl, ix, iy, wz; unsigned int af2,bc2,de2,hl2; unsigned char r, r2, iff1, iff2, halt, im, i; } regs_z80_data_t; typedef struct { unsigned char regs_vdp[0x20]; unsigned short dma_len; unsigned int dma_src, dma_dst; } vdp_regs_t; typedef struct { int type; // register_type_t regs_68k_data_t regs_68k; reg_val_t any_reg; vdp_regs_t vdp_regs; regs_z80_data_t regs_z80; } register_data_t; typedef struct { int size; unsigned int address; unsigned char m68k_rom[MAXROMSIZE]; unsigned char m68k_ram[0x10000]; unsigned char z80_ram[0x2000]; } memory_data_t; typedef struct { bpt_type_t type; unsigned int address; int width; int enabled; } bpt_data_t; typedef struct { int count; bpt_data_t breaks[MAX_BREAKPOINTS]; } bpt_list_t; typedef struct { request_type_t req_type; register_data_t regs_data; memory_data_t mem_data; bpt_data_t bpt_data; int dbg_events_count; debugger_event_t dbg_events[MAX_DBG_EVENTS]; bpt_list_t bpt_list; int dbg_active, dbg_paused; int is_ida; } dbg_request_t; #pragma pack(pop) dbg_request_t *open_shared_mem(); void close_shared_mem(dbg_request_t **request); int recv_dbg_event(dbg_request_t *request, int wait); void send_dbg_request(dbg_request_t *request, request_type_t type); #ifdef __cplusplus } #endif #endif</span></span></span></span></code> </pre> </div></div><br><p>  The first field in the structure will be the query type: </p><br><ul><li>  reading / setting registers </li><li>  read / write memory </li><li>  work with breakpoints </li><li>  pause / continue emulation, detach / stop debugger </li><li>  <code>Step Into</code> / <code>Step Over</code> </li></ul><br><p>  Next come the registers <code>M68K</code> , <code>Z80</code> , <code>VDP</code> .  Next are the memory blocks <code>ROM</code> , <code>RAM</code> , <code>VRAM</code> , <code>Z80</code> . </p><br><p>  To add / remove breakpoints, I also started the corresponding structure.  Well, their list is also here (for the most part, it is only for display in the GUI, without having to remember all the installed bryaks, as <code>IDA</code> does). </p><br><p>  Next comes the list of debug events: </p><br><ul><li>  Debug started (required for <code>IDA Pro</code> ) </li><li>  Debugging is suspended (the <code>PC</code> saved in the event, on which the emulation is currently suspended) </li><li>  Breakpoint triggered (also stores the <code>PC</code> value on which the trigger occurred) </li><li>  <code>Step Into</code> or <code>Step Over</code> was performed (also, in fact, only needed for <code>IDA</code> , because you can get by with only one pause event) </li><li>  The emulation process has been stopped.  After clicking the <code>Stop</code> button in <code>IDA</code> without receiving this event, it will wait indefinitely </li></ul><br><p>  Armed with the idea of ‚Äã‚Äãa protocol, we implement the processing of client requests, thus obtaining the following debugger kernel code: </p><br><div class="spoiler">  <b class="spoiler_title">Debug.c source code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"debug.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"shared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> m68ki_cpu m68k #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MUL (7) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> BUILD_TABLES #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m68ki_cycles.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m68kconf.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m68kcpu.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m68kops.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"vdp_ctrl.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Z80.h"</span></span></span><span class="hljs-meta"> static int dbg_first_paused, dbg_trace, dbg_dont_check_bp; static int dbg_step_over; static int dbg_last_pc; static unsigned int dbg_step_over_addr; static dbg_request_t *dbg_req = NULL; static HANDLE hMapFile = 0; typedef struct breakpoint_s { struct breakpoint_s *next, *prev; int enabled; int width; bpt_type_t type; unsigned int address; } breakpoint_t; static breakpoint_t *first_bp = NULL; static breakpoint_t *add_bpt(bpt_type_t type, unsigned int address, int width) { breakpoint_t *bp = (breakpoint_t *)malloc(sizeof(breakpoint_t)); bp-&gt;type = type; bp-&gt;address = address; bp-&gt;width = width; bp-&gt;enabled = 1; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (first_bp) { bp-&gt;next = first_bp; bp-&gt;prev = first_bp-&gt;prev; first_bp-&gt;prev = bp; bp-&gt;prev-&gt;next = bp; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { first_bp = bp; bp-&gt;next = bp; bp-&gt;prev = bp; } return bp; } static void delete_breakpoint(breakpoint_t * bp) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (bp == first_bp) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (bp-&gt;next == bp) { first_bp = NULL; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { first_bp = bp-&gt;next; } } bp-&gt;next-&gt;prev = bp-&gt;prev; bp-&gt;prev-&gt;next = bp-&gt;next; free(bp); } static breakpoint_t *next_breakpoint(breakpoint_t *bp) { return bp-&gt;next != first_bp ? bp-&gt;next : 0; } static breakpoint_t *find_breakpoint(unsigned int address, bpt_type_t type) { breakpoint_t *p; for (p = first_bp; p; p = next_breakpoint(p)) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((p-&gt;address == address) &amp;&amp; ((p-&gt;type == BPT_ANY) || (p-&gt;type &amp; type))) return p; } return 0; } static void remove_bpt(unsigned int address, bpt_type_t type) { breakpoint_t *bpt; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((bpt = find_breakpoint(address, type))) delete_breakpoint(bpt); } static int count_bpt_list() { breakpoint_t *p; int i = 0; for (p = first_bp; p; p = next_breakpoint(p)) { ++i; } return i; } static void get_bpt_data(int index, bpt_data_t *data) { breakpoint_t *p; int i = 0; for (p = first_bp; p; p = next_breakpoint(p)) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (i == index) { data-&gt;address = p-&gt;address; data-&gt;width = p-&gt;width; data-&gt;type = p-&gt;type; data-&gt;enabled = p-&gt;enabled; break; } ++i; } } static void clear_bpt_list() { while (first_bp != NULL) delete_breakpoint(first_bp); } static void init_bpt_list() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (first_bp) clear_bpt_list(); } void check_breakpoint(bpt_type_t type, int width, unsigned int address, unsigned int value) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!dbg_req || !dbg_req-&gt;dbg_active || dbg_dont_check_bp) return; breakpoint_t *bp; for (bp = first_bp; bp; bp = next_breakpoint(bp)) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!(bp-&gt;type &amp; type) || !bp-&gt;enabled) continue; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((address </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;= (bp-&gt;address + bp-&gt;width)) &amp;&amp; ((address + width) &gt;= bp-&gt;address)) { dbg_req-&gt;dbg_paused = 1; break; } } } static void pause_debugger() { dbg_trace = 1; dbg_req-&gt;dbg_paused = 1; } static void resume_debugger() { dbg_trace = 0; dbg_req-&gt;dbg_paused = 0; } static void detach_debugger() { clear_bpt_list(); resume_debugger(); } static void activate_debugger() { dbg_req-&gt;dbg_active = 1; } static void deactivate_debugger() { dbg_req-&gt;dbg_active = 0; } int activate_shared_mem() { hMapFile = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, sizeof(dbg_request_t), SHARED_MEM_NAME); if (hMapFile == 0) { return -1; } dbg_req = (dbg_request_t*)MapViewOfFile(hMapFile, FILE_MAP_ALL_ACCESS, 0, 0, sizeof(dbg_request_t)); if (dbg_req == 0) { CloseHandle(hMapFile); return -1; } memset(dbg_req, 0, sizeof(dbg_request_t)); return 0; } void deactivate_shared_mem() { UnmapViewOfFile(dbg_req); CloseHandle(hMapFile); hMapFile = NULL; dbg_req = NULL; } static unsigned int calc_step_over() { unsigned int pc = m68k_get_reg(M68K_REG_PC); unsigned int sp = m68k_get_reg(M68K_REG_SP); unsigned int opc = m68ki_read_imm_16(); unsigned int dest_pc = (unsigned int)(-1); // jsr if ((opc &amp; 0xFFF8) == 0x4E90) { m68k_op_jsr_32_ai(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFF8) == 0x4EA8) { m68k_op_jsr_32_di(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFF8) == 0x4EB0) { m68k_op_jsr_32_ix(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EB8) { m68k_op_jsr_32_aw(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EB9) { m68k_op_jsr_32_al(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EBA) { m68k_op_jsr_32_pcdi(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EBB) { m68k_op_jsr_32_pcix(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } // bsr else if ((opc &amp; 0xFFFF) == 0x6100) { m68k_op_bsr_16(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x61FF) { m68k_op_bsr_32(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFF00) == 0x6100) { m68k_op_bsr_8(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } // dbf else if ((opc &amp; 0xfff8) == 0x51C8) { dest_pc = m68k_get_reg(M68K_REG_PC) + 2; } m68k_set_reg(M68K_REG_PC, pc); m68k_set_reg(M68K_REG_SP, sp); return dest_pc; } void process_request() { if (!dbg_req || !dbg_req-&gt;dbg_active) return; if (dbg_req-&gt;req_type == REQ_NO_REQUEST) return; switch (dbg_req-&gt;req_type) { case REQ_GET_REG: { register_data_t *regs_data = &amp;dbg_req-&gt;regs_data; if (regs_data-&gt;type &amp; REG_TYPE_M68K) regs_data-&gt;any_reg.val = m68k_get_reg(regs_data-&gt;any_reg.index); if (regs_data-&gt;type &amp; REG_TYPE_VDP) regs_data-&gt;any_reg.val = reg[regs_data-&gt;any_reg.index]; if (regs_data-&gt;type &amp; REG_TYPE_Z80) { if (regs_data-&gt;any_reg.index &gt;= 0 &amp;&amp; regs_data-&gt;any_reg.index &lt;= 12) // PC &lt;-&gt; HL2 { regs_data-&gt;any_reg.val = ((unsigned int *)&amp;Z80.pc)[regs_data-&gt;any_reg.index]; } else if (regs_data-&gt;any_reg.index &gt;= 13 &amp;&amp; regs_data-&gt;any_reg.index &lt;= 19) // R &lt;-&gt; I { regs_data-&gt;any_reg.val = ((unsigned char *)&amp;Z80.r)[regs_data-&gt;any_reg.index - 13]; } } } break; case REQ_SET_REG: { register_data_t *regs_data = &amp;dbg_req-&gt;regs_data; if (regs_data-&gt;type &amp; REG_TYPE_M68K) m68k_set_reg(regs_data-&gt;any_reg.index, regs_data-&gt;any_reg.val); if (regs_data-&gt;type &amp; REG_TYPE_VDP) reg[regs_data-&gt;any_reg.index] = regs_data-&gt;any_reg.val; if (regs_data-&gt;type &amp; REG_TYPE_Z80) { if (regs_data-&gt;any_reg.index &gt;= 0 &amp;&amp; regs_data-&gt;any_reg.index &lt;= 12) // PC &lt;-&gt; HL2 { ((unsigned int *)&amp;Z80.pc)[regs_data-&gt;any_reg.index] = regs_data-&gt;any_reg.val; } else if (regs_data-&gt;any_reg.index &gt;= 13 &amp;&amp; regs_data-&gt;any_reg.index &lt;= 19) // R &lt;-&gt; I { ((unsigned char *)&amp;Z80.r)[regs_data-&gt;any_reg.index - 13] = regs_data-&gt;any_reg.val &amp; 0xFF; } } } break; case REQ_GET_REGS: case REQ_SET_REGS: { register_data_t *regs_data = &amp;dbg_req-&gt;regs_data; if (regs_data-&gt;type &amp; REG_TYPE_M68K) { regs_68k_data_t *m68kr = &amp;regs_data-&gt;regs_68k; if (dbg_req-&gt;req_type == REQ_GET_REGS) { m68kr-&gt;d0 = m68k_get_reg(M68K_REG_D0); m68kr-&gt;d1 = m68k_get_reg(M68K_REG_D1); m68kr-&gt;d2 = m68k_get_reg(M68K_REG_D2); m68kr-&gt;d3 = m68k_get_reg(M68K_REG_D3); m68kr-&gt;d4 = m68k_get_reg(M68K_REG_D4); m68kr-&gt;d5 = m68k_get_reg(M68K_REG_D5); m68kr-&gt;d6 = m68k_get_reg(M68K_REG_D6); m68kr-&gt;d7 = m68k_get_reg(M68K_REG_D7); m68kr-&gt;a0 = m68k_get_reg(M68K_REG_A0); m68kr-&gt;a1 = m68k_get_reg(M68K_REG_A1); m68kr-&gt;a2 = m68k_get_reg(M68K_REG_A2); m68kr-&gt;a3 = m68k_get_reg(M68K_REG_A3); m68kr-&gt;a4 = m68k_get_reg(M68K_REG_A4); m68kr-&gt;a5 = m68k_get_reg(M68K_REG_A5); m68kr-&gt;a6 = m68k_get_reg(M68K_REG_A6); m68kr-&gt;a7 = m68k_get_reg(M68K_REG_A7); m68kr-&gt;pc = m68k_get_reg(M68K_REG_PC); m68kr-&gt;sr = m68k_get_reg(M68K_REG_SR); m68kr-&gt;sp = m68k_get_reg(M68K_REG_SP); m68kr-&gt;usp = m68k_get_reg(M68K_REG_USP); m68kr-&gt;isp = m68k_get_reg(M68K_REG_ISP); m68kr-&gt;ppc = m68k_get_reg(M68K_REG_PPC); m68kr-&gt;ir = m68k_get_reg(M68K_REG_IR); } else { m68k_set_reg(M68K_REG_D0, m68kr-&gt;d0); m68k_set_reg(M68K_REG_D1, m68kr-&gt;d1); m68k_set_reg(M68K_REG_D2, m68kr-&gt;d2); m68k_set_reg(M68K_REG_D3, m68kr-&gt;d3); m68k_set_reg(M68K_REG_D4, m68kr-&gt;d4); m68k_set_reg(M68K_REG_D5, m68kr-&gt;d5); m68k_set_reg(M68K_REG_D6, m68kr-&gt;d6); m68k_set_reg(M68K_REG_D7, m68kr-&gt;d7); m68k_set_reg(M68K_REG_A0, m68kr-&gt;a0); m68k_set_reg(M68K_REG_A1, m68kr-&gt;a1); m68k_set_reg(M68K_REG_A2, m68kr-&gt;a2); m68k_set_reg(M68K_REG_A3, m68kr-&gt;a3); m68k_set_reg(M68K_REG_A4, m68kr-&gt;a4); m68k_set_reg(M68K_REG_A5, m68kr-&gt;a5); m68k_set_reg(M68K_REG_A6, m68kr-&gt;a6); m68k_set_reg(M68K_REG_A7, m68kr-&gt;a7); m68k_set_reg(M68K_REG_PC, m68kr-&gt;pc); m68k_set_reg(M68K_REG_SR, m68kr-&gt;sr); m68k_set_reg(M68K_REG_SP, m68kr-&gt;sp); m68k_set_reg(M68K_REG_USP, m68kr-&gt;usp); m68k_set_reg(M68K_REG_ISP, m68kr-&gt;isp); } } if (regs_data-&gt;type &amp; REG_TYPE_VDP) { vdp_regs_t *vdp_regs = &amp;regs_data-&gt;vdp_regs; for (int i = 0; i &lt; (sizeof(vdp_regs) / sizeof(vdp_regs-&gt;regs_vdp[0])); ++i) { if (dbg_req-&gt;req_type == REQ_GET_REGS) vdp_regs-&gt;regs_vdp[i] = reg[i]; else reg[i] = vdp_regs-&gt;regs_vdp[i]; } if (dbg_req-&gt;req_type == REQ_GET_REGS) { vdp_regs-&gt;dma_len = (reg[20] &lt;&lt; 8) | reg[19]; if (!vdp_regs-&gt;dma_len) vdp_regs-&gt;dma_len = 0x10000; vdp_regs-&gt;dma_src = vdp_dma_calc_src(); vdp_regs-&gt;dma_dst = vdp_dma_get_dst(); } } if (regs_data-&gt;type &amp; REG_TYPE_Z80) { regs_z80_data_t *z80r = &amp;regs_data-&gt;regs_z80; if (dbg_req-&gt;req_type == REQ_GET_REGS) { z80r-&gt;pc = Z80.pc.d; z80r-&gt;sp = Z80.sp.d; z80r-&gt;af = Z80.af.d; z80r-&gt;bc = Z80.bc.d; z80r-&gt;de = Z80.de.d; z80r-&gt;hl = Z80.hl.d; z80r-&gt;ix = Z80.ix.d; z80r-&gt;iy = Z80.iy.d; z80r-&gt;wz = Z80.wz.d; z80r-&gt;af2 = Z80.af2.d; z80r-&gt;bc2 = Z80.bc2.d; z80r-&gt;de2 = Z80.de2.d; z80r-&gt;hl2 = Z80.hl2.d; z80r-&gt;r = Z80.r; z80r-&gt;r2 = Z80.r2; z80r-&gt;iff1 = Z80.iff1; z80r-&gt;iff2 = Z80.iff2; z80r-&gt;halt = Z80.halt; z80r-&gt;im = Z80.im; z80r-&gt;i = Z80.i; } else { Z80.pc.d = z80r-&gt;pc; Z80.sp.d = z80r-&gt;sp; Z80.af.d = z80r-&gt;af; Z80.bc.d = z80r-&gt;bc; Z80.de.d = z80r-&gt;de; Z80.hl.d = z80r-&gt;hl; Z80.ix.d = z80r-&gt;ix; Z80.iy.d = z80r-&gt;iy; Z80.wz.d = z80r-&gt;wz; Z80.af2.d = z80r-&gt;af2; Z80.bc2.d = z80r-&gt;bc2; Z80.de2.d = z80r-&gt;de2; Z80.hl2.d = z80r-&gt;hl2; Z80.r = z80r-&gt;r; Z80.r2 = z80r-&gt;r2; Z80.iff1 = z80r-&gt;iff1; Z80.iff2 = z80r-&gt;iff2; Z80.halt = z80r-&gt;halt; Z80.im = z80r-&gt;im; Z80.i = z80r-&gt;i; } } } break; case REQ_READ_68K_ROM: case REQ_READ_68K_RAM: case REQ_READ_Z80: { dbg_dont_check_bp = 1; memory_data_t *mem_data = &amp;dbg_req-&gt;mem_data; for (int i = 0; i &lt; mem_data-&gt;size; ++i) { switch (dbg_req-&gt;req_type) { case REQ_READ_68K_ROM: mem_data-&gt;m68k_rom[mem_data-&gt;address + i] = m68ki_read_8(mem_data-&gt;address + i); break; case REQ_READ_68K_RAM: mem_data-&gt;m68k_ram[(mem_data-&gt;address + i) &amp; 0xFFFF] = m68ki_read_8(mem_data-&gt;address + i); break; case REQ_READ_Z80: mem_data-&gt;z80_ram[(mem_data-&gt;address + i) &amp; 0x1FFF] = z80_readmem(mem_data-&gt;address + i); break; default: break; } } dbg_dont_check_bp = 0; } break; case REQ_WRITE_68K_ROM: case REQ_WRITE_68K_RAM: case REQ_WRITE_Z80: { dbg_dont_check_bp = 1; memory_data_t *mem_data = &amp;dbg_req-&gt;mem_data; for (int i = 0; i &lt; mem_data-&gt;size; ++i) { switch (dbg_req-&gt;req_type) { case REQ_WRITE_68K_ROM: m68ki_write_8(mem_data-&gt;address + i, mem_data-&gt;m68k_rom[mem_data-&gt;address + i]); break; case REQ_WRITE_68K_RAM: m68ki_write_8(0xFF0000 | ((mem_data-&gt;address + i) &amp; 0xFFFF), mem_data-&gt;m68k_ram[(mem_data-&gt;address + i) &amp; 0xFFFF]); break; case REQ_WRITE_Z80: z80_writemem(mem_data-&gt;address + i, mem_data-&gt;z80_ram[(mem_data-&gt;address + i) &amp; 0x1FFF]); break; default: break; } } dbg_dont_check_bp = 0; } break; case REQ_ADD_BREAK: { bpt_data_t *bpt_data = &amp;dbg_req-&gt;bpt_data; if (!find_breakpoint(bpt_data-&gt;address, bpt_data-&gt;type)) add_bpt(bpt_data-&gt;type, bpt_data-&gt;address, bpt_data-&gt;width); } break; case REQ_TOGGLE_BREAK: { bpt_data_t *bpt_data = &amp;dbg_req-&gt;bpt_data; breakpoint_t *bp = find_breakpoint(bpt_data-&gt;address, bpt_data-&gt;type); if (bp != NULL) bp-&gt;enabled = !bp-&gt;enabled; } break; case REQ_DEL_BREAK: { bpt_data_t *bpt_data = &amp;dbg_req-&gt;bpt_data; remove_bpt(bpt_data-&gt;address, bpt_data-&gt;type); } break; case REQ_CLEAR_BREAKS: clear_bpt_list(); case REQ_LIST_BREAKS: { bpt_list_t *bpt_list = &amp;dbg_req-&gt;bpt_list; bpt_list-&gt;count = count_bpt_list(); for (int i = 0; i &lt; bpt_list-&gt;count; ++i) get_bpt_data(i, &amp;bpt_list-&gt;breaks[i]); } break; case REQ_ATTACH: activate_debugger(); dbg_first_paused = 0; break; case REQ_PAUSE: pause_debugger(); break; case REQ_RESUME: resume_debugger(); break; case REQ_STOP: stop_debugging(); break; case REQ_STEP_INTO: { if (dbg_req-&gt;dbg_paused) { dbg_trace = 1; dbg_req-&gt;dbg_paused = 0; } } break; case REQ_STEP_OVER: { if (dbg_req-&gt;dbg_paused) { unsigned int dest_pc = calc_step_over(); if (dest_pc != (unsigned int)(-1)) { dbg_step_over = 1; dbg_step_over_addr = dest_pc; } else { dbg_step_over = 0; dbg_step_over_addr = 0; dbg_trace = 1; } dbg_req-&gt;dbg_paused = 0; } } break; default: break; } dbg_req-&gt;req_type = REQ_NO_REQUEST; } void send_dbg_event(dbg_event_type_t type) { dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].type = type; dbg_req-&gt;dbg_events_count += 1; } void stop_debugging() { send_dbg_event(DBG_EVT_STOPPED); detach_debugger(); deactivate_debugger(); dbg_first_paused = dbg_req-&gt;dbg_paused = dbg_trace = dbg_dont_check_bp = dbg_step_over = dbg_step_over_addr = dbg_last_pc = 0; } void start_debugging() { if (dbg_req != NULL &amp;&amp; dbg_req-&gt;dbg_active) return; activate_debugger(); init_bpt_list(); dbg_first_paused = dbg_req-&gt;dbg_paused = dbg_trace = dbg_dont_check_bp = dbg_step_over = dbg_step_over_addr = dbg_last_pc = 0; } int is_debugger_accessible() { return (dbg_req != NULL); } void process_breakpoints() { int handled_event = 0; int is_step_over = 0; int is_step_in = 0; unsigned int pc = m68k_get_reg(M68K_REG_PC); if (!dbg_req || !dbg_req-&gt;dbg_active) return; if (dbg_req-&gt;dbg_paused &amp;&amp; dbg_first_paused &amp;&amp; !dbg_trace) longjmp(jmp_env, 1); if (!dbg_first_paused) { dbg_first_paused = 1; dbg_req-&gt;dbg_paused = 1; dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].pc = pc; strncpy(dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].msg, "gpgx", sizeof(dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].msg)); send_dbg_event(DBG_EVT_STARTED); } if (dbg_trace) { is_step_in = 1; dbg_trace = 0; dbg_req-&gt;dbg_paused = 1; dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].pc = pc; send_dbg_event(DBG_EVT_STEP); handled_event = 1; } if (!dbg_req-&gt;dbg_paused) { if (dbg_step_over &amp;&amp; pc == dbg_step_over_addr) { is_step_over = 1; dbg_step_over = 0; dbg_step_over_addr = 0; dbg_req-&gt;dbg_paused = 1; } if (dbg_last_pc != pc) check_breakpoint(BPT_M68K_E, 1, pc, pc); if (dbg_req-&gt;dbg_paused) { dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].pc = pc; send_dbg_event(is_step_over ? DBG_EVT_STEP : DBG_EVT_BREAK); handled_event = 1; } } if (dbg_first_paused &amp;&amp; (!handled_event) &amp;&amp; dbg_req-&gt;dbg_paused) { dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].pc = pc; send_dbg_event(DBG_EVT_PAUSED); } dbg_last_pc = pc; if (dbg_req-&gt;dbg_paused &amp;&amp; (!is_step_in || is_step_over)) { longjmp(jmp_env, 1); } } int is_debugger_paused() { return is_debugger_accessible() &amp;&amp; dbg_req-&gt;dbg_paused &amp;&amp; dbg_first_paused &amp;&amp; !dbg_trace; }</span></span></span></span></code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title">  debug.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _DEBUG_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _DEBUG_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __cplusplus extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;setjmp.h&gt; #include "debug_wrap.h" extern void start_debugging(); extern void stop_debugging(); extern int is_debugger_accessible(); extern void process_request(); extern int is_debugger_paused(); extern int activate_shared_mem(); extern void deactivate_shared_mem(); void check_breakpoint(bpt_type_t type, int width, unsigned int address, unsigned int value); extern jmp_buf jmp_env; #ifdef __cplusplus } #endif #endif</span></span></span></span></code> </pre> </div></div><br><p>              . <br> ,    <code>check_breakpoint</code>  <code>VDP</code>       <code>#ifdef LOGVDP</code> .       <code>vdp_ctrl.c</code> : </p><br><pre> <code class="cpp hljs">check_breakpoint(BPT_VRAM_W, <span class="hljs-number"><span class="hljs-number">2</span></span>, addr, data); ... check_breakpoint(BPT_CRAM_W, <span class="hljs-number"><span class="hljs-number">2</span></span>, addr, data); ... check_breakpoint(BPT_VSRAM_W, <span class="hljs-number"><span class="hljs-number">2</span></span>, addr, data); ... check_breakpoint(BPT_VRAM_R, <span class="hljs-number"><span class="hljs-number">2</span></span>, addr, data); ... check_breakpoint(BPT_CRAM_R, <span class="hljs-number"><span class="hljs-number">2</span></span>, addr, data); ... check_breakpoint(BPT_VSRAM_R, <span class="hljs-number"><span class="hljs-number">2</span></span>, addr, data);</code> </pre> <br><p>  <code>RAM</code>     ( <code>m68kcpu.h</code> ): </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// m68ki_read_8 check_breakpoint(BPT_M68K_R, 1, address, val); // m68ki_read_16 check_breakpoint(BPT_M68K_R, 2, address, val); // m68ki_read_32 check_breakpoint(BPT_M68K_R, 4, address, val); // m68ki_write_8 check_breakpoint(BPT_M68K_W, 1, address, val); // m68ki_write_16 check_breakpoint(BPT_M68K_W, 2, address, val); // m68ki_write_32 check_breakpoint(BPT_M68K_W, 4, address, val);</span></span></code> </pre> <br><p>      ,      ,      . </p><br><div class="spoiler"> <b class="spoiler_title">  debug_wrap.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Windows.h&gt; #include &lt;process.h&gt; #include "debug_wrap.h" static HANDLE hMapFile = NULL, hStartFunc = NULL; dbg_request_t *open_shared_mem() { hMapFile = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, SHARED_MEM_NAME); if (hMapFile == NULL) { return NULL; } dbg_request_t *request = (dbg_request_t *)MapViewOfFile(hMapFile, FILE_MAP_ALL_ACCESS, 0, 0, sizeof(dbg_request_t)); if (request == NULL) { CloseHandle(hMapFile); return NULL; } return request; } void close_shared_mem(dbg_request_t **request) { UnmapViewOfFile(*request); CloseHandle(hMapFile); hMapFile = NULL; *request = NULL; } int recv_dbg_event(dbg_request_t *request, int wait) { while (request-&gt;dbg_active || request-&gt;dbg_events_count) { for (int i = 0; i &lt; MAX_DBG_EVENTS; ++i) { if (request-&gt;dbg_events[i].type != DBG_EVT_NO_EVENT) { request-&gt;dbg_events_count -= 1; return i; } } if (!wait) return -1; Sleep(10); } return -1; } void send_dbg_request(dbg_request_t *request, request_type_t type) { if (!request) return; request-&gt;req_type = type; while (request-&gt;dbg_active &amp;&amp; request-&gt;req_type != REQ_NO_REQUEST) { Sleep(10); } }</span></span></span></span></code> </pre> </div></div><br><p>       .   ,  . ,         , ,      . </p><br><h3 id="yadro-otladchika-zapusk">  :  </h3><br><p>          <code>Genesis Plus GX</code> : </p><br><pre> <code class="cpp hljs"> var.key = <span class="hljs-string"><span class="hljs-string">"genesis_plus_gx_debugger"</span></span>; environ_cb(RETRO_ENVIRONMENT_GET_VARIABLE, &amp;var); { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!var.value || !<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(var.value, <span class="hljs-string"><span class="hljs-string">"disabled"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_debugger_accessible()) { stop_debugging(); stop_gui(); deactivate_shared_mem(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { activate_shared_mem(); start_debugging(); run_gui(); } } ... { <span class="hljs-string"><span class="hljs-string">"genesis_plus_gx_debugger"</span></span>, <span class="hljs-string"><span class="hljs-string">"Debugger; disabled|enabled"</span></span> },</code> </pre> <br><p>    <code>RetroArch</code> : <br>   ,      <code>retro_run()</code> .      (      ),    . ,      <code>retro_run()</code> ,  <code>RetroArch</code>  .      <code>setjmp()</code> / <code>longjmp()</code> .  ,        <code>retro_run()</code> : </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_debugger_paused()) { longjmp(jmp_env, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> is_paused = setjmp(jmp_env); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_paused) { process_request(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>      <code>retro_run()</code>      <code>process_request()</code> ,      ,    . </p><br><h3 id="ps-zatravka-dlya-vtoroy-chasti"> PS     </h3><br><p><img src="https://habrastorage.org/webt/uc/ln/ec/uclnecmakoun2veml3ooxfvaete.png"></p><br><p> <strong>Update</strong> : <br>  <a href="https://habr.com/post/435002/">  </a>      -  <code>IDA Pro</code> ,      . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/434992/">https://habr.com/ru/post/434992/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../434980/index.html">It is finished! NASA's New Horizons spacecraft contacted from a distance of 4 billion miles</a></li>
<li><a href="../434982/index.html">Perspective: MultiClet S1</a></li>
<li><a href="../434984/index.html">What I hate for Eloquent ORM</a></li>
<li><a href="../434986/index.html">Basic C ++ Standard Library Concepts</a></li>
<li><a href="../434990/index.html">Using the Cisco 800 Series (for example Cisco 857) as a home router</a></li>
<li><a href="../434994/index.html">Android: Creating Dynamic Product Flavors and Signing Configs</a></li>
<li><a href="../434996/index.html">How I shared the location through the VC API</a></li>
<li><a href="../435000/index.html">The concept of the interaction of advertising channels and its application in practice</a></li>
<li><a href="../435002/index.html">IDA Pro Upgrade. Debugger for Sega Mega Drive (part 2)</a></li>
<li><a href="../435006/index.html">Where and how do nuclear reactors do</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>