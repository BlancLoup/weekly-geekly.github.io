<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reverse engineering NES emulator in GameCube game</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the process of finding ways to activate the developer menu left in Animal Crossing, including the game selection menu for the NES emulator, I disco...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reverse engineering NES emulator in GameCube game</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/499/dc8/2e4/499dc82e445ffd6bfd607d4f834ccd5a.png" alt="image"></div><br>  In the process of finding ways to activate the developer menu left in Animal Crossing, including the game selection menu for the NES emulator, I discovered an interesting feature that exists in the original game and was constantly active, but never used by Nintendo. <br><br>  In addition to the NES / Famicom games that can be obtained inside the game, you can download new NES games from a memory card. <br><br>  I also managed to find a way to use this ROM loader to patch my code and data into the game, which allows you to run the code through a memory card. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Introduction - NES Console Objects </h2><br>  Conventional NES games that can be obtained at Animal Crossing are separate pieces of furniture in the form of an NES console with a cartridge on it. <br><br>  By placing this object in your home and interacting with it, you can run this single game.  The picture below shows Excitebike and Golf. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/40e/e33/409/40ee334095bd1151c3c968a84f8cf92b.png"></div><a name="habracut"></a><br>  There is also a common ‚ÄúNES Console‚Äù object, in which there are no embedded games.  You can buy it from Redd, and sometimes get through random events, for example, by reading on the city bulletin board that the console is buried at a random point in the city. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f41/d20/687/f41d20687aed7d6a4d044a5a5d084045.png"></div><br>  This object looks like a NES console with no cartridges on it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35c/010/9a3/35c0109a32b31deeb202280773f363a0.png"></div><br>  The problem with this object is that it was conceived as unplayable.  Every time you interact with it, you simply see a message stating that you do not have gaming software. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9e/6d3/3b8/a9e6d33b8e039a2f17c12fd134cf0308.png"></div><br>  It turned out that this object is actually trying to scan the memory card for the presence of specially designed files containing ROM images for NES!  The NES emulator used to run embedded games seems to be the full standard GameCube NES emulator, and is able to run most games. <br><br>  Before demonstrating these functions, I will explain the process of their reverse development. <br><br><h2>  Search ROM loader on a memory card </h2><br><h3>  Looking for developer menu </h3><br>  Initially, I wanted to find the code that activates various developer menus, such as the map selection menu or the game selection menu for the NES emulator.  The <a href="https://tcrf.net/Animal_Crossing">Forest Map Select</a> menu, which makes it easy to instantly download different locations of the game, was quite easy to find - I just searched for the FOREST MAP SELECT line that appears at the top of the screen (you can see it in various videos and screenshots on the Internet ). <br><br>  In FOREST MAP SELECT, there are cross-references of data to the <code>select_print_wait</code> function, which leads to a bunch of other functions that also have the <code>select_*</code> prefix, including the <code>select_init</code> function.  These turned out to be functions that control the card selection menu. <br><br>  The <code>select_init</code> function leads to another interesting function called <code>game_get_next_game_dlftbl</code> .  This function links together all the other menus and ‚Äúscenes‚Äù that can be launched: a screen with the Nintendo logo, the main screen, the map selection menu, the NES (Famicom) emulator menu, and so on.  It starts at the beginning of the main game procedure, finds which scene initialisation function should be launched, and finds its entry in the table data structure called <code>game_dlftbls</code> .  This table contains links to various scene processing functions, as well as some other data. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d93/cbc/019/d93cbc0191a754e6bb566525f1a21666.png"></div><br>  A careful study of the first block of the function showed that it loads the ‚Äúnext game init‚Äù function, and then begins to compare it with a series of known init functions: <br><br><ul><li> <code>first_game_init</code> </li> <li> <code>select_init</code> </li> <li> <code>play_init</code> </li> <li> <code>second_game_init</code> </li> <li> <code>trademark_init</code> </li> <li> <code>player_select_init</code> </li> <li> <code>save_menu_init</code> </li> <li> <code>famicom_emu_init</code> </li> <li> <code>prenmi_init</code> </li> </ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e6/785/bae/2e6785bae4c526f3acba034d4f7e4b2e.png"></div><br>  One of the pointers to the functions it is looking for is <code>famicom_emu_init</code> , which is responsible for running the NES / Famicom emulator.  <code>game_get_next_game_init</code> Dolphin debugger to the <code>game_get_next_game_init</code> result to be <code>famicom_emu_init</code> or <code>select_init</code> , I was able to display special menus.  The next step is to determine how these pointers are set in the normal way during program execution.  The only thing that the <code>game_get_next_game_init</code> function <code>game_get_next_game_init</code> is loading the value at the <code>0xC</code> offset of the first argument to <code>game_get_next_game_dlftbl</code> . <br><br>  Keeping track of these values ‚Äã‚Äãin various data structures was a bit boring, so I‚Äôll go straight to the main one.  The most important thing I found: <br><br><ul><li>  When a game is launched in the usual way, it performs the following sequence of actions: <br><ul><li> <code>first_game_init</code> </li> <li> <code>second_game_init</code> </li> <li> <code>trademark_init</code> </li> <li> <code>play_init</code> </li> </ul></li><li>  <code>player_select_init</code> sets the next init value to <code>select_init</code> .  This screen should allow you to select a player immediately after selecting a card, but it looks like it is not working properly. </li></ul><br>  I also found one nameless function that sets the em function init, but I didn‚Äôt find anything assigning the init functions the init values ‚Äã‚Äãof the player or card selection. <br><br>  At that point, I realized that I had another stupid problem with how I loaded the function names in IDA: because of the regular expression used to cut lines in the debug symbol file, I missed all the function names starting with a capital letter .  The function that set <code>famicom_emu_init</code> looked similar to the transition between scenes, and, of course, was called <code>Game_play_fbdemo_wipe_proc</code> . <br><br>  <code>Game_play_fbdemo_wipe_proc</code> handles scene transitions, such as clearing the screen and dimming. <br><br>  Under certain conditions, the transition of the screen was carried out from the usual gameplay to the display of the emulator.  It was he who set the em function init. <br><br><h3>  Processing console objects </h3><br>  In fact, switching to the screen transition handler emulator is forced by the function-handlers of furniture objects for NES consoles.  When a player interacts with one of the consoles, <code>aMR_FamicomEmuCommonMove</code> is <code>aMR_FamicomEmuCommonMove</code> . <br><br>  When calling the function <code>r6</code> contains an index value corresponding to the numbers in the names of the NES game files in <code>famicom.arc</code> : <br><br><ul><li> <code>01_nes_cluclu3.bin.szs</code> </li> <li> <code>02_usa_balloon.nes.szs</code> </li> <li> <code>03_nes_donkey1_3.bin.szs</code> </li> <li> <code>04_usa_jr_math.nes.szs</code> </li> <li> <code>05_pinball_1.nes.szs</code> </li> <li> <code>06_nes_tennis3.bin.szs</code> </li> <li> <code>07_usa_golf.nes.szs</code> </li> <li> <code>08_punch_wh.nes.szs</code> </li> <li> <code>09_usa_baseball_1.nes.szs</code> </li> <li> <code>10_cluclu_1.qd.szs</code> </li> <li> <code>11_usa_donkey3.nes.szs</code> </li> <li> <code>12_donkeyjr_1.nes.szs</code> </li> <li> <code>13_soccer.nes.szs</code> </li> <li> <code>14_exbike.nes.szs</code> </li> <li> <code>15_usa_wario.nes.szs</code> </li> <li> <code>16_usa_icecl.nes.szs</code> </li> <li> <code>17_nes_mario1_2.bin.szs</code> </li> <li> <code>18_smario_0.nes.szs</code> </li> <li> <code>19_usa_zelda1_1.nes.szs</code> </li> </ul><br>  ( <code>.arc</code> is the proprietary format of file archives.) <br><br>  When <code>r6</code> non-zero, it is passed in the <code>aMR_RequestStartEmu</code> call.  This triggers the transition to the emulator. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f78/268/1d7/f782681d712b4098ad6f9269cf2df5cc.png"></div><br>  However, if <code>r6</code> is zero, the function <code>aMR_RequestStartEmu_MemoryC</code> is called <code>aMR_RequestStartEmu_MemoryC</code> .  Having assigned the value 0 in the debugger, I received the message "I don't have any software".  I didn‚Äôt immediately remember that I had to check the ‚ÄúNES Console‚Äù object to make sure that it <code>r6</code> value, but it turned out that the zero index is used for the console object without a cartridge. <br><br>  Although <code>aMR_RequestStartEmu</code> simply saves the index value in some kind of data structure, <code>aMR_RequestStartEmu_MemoryC</code> performs much more complex operations ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d23/844/831/d23844831e1e9f9b8ef5b6a4306948ab.png"></div><br>  This third block of code calls <code>aMR_GetCardFamicomCount</code> and checks for a non-zero result, otherwise it misses most of the interesting things on the left side of the function graph. <br><br>  <code>aMR_GetCardFamicomCount</code> calls <code>famicom_get_disksystem_titles</code> , which then calls <code>memcard_game_list</code> , and then everything becomes very interesting. <br><br>  <code>memcard_game_list</code> mounts the memory card and starts <code>memcard_game_list</code> around in the file recording cycle, checking each one for some values.  Having traced the function in the debugger, I was able to understand that it compared the values ‚Äã‚Äãwith each of my files on the memory card. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da1/e17/dd1/da1e17dd1b1acd6552eeeabaedc586fb.png"></div><br>  The function decides whether to load or not to load the file, depending on the results of checking several lines.  First, it checks for the presence of the ‚ÄúGAFE‚Äù and ‚Äú01‚Äù strings, which are game and company identifiers.  01 stands for Nintendo, ‚ÄúGAFE‚Äù is Animal Crossing.  I think it stands for GameCube Animal Forest English. <br><br>  She then checks the strings ‚ÄúDobutsunomoriP_F_‚Äù and ‚ÄúSAVE‚Äù.  In this case, the first line must match, but not the second.  It turned out that ‚ÄúDobutsunomoriP_F_SAVE‚Äù is the name of the file in which the data of the embedded NES games are stored.  Therefore, all files will be loaded, except for this, with the prefix "DobutsunomoriP_F_". <br><br>  Using the Dolphin debugger to skip the string comparison with ‚ÄúSAVE‚Äù and forcing the game to assume that my SAVE file can be safely downloaded, I received this menu after using the NES console: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d4/1d2/696/1d41d26963aeaf11450155f1d7d53085.png"></div><br>  I answered ‚ÄúYes‚Äù and tried to load the save file as a game, after which I first saw the built-in game crash screen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41e/662/4cc/41e6624cc68fe28e897cd1803ba1a39a.png"></div><br>  Fine!  Now I know that she is actually trying to load games from a memory card, and I can start analyzing the format for save files to see if you can load a real ROM. <br><br>  The first thing I tried to do was try to find where the name of the game is read from the memory card file.  Searching for the string ‚ÄúFEFSC‚Äù, which was present in the message ‚ÄúWould you like to play &lt;name&gt;?‚Äù, I found the offset at which it was read from the file: <code>0x642</code> .  I copied the save file, changed the file name to ‚ÄúDobutsunomoriP_F_TEST‚Äù, changed the bytes at offset <code>0x642</code> to ‚ÄúTESTING‚Äù and imported the changed save, after which the name I needed was displayed in the menu. <br><br>  After adding several more files in this format, several more choices appeared in the menu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/235/ca3/668/235ca3668ae0a02ad2609847bdf193c0.png"></div><br><h3>  ROM download </h3><br>  If <code>aMR_GetCardFamicomCount</code> returns non-zero, then memory is allocated on the heap, <code>famicom_get_disksystem_titles</code> is called again directly, and then a bunch of random offsets are specified in the data structure.  Instead of deciphering where these values ‚Äã‚Äãwould be read, I began to study the list of <code>famicom</code> functions. <br><br>  It turned out that I needed <code>famicom_rom_load</code> .  It manages the loading of a ROM, or from a memory card, or from the game‚Äôs internal resources. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/999/22b/462/99922b462892ef544d45e849da1c54a5.png"></div><br>  The most important thing in this ‚Äúboot from memory card‚Äù block is that it causes <br>  <code>memcard_game_load</code> .  She again mounts the file on the memory card, reads it and parsit.  This is where the most important file format options become apparent. <br><br><h4>  Checksum value </h4><br>  The first thing that happens after downloading a file is the calculation of the checksum.  <code>calcSum</code> function is <code>calcSum</code> , which is a very simple algorithm that summarizes the values ‚Äã‚Äãof all bytes in the data from the memory card.  The bottom eight bits of the result must be zero.  That is, to pass this test, you need to sum up the values ‚Äã‚Äãof all bytes in the source file, calculate the value that needs to be added so that the bottom eight bits become zero, and then assign a value to the checksum byte in the file. <br><br>  If the check fails, then you receive a message that the memory card cannot be correctly read, and nothing happens.  During debugging, I just need to skip this check. <br><br><h4>  Copy ROM </h4><br>  Toward the end of <code>memcard_game_load</code> , another interesting thing happens.  There are some more interesting blocks of code between it and the checksum, but none of them leads to branching that skips the execution of this behavior. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc8/376/55d/cc837655d2ec1b207b0f7420db856a1e.png"></div><br>  If the particular 16-bit integer value read from the memory card is not zero, then a function is called that checks the compression header in the buffer.  It checks for the presence of Nintendo's proprietary compression formats, looking for ‚ÄúYay0‚Äù or ‚ÄúYaz0‚Äù at the beginning of the buffer.  If one of these lines is found, then the unpack function is called.  Otherwise, a simple memory copy function is performed.  In any of the cases, the variable named <code>nesinfo_data_size</code> then updated. <br><br>  Another hint of context here is that ROM files for NES embedded games use ‚ÄúYaz0‚Äù compression, and this line is present in the headers of their files. <br><br>  Having observed the value that is checked for zero, and the buffer transferred to the compression check functions, I quickly found out where the game was read in the file on the memory card.  A zero check is performed for a portion of the 32-byte buffer copied from offset <code>0x640</code> in the file, which is most likely a ROM header.  Also this function checks other parts of the file, and it is in them that the name of the game is located (starting with the third byte of the header). <br><br>  In the code execution path I found, the ROM buffer is located immediately after this 32-byte header buffer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c2/01f/34c/7c201f34c3b9427c288654d487acbcbf.png"></div><br>  This information is enough to try to create a working ROM file.  I just took one of the other Animal Crossing save files and edited it in a hex editor to replace the file name with <code>DobutsunomoriP_F_TEST</code> and clear all areas where I wanted to insert data. <br><br>  For the test run, I used the ROM game Pinball, which is already in the game, and pasted its contents after the 32-byte header.  Instead of calculating the checksum value, I set breakpoints just to skip <code>calcSum</code> and also watch the results of other checks that could lead to a branch skipping the ROM boot process. <br><br>  Finally, I imported a new file through the Dolphin memory card manager, restarted the game, and tried to start the console. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/199/d08/799/199d087997375f8666284220e7ffcc62.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/527/be8/5f5/527be85f54ab8f37609047d323c6b442.png"></div><br>  It worked!  There were small graphical bugs related to Dolphin parameters, which affected the graphics mode used by the NES emulator, but in general the game was just perfect.  (In newer Dolphin builds, it should work by default.) <br><br>  To make sure that other games will also start, I tried to record several other ROMs that were not in the game.  Battletoads was launched, but stopped working after the text of the screen saver (after further settings, I managed to make it playable).  On the other hand, Mega Man worked perfectly: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/923/5a2/7da/9235a27da4d094a496a477cc24cd4846.png"></div><br>  To learn how to generate new ROM files that could be loaded without debugging intervention, I had to start writing code and more deeply understand the parsing of the file format. <br><br><h3>  External ROM file format </h3><br>  The most important part of parsing files takes place in <code>memcard_game_load</code> .  There are six main sections of the code parsing block in this function: <br><br><ul><li>  Check sum </li><li>  Save file name </li><li>  ROM file header </li><li>  Unknown buffer copied without any processing </li><li>  Text comment, icon and banner uploader (for creating a new save file) </li><li>  ROM bootloader </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f00/194/51e/f0019451e2d0070900f75c62cb83535a.png"></div><br><h4>  Check sum </h4><br>  The bottom eight bits of the sum of all byte values ‚Äã‚Äãin the save file must be zero.  Here is a simple Python code that generates the required checksum byte: <br><br><pre> <code class="python hljs">checksum = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> byte_val <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_data_tmp: checksum += byte_val checksum = checksum % (<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">32</span></span>) <span class="hljs-comment"><span class="hljs-comment"># keep it 32 bit checkbyte = 256 - (checksum % 256) new_data_tmp[-1] = checkbyte</span></span></code> </pre> <br>  There is probably a special place to store the checksum byte, but adding it to the empty space at the very end of the save file works fine. <br><br><h4>  File name </h4><br>  Again, the name of the save file must begin with ‚ÄúDobutsunomoriP_F_‚Äù and end with something that does not contain ‚ÄúSAVE‚Äù.  This file name is copied a couple of times, and in one case the letter ‚ÄúF‚Äù is replaced with ‚ÄúS‚Äù.  This will be the name of the save files for the NES game (‚ÄúDobutsunomoriP_S_NAME‚Äù). <br><br><h4>  ROM header </h4><br>  An immediate copy of the 32-byte header is loaded into memory.  Some of the values ‚Äã‚Äãin this header are used to determine how to handle subsequent sections.  These are mainly some 16-bit size values ‚Äã‚Äãand packed parameter bits. <br><br>  If you trace the pointer, copied by the header, all the way to the beginning of the function, and find the position of its argument, the function signature below will show that it actually has the type <code>MemcardGameHeader_t*</code> . <br><br><pre> <code class="python hljs">memcard_game_load(unsigned char *, int, unsigned char **, char *, char *, MemcardGameHeader_t *, unsigned char *, unsigned long, unsigned char *, unsigned long)</code> </pre> <br><h4>  Unknown buffer </h4><br>  The 16-bit value of the size from the header is checked.  If it is not zero, then the corresponding number of bytes is directly copied from the file buffer to the new block of allocated memory.  This moves the data pointer in the file buffer so that further copying can proceed from the next section. <br><br><h4>  Banner, Icon and Comment </h4><br>  Another size value is checked in the header, and if it is not zero, the file compression check function is called.  If necessary, the decompression algorithm will be launched, after which <code>SetupExternCommentImage</code> is <code>SetupExternCommentImage</code> . <br><br>  This function deals with three things: a ‚Äúcomment‚Äù, a banner image and an icon.  For each of them in the ROM header there is a code showing how they should be processed.  There are the following options: <br><br><ol><li>  Use default </li><li>  Copy from banner / icon / comment section in ROM file </li><li>  Copy from alternate buffer </li></ol><br>  The default code values ‚Äã‚Äãcause the icon or banner to be loaded from the resource on disk, and the name of the save file and comment (text description of the file) are assigned the values ‚Äã‚ÄãAnimal Crossing and NES Cassette Save Data.  Here's what it looks like: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/906/519/045/906519045718e74cf565c2983401692c.png"></div><br>  The second code value simply copies the name of the game from the ROM file (some alternative to ‚ÄúAnimal Crossing‚Äù), and then tries to find the line "] ROM" in the file comments and replace it with "] SAVE".  Apparently, the files that Nintendo wanted to release should have been named ‚ÄúGame Name [NES] ROM‚Äù or something like that. <br><br>  For an icon and banner, the code tries to determine the image format, obtain a fixed-size value corresponding to this format, and then copy the image. <br><br>  At the last code value, the file name and description are copied unchanged from the buffer, and the icon and banner are also loaded from the alternative buffer. <br><br><h4>  ROM </h4><br>  If you take a close look at the screenshot of the <code>memcard_game_load</code> copy <code>memcard_game_load</code> , you will notice that the 16-bit value, checked for equality to zero, is shifted to the left by 4 bits (multiplied by 16), and then used as the size of the <code>memcpy</code> function, if compression is not detected.  This is another size value present in the header. <br><br>  If the size is not zero, then the ROM data is checked for compression and then copied. <br><br><h3>  Unknown buffer and bug search </h3><br>  Although loading a new ROM is quite curious, the most interesting thing about this ROM loader for me was that in fact it is the only part of the game that receives user input of variable size and copies it to different places in memory.  Almost everything else uses buffers of constant size.  Things like names and letter texts may seem different in length, but in fact the empty space is just filled with spaces.  Zero-terminated strings are used infrequently, thus avoiding common memory corruption bugs, such as using <code>strcpy</code> with a buffer that is too small to copy strings into it. <br><br>  I was very interested in the possibility of finding a game exploit based on save files, and it seemed that this was the best option. <br><br>  Most of the ROM file operations described above use copies of a constant size, with the exception of an unknown buffer and ROM data.  Unfortunately, the code processing this buffer allocates just as much space as is necessary to copy it, so no overflow occurs, and specifying very large sizes of ROM files was not very useful. <br><br>  But I still wanted to know what was happening with this buffer, which is copied without any processing. <br><br><h4>  NES Information Tag Handlers </h4><br>  I am back to <code>famicom_rom_load</code> .  After loading a ROM from a memory card or disk, several functions are called: <br><br><ul><li> <code>nesinfo_tag_process1</code> </li> <li> <code>nesinfo_tag_process2</code> </li> <li> <code>nesinfo_tag_process3</code> </li> </ul><br>  Tracing the place where the unknown buffer is copied, I made sure that this task is performed by these functions.  They begin with a call to <code>nesinfo_next_tag</code> , which performs a simple algorithm: <br><br><ul><li>  Checks whether the specified pointer <code>nesinfo_tags_end</code> pointer in <code>nesinfo_tags_end</code> .  If it is less than <code>nesinfo_tags_end</code> or <code>nesinfo_tags_end</code> is zero, then it checks the presence of the string "END" in the header of the pointer. <br><br><ul><li>  If END is reached, or the pointer has risen to or above <code>nesinfo_tags_end</code> , then the function returns zero (null). </li><li>  Otherwise, the byte at offset <code>0x3</code> pointer is added to 4 and to the current pointer, after which the value is returned. </li></ul></li></ul><br>  This tells us that there is some sort of label format of the three-letter name, the data size values, and the data itself.  The result is a pointer to the next label, because the current label is skipped ( <code>cur_ptr + 4</code> skips the three-letter name and one byte, and <code>size_byte</code> skips the data). <br><br>  If the result is not zero, then the label processing function performs a series of string comparisons to figure out which label to process.  Some of the label names checked in <code>nesinfo_tag_process1</code> : VEQ, VNE, GID, GNO, BBR and QDS. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f1/094/08b/0f109408b8d01ec8cf4522445463e378.png"></div><br>  If a match is found for a tag, some handler code is executed.  Some of the handlers do nothing but output the label in the debug message.  Other handlers are more complex.  After processing the label, the function tries to get the next label and continue processing. <br><br>  Fortunately, there are many detailed debugging messages that appear when tags are detected.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">They are all in Japanese, so they must first be decoded from Shift-JIS and translated. For example, a message for QDS might read "Loading disk save area" or "Since this is the first run, create a disk save area." The messages for BBR read "load backup battery" or "since this is the first run, perform the cleanup." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Both of these codes also load some values ‚Äã‚Äãfrom the data section of their label and use them to calculate the offset in the ROM data, and then perform copy operations. Obviously, they are responsible for determining the parts in the ROM memory associated with the preservation of the state.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is also a ‚ÄúHSC‚Äù tag with a debug message saying that it handles point records. </font><font style="vertical-align: inherit;">It receives the ROM offset from its tag data, as well as the initial value of the record points. </font><font style="vertical-align: inherit;">These tags can be used to indicate a place in the memory of a NES game for storing record points, possibly for storing and restoring them later. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These tags create a rather complex system of loading metadata about ROM. </font><font style="vertical-align: inherit;">Moreover, many of them lead to calls </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">based on the values ‚Äã‚Äãpassed to these tags.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hunt for bugs </font></font></h4><br>  ,     ,     ,           ,    16-  .      16-   NES,        ,            32-   GameCube. <br><br>    ,    ,  <code>memcpy</code> ,   <code>0xFFFF</code> . <br><br><h5> QDS </h5><br> QDS  24-     ,   16-  . <br><br>   ,         .   c ‚Äî    ,      ROM  ,    16-    . <br><br> 24-     <code>0xFFFFFF</code> ,           ROM.     ‚Ä¶ <br><br>    ,       <code>0xFFFF</code> ,       .      (   <code>0x1000</code> ),     ¬´QDS¬ª   . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And therein lies the problem, because it </font></font><code>nesinfo_tag_process1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is actually called twice. For the first time, she receives some information about the space she needs to prepare for the save data. The QDS and BBR tags are not fully processed on the first run. After the first execution, a place is prepared for these saves, and the function is called again. This time, the QDS and BBR labels are processed completely, but if the lines of the label names are cleared from memory, then it is impossible to match the labels again! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This can be avoided by setting a smaller size value. Another problem is that the offset value can only move forward in memory, and the ROM NES data is located in a heap rather close to the end of the available memory.</font></font><br><br>      ,          ,    . <br><br>            ,    <code>malloc</code> ,    ,            <code>malloc</code> .           .                 <code>free</code>    . <br><br>     <code>malloc</code>     ( <code>0x7373</code> )      ,       <code>free</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If she does not find these bytes, then it causes </font></font><code>OSPanic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and the game freezes.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/516/68f/447/51668f447b75887250574f1ad1ec1800.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Without having the ability to influence these bytes in some target location, it is not possible to write here. </font><font style="vertical-align: inherit;">In other words, it is impossible to write something in an arbitrary place without being able to record something near this place. </font><font style="vertical-align: inherit;">There may be some way to make the value </font></font><code>0x73730000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stored on the stack directly in front of the return address </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and the</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> place to which the value we want to write is assigned to the destination address (it will also be checked as if it were a pointer to the heap block), but this difficult to achieve and use in an exploit.</font></font><br><br><h5> <code>nesinfo_update_highscore</code> </h5> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another feature related to QDS, BBR and HSC tags is </font></font><code>nesinfo_update_highscore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The sizes of the QDS, BBR and OFS labels (offset, offset) are used to calculate the offset to which the recording is to be performed, and the HSC label includes the recording to this location. This function is performed for each frame processed by the NES emulator. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The maximum offset value for each label in this case, even for QDS, is </font></font><code>0xFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. However, during the label processing cycle, the size values ‚Äã‚Äãfrom the BBR and QDS labels actually </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">accumulate</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This means that multiple labels can be used to calculate almost any offset value. The limit is the number of tags that can fit in the ROM data section of a file on a memory card, and it also has a maximum size </font></font><code>0xFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The base address to which the offset is added is the </font></font><code>0x800C3180</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">save data buffer. </font><font style="vertical-align: inherit;">This address is much lower than the ROM data, which gives us more freedom in choosing a place to write. </font><font style="vertical-align: inherit;">For example, it will be enough just to rewrite the return address in the stack at </font></font><code>0x812F95DC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, that didn't work either. </font><font style="vertical-align: inherit;">It turns out that it </font></font><code>nesinfo_tag_process1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">also checks the accumulated size of the offsets from these labels, and uses this size to initialize the space:</font></font><br><br><pre> <code class="cpp hljs">bzero(nintendo_hi_0, ((offset_sum + <span class="hljs-number"><span class="hljs-number">0xB</span></span>) * <span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-number"><span class="hljs-number">0x40</span></span>)</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b3/531/0ab/7b35310ab9bae3406ee423acd1c1a1a5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With the offset value that I was trying to calculate, this led to the fact that </font></font><code>0x48D91EC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(76,386,796) memory bytes </font><font style="vertical-align: inherit;">were cleared </font><font style="vertical-align: inherit;">, which is why the game failed to perform spectacularly.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PAT Mark </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I have already begun to lose hope, because all these tags that performed unprotected calls </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">led to failure even before I had time to use them. I decided to just do the documentation of the purpose of each tag, and gradually got to the mark in </font></font><code>nesinfo_tag_process2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most tag handlers </font></font><code>nesinfo_tag_process2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">never run, because they only work when the pointer is </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">non-zero. Nothing in the code assigns a non-zero value to this pointer. It is initialized with a zero value and is never used again. When loading ROM, it is set only </font></font><code>nesinfo_data_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, therefore it looks like a dead code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, there is one label that can still work with non-zero </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: PAT. This is the most difficult label in the function </font></font><code>nesinfo_tag_process2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5a/8fa/e47/b5a8fae47c7ba7f82b2ee9810a950c6e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">She also uses as a pointer </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but never checks it for zero. </font><font style="vertical-align: inherit;">The PAT label reads its own label data buffer, processing codes that calculate offsets. </font><font style="vertical-align: inherit;">These offsets are added to the pointer </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to calculate the destination address, and then the bytes are copied from the patch buffer to this location. </font><font style="vertical-align: inherit;">This copying is done with instructions for loading and saving bytes, and not with the help </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so I did not notice it before. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each PAT tag data buffer has an 8-bit type code, an 8-bit patch size, and a 16-bit offset value, followed by the patch data.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If the code is 2, then the offset value is added to the current sum of offsets. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If the code is 9, then the offset is shifted up by 4 bits and added to the current sum of offsets. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If the code is 3, then the sum of the offsets is reset to 0. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The maximum size of the NES information label is 255, that is, the largest PAT patch size is 251 bytes. </font><font style="vertical-align: inherit;">However, it is allowed to use several PAT tags, that is, you can patch more than 251 bytes, as well as patch non-adjacent places. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As long as we have a series of PAT subtags with code 2 or code 9, the offset of the destination pointer continues to accumulate. </font><font style="vertical-align: inherit;">When copying patch data, it is reset to zero, but if you use a zero patch size, this can be avoided. </font><font style="vertical-align: inherit;">It is clear that this can be used to calculate an arbitrary offset with a null pointer </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">using a variety of PAT labels. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, there are two more checks for code values ‚Äã‚Äã...</font></font><br><br><ul><li>     <code>0x80</code>  <code>0xFF</code> ,     <code>0x7F80</code> ,      16 .     16-         . </li></ul><br>            <code>0x80000000</code>  <code>0x807FFFFF</code> !         Animal Crossing.  ,       Animal Crossing     ROM     . <br><br>    -              . <br><br>       ,  ¬´zuru mode 2¬ª (  ,    <a href="https://habr.com/post/413967/"> </a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) when the user loads the ROM from the game card. </font><font style="vertical-align: inherit;">It turned out that the cheat combo of the keys only activates the ‚Äúzuru mode 1‚Äù mode, which does not have access to the functions that mode 2. With this patch, thanks to the memory card, we can get full access to the developer mode on the real hardware.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/864/d51/d15/864d51d15fa180ea3fab552a0dd4977b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The patch labels will be processed when the ROM is loaded. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/499/dc8/2e4/499dc82e445ffd6bfd607d4f834ccd5a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After downloading the ROM, you need to exit the NES emulator to see the result. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/694/6ea/3a2/6946ea3a20e0290b75eeba8bbf400d10.png"></div><br>  Works! <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The format of the informational labels patch </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Information labels in the save file that execute this patch are as follows: </font></font><br><br> <code>000000 5a 5a 5a 00 50 41 54 08 a0 04 6f 9c 00 00 00 7d &gt;ZZZ.PAT...o....}&lt; <br> 000010 45 4e 44 00 &gt;END.&lt;</code> <br> <br><ul><li> <code>ZZZ \x00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: ignored start label. </font></font><code>0x00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- this is the size of its data buffer: zero.</font></font></li><li> <code>PAT \x08 \xA0 \x04 \x6F\x9C \x00\x00\x00\x7D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: patch </font></font><code>0x80206F9C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font><code>0x0000007D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><ul><li> <code>0x08</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Is the size of the label buffer. </font></font></li><li> <code>0xA0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when added to </font></font><code>0x7F80</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">becomes </font></font><code>0x8020</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is, the top 16 bits of the destination address.</font></font></li><li> <code>0x04</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- This is the size of the patch data ( </font></font><code>0x0000007D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font></li><li> <code>0x6F9C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - This is the bottom 16 bits of the destination address. </font></font></li><li> <code>0x0000007D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - this is patch data. </font></font></li></ul></li><li> <code>END \x00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : end marker. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you want to experiment with the creation of a patcher or ROM save files, then </font><font style="vertical-align: inherit;">I posted a very simple code for generating files </font><font style="vertical-align: inherit;">at </font></font><a href="https://github.com/jamchamb/ac-nesrom-save-generator"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/jamchamb/ac-nesrom-save-generator</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">A patch like the one shown above can be generated with the following command:</font></font><br><br> <code>$ ./patcher.py Patcher /dev/null zuru_mode_2.gci -p 80206F9c 0000007D</code> <br> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbitrary code execution </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With this tag you can achieve the execution of arbitrary code in Animal Crossing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But here the last obstacle arises: the use of patches for data works well, but there are problems when patching code instructions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When patches are recorded, the game continues to carry out the old instructions that were in its place. This seems to be a caching problem, and in fact it is. The GameCube CPU has instruction caches, as written </font></font><a href="https://en.wikipedia.org/wiki/Nintendo_GameCube_technical_specifications"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the specifications</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To understand how to clear the cache, I began to examine the cache-related functions from the GameCube SDK documentation, and discovered </font></font><code>ICInvalidateRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This function invalidates cached blocks of instructions at a specified address in memory, which allows the modified instruction memory to be executed with updated code.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, without the ability to run the original code, we still can not call </font></font><code>ICInvalidateRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. For the successful execution of the code, we need another trick. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Studying the implementation </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for the possibility of using the heap overflow exploit, I learned that the implementation functions </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be turned off dynamically using a data structure called </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">loads a pointer to the current implementation </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>free</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from a static memory location, and then calls this function, passing all the arguments passed to </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NES emulator actively uses</font></font><code>my_malloc</code>         ROM NES ,    ,           ,     PAT. <br><br>  <code>my_malloc</code>         ,      ,   ,       <code>malloc</code>  <code>free</code> .      ,          <code>my_malloc</code> . <br><br>  - D≈çbutsu no Mori e+   Cuyler      PowerPC           : <a href="https://www.youtube.com/watch%3Fv%3DBdxN7gP6WIc">https://www.youtube.com/watch?v=BdxN7gP6WIc</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">(D≈çbutsu no Mori e + was the last iteration of Animal Crossing on the GameCube, which had the most updates. Released only in Japan.) The patch loads some code that allows the player to create any objects by typing their ID by letter and pressing the Z button.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/BdxN7gP6WIc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks to this, you can download mods, cheats and homebrew in a regular copy of Animal </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crossing on this GameCube.</font></font></div><p>Source: <a href="https://habr.com/ru/post/417117/">https://habr.com/ru/post/417117/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417107/index.html">The creator of the game while True: learn () about programming in a game dev, problems with VR and simulation ML</a></li>
<li><a href="../417109/index.html">Richard Hamming: Chapter 10. Coding Theory - I</a></li>
<li><a href="../417111/index.html">Online conferences: streaming vs webinar</a></li>
<li><a href="../417113/index.html">3D-printer of the Italian in Russia: Raise3D N1 Dual - modeling and prototyping</a></li>
<li><a href="../417115/index.html">Flutter.io bury or burn?</a></li>
<li><a href="../417119/index.html">Pagination in Vue.js</a></li>
<li><a href="../417123/index.html">Spark Streaming and Kafka Integration</a></li>
<li><a href="../417125/index.html">RTC Meetup .Net: welcome to first meeting</a></li>
<li><a href="../417127/index.html">Tesla has signed an agreement to build Gigafabrika 3 in China</a></li>
<li><a href="../417129/index.html">Mind universe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>