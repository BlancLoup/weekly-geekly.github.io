<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Useful techniques for working with Apache Camel</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you had to create integration solutions in Java, you probably know the wonderful Java framework called Apache Camel . It will easily connect betwee...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Useful techniques for working with Apache Camel</h1><div class="post__text post__text-html js-mediator-article">  If you had to create integration solutions in Java, you probably know the wonderful Java framework called <a href="http://camel.apache.org/">Apache Camel</a> .  It will easily connect between several services, import data from files, databases and other sources, notify you of various events in a Jabber client or via E-mail, and become the basis for a composite application based on a large number of other applications. <br><a name="habracut"></a><br><br><h2>  Introduction </h2><br>  The Apache Camel model is based on the notion of routes ( <a href="http://camel.apache.org/routes.html">routes</a> ), which can be configured both statically (for example, in the Spring-context file) and during application running.  Along the routes, caravans of messages travel along the way to various processors, converters, aggregators and other transformers, which ultimately allows processing data from many different sources in a single application and transferring this data to other services or saving it to any storage. <br>  In general, Camel is a completely self-contained framework.  Using it, often, you don‚Äôt even have to write your own code - you just need to type the correct route that will allow you to solve the problem.  However, all the same, to build your own data processing model, you may need to write code. <br><br>  So it was with us.  We use Camel to implement pipelines to handle multiple messages from various sources.  Such an approach allows, for example, to monitor the status of services, promptly notify about problems, receive aggregated analytical sections, prepare data for sending to other systems, and so on.  The flow of processed and ‚Äúdigestible‚Äù messages to the system can be quite large (thousands of messages per minute), so we try to use horizontally scalable solutions where possible.  For example, we have a system for tracking the status of tests performed and monitoring services.  Millions of such tests are performed daily, and we receive many times more messages to monitor their execution. <br>  In order to ‚Äúassimilate‚Äù a similar volume of messages, it is necessary to clearly define an aggregation strategy ‚Äî from more parallelism to less.  In addition, it is necessary to have at least basic horizontal scalability and fault tolerance of the service. <br>  We use <a href="http://activemq.apache.org/">ActiveMQ</a> as the message queue, and <a href="http://www.hazelcast.com/">Hazelcast</a> as the online storage. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Scaling </h2><br>  For the organization of parallel processing is organized a cluster of several peer servers.  Each of them has an <a href="http://activemq.apache.org/">ActiveMQ</a> broker, whose queues are composed of messages arriving via the HTTP protocol.  HTTP handles are behind the balancer, distributing messages on live servers. <br>  An incoming message queue on each server parses a Camel application that uses a <a href="http://www.hazelcast.com/">Hazelcast</a> cluster to store states and, if necessary, synchronize processing.  ActiveMQ is also clustered using NetworkConnectors, and can ‚Äúshare‚Äù messages with each other. <br>  In general, the scheme is as follows: <br><img src="https://habrastorage.org/getpro/habr/post_images/649/5c7/dc1/6495c7dc17eb971feee08e7562e25cca.png" alt="image"><br>  As can be seen from the diagram, the failure of one of the components of the system does not violate its performance, taking into account the equality of the elements.  For example, if a message handler fails on one of the servers, ActiveMQ starts to send messages from its queues to others.  If one of the ActiveMQ brokers falls, then the handler hooks to the next one.  Well, finally, if the entire server fails, the other servers continue to work hard, as if nothing had happened.  To increase data safety, Hazelcast nodes store backup copies of their neighbors' data (copies are made asynchronously, their number on each node is configured additionally). <br>  This scheme also allows you to scale out the service cost-effectively, adding additional servers, and thereby increasing the computing resource. <br><br><h2>  Distributed aggregators </h2><br>  When using aggregation, Apache Camel includes the concepts of " <a href="http://camel.apache.org/aggregator2.html">aggregation repository</a> " and " <a href="http://camel.apache.org/correlation-identifier.html">correlation key</a> ".  The first is the repository where the aggregated states are stored (for example, the number of dropped tests per day).  The second is the key used to distribute the message flow by state.  In other words, a correlation key is a key in the aggregation repository (for example, the current date). <br>  For aggregators in such a scheme, we needed to implement our own aggregation repository, which can store states in Hazelcast and synchronize the processing of identical keys within the cluster.  Unfortunately, in the standard delivery of Camel, we did not find such a possibility.  It turned out to be quite easy to create it - just implement the <a href="http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/spi/AggregationRepository.html">AggregationRepository</a> interface: <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HazelcastAggregatorRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AggregationRepository</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger logger = LoggerFactory.getLogger(getClass()); <span class="hljs-comment"><span class="hljs-comment">// maximum time of waiting for the lock from hz public static final long WAIT_FOR_LOCK_SEC = 20; private final HazelcastInstance hazelcastInstance; private final String repositoryName; private IMap&lt;String, DefaultExchangeHolder&gt; map; public HazelcastAggregatorRepository(HazelcastInstance hazelcastInstance, String repositoryName){ this.hazelcastInstance = hazelcastInstance; this.repositoryName = repositoryName; } @Override protected void doStart() throws Exception { map = hazelcastInstance.getMap(repositoryName); } @Override protected void doStop() throws Exception { /* Nothing to do */ } @Override public Exchange add(CamelContext camelContext, String key, Exchange exchange) { try { DefaultExchangeHolder holder = DefaultExchangeHolder.marshal(exchange); map.tryPut(key, holder, WAIT_FOR_LOCK_SEC, TimeUnit.SECONDS); return toExchange(camelContext, holder); } catch (Exception e) { logger.error("Failed to add new exchange", e); } finally { map.unlock(key); } return null; } @Override public Exchange get(CamelContext camelContext, String key) { try { map.tryLock(key, WAIT_FOR_LOCK_SEC, TimeUnit.SECONDS); return toExchange(camelContext, map.get(key)); } catch (Exception e) { logger.error("Failed to get the exchange", e); } return null; } @Override public void remove(CamelContext camelContext, String key, Exchange exchange) { try { logger.debug("Removing '" + key + "' tryRemove..."); map.tryRemove(key, WAIT_FOR_LOCK_SEC, TimeUnit.SECONDS); } catch (Exception e) { logger.error("Failed to remove the exchange", e); } finally { map.unlock(key); } } @Override public void confirm(CamelContext camelContext, String exchangeId) { /* Nothing to do */ } @Override public Set&lt;String&gt; getKeys() { return Collections.unmodifiableSet(map.keySet()); } private Exchange toExchange(CamelContext camelContext, DefaultExchangeHolder holder) { Exchange exchange = null; if (holder != null) { exchange = new DefaultExchange(camelContext); DefaultExchangeHolder.unmarshal(exchange, holder); } return exchange; } }</span></span></code> </pre> </div></div><br>  To use such a repository, now you just need to connect to the Hazelcast project and declare it in context, and then add a set of repositories with an indication to the Hazelcast instance.  It is important to remember that each aggregator must have its own key space, and therefore it must also transfer the name of the repository.  In the Hazelcast settings you need to register all the servers that are included in the cluster. <br>  Thus, we get the opportunity to use aggregators in a distributed environment without thinking about which server will aggregate on. <br><br><h2>  Distributed timers </h2><br>  The number of states stored in the cluster is quite large.  But not all of them are needed all the time.  In addition, some states (for example, the status of tests that have not been used for a long time, and therefore there have not been any messages for them for a long time) are generally not necessary to be stored.  I want to get rid of such states and additionally notify other systems about this.  To do this, it is necessary to check the state of aggregators for obsolescence at a specified frequency and to delete them. <br>  The simple way to do this is to add a periodic task, for example, using Quartz.  In addition, Camel allows you to do this.  However, it must be remembered that execution takes place in a cluster with multiple peer servers.  And I don‚Äôt really want the Quartz periodic tasks to work at all at the same time.  To avoid this, it is enough to make synchronization again with the help of Hazelcast locks.  But how to get Quartz to initialize only on one server, or rather at what point in time to synchronize? <br>  To initialize the Camel context and all other components of the system, we use Spring, and to get Quartz to start the scheduler on only one server from the cluster, first, it is necessary to disable its automatic launch by explicitly declaring the context: <br><pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"quartz"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"org.apache.camel.component.quartz.QuartzComponent"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"autoStartScheduler"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"false"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Secondly, you need to synchronize somewhere and start the scheduler only if you managed to capture the lock, and then wait for the next moment of its capture (in case the previous server that captured the lock failed or for some reason released it).  This can be implemented in Spring in several ways, for example, through ApplicationListener, which allows you to handle context launch events: <br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.my.hazelcast.HazelcastQuartzSchedulerStartupListener"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"hazelcastInstance"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ref</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"hazelcastInstance"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"quartzComponent"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ref</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"quartz"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  We get the following implementation of the class scheduler initialization: <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HazelcastQuartzSchedulerStartupListener</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShutdownPrepared</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String DEFAULT_QUARTZ_LOCK = <span class="hljs-string"><span class="hljs-string">"defaultQuartzLock"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> initialized = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; Logger log = LoggerFactory.getLogger(getClass()); Lock lock; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> initialized = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> String lockName; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> HazelcastInstance hazelcastInstance; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> QuartzComponent quartzComponent; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HazelcastQuartzSchedulerStartupListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); log.info(<span class="hljs-string"><span class="hljs-string">"HazelcastQuartzSchedulerStartupListener created"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setLockName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String lockName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lockName = lockName; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> Lock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lock == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { lock = hazelcastInstance.getLock(lockName != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? lockName : DEFAULT_QUARTZ_LOCK); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lock; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareShutdown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> forced)</span></span></span><span class="hljs-function"> </span></span>{ unlock(); } <span class="hljs-meta"><span class="hljs-meta">@Required</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setQuartzComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QuartzComponent quartzComponent)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.quartzComponent = quartzComponent; } <span class="hljs-meta"><span class="hljs-meta">@Required</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setHazelcastInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HazelcastInstance hazelcastInstance)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.hazelcastInstance = hazelcastInstance; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ApplicationEvent event)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (initialized) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { getLock().lock(); log.warn(<span class="hljs-string"><span class="hljs-string">"This node is now the master Quartz!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { quartzComponent.startScheduler(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { unlock(); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(e); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (OperationTimeoutException e) { log.warn(<span class="hljs-string"><span class="hljs-string">"This node is not the master Quartz and failed to wait for the lock!"</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { log.error(<span class="hljs-string"><span class="hljs-string">"Error while trying to wait for the lock from Hazelcast!"</span></span>, e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { getLock().unlock(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IllegalStateException e) { log.warn(<span class="hljs-string"><span class="hljs-string">"Exception while trying to unlock quartz lock: Hazelcast instance is already inactive!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { log.warn(<span class="hljs-string"><span class="hljs-string">"Exception during the unlock of the master Quartz!"</span></span>, e); } } }</code> </pre></div></div><br>  Thus, we will be able to use periodic tasks <a href="http://camel.apache.org/quartz.html">recommended by Camel in the way</a> and taking into account the distributed runtime environment.  For example: <br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">route</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"quartz-route"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">from</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">uri</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"quartz://quartz-test/test?cron=*+*+*+*+*+?"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">log</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">message</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Quartz each second message caught ${in.body.class}!"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">to</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">uri</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"direct:queue:done-quartz"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">route</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><h2>  Finite state machine </h2><br>  In addition to simple methods of aggregation (for example, counting amounts), we also often needed to switch the states of aggregators depending on incoming messages, for example, to always remember the current state of the test performed.  <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25B2%25D1%2582%25D0%25BE%25D0%25BC%25D0%25B0%25D1%2582">Finite automata</a> are well suited for this feature.  Imagine that we have some test status.  For example, TestPassedState.  When we receive a TestFailed message for this test, we must switch the state of the aggregator to TestFailedState, and when we receive the TestPassed, we will again switch to TestPassedState.  And so on to infinity.  On the basis of these transitions, you can draw some conclusions, for example, if a transition occurs TestPassed -&gt; TestFailed, it is necessary to notify all interested parties that the test has broken.  And if the reverse transition occurs, then, on the contrary, tell them that everything has become good. <br><img src="https://habrastorage.org/getpro/habr/post_images/265/cb7/ad5/265cb7ad5c4e61c5eb6ed7076132ac11.png" alt="image"><br><br>  Selecting options for the implementation of such an aggregation strategy, we came to the conclusion that we need some kind of state machine model adapted to the realities of message processing.  First, the messages arriving at the input of aggregators are a certain set of objects.  Each event has its own type, and therefore easily falls on classes in Java.  To describe the types of events, we use the xsd scheme, according to which we generate a set of classes using xjc.  These classes are easily serialized and deserialized into xml and json, using jaxb.  The states stored in Hazelcast are also represented by a set of classes generated by xsd.  Thus, we needed to find an implementation of finite automata, which makes it easy to operate with state transitions based on the message type and the current state type.  And I also wanted these transitions to be specified declaratively, and not imperatively, as in many similar libraries.  We did not find such a lightweight implementation of such functionality, and therefore we decided to write our own, taking into account our needs and well forming the basis for processing messages coming along the route to Camel. <br><br>  A small library that implements our needs is called <b>Yatomata</b> (from the words Yet Another auTomata) and is available on <a href="https://github.com/yandex-qatools/yatomata">github</a> . <br>  It was decided to simplify the FSM model somewhat - for example, the context is set by the current state object, the message also stores some data.  However, the transitions are determined only by the types of states and messages.  A state machine is defined for a class that is used as an aggregator.  For this, the class is annotated with <b>@FSM</b> .  An initial state (start) and a set of transitions are defined for it, some of which stop the aggregation (stop = true), automatically sending the accumulated state further along the route. <br>  A set of transitions is declared by the <b>@Transitions</b> annotation and an array of <b>@Transit</b> annotations, each of which can be given a set of initial states (from), an end state (to), a set of events for which this transition is activated (on), and whether this state is the end of the machine (stop).  For conversion processing, annotations are provided for <b>@OnTransit</b> , <b>@BeforeTransit</b> , and also <b>@AfterTransit</b> , which can be used to mark public methods inside a class.  These methods will be invoked if a matching transition is found that satisfies its signature. <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FSM</span></span>(start = Undefined.class) <span class="hljs-meta"><span class="hljs-meta">@Transitions</span></span>({ <span class="hljs-meta"><span class="hljs-meta">@Transit</span></span>(on = TestPassed.class, to = TestPassedState.class), <span class="hljs-meta"><span class="hljs-meta">@Transit</span></span>(on = TestFailed.class, to = TestFailedState.class), <span class="hljs-meta"><span class="hljs-meta">@Transit</span></span>(stop = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, on = TestExpired.class), }) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestStateFSM</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@OnTransit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onTestFailed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State oldState, TestFailedState newState, TestFailed event)</span></span></span></span>{} <span class="hljs-meta"><span class="hljs-meta">@OnTransit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onTestPassed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State oldState, TestPassedState newState, TestPassed event)</span></span></span></span>{} }</code> </pre><br>  Work with the state machine is as follows: <br><pre> <code class="java hljs">Yatomata&lt;TestStateFSM&gt; fsm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FSMBuilder(TestStateFSM.class).build(); fsm.getCurrentState(); <span class="hljs-comment"><span class="hljs-comment">// returns instance of Undefined fsm.isStopped(); // returns false fsm.getFSM(); // returns instance of TestStateFSM fsm.fire(new TestPassed()); // returns instance of TestPassedState fsm.fire(new TestFailed()); // returns instance of TestFailedState fsm.fire(new TestExpired()); // returns instance of TestFailedState fsm.isStopped(); // returns true</span></span></code> </pre><br>  By implementing the <a href="http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/processor/aggregate/AggregationStrategy.html">AggregationStrategy</a> interface, we created the FSMAggregationStrategy, which is declared in Spring context like this: <br><pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"runnableAggregator"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.my.FSMAggregationStrategy"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">constructor-arg</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.my.TestStateFSM"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  The simplest implementation of an aggregation strategy when using this state machine may look like this: <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FSMAggregationStrategy</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AggregationStrategy</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Yatomata&lt;T&gt; fsmEngine; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FSMAggregationStrategy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class fsmClass)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fsmEngine = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FSMBuilder(fsmClass).build(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Exchange </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aggregate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Exchange state, Exchange message)</span></span></span><span class="hljs-function"> </span></span>{ Object result = state == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> : state.getIn().getBody(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Object event = message.getIn().getBody(); Object fsm = fsmEngine.getFSM(); result = fsmEngine.fire(event); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { logger.error(fsm + <span class="hljs-string"><span class="hljs-string">" error"</span></span>, e); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { message.getIn().setBody(result); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> message; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isCompleted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fsmEngine.isCompleted(); } }</code> </pre><br></div></div><br><h2>  findings </h2><br>  These techniques allowed us to implement several horizontally scalable services for various purposes.  Apache Camel showed its best and met its expectations.  It combines declarativity with high flexibility, which in total provides excellent scaling of integration applications with minimal effort to support and add new functionality. </div><p>Source: <a href="https://habr.com/ru/post/219629/">https://habr.com/ru/post/219629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../219615/index.html">Leakage of confidential data when caching network requests on the iOS platform</a></li>
<li><a href="../219617/index.html">ZooKeeper as a guaranteed delivery system for Yandex.Mail</a></li>
<li><a href="../219619/index.html">Getting a pointer to a .Net object</a></li>
<li><a href="../219623/index.html">An overview of specialized ways to circumvent locks on the Internet</a></li>
<li><a href="../219627/index.html">Epson - report from Droidcon Moscow 2014</a></li>
<li><a href="../219635/index.html">Microsoft Azure for Research Grant</a></li>
<li><a href="../219637/index.html">10 game mechanics in HTML Academy</a></li>
<li><a href="../219647/index.html">What happens in the brains of the neural network and how to help them</a></li>
<li><a href="../219651/index.html">Rakes that are not worth stepping on</a></li>
<li><a href="../219653/index.html">As we were beaten by current on April 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>