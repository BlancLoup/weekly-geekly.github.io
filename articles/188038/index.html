<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Where do gethashcode's hands grow in .NET</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 This article focuses on the generation of hash codes on the .NET platform. The topic is quite interesting, and I think any self-respect...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Where do gethashcode's hands grow in .NET</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  This article focuses on the generation of hash codes on the .NET platform.  The topic is quite interesting, and I think any self-respecting .NET developer should know it.  So let's go! <br><br><h4>  What is stored in objects besides their fields? </h4><br>  We begin our article by finding out what is stored in objects of the reference type in addition to their fields. <br><br>  Each object of reference type has a so-called header (Header), which consists of two fields: a pointer to the type of which this object is (MethodTablePointer), as well as a synchronization index (SyncBlockIndex). <br><a name="habracut"></a><br>  <i><b>What are they needed for?</b></i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The first field is necessary so that each managed object can provide information about its type at runtime, that is, you cannot issue one type after another, this is done for type safety.  Also, this pointer is used to implement dynamic dispatching of methods; in fact, methods of this object are called through it.  The Object.GetType method actually returns exactly the MethodTablePointer pointer. <br><br>  The second field is necessary for a multithreaded environment, namely, in order that each object can be used thread-safe. <br><br>  When the CLR is loaded, it creates a so-called pool of synchronization blocks, you can say a regular array of these synchronization blocks.  When an object needs to work in a multi-threaded environment (this is done using the Monitor.Enter method or a C # lock language construct), the CLR searches for a free synchronization block in its list and writes its index to the same field in the object header.  As soon as the object no longer needs a multi-threaded environment, the CLR simply assigns a value of -1 to this field and thereby frees the synchronization block. <br><br>  Synchronization blocks are in fact a new incarnation of critical sections from C ++.  The creators of the CLR considered that it would be too expensive to associate with each managed object the structure of the critical section, given that most of the objects do not use a multi-threaded environment. <br><br>  For a better understanding of the situation, consider the following picture: <br><img src="https://habrastorage.org/storage2/7c7/f6a/2a0/7c7f6a2a068ab578260996dfd678260a.png"><br><br>  As seen in the picture, ObjectA and ObjectB are of the same type, since their MethodTablePointer points to the same type.  ObjectC has a different type.  It is also seen that ObjectA and ObjectC involve a pool of synchronization blocks, that is, they actually use a multi-threaded environment.  ObjectB does not use the pool because its SyncBlockIndex = -1. <br><br>  Now after we have considered how objects are stored, we can proceed to the generation of hash codes. <br><br><h4>  How GetHashCode works with reference types </h4><br><h5>  The fact that the GetHashCode method returns the address of an object on the managed heap is a myth.  This can not be, in view of its not consistency, the garbage collector, compacting the heap, displaces objects and accordingly changes all their addresses to them. </h5><br>  It was not for nothing that I started the article by explaining what SyncBlock is, since in the first versions of the framework, the free index of some SyncBlock was used as a hash code of the reference type.  Thus, in .NET 1.0 and .NET 1.1, calling the GetHashCode method led to the creation of SyncBlock and entering its index into the object header in the SyncBlockIndex field.  As you understand, this is not a very good implementation for the hash function, because firstly, internal structures that are not needed are created, which take up memory + time is wasted creating them, secondly, hash codes will go in a row, that is, they will be predictable.  Here is a <a href="http://blogs.msdn.com/b/brada/archive/2003/09/30/50396.aspx">link</a> to a blog in which one of the CLR developers says that such implementation is bad and that they will change it in the next version. <br><br>  Since .NET 2.0, the hashing algorithm has changed.  Now it uses the manage identifier of the thread in which the method is executed.  If you believe the implementation in SSCLI20, then the method looks like this: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-function">inline DWORD </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNewHashCode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Every thread has its own generator for hash codes so that we won't get into a situation // where two threads consistently give out the same hash codes. // Choice of multiplier guarantees period of 2**32 - see Knuth Vol 2 p16 (3.2.1.2 Theorem A) DWORD multiplier = m_ThreadId*4 + 5; m_dwHashCodeSeed = m_dwHashCodeSeed*multiplier + 1; return m_dwHashCodeSeed; }</span></span></code> </pre> <br>  Thus, each thread has its own generator for hash codes, so we cannot get into a situation where two threads sequentially generate the same hash codes. <br><br>  As before, the hash code is calculated once and stored in the object header in the SyncBlockIndex field (this is CLR optimization).  Now the question arises, what if after calling the GetHashCode method we need to use the synchronization index?  Where to write it?  And what to do with the hash code? <br><br>  To answer these questions, consider the structure of SyncBlock. <br><img src="https://habrastorage.org/storage2/f46/d73/4da/f46d734da05c964f14acd386079ba99c.png"><br><br>  The first time the GetHashCode method is called, the CLR computes the hash code and puts it in the SyncBlockIndex field.  If SyncBlock is associated with the object, that is, the SyncBlockIndex field is used, the CLR writes the hash code into SyncBlock itself, the figure shows the place in the SyncBlock that is responsible for storing the hash code.  As soon as SyncBlock is released, the CLR copies the hash code from its body to the header of the SyncBlockIndex object.  That's all. <br><br><h4>  How GetHashCode works for significant types </h4><br>  Now let's talk about how the GetHashCode method works for significant types.  I will say in advance, it works quite interestingly. <br><br>  The first thing to say is that the creators of the CLR recommend always overriding this method with user-defined types, since it may not work very quickly, and its default behavior may not always satisfy you. <br><br>  In fact, the CLR has two versions of the implementation of the GetHashCode method for significant types, and then which version will be used depends solely on the type itself. <br><br>  <b>First version:</b> <br>  If the structure does not have reference fields, and there is no free space between its fields, the fast version of the GetHashCode method is used.  The CLR is simply xor - um every 4 bytes of the structure and gets the answer.  This is a good hash, since the entire contents of the structure are involved.  For example, a structure that has a bool type field and an int will have a free space of 3 bytes, since the JIT allocates fields by 4 bytes when placed, and therefore the second version will be used to get the hash code. <br><br>  By the way, there was a bug in the implementation of this version, which was fixed only in .NET 4. It lies in the fact that the hash code for the decimal type was not calculated correctly. <br><br>  Consider the code <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> d1 = <span class="hljs-number"><span class="hljs-number">10.0</span></span>m; <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> d2 = <span class="hljs-number"><span class="hljs-number">10.00000000000000000</span></span>m;</code> </pre><br>  From the point of view of numbers, d1 and d2 are equal, but their bit representations differ (due to the decimal representation of the representation).  And since CLR xor - it is every 4 bytes (of which only 4 since decimal occupies 16 bytes), different hash codes are obtained.  By the way, this bug was manifested not only in decimal, but also in any structure that contains this type, and also uses the fast version to calculate the hash code. <br><br>  <b>The second version:</b> <br>  If the structure contains reference fields or there is free space between its fields, then a slower version of the method is used.  The CLR selects the first structure field, on the basis of which it creates a hash code.  This field should be immutable whenever possible, for example, of the string type, otherwise when it is changed, the hash code will also change, and we will not be able to find our structure in the hash table if it was used as a key.  It turns out that if the first field of the structure is changeable, then it breaks the standard logic of the GetHashCode method.  This is another reason why structures should not be changed.  CLR xor-it hash code of this field with a pointer to the type of this field (MethodTablePointer).  The CLR does not consider static fields, since a static field can be a field with the same data types, with the result that we fall into infinite recursion. <br><br><div class="spoiler">  <b class="spoiler_title">CLR developers comment to GetHashCode on ValueType:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/*=================================GetHashCode================================== ** Action: Our algorithm for returning the hashcode is a little bit complex. We look ** for the first non-static field and get it's hashcode. If the type has no ** non-static fields, we return the hashcode of the type. We can't take the ** hashcode of a static member because if that member is of the same type as ** the original type, we'll end up in an infinite loop. **Returns: The hashcode for the type. **Arguments: None. **Exceptions: None. ==============================================================================*/</span></span> [MethodImplAttribute(MethodImplOptions.InternalCall)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashCode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Note that for correctness, we can't use any field of the value type // since that field may be mutable in some way. If we use that field // and the value changes, we may not be able to look up that type in a // hash table. For correctness, we need to use something unique to // the type of this object. // HOWEVER, we decided that the perf of returning a constant value (such as // the hash code for the type) would be too big of a perf hit. We're willing // to deal with less than perfect results, and people should still be // encouraged to override GetHashCode.</span></span></code> </pre><br></div></div><br><h5>  On a note </h5><br>  Structures cannot contain instance fields of their own type.  That is, the following code will not compile: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Node { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data; Node node; }</code> </pre><br>  This is due to the fact that the structure can not be null.  The following code confirms that this is not possible: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myNode = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node(); myNode.node.node.node.node.node.node.node.node.node.......</code> </pre><br>  However, static fields of their own type are completely allowed, since they are stored in a single copy of the type of this structure.  That is, the following code is quite valid. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Node { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Node node; }</code> </pre><br><h5>  On a note </h5><br>  To understand the situation, consider the following code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">29</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"k1 - {0}, k2 - {1}"</span></span>, k1.GetHashCode(), k2.GetHashCode()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">"abc"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">"def"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"v1 - {0}, v2 - {1}"</span></span>, v1.GetHashCode(), v2.GetHashCode());</code> </pre><br>  In the first case, the structure has no reference fields and there is no free distance between the fields, since the int field takes 4 bytes, so the fast version is used to calculate the hash code, so it will be output to the console: <br><br>  <b>k1 - 411217769, k2 - 411217771</b> <br><br>  In the second case, the structure has a reference field (string), so a slower version is used.  The CLR selects the field with the int type as the field for generating the hash code, and the string field is simply ignored, with the result that the following will be output to the console: <br><br>  <b>v1 - 411217780, v2 - 411217780</b> <br><br>  Now I think it is clear why the CLR developers say that all user-significant data types (and not only significant, but all in general) override the GetHashCode method.  Firstly, it may not work very quickly, secondly, to avoid misunderstanding why the hash codes of different objects are equal, as in the second case of the example. <br><br>  If you do not override the GetHashCode method, you can get a big hit on performance by using a meaningful type as a key in a hash table. <br><br><h4>  How GetHashCode works with string type </h4><br>  The String class overrides the GetHashCode method.  Its implementation in .NET 4.5 looks like this: <br><br><div class="spoiler">  <b class="spoiler_title">GetHashCode X64</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashCode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HashHelpers.s_UseRandomizedStringHashing) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.InternalMarvin32HashString(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Length, <span class="hljs-number"><span class="hljs-number">0L</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* chPtr1 = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num1 = <span class="hljs-number"><span class="hljs-number">5381</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num2 = num1; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* chPtr2 = chPtr1; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num3; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((num3 = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) *chPtr2) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { num1 = (num1 &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) + num1 ^ num3; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num4 = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) chPtr2[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num4 != <span class="hljs-number"><span class="hljs-number">0</span></span>) { num2 = (num2 &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) + num2 ^ num4; chPtr2 += <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num1 + num2 * <span class="hljs-number"><span class="hljs-number">1566083941</span></span>; } }</code> </pre><br></div></div><br>  This is the code for a 64-bit machine, but if we look at the common code with directives <br><br><div class="spoiler">  <b class="spoiler_title">Gethashcode</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashCode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> FEATURE_RANDOMIZED_STRING_HASHING </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(HashHelpers.s_UseRandomizedStringHashing) { return InternalMarvin32HashString(this, this.Length, 0); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> // FEATURE_RANDOMIZED_STRING_HASHING unsafe { fixed (char* src = this) { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> WIN32 int hash1 = (5381&lt;&lt;16) + 5381; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> int hash1 = 5381; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> int hash2 = hash1; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> WIN32 // 32 bit machines. int* pint = (int *)src; int len = this.Length; while (len &gt; 2) { hash1 = ((hash1 &lt;&lt; 5) + hash1 + (hash1 &gt;&gt; 27)) ^ pint[0]; hash2 = ((hash2 &lt;&lt; 5) + hash2 + (hash2 &gt;&gt; 27)) ^ pint[1]; pint += 2; len -= 4; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (len &gt; 0) { hash1 = ((hash1 &lt;&lt; 5) + hash1 + (hash1 &gt;&gt; 27)) ^ pint[0]; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> int c; char* s = src; while ((c = s[0]) != 0) { hash1 = ((hash1 &lt;&lt; 5) + hash1) ^ c; c = s[1]; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (c == 0) break; hash2 = ((hash2 &lt;&lt; 5) + hash2) ^ c; s += 2; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> return hash1 + (hash2 * 1566083941); } } }</span></span></code> </pre><br></div></div><br>  then we note that there are differences depending on which machine is 32 or 64 bit. <br><br>  It should be said that the implementation of this method changes with each .NET release.  This was written by Eric Lippert.  He warned that our code would not in any way save the hashes that are generated in the standard way in the database or on disk, since they are likely to change the implementation in the next .NET release.  So it happened during the last 4 releases of .NET. <br><br>  Implementing hashing on a string type does not imply caching the result.  That is, each time you call the GetHashCode method, we will re-calculate the hash code for the string.  According to Eric Lippert, this is done to save memory, the extra 4 bytes for each object of the string type are not worth it.  Given that the implementation is very fast, I think this is the right decision. <br><br>  If you noticed, in the implementation of the GetHashCode method, code appeared that was not there before: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HashHelpers.s_UseRandomizedStringHashing) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.InternalMarvin32HashString(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Length, <span class="hljs-number"><span class="hljs-number">0L</span></span>);</code> </pre><br>  It turns out that in .NET 4.5 it is possible to calculate the hash code for the strings for each domain.  Thus, by setting the attribute value to 1, you can ensure that the hash code is calculated based on the domain in which the method is called.  Thus, identical strings in different domains will have different hash codes.  The method that generates this hash code is secret and its implementation is not disclosed. <br><br><h4>  How does GetHashCode work for delegates? </h4><br>  Before proceeding to the delegates' discussion of the implementation of the GetHashCode method, let's talk about how they are implemented. <br><br>  Each delegate is inherited from the MulticastDelegate class, which in turn is inherited from the Delegate class.  This hierarchy has developed historically, since it would be possible to do with one class MulticastDelegate. <br><br>  The implementation of the GetHashCode method in the Delegate class looks like this <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashCode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetType().GetHashCode(); }</code> </pre><br>  that is, a hash of the delegate type is actually returned.  It turns out that delegates of the same type containing different methods for calling always return the same hash code. <br><br>  As you know, delegates can contain chains of methods, that is, calling one delegate will lead to calling several methods, in which case such an implementation is not suitable because delegates of one type, regardless of the number of methods, would have one hash code, which is not very good, therefore, in MulticastDelegate, the GetHashCode method is redefined in such a way that it uses each method the underlying delegate.  However, if the number of methods and the type of delegates do coincide, the hash codes will be the same. <br><br>  The implementation of the method in the MulticastDelegate class looks like this <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sealed</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashCode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.IsUnmanagedFunctionPtr()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ValueType.GetHashCodeOfPtr(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._methodPtr) ^ ValueType.GetHashCodeOfPtr(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._methodPtrAux); <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] objArray = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._invocationList <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (objArray == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; index &lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._invocationCount; ++index) num = num * <span class="hljs-number"><span class="hljs-number">33</span></span> + objArray[index].GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num; }</code> </pre><br>  As you know, the delegate stores its methods in the _invocationList list only if there are more than one of them. <br><br>  If the delegate contains only one method, then in the code above <b>objArray = null</b> and, accordingly, the delegate hash code will be equal to the hash code of the delegate type. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] objArray = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._invocationList <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (objArray == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.GetHashCode();</code> </pre><br>  To clarify the situation, consider the following code. <br><br><pre> <code class="cs hljs">Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; f1 = () =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; f2 = () =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  the hash codes of these delegates are equal to the hash code of the type Func &lt;int&gt;, that is, they are equal to each other. <br><br><pre> <code class="cs hljs">Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; f1 = () =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; f2 = () =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>; f1 += () =&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; f2 += () =&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br>  In this case, the delegates' hash codes also coincide, although the methods are different.  In this case, the following code is used to calculate the hash code. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; index &lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._invocationCount; ++index) num = num * <span class="hljs-number"><span class="hljs-number">33</span></span> + objArray[index].GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num;</code> </pre><br>  And the last case <br><br><pre> <code class="cs hljs">Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; f1 = () =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; f2 = () =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>; f1 += () =&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; f1 += () =&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>; f2 += () =&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br>  Hash codes will differ due to the fact that the number of methods for these delegates is not equal (each method has an effect on the resulting hash code). <br><br><h4>  How GetHashCode works for anonymous types </h4><br>  As you know, anonymous types are a new feature in C # 3.0.  Moreover, this is a feature of the language, the so-called syntactic sugar, because the CLR knows nothing about them. <br><br>  Their GetHashCode method is redefined in such a way that it uses each field.  Using this implementation, two anonymous types return the same hash code if and only if all their fields are equal.  Such an implementation makes anonymous types well suited for keys in hash tables. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newType = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { Name = <span class="hljs-string"><span class="hljs-string">"Timur"</span></span>, Age = <span class="hljs-number"><span class="hljs-number">20</span></span>, IsMale = <span class="hljs-literal"><span class="hljs-literal">true</span></span> };</code> </pre><br>  For this anonymous type, the following code will be generated: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashCode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1521134295</span></span> * (<span class="hljs-number"><span class="hljs-number">-1521134295</span></span> * (<span class="hljs-number"><span class="hljs-number">-1521134295</span></span> * <span class="hljs-number"><span class="hljs-number">-974875401</span></span> + EqualityComparer&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;.Default.GetHashCode(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Name)) + EqualityComparer&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt;.Default.GetHashCode(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Age)) + EqualityComparer&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;.Default.GetHashCode(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.IsMale); }</code> </pre><br><h5>  On a note </h5><br>  Given that the GetHashCode method is overridden by the Equals method, it must also be overridden accordingly. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newType = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { Name = <span class="hljs-string"><span class="hljs-string">"Timur"</span></span>, Age = <span class="hljs-number"><span class="hljs-number">20</span></span>, IsMale = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newType1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { Name = <span class="hljs-string"><span class="hljs-string">"Timur"</span></span>, Age = <span class="hljs-number"><span class="hljs-number">20</span></span>, IsMale = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newType.Equals(newType1)) Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"method Equals return true"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"method Equals return false"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newType == newType1) Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"operator == return true"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"operator == return false"</span></span>);</code> </pre><br>  The following will be displayed on the console: <br><br>  method Equals return true <br>  operator == return false <br><br>  The thing is that anonymous types override the Equals method in such a way that it checks all fields as it is done with ValueType (only without reflection), but does not override the equality operator.  Thus, the Equals method compares by value, while the equality operator compares by reference. <br><br>  <b>Why was it necessary to override the Equals and GetHashCode methods?</b> <br>  Given that anonymous types were created to simplify working with LINQ, the answer becomes clear.  Anonymous types are conveniently used as hash keys in grouping operations (group) and joins in LINQ. <br><br><h5>  On a note </h5><br><h4>  Conclusion </h4><br>  As you can see the generation of hash codes is not a very simple matter.  In order to generate good hashes, you need to make a lot of effort, and the CLR developers had to make many concessions to make our lives easier.  It is good to generate the hash code, it is impossible for all cases, therefore it is better to override the GetHashCode method for your custom types, thereby adjusting them to your specific situation. <br><br>  Thanks for reading!  Hope the article has been helpful. <br><br>  Thanks to the <a href="https://habrahabr.ru/users/dreamwalker/" class="user_link">DreamWalker</a> user for kindly providing updated images to the article. </div><p>Source: <a href="https://habr.com/ru/post/188038/">https://habr.com/ru/post/188038/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../188022/index.html">Free translation of executive summary from The Innovator's Solution book on the innovator's dilemma and its possible solution</a></li>
<li><a href="../188024/index.html">Do you use a universal password for client sites?</a></li>
<li><a href="../188026/index.html">Morphology and computational linguistics for the smallest</a></li>
<li><a href="../188032/index.html">Mamba Hiring: DIY statistics</a></li>
<li><a href="../188034/index.html">Picture Factory - how does it work? Part 2</a></li>
<li><a href="../188042/index.html">How HTTPS Secures Your Connection: What Every Web Developer Should Know</a></li>
<li><a href="../188044/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ67 (July 21 - 27, 2013)</a></li>
<li><a href="../188046/index.html">Design Patterns in Ruby: A Template Method</a></li>
<li><a href="../188048/index.html">DALER: and crawls and flies (remote control)</a></li>
<li><a href="../188050/index.html">Google is actively working to create a voice instant translator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>