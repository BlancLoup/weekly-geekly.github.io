<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using the NSProxy class on a simple example</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. Today we will talk about the practical use of NSProxy class, the post will be small, I think it will be interesting to read for many beginners....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using the NSProxy class on a simple example</h1><div class="post__text post__text-html js-mediator-article">  Hello.  Today we will talk about the practical use of NSProxy class, the post will be small, I think it will be interesting to read for many beginners. <br><br>  A little offtopic. <br><br>  In general, the distribution in the company, I got on Legacy project on Objc, where the massive view controller was considered the benchmark of the architecture.  Of course, without normal specs and tests.  For a short development career, I have developed a couple of rules for such projects, the first is no refactoring on my part without instructions from above, the second is to touch the existing code only when absolutely necessary.  All this is due to the fact that in such projects it is very difficult to catch regression (or maybe I'm just lazy?). <br><a name="habracut"></a><br>  Well, for me, this project is legally noteworthy because in terms of architecture there is no such project, there are 1000 lines of controllers, in short, the project is ideal for experiments - it‚Äôs impossible to do worse, and the absence of hard deadlines has only this :) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In general, I received a ticket to expand the existing functionality associated with Google maps (Google maps).  The project code is rather confused, strongly connected, so I decided not to refactor anything and not to touch it at all for fear of breaking something. <br><br>  The ticket itself is simple - add a new type of points on the map and perform certain actions on it.  It's simple.  Let's take a step-by-step look at the evolution of the solution to this task and where the NSProxy class has helped us here <br><br><h4>  Solution 1 (in the forehead) </h4><br>  Of course, especially for a beginner, the thought comes to mind, just add a couple of methods to an already existing controller, the first to request points via the WebService and the second method to display the obtained points on the map.  Those who are not familiar with Google maps, when taped on the map marker, its delegate works <br><br>  - (BOOL) mapView: (GMSMapView *) mapView didTapMarker: (GMSMarker *) marker {} <br><br>  And the logic for handling tapas is already added to the existing method by the next if block, since there already existed a large number of different points on the map before the introduction of the new feature. <br><br>  I decided to give up this method, since the controller is already quite bold, and besides, the new functionality does not overlap with the existing one and is simply boring and serious. <br><br><h4>  Solution 2 </h4><br>  Create a separate controller (not to be confused with the View controller), in which there will be a request for points and their drawing on the map transferred to the Google controller, and to which we will delegate the callback from the tap to the marker from the existing controller.  It would look like this (the code for the new functionality in the old controller): <br><br><pre><code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)viewDidLoad { [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> viewDidLoad]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mapView.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.newLogicController = [[NewLogicController alloc] initWithMapView:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mapView]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.newLogicController load]; } - (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)mapView:(GMSMapView *)mapView didTapMarker:(GMSMarker *)marker { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> canHandleMarker:marker]) { <span class="hljs-comment"><span class="hljs-comment">// old logic } else { // new logic NewLogicController *controller = self.newLogicController; return [controller mapView:mapView didTapMarker:marker]; } }</span></span></code> </pre> <br>  That is, we create a controller and then simply delegate to it tapas on the map for newly added points.  It seems simple, it looks good, but I don‚Äôt like this if for branching old and new logic (maybe a matter of taste or boredom again?).  Although the if-s in the real application was much larger and with complex logic.  It was decided to touch the existing code as little as possible; for this, it was necessary to somehow tell Google the map that it might have several delegates.  The idea was that the delegate, when calling his method, would determine whether a call was made for him at all, if not for him, then forward the call to the next delegate, if for him, then handle the call and terminate the call chain.  Here we smoothly flow to the next solution. <br><br><h4>  Solution 3 </h4><br>  The essence of the idea is to create a class that will support the delegate protocol of Google Maps, but in fact it will not contain its implementation, but will simply delegate calls to real delegates.  Moreover, in my case, first delegate the call to the non-core delegate (that is, the one with the new logic), and only then, if he answers that he is not supported, to the main delegate. <br><br>  The NSProxy class is ideally suited to us for this. Let me remind you that this is an abstract class that does not have a super class (hi NSObject), since it is abstract, then to use it you must inherit from it and implement abstract methods.  Actually, the documentation clearly tells us which methods we must implement, these are a couple of methods: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSMethodSignature</span></span> *)methodSignatureForSelector:(SEL)sel; - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)forwardInvocation:(<span class="hljs-built_in"><span class="hljs-built_in">NSInvocation</span></span> *)invocation;</code> </pre><br>  These methods will be called when your heir proxy class sent any message, and will be called in the same order in which they are written.  In these methods, your proxy should forward calls to other real objects.  In fact, there is a shorter way of proxying through the method: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)forwardingTargetForSelector:(SEL)aSelector;</code> </pre><br>  if the object for which the call is intended is returned from it, then the methods: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSMethodSignature</span></span> *)methodSignatureForSelector:(SEL)sel; - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)forwardInvocation:(<span class="hljs-built_in"><span class="hljs-built_in">NSInvocation</span></span> *)invocation;</code> </pre><br>  will not be called, if you return nil, then the turn of these methods comes. <br><br>  The final simplified view of the proxy class will look something like this: <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GoogleMapViewProxy</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSProxy</span></span></span><span class="hljs-class"> &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GMSMapViewDelegate</span></span></span><span class="hljs-class">&gt; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">weak</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fakeDelegate</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">weak</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">originDelegate</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">instancetype</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">init</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GoogleMapViewProxy</span></span></span><span class="hljs-class"> - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">instancetype</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">init</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; } - (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)forwardingTargetForSelector:(SEL)aSelector { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fakeDelegate respondsToSelector:aSelector]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fakeDelegate; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.originDelegate respondsToSelector:aSelector]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.originDelegate; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; } } - (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)respondsToSelector:(SEL)aSelector { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fakeDelegate respondsToSelector:aSelector]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">YES</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.originDelegate respondsToSelector:aSelector]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">YES</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NO</span></span>; } } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)forwardInvocation:(<span class="hljs-built_in"><span class="hljs-built_in">NSInvocation</span></span> *)invocation { [invocation invokeWithTarget:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.originDelegate]; } - (<span class="hljs-built_in"><span class="hljs-built_in">NSMethodSignature</span></span> *)methodSignatureForSelector:(SEL)sel { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.originDelegate methodSignatureForSelector:sel]; } <span class="hljs-keyword"><span class="hljs-keyword">@end</span></span></code> </pre><br>  Everything important happens in the method: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)forwardingTargetForSelector:(SEL)aSelector;</code> </pre><br>  although we can easily transfer this code to: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSMethodSignature</span></span> *)methodSignatureForSelector:(SEL)sel;</code> </pre><br>  just then the call chain will be a little longer about what I wrote above. <br><br>  As we can see, if a new delegate responds to a message, then the call is delegated to it, if not, then we just call the original (this proxy does not take into account the moment when our new delegate implements methods that the original delegate does not implement, in this implementation we will drop into DoesNotRecognizeSelector , for my case, this situation does not happen, so I dropped this moment). <br><br>  The final version of the code in the controller with the old logic remains almost unchanged: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)viewDidLoad { [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> viewDidLoad]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mapView.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.newLogicController = [[NewLogicController alloc] initWithMapView:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mapView]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.newLogicController load]; }</code> </pre><br>  and the code in the controller with the new logic: <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewLogicController</span></span></span><span class="hljs-class"> () &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GMSMapViewDelegate</span></span></span><span class="hljs-class">&gt; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSMutableArray</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GMSMarker</span></span></span><span class="hljs-class"> *&gt; *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">markers</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GoogleMapViewProxy</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mapProxy</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewLogicController</span></span></span><span class="hljs-class"> - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">instancetype</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initWithMapView</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GMSMapView</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mapView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> init]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { _markers = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span> array]; _mapProxy = [[GoogleMapViewProxy alloc] init]; _mapProxy.fakeDelegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; _mapProxy.originDelegate = mapView.delegate; mapView.delegate = _mapProxy;<span class="hljs-comment"><span class="hljs-comment">//   ,        } return self; } - (BOOL)mapView:(GMSMapView *)mapView didTapMarker:(GMSMarker *)marker { if ([self.markers containsObject:marker]) { //   return NO; } //           return [self.mapProxy.originDelegate mapView:mapView didTapMarker:marker]; } - (void)load { // ... } @end</span></span></code> </pre><br><h4>  Results </h4><br>  The implementation of this task through a proxy allowed us to add functionality to the existing code with minimal changes for it.  If in the future we need to abandon this functionality, then for this we only need to delete the creation of the controller.  High reuseability - to add this feature to another screen, we just need to create a controller and give it a google map. <br><br>  The post turned out to be small, so I will share another interesting case where NSProxy can be used - to refuse tedious type checks: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">id</span></span>&lt;SomeDelegate&gt; delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.delegate; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([delegate respondsToSelector:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(someMethod:)]) { [delegate someMethod:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>]; }</code> </pre><br>  that is, immediately write without fear of falling in the DoesNotRecognizeSelector: <br><br><pre> <code class="objectivec hljs">[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.delegate someMethod:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>];</code> </pre><br>  I will not repeat how to achieve this, everything is very detailed in the <a href="http://petersteinberger.com/blog/2013/smart-proxy-delegation/">article</a> by Peter Steinberger. <br><br>  All cookies and thank you for your attention. <br><br><h4>  Update. </h4><br>  The method of using the NSProxy class considered in the article would be appropriate rather only in a fragile project.  Therefore, in projects under active development, it is not worthwhile to adopt this trick. </div><p>Source: <a href="https://habr.com/ru/post/328206/">https://habr.com/ru/post/328206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328194/index.html">The digest of interesting materials for the mobile # 202 developer (May 2-8)</a></li>
<li><a href="../328198/index.html">Applied application of the nonlinear programming problem</a></li>
<li><a href="../328200/index.html">How to talk about yourself at the interview</a></li>
<li><a href="../328202/index.html">Correction codes "on the fingers"</a></li>
<li><a href="../328204/index.html">Where to go for those who have decided to leave Ubuntu Unity</a></li>
<li><a href="../328208/index.html">Adding to_string simplifies development and debugging code on Elixir</a></li>
<li><a href="../328210/index.html">Exhibitions and conferences on virtual reality 2017</a></li>
<li><a href="../328212/index.html">Reverse Engineering "Kazakov", the last part: the second breath</a></li>
<li><a href="../328218/index.html">Idiom Kotlin, a set of good practices</a></li>
<li><a href="../328220/index.html">Table design</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>