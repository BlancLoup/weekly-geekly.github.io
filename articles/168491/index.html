<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to use the Instruments utility in Xcode</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At this point, your iOS development career is in the state where you wrote one application or two, and you are certainly wondering what you can do to ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to use the Instruments utility in Xcode</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/a21/e40/17f/a21e4017f99a24f278e21178351e89d3.png"><br>  At this point, your iOS development career is in the state where you wrote one application or two, and you are certainly wondering what you can do to make your applications even better. <br><br>  In addition to improving your application by adding to it all kinds of "curlicues", there is one thing that all good developers have to do with their code - process it with the Instruments utility! <br><br>  This guide will show you how to use the most important features of the tool called Instruments, which comes with Xcode.  It will allow you to check your software code for performance problems, memory leaks and other problems. <br><a name="habracut"></a><br>  You will learn: <br><ul><li>  How to detect and fix memory management errors in your code using the Allocations and Leaks tools, and </li><li>  How to determine the problem place in the code using the time profiling tool, and </li><li>  How to make your code more efficient. </li></ul><br><blockquote>  Note: This guide assumes that you are competent in Objective-C and iOS programming.  If you are a complete beginner in iOS programming, you need to read other lessons <a href="http://www.raywenderlich.com/">from this site</a> .  The app on which we are training in this tutorial uses a storyboard, so make sure that you are familiar with this concept;  if not, start with <a href="http://www.raywenderlich.com/5138/beginning-storyboards-in-ios-5-part-1">this guide</a> . <br></blockquote><br>  This tutorial uses Xcode 4.5, make sure your Xcode is updated to the latest version that is available in the Mac App Store. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      All is ready?  Get ready to plunge into the fascinating world of Instruments! <br><br><h2>  Getting started </h2><br>  In this guide, you will not need to go through the process of creating an application from scratch, we will give you a ready-made example of a project.  Your task is to improve this application using Instruments and our recommendations, and then do the same with your own applications! <br><br>  <a href="">Download the project</a> , unpack it and open it in Xcode. <br>  Compile and run the application, in the application, enter some text in the search box, perform a search, then enter the search results, and you will see something like this: <br><img src="https://habrastorage.org/storage2/2b4/6aa/7ed/2b46aa7ed1621d5a87531b2d65422a64.png"><br><br>  Use the application, try its basic functions.  As you understand, the meaning of the application - search and display photos from Flickr.  At the top of the application there is a search string, where you write the query, perform the search, and the result string appears in the table. <br><br>  This table row contains the search query and the number of results found in parentheses.  If you click on a row, you will see another table with a small image and its name. <br><br>  If you click on one of the lines with the image, you can already see a large image, full screen.  At the same time, using the Rotate button, you can rotate the image. <br><br>  So far so good!  You can see that the application works as intended.  And you are ready to upload it to the store.  However, let's see what the Instruments utility says about this application. <br><br><h2>  Time to profile </h2><br>  Many developers start developing with a vague internal need to make an application that will be fast - and this is a worthy goal.  Then they read about the so-called ‚Äúpremature optimization‚Äù and ask themselves how to avoid this terrible phenomenon, condemned by gray-bearded programmers.  And in the worst case, novice developers forget about optimization in general! <br><br>  Of course, you can exclude optimization from your application development process.  This ten years ago, mobile devices were incredibly limited, even the use of floating-point numbers was forbidden, because it made the size of the code huge, and the calculations went at the speed of the glacier. <br><br>  And now in your pocket is incredible power, which is already able to beat the best examples of desktop computers.  But you will not always nod to the powerful hardware and processor speed, instead of removing the inefficient bits in your application. <br><br>  What is "profiling"?  Profiling is a dimension.  The result of the profiling session allows you to determine which parts of the code are used most often, which in turn tells you which parts of the code you should try to improve. <br><br>  You can spend a week fine-tuning an interesting algorithm, but if this code takes only 0.5% of the total execution time, no one will ever notice the difference, no matter how much you have improved it.  If, instead, you optimized the cycle for which your program spends 90% of its time, and improved the cycle by only 10%, then most likely the updated program will receive five stars in reviews, because it will become much faster! <br><br>  First optimization lesson: find the right places to optimize them! <br>  Premature optimization, as you may have guessed, spends time optimizing code, which ultimately does not matter. <br><br>  The first tool we‚Äôll look at is Time Profiler.  When profiling, you will often be confronted with a thread stack trace.  For example, the trace window: <br><img src="https://habrastorage.org/storage2/410/709/b89/410709b89060209043ee80d9fd48dcf5.png"><br><br>  This screen displays the call stack of each thread.  Each line, or frame, as it is also called, is a command executed by the program, and the topmost line (frame number 0) is the line in which the processor is currently executing code. <br><br>  The time spent by each line is determined by how many times the profiler has stopped on this line while the processor has processed the code specified in this line. <br>  For example, if you run 100 samples at intervals of 1 millisecond, and a specific line of code appears in the top line of a stack trace for 10 samples, you can conclude that approximately 10% of the total execution time, that is, 10 milliseconds, was spent on this code.  This is a pretty rough approximation, but it works! <br><br>  If it is not yet clear, we shall understand later, we will start using Instruments! <br>  In the Xcode menu, select the item ProductProfile or press ‚åò I. So you will compile the application and launch Instruments.  You will be greeted with a selection window that looks like this: <br><img src="https://habrastorage.org/storage2/686/9f7/59a/6869f759a32bb991161d53ccc4f3e64b.png"><br><br>  Here you can select the profiling template you want to use. <br>  Select the <b>Time Profiler</b> template and click the <b>Profile</b> button.  The iOS simulator and your application will start.  The system will ask you to enter a password for Instruments utility access to other processes - do not be afraid, it is safe! <br>  In the Instruments window, you can see the countdown, and how the little arrow moves from left to right above the graph in the center of the screen.  This means that your application is running. <br>  Now, we use our application as intended.  Do a couple of searches, click on the search results.  You may have noticed that entering the search results is tediously slow, and scrolling through the list of search results is also incredibly annoying - we have a terribly awkward app! <br>  Well, you're lucky, because we're going to fix it all!  However, for a start, let's take a quick look at Instruments. <br>  First, make sure that all three selection items are pressed on the toolbar's View selector and it looks like this: <br><img src="https://habrastorage.org/storage2/e17/d46/b01/e17d46b01dae7e8ca81d5370f8c444a4.png"><br><br>  This means that all panels are visible.  Now look at the screenshot below and the description of each section below it: <br><img src="https://habrastorage.org/storage2/663/aaf/ca9/663aafca9cb9c0d7a28fabd5bdf0030b.png"><br><br><ol><li>  This is the launch control buttons.  The middle red button stops and starts the application, which is currently profiled.  It actually stops and starts the application - and does not pause. </li><li>  This is a work timer and a navigator.  The timer counts how long the application is running, which is profiled.  Arrows can be moved between launches.  If you stop and then start the application using the controls, you will start a new launch.  The display will read ‚ÄúRun 2 of 2‚Äù, but you can return to the data of the first launch by stopping the current launch, and then pressing the left arrow. </li><li>  This is called a track.  In the Time Profiler template that we have selected, there is only one instrument, and therefore, only one track.  You will learn more about the features of track graphics later in this tutorial. </li><li>  This is a panel of additional details.  In the Time Profiler template, it is used to display the stack trace. </li><li>  This is the details panel.  This shows the basic information about the particular instrument you are using.  In our case, it shows calls that can be called "hot" - that is, those that used the most CPU time. <br>  If you click on the panel just above, which says: ‚ÄúCall Tree‚Äù (the ‚ÄúCall Tree‚Äù on the left) and select ‚ÄúSample List‚Äù, then you will see a different type of data.  This will be a list of samples.  Click on a couple of samples, and you will see the stack trace caught by them in the additional details panel. </li><li>  This is the options panel.  You will learn about it soon. </li></ol><br>  And now rule the clumsy interface of our program! <br><br><h2>  Looking deep </h2><br>  Start the image search and enter the result.  I personally like to look for the word ‚Äúdog‚Äù, but you yourself choose what you want to look for - you can be one of those very people who adore kote! <br><br>  Twist the result window up and down several times so that you have a good amount of data to profile.  You will see that the numbers in the middle of the screen are changing and the graph is being filled;  This means that CPU cycles are used. <br><br>  You probably did not expect such a "braked" behavior of the user interface;  The application with the list is not ready for the AppStore until the list scrolls like clockwork!  To help pinpoint the problem, you need to change some of the time profiling options. <br><br>  In the options panel (remember, # 6 in the picture), in the <b>Call Tree</b> section, tick off the <b>Separate by Thread</b> , <b>Invert Call Tree</b> , <b>Hide System Libraries</b> and <b>Show Obj-C Only</b> checkboxes.  It will look like this: <br><img src="https://habrastorage.org/storage2/f95/106/d1e/f95106d1ef00c2e8090a1b765081a8e7.png"><br><br>  This is what these options are for: <br><ul><li>  <b>Separate by Thread</b> : Each thread must be considered separately.  This allows you to understand which threads are responsible for the most CPU usage. </li><li>  <b>Invert Call Tree</b> : The stack trace will be displayed from top to bottom.  This means that you will see in the report those lines of code that were in frame number 0 when the sample stopped.  After all, as a rule, you want to see the most "heavy" lines of code for which the processor spends the most time. </li><li>  <b>Hide Missing Symbols</b> : If a dSYM file is not found for your application or system framework, then instead of procedure names, you will see only hexadecimal values.  If this option is selected, they will be hidden, and only fully recognized calls will be shown.  This will help to streamline the submitted data. </li><li>  <b>Hide System Libraries</b> : If this option is selected, then only calls to your own application will be displayed.  This is a very useful option, as you are usually interested only in the processor costs of your code - you can not do anything with the processor costs of the system libraries! </li><li>  <b>Show Obj-C Only</b> : If this option is selected, then only Objective-C methods will be displayed, and not all C or C ++ functions.  They are usually not in your program, well, unless you use OpenGL, for example. </li><li>  <b>Flatten Recursion</b> : This option allows you to display a recursive function (a function that calls itself) as one record in each stack trace, rather than as multiple records. </li><li>  <b>Top Functions</b> : If you tick the box, the Instrumens will consider the time spent by the function as the sum of the time immediately inside this function and the time spent in the sub-function caused by this function.  That is, if function A caused function B, then the time spent by A would be equal to the time spent by function A PLUS time spent by function B. This can be very useful, as it allows you to immediately find the most time-consuming call. </li></ul><br><br>  Although some values ‚Äã‚Äãmay differ slightly, after setting the checkboxes I specified, the report should look like this: <br><img src="https://habrastorage.org/storage2/5d1/eef/f5b/5d1eeff5bc079ce4a66c6c194922bff5.png"><br><br>  Well, of course, we see the problem.  The vast majority of time is spent on executing the <b>setPhoto</b> procedure <b>:</b> from the <b>PhotoCell</b> class, that is, on displaying a photo in a row of a table.  This should not be news for you, you remember that the scrolling of the table was the slowest element of the program interface. <br>  To find out what is happening inside this method, double-click on the line with its name.  You will see this window: <br><img src="https://habrastorage.org/storage2/eba/2b5/adb/eba2b5adba6dec78fbe3c4a36c06f22b.png"><br><br>  Now that's interesting, isn't it!  Almost three-quarters of the time spent setPhoto procedure: busy creating an <b>imageData</b> variable for a photo! <br><br>  Now you can see what the problem is.  The <b>dataWithContentsOfURL</b> method waits and does not return until the data has been loaded.  And each request to the Internet to receive data can take up to several seconds.  This method runs on the main thread, and therefore the entire user interface is blocked while images are being loaded. <br><br>  To solve this problem, you need to use the call <b>ImageCache</b> , which allows you to asynchronously load images in the background thread.  The code is already in the <b>PhotoCell</b> class. <br>  You can switch to Xcode and find the file you want, but Instruments has a convenient ‚ÄúOpen in Xcode‚Äù button.  Find it on the panel just above the code and click: <br><img src="https://habrastorage.org/storage2/f2b/2f4/19c/f2b2f419c21e7136c07dcb2fc09f9b0a.png"><br><br>  Click!  Xcode gives us the right place! <br>  Now, comment out the two lines in which we populate the imageData variable and the image at the row of the table, and remove the comment in the code block below.  Now the setPhoto method will look like this: <br><br><pre><code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)setPhoto:(FlickrPhoto *)photo { _photo = photo; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.textLabel.text = photo.title; <span class="hljs-comment"><span class="hljs-comment">// NSData *imageData = [NSData dataWithContentsOfURL:_photo.thumbnailUrl]; // self.imageView.image = [UIImage imageWithData:imageData]; [[ImageCache sharedInstance] downloadImageAtURL:_photo.thumbnailUrl completionHandler:^(UIImage *image) { self.imageView.image = image; [self setNeedsLayout]; }]; }</span></span></code> </pre> <br><br>  Re-run application profiling using Instruments by clicking <b>ProductProfile</b> (or ‚åò I - remember that these hot keys really save you time). <br>  Please note that this time you were not asked which Instruments pattern to use.  This is because you still have our application window open, and Instruments assumes that you want to run it again with the same template. <br><br>  Work again in the application, run a couple of searches.  Note that this time the interface is not as clumsy as it was before!  Images are now loaded asynchronously and cached in the background, so if they were loaded once, they are not loaded again. <br><br>  Looks good!  Is it time to send the program to the AppStore?  Not yet! <br><br><h2>  Something with my memory has become </h2><br>  The next tool we consider is Allocations.  He will give you detailed information about all the objects that were created and about the memory they occupied;  it also shows the number of links to each object. <br><br>  Let's start profiling our application with a new profile.  Close the Instruments, go back to Xcode and select the <b>ProductProfile</b> menu <b>item</b> again.  Then select the <b>Allocations</b> profile and click the <b>Profile</b> button. <br><img src="https://habrastorage.org/storage2/1f0/e43/d11/1f0e43d11309ffc0934e75a12bb77064.png"><br><br>  The Instruments utility will open again, and you will see the following window: <br><img src="https://habrastorage.org/storage2/9ee/2cc/71c/9ee2cc71cf54a76cfd38b554c599a994.png"><br><br>  This time you will see two tracks.  One of them is called <b>Allocations</b> , the other is <b>VM Tracker</b> .  We will take a closer look at the Allocations profile in this lesson;  VM Tracker profile is also very useful, but it is more difficult, about him another time. <br>  So what error are we going to look for? <br><br>  She is in the project, but you do not know where.  You've probably heard of memory leaks.  But, most likely, you do not know that in reality there are two types of leaks. <br>  One of them is a real memory leak when the object was not released, but no one needs it.  Because of this, the occupied memory cannot be reused. <br><br>  The second type of leak is a bit more complicated.  It is called "unlimited growth of memory."  It occurs when memory continues to stand out and is not given a chance to be released. <br>  If this continues indefinitely, at some point the memory will be full, and you will encounter big problems with memory.  In iOS, this means that the application will be killed by the system watchdog timer.  So your application will not get five stars! <br><br>  We develop a plan for how we can detect unlimited memory growth.  First, perform in the application of pieces of 10 different searches (but do not enter the results yet).  Make sure the search yielded some results!  Now we will wait a few seconds without touching the application. <br>  You will notice that the graph in the Allocations track is growing.  This suggests that memory continues to be allocated.  So you got an unlimited growth of memory. <br><br>  We will do the so-called "snapshot analysis of the heap."  To do this, click the button called ‚ÄúMark Heap‚Äù.  You will find it on the panel on the left side: <br><img src="https://habrastorage.org/storage2/cbe/5e5/f0e/cbe5e5f0ef7e5f4a9134fef5172c74c9.png"><br><br>  Click it and see a red flag appear in the track, like this: <br><img src="https://habrastorage.org/storage2/d99/249/a32/d99249a320099d9a135448cbfb56e62d.png"><br><br>  The purpose of analyzing a heap snapshot is to perform some action several times, and see where memory grows indefinitely.  Enter one of the search results and wait a few seconds for the images to load, and then return to the main page.  Check one more box on the heap.  Do this several times with different search results. <br><br>  After 10 entries in all 10 results, the Instruments window will look like this: <br><img src="https://habrastorage.org/storage2/a41/697/b83/a41697b837a8e27fab64524063db51bb.png"><br><br>  Well, of course, there is nothing good here.  But wait, but what about the message about the lack of memory?  You know about them, right?  The message about the lack of memory iOS says that the application has become cramped in memory, and you need to clear part of the memory occupied. <br><br>  It is possible that your application is not guilty of anything, and this is something in the depths of UIKit memory consumption.  Let's give the system frameworks and your application a chance to clear your memory before pointing your finger at the guilty one. <br><br>  We simulate a message about low memory by selecting the Hardware \ Simulate Memory Warning option in the iOS simulator menu (in the Russian version, the Hardware \ Simulate a low memory warning).  You will notice that memory has become less used, but, of course, not as little as before.  That is, somewhere there is an unlimited growth of memory. <br><br>  Let's take a look at the snapshots taken. <br><br><h2>  Hit me with your best shot </h2><br>  The first shot is the base one.  Open it, you will see all the objects for which memory was allocated and which were not released at the time when the picture was taken.  Subsequent snapshots will contain only changes in objects between the current and previous snapshots. <br><br>  Look at the ‚ÄúHeap Growth‚Äù column, and you will see that, of course, growth is happening somewhere.  Open one of the heap snapshots and you will see the following window: <br><img src="https://habrastorage.org/storage2/0ed/705/6dd/0ed7056dd5098c7689c16dce4fd020df.png"><br><br>  Wow, how many objects!  Where to begin? <br><br>  It is best to look at the classes that you use in your application directly.  In our case, the classes are HTTPHeaderDict, CGRegion, CGPath, CFNumber, etc.  can be ignored. <br><br>  But the UIImage class that we use in the application is interesting for us.  Click the arrow to the left of the UIImage to expand the list of created UIImage objects.  Select one of the specific UIImage objects from the list and look at the additional information panel (on the right): <br><img src="https://habrastorage.org/storage2/a9c/7dc/be0/a9c7dcbe086f46368d4d3c28be9ce7aa.png"><br><br>  This is a stack trace at the time this particular UIImage was created.  The trace lines shown in gray are in the system libraries;  lines in black font - in the application code.  If you double-click on such a black line, we will get into the code of our application: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)downloadImageAtURL:(<span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span>*)url completionHandler:(ImageCacheDownloadCompletionHandler)completion { <span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> *cachedImage = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> imageForKey:[url absoluteString]]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cachedImage) { completion(cachedImage); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">dispatch_async</span></span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number"><span class="hljs-number">0</span></span>), ^{ <span class="hljs-built_in"><span class="hljs-built_in">NSData</span></span> *data = [<span class="hljs-built_in"><span class="hljs-built_in">NSData</span></span> dataWithContentsOfURL:url]; <span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> *image = [<span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> imageWithData:data]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> setImage:image forKey:[url absoluteString]]; <span class="hljs-built_in"><span class="hljs-built_in">dispatch_async</span></span>(dispatch_get_main_queue(), ^{ completion(image); }); }); } }</code> </pre><br><br>  The Instruments utility is very useful, but it can not do everything for you!  Now you need to work independently to understand where the problem is with the memory. <br><br>  Look at the method above and you will see that it calls a method called <b>SetImage: forKey</b> .  This method caches the image so that it can be used again in the application later.  Aha  Maybe we found a problem! <br><br>  Take a look at the implementation of this method: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)setImage:(<span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span>*)image forKey:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span>*)key { [_cache setObject:image forKey:key]; }</code> </pre><br><br>  Here an image is added to the dictionary, as the object corresponding to the key is the URL of the image.  But if you look at the code, you will notice that the image is never removed from this dictionary! <br>  This is where our unlimited memory growth happens!  Everything works as it should, but the application does not remove anything from the cache - it only adds! <br><br>  To solve this problem, you need to enable the ImageCache class to hear the low-memory warnings that UIApplication receives.  When ImageCache receives a warning, it will be a good boy and clear its cache. <br><br>  To get ImageCache to receive warnings, change the initialization method to become like this: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)init { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> init])) { _cache = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> new]; [[<span class="hljs-built_in"><span class="hljs-built_in">NSNotificationCenter</span></span> defaultCenter] addObserver:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> selector:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(memoryWarning:) name:<span class="hljs-built_in"><span class="hljs-built_in">UIApplicationDidReceiveMemoryWarningNotification</span></span> object:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; }</code> </pre><br><br>  So you register the receipt of <b>UIApplicationDidReceiveMemoryWarningNotification</b> messages in the <b>memoryWarning</b> method <b>:.</b>  Now implement this method as shown below: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)memoryWarning:(<span class="hljs-built_in"><span class="hljs-built_in">NSNotification</span></span>*)note { [_cache removeAllObjects]; }</code> </pre><br><br>  The memoryWarning method will only delete all objects in the cache.  This ensures that the images will not remain in memory, they will all be released. <br><br>  To check this, run the Instruments utility again (in Xcode, press ‚åò I) and repeat the steps you did before.  Do not forget to simulate the lack of memory at the end! <br><blockquote>  Note: Make sure you start the fixed application from Xcode, and not just press the red button in Instruments.  This is the only way to start profiling the modified code. <br></blockquote><br>  This time, the heap snapshot analysis will look like this: <br><img src="https://habrastorage.org/storage2/04a/11f/df7/04a11fdf72ee5289c56acb722cb09af8.png"><br><br>  This time, memory usage plummeted after a low-memory message was received.  Of course, a certain amount of memory is still used, but not as large as before. <br><br>  The reason for some growth in the use of memory can be system libraries, and here we can not do anything.  All you can do in your application is free up as much memory as possible, and you have already done it! <br><br>  Well done!  Another problem fixed!  Well, now it‚Äôs time to download the app in the AppStore!  Oh, wait - there is still a problem of the first type of memory leak, and we still have not solved it. <br><br><h2>  Call the plumber - you have a leak! </h2><br>  The next profile we look at is Leaks.  It is used to find memory leaks of the first kind, as we said earlier - this is when the object is no longer referenced, and it takes up memory. <br><br>  Leak detection seems to be very difficult, but the Leaks profile remembers all the objects for which memory was allocated and periodically scans each object to determine which may not be available from any other object. <br><br>  Close Instruments, go back to Xcode and select the menu item <b>ProductProfile</b> .  Select a <b>Leaks</b> profile and click the <b>Profile</b> button: <br><img src="https://habrastorage.org/storage2/fa5/0b1/c75/fa50b1c7549ba91da6f74d52adb45641.png"><br><br>  In the Instruments window there are 2 tracks - Allocations and Leaks.  Track Allocations is the same as you used in the previous section. <br><br>  We will only use the Leaks track in this section, so click on it to highlight it.  Please note that the contents of the other Instruments windows have changed since then and now show information about the Leaks track. <br><br>  In the information panel, at the bottom left, the <b>Automatic Snapshotting</b> flag is already on.  This means that memory snapshots for detecting memory leaks will be taken automatically. <br>  The interval between shots can be changed, but 10 seconds set by default is quite enough for our purposes.  You can also take a picture at any time by clicking on the ‚ÄúSnapshot Now‚Äù button. <br><br>  Work with the application!  Run the search and enter the search results.  Then click on one of the lines with the result to see the image in full screen.  Press the <b>Rotate</b> button several times in the upper left corner. <br><br>  Return to Instruments.  If you have done all these steps correctly, you will notice a leak!  The Instruments window will look like this: <br><img src="https://habrastorage.org/storage2/1d5/d7b/35d/1d5d7b35d58290eaf78552aadcb0620a.png"><br><br>  Return to the iOS simulator and press the <b>Rotate</b> button a couple more times.  Return to Instruments and wait.  More leaks will appear, the window now looks something like this: <br><img src="https://habrastorage.org/storage2/7fa/307/68e/7fa30768e0d802554007c274c3a3632a.png"><br><br>  Where did these leak?  If the additional information panel is not open for you, open it by pressing the button on the far right in the View selector: <br><img src="https://habrastorage.org/storage2/e17/d46/b01/e17d46b01dae7e8ca81d5370f8c444a4.png"><br><br>  Select the CGContext object from the list of objects with a detected memory leak.  Look at the additional information panel, it shows the stack trace at the time the object is created.  Tracing looks like this: <br><img src="https://habrastorage.org/storage2/475/bb6/44e/475bb644ee9b95a9b5ebe157b6a00ed1.png"><br><br>  And again in the list of frames among the "gray" frames, calls to system frameworks, there is a "black" frame - a call to the code of our application.  Double-click on it to see the code for this method. <br>  This is the <b>rotateTapped:</b> method, which handles pressing the Rotate button.  This method rotates the original image and creates a new image, the code is shown below: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)rotateTapped:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)sender { <span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> *currentImage = _imageView.image; <span class="hljs-built_in"><span class="hljs-built_in">CGImageRef</span></span> currentCGImage = currentImage.CGImage; <span class="hljs-built_in"><span class="hljs-built_in">CGSize</span></span> originalSize = currentImage.size; <span class="hljs-built_in"><span class="hljs-built_in">CGSize</span></span> rotatedSize = <span class="hljs-built_in"><span class="hljs-built_in">CGSizeMake</span></span>(originalSize.height, originalSize.width); <span class="hljs-built_in"><span class="hljs-built_in">CGContextRef</span></span> context = <span class="hljs-built_in"><span class="hljs-built_in">CGBitmapContextCreate</span></span>(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, rotatedSize.width, rotatedSize.height, <span class="hljs-built_in"><span class="hljs-built_in">CGImageGetBitsPerComponent</span></span>(currentCGImage), <span class="hljs-built_in"><span class="hljs-built_in">CGImageGetBitsPerPixel</span></span>(currentCGImage) * rotatedSize.width, <span class="hljs-built_in"><span class="hljs-built_in">CGImageGetColorSpace</span></span>(currentCGImage), <span class="hljs-built_in"><span class="hljs-built_in">CGImageGetBitmapInfo</span></span>(currentCGImage)); <span class="hljs-built_in"><span class="hljs-built_in">CGContextTranslateCTM</span></span>(context, rotatedSize.width, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f); <span class="hljs-built_in"><span class="hljs-built_in">CGContextRotateCTM</span></span>(context, M_PI_2); <span class="hljs-built_in"><span class="hljs-built_in">CGContextDrawImage</span></span>(context, (<span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>){.origin=<span class="hljs-built_in"><span class="hljs-built_in">CGPointZero</span></span>, .size=originalSize}, currentCGImage); <span class="hljs-built_in"><span class="hljs-built_in">CGImageRef</span></span> newCGImage = <span class="hljs-built_in"><span class="hljs-built_in">CGBitmapContextCreateImage</span></span>(context); <span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> *newImage = [<span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> imageWithCGImage:newCGImage]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.imageView.image = newImage; }</code> </pre><br><br>  And again, Instruments utility gives you a hint where the problem is, but what the problem is, she cannot tell you for sure.  Instruments can only show you where the memory leak object was created.  And your job is to solve the problem! <br><br>  The person who wrote the code probably thought that ARC should have taken over all the memory management ... right? <br>  Recall that ARC only works with Objective-C objects.  It does not count references and free CoreFoundation objects that are not Objective-C objects. <br><br>  And now it becomes obvious that the problem is that the CGContextRef and CGImageRef objects were not freed!  To fix this, add the following two lines of code at the end of the <b>rotateTapped</b> method <b>:</b> <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">CGImageRelease</span></span>(newCGImage); <span class="hljs-built_in"><span class="hljs-built_in">CGContextRelease</span></span>(context);</code> </pre><br><br>  These two calls are necessary to balance the number of references to these two objects.  The moral of this story is that you still have to remember about the counting of links to objects, even if you use ARC in your project! <br>  Log in to Xcode, press ‚åòI to profile the application in Instruments. <br><br>  Run the application again using the Leaks profile and verify that the memory leak has been fixed.  If you completed the steps described correctly, the leak should disappear! <br>  Well done!  Keep it up! <br><br><h2>  What's next? </h2><br>  Now use the knowledge gained to profile your own applications with the help of Instruments and see what is happening in them!  Also, try making Instruments part of your software development work. <br><br>  Instrument through your code as often as possible.  Spread your application in the AppStore, only making sure that you have done everything possible to find problems with performance and memory management. <br>  Now go and make effective applications! </div><p>Source: <a href="https://habr.com/ru/post/168491/">https://habr.com/ru/post/168491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../168475/index.html">Marketing from Blizzard Entertainment</a></li>
<li><a href="../168477/index.html">Attributes system</a></li>
<li><a href="../168483/index.html">5 Practical Tips for Using Lithium-Ion Batteries</a></li>
<li><a href="../168485/index.html">The dark side of the code</a></li>
<li><a href="../168487/index.html">Ordinary screen user: who is he?</a></li>
<li><a href="../168493/index.html">7 steps to successfully migrate the SharePoint 2007 portal to SharePoint 2010</a></li>
<li><a href="../168497/index.html">Returning to the printed</a></li>
<li><a href="../168503/index.html">Kim Jong-un and the mysterious smartphone</a></li>
<li><a href="../168511/index.html">Runetology (184): Oleg Cheltsov, Fotolia project founder</a></li>
<li><a href="../168515/index.html">Squid3 in SSLBump mode with dynamic certificate generation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>