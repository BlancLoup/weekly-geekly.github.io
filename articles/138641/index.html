<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The evolution of security systems on electronic keys</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is devoted to the development of protection systems on hardware keys, the types of attacks that have been faced in recent years, and how ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The evolution of security systems on electronic keys</h1><div class="post__text post__text-html js-mediator-article">  This article is devoted to the development of protection systems on hardware keys, the types of attacks that have been faced in recent years, and how they managed to resist.  The possibilities of electronic keys that directly affect the degree of protection of software, and the main problems inherent in this technology are considered.  The author of the article is the leading developer of the Guardant project, Aktiv company. <br><br>  Modern electronic keys are divided into keys with symmetric cryptography, keys with asymmetric cryptography, and keys with downloadable code.  The latter type of device requires more detailed analysis beyond the scope of this article. <br><br>  Consider the protection of Windows-based applications developed using compiled programming languages ‚Äã‚Äã(C, C ++, Pascal, Delphi, Fortran, etc.). <br><a name="habracut"></a><br><h4>  Data exchange between the program and the electronic key </h4><br>  The main way to build reliable protection is to use the API library to work with the electronic key.  As a rule, API is delivered in the form of static and dynamic library. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Static libraries, in contrast to dynamic ones, are joined (linked) to the executable program during the build process.  Their use is most preferable, since  eliminates the possibility of a simple file substitution.  Next, we will consider the protection of applications using exactly the static library. <br><br>  The program communicates with the electronic key through the API library, which directly interacts with the electronic key driver.  A typical exchange scheme between a protected program and an electronic key is shown in Fig.1. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cd1/b43/eb0/cd1b43eb0f507fc3eef9efb12603e048.png" alt="image"><br><br>  Attacks in such a scheme are aimed at the interaction between different security modules.  Interception of requests to the electronic key at the level of the electronic key driver (1) or USB bus driver (2) does not require any modification of each new version of the application, unlike the variant with interception of static API library calls (3). <br><br><h4>  Attack on the dongle driver </h4><br>  This type of attack is the simplest.  The original electronic key driver is replaced with an emulator driver.  Data transmitted to the key and returned back are intercepted and stored in a file on disk.  Then the original key is removed from the computer and the program begins to interact with the emulator, continuing to sincerely believe that communicates with the key. <br><br>  Turning to the particulars, I would like to dwell in more detail on the protection from software emulators in Guardant electronic keys.  Guardant dongle drivers contain an electronic signature (ES).  When you call Guardant API functions, the protected application automatically checks the driver signature in RAM.  Since the private key is not known, it is impossible to create a driver emulator with the correct signature.  The virtual machine (pseudocode), through which the executable driver files and the Guardant API libraries, is prevented from removing the check.  The verification scheme is shown in Fig.2. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/88d/703/422/88d703422c173180d1528c15a3f24c74.png" alt="image"><br><br>  After the implementation of such protection in practice, software emulators have shifted to the USB-bus level (2nd version of the attack). <br><br><h4>  USB bus driver attack </h4><br>  The creation of such an emulator required the study of the exchange protocol between the dongle driver and the USB bus driver.  Paradoxically it sounds, but in such a situation LPT-keys turned out to be more reliable, since  The dongle driver directly interacts with the LPT dongle through the computer I / O ports, bypassing the intermediate driver. <br><br>  Unfortunately, it is impossible to completely get rid of software emulators at the USB bus level using keys with symmetric cryptography.  However, good protection, built on a constant exchange with an electronic key, may require more than one day to record all possible parcels and answers to the key and work for an illegal user at the most inappropriate moment.  Hacked programs that stop working for unknown reasons, only to confirm. <br><br>  Separately, I want to mention the protection, when developers are limited to a simple test of the presence of an electronic key.  This is a blunder.  Using the disassembler, ‚Äúindependence‚Äù can be presented to such a program in 15 minutes. <br><br>  In electronic keys with asymmetric cryptography, the data exchange between the protected program and the electronic key is encrypted on the session keys.  For this reason, the third option is the only possible attack. <br><br><h4>  Attack to intercept static library API calls </h4><br>  This attack is the most logical for keys with asymmetric cryptography.  It is expedient only if the electronic key manufacturer takes care of the protection of its libraries, otherwise it is much easier to attack the library itself. <br><br>  With the help of modern disassembler, you can quickly recognize the functions of the API in the program.  And if so, then all function calls are easy to intercept.  This means that access codes, requests and responses are still vulnerable.  And if the program developer himself did not protect calls to API functions, then this is the best place to attack. <br><br>  To exclude the possibility of intercepting calls to the static API library in a protected program, you need to combine the key functions of the application and the API functions into a single whole.  Only then will it be really difficult to analyze the parameters, intercept calls or modify requests and responses to API functions.  In practice, the development of protection is started after the main application code has been written.  Very often, there is not enough time and, perhaps, desire for a deep integration of the interaction between the program and electronic keys.  The least time consuming way to improve the quality of protection is to additionally use software tools that complicate code analysis.  In this case, the interaction of the program functions and the functions of the static API library becomes difficult to understand. <br><br>  Returning to Guardant dongles, let's say that all Guardant API libraries are protected from analysis and modification using a virtual machine.  By virtual machine is meant pseudocode obtained from the original binary code of the program, and the corresponding interpreter.  Pseudocode instructions can only be executed on the interpreter for which it was generated.  The interpreter is responsible for protecting the pseudocode instructions and itself against modification using multiple integrity controls.  All parameters of instructions, constants, addresses of transitions are decrypted on the hashes of the pseudo-code and interpreter fragments.  To make analysis difficult, the pseudocode interpreter is protected using polymorphic obfuscation.  The listed characteristics are implemented in a unique way in each copy of the virtual machine. <br><br>  The pseudocode protection technology is available to anyone using the <a href="http://www.guardant-online.ru/guardant-armor/review/">Guardant Armor</a> service.  This approach has a number of advantages: the protection tool is constantly updated and is not available for study.  At the same time, developers who use Guardant dongles receive special benefits.  The service allows you to protect the program's functions simultaneously with the functions of the Guardant API static library ( <a href="http://www.guardant-online.ru/guardant-armor/monolith/">Guardant Monolith</a> technology).  The presence of the Guardant API library within the application is determined automatically, so no additional recompilation of the application is required.  As a result, each time the application is protected, a unique copy of the virtual machine is created with its own instructions, constants, obfuscation, in which the logic of the program is closely related to the electronic key library.  Now, in order to intercept calls to a static library or attack the library itself, you will have to deal with each defense individually. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ed/8ae/838/5ed8ae838e6d597c924bc69a04847c5a.png" alt="image"><br><br>  Consider this on the example of a small test application, a fragment of which is shown in Fig.4.  This example very clearly characterizes the vulnerability of calls to any static library within an application.  The problem concerns all manufacturers of electronic keys. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7bd/a06/8fc/7bda068fc02893b2fbf9e7d601f25dcb.png" alt="image"><br><br>  Suppose that the application function <code>MyLogicAndVerifyDongle</code> contains some software calculations using an electronic key.  Work without this function is impossible, since  it contains part of the key application logic.  In this case, the function call is made from a less important part of the program code.  To access the dongle, calls are made to the Guardant API static library.  In this example, these are calls to the <code>GrdRead</code> and <code>GrdCrypt</code> .  At the beginning of each function there is only a transition to the protected area VM_Start.  However, the <code>MyLogicAndVerifyDongle</code> function <code>MyLogicAndVerifyDongle</code> remains unprotected and may be subject to attack. <br><br>  Now let's protect the API functions and key functions of the application using Guardant Online service.  A fragment of the protected application is shown in Fig.  five. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cca/d77/a4e/ccad77a4eb0e6492c7d504d102a36f72.png" alt="image"><br><br>  After protection, the <code>MyLogicAndVerifyDongle</code> function <code>MyLogicAndVerifyDongle</code> contains a transition to the protected area <code>Guardant_VirtualMachine</code> .  The addresses where the executable function code was previously located are garbage instructions.  The function itself is translated into pseudo-code and executed on the same virtual machine as the Guardant API functions.  It is no longer possible to set breakpoints on calls to API functions, since  transitions are hidden inside the virtual machine.  This means that hacking the program will have to unwind the entire logic of the virtual machine, and it is an order of magnitude more complicated than just intercepting API functions. <br><br><h4>  findings </h4><br>  A number of recommendations for building reliable protection. <br><br>  1. It is necessary to use static API libraries in the program.  API library calls must be tightly integrated with the logic of the program being protected - this is a guarantee of creating persistent protection. <br>  2. It is better to use keys with asymmetric cryptography, since  for them there is no easy way to create tabular emulators. <br>  3. Application code and static API library must be protected from analysis using software protection tools, where there is no simple ability to intercept API function calls in the program.  For developers using Guardant technology, the ideal solution is Guardant Monolith. </div><p>Source: <a href="https://habr.com/ru/post/138641/">https://habr.com/ru/post/138641/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../138635/index.html">Why I choose D</a></li>
<li><a href="../138637/index.html">Radio Survey (Site Survey) Wi-Fi Coverage</a></li>
<li><a href="../138638/index.html">BlackBerry PlayBook OS 2.0 is now available.</a></li>
<li><a href="../138639/index.html">Change phone settings for time and location (no gps, operator towers)</a></li>
<li><a href="../138640/index.html">Shocking Objective-C for Java Programmers, Part Two</a></li>
<li><a href="../138644/index.html">Samsung CIS Forum 2012: Faster, Higher, WIDE!</a></li>
<li><a href="../138645/index.html">C February 23! Prizes and gifts to defenders of the fatherland</a></li>
<li><a href="../138646/index.html">In Britain, can close access to The Pirate Bay</a></li>
<li><a href="../138648/index.html">Ya.Subbotnik goes to Chelyabinsk</a></li>
<li><a href="../138650/index.html">Windows XP and Windows 7 received extended five-year support</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>