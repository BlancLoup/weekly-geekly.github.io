<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Continuous integration with Drone CI, Docker and Ansible</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Can you imagine that you will never again have to install dependencies and configure configurations manually on your continuous integration server? Do...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Continuous integration with Drone CI, Docker and Ansible</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://blog.maqpie.com//content/images/2017/03/---------_-------_1--1--1.png" alt="image"></p><br><p>  Can you imagine that you will never again have to install dependencies and configure configurations manually on your continuous integration server?  Do you believe that every step of your build can be truly isolated and work exclusively in Docker containers?  After all, would you like to try a tool that is in the <a href="https://github.com/search%3Futf8%3D%25E2%259C%2593%26q%3Dlanguage%253AGo%2Bstars%253A%253E9003%26type%3DRepositories%26ref%3Dsearchresults">top 20 of</a> all open source projects written in Golang and has 9k + asterisks on Github? </p><br><p>  In this article, we would like to talk about the magnificent Drone CI, which has already helped us simplify and improve our continuous integration.  We will share the details of the installation of the Drone CI and show with the example of a small project all the details of the use.  If you don‚Äôt like to read a lot and want to try it right away, there are links to Github repositories at the end of the article that will help you get started quickly. </p><br><a name="habracut"></a><br><p>  Before turning to the main topic, I would like to thank our readers for the large number of good reviews about the article on <a href="https://blog.maqpie.com/2017/02/22/fully-automated-development-environment-with-docker-compose/">docker-compose</a> and, of course, <a href="https://github.com/bradrydzewski">Brad Rydzewski</a> , the author of Drone CI, without whom this article would not exist.  This is a huge motivation for us to write on! </p><br><h3 id="nemnogo-istorii">  A bit of history </h3><br><p>  If you are already familiar with the term "Continuous Integration" (CI) and would like to know more, start with a <a href="https://martinfowler.com/articles/continuousIntegration.html">great article</a> from <a href="https://martinfowler.com/">Martin Fowler</a> .  Continuous integration has long been familiar to us, helping us to identify problems and fully automate the process of deploying the application, while saving a lot of time for the entire team. </p><br><p> I have been using CI servers for the past 7 years and, like many of us, started with <a href="https://jenkins.io/">Jenkins</a> , later <a href="https://www.jetbrains.com/teamcity/">TeamCity</a> , and then fell in love with <a href="https://travis-ci.org/">Travis CI</a> .  Each of these products has done a lot to develop the practice of continuous integration.  One of the ideas that makes me change tools from time to time is the possibility of fully automating any processes.  Jenkins and TeamCity have a very advanced user interface that allows you to configure continuous integration for any project, but it is rather difficult to automate.  Travis is a very good tool and still remains option number 1 for all my open-source initiatives, since <em>"Testing your open source project is 10000% free"</em> .  Travis was the first tool to configure continuous integration with a single <code>.travis.yml</code> file. </p><br><h3 id="pipeline-as-a-code">  Pipeline as a code </h3><br><p>  <em>"Pipeline as a code"</em> is a relatively new approach that allows you to configure the 'deployment pipeline' using code instead of manually setting up a running CI service.  Today, this concept is very popular, and I know at least five players in this segment: <a href="http://www.lambda.cd/">LambdaCD</a> , <a href="https://concourse.ci/">Concourse</a> , <a href="https://github.com/drone/drone">Drone</a> , <a href="https://www.gocd.io/">GoCD</a> and <a href="https://travis-ci.org/">Travis CI</a> .  This approach not only makes it easier to automate continuous integration and continuous deployment, but also allows you to test the infrastructure for deployment.  This concept made the world look different, but the most important thing is that it really allows you to use CI more efficiently and elegantly. </p><br><h3 id="kak-my-nepreryvno-integriruem">  How do we continuously integrate </h3><br><p>  Today, we have 6 people in our team, and our approach to continuous integration and deployment is quite simple.  We actively use Github, <a href="https://help.github.com/articles/about-pull-requests/">Pull Requests</a> , <a href="https://github.com/blog/2291-introducing-review-requests">Code Review</a> .  If you want to learn more about <em>"Continuous Delivery"</em> - pay attention to the book " <a href="https://www.amazon.com/gp/product/0321601912%3Fie%3DUTF8%26tag%3Dmartinfowlerc-20%26linkCode%3Das2%26camp%3D1789%26creative%3D9325%26creativeASIN%3D0321601912">Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation</a> " by Jez Humble and David Farley. </p><br><p>  The main steps of our continuous integration and continuous deployment: </p><br><ol><li>  Each team member works in a separate branch and creates a pull request as soon as the task is done. </li><li>  Each commit in Pull Request is checked by our CI server.  Run unit, integration, UI tests and lint.  The launch status is displayed in Github: <img src="https://blog.maqpie.com/content/images/2017/02/Screen-Shot-2017-02-27-at-19.21.11.png" alt="image"></li><li>  Each pull request is necessarily viewed by two team members.  One of them runs the code locally and checks all changes in the user interface.  If the test run was successful and the review was completed, the code is merged into the main branch (master) and the process of automatic deployment to the pre-production environment begins. </li><li>  Deployment consists of two steps.  First of all, we publish all our Docker containers on DockerHub, and then we run a small Ansible script that deploys the application on our servers. </li><li>  After a little manual testing, all changes are added to the "production" branch, and the automatic deployment process starts in the "production" environment. </li></ol><br><p>  The process has several drawbacks and will require some changes when our team becomes larger.  But today it suits us completely and, in our opinion, is ideal for small teams of up to 10 people.  The main disadvantages include: </p><br><ol><li>  Despite a large number of tests, some changes that fall into the master contain defects.  This blocks the deployment of other pull requests to eliminate defects. </li><li>  When our master branch is not in the "production ready" state, we have to deviate from the process and correct problems encountered by our clients right in the "production" branch, which adds the need to transfer these changes back to the master branch. </li><li>  We have not fully worked out the process of rollback changes, if something went wrong.  It consists in rolling back the "production" branch to the pre-deployment state.  If changes are required in the database - they are carried out manually at this stage. </li></ol><br><p>  We will deal with the elimination of these shortcomings as our team grows.  To date, we can already almost painlessly deploy our project several times a day.  We are not deploying the application as <a href="https://github.com/blog/1241-deploying-at-github">Github</a> yet, but the first steps have already been taken :) </p><br><h2 id="drone-ci">  Drone ci </h2><br><p>  After comparing different tools, our choice fell on the Drone CI and over the past three months we have completely switched to it.  Drone CI has 9003 stars on Github (March 15, 2017).  Drone CI is in the top <a href="https://github.com/search%3Futf8%3D%25E2%259C%2593%26q%3Dlanguage%253AGo%2Bstars%253A%253E8857%26type%3DRepositories%26ref%3Dsearchresults">20</a> apps written in Go on Github.  <a href="https://gitter.im/drone/drone">The channel</a> in Gitter never sleeps - there you can get answers to any questions. </p><br><h3 id="ustanovka">  Installation </h3><br><p>  Drone CI is a single Docker container of <a href="https://hub.docker.com/r/drone/drone/tags/">8 megabytes</a> .  This container contains two services: </p><br><ol><li>  Drone UI is a simple user interface and server that coordinates agents and displays build statuses. </li><li>  Drone Agent is another service where the build of your projects starts. </li></ol><br><p>  All data about past and current builds are stored in the database.  The default is <a href="https://www.sqlite.org/">Sqlite</a> , but it is possible to use other relational databases, such as PostgreSQL and MySQL.  Especially for this article, we have prepared a <a href="https://github.com/maqpie/deploy-drone">Github repository</a> that will help you install the Drone CI on your local environment or on your production environment in just a few minutes. </p><br><h3 id="nachalo-raboty">  Beginning of work </h3><br><p>  For a start, I would like to briefly introduce you to the principle of the Drone CI.  After you have installed and logged into the Drone CI using your Github account, the Drone automatically displays all your repositories.  The first step is to enable the repositories for which you want to configure continuous integration: </p><br><p><img src="https://blog.maqpie.com/content/images/2017/03/drone-enable.png" alt="image"></p><br><p>  At this work with the user interface is almost over.  Further it will be needed only to view the status of your builds. </p><br><p>  All configuration of deployment steps is carried out in one file: <code>drone.yml</code> .  This file is usually located in the root of your repository and fully describes everything that happens on your CI server.  In essence, <code>.drone.yml</code> is an arbitrary set of steps, each of which is launched in a separate, isolated Docker container.  At each commit, before running the steps from <code>.drone.yml</code> , Drone automatically clones our repository and adds it as a Docker volume for each step. </p><br><p>  To make it clearer, let's look at a simple configuration that runs tests, builds an image of a docker, publishes it on Dockerhub, and sends a simple notification to Slack when the build is finished. </p><br><pre> <code class="hljs mel">pipeline: run-tests: <span class="hljs-keyword"><span class="hljs-keyword">image</span></span>: node:<span class="hljs-number"><span class="hljs-number">6.3</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> commands: - cd ./api &amp;&amp; npm i --quiet - npm test publish-api-docker: <span class="hljs-keyword"><span class="hljs-keyword">image</span></span>: plugins/docker:<span class="hljs-number"><span class="hljs-number">1.12</span></span> username: ${DOCKER_USERNAME} password: ${DOCKER_PASSWORD} email: ${DOCKER_EMAIL} repo: anorsich/ds-api tags: - latest dockerfile: ./api/Dockerfile context: ./api/ slack-notification: <span class="hljs-keyword"><span class="hljs-keyword">image</span></span>: plugins/slack webhook: https:<span class="hljs-comment"><span class="hljs-comment">//hooks.slack.com/services/... username: drone-ci channel: andrew icon_emoji: ":rocket:"</span></span></code> </pre> <br><p>  It's all!  Now, with each commit to the repository, you will run tests, collect containers, and arrive at Slack. </p><br><h3 id="storonnie-zavisimosti-i-izolyaciya-shagov-sborki">  Third-party dependencies and isolation of assembly steps </h3><br><p>  Each step in Drone is performed in a separate Docker container, which allows you not to worry about installing and updating dependencies on server agents.  An important difference is that the dependencies for each step can be completely different.  In one step, you can run tests for Node.JS, and in the next one, quietly start building an application written on Go.  Transition to new versions of platforms is carried out only by changing the container version.  For example, we can easily add a new step that will run the tests and build the project on the latest version of Node.JS: </p><br><pre> <code class="hljs coffeescript"> run-tests-<span class="hljs-literal"><span class="hljs-literal">on</span></span>-latest-node: image: node:<span class="hljs-number"><span class="hljs-number">7.7</span></span> commands: - cd ./api &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">npm</span></span> i --quiet - <span class="hljs-built_in"><span class="hljs-built_in">npm</span></span> test</code> </pre> <br><p>  In fact, you only need to configure your CI server in one case - if a new version of the CI server itself is released.  Everything else is configured directly in the repository in <code>.drone.yml</code> , without a single click.  Install - and forget :) </p><br><p>  It is important to note that each step is completely isolated from the others, as it is performed in a separate container.  No more version conflicts! </p><br><p>  Another possibility that we do not use yet, but I would like to mention is the support of <a href="http://readme.drone.io/0.5/usage/build-matrix/">matrix assemblies</a> , which allows you to immediately test your code on various versions of platforms, databases, and so on. </p><br><h3 id="zapusk-po-usloviyu">  Run by condition </h3><br><p>  Sometimes there is a need to run a step in your build only under certain conditions.  By default, all steps are launched sequentially and, if one of the steps is broken, the next ones are not launched.  The main limitations that we use are: </p><br><ol><li>  Branch name (master, production) </li><li>  Build status (success, failure) </li><li>  Github event (pull_request, push, tag, deployment) </li></ol><br><p>  For example, we want to send a notification to Slack when the build was successful and when it broke.  To do this, we use the <code>when</code> section and add <code>status</code> : </p><br><pre> <code class="hljs perl"> slack-notification: image: plugins/slack ... <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>: status: [ success, failure ] event: [ <span class="hljs-keyword"><span class="hljs-keyword">push</span></span>, tag, deployment, pull_request ]</code> </pre> <br><p>  More information about the limitations can be found <a href="http://readme.drone.io/0.5/usage/conditional-build-steps/">here</a> . </p><br><p>  Another interesting feature worth mentioning is the ability not to start the build by adding a commit message to the messages: <code>[ci skip]</code> . </p><br><h3 id="plaginy">  Plugins </h3><br><p>  Plugins is a Drone CI approach for integration with third-party services, such as Amazon S3, Dockerhub, Slack.  A complete list of all plugins can be found <a href="http://plugins.drone.io/">here</a> .  Each plugin is a separate Docker container that performs a predefined task.  In our example above, we used two plugins: </p><br><ol><li>  Docker plugin ( <code>plugins/docker</code> ) - to build and publish Docker image on Dockerhub. </li><li>  Slack plugin ( <code>plugins/slack</code> ) - for sending notifications to Slack. </li></ol><br><p>  To date, plug-ins solve most common tasks, but not all.  To start any task specific to your project, you just need to wrap this task in a Docker image - and you can start using it in the Drone CI.  You have access to any programming languages ‚Äã‚Äãthat you can run in Docker.  Continuous integration for your special steps can be organized again with the help of Drone. </p><br><h3 id="konsolnaya-utilita">  Console utility </h3><br><p>  <a href="http://readme.drone.io/0.5/install/cli/">The console Drone utility</a> allows you to communicate with a remote server and perform various administrative tasks.  After installation, you need to connect to your remote server.  To do this, you need to export two variables in the terminal: </p><br><ol><li>  <code>export DRONE_SERVER=http://MY_DRONE_URL</code> - URL of your Drone server. </li><li>  <code>export DRONE_TOKEN=</code> - personal token that is created after you log in to the Drone UI.  You can find it on the following page: <code>https://MY_DRONE_URL/account</code> .  Just press <code>SHOW TOKEN</code> and copy. </li></ol><br><p>  Now the console utility should be configured. </p><br><h3 id="sekrety">  Secrets </h3><br><p>  Drone has very convenient tools for safe work with private information, such as passwords and ssh keys (in a word - secrets).  In the example above, we used the Docker plugin to publish the Docker image on Dockerhub, which needs your password and username. <br>  In <a href="https://github.com/maqpie/drone-starter">Github repositories</a> with an example of organization of continuous integration for Node.JS applications using Drone, we also use <a href="https://www.ansible.com/">Ansible</a> .  With it, we run Docker containers on a remote server.  To communicate with a remote server requires a separate key.  As you know, storing sensitive information in the Github repository is considered bad practice, which can be used by hackers to compromise your application.  In Drone CI, this problem is solved. </p><br><p>  First of all, let's see how we can add a password and username for Dockerhub (used by the <code>plugins/docker</code> plugin): </p><br><pre> <code class="hljs pgsql">drone <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> secret <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> DOCKER_USERNAME andrew drone <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> secret <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> DOCKER_PASSWORD <span class="hljs-keyword"><span class="hljs-keyword">password</span></span> drone <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> secret <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> DOCKER_EMAIL email</code> </pre> <br><p>  You can add secrets only to a specific repository or for all repositories within your Drone CI using <code>global</code> .  If you want to add a secret only for a specific repository, you need to specify its name and not use <code>global</code> : </p><br><pre> <code class="hljs cs">drone secret <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> maqpie/drone-starter DOCKER_USERNAME andrew</code> </pre> <br><p>  Once your secrets are added, you can use them using the simple <code>${DOCKER_USERNAME}</code> syntax directly in <code>.drone.yml</code> .  Here is a small example: </p><br><pre> <code class="hljs mel">publish-api-docker: <span class="hljs-keyword"><span class="hljs-keyword">image</span></span>: plugins/docker:<span class="hljs-number"><span class="hljs-number">1.12</span></span> username: ${DOCKER_USERNAME} password: ${DOCKER_PASSWORD} email: ${DOCKER_EMAIL}</code> </pre> <br><p>  As mentioned earlier, we also need an ssh key to work with a remote server.  The key can be added as follows: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">drone</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">global</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">secret</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SSH_KEY</span></span> @/<span class="hljs-keyword"><span class="hljs-keyword">Users</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">andrew</span></span>/.<span class="hljs-keyword"><span class="hljs-keyword">ssh</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">id_rsa</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">drone</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">demo</span></span></code> </pre> <br><h3 id="zaschita-i-podpis-sekretov">  Securing and signing secrets </h3><br><p>  To protect your secrets, Drone uses a simple signature mechanism for your <code>.drone.yml</code> .  With each change in <code>.drone.yml</code> , you need to re-sign it.  Drone checks the signature each time before starting the builds.  If the signature does not match, secrets will not be published and will not be available. </p><br><p>  To sign, use your personal authorization key, which you added when setting up the drone console utility: </p><br><pre> <code class="hljs matlab">drone <span class="hljs-built_in"><span class="hljs-built_in">sign</span></span> maqpie/drone-starter</code> </pre> <br><p>  When signing, you must specify the name of the repository in which <code>.drone.yml</code> is located.  As a result of this command, the <code>.drone.yml.sig</code> file should appear, which should be transferred to the repository. </p><br><p>  Important: Before signing your <code>.drone.yml</code> for your repository, make sure that this repository is included in the Drone UI - otherwise the signature file will not be created. </p><br><p>  Despite the good secrets protection mechanism in Drone, hackers still have several opportunities to access them.  For example, if you use a bash script in one of the steps, a hacker might use <code>curl</code> or another tool to access your password or ssh key.  Always apply general safety guidelines. </p><br><h3 id="servisy">  Services </h3><br><p>  Services in Drone UI allow you to run any container during the execution of your build process.  All services are on the same subnet as the process build containers.  This feature can be very useful for various types of integration testing.  Services are usually declared at the end of <code>.drone.yml</code> .  An example of starting a MySQL database is as follows: </p><br><pre> <code class="hljs pgsql">services: <span class="hljs-keyword"><span class="hljs-keyword">database</span></span>: image: mysql environment: - MYSQL_DATABASE=test - MYSQL_ALLOW_EMPTY_PASSWORD=yes</code> </pre> <br><p>  At the current stage, we do not use services; instead, we use a simpler approach for us using docker-compose. </p><br><h3 id="zapusk-testov-s-pomoschyu-docker-compose">  Running tests with docker-compose </h3><br><p>  In our previous <a href="https://blog.maqpie.com/2017/02/22/fully-automated-development-environment-with-docker-compose/">article,</a> we shared our love for <a href="https://docs.docker.com/compose/">docker-compose</a> .  I would like to dwell on how we run our tests in the Drone CI.  The step in <code>.drone.yml</code> looks like this: </p><br><pre> <code class="hljs cs"> run-tests-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>-compose: image: michalpodeszwa/docker-compose:latest volumes: - /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/run/docker.sock:/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/run/docker.sock commands: - ./bin/drone-run-tests.sh api-tests - ./bin/drone-run-tests.sh web-tests when: <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>: [pull_request]</code> </pre> <br><p>  <code>/bin/drone-run-tests.sh</code> runs tests with a small wrapper over docker-compose.  Before delving into our approach, I would like to talk about the trade-offs that we went to.  First of all, we refused to isolate the container in this line: </p><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">volumes:</span></span> - <span class="hljs-regexp"><span class="hljs-regexp">/var/run</span></span><span class="hljs-regexp"><span class="hljs-regexp">/docker.sock:/var</span></span><span class="hljs-regexp"><span class="hljs-regexp">/run/docker</span></span>.sock</code> </pre> <br><p>  In short, this line actually allows this container to run any command that the docker service can start, which allows you to run any command on the host, since the docker service is started as <code>root</code> user.  In more detail with all the consequences you can find in <a href="https://raesene.github.io/blog/2016/03/06/The-Dangers-Of-Docker.sock/">this</a> article.  This method is definitely not suitable for shared repositories. </p><br><p>  Why did we take such a risk?  There are several reasons: </p><br><ol><li>  We have a closed project, which deals with one team. </li><li>  Our Drone CI is running on a separate server, and even if someone wants to break it using the lack of isolation, we won‚Äôt lose anything.  Raising a new Drone CI will take us no more than 5 minutes, taking into account the DNS update. </li><li>  The most important reason is that we wanted to use the Docker cache effectively.  We make about 20-100 commits to the repository every day, and each of them runs our tests.  If we did not use the Docker cache, at each commit the containers would be rebuilt again, which takes a lot of time. </li></ol><br><p>  Now that you know about the drawbacks in our approach, let's take a look at the approach itself.  In fact, to run the tests, we simply use <code>docker-compose up --file docker-compose.drone-tests.yml</code> .  In the same way, tests are run on work environments.  The only problem we encountered when running tests through docker-compose is that the exit code of docker-compose was always 0. Drone, like any other CI, in this case believes that the build was successful and proceeds to the next step.  To remedy this situation, we wrote a small script that analyzes the exit codes of the containers after running the tests and, if at least one of the containers came out with a non-zero code, uses this code to exit.  The contents of the script <code>/bin/drone-run-tests.sh</code> , which you saw above in the test launch step, looks like this: </p><br><pre> <code class="hljs mel">#!/bin/sh # remove old containers docker-compose --<span class="hljs-keyword"><span class="hljs-keyword">file</span></span> docker-compose.drone-tests.yml rm -f # run tests docker-compose --<span class="hljs-keyword"><span class="hljs-keyword">file</span></span> docker-compose.drone-tests.yml up --build echo <span class="hljs-string"><span class="hljs-string">"Inspecting exited containers:"</span></span> docker-compose --<span class="hljs-keyword"><span class="hljs-keyword">file</span></span> docker-compose.drone-tests.yml ps docker-compose --<span class="hljs-keyword"><span class="hljs-keyword">file</span></span> docker-compose.drone-tests.yml ps -q | xargs docker inspect -f <span class="hljs-string"><span class="hljs-string">'{{ .State.ExitCode }}'</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> read code; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-string"><span class="hljs-string">"$code"</span></span> != <span class="hljs-string"><span class="hljs-string">"0"</span></span> ]; then exit $code fi done</code> </pre> <br><h3 id="ssylki-i-podskazki">  Links and Tips </h3><br><p>  As with any tool, there are some things in the Drone CI that are in development and do not always work as desired.  Fortunately, there were only a few of them: </p><br><ol><li>  Drone UI freezes if the process of your build displays too much information.  In all of our Docker files for Node.JS, we had to add <code>--quiet</code> when running <code>npm install</code> - less useless information was displayed.  I do not quite understand why this option is not used by default in npm. </li><li>  There are two versions of Drone 0.4 and 0.5.  The latter is now in active development, but fairly stable (we have not had any problems in 2 months). There are a lot of differences from 0.4.  When searching for different answers, we often found old answers that are no longer relevant. </li><li>  Documentation for version 0.5 is located at the following address: <a href="http://readme.drone.io/0.5/">http://readme.drone.io/0.5/</a> .  Documentation is probably the weakest side of Drone at the moment.  From myself I can say that the <a href="https://webpack.github.io/docs/usage.html">first version</a> (read the comments below) of the Webpack documentation was also not the best, but this did not prevent him from becoming the standard for most web projects. </li></ol><br><p>  If we managed to convince you to try Drone, below you can find a list of links that may be useful: </p><br><ol><li>  <a href="https://github.com/drone/drone">Drone github</a> </li><li>  <a href="https://github.com/drone-plugins">Drone plugins github</a> </li><li>  <a href="http://readme.drone.io/0.5/">Drone 0.5 documentation</a> </li><li>  <a href="https://gitter.im/drone/drone">Drone gitter</a> </li><li>  <a href="http://readme.drone.io/">Drone 0.4 documentation</a> - some parts of this documentation are not yet fully migrated to version 0.5. </li></ol><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Drone CI is a modern solution for continuous integration problems.  Using Drone, you will never set up your servers again, get a completely isolated environment for running your builds and be able to scale your CI server to infinity.  For two months of work, we completely fell in love with him. </p><br><p>  To help you get started using Drone CI, we have prepared two Github repositories: </p><br><ol><li> <a href="https://github.com/maqpie/deploy-drone">Deploy Drone</a> ‚Äî    Drone CI    production . </li><li> <a href="https://github.com/maqpie/drone-starter">Drone Starter</a> ‚Äî     Drone CI, Ansible, Docker     Node.js . </li></ol><br><p>     <a href="https://github.com/maqpie/drone-starter/issues/new"> </a> ! </p><br><p>  ,        51%,      49% ‚Äî       Github :) </p><br><p> ,          ! </p><br><p>   ,   <a href="https://blog.maqpie.com/2017/03/21/build-and-deploy-applications-using-drone-ci-docker-and-ansible/"></a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/324588/">https://habr.com/ru/post/324588/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324576/index.html">IBM Q - developing a quantum computer running through the cloud</a></li>
<li><a href="../324578/index.html">IntelliJ IDEA 2017.1 Review: Java 9, Kotlin 1.1, Spring, Gradle, JavaScript, Go, and more</a></li>
<li><a href="../324580/index.html">Asterisk queues, minor tricks</a></li>
<li><a href="../324582/index.html">Spring Games KIPS. Or master the budget for information security in $ 300.000</a></li>
<li><a href="../324586/index.html">Employees and social networks</a></li>
<li><a href="../324590/index.html">The history of the 3rd place on ML Boot Camp III</a></li>
<li><a href="../324592/index.html">Mahou updated to version 2.0</a></li>
<li><a href="../324594/index.html">JNI Receive and Connect to JVM in Delphi</a></li>
<li><a href="../324596/index.html">Statistics on property values ‚Äã‚Äã- visualization on the map</a></li>
<li><a href="../324598/index.html">Quadstor - performance and reliability</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>