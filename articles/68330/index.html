<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>OpenGL ES 2.0 to iPhone 3G S Basics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the most pleasant innovations in the iPhone 3GS is a faster and more powerful graphical platform with support for OpenGL ES 2.0 . Unfortunately...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>OpenGL ES 2.0 to iPhone 3G S Basics</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/e7b/e93/759/e7be9375982371ff1929b27d0e8df887.jpg" width="200" height="382">  One of the most pleasant innovations in the <strong>iPhone 3GS</strong> is a faster and more powerful graphical platform with support for <strong>OpenGL ES 2.0</strong> .  Unfortunately, there is little information from <strong>Apple</strong> about how to use the new opportunities.  For almost all <strong>APIs</strong> , they have excellent documentation with sample codes, but the problem is that in the case of <strong>OpenGL, the</strong> examples always left, to put it mildly, much to be desired. <br><br>  Moreover, for beginners working with <strong>OpenGL ES 2.0</strong> , neither the basic examples nor the <strong>Xcode</strong> template are offered.  To take advantage of advanced graphics capabilities, you will have to master them yourself.  You should not mistakenly assume that <strong>OpenGL ES 2.0</strong> is a slightly modified version of <strong>OpenGL ES 1.1</strong> with a couple of new features.  The differences between them are cardinal!  The conveyor with fixed functions has disappeared, and now to display a regular triangle on the screen, you will need to get a deeper acquaintance with the basics of computer graphics, including shaders. <a name="habracut"></a><br><br>  Given the complete lack of documentation, I decided to create the simplest application on the <strong>iPhone</strong> using <strong>OpenGL ES 2.0</strong> .  For users, it may well be the starting point for creating applications.  I considered rotating teapots and other constructions as options, but in the end I decided not to go into details on loading the model, but simply to update the <strong>OpenGL ES 1.1</strong> application, which is part of the <strong>XCode</strong> template.  The full summary code <a href="">can be downloaded here</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Nothing intriguing - just a rotating square.  However, this is enough to get acquainted with the basics of running <strong>OpenGL</strong> , creating shaders, and connecting them to the program and then using it.  Moreover, at the end we will consider the function that is impossible in <strong>OpenGL ES 1.1</strong> .  Ready? <br><br><h2>  <b>Initialization</b> </h2><br>  Initializing <strong>OpenGL is</strong> almost the same as <strong>OpenGL ES 1.1</strong> .  The only difference is that you need to report a new version of the <strong>API</strong> for <strong>ES 2.0</strong> . <br><br> <code>context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</code> <br> <br>  Everything else, including <strong>EAGLView</strong> and the creation of so-called <strong>back buffers</strong> , remains the same as before - I will not dwell on these points. <br><br>  Do not forget that during the initialization of <strong>OpenGL ES 2.0</strong> it will not be possible to call functions related to <strong>OpenGL ES 1.1</strong> .  Attempting to work with them will cause the program to crash, since these functions lack the correct settings.  Accordingly, if you want to take advantage of the <strong>3GS</strong> graphics, while ensuring compatibility with previous models, you will need to check the device type in the process, activating <strong>OpenGL ES 1.1</strong> or <strong>2.0</strong> ‚Äî you will have your own codes for each option. <br><br><h2>  <b>Shader creation</b> </h2><br>  <strong>OpenGL ES 1.1</strong> uses a pipeline with fixed functions for rendering polygons.  To visualize an object on the screen in <strong>OpenGL ES 2.0</strong> , it is necessary to register shaders - mini-programs created for a specific graphical platform.  Their task is to transform the input data (vertices and states) into an image on the screen.  Shaders are written in the language <strong>OpenGL Shader Language</strong> (abbreviated <strong>GLSL</strong> ), which does not make the slightest problem for those who are used to working with C. Of course, to use all its features, you will need to learn some of the details.  Below are presented only the basic concepts and their relationships. <br><br>  Shaders are of two types: vertex shaders are executed for each vertex, fragment shaders for each pixel.  Technically, the latter are performed for each fragment, which may not correspond to a pixel, for example, when smoothing.  So far we can safely assume that fragment shaders are executed for each pixel being rendered. <br><br>  The vertex shader computes the position of the vertex in a truncated space ( <strong>Clip Space</strong> ).  Optionally, other values ‚Äã‚Äãcan be calculated for later use by the fragment shader. <br><ul><li>  The vertex shader accepts two types of data - uniform and attributes.  Unified input are values ‚Äã‚Äãthat are set once from the main program and apply to all vertices processed by the vertex shader when a drawing is requested.  For example, the transformation of the <strong>world view view</strong> is a unified introductory one. </li></ul><br><ul><li>  The introductory attributes of a single drawing request may vary for each vertex.  The position, the normal, the color information are all introductory attributes. </li></ul><br>  At the output, the vertex shader provides two types of data: <br><ul><li>  The implied position in the variable " <strong>gl_Position</strong> ", i.e.  the position of the vertex in the truncated space (later transformed into the viewport <strong>space</strong> ). </li></ul><br><ul><li>  Varying results.  Variables defined by the varying attribute will be interpolated between the vertices, and the resulting values ‚Äã‚Äãwill be passed as input to the fragment shaders. </li></ul><br>  In a typical program, the vertex shader simply transforms the position of the vertex from the <strong>Model Space</strong> to the truncated space and transmits the vertex color for interpolation by a fragment shader. <br><br> <code>uniform mat4 u_mvpMatrix; <br> <br> attribute vec4 a_position; <br> attribute vec4 a_color; <br> <br> varying vec4 v_color; <br> <br> void main() <br> { <br> gl_Position = u_mvpMatrix * a_position; <br> v_color = a_color; <br> } <br></code> <br><br>  Fragment shaders calculate the color of the fragment (pixel).  The input parameters for them are varying variables generated by the vertex shader in addition to the variable " <strong>gl_Position</strong> ".  The color calculation can be limited to adding a constant to <strong>gl_Position</strong> , or it can be a search for a texture pixel by <strong>uv</strong> coordinates or a complex operation that takes the lighting conditions into account. <br><br>  Our fragmentary shader will be elementary: taking the color from the vertex shader, it applies it to this fragment. <br><br> <code>varying vec4 v_color; <br> <br> void main() <br> { <br> gl_FragColor = v_color; <br> } <br></code> <br><br>  It is quite possible that all this sounds vague and vague, but this is the beauty of shaders: no presets, rendering depends only on the desires of the user (and the capabilities of the hardware). <br><br><h2>  <b>Compiling Shaders</b> </h2><br>  We have several ready-made shaders.  How to make them work?  It will take several steps, the first of which will be the compilation and installation of links. <br><br>  In the process of work, it is necessary to load the source code text for each vertex together with fragment shaders, and then compile it using a couple of <strong>OpenGL</strong> references. <br><br> <code>const unsigned int shader = glCreateShader(type); <br> glShaderSource(shader, 1, (const GLchar**)&amp;source, NULL); <br> glCompileShader(shader); <br></code> <br><br>  As soon as the compilation for shaders is completed, you need to create a shader program, add the shaders themselves and link them together. <br><br> <code>m_shaderProgram = glCreateProgram(); <br> glAttachShader(m_shaderProgram, vertexShader); <br> glAttachShader(m_shaderProgram, fragmentShader); <br> glLinkProgram(m_shaderProgram); <br></code> <br><br>  Linking involves overriding the vertex shader data at the output to the intended result of the fragment shader. <br><br>  It is possible to diagnose errors when compiling and establishing links with displaying a message about the cause of the error. <br><br> <code>int success; <br> glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;success); <br> if (success == 0) <br> glGetShaderInfoLog(shader, sizeof(errorMsg), NULL, errorMsg); <br></code> <br><br>  If you don‚Äôt like the idea of ‚Äã‚Äãcompiling and linking programs in the process of work, I hasten to notice that this opinion is shared by many.  Ideally, this step should be performed offline, by analogy with compiling source code for the main program in <strong>Objective C.</strong>  Unfortunately, the priority for <strong>Apple</strong> is openness and the ability to change the format in the future, so we are forced to compile with the installation of the connection "on the job."  This is not just annoying, but, theoretically, implies a rather low speed with several shaders.  No one wants to lose extra seconds when launching the application, but for now you have to take it for granted in exchange for the ability to work with shaders on the <strong>iPhone</strong> . <br><br><h2>  <b>Binding</b> </h2><br>  We are almost ready to use shaders, but first we need to specify how to properly configure the input data.  The vertex shader expects a customized <strong>mvp</strong> matrix ( <strong>model-view-projection</strong> ), as well as a vertex data stream with positions and colors. <br><br>  To do this, we request the desired parameters from the shader program.  It returns a handle by which values ‚Äã‚Äãare set up immediately before the model is rendered. <br><br> <code>m_a_positionHandle = glGetAttribLocation(m_shaderProgram, "a_position"); <br> m_a_colorHandle = glGetAttribLocation(m_shaderProgram, "a_color"); <br> m_u_mvpHandle = glGetUniformLocation(m_shaderProgram, "u_mvpMatrix"); <br></code> <br><br><h2>  <b>Work with shaders</b> </h2><br>  And finally, with the help of our shaders, we can re-draw several polygons.  All you need is to run a shader program ... <br><br> <code>glUseProgram(m_shaderProgram); <br></code> <br><br>  ... and set up correct input, using the previously requested descriptors to enter the parameters: <br><br> <code>glVertexAttribPointer(m_a_positionHandle, 2, GL_FLOAT, GL_FALSE, 0, squareVertices); <br> glEnableVertexAttribArray(m_a_positionHandle); <br> glVertexAttribPointer(m_a_colorHandle, 4, GL_FLOAT, GL_FALSE, 0, squareColors); <br> glEnableVertexAttribArray(m_a_colorHandle); <br> glUniformMatrix4fv(m_u_mvpHandle, 1, GL_FALSE, (GLfloat*)&amp;mvp.m[0] ); <br></code> <br><br>  Now we simply call any of the rendering functions known from <strong>OpenGL ES 1.1</strong> (" <strong>glDrawArrays</strong> " or " <strong>glDrawElements</strong> "): <br><br> <code>glDrawArrays(GL_TRIANGLE_STRIP, 0, 4); <br></code> <br><br>  If everything went well, the correctly rendered model will appear on the screen.  In our case, this is just a square, which will become the basis for rendering your own models - with the necessary transformations, shaders and effects. <br><br><h2>  <b>And a small bonus at last</b> </h2><br>  I understand that it‚Äôs not too tempting to do all this just to get the same rotating square as in the <strong>OpenGL ES 1.1</strong> template.  Of course, this is a necessary and important first step, but still ... Therefore, to demonstrate how easy it is to create various effects with <strong>GLSL</strong> , I present a modified pixel shader. <br><br> <code>float odd = floor(mod(gl_FragCoord.y, 2.0)); <br> gl_FragColor = vec4(v_color.x, v_color.y, v_color.z, odd); <br></code> <br><br>  This version of the fragment shader checks whether the pixel is an even or an odd string, and renders the even rows as completely transparent, creating a strip effect on the screen.  To achieve a similar result in <strong>OpenGL ES 1.1</strong> was very problematic, and in version 2.0 it is just a couple of simple lines. <br><br>  Armed with sample code and ideas about shader functions, you can now create your own shaders and add interesting and unique visual effects to games. <br><br>  The source code for the lessons can be downloaded <a href="http://lookapp.ru/2009/08/30/iphone-sdk-tutorials91/"><b>here</b></a> . <br>  The text of the original article in English is <a href="http://www.mobileorchard.com/getting-started-with-opengl-es-20-on-the-iphone-3gs/"><b>here</b></a> . </div><p>Source: <a href="https://habr.com/ru/post/68330/">https://habr.com/ru/post/68330/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../68322/index.html">SQL and flags</a></li>
<li><a href="../68323/index.html">Vectorize the image with a genetic algorithm.</a></li>
<li><a href="../68324/index.html">Industry news for the week</a></li>
<li><a href="../68325/index.html">Dark Theme (Twilight) for Netbeans</a></li>
<li><a href="../68326/index.html">In the near future, two new navigation applications will become available for Android using DWA - ‚ÄúAugmented Reality for Driving‚Äù</a></li>
<li><a href="../68332/index.html">About ¬µTP in new versions of ¬µTorrent: what is it, how, why?</a></li>
<li><a href="../68334/index.html">Architectural tools in Visual Studio 2010</a></li>
<li><a href="../68335/index.html">ngxv8</a></li>
<li><a href="../68337/index.html">Creeping muck, or about problems with a single database of a single application</a></li>
<li><a href="../68338/index.html">Airsoft: A little bit about everything</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>