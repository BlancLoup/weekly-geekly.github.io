<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Regular expressions, a guide for beginners. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Regular expressions (PBs) are essentially a tiny programming language, embedded in Python and accessible using the re module. Using it, you specify th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Regular expressions, a guide for beginners. Part 1</h1><div class="post__text post__text-html js-mediator-article">  Regular expressions (PBs) are essentially a tiny programming language, embedded in Python and accessible using the re module.  Using it, you specify the rules for the set of possible strings that you want to check;  This set can contain English phrases, or email addresses, or TeX commands, or whatever.  With the help of PB, you can ask questions such as ‚ÄúDoes this string match the pattern?‚Äù, Or ‚ÄúDoes the pattern match somewhere with this string?‚Äù.  You can also use regular expressions to change a string or split it into various ways. <br><a name="habracut"></a><br>  Patterns of regular expressions are compiled in a series of byte-codes, which are then executed by the corresponding engine written in C. For advanced use, it may be important to pay attention to how the engine will execute this regular expression and write it so that it turns out byte-code that works faster.  Optimization is not covered in this document, as it requires you to have a good understanding of the internal parts of the engine. <br><br>  The language of regular expressions is relatively small and limited; therefore, not all possible tasks for processing strings can be done using regular expressions.  There are also tasks that <i>can be</i> done with regular expressions, but expressions are too complex.  In these cases, it may be better to write plain Python code, let it run slower than the developed regular expression, but will be more understandable. <br><br><h4>  Simple templates </h4><br>  We start by learning the simplest regular expressions.  Since regular expressions are used to work with strings, we start with the most common task - matching characters. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For a detailed explanation of the technical side of regular expressions (deterministic and non-deterministic finite automata) you can refer to almost any compiler writing tutorial. <br><br><h5>  Character Matching </h5><br>  Most letters and symbols correspond to themselves.  For example, the regular expression <code>test</code> will exactly match the string <code>test</code> (you can turn on case-insensitive mode, which will allow this regular expression to also match <code>Test</code> or <code>TEST</code> , but more on that later). <br><br>  There are exceptions to this rule;  some characters are special <i>metacharacters</i> , and do not correspond to themselves.  Instead, they indicate that some unusual thing must be found, or they affect other parts of the regular expression, repeating or changing their meaning.  Most of this tutorial is devoted to discussing various metacharacters and what they do. <br><br>  Here is a complete list of metacharacters;  their meanings will be discussed in the rest of this HOWTO. <br><br> <code>. ^ $ * + ? { [ ] \ | ( )</code> <br> <br>  The first metacharacters that we will look at are <code>[</code> and <code>]</code> .  They are used to define a character class, which is a set of characters with which you are looking for a match.  Characters can be listed individually, or as a range of characters indicated by the first and last characters, separated by a <code>'-'</code> .  For example, <code>[abc]</code> will match any of the characters <code>a, b</code> or <code>c</code> ;  this is the same as the expression <code>[ac]</code> , which uses a range to specify the same set of characters.  If you want to match only lowercase letters, PB will look like <code>[az]</code> . <br><br>  Metacharacters are not active inside classes.  For example, <code>[akm$]</code> will match any of the characters <code>'a', 'k', 'm'</code> or <code>'$'</code> .  The <code>'$'</code> character is usually a metacharacter (as seen from the list of characters above), but within the class of characters it loses its particular nature. <br><br>  In order to match characters outside this class, the symbol <code>'^'</code> added at the beginning of the class.  For example, the expression <code>[^5]</code> matches any character except '5'. <br><br>  Perhaps the most important is the backslash metacharacter <code>\</code> .  As in Python string literals, backslashes can be followed by various characters denoting different special sequences.  It is also used for escaping metacharacters so that they can be used in templates;  for example, if you need to find a match <code>[</code> or <code>\</code> , in order to deprive them of their special role of metacharacters, you must put a backslash in front of it: <code>\[</code> or <code>\\</code> . <br><br>  Some of the special sequences beginning with <code>'\'</code> represent predefined character sets that are often useful, such as a set of numbers, a set of letters, or sets of everything that is not spaces, tabs, etc. (whitespace).  The following predefined sequences are a subset of them.  For a complete list of sequences and extended class definitions for Unicode strings, see the last part of <a href="http://docs.python.org/library/re.html">Regular Expression Syntax</a> . <br><br> <code>\d</code> <br>  Matches any digit;  equivalent class <code>[0-9]</code> . <br> <code>\D</code> <br>  Matches any non-numeric character;  equivalent class <code>[^0-9]</code> . <br> <code>\s</code> <br>  Matches any whitespace character;  equivalent to <code>[ \t\n\r\f\v]</code> . <br> <code>\S</code> <br>  Matches any non-whitespace character;  the equivalent of <code>[^ \t\n\r\f\v]</code> . <br> <code>\w</code> <br>  Matches any letter or number;  the equivalent of <code>[a-zA-Z0-9_]</code> . <br> <code>\W</code> <br>  On the contrary;  equivalent to <code>[^a-zA-Z0-9_]</code> . <br><br>  These sequences can be included in a character class.  For example, [\ s,.] Is a character class that will match any whitespace character or comma or period. <br><br>  The last metacharacter in this section is the <code>'.'</code>  .  It matches all characters except the newline character, but there is an alternative mode ( <code>re.DOTALL</code> ) where this set will include it. <code>'.'</code>  often used where you want to match "any character". <br><br><h5>  Duplicate things </h5><br>  The ability to match different character sets is the first thing that regular expressions can do and which is not always possible to do with string methods.  However, if this were the only additional opportunity, they would not be so interesting.  Another possibility is that you can specify how many times the part of the regular expression should be repeated. <br><br>  The first metacharacter to repeat is <code>*</code> .  It indicates that the previous character can be matched zero or more times, instead of one comparison. <br><br>  For example, <code>ca*t</code> will correspond to <code>ct</code> (0 characters <code>a</code> ), cat (1 character <code>a</code> ), caaat (3 characters <code>a</code> ), and so on.  The regular expression engine has various internal constraints resulting from the size of the <code>int</code> type for C, which does not allow it to match more than 2 billion 'a' characters.  (I hope you do not need this). <br><br>  Repetitions such as <code>*</code> are called <i>greedy</i> ;  the engine will try to repeat it as many times as possible.  If the following parts of the template do not match, the engine will go back and try again with a few repetitions of the symbol. <br><br>  A step-by-step examination of an example will make the explanation clearer.  Let's look at the expression <code>a[bcd]*b</code> .  It corresponds to the letter <code>'a'</code> , zero or more characters from the class <code>[bcd]</code> , and finally, the final letter <code>'b'</code> .  Now imagine a mapping of this regular expression to the string <code>abcbd</code> .  Here's how the comparison happens in stages: <br><br>  1. <code>a</code> - 'a' matches a regular expression <br>  2. <code>abcbd</code> - the engine matches <code>[bcd]*</code> on as many characters as possible, that is, to the end of the line (since all characters correspond to the class in brackets []) <br>  3. Failure - the engine tries to match the last character in a regular expression - the letter <code>b</code> , but the current position is at the end of the line, where there are no characters, so that it fails. <br>  4. <code>abcb</code> - went back, reduced by one character mapping from <code>[bcd]*</code> <br>  5. Failing - trying to find <code>b</code> again, but only <code>d</code> at the end <br>  6. <code>abc</code> - go back again, now <code>[bcd]*</code> this is only bc <br>  7. <code>abcb</code> - look for the last character of the regular expression again - b.  Now he really is on the right position and we succeed <br><br>  So, the end of the RV was reached and a comparison with it was given by <code>abcb</code> .  This example showed how the engine first gets as far as it can and, if it does not find a match, comes back, working again and again with the rest of the regular expression.  He will do so until he gets a zero match for <code>[bcd]*</code> , and, if and then there is no match, he concludes that the string doesn‚Äôt fit the PB pattern at all. <br><br>  Another repetition metacharacter is <code>+</code> , repeating the comparison sequence <i>one</i> or more times.  Pay special attention to the difference between <code>*</code> and <code>+</code> .  <code>*</code> requires matching the required part <i>zero</i> or more times, that is, the repeatable may not be present at all, and <code>+</code> requires <i>at least one</i> occurrence.  For a similar example, <code>ca+t</code> will be matched by <code>cat</code> or, for example, <code>caaat</code> , but not <code>ct</code> . <br><br>  There are two more repeating specifiers.  Question mark <code>?</code>  that checks for a match zero or one time.  For example, <code>home-?brew</code> matches both <code>homebrew</code> and <code>home-brew</code> . <br><br>  The most complete repeating specifier is <code>{m,n}</code> , where <code>m</code> and <code>n</code> are integers.  This determinant means that there must be at least <code>m</code> and no more than <code>n</code> repetitions.  For example, <code>a/{1,3}b</code> corresponds to <code>a/b</code> , <code>a//b</code> and <code>a///b</code> .  This cannot be <code>ab</code> , a line in which there are no slashes, or <code>a////b</code> , in which there are four of them. <br><br>  You can not specify <code>m</code> or <code>n</code> , then the most reasonable value is assumed for the absent.  Lowering <code>m</code> means that the lower limit is 0, lowering <code>n</code> implies infinity to the upper limit, but, as mentioned above, the latter is limited by memory. <br><br>  Readers may already have noticed that all three other specifiers can be expressed through the latter.  <code>{0,}</code> is the same as <code>*</code> , {1,} is equivalent to <code>+</code> , and <code>{0,1}</code> can replace the sign <code>?</code>  . <br><br><h4>  Use regular expressions </h4><br>  Now that we‚Äôve covered a few simple regular expressions, how can we use them in Python?  The <code>re</code> module provides an interface for regular expressions, which allows you to compile regular expressions into objects and then perform mappings with them. <br><br><h5>  Compiling regular expressions </h5><br>  Regular expressions are compiled into template objects that have methods for various operations, such as finding an occurrence of a pattern or performing a string replacement. <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">import</font> <font color="#dc143c">re</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> p = <font color="#dc143c">re</font> .  <font color="#008000">compile</font> <font>(</font> <font color="#483d8b">'ab *'</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">print</font> p <br>  <font color="#66cc66">&lt;</font> _sre.  <font>SRE_Pattern</font> <font color="#008000">object</font> at 0x ... <font color="#66cc66">&gt;</font> </blockquote><br><br>  <code>re.compile()</code> also accepts optional arguments used to include various syntax features and variations: <br><br> <code>&gt;&gt;&gt; p = re.compile('ab*', re.IGNORECASE)</code> <br> <br>  The regular expression is passed to <code>re.compile()</code> as a string.  Regular expressions are treated as strings because they are not part of the Python language, and there is no special syntax for expressing them.  (There are applications that do not need regular expressions at all, so there is no need to override the language specification, including them.) Instead, there is a <code>re</code> module, which is a C wrapper on the module, like <code>socket</code> or <code>zlib</code> modules. <br><br>  Passing regular expressions as strings allows Python to be simpler, but it has one flaw, which is the topic of the next section. <br><br><h4>  Backslash disaster <br>  (Or backward plague :)) </h4><br><br>  As noted earlier, in regular expressions in order to designate a special form or to allow characters to lose their special role, the backslash character ( <code>'\'</code> ) is used.  This leads to a conflict with using the same character in Python string literals for the same purpose. <br><br>  Let's say you want to write a regular expression corresponding to <code>\section</code> , which you need to find in the LaTeX file.  To find out what to write in the program code, let's start with the line that needs to be compared.  Further, you should avoid any backslashes and other metacharacters by escaping them with a backslash, with the result that the <code>\\</code> part appears in the string.  Then, the resulting string to be passed to <code>re.compile ()</code> should be <code>\\section</code> .  However, in order to express it as a Python string literal, both backslashes must be escaped <i>again</i> , that is, the <code>"\\\\section"</code> . <br><br>  In short, to match backslash, you need to write <code>'\\\\'</code> as the regular expression string, because the regular expression must be <code>\\</code> , and each backslash must be translated to the usual string as <code>\\</code> . <br><br>  The solution is to use raw strings for regular expressions;  in string literals with the prefix <code>'r'</code> slashes are not processed in any way, so <code>r"\n"</code> is a string of two characters ('\' and 'n'), and "\ n" is one character of the new string.  Therefore, regular expressions will often be written using raw strings. <br><br><table><tbody><tr><td>  <b>Regular string</b> </td><td>  <b>Raw string</b> </td></tr><tr><td>  'ab *' </td><td>  r'ab * ' </td></tr><tr><td>  '\\\\ section' </td><td>  r '\\ section *' </td></tr><tr><td>  '\\ w + \\ s + \\ 1' </td><td>  r '\ w + \ s + \ 1' </td></tr></tbody></table><br><br><h4>  Performing mappings </h4><br>  After you have an object representing the compiled regular expression, what will you do with it?  Template objects have several methods and attributes.  Only the most important ones will be covered here;  For a complete list, see the <a href="http://docs.python.org/library/re.html"><code>re</code> documentation</a> . <br><br><table><tbody><tr><td>  <b>Method / Attribute</b> </td><td>  <b>purpose</b> </td></tr><tr><td>  match () </td><td>  Determine whether a regular expression match starts at the beginning of a string. </td></tr><tr><td>  search () </td><td>  Scan the entire string for all regular expression matches. </td></tr><tr><td>  findall () </td><td>  Find all substrings of regular expression matches and return them as a list </td></tr><tr><td>  finditer () </td><td>  Find all substrings of regular expression matches and return them as an iterator </td></tr></tbody></table><br><br>  If no matches were found, then <code>match()</code> and <code>search()</code> return <code>None</code> .  If the search is successful, a <code>MatchObject</code> instance is <code>MatchObject</code> containing information about the match: where it begins and ends, a matching substring, and so on. <br><br>  You can find out about it by experimenting with the <code>re</code> module.  You can also take a look at <code>Tools/scripts/redemo.py</code> , the demo program included with the Python distribution.  It allows you to enter regular expressions and strings, and displays if there is a match with the regular expression or not.  <code>redemo.py</code> can be quite useful for debugging complex regular expressions.  Phil Schwartz's <a href="http://kodos.sourceforge.net/">Kodos</a> is another interactive tool for developing and testing PB models. <br><br>  In this tutorial, we use the standard Python interpreter for the examples: <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">import</font> <font color="#dc143c">re</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> p = <font color="#dc143c">re</font> .  <font color="#008000">compile</font> <font>(</font> <font color="#483d8b">'[az] +'</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> p <br>  <font color="#66cc66">&lt;</font> _sre.  <font>SRE_Pattern</font> <font color="#008000">object</font> at 0x ... <font color="#66cc66">&gt;</font> </blockquote><br><br>  Now you can try to compare the strings for the regular expression <code>[az]+</code> .  An empty string will not correspond to it, because <code>+</code> means repeating "one or more" times.  <code>match()</code> in this case should return <code>None</code> , which we see: <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> p.  <font>match</font> <font>(</font> <font color="#483d8b">""</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">print</font> p.  <font>match</font> <font>(</font> <font color="#483d8b">""</font> <font>)</font> <br>  <font color="#008000">None</font> </blockquote><br><br>  Now try a string that should match the pattern: <code>'tempo'</code> .  In this case, <code>match()</code> will return a <code>MatchObject</code> , which you can place in some variable to use in the future: <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> m = p.  <font>match</font> <font>(</font> <font color="#483d8b">'tempo'</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">print</font> m <br>  <font color="#66cc66">&lt;</font> _sre.  <font>SRE_Match</font> <font color="#008000">object</font> at 0x ... <font color="#66cc66">&gt;</font> </blockquote><br><br>  You can now call <code>MatchObject</code> to get information about the corresponding rows.  There <code>MatchObject</code> also several methods and attributes for <code>MatchObject</code> , the most important of which are: <br><br><table><tbody><tr><td>  <b>Method / Attribute</b> </td><td>  <b>purpose</b> </td></tr><tr><td>  group () </td><td>  Return a string that matches a regular expression. </td></tr><tr><td>  start () </td><td>  Return the starting position of the match </td></tr><tr><td>  end () </td><td>  Return end position to match </td></tr><tr><td>  span () </td><td>  Return a tuple (start, end) of matching positions </td></tr></tbody></table><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> m.  <font>group</font> <font>(</font> <font>)</font> <br>  <font color="#483d8b">'tempo'</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> m.  <font>start</font> <font>(</font> <font>)</font> , m.  <font>end</font> <font>(</font> <font>)</font> <br>  <font>(</font> <font color="#ff4500">0</font> , <font color="#ff4500">5</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> m.  <font>span</font> <font>(</font> <font>)</font> <br>  <font>(</font> <font color="#ff4500">0</font> , <font color="#ff4500">5</font> <font>)</font> </blockquote><br><br>  Since the <code>match()</code> method only matches matches from the beginning of the string, <code>start()</code> will always return 0. However, the <code>search()</code> method scans the entire string, so the start for it is not necessarily zero: <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">print</font> p.  <font>match</font> <font>(</font> <font color="#483d8b">'::: message'</font> <font>)</font> <br>  <font color="#008000">None</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> m = p.  <font>search</font> <font>(</font> <font color="#483d8b">'::: message'</font> <font>)</font> <font color="#66cc66">;</font>  <font color="#ff7700">print</font> m <br>  <font color="#66cc66">&lt;</font> _sre.  <font>SRE_Match</font> <font color="#008000">object</font> at 0x ... <font color="#66cc66">&gt;</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> m.  <font>group</font> <font>(</font> <font>)</font> <br>  <font color="#483d8b">'message'</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> m.  <font>span</font> <font>(</font> <font>)</font> <br>  <font>(</font> <font color="#ff4500">4</font> , <font color="#ff4500">11</font> <font>)</font> </blockquote><br><br>  In real programs, the most common style is storing a <code>MatchObject</code> in a variable, and then checking for <code>None</code> .  Usually it looks like this: <br><br><blockquote>  p = <font color="#dc143c">re</font> .  <font color="#008000">compile</font> <font>(</font> ... <font>)</font> <br>  m = p.  <font>match</font> <font>(</font> <font color="#483d8b">'string goes here'</font> <font>)</font> <br>  <font color="#ff7700">if</font> m: <br>  <font color="#ff7700">print</font> <font color="#483d8b">'Match found:'</font> , m.  <font>group</font> <font>(</font> <font>)</font> <br>  <font color="#ff7700">else</font> : <br>  <font color="#ff7700">print</font> <font color="#483d8b">'No match'</font> </blockquote><br><br>  Two methods return all matches for the template.  <code>findall()</code> returns a list of matched substrings: <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> p = <font color="#dc143c">re</font> .  <font color="#008000">compile</font> <font>(</font> <font color="#483d8b">' <font color="#000099">\ d</font> +'</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> p.  <font>findall</font> <font>(</font> <font color="#483d8b">'12 drummers drumming, 11 pipers piping, 10 lords a-leaping '</font> <font>)</font> <br>  <font>[</font> <font color="#483d8b">'12'</font> , <font color="#483d8b">'11'</font> , <font color="#483d8b">'10'</font> <font>]</font> </blockquote><br><br>  The <code>findall()</code> method must create a complete list before it can be returned as a result.  The <code>finditer()</code> method returns a sequence of <code>MatchObject</code> instances as an iterator. <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> iterator = p.  <font>finditer</font> <font>(</font> <font color="#483d8b">'12 drummers drumming, 11 ... 10 ... '</font> <font>)</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> iterator <br>  <font color="#66cc66">&lt;</font> callable-iterator <font color="#008000">object</font> at 0x401833ac <font color="#66cc66">&gt;</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">for</font> match <font color="#ff7700">in</font> iterator: <br>  ... <font color="#ff7700">print</font> match.  <font>span</font> <font>(</font> <font>)</font> <br>  ... <br>  <font>(</font> <font color="#ff4500">0</font> , <font color="#ff4500">2</font> <font>)</font> <br>  <font>(</font> <font color="#ff4500">22</font> , <font color="#ff4500">24</font> <font>)</font> <br>  <font>(</font> <font color="#ff4500">29</font> , <font color="#ff4500">31</font> <font>)</font> </blockquote><br><br><h4>  Functions at the module level </h4><br>  You do not need to create template objects and call their methods;  the <code>re</code> module also provides the top-level functions <code>match(), search(), findall(), sub()</code> and so on.  These functions take the same arguments as for templates, with the string RV as the first argument and also return <code>None</code> or <code>MatchObject</code> . <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#ff7700">print</font> <font color="#dc143c">re</font> .  <font>match</font> <font>(</font> r <font color="#483d8b">'From <font color="#000099">\ s</font> +'</font> , <font color="#483d8b">'Fromage amk'</font> <font>)</font> <br>  <font color="#008000">None</font> <br>  <font color="#66cc66">&gt;&gt;&gt;</font> <font color="#dc143c">re</font> .  <font>match</font> <font>(</font> r <font color="#483d8b">'From <font color="#000099">\ s</font> +'</font> , <font color="#483d8b">'From amk Thu May 14 19:12:10 1998'</font> <font>)</font> <br>  <font color="#66cc66">&lt;</font> _sre.  <font>SRE_Match</font> <font color="#008000">object</font> at 0x ... <font color="#66cc66">&gt;</font> </blockquote><br><br>  These functions simply create a template object for you and call the appropriate method.  They also store the object in the cache, so future calls using the same regular expression will be faster. <br><br>  Should you use these functions or templates with methods?  It depends on how often the regular expression will be used and on your personal coding style.  If the regular expression is used in only one place in the code, then such functions are probably more convenient.  If the program contains many regular expressions, or reuses the same in several places, then it would be advisable to collect all the definitions in one place, in a section of code that precompiles all regular expressions.  As an example from the standard library, here is a piece from <code>xmllib.py</code> : <br><br> <code>ref = re.compile( ... ) <br> entityref = re.compile( ... ) <br> charref = re.compile( ... ) <br> starttagopen = re.compile( ... )</code> <br> <br>  I myself prefer to work with compiled objects, even for one-time use, but very few people will be the same purist in it, like me. <br><br><h4>  Compilation flags </h4><br>  Compilation flags allow you to change some aspects of how regular expressions work.  The flags are available in the module under two names: long, such as <code>IGNORECASE</code> and short, in single letter form, such as <code>I</code>  Multiple flags can be given in the form of binary OR;  for example <code>re.I | re.M</code>  <code>re.I | re.M</code> sets the flags I and M. <br><br>  <b>DOTALL, S</b> <br>  Matching is the same as <code>'.'</code>  , that is, with any character, but when this flag is included, a newline character is added to the consideration. <br><br>  <b>IGNORECASE, I</b> <br>  Matchless case mapping;  For example, <code>[AZ]</code> will also match lower case letters, so <code>Spam</code> will match <code>Spam, spam, spAM</code> and so on. <br><br>  <b>LOCALE, L</b> <br>  Makes <code>\w, \W, \b, \B</code> dependent on localization.  For example, if you work with text in French, and want to write <code>\w+</code> to find words, but <code>\w</code> searches only characters from the set <code>[A-Za-z]</code> and will not search for '√©' or '√ß'.  If the system is configured correctly and French is selected, '√©' will also be treated as a letter. <br><br>  <b>MULTILINE, M</b> <br>  (The metacharacters <code>^</code> and <code>$</code> have not yet been described; they will be introduced a little later, at the beginning of the second part of this manual. <br><br>  Usually <code>^</code> looks for a match only at the beginning of a line, and <code>$</code> only at the end immediately before the newline character (if any).  If this flag is specified, <code>^</code> comparison occurs in all lines, that is, at the beginning, and immediately after each new line character.  Similarly for <code>$</code> . <br><br>  <b>UNICODE, U</b> <br>  Makes <code>\w, \W, \b, \B, \d, \D, \s, \S</code> match the Unicode table. <br><br>  <b>VERBOSE, X</b> <br>  It includes verbose (detailed) regular expressions that can be organized more clearly and clearly.  If this flag is specified, spaces in the regular expression string are ignored, unless they are in the character class or preceded by an unscreened backslash;  This allows you to organize regular expressions in a clearer way.  This flag also allows placing regular comments with <code>'#'</code> , which will be ignored by the engine. <br><br>  An example of how RV becomes significantly easier to read: <br><br><blockquote>  charref = <font color="#dc143c">re</font> .  <font color="#008000">compile</font> <font>(</font> r <font color="#483d8b">"" "</font> <font color="#483d8b"><br></font>  <font color="#483d8b">&amp; [#] # Start of a numeric entity reference</font> <font color="#483d8b"><br></font>  <font color="#483d8b">(</font> <font color="#483d8b"><br></font>  <font color="#483d8b">0 [0-7] + # Octal form</font> <font color="#483d8b"><br></font>  <font color="#483d8b">|</font>  <font color="#483d8b">[0-9] + # Decimal form</font> <font color="#483d8b"><br></font>  <font color="#483d8b">|</font>  <font color="#483d8b">x [0-9a-fA-F] + # Hexadecimal form</font> <font color="#483d8b"><br></font>  <font color="#483d8b">)</font> <font color="#483d8b"><br></font>  <font color="#483d8b">;</font>  <font color="#483d8b"># Trailing semicolon</font> <font color="#483d8b"><br></font>  <font color="#483d8b">"" "</font> , <font color="#dc143c">re</font> . <font>VERBOSE</font> <font>)</font> </blockquote><br><br>  Without verbose, it would look like this: <br><br><blockquote>  charref = <font color="#dc143c">re</font> .  <font color="#008000">compile</font> <font>(</font> <font color="#483d8b">"&amp; # (0 [0-7] +"</font> <br>  <font color="#483d8b">"| [0-9] +"</font> <br>  <font color="#483d8b">"| x [0-9a-fA-F] +);"</font>  <font>)</font> </blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the above example, the automatic concatenation of Python string literals was used to break the RV into smaller parts, but, all the same, without explanation, this example is more difficult to understand than the version with </font></font><code>re.VERBOSE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this point we will complete our review. </font><font style="vertical-align: inherit;">I advise you to take some rest before the </font></font><a href="http://habrahabr.ru/blogs/python/115436/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">second half</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which contains a story about other metacharacters, methods for splitting, searching and replacing strings and a large number of examples of using regular expressions. </font></font><br><br> <a href="http://habrahabr.ru/blogs/python/115436/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continuation</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/115825/">https://habr.com/ru/post/115825/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../115817/index.html">IPad 2 Video Review (Part 1 and 2)</a></li>
<li><a href="../115818/index.html">Storing your photo archive</a></li>
<li><a href="../115820/index.html">Problems with DKIM in the class phpmailer</a></li>
<li><a href="../115821/index.html">Meet COBOL - Part 2</a></li>
<li><a href="../115824/index.html">On Astronomy Picture of the Day</a></li>
<li><a href="../115829/index.html">Why is Firefox 4 not giving up on Windows XP?</a></li>
<li><a href="../115831/index.html">Broadway - GTK + 3.0 backend for HTML5</a></li>
<li><a href="../115834/index.html">Decorating lists</a></li>
<li><a href="../115837/index.html">How much do you earn? (for web designers)</a></li>
<li><a href="../115838/index.html">U-Socket - a regular electrical outlet with USB</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>