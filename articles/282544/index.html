<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Garbage Collector & C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Manual memory management with C ++ is simultaneously one of the biggest advantages and disadvantages in the language. Indeed, this paradigm allows you...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Garbage Collector & C ++</h1><div class="post__text post__text-html js-mediator-article">  Manual memory management with C ++ is simultaneously one of the biggest advantages and disadvantages in the language.  Indeed, this paradigm allows you to create very productive programs, but it also gives rise to a lot of problems.  There are several ways to get rid of them.  I tried several and eventually came to the garbage collector.  In this article, I want to present not so much the implementation of the garbage collector in C ++, but the history of the idea and its use, what it is to use, and why it was finally abandoned. <br><br><a name="habracut"></a><br><br>  So, like most programmers, I have my own project, namely a two-dimensional game engine.  All "experiments" were made on it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Stage One: Memory Debugging </h1><br>  The most common problem with manual memory management is leaks.  To learn about them you need to monitor the memory.  That was my initial approach.  We follow the creation and deletion of objects, check after the end of the program that remains not deleted.  It is done very simply: we reload the <b>new</b> and <b>delete</b> operators so that they can take in the parameters the name of the source code file and the line where the allocation comes from, and store all the locations in one place.  For convenience, we declare a macro, which transmits the file name and string to the operator.  Accordingly, when deleting an object, we delete the record about the corresponding allocation. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt; class MemoryManager { struct AllocInfo { const char* source; int line; int size; void* data; }; static MemoryManager instance; std::vector&lt;AllocInfo&gt; allocations; public: static void RegAllocation(void* ptr, int size, const char* source, int line) { AllocInfo info; info.data = ptr; info.size = size; info.source = source; info.line = line; instance.allocations.push_back(info); } static void UnregAllocation(void* ptr) { for (std::vector&lt;AllocInfo&gt;::iterator it = instance.allocations.begin(); it != instance.allocations.end(); ++it) { if (it-&gt;data == ptr) { instance.allocations.erase(it); return; } } } static void PrintInfo() { for (std::vector&lt;AllocInfo&gt;::iterator it = instance.allocations.begin(); it != instance.allocations.end(); ++it) printf("0x%x: %i bytes at %s: %i", it-&gt;data, it-&gt;size, it-&gt;source, it-&gt;line); } }; MemoryManager MemoryManager::instance; void* operator new(size_t size, const char* location, int line) { void* res = ::operator new(size); MemoryManager::RegAllocation(res, size, location, line); return res; } void operator delete(void* allocMemory, const char* location, int line) { MemoryManager::UnregAllocation(allocMemory); } void operator delete(void* allocMemory) { MemoryManager::UnregAllocation(allocMemory); } #define mnew new(__FILE__, __LINE__) int main() { int* data = mnew int; MemoryManager::PrintInfo(); return 0; }</span></span></span></span></code> </pre> <br></div></div><br><br>  <b>pros</b> <br><ul><li>  simple and clear </li><li>  not expensive in terms of resources </li><li>  during the execution of the program, we know the amount of memory involved </li></ul><br><br>  <b>Minuses</b> <br><ul><li>  to learn about leaks, you need to complete the program </li><li>  not very informative exactly where allocations happen </li><li>  using overloaded operators slightly changes the syntax </li></ul><br><br><h1>  Stage Two: Smart Pointers </h1><br>  And the truth is, the most common solution to the problem of memory management is smart pointers.  You are sure to be asked about them at the interview.  The idea is simple: instead of the usual pointers, we use template classes that work as pointers, but have additional functionality for automatically releasing objects.  Together with the object, we store the reference counter, when assigning a value to a pointer, we increase the counter, when we destroy the pointer, we decrease it.  If the counter is zero, the object is not needed by anyone and it can be freed.  However, there is a small problem - if two objects refer to each other, they will never be released, since both have a reference count equal to one. <br><br><img src="https://habrastorage.org/files/427/ef2/54b/427ef254bd3e4cf3abaa79718f156059.gif"><br><br>  Weak pointers solve this obsession problem.  One of the pointers is made weak, and now the reference counters are zero and both objects can be freed. <br><br><img src="https://habrastorage.org/files/601/507/b70/601507b7085e4c3c89c251f8ab426d8b.gif"><br><br>  Well, let's think of a more complicated situation. <br><br><img src="https://habrastorage.org/files/33d/d2f/681/33dd2f68166a417ab5d9c1f3818cdad0.gif"><br><br>  This situation can also be resolved with weak / strong pointers, but will it be easier to manually control?  If the programmer does something wrong, the result will be the same: a leaked, un-freed object.  In fact, such situations are rare and, in general, such an approach greatly simplifies the work with memory. <br><br>  <b>pros</b> <br><ul><li>  does not require a lot of resources </li><li>  guarantees the correct release of objects with the right architecture </li><li>  easy to learn </li></ul><br><br>  <b>Minuses</b> <br><ul><li>  complicates the syntax </li><li>  in some situations it is difficult to properly build weak / strong pointers </li><li>  looped links lead to leaks </li></ul><br><br><h1>  Stage Three: Cycling </h1><br>  After testing smart pointers, I remained dissatisfied.  I just want to use the same type of smart pointer everywhere, and not to think about looped links.  Let him think about them.  But how to do that?  Imagine the situation: <br><br><img src="https://habrastorage.org/files/42c/01d/c0f/42c01dc0f64e4c37a0d3b29b0bc9588e.gif"><br><br>  It is necessary to somehow find out that the two lower objects are looped and can be deleted, because no one refers to them.  According to the picture, it is already easy to guess: if the links from the object do not lead to higher-level objects, then it can be released.  Top-level objects are, roughly speaking, those objects that begin application initialization.  For C ++, these are objects on the stack and static. <br><br><h1>  Stage Four: Garbage Collector </h1><br>  I think the attentive reader already understood that this is the scheme of the garbage collector, only the opposite.  The simplest collector works like this: going down the links from top-level objects, we mark everyone as relevant, after that we have the right to remove those that are not marked. <br><br><img src="https://habrastorage.org/files/a51/8f6/329/a518f6329c5a4c7d9cf5aa764b17e080.gif"><br><br>  For implementation, we need the same template pointer class as in the case of smart pointers.  Plus, you need the collector himself, who will monitor everything and do the actual garbage collection. <br><br><div class="spoiler">  <b class="spoiler_title">Slightly more code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt; #include &lt;map&gt; #include &lt;algorithm&gt; class IPtr; template&lt;typename T&gt; struct Destroyer { static void Destroy(void* obj) { (*(T*)(obj)).~T(); } }; class MemoryManager { public: struct ObjectInfo { void* object; size_t size; bool mark; const char* source; int line; std::vector&lt;IPtr*&gt; pointers; void(*destroy)(void*) = nullptr; }; private: static MemoryManager instance; std::map&lt;void*, ObjectInfo*&gt; objects; std::vector&lt;IPtr*&gt; pointers; size_t allocatedBytes = 0; bool currentMark = true; public: static void CollectGarbage(); protected: void MarkObject(ObjectInfo* info); friend void* operator new(size_t size, const char* source, int line); friend void operator delete(void* object, const char* source, int line); friend void operator delete(void* object); template&lt;typename T&gt; friend class Ptr; }; MemoryManager MemoryManager::instance; class IPtr { protected: void* object; MemoryManager::ObjectInfo* info; public: virtual ~IPtr() {} virtual bool IsRoot() const = 0; protected: void MarkInvalid() { object = nullptr; info = nullptr; } friend void operator delete(void* object); friend class MemoryManager; }; template&lt;typename T&gt; class Ptr: public IPtr { public: Ptr() { object = nullptr; info = nullptr; MemoryManager::instance.pointers.push_back(this); } Ptr(T* object) { this-&gt;object = object; auto fnd = MemoryManager::instance.objects.find(object); if (fnd != MemoryManager::instance.objects.end()) { info = fnd-&gt;second; info-&gt;pointers.push_back(this); if (!info-&gt;destroy) info-&gt;destroy = &amp;Destroyer&lt;T&gt;::Destroy; } MemoryManager::instance.pointers.push_back(this); } Ptr(const Ptr&lt;T&gt;&amp; other) { object = other.object; info = other.info; if (info) info-&gt;pointers.push_back(this); MemoryManager::instance.pointers.push_back(this); } ~Ptr() { if (info) { auto fnd = std::find(info-&gt;pointers.begin(), info-&gt;pointers.end(), this); if (fnd != info-&gt;pointers.end()) info-&gt;pointers.erase(fnd); } auto fnd = std::find(MemoryManager::instance.pointers.begin(), MemoryManager::instance.pointers.end(), this); if (fnd != MemoryManager::instance.pointers.end()) MemoryManager::instance.pointers.erase(fnd); } T* Get() const { return (T*)object; } bool IsValid() const { return object != nullptr; } bool IsRoot() const { return false; } operator bool() { return object != nullptr; } operator T*() { return (T*)object; } T* operator-&gt;() { return (T*)object; } T&amp; operator*() { return *(T*)object; } const T&amp; operator*() const { return *(T*)object; } Ptr&lt;T&gt;&amp; operator=(const Ptr&lt;T&gt;&amp; other) { if (info) { auto fnd = std::find(info-&gt;pointers.begin(), info-&gt;pointers.end(), this); if (fnd != info-&gt;pointers.end()) info-&gt;pointers.erase(fnd); } object = other.object; info = other.info; if (info) info-&gt;pointers.push_back(this); return *this; } Ptr&lt;T&gt;&amp; operator=(T* other) { if (info) { auto fnd = std::find(info-&gt;pointers.begin(), info-&gt;pointers.end(), this); if (fnd != info-&gt;pointers.end()) info-&gt;pointers.erase(fnd); } object = other; auto fnd = MemoryManager::instance.objects.find(object); if (fnd != MemoryManager::instance.objects.end()) { info = fnd-&gt;second; info-&gt;pointers.push_back(this); if (!info-&gt;destroy) info-&gt;destroy = &amp;Destroyer&lt;T&gt;::Destroy; } else info = nullptr; return *this; } }; template&lt;typename T&gt; class RootPtr: public Ptr&lt;T&gt; { public: RootPtr():Ptr() {} RootPtr(T* object):Ptr(object) {} RootPtr(const Ptr&lt;T&gt;&amp; other):Ptr(other) {} bool IsRoot() const { return true; } operator bool() { return object != nullptr; } operator T*() { return (T*)object; } T* operator-&gt;() { return (T*)object; } T&amp; operator*() { return *(T*)object; } const T&amp; operator*() const { return *(T*)object; } RootPtr&lt;T&gt;&amp; operator=(const Ptr&lt;T&gt;&amp; other) { Ptr&lt;T&gt;::operator=(other); return *this; } RootPtr&lt;T&gt;&amp; operator=(T* other) { Ptr&lt;T&gt;::operator=(other); return *this; } }; void* operator new(size_t size, const char* source, int line) { void* res = malloc(size); MemoryManager::ObjectInfo* objInfo = new MemoryManager::ObjectInfo(); objInfo-&gt;object = res; objInfo-&gt;size = size; objInfo-&gt;mark = MemoryManager::instance.currentMark; objInfo-&gt;source = source; objInfo-&gt;line = line; MemoryManager::instance.objects[res] = objInfo; MemoryManager::instance.allocatedBytes += size; return res; } void operator delete(void* data, const char* source, int line) { delete data; } void operator delete(void* data) { auto fnd = MemoryManager::instance.objects.find(data); if (fnd != MemoryManager::instance.objects.end()) { MemoryManager::instance.allocatedBytes -= fnd-&gt;second-&gt;size; for (auto ptr : fnd-&gt;second-&gt;pointers) ptr-&gt;MarkInvalid(); delete fnd-&gt;second; MemoryManager::instance.objects.erase(fnd); } free(data); } void MemoryManager::CollectGarbage() { instance.currentMark = !instance.currentMark; for (auto ptr : instance.pointers) { if (ptr-&gt;IsRoot()) { if (ptr-&gt;info) instance.MarkObject(ptr-&gt;info); } } std::vector&lt; std::map&lt;void*, ObjectInfo*&gt;::iterator &gt; freeObjects; for (auto obj = instance.objects.begin(); obj != instance.objects.end(); ++obj) { if (obj-&gt;second-&gt;mark != instance.currentMark) freeObjects.push_back(obj); } for (auto obj : freeObjects) { instance.allocatedBytes -= obj-&gt;second-&gt;size; obj-&gt;second-&gt;destroy(obj-&gt;first); free(obj-&gt;first); for (auto ptr : obj-&gt;second-&gt;pointers) ptr-&gt;MarkInvalid(); delete obj-&gt;second; instance.objects.erase(obj); } } void MemoryManager::MarkObject(ObjectInfo* info) { info-&gt;mark = MemoryManager::instance.currentMark; char* left = (char*)info-&gt;object; char* right = left + info-&gt;size; for (auto ptr : instance.pointers) { char* cptr = (char*)ptr; if (cptr &gt;= left &amp;&amp; cptr &lt; right) { if (ptr-&gt;info &amp;&amp; ptr-&gt;info-&gt;mark != MemoryManager::instance.currentMark) MarkObject(ptr-&gt;info); } } } #define mnew new(__FILE__, __LINE__) struct B; struct C; struct D; struct A { Ptr&lt;B&gt; pb; Ptr&lt;C&gt; pc; A() { printf("A()\n"); } ~A() { printf("~A()\n"); } }; struct B { Ptr&lt;C&gt; pc; B() { printf("B()\n"); } ~B() { printf("~B()\n"); } }; struct C { Ptr&lt;D&gt; pd; C() { printf("C()\n"); } ~C() { printf("~C()\n"); } }; struct D { Ptr&lt;C&gt; pc; D() { printf("D()\n"); } ~D() { printf("~D()\n"); } }; int main() { RootPtr&lt;A&gt; pa = mnew A; pa-&gt;pb = mnew B; pa-&gt;pc = mnew C; pa-&gt;pc-&gt;pd = mnew D; pa-&gt;pc-&gt;pd-&gt;pc = pa-&gt;pc; pa-&gt;pc = nullptr; MemoryManager::CollectGarbage(); return 0; }</span></span></span></span></code> </pre><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">How it works</b> <div class="spoiler_text">  For each created object, <b>ObjectInfo</b> meta-information is created and stored in the MemoryManager.  Each such object is created by an overloaded <b>new</b> operator.  <b>ObjectInfo</b> stores information about the size of an object, the place from which it was created, a list of pointers to it and a pointer to a function to call the destructor of this object. <br><br>  To work with objects, instead of the usual pointers, the template classes <b>Ptr</b> and <b>RootPtr are used</b> .  <b>RootPtr is</b> required to indicate top-level objects, since during the execution of the program it is impossible to know that the object was created on the stack or statically (correct me if I'm wrong).  When initializing or copying pointers, pointers are added and removed from the corresponding <b>ObjectInfo</b> . <br><br>  When you call garbage collection, the Boolean variable of the marker is reversed and the object marking cycle begins.  The cycle goes through high-level pointers, then recursively through their child pointers.  The child pointer is the one that is in the body of the object.  After that, all objects for which the marker does not match the current one are deleted. <br></div></div><br><br>  An attentive reader will surely notice one more thing: we pay for productivity with productivity.  We get all the typical cons of garbage collectors: excessive memory consumption and a lot of garbage collection.  It is on my project of the game engine that is a fatal minus, because every frame should take a few milliseconds and there is simply no time to stop everything and collect garbage.  However, there is a good point, this garbage collector is completely ours and we can do whatever we want! <br><br><h1>  Stage Five: Improvisation </h1><br>  The first thing that comes to mind is that we completely manage the moment of garbage collection.  It is not necessary to do this in the middle of the gameplay.  You can do this just when the greatest number of initializations and destruction of objects occur during loading levels.  When developing games, it is not customary to do a lot of allocations / destruction during an active game.  If at each shot to load and create an object bullet, no memory optimization will not save you.  Therefore, to do a long garbage collection between levels seems like a rather tenacious idea. <br><br>  The next idea is not to call garbage collection at all or to do it extremely rarely.  Objects are still deleted manually or by smart pointers, and the garbage collector can be used as a debugger and safety net.  In this embodiment, we get the performance equivalent to manual memory management and safety from leaks during garbage collection. <br><br>  Thus, we can use the collector in different ways.  With rapid prototyping, we are not concerned with performance, but we need stability, in which case we use automatic assembly.  In a normal situation, we try to manually manage the memory, and the collector tells us and insures.  And of course, you can simply turn it off and go to fully manual control. <br><br>  In addition, you can realize a little more "goodies".  Since we use template pointer classes, we can check them for correctness, that is, when deleting an object manually, make all references to it invalid.  And then in the right places to check them.  Another possible improvement is memory defragmentation.  At the stage of garbage collection, you can rearrange the actual objects in the memory to reduce the processor cache misses, which will undoubtedly give a performance boost. <br><br>  <b>pros</b> <br><ul><li>  protection against leaks and the use of incorrect pointers </li><li>  minimum costs when working in semi-automatic mode </li><li>  maximum convenience with fully automatic mode </li></ul><br><br>  <b>Minuses</b> <br><ul><li>  syntax complication </li><li>  understanding of the pattern of operation and use is necessary </li><li>  garbage collection process still takes considerable time </li></ul><br><br><h1>  Stage Six: Return to Top </h1><br>  In the end, the decision to refuse the collector was influenced by the specifics of my project.  The project is planned to be open source and it focuses primarily on usability.  The increasing complexity of the already complicated C ++ syntax with specific pointers and the addition of a garbage collector will undoubtedly have a bad impact on the project.  Just imagine the developer‚Äôs acquaintance with the new technology: he needs to learn a new API, and also with a tricky memory management model, especially since most C ++ programmers manage the memory well enough so that they can be managed manually. <br>  Finally, I made sure to return to the manual model when I decided to use scripts.  That they are needed for simplicity and convenience.  You make a prototype or a simple game - use scripts, save time and resources.  Flexibility and performance are needed - welcome to C ++.  That who will use With ++ actually the garbage collector is hardly required. <br><br>  That's how I returned to the beginning.  I hope my experience will be useful or at least interesting to other cyclists. <br><br>  PS The code from the article is not optimized and is provided only for understanding the work. </div><p>Source: <a href="https://habr.com/ru/post/282544/">https://habr.com/ru/post/282544/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282532/index.html">We are looking for free IPv4 in BGP full-view</a></li>
<li><a href="../282534/index.html">Yandex Font - Yandex Sans</a></li>
<li><a href="../282536/index.html">We create a game for the smallest on Phaser in Intel XDK</a></li>
<li><a href="../282538/index.html">Welcome to Moscow CocoaHeads Meetup April 29</a></li>
<li><a href="../282542/index.html">El-get, ELPA, MELPA and automatic package installation</a></li>
<li><a href="../282546/index.html">Intel ME. How to avoid the uprising of cars?</a></li>
<li><a href="../282548/index.html">How to test antivirus software</a></li>
<li><a href="../282550/index.html">About coordination of changes in time zones</a></li>
<li><a href="../282552/index.html">Apache Parquet performance</a></li>
<li><a href="../282556/index.html">Cocos creator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>