<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to make a distributed assembly system from Ninja?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 Recently, I thought about picking up another free build system, ‚ÄúIs it possible to take and write such a system yourself? It's simple - t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to make a distributed assembly system from Ninja?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/d4d/c70/29d/d4dc7029d50a4d579df3b0b58e4ba331.png" align="left">  Hi, Habr! <br><br>  Recently, I thought about picking up another free build system, ‚ÄúIs it possible to take and write such a system yourself?  It's simple - take the same Ninja, fasten the separation to preprocessing and compiling, and transfer files over the network to and fro.  How much easier? " <br><br>  Simple - not easy, how to make such a system yourself - I will tell you under the cut. <br><a name="habracut"></a><br><h3>  Stage 0. Task statement </h3><br>  <b>Disclaimer: The article is marked as a tutorial, but this is not a step-by-step tutorial, copying the code from which the finished product will turn out.</b>  <b>It is rather an instruction - how to plan and where to dig.</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      First, we define what the general algorithm of the work should be: <br><br><ul><li>  We read the graph of the assembly, isolate the compilation commands; </li><li>  We split the compilation into two stages, preprocessing and the actual code generation.  We mark the last one as possible for remote execution; </li><li>  We perform preprocessing, read the result into memory; </li><li>  We send the preprocessed file and the command to generate code to another host over the network; </li><li>  We execute the code generation command, read the object file and give it as a response over the network; </li><li>  The resulting object file is saved to disk and the compiler messages are output to the console. </li></ul><br>  It seems not so scary, right?  But just for the evening to write all this, perhaps, will not work.  At first we will write several prototypes, and the article tells about them: <br><br><ol><li>  Prototype 1. The program mimics the compiler, dividing the command into 2, and self-invoking the compiler. </li><li>  Prototype 2. To this, add the transfer command to compile over the network, without the file itself. </li><li>  Prototype 3. Go through the Ninja assembly graph, displaying potentially broken commands. </li></ol><br>  It is recommended to develop a prototype for a POSIX-compatible OS, if you do not use libraries. <br><br><h3>  Stage 1. We split the command line </h3><br>  For the prototype, let's stop on the GCC compiler (or Clang, there is not much difference), since  its command line is easier to disassemble. <br><br>  Let our program be called through the command "test -c hello.cpp -o hello.o".  We assume that after the key "-c" (compilation into object code) there is always the name of the input file, although this is not the case.  Also, for the time being, we‚Äôll stop only at work in a local directory. <br><br>  We will use <a href="https://www.opennet.ru/man.shtml%3Ftopic%3Dpopen%26category%3D3">the popen function</a> to start the process and get standard output.  The function allows you to open the process in the same way as we would open the file. <br><br>  Main.cpp file: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "InvocationRewriter.hpp" #include "LocalExecutor.hpp" int main(int argc, char ** argv) { StringVector args; for (int i = 1; i &lt; argc; ++i) args.emplace_back(argv[i]); InvocationRewriter rewriter; StringVector ppArgs, ccArgs; //      . if (!rewriter.SplitInvocation(args, ppArgs, ccArgs)) { std::cerr &lt;&lt; "Usage: -c &lt;filename&gt; -o &lt;filename&gt; \n"; return 1; } LocalExecutor localExecutor; const std::string cxxExecutable = "/usr/bin/g++"; // ,     GNU/Linux. const auto ppResult = localExecutor.Execute(cxxExecutable, ppArgs); if (!ppResult.m_result) { std::cerr &lt;&lt; ppResult.m_output; return 1; } const auto ccResult = localExecutor.Execute(cxxExecutable, ccArgs); if (!ccResult.m_result) { std::cerr &lt;&lt; ccResult.m_output; return 1; } //   ,    ,   . return 0; }</span></span></span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">InvocationRewriter.hpp code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using StringVector = std::vector&lt;std::string&gt;; class InvocationRewriter { public: bool SplitInvocation(const StringVector &amp; original, StringVector &amp; preprocessor, StringVector &amp; compilation) { //     -c  -o. //  ,   -c     ,     . const auto cIter = std::find(original.cbegin(), original.cend(), "-c"); const auto oIter = std::find(original.cbegin(), original.cend(), "-o"); if (cIter == original.cend() || oIter == original.cend()) return false; const auto cIndex = cIter - original.cbegin(); const auto oIndex = oIter - original.cbegin(); preprocessor = compilation = original; const std::string &amp; inputFilename = original[cIndex + 1]; preprocessor[oIndex + 1] = "pp_" + inputFilename; //     preprocessor[cIndex] = "-E"; //   - . compilation[cIndex + 1] = "pp_" + inputFilename; return true; } };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">LocalExecutor.hpp code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;stdio.h&gt; using StringVector = std::vector&lt;std::string&gt;; class LocalExecutor { public: ///   :   +  struct ExecutorResult { std::string m_output; bool m_result = false; ExecutorResult(const std::string &amp; output = "", bool result = false) : m_output(output), m_result(result) {} }; ///     popen. ExecutorResult Execute(const std::string &amp; executable, const StringVector &amp; args) { std::string cmd = executable; for (const auto &amp; arg : args) cmd += " " + arg; cmd += " 2&gt;&amp;1"; //  sterr  stdout. FILE * process = popen(cmd.c_str(), "r"); if (!process) return ExecutorResult("Failed to execute:" + cmd); ExecutorResult result; char buffer[1024]; while (fgets(buffer, sizeof(buffer)-1, process) != nullptr) result.m_output += std::string(buffer); result.m_result = pclose(process) == 0; return result; } };</span></span></span></span></code> </pre><br></div></div><br>  Well, now we have a small compiler emulator that jerks a real compiler.  We go further :) <br><br>  Further development of the prototype: <br><br><ul><li>  Include absolute file names; </li><li>  Use one of the libraries for working with processes: Boost.Process, QProcess, or Ninja Subprocess; </li><li>  Implement command sharing support for MSVC; </li><li>  Make the API to execute commands asynchronous, and execute in a separate thread. </li></ul><br><h3>  Stage 2. Network subsystem </h3><br>  Prototype network exchange will do on BSD Sockets ( <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D0%25BA%25D0%25B5%25D1%2582%25D1%258B_%25D0%2591%25D0%25B5%25D1%2580%25D0%25BA%25D0%25BB%25D0%25B8">Berkeley Sockets</a> ) <br><br>  A bit of theory: <br><br>  A socket is literally a ‚Äúhole‚Äù in which data can be written and read from it.  To connect to a remote server, the algorithm is as follows: <br><br><ul><li>  Create a socket of the desired type (TCP) using the function socket (); </li><li>  After creation, set the necessary flags, for example, non-blocking mode using setsockopt (); </li><li>  Get the address in the correct format for BSD sockets using getaddrinfo (); </li><li>  Connect to a TCP host using the connect () function, passing the prepared address there; </li><li>  Call read / send functions for reading and writing; </li><li>  After finishing the work, call close (). </li></ul><br>  The server works a little harder: <br><br><ul><li>  Create a socket using the function socket (); </li><li>  Set options; </li><li>  Call bind () to bind a socket to a specific address (obtained through getaddrinfo) </li><li>  We start listening on the port by calling listen (); </li><li>  Incoming connections are accepted by the accept () function - it returns us a new socket; </li><li>  With the received socket, perform read / write operations; </li><li>  Close the connection socket and the listening socket through close (). </li></ul><br>  We need a socket client and a socket server.  Let their interface look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">///   class IDataSocket { public: using Ptr = std::shared_ptr&lt;IDataSocket&gt;; ///    . Success- , TryAgain -      , Fail -   . enum class WriteState { Success, TryAgain, Fail }; enum class ReadState { Success, TryAgain, Fail }; public: virtual ~IDataSocket() = default; ///     virtual bool Connect () = 0; ///   virtual void Disconnect () = 0; ///    - ;   virtual bool IsConnected () const = 0; virtual bool IsPending() const = 0; ///       virtual ReadState Read(ByteArrayHolder &amp; buffer) = 0; ///    . virtual WriteState Write(const ByteArrayHolder &amp; buffer, size_t maxBytes = size_t(-1)) = 0; }; ///  "".      . class IDataListener { public: using Ptr = std::shared_ptr&lt;IDataListener&gt;; virtual ~IDataListener() = default; ///    virtual IDataSocket::Ptr GetPendingConnection() = 0; ///   : virtual bool StartListen() = 0; };</span></span></code> </pre><br>  I will not embed the implementation of this interface into the article, you can do it yourself or <a href="">peep here</a> . <br><br>  Suppose we have a socket ready, what will the client and server compiler look like? <br><br>  Server: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;TcpListener.h&gt; #include &lt;algorithm&gt; #include &lt;iostream&gt; #include "LocalExecutor.hpp" int main() { //    . TcpConnectionParams tcpParams; tcpParams.SetPoint(6666, "localhost"); //     6666; auto listener = TcpListener::Create(tcpParams); IDataSocket::Ptr connection; //    ; while((connection = listener-&gt;GetPendingConnection()) == nullptr) ; //      . connection-&gt;Connect(); ByteArrayHolder incomingBuffer; //!&lt;    std::vector&lt;uint8_t&gt;; while (connection-&gt;Read(incomingBuffer) == IDataSocket::ReadState::TryAgain) ; // ,       ,  . std::string args((const char*)(incomingBuffer.data()), incomingBuffer.size()); std::replace(args.begin(), args.end(), '\n', ' '); LocalExecutor localExecutor; const auto result = localExecutor.Execute("/usr/bin/g++", StringVector(1, args)); std::string stdOutput = result.m_output; if (stdOutput.empty()) stdOutput = "OK\n"; //   -    ,    OK. //       . ByteArrayHolder outgoingBuffer; std::copy(stdOutput.cbegin(), stdOutput.cend(), std::back_inserter(outgoingBuffer.ref())); connection-&gt;Write(outgoingBuffer); connection-&gt;Disconnect(); //    ,       . //     /      . return 0; }</span></span></span></span></code> </pre><br>  Customer: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;TcpSocket.h&gt; #include "InvocationRewriter.hpp" #include "LocalExecutor.hpp" int main(int argc, char ** argv) { StringVector args; for (int i = 1; i &lt; argc; ++i) args.emplace_back(argv[i]); InvocationRewriter rewriter; StringVector ppArgs, ccArgs; //      . if (!rewriter.SplitInvocation(args, ppArgs, ccArgs)) { std::cerr &lt;&lt; "Usage: -c &lt;filename&gt; -o &lt;filename&gt; \n"; return 1; } LocalExecutor localExecutor; const std::string cxxExecutable = "/usr/bin/g++"; // ,     GNU/Linux. const auto ppResult = localExecutor.Execute(cxxExecutable, ppArgs); if (!ppResult.m_result) { std::cerr &lt;&lt; ppResult.m_output; return 1; } //      6666 TcpConnectionParams tcpParams; tcpParams.SetPoint(6666, "localhost"); auto connection = TcpSocket::Create(tcpParams); connection-&gt;Connect(); ByteArrayHolder outgoingBuffer; for (auto arg : ccArgs) { arg += " "; //       . std::copy(arg.cbegin(), arg.cend(), std::back_inserter(outgoingBuffer.ref())); } connection-&gt;Write(outgoingBuffer); ByteArrayHolder incomingBuffer; while (connection-&gt;Read(incomingBuffer) == IDataSocket::ReadState::TryAgain) ; std::string response((const char*)(incomingBuffer.data()), incomingBuffer.size()); if (response != "OK\n") { std::cerr &lt;&lt; response; return 1; } return 0; }</span></span></span></span></code> </pre><br>  Yes, not all sources are shown, for example, TcpConnectionParams or ByteArrayHolder, but these are fairly primitive structures. <br><br>  After debugging this prototype, we have a small service that can compile preprocessed files locally (with some assumptions, for example, that the working directory of the client and server are the same). <br><br>  Further development of the prototype: <br><br><ul><li>  I strongly recommend using one of the existing network libraries - Boost.Asio, QTcpSocket (QtNetwork), and also think about serialization using Protobuf or other similar ones. </li><li>  Implement file transfer over the network.  Most likely, you will have to break them into fragments, but will depend on the library you choose. </li><li>  You need to think about the asynchronous message sending and receiving API.  In addition, it is desirable to make it abstract and not bound to sockets in general. </li></ul><br><h3>  Stage 3. Integration with Ninja </h3><br>  To get started, you need to familiarize yourself with the principles of Ninja.  It is assumed that you have already collected any projects with its help and roughly imagine what build.ninja looks like. <br>  Used concepts: <br><br><ul><li>  A node (Node) is just a file.  Input (source), output (object files) are all nodes or vertices of the graph. </li><li>  A rule (Rule) is essentially just a command with a pattern of arguments.  For example, a call to gcc is a rule, and its arguments are $ FLAGS $ INCLUDES $ DEFINES and some other general arguments. </li><li>  Edge.  It was a little surprising for me, but the edge connects not two nodes, but several input nodes and one output node, through the Rule.  The entire assembly system is based on what consistently bypasses the graph, executing commands for the edges.  Once all the edges are processed, the project is assembled. </li><li>  A state is a container with all of the above, which the build system uses. </li></ul><br>  How it looks about, if you draw dependencies: <br><br><img src="https://habrastorage.org/files/d89/468/51b/d8946851b3f145d48c8e8257bd21d8cb.png"><br><br>  This shows the assembly graph for two translation units that are assembled into an application. <br><br>  As we can see, in order to make our changes to the build system, we need to rewrite the State, breaking Edges into two in the right places and adding new nodes (preprocessed files). <br>  Suppose we already have ninja sources, we compile them, and everything works in assembled form. <br>  Add the following code snippet to ninja.cc: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Limit number of rebuilds, to prevent infinite loops. const int kCycleLimit = 100; for (int cycle = 1; cycle &lt;= kCycleLimit; ++cycle) { NinjaMain ninja(ninja_command, config); ManifestParser parser(&amp;ninja.state_, &amp;ninja.disk_interface_, options.dupe_edges_should_err ? kDupeEdgeActionError : kDupeEdgeActionWarn); string err; if (!parser.Load(options.input_file, &amp;err)) { Error("%s", err.c_str()); return 1; } //    ,   : RewriteStateRules(&amp;ninja.state_); //   </span></span></code> </pre><br>  The function RewriteStateRules itself can be carried in a separate file, or declared here in ninja.cc as: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"InvocationRewriter.hpp"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ,     Ninja. struct RuleReplace { const Rule* pp; const Rule* cc; std::string toolId; RuleReplace() = default; RuleReplace(const Rule* pp_, const Rule* cc_, std::string id) : pp(pp_), cc(cc_), toolId(id) {} }; void RewriteStateRules(State *state) { //   , ..    ,      . const auto rules = state-&gt;bindings_.GetRules(); std::map&lt;const Rule*, RuleReplace&gt; ruleReplacement; InvocationRewriter rewriter; //      for (const auto &amp; ruleIt : rules) { const Rule * rule = ruleIt.second; const EvalString* command = rule-&gt;GetBinding("command"); if (!command) continue; //     rewriter-. std::vector&lt;std::string&gt; originalRule; for (const auto &amp; strPair : command-&gt;parsed_) { std::string str = strPair.first; if (strPair.second == EvalString::SPECIAL) str = '$' + str; originalRule.push_back(str); } //   : std::vector&lt;std::string&gt; preprocessRule, compileRule; if (rewriter.SplitInvocation(originalRule, preprocessRule, compileRule)) { //  2  rule - rulePP  ruleCC,   bindings_   . //     ruleReplacement (ruleReplacement[rule] = ...) } } const auto paths = state-&gt;paths_; std::set&lt;Edge*&gt; erasedEdges; //      for (const auto &amp; iter : paths) { Node* node = iter.second; Edge* in_egde = node-&gt;in_edge(); if (!in_egde) continue; //       . //      ,  : const Rule * in_rule = &amp;(in_egde-&gt;rule()); auto replacementIt = ruleReplacement.find(in_rule); if (replacementIt != ruleReplacement.end()) { RuleReplace replacement = replacementIt-&gt;second; const std::string objectPath = node-&gt;path(); const std::string sourcePath = in_egde-&gt;inputs_[0]-&gt;path(); const std::string ppPath = sourcePath + ".pp"; //       . Node *pp_node = state-&gt;GetNode(ppPath, node-&gt;slash_bits()); //     Edge* edge_pp = state-&gt;AddEdge(replacement.pp); Edge* edge_cc = state-&gt;AddEdge(replacement.cc); // ...   ... //       edge_pp; //      edge_cc //     pp_node. //  ,   edge_cc,     - // ,  : edge_cc-&gt;is_remote_ = true; //   ,   . in_egde-&gt;outputs_.clear(); in_egde-&gt;inputs_.clear(); in_egde-&gt;env_ = nullptr; erasedEdges.insert(in_egde); } } //   . vector&lt;Edge*&gt; newEdges; for (auto * edge : state-&gt;edges_) { if (erasedEdges.find(edge) == erasedEdges.end()) newEdges.push_back(edge); } state-&gt;edges_ = newEdges; }</span></span></span></span></code> </pre><br>  Some tedious fragments are cut, the full code <a href="">can be viewed here</a> . <br><br>  Prototype revision: <br><br><ul><li>  Most likely, the first version of InvocationRewriter does not work, you will need to take into account many things - for example, the fact that the compilation argument "-c" can be set to "-c", well, I am not talking about the fact that it does not necessarily precede the source file. </li><li>  There may be many additional flags that mark some files, so not all that ‚Äúnot a flag‚Äù is a file. </li><li>  After creating a split graph, if it is successfully assembled in two phases ‚Äúpreprocessing and compilation‚Äù, it will be necessary to integrate the remote execution over the network with our network layer.  The actual build cycle in Ninja is in build.cc in the Builder :: Build function.  It can be added by analogy with <br>  ‚ÄúIf (failures_allowed &amp;&amp; command_runner _-&gt; CanRunMore ())‚Äù and ‚Äúif (pending_commands)‚Äù have their stages for a distributed assembly. </li></ul><br><h3>  Stage X. What's next? </h3><br>  After successfully creating a prototype, you need to move in small steps to create a product: <br><br><ul><li>  Configuration of all modules - both the network subsystem and the InvocationRewriter; </li><li>  Support for any combination of options under different compilers; </li><li>  Compression support for file transfer; </li><li>  Various diagnostics in the form of logs; </li><li>  Writing a coordinator who will be able to maintain connections to multiple build servers; </li><li>  Writing a balancer that will take into account the fact that several clients use the servers at once (and not overload them beyond measure); </li><li>  Write integration with other build systems, not just Ninja. </li></ul><br>  In general, guys, I stopped somewhere at this stage;  made the opensource project Wuild ( <a href="https://github.com/mapron/Wuild">source code here</a> ), the Apache license, which implements all these things.  It took about 150 hours of free time to write (if anyone decides to repeat my path).  I highly recommend using the existing free libraries to the maximum in order to concentrate on business logic and not to debug the network or launch processes. <br><br>  What Wuild can do: <br><br><ul><li>  Distributed build with cross-compilation (Clang) for Win, Mac, Linux; </li><li>  Integration with Ninja and Make. </li></ul><br>  Yes, in general, and all;  the project is in a state between alpha and beta (stability is, features are not: D).  I do not post benchmarks (I do not want to advertise), but, in comparison with one of the similar products, I was more than satisfied with the speed. <br><br>  The article is more of an educational nature, and the project is a cautionary one (how not to do it, in the sense of the NIH syndrome, make fewer bicycles). <br><br>  Who wants - fork, do pull-requests, use for any scary purposes! </div><p>Source: <a href="https://habr.com/ru/post/321660/">https://habr.com/ru/post/321660/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321648/index.html">J-bird</a></li>
<li><a href="../321652/index.html">UNIX-like systems contain a bunch of crutches. The collapse of the "UNIX philosophy"</a></li>
<li><a href="../321654/index.html">C ++ Russia: interview with speakers</a></li>
<li><a href="../321656/index.html">The basics of Juniper Contrail, and how to put it in the lab</a></li>
<li><a href="../321658/index.html">The digest of interesting materials for the mobile developer # 190 (February 5-12)</a></li>
<li><a href="../321662/index.html">Pygest # 3. Releases, articles, interesting projects from the world of Python [January 30, 2017 - February 13, 2017]</a></li>
<li><a href="../321664/index.html">Release Management Process - for post-project support or product development</a></li>
<li><a href="../321666/index.html">Why I work only remotely</a></li>
<li><a href="../321668/index.html">Versioning build artifacts in Gradle using git tag, brunch and commit names</a></li>
<li><a href="../321670/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ249 (February 6 - 12, 2017)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>