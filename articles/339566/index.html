<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development of browser-based online games without frameworks and engines</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 This post will describe the process of developing online games in pure javascript and WebGL (without frameworks and engines). Some algori...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development of browser-based online games without frameworks and engines</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/e1/e0/59e1e0700cdf7570192875.png"></div><br>  Hi, Habr! <br><br>  This post will describe the process of developing online games in pure javascript and WebGL (without frameworks and engines).  Some algorithms, rendering techniques, artificial intelligence of bots and network game will be considered.  The project is completely open source, at the end of the post there will be a link to the repository. <br><a name="habracut"></a><br>  Immediately gameplay video: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/acMu20MkGjE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Here plays a bot called Lyaguha and other bots</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Introduction </h3><br>  The game is a 2D shooting game "top view".  The game contains the following elements: land;  walls that limit visibility;  lava, on which you can not walk;  bridges over lava;  6 types of weapons and 5 types of power;  characters, one of which is controlled by the player. <br><br>  The gameplay, as in Quake III, is an ordinary deathmatch, that is, you need to kill more enemies than they do.  There are bots in the game, but as soon as a live player enters it, one of the bots is removed (the one who recently died and did not have time to respawn).  A set of weapons is traditional for such games.  It is worth noting only that the rail infinite damage, and the rocket launcher shoots "smart" missiles - they are undermined automatically when they fly at a minimum distance from the enemy. <br><br>  The client is written in javascript using WebGL, and the server is in node.js.  This project uses the following libraries: <br><br><ul><li>  <a href="https://github.com/toji/game-shim">game-shim.js</a> - for requestAnimationFrame, fullscreen and mouselock </li><li>  <a href="https://github.com/toji/gl-matrix">gl-matrix.js</a> - matrix library </li><li>  <a href="">howler.js</a> - sound library </li><li>  bootstrap and jquery especially for the page with the input of the nickname, have not been used anywhere else </li><li>  the server uses express, ws (WebSocket) and others </li></ul><br>  We now turn directly to the description of the algorithms used. <br>  The level (map) is rendered with the help of the so-called levelmapy - this is a regular texture, each channel of which contains a certain mask (these masks will be discussed below).  In this game, the maximum card size is 256x256, where 1x1 corresponds to the size of the characters.  This card is designed for about 110 players.  For simplicity, consider the 64x64 map.  But first you need to generate it. <br><br><h3>  Level generation </h3><br>  To generate the map, the usual <a href="https://habrahabr.ru/post/142592/">Perlin noise is</a> used, plus some transformations and filtering: <br><br><img src="https://habrastorage.org/webt/59/d9/30/59d93041f3c42813809737.png"><br><br>  <i>Where perlinNoise () is Perlin noise, ranging from 0 to 1,</i> <i><br></i>  <i>abs (x) is the modulus of a number</i> <i><br></i>  <i>clamp (x) - if x &lt;0, then x = 0. If x&gt; 1, then x = 1,</i> <i><br></i>  <i>norm (-0.5, 2) - normalizes noise in this range.</i> <br><br>  Such a sequence of transformations at the output gives the required topology of the map: it consists of rooms and corridors, 2-3 pixels wide. <br><br>  The resulting texture is the mask of the earth (black is the earth, white is the wall). <br>  Next, a lava river is generated in a separate buffer.  For this, a polyline is generated (if inflows are needed, then several polylinea) and each segment of the polyline is ‚Äúdrawn‚Äù into the buffer using <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2591%25D1%2580%25D0%25B5%25D0%25B7%25D0%25B5%25D0%25BD%25D1%2585%25D1%258D%25D0%25BC%25D0%25B0">the Bresenham algorithm</a> .  Then this buffer with segments is blurred according to Gauss.  The blur radius is selected based on the required width of the river.  A two pass algorithm is used to optimize the blur.  The blur function will come in handy more than once.  Blur the buffer with lava is needed in order to give the river width, as well as in the future for rendering. <br><br>  In the mask of the earth, where the lava passes and in close proximity to it, the walls are removed: <br><br><img src="https://habrastorage.org/webt/59/d9/e4/59d9e44678929935638973.png"><br>  <i>From left to right: the ground mask from the previous stage;</i>  <i>lava mask;</i>  <i>clearing the walls of the lava;</i>  <i>final result</i> <br><br>  Before you get this very final result, several transformations are performed above the earth's mask: filtering small details (walls and aisles one pixel wide are undesirable);  Filling of isolated areas (in the process of generation, zones can be formed that are completely isolated by walls from all sides, it is better to fill them with white so that players do not spawn there);  At the edges, a layer of walls 5 pixels wide is added to prevent players from escaping from the map. <br><br><div class="spoiler">  <b class="spoiler_title">And so, for example, looks like a map of 256x256</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d9/ee/59d9ee1e60894435820170.png"></div><br></div></div><br>  Well, in the end bridges are generated.  Everything is simple: random points on the lava are chosen so that the bridges are not too close to each other or too far, and they are oriented perpendicular to the lava flow at this point (naturally, bridges are not baked in the level map, they are stored simply as an array of objects). <br><br>  In addition to the earth and lava masks, two additional auxiliary masks are generated: a mask for textures (since two different textures are superimposed on the ground in the game, this mask sets the mixing coefficients of these textures) and the mask of static shadows from the walls.  The texture mask is the same Perlin noise. <br>  Before you bake the mask of the earth in the levelmap it should be blurred according to Gauss.  This is needed to create smooth contours. <br><br>  All of the above masks and make up our level.  This is what it consists of: the R channel contains a mask of lava;  G - the mask of the earth;  B - mask for mixing diffuse textures;  A - shadows. <br><br><div class="spoiler">  <b class="spoiler_title">Ready Levelmap</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d9/fb/59d9fb75e71a6300842853.png"></div><br>  <i>The truth here is not visible alpha channel, in which shadows are baked</i> <br></div></div><br><h3>  Rendering level </h3><br>  If right now we take and render the levelmap, we get something like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/e1/e8/59e1e8c0e207f232704402.png"></div><br>  <i>On the left, a rectangle on the levelmap shows the camera coverage.</i> <br><br>  How to get this?  Suppose we have a camera matrix (we know for sure the position of our player and the angle of his turn).  In the vertex shader, this matrix is ‚Äã‚Äãmultiplied by the texture coordinates of full-screen quad, and the result is transferred to the fragment shader.  These texture coordinates are nothing more than the coordinates of a fragment inside a levelmap.  Therefore, we simply do a sample of it from these coordinates.  In the screenshot above, only RG channels are displayed. <br><br>  It turned out too blurry (Gauss filter makes itself felt).  Let's apply the clamping to the result of the sample from the levmapy: <br><br><pre><code class="hljs pgsql">vec4 <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> = texture2D(levelmap, texcoord.xy); vec2 color = clamp((<span class="hljs-keyword"><span class="hljs-keyword">level</span></span>.rg * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * <span class="hljs-number"><span class="hljs-number">30.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre> <br>  The meaning of this formula: level.rg changes smoothly from 0 to 1 (seen in the screenshot above).  After clamping, <b>all</b> sample values ‚Äã‚Äãless than 0.5 turn to 0, and large 0.516 turn to 1, and the values ‚Äã‚Äãin the [0.5, 0.516] segment ‚Äústretch‚Äù to the [0, 1] segment.  This is how it looks like: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/da/06/59da06a508454689953189.gif"></div><br><br>  The time has come for textures: two diffuse textures are mixed by a mask from the B-channel of the levelampa, a texture of the wall by the G-channel is mixed with them, and the result is mixed with the texture of the lava by the R-channel of the level (the colors are mixed in the GLSL shaders ordinary linear interpolation of two values ‚Äã‚Äãby the mixing coefficient).  For sampling from textures, all the same texture coordinates are used multiplied by a certain coefficient, which affects the number of repetitions of this texture throughout the entire map: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/da/0b/59da0b77e3b1b943066117.gif"></div><br><br>  Everything looks too flat.  To fix this in our shader you need to transfer another texture with Perlin noise.  A sample of this texture is added to the value of the R-channel levelmapy (lava mask).  The resulting coefficient is used not only for mixing lava and earth, but also for shading the coastline.  Also add static shadows that are stored in the level channel A-channel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/da/33/59da333234346126681385.gif"></div><br><br>  It looks better already, pay attention to how the coastline has changed, now it is not so flat and flat. <br><br>  It remains to solve the last problem: we can see through the wall (that is, we see areas that are fenced off by the wall from our character).  To solve this problem, the fragment trace is used: a ray is ejected from the studied fragment to the character‚Äôs side and samples are leveled from the level (we are only interested in the G channel with a mask of the wall), this project uses 12 samples.  From the results of the samples, it is possible to determine whether a fragment is visible from the character‚Äôs position or not.  Such a trace is too expensive for a full-screen passage, so it is performed in a separate small-size framebuffer (64x64).  This texture is called the visibility map: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/e1/ed/59e1ed98a0882548627940.png"></div><br>  <i>Before and after the visibility map</i> <br><br>  The visibility map is used not only in the full screen aisle for rendering maps, but also for rendering all game objects (bridges, cannons, characters). <br><br><h3>  Lava rendering </h3><br>  Now let's animate the lava.  To do this, create an offset map.  In this texture, a 2D vector is stored in the RG channels, which is added to the texture coordinates for sampling from the lava texture.  And not just the displacement map is needed, but the displacement map that changes with time.  In this game, a 512x512 framebuffer is used to create the displacement map.  The texture with the Perlin noise and the time measured from 0 to 1 is transferred to the shader of this pass. <br><br>  Piece of fragment shader (simplified): <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">vec4</span></span> d1 = texture2D(noise, (texcoord.xy + time.xy)); <span class="hljs-attribute"><span class="hljs-attribute">vec4</span></span> d2 = texture2D(noise, (texcoord.xy + time.yx) * <span class="hljs-number"><span class="hljs-number">2</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-attribute"><span class="hljs-attribute">vec4</span></span> d3 = texture2D(noise, (texcoord.xy + vec2(<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> - time.x, <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>)) * <span class="hljs-number"><span class="hljs-number">4</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-attribute"><span class="hljs-attribute">vec4</span></span> d4 = texture2D(noise, (texcoord.xy + vec2(<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> - time.x)) * <span class="hljs-number"><span class="hljs-number">8</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-attribute"><span class="hljs-attribute">vec2</span></span> d = (d1.rg + d2.gr + d3.rg + d4.gr) * <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">25</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = vec4(d.rg, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  <i>where noise is a noise texture (it is static).</i> <br><br>  The meaning of this shader is that 4 samples are made from the same noise texture, but with a different scale of texture coordinates.  Moreover, they are shifted with time in perpendicular directions (pay attention to the second sample, the time.yx offset is used there, and time.xy is used in the first one).  The time is sewn only in the x-component of the time variable, and the y-component contains 0. <br><br><div class="spoiler">  <b class="spoiler_title">Animated Offset Map</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/ec/6c/59ec6cd89004b983713934.gif"></div><br>  <i>Hereinafter, the animation is intermittent, because it was not possible to loop it for the gif, but in the game it is smooth</i> <br></div></div><br>  Now this animated texture can be transferred to the lava shader.  In this shader, we sample the displacement map and add the resulting 2D vector to the texture coordinates of the lava. <br><br>  Simplified Shader Piece: <br><br><pre> <code class="hljs lisp">vec4 wave = texture2D(<span class="hljs-name"><span class="hljs-name">tex_wave</span></span>, texcoord.zw) * <span class="hljs-number"><span class="hljs-number">0.1</span></span><span class="hljs-comment"><span class="hljs-comment">; vec4 color = texture2D(lava, texcoord.xy + wave.rg);</span></span></code> </pre><br>  <i>where tex_wave is the displacement map (well, or the wave map).</i> <br><br>  With a coefficient of 0.1 you can play, it affects the "disturbance" of the lava. <br><br>  Animated lava: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/e1/fd/59e1fd3d5aa58244596967.gif"></div><br><br>  In principle, this could be stopped, it looks pretty good.  But you can do even better - make the lava flow.  To create the flow, we need to generate another texture: the velocity map.  When the lava was generated, we created a polyline and drew the segments of this polyline into the lava buffer.  Now we will get another buffer for the velocity map.  Let's draw in it segments of a broken line, but at the same time each segment will bring in this buffer the vector of the direction of the segment.  Then we blur this buffer according to Gauss, thus we not only ‚Äúmix‚Äù speeds at river bends and at intersections with tributaries, but also get the effect of ‚Äúviscous lava‚Äù, that is, the velocity of lava flow in the middle of the river is higher than that of the coast. <br><br><div class="spoiler">  <b class="spoiler_title">Velocity map</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/eb/17/59eb178bba2f0624572103.png"></div><br>  <i>Right is the velocity map.</i>  <i>RG channels correspond to the velocity vector</i> <br></div></div><br>  The velocity map is used to offset the texture coordinates of the lava.  In order for a flow effect to appear, it is necessary to displace it in time. <br><br>  So, the updated lava shader (simplified): <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">vec4</span></span> vel = texture2D(tex_velocity, texcoord.xy); <span class="hljs-attribute"><span class="hljs-attribute">vec4</span></span> wave = texture2D(tex_wave, texcoord.zw) * <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">vec4</span></span> col1 = texture2D(lava, texcoord.xy + wave.rg + vel.xy * time.x); <span class="hljs-attribute"><span class="hljs-attribute">vec4</span></span> col2 = texture2D(lava, texcoord.xy + wave.rg + vel.xy * time.x - vel.xy); <span class="hljs-attribute"><span class="hljs-attribute">vec4</span></span> color = mix(col1, col2, time.x);</code> </pre><br>  Here two samples are taken from the lava texture at a distance from each other exactly equal to vel.xy and mixed by the time value. <br><br><div class="spoiler">  <b class="spoiler_title">Why make two samples instead of one?</b> <div class="spoiler_text">  The fact is that time.x is measured from 0 to 1 and when moving from 1 to 0, a jump in texture coordinates occurs, which is also expressed in jumps in the animation of the texture itself.  If the time is not reset to zero (even if it always grows), then even worse, the texture will flatten, because we have different lava flow rates (even for neighboring fragments, they are generally different).  The first sample gives the color of the lava in the present tense, and the second gives the color that was a unit of time ago.  These samples are interpolated in time.  Thus, smooth animation is achieved. <br></div></div><br>  All together looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/e2/03/59e203c9bc2c6916476890.gif"></div><br><br><div class="spoiler">  <b class="spoiler_title">Rendering decals</b> <div class="spoiler_text">  The decals in this game are pools of blood, traces of rocket blasts and other bullets. <br>  Decals, like objects, are not stored by themselves anywhere and are not processed.  Each decal, at the time of its appearance, is rendered into a huge texture that covers the entire map.  This texture is then ‚Äústretched‚Äù on the levelmap.  That is, it contains all the decals that have ever appeared (of course, it is not cleaned). <br><br>  Now let's find out what resolution this decal texture should have.  Experimentally, it was found that 16x16 texels of textures per one card tile looks optimal (if you take 32x32, then this is already larger than the size of the decal itself, for example, the explosion trace, and 4-fold loss from memory).  The largest map has a size of 256x256, then the resolution of the decal texture is 16 * 256 = 4096x4096. <br>  In fact, the 4K * 4K texture is not created; instead, the entire map is ‚Äúsawn‚Äù into 32x32 zones.  Each such zone has its own texture with decals 512x512.  There are 64 such textures for a large map. In order not to transfer a pack of these textures to the main pass of the map rendering (and not to process from which sample to make the samples), another framebuffer was created.  For it, exactly the same matrix of the camera is configured as for rendering the map.  And all the textures with decals are rendered one by one into it taking into account their positions on the map (of course, most of them are clipped before the drawcall call).  Now, only this ready-made framebuffer is transferred to the main pass of the map rendering. <br></div></div><br><h3>  Physics </h3><br>  To determine whether a point collides with a wall or hits a point in the lava, you need to read the value from the array with a blurred level on the integer coordinates of this point, as well as on the neighboring coordinates.  Manually perform a linear interpolation of these values ‚Äã‚Äãand compare with a certain threshold value. <br><br><div class="spoiler">  <b class="spoiler_title">Collision Detection (Simplified)</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getCollide = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> frac = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) =&gt;</span></span> x - <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x | </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lerp</span></span></span><span class="hljs-function"> = (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, t</span></span></span><span class="hljs-function">) =&gt;</span></span> a * (<span class="hljs-number"><span class="hljs-number">1</span></span> - t) + b * t; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buffer = level.getGroundMap(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cx = pos.x | <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cy = pos.y | <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> t00 = buffer.getData(cx, cy); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> t10 = buffer.getData(cx + <span class="hljs-number"><span class="hljs-number">1</span></span>, cy); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> t01 = buffer.getData(cx, cy + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> t11 = buffer.getData(cx + <span class="hljs-number"><span class="hljs-number">1</span></span>, cy + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dx = frac(pos.x); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dy = frac(pos.y); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xx1 = lerp(t00, t10, dx); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xx2 = lerp(t01, t11, dx); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> yy = lerp(xx1, xx2, dy); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> yy * <span class="hljs-number"><span class="hljs-number">255</span></span> | <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br></div></div><br>  To determine the normal to the wall at the point (X, Y), it is necessary to perform this operation three times: for points (X, Y), (X + 0.25, Y), (X, Y + 0.25): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getNorm = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dest_normal, pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> t00 = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getCollide(pos); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> t10 = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getCollide(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(pos.x + <span class="hljs-number"><span class="hljs-number">0.25</span></span>, pos.y)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> t01 = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getCollide(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(pos.x, pos.y + <span class="hljs-number"><span class="hljs-number">0.25</span></span>)); dest_normal.set(t10 - t00, t01 - t00); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t00; };</code> </pre><br>  Normals are used not only to calculate bounce, but also to collide a character with a wall.  When a character crosses a wall with a body, then in the same frame it kind of pushes him out in the direction of the normal. <br><br>  Ricochets: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/e2/2c/59e22c9b6108a694521853.gif"></div><br><br>  Advantages and disadvantages of using levelmaps in comparison with the tile renderer. <br><br>  Pros: <br><br><ul><li>  Rendered in one call and all in one shader </li><li>  Easy to create bumps and smooth transitions, while physics does not suffer </li><li>  Free antialiasing </li><li>  No need to store a ton of tiles and think about how to cut them around the camera </li><li>  Something else </li></ul><br>  Minuses: <br><br><ul><li>  Rendered in one call and all in one shader, so it's pretty heavy </li><li>  We are limited in diffuse textures, because the blending masks need to be placed in the channels of the levelmapy, of which there are only 4. Well, it is generally more difficult to create diversity on the map </li><li>  Something else </li></ul><br><h3>  Artificial intelligence bots </h3><br>  The first and most important task of AI bots is to teach them to just run around the map, not paying attention to enemies and objects.  That is adequate movement in the corridors and rooms, as well as on bridges over the lava.  For this purpose, a special graph is used, whose nodes are called waypoints.  Such a graph should cover the entire map, go through all the corridors and rooms.  The bot simply has a link to the current waypoint, and when it reaches it, it randomly selects the next waypoint from those referenced by its current one.  It looks kind of simple.  But first, you need to build this waypoint graph. <br><br>  So, we have a land mask and a lava mask.  We will add these two masks to get a map of the terrain (hereinafter we will deal with it when building the graph). <br><br><div class="spoiler">  <b class="spoiler_title">Passability map for our level</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/eb/19/59eb19e53a3cc729168301.png"></div><br></div></div><br>  Surely there are many ways to build a waypoint graph.  In this project, the graph construction algorithm is based on the Distance Field method (distance map).  Here in <a href="https://habrahabr.ru/post/245729/">this post</a> describes the algorithm for constructing a Distance Field.  The meaning of the distance map - at each point is recorded the distance to the <b>nearest impassable</b> point. <br><br>  Distance Map: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/eb/1a/59eb1adabc322090653530.png"></div><br>  <i>Here the distance is coded in the picture in color, the darker the further</i> <br><br>  In principle, there are already guessed the outlines of the future graph.  The next preparatory stage is the calculation of the gradient of the distance map.  Where the gradient is close to zero, there will be waypoint. <br>  The gradient of the distance map at the point (i, j) is calculated like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> val00 = distance_field.getData(i - <span class="hljs-number"><span class="hljs-number">1</span></span>, j - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> val10 = distance_field.getData(i , j - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> val20 = distance_field.getData(i + <span class="hljs-number"><span class="hljs-number">1</span></span>, j - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> val01 = distance_field.getData(i - <span class="hljs-number"><span class="hljs-number">1</span></span>, j); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> val11 = distance_field.getData(i , j); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> val21 = distance_field.getData(i + <span class="hljs-number"><span class="hljs-number">1</span></span>, j); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> val02 = distance_field.getData(i - <span class="hljs-number"><span class="hljs-number">1</span></span>, j + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> val12 = distance_field.getData(i , j + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> val22 = distance_field.getData(i + <span class="hljs-number"><span class="hljs-number">1</span></span>, j + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dx = (val00 - val11) + (val01 - val11) + (val02 - val11) + (val11 - val20) + (val11 - val21) + (val11 - val22); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dy = (val00 - val11) + (val10 - val11) + (val20 - val11) + (val11 - val02) + (val11 - val12) + (val11 - val22); gradient_x.setData(i + j * size | <span class="hljs-number"><span class="hljs-number">0</span></span>, dx); gradient_y.setData(i + j * size | <span class="hljs-number"><span class="hljs-number">0</span></span>, dy);</code> </pre><br>  So  for all pixels of the map, we execute this code (in fact, only for passable pixels). <br><br>  Gradient Distance Map: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/eb/1b/59eb1b9571fd0583099563.png"></div><br>  <i>Here, according to tradition, RG channels encode a vector</i> <br><br>  This map resembles a mountain range.  The idea is to scatter the waypoints at the points where the ridge of this ridge passes.  How to find a comb?  The components of the gradient vector vary from -1 to 1. The ridge ridge will be there where the gradient is in the range [-Œ±, Œ±], where Œ± is a certain constant chosen experimentally (in this project it is equal to 0.4).  All points at which this condition is satisfied will be the first approach to the set of waypoints.  In addition to the ‚Äúridge‚Äù waypoints, two waypoints are also added for each bridge (at the points where the bridge rests on the ground).  Weypoint Card: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/eb/21/59eb21e8382ba938975961.png"></div><br>  <i>Green dots are waypoints</i> <br><br>  The waypoints are too thick.  Some of them need to be removed.  In this project, the minimum allowable distance between the waypoints is 4 pixels.  Therefore, we enumerate all pairs of waypoints, and if the distance is less than the allowable distance, then we delete one of them.  Naturally we pass bridge waypoints, since  they should never be removed. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/eb/22/59eb22b9a8af0285201403.png"></div><br>  Now you need to connect these waypoints with ribs.  We iterate over all pairs of waypoints and connect a pair with an edge when both of the waypoint are visible from each other.  Tracing is used to determine visibility: we make n samples from the permeability map along the segment connecting these waypoints;  where n is the length of the segment.  If all the samples gave a passable pixel, then we connect these two waypoints with an edge: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/eb/26/59eb26ad4caa4536935910.png"></div><br>  <i>The red lines are the edges of the graph.</i> <br><br>  It turned out too many extra edges.  To solve this problem you need to get rid of the triangles.  How it works?  Take any edge with two waypoints A and B. Suppose among neighbors A there is a waypoint C, which in turn is a neighbor B. Ie  triangle ABC is formed.  The longest edge of this triangle needs to be removed.  Do the same for all edges: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/eb/28/59eb284096f79901751058.png"></div><br>  <i>Some wapoints are not connected by ribs to others - they are filtered out.</i>  <i>Also in the picture you can see that one edge passed over the bridge over the lava.</i> <br><br>  This is the final graph.  Now every bot can navigate it. <br>  AI bot consists of state machines, there are three of them.  One state machine sets the general state of the bot, and the other two control two degrees of freedom: legs (movement) and body.  At the output of the AI, the bot produces the rotation angle and the press of its keys, i.e.  The only difference between a bot and a real player is that the player‚Äôs character receives input from the keyboard and mouse, and the bot‚Äôs character receives input from the AI.  In addition to running around in the waypoint graph, the bot also knows how to respond to objects: rolling cannons and powerpops, other bots and some bullets.  Moreover, a bot responds to these objects if and only if they are in its visibility zone: within its ‚Äúcamera‚Äù (as a player‚Äôs) and not fenced off by walls. <br><br>  The following video demonstrates an AI bot named Frog in a duel with other bots on the big map: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/3KOJhWFbpg8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  So, we just generated a map, lava and graph for AI.  And what about performance?  I measured the time of all stages of generation for the largest 256x256 card on Mac mini (end of 2012), let me remind you, all the code is written in js and runs in a regular chrome browser: <br><table><tbody><tr><th>  Algorithm </th><th>  Time, ms </th></tr><tr><td>  Particle texture generation </td><td>  280 </td></tr><tr><td>  Blood texture generation </td><td>  190 </td></tr><tr><td>  Lava River Generation </td><td>  700 </td></tr><tr><td>  Generate the rest of the card </td><td>  630 </td></tr><tr><td>  Creating a graph </td><td>  210 (720) </td></tr><tr><td>  Total: </td><td>  2010 (2520) </td></tr></tbody></table><br>  The time in brackets is indicated without the use of the hashpoint hash.  This hash is used to quickly find the waypoints near the data in some graph construction algorithms.  Without this hash in these algorithms, the waypoints with complexity O (n <sup>2</sup> ) get over. <br><br><h3>  Network part </h3><br>  The server is written in node.js using WebSocket.  The entire server consists of three parts: master-server - http-server, distributes statics;  game-server - connects to the master server and is invisible to the user, owns the game rooms;  the game room - the user is connected to it via a web socket, other players and bots are running there. <br><br>  In the development of the server side, an approach using fakekroket was applied.  What it is?  Feyksokety are two objects in a client part with interfaces of the real client and server socket.  They emulate the work of real sockets.  The ‚Äúclient‚Äù and ‚Äúserver‚Äù feixocket (in quotes, because they are both client, that is, browser-based) exchange data with each other via setTimeout (for debugging purposes, it was also the ping interval of 30 milliseconds).  The idea is that the real server code can be given to the browser, telling it to work in the fakebox mode.  At the same time, the real client code does not even suspect that the server works next to it in the browser, it simply sends data to the socket (which is a fake-socket) and receives data from it.  Feyksokety used in the development and debugging server code.  But real online works through real sockets. <br><br>  Even after the development of the server code, the fakeboxes were not in vain, they remained in the project and serve as a safety net in case the game room is unavailable for some reason.  How it works?  When a user enters the game, two options can happen: the room is free and ready to accept a new player, then he simply gives the ip address and port of the room and he plays online.  The second option is: if there are no places in the rooms or all the rooms are damaged, then the master server tells the browser to switch to fakeboxes, also sends it all server code (well, not all, but only the code of the game room).  And the user plays the game with bots exclusively locally (well, not lucky for him), while the user will not even know that he plays locally (well, it's in the idale). <br><br>  Feyksokety played a huge role in the development of the server.  Since  Both the client and server are running in the browser - they are very easy to debug, you can also display debug-render, i.e.  Schematically render objects in exactly those positions where they are actually located on the server at a given time.  You can play with the ping: change the interval in the setTimeout function to implement any predictions and see how they work on different pings (in this project, however, no predictions were implemented). <br><br>  Benefits of fakexets: <br><br><ul><li>  Easy debugging - both the server and client are in the browser </li><li>  You can put any ping and see how it will be played at its different values. </li><li>  debag-render allows you to understand how objects look right now on the server </li></ul><br>  Cons fake: <br><br><ul><li>  Bots must be in the game, if there are no bots, then fake-pockets are useless. </li><li>  The server must be written in the same language as the client. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> With them, you can only debug the logic of the server code, but the full server picture (traffic, load on the network, different ping for different clients ...) they will not give </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArrayBuffer is used to transfer data between the client and the server. </font><font style="vertical-align: inherit;">All data is serialized to this buffer, and a 2-byte float method is also used. </font><font style="vertical-align: inherit;">Before forming a package for a client, all objects are maximally cut off over the camera of this client, so as not to send him extra information. </font><font style="vertical-align: inherit;">As a result, it was estimated that the average size of the server package for a single client is approximately 110-120 bytes. </font><font style="vertical-align: inherit;">And it contains all the information needed to render this frame to this client.</font></font><br><br><h3>  Conclusion </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to all of the above, the game also has its own console, which is invoked by the tilde key (with commands, variables, auto-completion and history). </font><font style="vertical-align: inherit;">There is also a pretty good nickname generator and event system. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The full source code of the game is posted on </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Startup Guide (you must have node.js installed). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you already have bower installed, then skip this step, otherwise:</font></font><br><br><pre> <code class="bash hljs">npm install -g bower</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> At the root of the project we execute two commands: </font></font><br><br><pre> <code class="bash hljs">bower install npm install</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Starting the master server: </font></font><br><br><pre> <code class="bash hljs">npm run master</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If port 80 is busy, you can do this: </font></font><br><br><pre> <code class="bash hljs">npm run master -- --master-server:port=8800</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In principle, this is already enough, you can go to localhost (well, or localhost: 8800, if you changed the port) and there will already be a game, though local through feyksokety. </font><font style="vertical-align: inherit;">If you need an honest online, then in another console we do:</font></font><br><br><pre> <code class="bash hljs">npm run game</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now you can enter the game not only from this computer, but also from any other computer, simply by entering the ip master server in the address bar. </font><font style="vertical-align: inherit;">To find out whether the game is local, you need to call the game console and issue the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">status</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Another interesting command is the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spectator nick</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , where nick is the player's name, then the camera will move to this player. </font><font style="vertical-align: inherit;">By default, a large map of 110 players will be generated. </font><font style="vertical-align: inherit;">To generate other maps, you need to run:</font></font><br><br><pre> <code class="bash hljs">npm run game -- -- --game-server:seed=314 --game-server:size=0</code> </pre><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is not a typo, the number of hyphens is exactly that. </font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This command will generate a small map, which is described in this post. </font><font style="vertical-align: inherit;">The following sizes are supported: 0 - small map, 1 - medium and 2 - large map (by default). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is best to run in the chrome browser, in other browsers the correct operation is not guaranteed.</font></font><br><br>  Thank you all for your attention. </div><p>Source: <a href="https://habr.com/ru/post/339566/">https://habr.com/ru/post/339566/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339554/index.html">How to create a quality map for metro</a></li>
<li><a href="../339556/index.html">Setting tasks for beginners timlidov</a></li>
<li><a href="../339558/index.html">Food Design Digest, September 2017</a></li>
<li><a href="../339562/index.html">Mathematical model of a liquid tachometer in Python</a></li>
<li><a href="../339564/index.html">Cocos2d-x - Basic Concepts</a></li>
<li><a href="../339568/index.html">PostgreSQL 10 released</a></li>
<li><a href="../339570/index.html">The economy of tokens: discounts - the main problems</a></li>
<li><a href="../339572/index.html">API on Swift in five minutes. Lecture in Yandex</a></li>
<li><a href="../339576/index.html">REPL - setting for saving history and loading modules by default</a></li>
<li><a href="../339580/index.html">Using the event model in Doctrine 2 + Symfony 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>