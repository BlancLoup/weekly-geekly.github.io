<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The fundamental problem of package managers for programming languages</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Why are there so many different package managers? They can be found in many operating systems (apt, yum, pacman, Homebrew), and working with many prog...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The fundamental problem of package managers for programming languages</h1><div class="post__text post__text-html js-mediator-article">  Why are there so many different package managers?  They can be found in many operating systems (apt, yum, pacman, Homebrew), and working with many programming languages ‚Äã‚Äã(Bundler, Cabal, Composer, CPAN, CRAN, CTAN, EasyInstall, Go Get, Maven, npm, NuGet, OPAM PEAR, pip, RubyGems, etc., etc.).  "Every programming language needs its own package manager, it has become a universally recognized truth."  What kind of inexplicable attraction makes programming languages, one after another, slide into this cliff?  Why don't we just <a href="http://www.standalone-sysadmin.com/blog/2014/03/just-what-we-need-another-package-manager/">use existing</a> package managers? <br><a name="habracut"></a><br><br>  You probably already have some suggestions why using apt to manage Ruby packages is not a good idea.  ‚ÄúSystem package managers and package managers for programming languages ‚Äã‚Äãare completely different things.  Centralized distribution of all packages is great, but it is completely unsuitable for most libraries hosted on GitHub.  Centralized packet distribution is too slow.  All programming languages ‚Äã‚Äãare different and their communities do not interact with each other.  Such package managers install packages globally, and I want to manage the versions of the libraries used. ‚ÄùThese flaws are certainly present in this solution.  But the very essence of all these problems is missing in them. <br><br>  The fundamental problem is that package managers for various programming languages ‚Äã‚Äãare <b>decentralized</b> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This decentralization is implied even in the definition of the package manager itself: it is a kind of program that installs programs and libraries from remote sources that were not available locally at the time of installation.  Even if you imagine an ideal centralized package manager, even there will be two copies of this library: one - somewhere on the server, the second - located locally with the programmer who writes the application, using this library.  However, in reality, the library ecosystem suffers greatly from fragmentation - it brings together many libraries created by different developers.  Of course, all libraries can be loaded and indexed in one place, but this still does not mean that library authors will be aware of any other use cases.  And then we get what Perl is called DarkPAN in the world: an innumerable amount of code that seems to exist, but which we don‚Äôt have any idea about, since it is wired somewhere in the proprietary code or functions somewhere in the corporate servers.  Decentralization can be bypassed only when you control absolutely <i>all the</i> code of your application.  But in this case, you hardly need a package manager, is it?  (By the way, colleagues told me that this is necessary for large projects, such as the Windows operating system or Google Chrome browser.) <br><br>  Decentralized systems are complex.  Seriously, very complicated.  If you don‚Äôt think carefully about the architecture of such a system, dependency hell certainly awaits you.  There is no one ‚Äúright‚Äù solution to this problem: I can name at least three different approaches to solving this problem, which are used in different generations of package managers, and each of them has its own advantages and disadvantages. <br><br>  <b>Pinned versions.</b>  Perhaps the most popular is the opinion that the developer should strictly indicate the version of the package used.  This approach is promoted by such managers as Bundler for Ruby, Composer for PHP, pip in conjunction with virtualenv for Python and any other Ruby / node.js inspired approach (for example, Gradle for Java or Cargo for Rust).  Recreation of assemblies in them rules the ball - these package managers solve the problem of decentralization, simply by assuming that the entire ecosystem of packages ceases to exist as soon as you have fixed the versions.  The main advantage of this approach is that you can specify the versions of libraries that you use in your code.  Of course, this is also a disadvantage - you always have to control the versions of these libraries.  Usually versions are simply fixed, safely forgetting about them, even if any important security update is released.  To have updated versions of all dependencies development cycles are needed, but this time is most often spent on other things (for example, developing new features). <br><br>  <b>Stable versions.</b>  If package management requires each individual application developer to spend time and effort on keeping all dependencies up to date and checking that they continue to work correctly with the application and with each other, we could ask ourselves: is there a way to centralize this work?  This leads us to another approach: create a centralized repository with approved packages, the work that has been tested together, and issue bug fixes and security updates for them while we maintain backward compatibility.  For various programming languages ‚Äã‚Äãthere are implementations of such package managers.  At least two that I know about are Anaconda for Python and Stackage for Haskell.  But if you look closely, we will see that <i>exactly the same</i> model is used in package managers of operating systems.  As a system administrator, I often recommend that users give preference to libraries distributed in operating system repositories.  They will not break backward compatibility until we switch to a new release version of the OS, and at the same time, you will always use the latest bug fixes and security updates.  (Yes, you will not be able to use features from the new versions, but, by itself, this goes against the concept of stability.) <br><br>  <b>Considering decentralization.</b>  Up to this point, we tried not to consider decentralization at all as an acceptable approach.  They talked about the need for a central repository and update control by the developer.  But do not we throw out the child with water?  The main disadvantage of the centralized approach is the huge amount of work that needs to be done in order to achieve stable operation of all packages and to keep these packages up to date.  In addition, no one expects that absolutely all packages will be compatible with each other, but, nevertheless, this does not prevent the use of certain categories of packages with others.  The ideal decentralized system shifts the task of determining which packages can work together for everyone who participates in this system, which again brings us back to the fundamental question: How can we create an ecosystem of decentralized package managers that will work? <br><br>  Here are a number of principles that can help us: <br><br><ol><li>  <b>Strong dependency encapsulation.</b>  One of the reasons that makes dependency hell such an insidious problem is that package dependencies are often an inseparable part with its core API: thus, the choice of dependency is more of a global choice that affects the entire application.  If the library uses any dependencies inside, and this choice is completely determined only by the details of the internal implementation of this library, it <i>should not</i> lead to any global constraints.  NPM for NodeJS brings this principle to a logical limit ‚Äî by default, it does not limit dependency duplication, allowing each library to download its own instance of the dependent package.  Although I <a href="http://stackoverflow.com/questions/25268545/why-does-npms-policy-of-duplicated-dependencies-work">doubt</a> that it is worth duplicating absolutely all the packages (this is found in the Maven ecosystem for Java), I certainly agree that this approach increases the composability of dependencies. </li><li> <b>Semantic versioning promotion.</b>  In decentralized systems, it is especially important that library developers provide as accurate library information as possible so that users and utilities working with packages can make informed decisions.  Different formats of versions and ranges of versions only complicate the already difficult task (as I wrote in the previous <a href="http://blog.ezyang.com/2014/08/whats-a-module-system-good-for-anyway/">post</a> ).  If you have the opportunity to <a href="http://bndtools.org/">use semantic versions</a> , or even better, instead of semantic versions, use a more correct approach, indicating type dependencies in your interfaces, our utilities will be able to make the best choice.  The ‚Äúgold standard‚Äù of information in decentralized systems is ‚ÄúIs package A compatible with package B‚Äù, and this information is often very difficult to analyze (or impossible for systems with dynamic typing). </li><li>  <b>Centralization for special cases.</b>  One of the principles of the decentralized system is that each participant can gather the most suitable environment for themselves.  This implies a certain freedom in choosing a central source, or the creation and use of one‚Äôs own ‚Äî centralization for special occasions.  If we assume that users will create their own repositories, in the style used in operating systems, we must provide them with the tools with which you can easily and painlessly create and use these repositories. </li></ol><br><br>  For a long time, the source code management ecosystem was completely built around centralized systems.  The proliferation of version control systems like Git has radically changed the situation: although Git may seem more complicated than Subversion to master people far from technology, the merits of decentralization are much bigger and more diverse.  But no one has yet managed to create the same Git for package management.  If someone assures you that the package management problem is solved and everything is just reinventing the Bundler, I ask you - think about decentralization properly. </div><p>Source: <a href="https://habr.com/ru/post/250065/">https://habr.com/ru/post/250065/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../250053/index.html">Why developers don't like Unit Tests</a></li>
<li><a href="../250055/index.html">WSGI / Rack for PHP</a></li>
<li><a href="../250057/index.html">Music as infrastructure: the choice of headphones</a></li>
<li><a href="../250061/index.html">Sites from right to left: how to connect the RTL-standard</a></li>
<li><a href="../250063/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ146 (February 2 - 8, 2015)</a></li>
<li><a href="../250067/index.html">Full stack vs micro framework, Docker ecosystem and other things with which lucky pythonists (UPD: video)</a></li>
<li><a href="../250071/index.html">Product design digest, January 2015</a></li>
<li><a href="../250073/index.html">DevCon Digest # 1. Immerse in .NET</a></li>
<li><a href="../250075/index.html">PHP Digest number 56 - interesting news, materials and tools (January 25 - February 8, 2015)</a></li>
<li><a href="../250079/index.html">Ruby 2.2 incremental garbage collector</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>