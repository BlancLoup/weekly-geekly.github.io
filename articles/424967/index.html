<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Closures in javascript for beginners</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Closures are one of the fundamental concepts of JavaScript, causing difficulties for many beginners to know and understand that every JS programmer sh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Closures in javascript for beginners</h1><div class="post__text post__text-html js-mediator-article">  Closures are one of the fundamental concepts of JavaScript, causing difficulties for many beginners to know and understand that every JS programmer should.  Having dealt well with closures, you will be able to write better, more efficient, and cleaner code.  And this, in turn, will contribute to your professional growth. <br><br>  The material, the translation of which we publish today, is dedicated to the story about the internal mechanisms of closures and how they work in JavaScript-programs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/652/808/540/652808540f60e3a5f1b4b255fe90337a.png"></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">What is a closure?</font> </h2><br>  A closure is a function that has access to the scope, the function that is external to it, even after this external function has completed its work.  This means that the variables declared in the external function and the arguments passed to it can be stored in the closure.  Before we move on to closures, let's deal with the concept of "lexical environment". 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  <font color="#3AC1EF">What is the lexical environment?</font> </h2><br>  The term "lexical environment" or "static environment" in JavaScript refers to the ability to access variables, functions and objects based on their physical location in the source code.  Consider an example: <br><br><pre><code class="hljs pgsql">let a = <span class="hljs-string"><span class="hljs-string">'global'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>() {    let b = <span class="hljs-string"><span class="hljs-string">'outer'</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span>() {      let c = <span class="hljs-string"><span class="hljs-string">'inner'</span></span>      console.log(c);   // <span class="hljs-string"><span class="hljs-string">'inner'</span></span>      console.log(b);   // <span class="hljs-string"><span class="hljs-string">'outer'</span></span>      console.log(a);   // <span class="hljs-string"><span class="hljs-string">'global'</span></span>    }    console.log(a);     // <span class="hljs-string"><span class="hljs-string">'global'</span></span>    console.log(b);     // <span class="hljs-string"><span class="hljs-string">'outer'</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span>();  } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>(); console.log(a);         // <span class="hljs-string"><span class="hljs-string">'global'</span></span></code> </pre> <br>  Here, the <code>inner()</code> function has access to variables declared in its own scope, in the scope of the <code>outer()</code> function, and in the global scope.  The <code>outer()</code> function has access to variables declared in its own scope and global scope. <br><br>  The chain of scopes of the above code will look like this: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Global</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> } }</code> </pre> <br>  Notice that the <code>inner()</code> function is surrounded by the lexical environment of the <code>outer()</code> function, which, in turn, is surrounded by the global scope.  That is why the <code>inner()</code> function can access variables declared in the <code>outer()</code> function and in the global scope. <br><br><h2>  <font color="#3AC1EF">Practical examples of closures</font> </h2><br>  Consider, before analyzing the intricacies of the internal structure of closures, a few practical examples. <br><br><h3>  <font color="#3AC1EF">‚ñçSample number 1</font> </h3><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">'Peter'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displayName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name); }; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> peter = person(); peter(); <span class="hljs-comment"><span class="hljs-comment">// 'Peter'</span></span></code> </pre> <br>  Here we call the <code>person()</code> function, which returns the internal <code>displayName()</code> function, and store this function in the <code>peter</code> variable.  When we then call the <code>peter()</code> function (the corresponding variable actually stores the reference to the <code>displayName()</code> function), the name <code>Peter</code> is displayed in the console. <br><br>  At the same time, the <code>displayName()</code> function does not have a variable named <code>name</code> , so we can conclude that this function can somehow access the variable declared in the function external to it, <code>person()</code> , even after how this function worked.  Perhaps this is because the <code>displayName()</code> function is actually a closure. <br><br><h3>  <font color="#3AC1EF">‚ñçSample number 2</font> </h3><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter++; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = getCounter(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(count());  <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(count());  // 1 console.log(count());  // 2</span></span></code> </pre> <br>  Here, as in the previous example, we store the reference to the anonymous internal function returned by the <code>getCounter()</code> function in the variable <code>count</code> .  Since the <code>count()</code> function is a closure, it can access the <code>counter</code> variable of the <code>getCount()</code> function even after the <code>getCounter()</code> function has completed its work. <br><br>  Note that the value of the <code>counter</code> variable is not reset to 0 each time the <code>count()</code> function is called.  It may seem that it should be reset to 0, as it could be when calling a normal function, but this does not happen. <br><br>  Everything works this way because every time the <code>count()</code> function is called, a new scope is created for it, but there is only one scope for the <code>getCounter()</code> function.  Since the <code>counter</code> variable is declared in the scope of the <code>getCounter()</code> function, its value between <code>count()</code> function calls is preserved, not resetting to 0. <br><br><h2>  <font color="#3AC1EF">How do closures work?</font> </h2><br>  So far we have talked about closures, and considered practical examples.  Now let's talk about the internal mechanisms of JavaScript, ensuring their work. <br><br>  In order to understand closures, we need to deal with the two most important concepts of JavaScript.  This is the execution context and the lexical environment. <br><br><h3>  <font color="#3AC1EF">Context of execution</font> </h3><br>  The execution context is an abstract environment in which the JavaScript code is computed and executed.  When global code is executed, it occurs within the global execution context.  The function code is executed inside the execution context of the function. <br><br>  At some point in time, the code can be executed only in one execution context (JavaScript is a single-threaded programming language).  These processes are managed using the so-called Call Stack. <br><br>  The call stack is a data structure based on the LIFO principle (Last In, First Out - last entered, first out).  New elements can be placed only in the upper part of the stack, and only elements can be removed from it. <br><br>  The current execution context will always be at the top of the stack, and when the current function terminates, its execution context is retrieved from the stack and control is transferred to the execution context, which was located below the context of this function in the call stack. <br><br>  Consider the following example in order to better understand what the execution context and call stack are: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e23/04d/ef3/e2304def39694bb52330011b2f0fa4af.png"></div><br>  <i><font color="#999999">Execution context example</font></i> <br><br>  When this code is executed, the JavaScript engine creates a global execution context for executing global code, and when it encounters a function call <code>first()</code> , it creates a new execution context for this function and places it on top of the stack. <br><br>  The call stack for this code looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/612/86c/7d2/61286c7d24769fa8df93b030e4d98c6b.png"></div><br>  <i><font color="#999999">Call stack</font></i> <br><br>  When the execution of the <code>first()</code> function is completed, its execution context is retrieved from the call stack and control is transferred to the execution context that is below it, that is, the global context.  After that, the code remaining in the global scope will be executed. <br><br><h3>  <font color="#3AC1EF">‚ñçLexic environment</font> </h3><br>  Every time the JS engine creates an execution context for executing a function or a global code, it also creates a new lexical environment for storing variables declared in this function during its execution. <br><br>  A lexical environment is a data structure that stores information about the correspondence of identifiers and variables.  Here, ‚Äúidentifier‚Äù is the name of a variable or function, and ‚Äúvariable‚Äù is a reference to an object (functions are also included) or a value of a primitive type. <br><br>  The lexical environment contains two components: <br><br><ul><li>  The environment record is the place where declarations of variables and functions are stored. </li><li>  Reference to the outer environment ‚Äî A reference that allows you to access the external (parent) lexical environment.  This is the most important component that needs to be dealt with in order to understand closures. </li></ul><br>  Conceptually, the lexical environment looks like this: <br><br><pre> <code class="hljs xml">lexicalEnvironment = { environmentRecord: {   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">identifier</span></span></span><span class="hljs-tag">&gt;</span></span> : <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>,   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">identifier</span></span></span><span class="hljs-tag">&gt;</span></span> : <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> } outer: <span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Reference</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">to</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">the</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">parent</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">lexical</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">environment</span></span></span><span class="hljs-tag">&gt;</span></span> }</code> </pre> <br>  Take a look at the following code snippet: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">first</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-number"><span class="hljs-number">25</span></span>;  <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Inside first function'</span></span>); } first(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Inside global execution context'</span></span>);</code> </pre> <br>  When the JS engine creates a global execution context for executing global code, it also creates a new lexical environment for storing variables and functions declared in the global scope.  As a result, the lexical environment of the global scope will look like this: <br><br><pre> <code class="hljs pgsql">globalLexicalEnvironment = { environmentRecord: {     a : <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>,     first : &lt; reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> &gt; } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> }</code> </pre> <br>  Note that the reference to the external lexical environment ( <code>outer</code> ) is set to <code>null</code> , since the global scope does not have an external lexical environment. <br><br>  When the engine creates an execution context for the <code>first()</code> function, it also creates a lexical environment for storing variables declared in this function during its execution.  As a result, the lexical environment of the function will look like this: <br><br><pre> <code class="hljs pgsql">functionLexicalEnvironment = { environmentRecord: {     b : <span class="hljs-number"><span class="hljs-number">25</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;globalLexicalEnvironment&gt; }</code> </pre> <br>  The link to the external lexical environment of the function is set to <code>&lt;globalLexicalEnvironment&gt;</code> , since in the source code the function code is in the global scope. <br><br>  Note that when a function completes, its execution context is retrieved from the call stack, but its lexical environment can be removed from memory, or it can remain there.  It depends on whether there are references to this lexical environment in other lexical environments in the form of references to an external lexical environment. <br><br><h2>  <font color="#3AC1EF">Detailed analysis of examples of working with closures</font> </h2><br>  Now that we have armed ourselves with knowledge of the execution context and the lexical environment, let us return to the closures and more deeply analyze the same code fragments that we have already considered. <br><br><h3>  <font color="#3AC1EF">‚ñçSample number 1</font> </h3><br>  Take a look at this code snippet: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">'Peter'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displayName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name); }; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> peter = person(); peter(); <span class="hljs-comment"><span class="hljs-comment">// 'Peter'</span></span></code> </pre> <br>  When the <code>person()</code> function is executed, the JS engine creates a new execution context and a new lexical environment for this function.  Completing the work, the function returns the <code>displayName()</code> function, a reference to this function is written to the <code>peter</code> variable. <br><br>  Her lexical environment will look like this: <br><br><pre> <code class="hljs pgsql">personLexicalEnvironment = { environmentRecord: {   <span class="hljs-type"><span class="hljs-type">name</span></span> : <span class="hljs-string"><span class="hljs-string">'Peter'</span></span>,   displayName: &lt; displayName <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> reference&gt; } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;globalLexicalEnvironment&gt; }</code> </pre> <br>  When the <code>person()</code> function completes, its execution context is retrieved from the stack.  But its lexical environment remains in memory, since the link to it is in the lexical environment of its internal function <code>displayName()</code> .  As a result, variables declared in this lexical environment remain accessible. <br><br>  When the <code>peter()</code> function is called (the corresponding variable stores a reference to the <code>displayName()</code> function), the JS engine creates a new execution context and a new lexical environment for this function.  This lexical environment will look like this: <br><br><pre> <code class="hljs pgsql">displayNameLexicalEnvironment = { environmentRecord: {   } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;personLexicalEnvironment&gt; }</code> </pre> <br>  The <code>displayName()</code> function has no variables, so its environment record will be empty.  During the execution of this function, the JS engine will try to find the <code>name</code> variable in the lexical environment of the function. <br><br>  Since the <code>displayName()</code> function cannot be found in the lexical environment, the search will continue in the external lexical environment, that is, in the lexical environment of the <code>person()</code> function, which is still in memory.  There, the engine finds the desired variable and displays its value in the console. <br><br><h3>  <font color="#3AC1EF">‚ñçSample number 2</font> </h3><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter++; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = getCounter(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(count());  <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(count());  // 1 console.log(count());  // 2</span></span></code> </pre> <br>  The lexical environment of the <code>getCounter()</code> function will look like this: <br><br><pre> <code class="hljs pgsql">getCounterLexicalEnvironment = { environmentRecord: {   counter: <span class="hljs-number"><span class="hljs-number">0</span></span>,   &lt;anonymous <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>&gt; : &lt; reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>&gt; } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;globalLexicalEnvironment&gt; }</code> </pre> <br>  This function returns an anonymous function that is assigned to the variable <code>count</code> . <br><br>  When the <code>count()</code> function is executed, its lexical environment looks like this: <br><br><pre> <code class="hljs pgsql">countLexicalEnvironment = { environmentRecord: { } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;getCountLexicalEnvironment&gt; }</code> </pre> <br>  When executing this function, the system will search for the <code>counter</code> variable in its lexical environment.  In this case, again, the record of the function environment is empty, so the search for the variable continues in the external lexical environment of the function. <br><br>  The engine finds the variable, displays it in the console and increments the <code>counter</code> variable stored in the <code>getCounter()</code> function's lexical environment. <br><br>  As a result, the lexical environment of the <code>getCounter()</code> function after the first call of the <code>count()</code> function will look like this: <br><br><pre> <code class="hljs pgsql">getCounterLexicalEnvironment = { environmentRecord: {   counter: <span class="hljs-number"><span class="hljs-number">1</span></span>,   &lt;anonymous <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>&gt; : &lt; reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>&gt; } <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;globalLexicalEnvironment&gt; }</code> </pre> <br>  Each time you call the <code>count()</code> function, the JavaScript engine creates a new lexical environment for this function and increments the <code>counter</code> variable, which leads to changes in the lexical environment of the <code>getCounter()</code> function. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  In this article, we talked about what closures are and dismantled the underlying JavaScript mechanisms underlying them.  Closures are one of the most important fundamental concepts of JavaScript; every JS developer should understand it.  Understanding closures is one step in the path to writing efficient and high-quality applications. <br><br>  <b>Dear readers!</b>  If you have experience in JS development, please share practical examples of how to use closures with beginners. <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/424967/">https://habr.com/ru/post/424967/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../424955/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ332 (September 24 - 30, 2018)</a></li>
<li><a href="../424957/index.html">Generate images from text using AttnGAN</a></li>
<li><a href="../424961/index.html">MTA-STS for Postfix</a></li>
<li><a href="../424963/index.html">Zuckerberg Finance: Building Tools for Science Together</a></li>
<li><a href="../424965/index.html">Develop React applications using ReasonReact</a></li>
<li><a href="../424969/index.html">Node.js Part 9 Guide: Working with the File System</a></li>
<li><a href="../424971/index.html">Habrokast "Sunset Manually" # 1. We are trying to set up an environment for developing toys under Windows</a></li>
<li><a href="../424973/index.html">Face Detection Video: Raspberry Pi and Neural Compute Stick</a></li>
<li><a href="../424975/index.html">SIEM depths: out-of-box correlations. Part 2. Data schema as a reflection of the ‚Äúworld‚Äù model</a></li>
<li><a href="../424977/index.html">Learning from mistakes: optimizing applications in the App Store and Google Play</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>