<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About Parboiled (Part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 2. Comparison of the text 

 In the second part of the loop, we‚Äôll talk about the basic rules for parsing characters in Parboiled. We will not to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About Parboiled (Part 2)</h1><div class="post__text post__text-html js-mediator-article">  <strong>Part 2. Comparison of the text</strong> <br><br>  In the second part of the loop, we‚Äôll talk about the basic rules for parsing characters in Parboiled.  We will not touch all the rules - there is documentation for this, I just want you to feel confident with the basic syntax of the rules used in Parboiled. <br><br>  To consolidate knowledge, we will write a simple recognizer for simple grammar.  It is a recognizer, not a full-fledged parser, since it will only match the input text with the rules described by us (also called <em>products</em> ), but will not extract any values ‚Äã‚Äãfrom the associated text.  The recognizer may be useful in and of itself, as it may work as a validator: if the input was incorrect, the recognizer will let know about it and tell you what went wrong and where.  And our recognizer will be very cool when we learn how to extract parsed values, and where does some kind of ‚Äúvalue stack‚Äù.  Here we go? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <strong>Cycle structure:</strong> <br><br><ul><li>  <a href="http://habrahabr.ru/post/270233">Part 1. Why Parboiled?</a> </li><li>  Part 2. Comparison of the text </li><li>  <a href="http://habrahabr.ru/post/270609">Part 3. Data Extraction</a> </li><li>  <a href="http://habrahabr.ru/post/271003">Part 4. The harsh reality</a> </li></ul><br><a name="habracut"></a><br><br><h1>  Preparatory work </h1><br>  Before starting work with the library, add it to the classpath.  In Maven, for example, it is done like this: <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>org.parboiled<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>parboiled_2.11<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span>2.1.0<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  I use Scala 2.11, but there are artifacts for 2.10 as well. <br><br><h1>  Rule Description Language (Rule DSL) </h1><br>  All Parboiled functionality is implemented over the syntax of the Scala language using specialized DSL.  Therefore, the description of the parser is really nothing more than a declaration of a class derived from <code>org.parboiled.Parser</code> .  As an example, let's write a parser that does nothing that does not prevent it from existing and enjoying life: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.parboiled2._ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyParser</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">val input: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">ParserInput</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     }</span></span></code> </pre> <br>  DSL constructs and a number of useful classes are added to the visibility area with just one import directive.  I want to note that the presence of the <code>input</code> parameter in the constructor is mandatory: this means that for each new set of input data you need to create a new parser object.  At first, it scared me very much, but I stopped being afraid when I saw how fast it works. <br><br><h2>  Rules for individual characters </h2><br>  So, when we already have a worthless parser, we need to add a few rules to it, according to which it will process the data.  If you have worked with Parboiled1, you can simply scroll through this section, as my explanations may seem unnecessarily detailed. <br><br>  Let's start with the terminals.  This term will be used in the future, so we will try to give it a definition here (not quite, however, strict): <br><br><blockquote>  The terminal is the simplest atomic rule that does not require additional definitions. <br></blockquote><br>  Let's describe two simplest rules: the first should recognize a certain known symbol, the second - the line: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyCharRule</span></span></span><span class="hljs-function"> </span></span>= rule { ch('a') } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyStringRule</span></span></span><span class="hljs-function"> </span></span>= rule { str(<span class="hljs-string"><span class="hljs-string">"string"</span></span>) }</code> </pre> <br>  Each time to designate their intentions in this way is very tiring.  And here we come to the aid of the implicit conversion mechanism (implicit conversions), which allows us to make the rules shorter: <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyCharRule</span></span></span><span class="hljs-function"> </span></span>= rule { 'a' } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyStringRule</span></span></span><span class="hljs-function"> </span></span>= rule { <span class="hljs-string"><span class="hljs-string">"string"</span></span> }</code> </pre><br>  Strings are matched with exact case sensitivity.  However, there are many non-case-sensitive languages ‚Äã‚Äã(for example, SQL).  For them, there is a rule of <code>ignoreCase</code> , which matches the input string regardless of its register.  The string passed to it must be in lower case: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StringWithCaseIgnored</span></span></span><span class="hljs-function"> </span></span>= rule { ignoreCase(<span class="hljs-string"><span class="hljs-string">"string"</span></span>) }</code> </pre> <br>  More details about the rules (or ‚Äúproducts‚Äù, if you like it that much) will be explained in the next article.  All the above (and below) rules are of type <code>Rule0</code> .  The rules are of different types, but now we need to know only what <code>Rule0</code> means that the rule matches the input string with itself and says whether it matches or not.  We did not specify the type because the mechanism for deducing the types of the language is still easy to handle by itself.  However, nothing prevents us from specifying the type explicitly: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StringWithCaseIgnored</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Rule0</span></span> = rule { ignoreCase(<span class="hljs-string"><span class="hljs-string">"string"</span></span>) }</code> </pre> <br>  There are special terminals in Parboiled (they are syntactic predicates): <br><br><ul><li>  <code>ANY</code> - any character except <code>EOI</code> . </li><li>  <code>EOI</code> (End of Input) is a virtual symbol-marker for the end of input, which you definitely want to add to the main rule of your parser.  <code>EOI</code> defined as: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">EOI</span></span> = '\uFFFF'</code> </pre> </li></ul><br>  Although the U + FFFF character is reserved for internal use by the Unicode standard, in practice it can easily occur in user input and change the behavior of the parser.  So be careful with the text that hits the input. <br><br>  In addition, if you do not add an <code>EOI</code> at the end of the main rule and an error occurs during the mapping, you will not know about it, since the parser will assume that the input data has not yet ended and will expect new data to arrive.  Therefore, whatever you gave to the entrance, a meaningless Success is waiting for you at the exit. <br><br>  From the rules of <code>chr</code> and <code>str</code> it is hardly possible to make a useful parser, so the first step to meaningfulness will be the ability to determine the <em>range of</em> valid symbols.  Parboiled2 makes it very easy: <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Digit</span></span></span><span class="hljs-function"> </span></span>= rule { '<span class="hljs-number"><span class="hljs-number">0</span></span>' - '<span class="hljs-number"><span class="hljs-number">9</span></span>' } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AlphaLower</span></span></span><span class="hljs-function"> </span></span>= rule { 'a' - 'z' }</code> </pre><br>  Both of these rules match at most one character from a range at a time (or do not match one).  Although it is very simple to write these two rules specifically in PB2, there is no need to do this: they are already defined in the <code>CharPredicate</code> object.  Parboiled1, on the contrary, forced to manually create these rules, almost every time you write another parser.  Therefore, I carried my library of primitives from project to project (I am sure that I did not do this alone).  Now my library has noticeably cleared up thanks to the emergence of <code>CharPredicate</code> .  It includes, for example, the following rules (I think that it will be clear from the names which categories of symbols they correspond to): <br><br><ul><li>  <code>CharPredicate.All</code> (works almost the same as <code>ANY</code> , but shows worse performance on large ranges of characters); </li><li>  <code>CharPredicate.Digit</code> ; </li><li>  <code>CharPredicate.Digit19</code> ; </li><li>  <code>CharPredicate.HexDigit</code> and many other rules. </li></ul><br>  If you are not satisfied with the existing rules, you can always define your own character predicate, for this you need to use the <code>from</code> method: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">CharPredicate</span></span> from (_.isSpaceChar)</code> </pre> <br>  In addition, for the symbolic predicates, the statements <code>except</code> ( <code>--</code> ) and <code>union</code> ( <code>++</code> ) are defined, which were not in PB1.  Personally, I suffered greatly from this absence: I had to close the rule ‚Äúfrom the other side‚Äù, listing all the black or white list of characters depending on the situation.  The rule can also be called a difference, since its role is the same as that of the <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D0%25B7%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C_%25D0%25BC%25D0%25BD%25D0%25BE%25D0%25B6%25D0%25B5%25D1%2581%25D1%2582%25D0%25B2">difference of two sets</a> . <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,    . def AllButQuotes = rule { CharPredicate.Visible -- "\"" -- "'" } //     .  ,  // AlphaNum    . def ValidIdentifier = rule { CharPredicate.Alpha ~ zeroOrMore(CharPredicate.AlphaNum ++ "_") }</span></span></code> </pre> <br>  It will be useful to know about two other rules: <code>anyOf</code> and <code>noneOf</code> .  They are very similar to <code>except</code> and <code>union</code> , but work on the whole character space of <code>ANY</code> .  And most importantly: in this space, they work faster.  These functions can take as input a string consisting of enumerations of characters.  For example: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">// ,       . def ArithmeticOperation = rule { anyOf("+-*/^") } //  ,      EOI. def WhiteSpaceChar = rule { noneOf(" \t\n") }</span></span></code> </pre> <br>  Sometimes the question arises, what to choose: <code>anyOf</code> / <code>noneOf</code> or <code>CharPredicate</code> ?  The predefined character predicate will work faster for 7-bit ASCII characters.  ‚ÄúPredefined‚Äù was written for a reason, and Part 4 of the Best Practices section will explain why.  However, for very large character ranges, <code>CharPredicate</code> behaves frankly bad, and then <code>anyOf</code> and <code>noneOf</code> should come to the <code>noneOf</code> . <br><br><h2>  Chains of rules </h2><br><h3>  N.times </h3><br>  Matching single characters is not interesting, so we move on to more complex rules.  Let's start with <code>times</code> , which allows you to match one rule several times in a row.  The number of repetitions must be accurate and known in advance. <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BartLearningParboiled</span></span></span><span class="hljs-function"> </span></span>= rule { <span class="hljs-number"><span class="hljs-number">100</span></span> times <span class="hljs-string"><span class="hljs-string">"I will never write a parser again. "</span></span> }</code> </pre> <br>  Some grammars require a hard range of repetitions, for example, <a href="http://www.chukfamily.ru/Kornei/Prosa/Ot2do5/Ot2do5.htm">from two to five</a> .  In the new Parboiled this can be easily arranged: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FutureOfCxx</span></span></span><span class="hljs-function"> </span></span>= rule { '<span class="hljs-type"><span class="hljs-type">C</span></span>' ~ (<span class="hljs-number"><span class="hljs-number">2</span></span> to <span class="hljs-number"><span class="hljs-number">5</span></span>).times('+') }</code> </pre> <br>  And in the old - there is a rule <code>nTimes</code> , which requires specifying the exact number of repetitions.  In case the exact number of repetitions is not known in advance, the next couple of rules will help you. <br><br><h3>  zeroOrMore </h3><br>  As you may have guessed from the name, zeroOrMore matches a sequence of zero and more occurrences of the specified rule.  The attentive reader has already noticed this rule in the examples and it most likely seemed familiar to him: in regular expressions, the exact same operation is indicated by an asterisk, and fans of academic terminology also know what it is called the <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B2%25D0%25B5%25D0%25B7%25D0%25B4%25D0%25B0_%25D0%259A%25D0%25BB%25D0%25B8%25D0%25BD%25D0%25B8">Kleene star</a> .  In any case, using this rule is very simple: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Whitespace</span></span></span><span class="hljs-function"> </span></span>= rule { anyOf(<span class="hljs-string"><span class="hljs-string">" \n\t"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OptWs</span></span></span><span class="hljs-function"> </span></span>= rule { zeroOrMore(<span class="hljs-type"><span class="hljs-type">Whitespace</span></span>) }</code> </pre> <br><h3>  oneOrMore </h3><br>  A rule similar to the previous one.  It does almost the same thing as <code>zeroOrMore</code> , but requires at least one repetition to be present in the input data.  Identical to plus wedges for regular grammars. <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnsignedInteger</span></span></span><span class="hljs-function"> </span></span>= rule { oneOrMore(<span class="hljs-type"><span class="hljs-type">CharPredicate</span></span>.<span class="hljs-type"><span class="hljs-type">Digit</span></span>) }</code> </pre> <br><h3>  Chain delimiter: separatedBy </h3><br>  Often we have to deal with the case when the set of elements is written in a row through some separator: this is CSV, definitions of lists or arrays, and enumeration of function arguments separated by commas, and much more.  In Parboiled2, parsing of such sequences is done easily and naturally: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CommaSeparatedNumbers</span></span></span><span class="hljs-function"> </span></span>= rule { oneOrMore(<span class="hljs-type"><span class="hljs-type">UnsignedInteger</span></span>).separatedBy(<span class="hljs-string"><span class="hljs-string">","</span></span>) }</code> </pre> <br>  However, the first version uses a less elegant syntax for this: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CommaSeparatedNumbers</span></span></span><span class="hljs-function"> </span></span>= rule { oneOrMore(<span class="hljs-type"><span class="hljs-type">UnsignedInteger</span></span>, separator = <span class="hljs-string"><span class="hljs-string">","</span></span>) }</code> </pre> <br><h3>  Sequence operator (~) </h3><br>  To specify a sequence of rules, use the <code>~</code> operator.  In regular expressions, there is no need for such an operator; this fact is written there directly, just as in some BNF variants.  For example, let's write a (extremely simplified) rule that matches the date of a particular format: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">CharPredicate</span></span>.<span class="hljs-type"><span class="hljs-type">Digit</span></span> <span class="hljs-comment"><span class="hljs-comment">//     : "yyyy-mm-dd" def SimplifiedRuleForDate = rule { Year ~ "-" ~ Month ~ "-" ~ Day } def Year = rule { Digit ~ Digit ~ Digit ~ Digit } def Month = rule { Digit ~ Digit } def Day = rule { Digit ~ Digit }</span></span></code> </pre><br><br>  As you can see, the rule is simplified as much as possible, and I am perfectly aware of the fact that we can have 99 days and 99 months.  It does not make sense to leave all checks at the parser level: we will still pass the matched string to the input of some class for working with the date and time, which will be guessed to perform validation, and return the result wrapped in Option.  But the grammar that we noticeably simplify.  Attempting to force the parser to perform all possible and impossible checks often leads to <a href="http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html">similar results</a> . <br><br><h3>  "Optional" rule (optional) </h3><br>  If the <code>zeroOrOne</code> rule <code>zeroOrOne</code> , then this would be <code>optional</code> : either there is one entry, or there are no entries at all.  Let's analyze the following example: in different operating system families, the end of line marker is encoded differently.  For example, in Unix-like operating systems, only the <code>\n</code> character is needed, whereas in Windows a sequence of two characters is used historically: <code>\r</code> and <code>\n</code> .  And if we want to process text created on any of these systems, then we can use the following rule for the end of the line: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Newline</span></span></span><span class="hljs-function"> </span></span>= rule { optional('\r') ~ '\n' }</code> </pre> <br><h3>  Ordered selection (|) </h3><br>  Analog operator <code>|</code>  in regular expressions, it is not without reason called the <em>ordered</em> choice.  Suppose that we need to recognize a number that may have a sign, but maybe it cannot.  A sign, if any, can be of two types: positive and negative, we will first deal with it: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Signum</span></span></span><span class="hljs-function"> </span></span>= rule { '+' | '-' }</code> </pre> <br>  The sign may be completely absent in the record of a positive number: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MaybeSign</span></span></span><span class="hljs-function"> </span></span>= rule { optional(<span class="hljs-type"><span class="hljs-type">Signum</span></span>) }</code> </pre> <br>  Then the number itself in any case will be presented as a sequence of possible occurrences of the sign of the number and its modulus - a number without a sign: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Integer</span></span></span><span class="hljs-function"> </span></span>= rule { <span class="hljs-type"><span class="hljs-type">MaybeSign</span></span> ~ <span class="hljs-type"><span class="hljs-type">UnsignedInteger</span></span> }</code> </pre> <br>  The order of enumeration of options in the <code>Signum</code> rule is important: the very first option that is chosen is selected, which excludes the possibility of grammar ambiguity.  And yes, this is how all PEG parsers work without exception.  So, if you need to parse an expression in the C language, you need to start the enumeration with the longest operations so that they match first, as the standard prescribes.  In simple terms, a rule might look like this: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operator</span></span></span><span class="hljs-function"> </span></span>= rule { <span class="hljs-string"><span class="hljs-string">"+="</span></span> | <span class="hljs-string"><span class="hljs-string">"-="</span></span> | <span class="hljs-string"><span class="hljs-string">"*="</span></span> | <span class="hljs-string"><span class="hljs-string">"/="</span></span> | <span class="hljs-string"><span class="hljs-string">"%="</span></span> | <span class="hljs-string"><span class="hljs-string">"&amp;="</span></span> | <span class="hljs-string"><span class="hljs-string">"^="</span></span> | <span class="hljs-string"><span class="hljs-string">"|="</span></span> | <span class="hljs-string"><span class="hljs-string">"&lt;&lt;="</span></span> | <span class="hljs-string"><span class="hljs-string">"&gt;&gt;="</span></span> | <span class="hljs-string"><span class="hljs-string">"&lt;&lt;"</span></span> | <span class="hljs-string"><span class="hljs-string">"&gt;&gt;"</span></span> | <span class="hljs-string"><span class="hljs-string">"&lt;="</span></span> | <span class="hljs-string"><span class="hljs-string">"&gt;="</span></span> | <span class="hljs-string"><span class="hljs-string">"=="</span></span> | <span class="hljs-string"><span class="hljs-string">"!="</span></span> | <span class="hljs-string"><span class="hljs-string">"||"</span></span> | <span class="hljs-string"><span class="hljs-string">"&amp;&amp;"</span></span> | <span class="hljs-string"><span class="hljs-string">"-&gt;"</span></span> | <span class="hljs-string"><span class="hljs-string">"++"</span></span> | <span class="hljs-string"><span class="hljs-string">"--"</span></span> | <span class="hljs-string"><span class="hljs-string">"&lt;"</span></span> | <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span> | <span class="hljs-string"><span class="hljs-string">"+"</span></span> | <span class="hljs-string"><span class="hljs-string">"-"</span></span> | <span class="hljs-string"><span class="hljs-string">"&amp;"</span></span> | <span class="hljs-string"><span class="hljs-string">"|"</span></span> | <span class="hljs-string"><span class="hljs-string">"."</span></span> | <span class="hljs-string"><span class="hljs-string">"*"</span></span> | <span class="hljs-string"><span class="hljs-string">"/"</span></span> | <span class="hljs-string"><span class="hljs-string">"!"</span></span> | <span class="hljs-string"><span class="hljs-string">"~"</span></span> | <span class="hljs-string"><span class="hljs-string">"^"</span></span> | <span class="hljs-string"><span class="hljs-string">"="</span></span> | <span class="hljs-string"><span class="hljs-string">","</span></span> }</code> </pre> <br>  The order of enumeration can be very different, but you need to ensure that in it <code>+</code> always goes after <code>+=</code> and <code>++</code> , and <code>&lt;</code> - after <code>&lt;=</code> and <code>&lt;&lt;</code> (and <code>&lt;&lt;</code> , in turn, after <code>&lt;&lt;=</code> ).  Otherwise, it may happen that the composite assignment operator <code>&lt;&lt;=</code> parses into the sequence [ <code>&lt;=</code> , <code>=</code> ], or even at all [ <code>&lt;</code> , <code>&lt;</code> , <code>=</code> ]. <br><br>  If the selection rule becomes excessively complex and we do not want to rely on the order of its elements, it is worthwhile to group them according to common prefixes (factor the parser): <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Operators</span></span></span><span class="hljs-function"> </span></span>= rule { (<span class="hljs-string"><span class="hljs-string">"+"</span></span> ~ optional(<span class="hljs-string"><span class="hljs-string">"="</span></span> | <span class="hljs-string"><span class="hljs-string">"+"</span></span>)) | (<span class="hljs-string"><span class="hljs-string">"&lt;"</span></span> ~ optional(<span class="hljs-string"><span class="hljs-string">"="</span></span> | (<span class="hljs-string"><span class="hljs-string">"&lt;"</span></span> ~ optional(<span class="hljs-string"><span class="hljs-string">"="</span></span>)))) | ... }</code> </pre> <br>  We note, however, that none of our examples will be able to automatically take into account the priorities of the operators, for this we will have to resort to more sophisticated rules. <br><br><h3>  A little sugar </h3><br>  For <code>optional</code> , <code>oneOrMore</code> and <code>zeroOrMore</code> there is syntactic sugar, which makes definitions even shorter: <code>.?</code>  <code>.+</code> and <code>.*</code> .  Please use them wisely: if you abuse them, your rules will be a little better read than regulars.  With the help of these "labels" we can make the description of our rules less verbose: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">CharPredicate</span></span>.<span class="hljs-type"><span class="hljs-type">Digit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SignedInteger</span></span></span><span class="hljs-function"> </span></span>= rule { (<span class="hljs-string"><span class="hljs-string">"+"</span></span> | <span class="hljs-string"><span class="hljs-string">"-"</span></span>).? ~ <span class="hljs-type"><span class="hljs-type">Digit</span></span>.+ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Newline</span></span></span><span class="hljs-function"> </span></span>= rule { '\r'.? ~ '\n' } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OptWs</span></span></span><span class="hljs-function"> </span></span>= rule { <span class="hljs-type"><span class="hljs-type">WhitespaceChar</span></span>.* }</code> </pre> <br><br><h3>  Run parser </h3><br>  In order to force the written parser to do at least something useful, you need to call the <code>run</code> method of its main (root) rule.  If you are writing a unit test for a parser, then it may be worthwhile to call this method for other rules.  Brackets after the method are required. <br><br>  Let's get our useless parser to work, able to match only one string constant.  So, our parser is defined as follows (do not forget about <code>EOI</code> ): <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.parboiled2._ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyParser</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">val input: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">ParserInput</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyStringRule</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Rule0</span></span> = rule { ignoreCase(<span class="hljs-string"><span class="hljs-string">"match"</span></span>) ~ <span class="hljs-type"><span class="hljs-type">EOI</span></span> } }</code> </pre> <br>  Now, somewhere in another place, we will create several instances of parsers and feed them with different data: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MyParser</span></span>(<span class="hljs-string"><span class="hljs-string">"match"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> p2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MyParser</span></span>(<span class="hljs-string"><span class="hljs-string">"Match"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> p3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MyParser</span></span>(<span class="hljs-string"><span class="hljs-string">"much"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// -  scala.util.Try p1.MyStringRule.run() // Success p2.MyStringRule.run() // Success p3.MyStringRule.run() // Failure</span></span></code> </pre> <br>  Passing rules in Parboiled2 is much easier than in Parboiled1, for which there is a whole zoo of runners (parser runners) that have to be additionally called.  For more information, please refer to the Error Reporting section of part 4. <br><br><h3>  Nested data structures </h3><br>  Parsing recursive structures is something that Parboiled can and regular expressions cannot.  In Parboiled, this is obtained naturally and naturally, which we will demonstrate in subsequent examples.  The only additional effort that is required of you is to explicitly declare the type of rules involved in the recursion. <br><br>  Analysis of recursive structures is usually illustrated with an example calculator of arithmetic expressions.  In my opinion, the example is not at all vivid.  Therefore, we consider a fictional configuration file format consisting of named blocks that contain key-value pairs. <br><br><h1>  BKV format (Block-Key-Value) </h1><br>  As an example, the ‚ÄúBKV‚Äù format, which was coined specifically for this tutorial, will be used.  It was inspired by the <a href="">HOCON</a> format and, in fact, is its subset.  A BKV consists of key-value pairs and blocks within which pairs can be placed.  It looks like this: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">server</span></span>.name = "webserver" <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> { port = "8080" address = "192.168.88.88" settings { greeting_message = "Hello!\n It's me!" } }</code> </pre> <br>  As you can see, the format is simple and straightforward, although escaping strings can frighten those who have never written parsers.  Escaping is very common when parsing, so we will definitely and in detail consider it. <br><br><h2>  Screened lines </h2><br>  In order to not have problems with whitespace and non-printable characters in most grammars, the strings are enclosed in double or single quotes (or some kind of similarity, for example, opening and closing angle brackets can be used).  Non-printable characters and quotes are escaped. <br><br>  In order to write a recognizer of shielded strings, you need to decide on the following syntax elements: <br><br><ul><li>  The characters that open and close the string (in our case it is the same character - a double quote). </li><li>  The escape character (in our case, the backslash character). </li><li>  A mnemonic character set for non-printable characters (we will support, at a minimum, <code>'\n'</code> , <code>'\t'</code> and <code>'\v'</code> ). </li></ul><br>  First, let's try to describe a rule for a quota line without escaping: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OverlySimplifiedQuotedString</span></span></span><span class="hljs-function"> </span></span>= rule { '<span class="hljs-string"><span class="hljs-string">"' ~ zeroOrMore(AllowedChar) ~ '"</span></span>' }</code> </pre> <br>  Since empty strings are also possible, we use the <code>zeroOrMore</code> rule between quotes.  Obviously, a double quote is not included in the list of valid characters.  What is allowed then?  Anything that is not prohibited.  Therefore, for our case, the list of allowed characters is as follows: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllowedChar</span></span></span><span class="hljs-function"> </span></span>= rule { noneOf(<span class="hljs-string"><span class="hljs-string">"\""</span></span>) }</code> </pre> <br>  You can live without a double quote, but it's hard.  But what happens if we add a quote inside the string?  Upon encountering it, the parser will think that the line has ended and explode with an error message on the next character. <br><br>  The escape character warns the parser that the next character is special.  The algorithm looks like this: the parser expects one of the allowed characters or a shielded sequence, and the shielded sequence consists of the shielding character and the operator of the choice of one of the characters following it: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllowedChar</span></span></span><span class="hljs-function"> </span></span>= rule { noneOf(<span class="hljs-string"><span class="hljs-string">"\"\\"</span></span>) | <span class="hljs-type"><span class="hljs-type">EscapeSequence</span></span> } <span class="hljs-comment"><span class="hljs-comment">//  : \", \\, \n, \a, \f, \v. def EscapeSequence = rule { '\' ~ anyOf("\"\\nafv") }</span></span></code> </pre> <br>  Having understood how this works, you can proceed to writing the final version of the rules for screening.  To do this, I propose to create a dedicated trait: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.parboiled2._ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QuotedStringSupport</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">CharsToBeEscaped</span></span> = <span class="hljs-string"><span class="hljs-string">"abfnrtv\\\""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">Backslash</span></span> = '\\' <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">AllowedChars</span></span> = <span class="hljs-type"><span class="hljs-type">CharPredicate</span></span>.<span class="hljs-type"><span class="hljs-type">Printable</span></span> -- <span class="hljs-type"><span class="hljs-type">Backslash</span></span> -- <span class="hljs-string"><span class="hljs-string">"\""</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QuotedStringSupport</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">QuotedStringSupport</span></span>._ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QuotedString</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Rule0</span></span> = rule { '<span class="hljs-string"><span class="hljs-string">"' ~ QuotedStringContent ~ '"</span></span>' } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QuotedStringContent</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Rule0</span></span> = rule { oneOrMore(<span class="hljs-type"><span class="hljs-type">AllowedChars</span></span> | <span class="hljs-type"><span class="hljs-type">DoubleQuotedStringEscapeSequence</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoubleQuotedStringEscapeSequence</span></span></span><span class="hljs-function"> </span></span>= rule { '\\' ~ anyOf(<span class="hljs-type"><span class="hljs-type">CharsToBeEscaped</span></span>) } }</code> </pre> <br>  Now, when we have dealt with the lines and selected the corresponding functionality in a separate treyt, let's move on to the format itself. <br><br><h2>  Auxiliary terminals </h2><br>  There are two approaches to writing parsers: ‚Äúfrom the general to the particular‚Äù and ‚Äúfrom the particular to the general.‚Äù  Typically, grammars are described according to the first, but this is only a tutorial, so let's start with smaller details and then generalize. <br><br>  We begin the description with auxiliary elements, namely, with spaces.  In our case, the spaces will be the characters: '', '' and ''.  Of course, there are more whitespace characters in nature, but in the example we will limit ourselves to three.  You can deal with spaces in various ways: <br><br><ul><li>  list the characters through an ordered selection operator; </li><li>  declare your <code>CharPredicate</code> containing these three characters; </li><li>  use <code>anyOf</code> . </li></ul><br>  We will use the latter.  In this case, we will take into account that in some places there may be several spaces, in others there may not be at all, and in some places there must be spaces (but our format does not require mandatory spaces): <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">WhitespaceChars</span></span> = <span class="hljs-string"><span class="hljs-string">"\n\t "</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WhiteSpace</span></span></span><span class="hljs-function"> </span></span>= rule { anyOf(<span class="hljs-type"><span class="hljs-type">WhitespaceChars</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OptWs</span></span></span><span class="hljs-function"> </span></span>= rule { zeroOrMore(<span class="hljs-type"><span class="hljs-type">WhiteSpace</span></span>) }</code> </pre> <br>  The rule describing the line feed we declared earlier: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Newline</span></span></span><span class="hljs-function"> </span></span>= rule { optional('\r') ~ '\n' }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The key and the block name represent an identifier similar to the one you can find in various programming languages. </font><font style="vertical-align: inherit;">The identifier must begin either with a letter of the English alphabet (case does not matter) or with an underscore. </font><font style="vertical-align: inherit;">In the middle can contain numbers as well as letters of the English alphabet (lowercase and uppercase). </font><font style="vertical-align: inherit;">The entry point in the middle of the identifier is also valid. </font><font style="vertical-align: inherit;">Before declaring a key, we will declare a rule describing an identifier. </font><font style="vertical-align: inherit;">(Similar rules will apply for block name). </font><font style="vertical-align: inherit;">We need two symbolic predicates: for the first and subsequent characters.</font></font><br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//    val IdentifierFirstChar = CharPredicate.Alpha ++ '_' //    val IdentifierChar = CharPredicate.AlphaNum ++ '.' ++ '_'</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's also declare the beginning and end of the block: </font></font><br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">BlockBeginning</span></span> = '{' <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">BlockEnding</span></span> = '}'</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now that we have all the necessary auxiliary terminals, let's do bigger blocks. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pairs key ‚Äî value </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We now turn to the syntax of key ‚Äì value pairs. </font><font style="vertical-align: inherit;">We require that the key be a valid identifier, as described above, and the value was a quoted string, as also described above. </font><font style="vertical-align: inherit;">So let's start by identifying the identifier:</font></font><br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Identifier</span></span></span><span class="hljs-function"> </span></span>= rule { <span class="hljs-type"><span class="hljs-type">IdentifierFirstChar</span></span> ~ zeroOrMore(<span class="hljs-type"><span class="hljs-type">IdentifierChar</span></span>) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhaps we should not have set the identifier with a fairly rigid rule, but most grammars with which you will most likely encounter use similar rules. </font><font style="vertical-align: inherit;">For example, identifiers are not allowed to begin with a digit, because of the presence of integer literals, various characters can be valid operators. </font><font style="vertical-align: inherit;">The rule describing the key will look like this:</font></font><br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Key</span></span></span><span class="hljs-function"> </span></span>= rule { <span class="hljs-type"><span class="hljs-type">Identifier</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To describe the value, use the already existing rule (for this we just need to mix the trait we wrote earlier): </font></font><br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Value</span></span></span><span class="hljs-function"> </span></span>= rule { <span class="hljs-type"><span class="hljs-type">DoubleQuotedString</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we describe the rule for the whole pair. </font><font style="vertical-align: inherit;">Here it is worth recalling once again that Parboiled is a PEG, it follows from this that we constantly need to remember the spaces and inform the rule about the places where they can occur.</font></font><br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">KeyValuePair</span></span></span><span class="hljs-function"> </span></span>= rule { <span class="hljs-type"><span class="hljs-type">Key</span></span> ~ <span class="hljs-type"><span class="hljs-type">OptWs</span></span> ~ <span class="hljs-string"><span class="hljs-string">"="</span></span> ~ <span class="hljs-type"><span class="hljs-type">OptWs</span></span> ~ <span class="hljs-type"><span class="hljs-type">Value</span></span> }</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nested blocks </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A block is limited to curly brackets and can contain inside both key-value pairs and other blocks. </font><font style="vertical-align: inherit;">Therefore, first we need to erase the differences between blocks and key-value pairs, calling both those and other nodes (nodes) of the syntactic tree.</font></font> This is done by the following code: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//     ,   ! def Node: Rule0 = rule { KeyValuePair | Block }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Since both the block and the root structure consist of a list of nodes, we need to declare a rule for this list: </font></font><br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Nodes</span></span></span><span class="hljs-function"> </span></span>= rule { <span class="hljs-type"><span class="hljs-type">OptWs</span></span> ~ zeroOrMore(<span class="hljs-type"><span class="hljs-type">Node</span></span>).separatedBy(<span class="hljs-type"><span class="hljs-type">Newline</span></span> ~ <span class="hljs-type"><span class="hljs-type">OptWs</span></span>) ~ <span class="hljs-type"><span class="hljs-type">OptWs</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optional spaces can be before the list of nodes, and after it, and between its individual elements, so we have so many occurrences in the rule </font></font><code>MaybeWs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Now we define the name of the block - this is all the same identifier that is used in the name of the key:</font></font><br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BlockName</span></span></span><span class="hljs-function"> </span></span>= rule { <span class="hljs-type"><span class="hljs-type">Identifier</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finally, we have everything necessary for declaring a block, therefore we will declare a block: </font></font><br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Block</span></span></span><span class="hljs-function"> </span></span>= rule { <span class="hljs-type"><span class="hljs-type">BlockName</span></span> ~ <span class="hljs-string"><span class="hljs-string">"{"</span></span> ~ <span class="hljs-type"><span class="hljs-type">Nodes</span></span> ~ <span class="hljs-string"><span class="hljs-string">"}"</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remember we defined </font></font><code>BlockBeginning</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>BlockEnding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">We use them in the ad:</font></font><br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Block</span></span></span><span class="hljs-function"> </span></span>= rule { <span class="hljs-type"><span class="hljs-type">BlockName</span></span> ~ <span class="hljs-type"><span class="hljs-type">BlockBeginning</span></span> ~ <span class="hljs-type"><span class="hljs-type">Nodes</span></span> ~ <span class="hljs-type"><span class="hljs-type">BlockEnding</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notice that it </font></font><code>Block</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">refers to a rule </font></font><code>Nodes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that will refer to a Node rule. A Node can be referred to as a Block rule, which causes a loop. Therefore, we need to explicitly specify the type of the rule, reassuring Parboiled. Since we are writing a recognizer, the type of the rule will always be Rule0 (more details on the types of rules will be in the next article). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, we have everything, lacking only the entry point, or root (root), which is also nothing more than a list of nodes for which we already have a ready-made rule. We use it, not forgetting to take into account possible spaces and complete the rule with the symbol </font></font><code>EOI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Root</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Rule0</span></span> = rule { <span class="hljs-type"><span class="hljs-type">Nodes</span></span> ~ <span class="hljs-type"><span class="hljs-type">EOI</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So we wrote a recognizer. </font><font style="vertical-align: inherit;">You can view its full source code </font></font><a href="https://gist.github.com/ppopoff/1bbf022327750f37ebcc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since it‚Äôs very rare to only compare values ‚Äã‚Äãin practice, and constantly extracting them from the text, in the next article I will tell you exciting stories about how this is done, as well as the types of rules. </font><font style="vertical-align: inherit;">In it, we will bring our resolver to the state of a full parser.</font></font></div><p>Source: <a href="https://habr.com/ru/post/270531/">https://habr.com/ru/post/270531/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270521/index.html">Docker 1.9 + Weave 1.2.1 bridge mode</a></li>
<li><a href="../270523/index.html">Colocation in theory and practice</a></li>
<li><a href="../270525/index.html">Cryptographers invent new ways to blackmail users</a></li>
<li><a href="../270527/index.html">Official Firebird 3.0 Release Candidate 1 and Beta Documentation for Firebird 3.0</a></li>
<li><a href="../270529/index.html">As we wrote AI for the Jackal, and why he has schizophrenia</a></li>
<li><a href="../270537/index.html">How I became an android developer without a core education, simultaneously hindering concrete</a></li>
<li><a href="../270541/index.html">How to calculate the range of communication equipment Ubiquiti. New version of the calculator AirLink</a></li>
<li><a href="../270543/index.html">TensorFlow: Google's machine learning, now smarter for everyone</a></li>
<li><a href="../270545/index.html">Declarative C ++ programming</a></li>
<li><a href="../270547/index.html">Hidden dependencies as a design ‚Äúsmell‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>