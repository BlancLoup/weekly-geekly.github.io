<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Detailed introduction to rvalue links for those who lacked a short</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instead KDPV - short drama to attract attention, based on real events. You can safely skip it and go to the article that will help you understand the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Detailed introduction to rvalue links for those who lacked a short</h1><div class="post__text post__text-html js-mediator-article"><p>  Instead KDPV - short drama to attract attention, based on real events.  You can safely skip it and go to the article that will help you understand the rvalue links, displacement constructors, universal links, perfect forwarding, etc. </p><br><h1 id="drama-v-treh-deystviyah">  Drama in three acts </h1><br><p>  <strong>First act</strong> </p><br><p>  <em>Compiler</em>  Local object x of type T, living on the stack, you are sentenced to seize from you all the property due to the fact that you will not use it for the rest of your life. </p><br><p>  <em>Object x</em> .  What?  I am not a temporary facility, I have a permanent registration, you do not have the right! </p><br><p>  <em>Compiler</em>  Nobody evicts you.  But according to the eleventh edition of the standard code, all your belongings will be transferred to another object, which needs them more. </p><br><p>  <em>Object x</em> .  And how do you do it?  All my data is securely encapsulated, I will not allow anyone to treat them unceremoniously.  If you really need them, then let the copy designer come with his flash drive, I'll copy to him. </p><br><a name="habracut"></a><br><p>  <em>Constructor</em> .  It is long and ineffective. </p><br><p>  <em>Object x</em> .  Maybe you are going to break the reinterpret_cast window for me, and rummage in the dark? </p><br><p>  <em>Compiler</em>  No, no, your case is too ordinary to use the services of collectors.  We just call the std :: move function, it puts static_cast &lt;T &amp;&amp;&gt; on you, and everyone will think that you are a temporary object, that is, an rvalue expression. </p><br><p>  <em>Object x</em> .  So what, static_cast does not affect me.  As soon as I get to the first point, I will take it off. </p><br><p>  <em>Compiler</em>  I have no doubt, but sooner than you do this, you will encounter a displacement designer already waiting outside the door.  It seems you have not had time to meet him ... </p><br><p>  <strong>Second act</strong> </p><br><p>  <em>T (T &amp;&amp;)</em> .  Oh, hello, temporary object! </p><br><p>  <em>Object x</em> .  No-no-no, I'm lvalue, just static_cast on me. </p><br><p>  <em>T (T &amp;&amp;)</em> .  Everyone says like that.  Well, what do you have?  Come here... </p><br><p>  <strong>Act Three (epilogue)</strong> </p><br><p>  <em>T (const T &amp;)</em> .  I'm not happy with your violent methods. </p><br><p>  <em>T (T &amp;&amp;)</em> .  You exaggerate, think for yourself why a dying object all this stuff?  If it were not for me, you would have made a copy for a long time, and immediately after you the destructor would have destroyed the original.  Stupid. </p><br><p>  <em>T (const T &amp;)</em> .  So maybe he did not lie, and he is not temporary? </p><br><p>  <em>T (T &amp;&amp;)</em> .  I do not care.  So someone decided that it was necessary.  Everything is legal, I just do my job. </p><br><p>  <em>T (const T &amp;)</em> .  But earlier they coped well without you.  Somehow they organized the transfer and return, or allocated to the object living space in dynamic memory.  And the compiler helped with optimization. </p><br><p>  <em>T (T &amp;&amp;)</em> .  Oh, remember all this bureaucracy.  The object was settled, then the registration record was lost, and that was all; he lived there until the end, and did not drive it away.  Enough to regret these objects, otherwise you will turn into my brother T (const T &amp;&amp;) - that one is even more compassionate.  I said to him: ‚ÄúEverything, the object is no longer a tenant, take away his belongings,‚Äù and he hesitates, saying uncomfortable, let me just copy it. </p><br><p>  <em>T (const T &amp;)</em> .  I also have a brother T (T &amp;), a real gangster.  Disguised as me, under the copy designer ... <em>Then come up with laziness</em> . </p><br><h1 id="predislovie">  Foreword </h1><br><p>  New concepts do not always fit exactly in the head.  It happened to me with rvalue links.  It seems that everything is very simple, the preconditions for their appearance are clear, but when you try to read a code saturated with various &amp;&amp; wrapped in a bunch of templates, you realize that you don‚Äôt understand anything. </p><br><p>  My mistake in studying this topic was that I presented the rvalue-links as a fundamentally new entity.  Perhaps this will seem strange to you, because in all the manuals they clearly say that this is just a link to rvalue.  I understood that.  But after all, a bunch of new concepts have appeared with them, such as universal links and perfect forwarding.  Also, the call to the function that returns &amp;&amp; has become some kind of mystical xvalue expression.  In short, it would be too easy to consider them as normal links. </p><br><p> So, most importantly - do not complicate!  If you saw <code>T&amp;&amp; ref = foo()</code> , and do not know how to treat ref now, then treat it as an old-kind constant reference to rvalue: <code>const T&amp; ref = foo()</code> , only without const. </p><br><p>  And why it was impossible to simply allow to take a link to rvalue?  Otherwise, we would immediately lose information about whether the expression was lvalue or rvalue.  Now, the rvalue "prefers" to be passed to the function with the argument T &amp;&amp;, and the lvalue - with T &amp;.  This gives us the opportunity to deal with objects in different ways, which is especially important for the implementation of copy and move constructors. </p><br><p>  Another of my mistakes is checking samples in Visual Studio.  Examples in articles, for example <code>std::string &amp;str = std::string("42")</code> , which should not be compiled, have been compiled.  This was due to a non-standard language extension from Visual Studio.  I will talk about this again, because understanding this behavior is very important if VS is your development environment. </p><br><p>  The best way to read this article is not to believe me and check everything yourself.  I advise in the debug build.  If you are using GCC, it would be nice to <code>-fno-elide-constructors</code> switch to disable the Copy Elision technique, which suppresses the challenge of copy and move constructors where you can.  And if VS, then turn on the 4th level of warnings for catching use of non-standard extensions. </p><br><h1 id="vvedenie">  Introduction </h1><br><p>  When studying rvalue links and displacement constructors, you can often find similar examples: </p><br><pre> <code class="cpp hljs">Matrix m = m1 * m2; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s = s1 + s2; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;BigInt&gt; primes = getAllMersennePrimes();</code> </pre> <br><p>  The temporary object is copied and immediately destroyed.  This, of course, is clearly an redundant operation, and the work of the displacement constructor is quite obvious here.  However, by adding a move constructor to your class, you may not notice the acceleration.  After all, the compiler uses various optimization techniques, in particular Return Value Optimization, which we will talk about a bit at the end of the article.  I offer the following example.  Imagine that we have filled a large local vector: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; items(<span class="hljs-number"><span class="hljs-number">1000000</span></span>); fill(items);</code> </pre> <br><p>  In memory, it looks like this (we will not over-complicate the scheme with a third pointer to the end of the reserve memory): </p><br><p><img src="https://habrastorage.org/files/15c/bde/034/15cbde0342534ab689d0bd9fdaff7a35.png" alt="Representation of a vector"></p><br><p>  And we want to pass it to some object, via setter: </p><br><pre> <code class="cpp hljs">storage-&gt;setItems(items); <span class="hljs-comment"><span class="hljs-comment">// items   </span></span></code> </pre> <br><p>  As it was before: the vector was transmitted by a constant reference (which allowed using both lvalue and rvalue), and then the copy constructor was called, which created the same large vector.  And the original was deleted only after going out of scope.  Although I would just like to give the new vector a pointer to the data: </p><br><p><img src="https://habrastorage.org/files/656/544/b59/656544b5911e46fa8a12c1dc164331b4.png" alt="Move vector"></p><br><p>  Now it is easy: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; items(<span class="hljs-number"><span class="hljs-number">1000000</span></span>); fill(items); storage-&gt;setItems(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(items)); <span class="hljs-comment"><span class="hljs-comment">// items   </span></span></code> </pre> <br><p>  And in the setItems method: </p><br><pre> <code class="cpp hljs">Storage::setItems(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; items) { items_ = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(items); }</code> </pre> <br><p>  Note that the vector is passed by value, which provides a copy for the lvalue and a move for the rvalue (in particular, temporary objects).  Thus, if you still need a local vector, just call setItems without std :: move.  A small overhead is that the argument is moved again using the move operator. </p><br><h1 id="inicializaciya">  Initialization </h1><br><p>  All we need to do to deal with all the concepts is to focus on different ways of initialization.  This may be a variable initialization: </p><br><pre> <code class="cpp hljs">T x = expr; <span class="hljs-comment"><span class="hljs-comment">// T x(expr);</span></span></code> </pre> <br><p>  Passing the argument: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T x)</span></span></span></span>; foo(expr);</code> </pre> <br><p>  Return value: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> expr; }</code> </pre> <br><p>  All these cases will be called initialization, since they are semantically identical.  Then consider the type <code>T</code>  It may be one of the following: </p><br><ul><li>  linkless type (A) </li><li>  lvalue reference (A &amp;) </li><li>  rvalue reference (A &amp;&amp;) </li></ul><br><p>  I will specify that the type with the pointer also belongs to one of them.  For example, <code>A*</code> is a linkless type, <code>A*&amp;</code> - lvalue reference, etc.  Next, pay attention to the expression <code>expr</code> .  The expression has type and category values ‚Äã‚Äã(rvalue or lvalue).  The type of expression for us will not be as important as one might think.  In this topic, the main role is played by the category of the value of the expression: rvalue or lvalue, which for brevity will be called the category of the expression. </p><br><p>  Thus, we have 3 options on the left, 2 on the right. Total 6. Before considering them in more detail, let us learn to define a category. </p><br><h1 id="kategoriya-znacheniya-vyrazheniya">  Expression Value Category </h1><br><h2 id="lvalue-i-rvalue">  lvalue and rvalue </h2><br><p>  Before c ++ 11, only these 2 categories existed.  With the advent of move semantics, the category of rvalue was further split into 2 categories, which we will discuss in the next subsection.  So, the category of each expression is either lvalue or rvalue.  The standard, of course, describes what applies to each of them, but it is difficult to read. </p><br><p>  Scott Myers suggests the following rules: </p><br><ul><li>  If it is possible to take the address of an expression, then it is lvalue. </li><li>  Otherwise, if the type of the expression is an lvalue reference (i.e., T &amp; or const T &amp;, etc.), then it is also an lvalue. </li><li>  Otherwise, the expression is rvalue. </li></ul><br><p>  I don‚Äôt really like them, because they are not strict, and there are many subtleties that sometimes change.  And, most importantly, when studying a topic, how can I understand whether it is possible to take an address?  Well, well, we know that a temporary object cannot.  And <code>str</code> ? </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;&amp;str = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> *psrt = &amp;str;</code> </pre> <br><p>  It turns out that yes, it is possible, since <code>str</code> is an lvalue, although its type is an rvalue reference.  Remember this is important. </p><br><p>  If necessary, I refer to the <a href="http://en.cppreference.com/w/cpp/language/value_category">cppreference: value category</a> , where the list of expressions is given.  Some examples from there: </p><br><ul><li>  lvalue: <br><ul><li>  The name of a variable or argument (even if its type is an rvalue reference).  For example <code>std::cin</code> . </li><li>  A call to a function or operator whose return type is an lvalue reference.  For example <code>std::cout &lt;&lt; 1</code> , <code>++it</code> . </li><li>  String literals, such as <code>"Hello, world!"</code>  . </li></ul></li><li>  rvalue: <br><ul><li>  Non-string literal, for example <code>42</code> , <code>true</code> , <code>nullptr</code> . </li><li>  A call to a function or operator whose return type is not a reference. </li><li>  Take address: <code>&amp;a</code> . </li><li>  A call to a function or operator whose return type is an rvalue reference.  For example <code>std::move(x)</code> . </li><li>  <code>am</code> , where a is rvalue. </li></ul></li></ul><br><h2 id="xvalue-prvalue-i-glvalue">  xvalue, prvalue and glvalue </h2><br><p>  As mentioned, the rvalue has broken down into two categories: xvalue (eXpiring lvalue) and prvalue (pure rvalue).  And lvalue along with xvalue became glvalue (generalized lvalue).  Now, for the greatest accuracy, expressions should be attributed to one of 3 categories.  On the diagram, it looks like this: </p><br><p><img src="https://habrastorage.org/files/001/54b/c3b/00154bc3bd5e41f886922f0ce1d826d8.png" alt="Categories of expression"></p><br><p>  The xvalue includes the following expressions: </p><br><ul><li>  A call to a function or operator whose return type is an rvalue reference.  For example <code>std::move(x)</code> . </li><li>  <code>am</code> , where a is rvalue. </li></ul><br><p>  What were additional categories needed for?  The xvalue expression, although it is an rvalue, but has some lvalue properties, for example, it can be polymorphic.  Further, we will not need these additional categories, but they are useful to increase their credibility during heated discussions. </p><br><h1 id="sposoby-inicializacii">  Ways to initialize </h1><br><p>  According to our estimates came out 6 options.  In fact, you need to consider only 3. Because, first, you cannot initialize an rvalue-link with an lvalue-expression.  And secondly, the initialization of the object (non-reference type) by some expression, is performed using the copy or pass through constructor through the transfer of the expression (into the constructor) by reference, which reduces these cases to one of three options.  As an initial guideline such a scheme: </p><br><p><img src="https://habrastorage.org/files/2f5/217/5b8/2f52175b8421492ca80e1bc40480899e.png" alt="Priority links"></p><br><h2 id="t-x--lvalue">  T &amp; x = lvalue </h2><br><p>  Normal link. </p><br><h2 id="t-x--rvalue">  T &amp; x = rvalue </h2><br><p>  This only works in two cases. </p><br><h3 id="sluchay-1-dlya-konstantnoy-ssylki">  Case 1. For a constant link. </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; x = rvalue;</code> </pre> <br><p>  Before c ++ 11, this was the only way to pass a temporary object somewhere.  For example, in the copy constructor: </p><br><pre> <code class="cpp hljs">T::T(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp;); T x = T(); <span class="hljs-comment"><span class="hljs-comment">//  T       </span></span></code> </pre> <br><p>  or somewhere else: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> filename = <span class="hljs-string"><span class="hljs-string">"data"</span></span>; readFile(filename + <span class="hljs-string"><span class="hljs-string">".txt"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  std::string      readFile</span></span></code> </pre> <br><p>  As you know, a constant link extends the life of a temporary object.  Yes, but only while this link is still in scope.  Since the temporary object is located on the stack, when leaving the scope or from the function, the compiler is no longer obliged to be responsible for the fate of the object. </p><br><h3 id="sluchay-2-v-visual-studio">  Case 2. In Visual Studio </h3><br><p>  Do not be surprised by the example that works perfectly in Visual Studio: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; &amp;v = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;({ <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }); v.push_back(<span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br><p>  The answer will appear only at the 4th warning level: </p><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">warning</span></span> C4239: nonstandard <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> used note: A non-const reference may <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> be bound <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> an lvalue</code> </pre> <br><p>  This non-standard extension for C ++ is disabled by the <code>/Za (Disable Language Extensions)</code> key, but some heders, such as <code>Windows.h</code> , will not compile because the extension also includes other features. </p><br><h2 id="t-x--lvalue-1">  T &amp;&amp; x = lvalue </h2><br><p>  It's simple: you can't write like that.  Be careful, on Habr√© there is a translation of the article ‚ÄúA Brief Introduction to Rvalue References‚Äù (article already in 2008), which is the first in search engines for the request ‚Äúrvalue‚Äù.  The example from there is erroneous: </p><br><pre> <code class="cpp hljs">A a; A&amp;&amp; a_ref2 = a; <span class="hljs-comment"><span class="hljs-comment">//  rvalue </span></span></code> </pre> <br><p>  Also, there is an incorrect implementation of <code>std::move</code> .  However, in the comments pointed out the error. </p><br><h2 id="t-x--rvalue-1">  T &amp;&amp; x = rvalue </h2><br><p>  Went to the most interesting.  Let's start with the simplest examples: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;&amp; str = foo(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;&amp; i = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><p>  These links behave like normal.  You can submit a link const T &amp;, which can be changed, or recall the extension Visual Studio.  The question may arise, why it was impossible to simply use a regular link for all categories of expressions?  In VS, this worked perfectly (for classes).  The &amp;&amp; links make it possible to overload functions and especially constructors not only by the type of expression, but also by category (lvalue or rvalue).  Example with 2 constructors: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;); <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;&amp;); <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s1 = <span class="hljs-string"><span class="hljs-string">"Hello "</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s2 = <span class="hljs-string"><span class="hljs-string">"world!"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s3 = s1 + s2;</code> </pre> <br><p>  The expression <code>s1 + s2</code> is rvalue, and both constructors are suitable for it (see the diagram at the beginning of the section).  Priority will be given to the type string &amp;&amp;.  Those who are familiar with motion designers know why this is important.  Before we talk about this in more detail, we will deal with priorities. </p><br><h2 id="prioritet">  A priority </h2><br><p>  In most situations, it is enough to know that <code>T&amp;&amp;</code> "more priority" <code>const T&amp;</code> .  But it is desirable to deal with <code>const T&amp;&amp;</code> and <code>T&amp;</code> .  Here is an extended diagram: </p><br><p><img src="https://habrastorage.org/files/b7e/29b/f31/b7e29bf314d74a2aa88d8ad739b653db.png" alt="Extended link priority"></p><br><p>  The rules are simple (in descending order of priority): </p><br><ul><li>  First of all, similar tends to similar (horizontal arrows). </li><li>  The constant variant is also suitable. </li><li>  And if all other options are missing, then the type <code>const T&amp;</code> will be glad to all expressions. </li><li>  <em>For VS: don't forget about non-constant references to rvalue (dotted arrow)</em> . </li></ul><br><h2 id="konstruktory-kopirovaniya-i-peremescheniya-t-x--lvalue-t-x--rvalue">  Copy and move constructors (T x = lvalue; T x = rvalue;) </h2><br><p>  When you write: </p><br><pre> <code class="cpp hljs">T x = expr; <span class="hljs-comment"><span class="hljs-comment">// T x(expr);</span></span></code> </pre> <br><p>  constructor is called.  Which one  A class may have several: </p><br><pre> <code class="cpp hljs">T(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp;); <span class="hljs-comment"><span class="hljs-comment">//copy- T(T&amp;); // copy- T(const T&amp;&amp;); //  ? T(T&amp;&amp;); //move-</span></span></code> </pre> <br><p>  When the constructor is called, the expression is passed by reference according to the scheme above, depending on the category of the expression and the type of reference to the arguments.  Now about what each constructor does. </p><br><h3 id="1-tconst-t">  1. T (const T &amp;) </h3><br><p>  The usual copy constructor.  It has the lowest priority, but it can take any expression. </p><br><h3 id="2-tt">  2. T (T &amp;) </h3><br><p>  I call him an insidious copy constructor, because he can quite easily modify the source if it was not constant at first.  Has priority over normal copy constructor.  I doubt that it is used in practice.  If there are good examples of its use, write. </p><br><h3 id="3-tconst-t">  3. T (const T &amp;&amp;) </h3><br><p>  This can accept rvalue-expressions, i.e., objects whose life expectancy has come to an end.  The dying object says: I am dying, take mine <del>  grenades </del>  pointers to the data, I no longer need them.  And the designer answers: no, I can't, they will remain with you, I can only make a copy.  I also do not know a practical example of use. </p><br><h3 id="4-tt">  4. T (T &amp;&amp;) </h3><br><p>  This constructor is called only for non-constant rvalue.  Such an expression is a temporary object or an object <code>static_cast&lt;T&amp;&amp;&gt;</code> to an rvalue reference using <code>static_cast&lt;T&amp;&amp;&gt;</code> .  Such a transformation does not affect the object in any way, however, such a wrapper expression can be passed via an rvalue reference to the displacement constructor (or to some function).  The constructor takes all the pointers to the data and other members of the class and passes them to the new object.  Therefore, for the effective work of the move constructor, the class members should be smaller.  In the limiting case, you can only store one pointer to the implementation.  The Pimpl idiom (pointer to implementation) works well here. </p><br><p>  For example, consider the class of the string specified using the pointer to the data on the heap and the length of the string (this is only a conceptual example): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* data_; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> length_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">String</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length)</span></span></span><span class="hljs-function"> </span></span>{ data_ = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(length)); length_ = length; } ~String() { ::<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(data_); } };</code> </pre> <br><p>  So the displacement constructor might look like: </p><br><pre> <code class="cpp hljs">String(String&amp;&amp; other) { data_ = other.data_; <span class="hljs-comment"><span class="hljs-comment">//     length_ = other.length_; //   other.data_ = nullptr; //   ( ) other.length_ = 0; //    }</span></span></code> </pre> <br><p>  What would have happened if we hadn‚Äôt reset its data (3-4 constructor lines)?  Sooner or later, for two twin objects, a destructor would be called who would try to delete the same data two times.  But what if only the pointer to the data is zeroed, but not the length?  After all, the destructor will work twice normally - this one does not use length.  Then the user of the object that suddenly uses the <code>getLength</code> function will receive incorrect information.  Therefore, it is impossible to barbarously handle an object that is no longer needed.  In any case, you must leave it empty, but in the correct state.  In addition, it can cause movement several times throughout its life. </p><br><h1 id="static_castt-i-stdmove">  static_cast &lt;T &amp;&amp;&gt; and std :: move </h1><br><p>  We already talked about <code>static_cast&lt;T&amp;&amp;&gt;</code> when discussing the displacement constructor.  As you remember, the expression "wrapped" in <code>static_cast&lt;T&amp;&amp;&gt;</code> , signals that the object can be moved.  Then, if a new object is initialized, the move constructor will be called, not the copy.  Now we can implement the task from the beginning of the article: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; items(<span class="hljs-number"><span class="hljs-number">1000000</span></span>); fill(items); <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&amp;&amp; &gt; (items); <span class="hljs-comment"><span class="hljs-comment">//    ,    storage-&gt;setItems( static_cast&lt; std::vector&lt;int&gt;&amp;&amp; &gt; (items) ); // items   </span></span></code> </pre> <br><p>  You probably know that there is a more convenient way - to call the function <code>std::move</code> , which is a wrapper over static_cast.  To understand how it works, we will write it ourselves and step on the rake, but it will be a useful lesson.  Before reading further, you can write it yourself.  Of course, this function should be template to accept different types.  But for now, for simplicity, we will do for one particular class A. Let‚Äôs speculate.  If we want to pass an lvalue, then this can only be done using an argument of type A &amp;.  Next, we convert it to A &amp;&amp;, and the return type will also be A &amp;&amp;.  The call to the function that returns &amp;&amp; is an rvalue expression (or rather xvalue), as we wanted. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">A&amp;&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_move</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A&amp; a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;A&amp;&amp;&gt;(a); }</code> </pre> <br><p>  But the standard std :: move function also accepts rvalue, so it is universal, which is not the case with ours.  One solution is simple - add another function with the argument A &amp;&amp;: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">A&amp;&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_move</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A&amp;&amp; a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;A&amp;&amp;&gt;(a); }</code> </pre> <br><p>  Works for both lvalue and rvalue.  But wait, the real std :: move is only one and has the template type of the argument T &amp;&amp;.  How so?  We will understand further. </p><br><h1 id="szhatie-ssylok-i-universalnye-ssylki">  Link compression and universal links </h1><br><p>  So, we found out that the template std :: move accepts an lvalue for the argument T &amp;&amp;.  So T &amp;&amp; is not an rvalue link.  T &amp;&amp; somehow turns into T &amp;.  But what type of T is instantiated?  To understand what's what, let's try to call two overloaded functions for two categories of expressions (rvalue and lvalue): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp;);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp;&amp;);</span></span> A a; foo(a); <span class="hljs-comment"><span class="hljs-comment">//lvalue; foo(A()); //rvalue;</span></span></code> </pre> <br><p>  In the functions themselves, we will check what type is instantiated by T. You can check the type of the link as follows: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_lvalue = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_lvalue_reference&lt;T&gt;::value; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_rvalue = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_rvalue_reference&lt;T&gt;::value;</code> </pre> <br><p>  It turns out that 3 options are suitable: </p><br><ol><li>  The <code>foo(lvalue)</code> entry, when <code>foo(T&amp;)</code> called, is equivalent to <code>foo&lt;T&gt;(lvalue)</code> . </li><li>  The record <code>foo(rvalue)</code> , when calling <code>foo(T&amp;&amp;)</code> , is equivalent to <code>foo&lt;T&gt;(rvalue)</code> . </li><li>  The record <code>foo(lvalue)</code> , when calling <code>foo(T&amp;&amp;)</code> , is equivalent to <code>foo&lt;T&amp;&gt;(lvalue)</code> . </li></ol><br><p>  In the following diagram, the signatures on the arrows indicate what type T was instantiated for in this or that case. </p><br><p><img src="https://habrastorage.org/files/f26/b94/908/f26b949088bf4bcc999de13c004d87b8.png" alt="Template Instances and Category"></p><br><p>  The first two variants are predictable, we relied on them.  The third one is using the reference collapse rule - link compression, which determines the behavior when a link to a link appears.  Such a construction is in itself forbidden, but arises in patterns.  Therefore, it was set that if T is instantiated by A &amp;&amp;, then T &amp;&amp; (A &amp;&amp; &amp;&amp;) = A &amp;&amp;, and in other cases (links to the link) the type is A &amp;, that is: </p><br><pre> <code class="hljs php">T = A&amp; =&gt; T&amp; = A&amp; T = A&amp; =&gt; T&amp;&amp; = A&amp; T = A&amp;&amp; =&gt; T&amp; = A&amp; T = A&amp;&amp; =&gt; T&amp;&amp; = A&amp;&amp;</code> </pre> <br><p>  Thus, an argument of type T &amp;&amp;, where T is a template type, can accept both types of references.  Therefore, a link like T &amp;&amp; is called a <strong>universal link</strong> . </p><br><h1 id="stdmove-prodolzhenie">  std :: move (continued) </h1><br><p>  Now it is clear that std :: move can apply T &amp;&amp; (see foo (T &amp;&amp;) in the diagram above).  Let's add to the pattern of our my_move: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_move</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T&amp;&amp;&gt;(t); }</code> </pre> <br><p>  This is an erroneous implementation, since T &amp;&amp; turns into A &amp; for lvalue, and, in this case, the instance of the function will be: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">A&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_move</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A&amp; t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;A&amp;&gt;(t); }</code> </pre> <br><p>  The argument type is correct, but for the rest of the places we needed to leave A &amp;&amp; instead of A &amp;.  It's time to watch the implementation of std :: move: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remove_reference</span></span></span><span class="hljs-class">&lt;T&gt;:</span></span>:<span class="hljs-function"><span class="hljs-function">type&amp;&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; _Arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(_Arg)); }</code> </pre> <br><p>  I think it is clear: remove_reference removes all references, and then &amp;&amp; is added to the resulting type.  By the way, the remove_reference class is very simple.  These are the three specializations of the template class with the parameters T, T &amp;, T &amp;&amp;. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remove_reference</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remove_reference</span></span></span><span class="hljs-class">&lt;T&amp;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remove_reference</span></span></span><span class="hljs-class">&lt;T&amp;&amp;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T type; };</code> </pre> <br><h1 id="perfect-forwarding-i-stdforward">  Perfect forwarding and std :: forward </h1><br><p>  It would seem, to deal with all the problems, but no.  We have learned to pass on all expressions using the T &amp;&amp; pattern, but so far we have not been interested in how to work with them further.  The std :: move function does not count, because without thinking, it all leads to an rvalue.  Why do we need to distinguish between categories of expressions?  Imagine that we are writing an analogue of <code>make_shared</code> .  I remind you that <code>make_shared&lt;T&gt;(...)</code> itself calls the constructor T with the given arguments.  Now is not the time to deal with the variadic templates, therefore, for simplicity, we assume that there is only one argument.  We will also return the most common pointer.  Take a simple class: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: A(); <span class="hljs-comment"><span class="hljs-comment">//  A(const A&amp;); //  A(A&amp;&amp;); //  };</span></span></code> </pre> <br><p>  We want to do this: </p><br><pre> <code class="cpp hljs">A a; A* a1 = make_raw_ptr&lt;A&gt;(a); <span class="hljs-comment"><span class="hljs-comment">//   A* a2 = make_raw_ptr&lt;A&gt;(A()); //   delete a1; delete a2;</span></span></code> </pre> <br><p>  Using the compression of the links, we write the implementation: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arg</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_raw_ptr</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arg</span></span></span><span class="hljs-class"> &amp;&amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">arg</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T(arg); };</code> </pre> <br><p>  Well, it works, of course.  Only copying always happens.  Found a bug?  It's simple - arg is always lvalue.  It seems that we have lost information about the category of the original expression.  Not really - it can still be extracted from Arg.  After all, for lvalue: Arg = A &amp;, for rvalue: Arg = A.  It turns out that we need a function that restores the type of the link, that is: </p><br><ol><li>  When passing lvalue of type A &amp; returns A &amp; </li><li>  When passing lvalue of type A returns A &amp;&amp; </li><li>  By transfer of rvalue ... We will not bother yet. </li></ol><br><p>     A ( ): </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 1-  A&amp; my_forward(A&amp; a) { return a; } // 2-  A&amp;&amp; my_forward(A&amp; a) // ,   lvalue { return static_cast&lt;A&amp;&amp;&gt;(a); //,     rvalue }</span></span></code> </pre> <br><p>    ,    . ,        A&amp;,     A. ,      A&amp; ‚Äî A&amp;,   A ‚Äî A&amp;&amp;.    , ""    &amp;&amp;. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_forward</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T&amp;&amp;&gt;(a); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arg</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_raw_ptr</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arg</span></span></span><span class="hljs-class"> &amp;&amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">arg</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T(my_forward&lt;Arg&gt;(arg)); };</code> </pre> <br><p>   std::forward  .     &amp;  &amp;&amp;,     . </p><br><h1 id="vozvrat-obekta">   </h1><br><p>    /   ,  ,           .       move-.        .    GCC    <code>-fno-elide-constructors</code> .    ,   . </p><br><h2 id="vozvrat-bez-optimizacii">    </h2><br><p>        . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T result; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } foo();</code> </pre> <br><p>     foo  .       ,          . ,   ,    : </p><br><pre> <code class="cpp hljs">T temp = result; <span class="hljs-comment"><span class="hljs-comment">//     </span></span></code> </pre> <br><p>    ,     ,   . temp ‚Äî  ,     . ,  result,  ,     rvalue,      foo.  temp         .    ,    ( &amp;  &amp;&amp;)    . </p><br><p>     ,   : </p><br><pre> <code class="cpp hljs">T x = foo();</code> </pre> <br><p>  : </p><br><pre> <code class="cpp hljs">T temp = result; <span class="hljs-comment"><span class="hljs-comment">//      T x = std::move(temp); //     </span></span></code> </pre> <br><p>          . ,         . </p><br><p>  ,         (   ,   sizeof, ),      . </p><br><h2 id="copy-elision-i-return-value-optimization"> Copy elision  return value optimization </h2><br><p>  C++  :     ?      <code>std::vector&lt;int&gt; get();</code>   <code>void get(std::vector&lt;int&gt; &amp;);</code>  move-  .       copy elision ‚Äî     ,   .  ,     return value optimization (RVO).        ( ),      ,     .  ,       ,    .     RVO?   Visual Studio 2015: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> T(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: T() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">//RVO      T() {}; //   };</span></span></code> </pre> <br><p>  ,      .        ,       ,    .            std::shared_ptr  std::unique_ptr. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/322132/">https://habr.com/ru/post/322132/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322108/index.html">Wordpress + CloudFlare - fresh move to https</a></li>
<li><a href="../322112/index.html">SDS, Cloudless Cloud, Aruba, and Composable Infrastructure: New HPE Webinars</a></li>
<li><a href="../322116/index.html">Problems encountered in the development of android-applications</a></li>
<li><a href="../322120/index.html">A tale about how I treated a server with WP, or 700 users online on 2 cores</a></li>
<li><a href="../322130/index.html">Testing the Documented API with the Apiary Dredd Utility</a></li>
<li><a href="../322134/index.html">[Bughunting] Blind XSS vulnerability on omnidesk support sites</a></li>
<li><a href="../322138/index.html">The worst technological forecasts for the last 150 years</a></li>
<li><a href="../322140/index.html">Graphic description of ownership and borrowing in Rust</a></li>
<li><a href="../322142/index.html">MySQL dacherization in Uber</a></li>
<li><a href="../322144/index.html">How to save the project from closing, having understood with MySQL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>