<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rayon: data parallelism in Rust</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The last couple of weeks I've been working on updating Rayon - my experimental data parallelism library in Rust. 

 I am quite pleased with the way th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rayon: data parallelism in Rust</h1><div class="post__text post__text-html js-mediator-article"> The last couple of weeks I've been working on updating <a href="https://github.com/nikomatsakis/rayon/">Rayon</a> - my experimental <strong>data parallelism</strong> library in Rust. <br><br>  I am quite pleased with the way the development is going on, so I decided to explain to what I came to the blog post. <br>  <strong>The goal of Rayon is to make adding parallelism to sequential code simple,</strong> so that any <code>for</code> loop or iterator could be made to work in multiple threads.  For example, if you have such a chain of iterators: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> total_price = stores.iter() .map(|store| store.compute_price(&amp;list)) .sum()</code> </pre><br>  then you can make its work parallel simply by changing the usual <em>‚Äúsequential iterator‚Äù</em> to <em>‚Äúparallel iterator‚Äù</em> from Rayon: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> total_price = stores.par_iter() .map(|store| store.compute_price(&amp;list)) .sum()</code> </pre><br><a name="habracut"></a><br>  Of course, it is not enough to make concurrency simple, it must also be made safe.  <strong>Rayon ensures that using its API will never lead to a data race.</strong> <br>  This post explains how Rayon works.  First, it tells about the main primitive of Rayon ( <code>join</code> ), and then how it is implemented. <br>  I separately want to draw attention to how the combination of the Rust feature set makes it possible to realize <code>join</code> with very low overhead during the execution of the program, while still giving strict security guarantees.  Then I will briefly describe how a <code>join</code> iterator abstraction is built on the basis of <code>join</code> . <br>  However, I want to emphasize that Rayon is more <em>in the process of development</em> .  I expect that the design of the parallel iterator will go through many more, let's say, iterations (pun intended), because the current implementation is not as flexible as I would like.  In addition, there are several special cases that are handled incorrectly, in particular the spread of panic and cleaning up resources.  Regardless, Rayon may be useful for certain tasks right now.  I am very glad, and I hope you will be happy too! <br><br><h3>  Rayon main primitive: join </h3><br>  At the beginning of the post, I showed an example of using a parallel iterator for the map-reduce operation: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> total_price = stores.par_iter() .map(|store| store.compute_price(&amp;list)) .sum()</code> </pre><br>  However, in fact, parallel iterators are just a small library built on the basis of a more fundamental primitive: <code>join</code> .  Using <code>join</code> is easy.  You call two closures, as shown below, and <code>join</code> <em>potentially</em> runs them in parallel.  As soon as both of them are completed, he will return the result: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// `do_something`  `do_something_else` **   join(|| do_something(), || do_something_else())</span></span></code> </pre><br>  The main point here is that the two closures <em>can potentially</em> run in parallel: the <strong>decision whether or not to use parallel threads is made dynamically, depending on whether there are free cores or not.</strong>  The idea is that you can use <code>join</code> mark in your program the places where concurrency can be useful, and then let the library at run time decide whether to use it or not. <br>  The <em>potential parallelism</em> approach is the basic idea that distinguishes Rayon from <a href="">limited crossbeam flows</a> .  If you distribute work across two restricted threads in the crossbeam, it will always be executed in parallel in different threads.  At the same time, the call to <code>join</code> in Rayon does not necessarily lead to parallel code execution.  As a result, we have not only a simpler API, but also more efficient use of resources.  All because it is very difficult to predict in advance when parallelization will be profitable.  This always requires knowledge of some global context, for example: does the computer have free cores and what other parallel operations are being performed now?  <strong>In fact, one of the main goals of this post is to promote <em>potential parallelism</em> as the basis for libraries for data parallelism in Rust,</strong> as opposed to <em>guaranteed parallelism</em> , which we saw earlier. <br>  This is not to mention the fact that there is no separate role for guaranteed parallelism offered by crossbeam.  The semantics of <em>potential concurrency</em> also imposes some limitations on what your parallelized closures can do.  For example, if you try to use a channel for communication between two closures in a <code>join</code> , then this will most likely lead to a deadlock.  It‚Äôs worthwhile to think about <code>join</code> as a hint to use parallelism in a typically sequential algorithm.  Sometimes this is not what you want - some algorithms are initially <em>parallel</em> .  (Note, however, that it is perfectly normal to use types like <code>Mutex</code> , <code>AtomicU32</code> , etc. from within <code>join</code> - you just don't want one closure to be <em>locked</em> while waiting for another.) <br><br><h3>  Join example: parallel quicksort </h3><br>  The <code>join</code> primitive is ideal for <em>divide-and-rule algorithms</em> .  These algorithms divide the work into approximately equal parts and then recursively perform it.  For example, we can implement a <a href="">parallel version of quicksort</a> : <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quick_sort</span></span></span></span>&lt;T:<span class="hljs-built_in"><span class="hljs-built_in">PartialOrd</span></span>+<span class="hljs-built_in"><span class="hljs-built_in">Send</span></span>&gt;(v: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> [T]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v.len() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mid = partition(v); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (lo, hi) = v.split_at_mut(mid); rayon::join(|| quick_sort(lo), || quick_sort(hi)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">partition</span></span></span></span>&lt;T:<span class="hljs-built_in"><span class="hljs-built_in">PartialOrd</span></span>+<span class="hljs-built_in"><span class="hljs-built_in">Send</span></span>&gt;(v: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> [T]) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { <span class="hljs-comment"><span class="hljs-comment">// . https://en.wikipedia.org/wiki/Quicksort#Lomuto_partition_scheme }</span></span></code> </pre><br>  In fact, the only difference between this version of quicksort and the consistent one is that at the end we call <code>rayon::join</code> ! <br><br><h3>  How to implement join: work interception (work-stealing) </h3><br>  Inside <code>join</code> implemented using a technique known as <strong>intercepting work.</strong>  As far as I know, the interception of work was first introduced as part of the <a href="https://en.wikipedia.org/wiki/Cilk">Cilk</a> project, and has since become a fairly standard technique (in fact, the name Rayon <em>(eng. "Viscose", and "Cilk" allusion to "silk", i.e. "silk" - approx. Transl.)</em> - a tribute to Cilk). <br>  The main idea is that with each call to <code>join(a, b)</code> we define two tasks <code>a</code> and <code>b</code> , which can be safely executed in parallel, but we do not yet know whether there are free threads for this.  All that the current thread does is add <code>b</code> to the <em>‚Äúplanned work‚Äù</em> queue, then take, and immediately execute <code>a</code> .  At the same time, there is a pool of other active threads (usually one thread per core of the CPU, or something like that).  As soon as one of the threads is released, it goes and digs into the <em>‚Äúplanned work‚Äù</em> queues of other threads: if there is a task there, the free flow captures it and executes it itself.  So in this case, while the first thread is busy executing <code>a</code> , another thread can start executing <code>b</code> . <br>  As soon as the first thread finishes <code>a</code> , it checks to see if someone else has started performing <code>b</code> ?  If not, he performs it himself.  If so, then he needs to wait until another thread finishes it.  But while the first thread is waiting, it can go and steal work from another thread, thereby contributing to the completion of the entire work process as a whole. <br>  In the form of a Rust-like pseudo-code, <code>join</code> looks something like this (the <a href="">real code is a</a> bit different, for example, it allows each operation to have a result): <br><br><pre> <code class="python hljs">fn join&lt;A,B&gt;(oper_a: A, oper_b: B) where A: FnOnce() + Send, B: FnOnce() + Send, { //  `oper_b`  ,      : let job = push_onto_local_queue(oper_b); //  `oper_a` : oper_a(); // Check whether anybody stole `oper_b`: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pop_from_local_queue(oper_b) { //  ,  . oper_b(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // ,    . //         : <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> not_yet_complete(job) { steal_from_others(); } result_b = job.result(); } }</code> </pre><br>  What makes the interception of work so elegant is its natural adaptation to the CPU load.  That is, if all worker threads are busy, then <code>join(a, b)</code> starts to execute all closures sequentially (i.e. <code>a(); b();</code> ), which is no worse than the sequential code.  But if there are free threads, then we get parallel execution. <br><br><h3>  Performance measurement </h3><br>  Rayon is still quite young, so I don‚Äôt have a lot of test programs (and so far I haven‚Äôt optimized it much).  In spite of this, now you can get a noticeable acceleration, although this will have to spend a <em>little</em> more time debugging than I would like.  For example, with the <a href="">improved version of quicksort,</a> I see the following <a href="https://en.wikipedia.org/wiki/Speedup">acceleration from parallel execution</a> on my 4-core Macbook Pro (so that four-fold acceleration is the maximum that can be expected): <br><table><tbody><tr><th>  Array length </th><th>  Acceleration </th></tr><tr><td>  1K </td><td>  0.95x </td></tr><tr><td>  32K </td><td>  2.19x </td></tr><tr><td>  64K </td><td>  3.09x </td></tr><tr><td>  128K </td><td>  3.52x </td></tr><tr><td>  512K </td><td>  3.84x </td></tr><tr><td>  1024K </td><td>  4.01x </td></tr></tbody></table><br>  The change I made in comparison with the original version - I added the <em>transition to a sequential algorithm</em> .  The bottom line is that if the input array is small enough (in my code - less than 5000 elements), then we move to a sequential version of the algorithm, refusing to call <code>join</code> .  This can be done at all without duplicating the code using types, as can be seen from the <a href="">code of my example</a> .  (If curious, I explain the idea in the appendix at the end of the article.) <br>  Hopefully, after some optimizations, the transition to sequential execution will be needed less often, but it is worth noting that high-level APIs (such as the parallel iterator, which I mentioned above) can also make the transition to sequential execution for you, so you don‚Äôt need to constantly think about it . <br>  In any case, if you <em>do not make the</em> transition to a consistent implementation, the results will not be as good, although they could be much worse: <br><table><tbody><tr><th>  Array length </th><th>  Acceleration </th></tr><tr><td>  1K </td><td>  0.41x </td></tr><tr><td>  32K </td><td>  2.05x </td></tr><tr><td>  64K </td><td>  2.42x </td></tr><tr><td>  128K </td><td>  2.75x </td></tr><tr><td>  512K </td><td>  3.02x </td></tr><tr><td>  1024K </td><td>  3.10x </td></tr></tbody></table><br>  In particular, remember that this version of the code <strong>gives all the subarrays up to unit length for parallel processing</strong> .  If the array is 512K or 1024K long, then many subarrays are created, which means there are a lot of tasks, but we still get accelerations up to 3.10x.  I think the reason why the code runs so well is that the <em>basic approach is</em> correct: Rayon avoids memory allocation and virtual dispatching, as described in the next section.  And yet I would like better performance than 0.41x for 1K arrays (and I think this is possible). <br><br><h3>  Using Rust features to minimize overhead </h3><br>  As you can see above, to make this scheme work, you need to reduce the overhead of placing the task in the local queue as much as possible.  In the end, it is expected that most tasks will not be intercepted, because the number of processors is much less than the number of tasks.  The Rayon API is designed to use some of the Rust features to reduce this overhead: <br><ul><li>  <code>join</code> polymorphic about the closure types of its arguments.  And this means that in the process of <abbr title="Creation of specialized implementations of polymorphic methods and types with specific types instead of typical parameters at compile time">monomorphization</abbr> separate copies of the <code>join</code> will be created <strong>specialized for each specific call</strong> .  Which, in turn, leads to the fact that when the <code>join</code> calls <code>oper_a()</code> and <code>oper_b()</code> (in contrast to the relatively rare cases when they are intercepted), the calls are dispatched statically, which means they can be inlined.  Yes, and it turns out that the creation of the circuit does not require memory allocation. </li><li>  Because <code>join</code> blocks execution before executing both closures, we can make <strong>full use of the layout on the stack</strong> .  This is good for both the API users and the implementation: for example, the quicksort example above is based on having access to the slice <code>&amp;mut [T]</code> , which is passed to the input, which is possible due to the blocking in <code>join</code> .  At the same time, the <code>join</code> implementation can <strong>completely avoid allocating memory from the heap</strong> and use only the stack (for example, objects of closures that are put in the local task queue are placed on the stack). </li></ul><br>  As can be seen from the above, the overhead of placing the task is quite low, although not as much as I would like.  There are several ways to reduce them even more: <br><ul><li>  Many implementations of job interception use heuristics when deciding whether to skip the placement of a task in the task queue for parallel processing.  For example, in the work of <a href="http://dl.acm.org/citation.cfm%3Fid%3D2629643">Lazy</a> <abbr title="Tzannes">Tzannes</abbr> <a href="http://dl.acm.org/citation.cfm%3Fid%3D2629643">Planning</a> <abbr title="Tzannes">,</abbr> an attempt was made to avoid placing a task in a queue if there are no free work flows (they are called <em>‚Äúhungry‚Äù</em> flows) capable of intercepting work. </li><li>  And, of course, good old optimizations can help.  For example, I have never even <em>looked</em> into the LLVM bitcode or assembly code obtained during the compilation of <code>join</code> , and it‚Äôs very likely that it‚Äôs the easiest to optimize. </li></ul><br><br><h3>  Freedom from racing data </h3><br>  I mentioned earlier that Rayon guarantees freedom from data races.  This means that you can add concurrency to a previously sequential code, without worrying about the fact that strange, difficult to reproduce bugs may appear. <br>  There are two types of errors that we should worry about.  First, two closures can use the same mutable state, so changes made in one thread can affect the other.  For example, if I change the example above so that it (incorrectly) called <code>quick_sort</code> with the <code>lo</code> parameter in both closures, then I hope that the code will not compile: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quick_sort</span></span></span></span>&lt;T:<span class="hljs-built_in"><span class="hljs-built_in">PartialOrd</span></span>+<span class="hljs-built_in"><span class="hljs-built_in">Send</span></span>&gt;(v: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> [T]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v.len() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mid = partition(v); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (lo, hi) = v.split_at_mut(mid); rayon::join(|| quick_sort(lo), || quick_sort(lo)); <span class="hljs-comment"><span class="hljs-comment">// &lt;-- ! } }</span></span></code> </pre><br>  And indeed, I will see such an error: <br><br><pre> <code class="rust hljs">test.rs:<span class="hljs-number"><span class="hljs-number">14</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-number"><span class="hljs-number">14</span></span>:<span class="hljs-number"><span class="hljs-number">27</span></span> error: closure requires unique access to `lo` but it is already borrowed [E0500] test.rs:<span class="hljs-number"><span class="hljs-number">14</span></span> || quick_sort(lo)); ^~~~~~~~~~~~~~~~~</code> </pre><br>  Similar errors will arise if I try to process <code>lo</code> (or <code>hi</code> ) in one circuit, and <code>v</code> in the other, which overlaps with both sections. <br>  <em>Note:</em> this example seems to be artificial, but in fact this is a real bug that I once allowed (or, rather, would allow) when implementing parallel iterators, which I will discuss later.  It is very easy to make such mistakes with copy-paste, and it‚Äôs very good that Rust turns them into an impossible event, and not into a bug with the program crash. <br>  Another type of bugs that can be caught is the use of thread safe types from one of the closures in the <code>join</code> .  For example, Rust offers a <a href="http://doc.rust-lang.org/std/rc/struct.Rc.html">type with a non-atomic reference counter</a> called <code>Rc</code> .  Since <code>Rc</code> uses non-atomic instructions to update the reference counter, it is not safe to separate <code>Rc</code> between different threads.  If someone tries to do so, as in the following example, the reference counter can easily become incorrect, which can lead to a double memory free or worse: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">share_rc</span></span></span></span>&lt;T:<span class="hljs-built_in"><span class="hljs-built_in">PartialOrd</span></span>+<span class="hljs-built_in"><span class="hljs-built_in">Send</span></span>&gt;(rc: Rc&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">//     `clone`   . //     . //     ! rayon::join(|| something(rc.clone()), || something(rc.clone())); }</span></span></code> </pre><br>  But, of course, if I try to compile this example, I get an error: <br><br><pre> <code class="rust hljs">test.rs:<span class="hljs-number"><span class="hljs-number">14</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-number"><span class="hljs-number">14</span></span>:<span class="hljs-number"><span class="hljs-number">9</span></span> error: the <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> `</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">core</span></span></span></span>::marker::<span class="hljs-built_in"><span class="hljs-built_in">Sync</span></span>` is not implemented <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> `</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alloc</span></span></span></span>::rc::Rc&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;` [E0277] test.rs:<span class="hljs-number"><span class="hljs-number">14</span></span> rayon::join(|| something(rc.clone()), ^~~~~~~~~~~ test.rs:<span class="hljs-number"><span class="hljs-number">14</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-number"><span class="hljs-number">14</span></span>:<span class="hljs-number"><span class="hljs-number">9</span></span> help: run `rustc --explain E0277` to see a detailed explanation test.rs:<span class="hljs-number"><span class="hljs-number">14</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-number"><span class="hljs-number">14</span></span>:<span class="hljs-number"><span class="hljs-number">9</span></span> note: `alloc::rc::Rc&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;` cannot <span class="hljs-keyword"><span class="hljs-keyword">be</span></span> shared between threads safely</code> </pre><br>  As you can see, in the last message after <em>‚Äúnote‚Äù the</em> compiler tells us that you cannot share access to <code>Rc</code> between different threads. <br>  You might be wondering, what kind of dark magic allows the <code>join</code> function to support both of these invariants?  In fact, the answer is surprisingly simple.  The first error I received when I tried to transfer the same <code>&amp;mut</code> -slice into two different closures results from the basic type system of Rust: you cannot have two closures that both exist simultaneously and have access to the same <abbr title="Slice with the right to change the data to which it refers"><code>&amp;mut</code> - cut</abbr> .  This is because access to <code>&amp;mut</code> data must be <em>unique</em> , which means that if you had two closures could get <em>unique</em> access to the same <code>&amp;mut</code> value, this would make the value not so <em>unique</em> . <br>  (In fact, it was one of the <a href="http://smallcultfollowing.com/babysteps/blog/2013/06/11/on-the-connection-between-memory-management-and-data-race-freedom/">greatest insights for me</a> when working with the Rust type system. Before that, I thought that <em>‚Äúdangling pointers‚Äù</em> in sequential programs and <em>‚Äúdata races‚Äù</em> are completely different kinds of bugs, but now I present them as two heads One Hydra. Basically, both types of bugs have unrestrained use of pseudonyms and data changes, and both of them can be solved using a system of ownership and borrowing. Deft, yes?) <br>  So what about the second error, in which I tried to send <code>Rc</code> between threads?  It arose because the <code>join</code> function requires that both its closure arguments satisfy the type <code>Send</code> .  The <code>Send</code> type in Rust indicates that data can be safely transferred between threads.  So when <code>join</code> declares that both closures must satisfy the type <code>Send</code> , it seems to say: <em>"for data that closures can access, it must be safe to move from one stream to another</em> . <em>"</em> <br><br><h3>  Parallel Iterators </h3><br>  At the beginning of the post I gave this example with a parallel iterator: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> total_price = stores.par_iter() .map(|store| store.compute_price(&amp;list)) .sum();</code> </pre><br>  But since then I have focused exclusively on <code>join</code> .  As I said earlier, the API for parallel iterators is actually a <a href="https://github.com/nikomatsakis/rayon/tree/22f04aee0e12b31e029ec669299802d6e2f86bf6/src/par_iter">fairly simple wrapper</a> around <code>join</code> .  At the moment, it looks more like a concentrate than anything else.  But what‚Äôs really elegant about it is that it does not require <em>any</em> <abbr title="Here, the unsafe, or unsafe code is one that can lead to undefined behavior when working with memory - in Rust such code is possible only in special unsafe blocks {}">unsafe code</abbr> related to concurrency.  That is, the API of parallel iterators is simply built on the basis of <code>join</code> , which hides all unsafe code.  (To be more precise, there is still quite a bit of unsafe code associated with <a href="">managing uninitialized memory</a> when constructing a vector. But this code has nothing to do with <em>parallelism</em> , similar code can be found in the <code>Vec</code> implementation. This code is also not correct in some boundary cases because I didn‚Äôt have time to write it properly.) <br>  I do not want to dive too much into the details of the implementation of the parallel iterator, because according to my plans it will still change.  But at a high level, the idea is that we have a <code>ParallelIterator</code> type <a href="">with the following main methods</a> : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParallelIterator</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shared</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Sync</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span></span>: ParallelIteratorState&lt;Shared=Self::Shared, Item=Self::Item&gt; + <span class="hljs-built_in"><span class="hljs-built_in">Send</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">state</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; (Self::Shared, Self::State); ... <span class="hljs-comment"><span class="hljs-comment">//    ,  `map`  . . }</span></span></code> </pre><br>   ,   <code>state</code>    -     <em> </em> .    ()    ,       <code>Sync</code> (      ).          <code>join</code> ,        <code>Send</code> (    ). <br> <a href=""></a> <code>ParallelIteratorState</code>      (, -  ).    : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParallelIteratorState</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Sized</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shared</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Sync</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; ParallelLen; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">split_at</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, index: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; (<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for_each</span></span></span></span>&lt;OP&gt;(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, shared: &amp;Self::Shared, op: OP) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> OP: <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>(Self::Item); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The method </font></font><code>len</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gives an idea of ‚Äã‚Äãthe amount of work remaining. </font><font style="vertical-align: inherit;">The method </font></font><code>split_at</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">divides this state into two parts. </font><font style="vertical-align: inherit;">The method </font></font><code>for_each</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">processes all values ‚Äã‚Äãfrom this iterator. </font><font style="vertical-align: inherit;">So, for example, a parallel iterator for the slice </font></font><code>&amp;[T]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">should be:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to implement </font></font><code>len</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which simply returns the length of the slice,</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implement </font></font><code>split_at</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which will cut the slice into two sub-slice,</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and implement </font></font><code>for_each</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which will </font><font style="vertical-align: inherit;">go </font><font style="vertical-align: inherit;">through the array and cause an operation for each element </font></font><code>op</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li></ul><br>    ,      ,      .     ,    ,      .      (,       ,    ): <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span></span>(shared, state) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.len() is too big { <span class="hljs-comment"><span class="hljs-comment">//     let midpoint = state.len() / 2; let (state1, state2) = state.split_at(midpoint); rayon::join(|| process(shared, state1), || process(shared, state2)); } else { //     state.for_each(|item| { // process item }) } }</span></span></code> </pre><br>  ,       <a href="">   </a>  <a href="">     </a> . <br><br><h3>     </h3><br>      Rayon.     ,  ,   ,        . <br>  ,   ,       Rust.        .     Rust, ,  ,   Erlang ,      ,    .      ,       quicksort. ,     ,               quicksort. <br>     <a href="http://smallcultfollowing.com/babysteps/blog/2013/06/11/data-parallelism-in-rust/"></a> <a href="http://smallcultfollowing.com/babysteps/blog/2012/06/11/hotpar/"></a> ,    ,    <code>Rayon</code> ‚Äî    .    ,         ,    <em></em> ‚Äî            Rust    ,   .  ,         : <br><ul><li> <em><a href="http://smallcultfollowing.com/babysteps/blog/2012/11/18/imagine-never-hearing-the-phrase-aliasable/">,      </a></em> . ,  ,     <code>&amp;mut</code>   ,    <code>const</code> - (   ,   ) <em>(  ,   Rust    , ,   -  ,         <code>const</code>  ‚Äî . .)</em> .  ,   Rust   , <em> </em>    . </li><li> <a href="">  Send</a> , RFC458.    <code>Send</code> ,       .   RFC   <a href="https://github.com/pythonesque"> </a>      <code>Send</code> -:     <code>'static</code> ,        .     Erlang,       ,      ,   . -         ,              . <br>  ,       <code>'static</code>   <code>Send</code> ,     ! </li></ul><br><br><h3> :         </h3><br>   ,        quicksort,      ,    .        quicksort   .  ,    Rust             .    <a href="">,      </a> . <br> -,   <code>Joiner</code> ,     <code>join</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Joiner</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">///    ,    . fn is_parallel() -&gt; bool; ///   `rayon::join`,   `oper_a(); oper_b();`. fn join&lt;A,R_A,B,R_B&gt;(oper_a: A, oper_b: B) -&gt; (R_A, R_B) where A: FnOnce() -&gt; R_A + Send, B: FnOnce() -&gt; R_B + Send; }</span></span></code> </pre><br>      ,      : <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parallel</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Joiner <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Parallel { .. } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequential</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Joiner <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Sequential { .. }</code> </pre><br>    <code>quick_sort</code>       <code>J: Joiner</code> ,    (  ).         : <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quick_sort</span></span></span></span>&lt;J:Joiner, T:<span class="hljs-built_in"><span class="hljs-built_in">PartialOrd</span></span>+<span class="hljs-built_in"><span class="hljs-built_in">Send</span></span>&gt;(v: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> [T]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v.len() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     ,    5K: if J::is_parallel() &amp;&amp; v.len() &lt;= 5*1024 { return quick_sort::&lt;Sequential, T&gt;(v); } let mid = partition(v); let (lo, hi) = v.split_at_mut(mid); J::join(|| quick_sort::&lt;J,T&gt;(lo), || quick_sort::&lt;J,T&gt;(hi)); }</span></span></code> </pre></div><p>Source: <a href="https://habr.com/ru/post/274299/">https://habr.com/ru/post/274299/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274287/index.html">Threads vs processes using the example of native Node.js add-on for load testing</a></li>
<li><a href="../274289/index.html">Dolphin Smalltalk 7 is released under open source license MIT</a></li>
<li><a href="../274291/index.html">HPE service: harsh weekdays and funny stories</a></li>
<li><a href="../274293/index.html">Adobe has released an emergency patch to fix critical vulnerabilities Flash Player</a></li>
<li><a href="../274295/index.html">Prototype messaging service Geotalk</a></li>
<li><a href="../274301/index.html">Opening a new data center Hydro66</a></li>
<li><a href="../274303/index.html">Why does percentile calculation not work as expected?</a></li>
<li><a href="../274305/index.html">Custom Cortina in Unity 5.3</a></li>
<li><a href="../274307/index.html">Video of the best reports of the JPoint 2015 Java Conference - Part 1</a></li>
<li><a href="../274309/index.html">New Year's gift from the Russian hoster low-cost</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>