<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Clang API. Start</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Now we can say with confidence that the times of self-written C ++ parsers are gradually passing away. Clang - a full-fledged C ++ - fronrend and comp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Clang API. Start</h1><div class="post__text post__text-html js-mediator-article">  Now we can say with confidence that the times of self-written C ++ parsers are gradually passing away.  Clang - a full-fledged C ++ - fronrend and compiler, which provides its users with a rich API, is slowly and inexorably entering the scene.  Using this API, you can parse the source text to C / C ++ / Objective C, and pull out all the necessary information from it - from the simple lexical meaning of tokens, to the symbol table, AST-trees and the results of static code analysis for all sorts of different problems.  In conjunction with llvm and with a strong desire, C ++ can be used as a scripting language, parsing and executing C ++ programs on the fly.  In general, the opportunities for programmers are rich, you just need to understand how to use them correctly.  And then, as often happens, the fun begins. <br><a name="habracut"></a><br><h4>  1. Clang or clang-c? </h4><br>  We must start with the fact that the developers of clang provide their clients with two types of API.  The first is completely ‚Äúplus‚Äù, but ... potentially unstable (in the sense that it can vary from version to version).  The second is guaranteed to be stable, but ... pure "sishnoe."  The choice in favor of one or the other should be made according to the situation, and based on the needs of the product developed on the basis of clang. <br><br><h5>  1.1 clang-c API </h5><br>  In the clang source tree, the implementation of this library is located in the tools branch (the implementation of the clang kernel itself is located in the lib).  This library is compiled into a dynamically loadable module, and its interface provides the client with a number of guarantees: <br><ol><li>  Stability and backward compatibility.  The client can safely go for himself (that is, for his code) from one version of clang to another, without fear that something will fall off or, worse, stop gathering. </li><li>  It is possible to determine the capabilities of the used clang implementation in runtime, and adjust to them. </li><li>  High resiliency - fatal errors in the clang kernel will not lead to client crash. </li><li>  Own flow control for heavyweight activities (like parsing). </li><li>  There is no need to compile the front-end itself, since all the functionality of the compiler and API is assembled as one dynamically loaded library. </li></ol><br>  But, for the listed advantages it is necessary to pay.  Therefore, the clang-c API has the following set of disadvantages: <br><ol><li>  Design in accordance with the ship-in-bottle pattern.  The entities with which the client of this API interacts are, in essence, wrappers over the original classes provided by the clang API. </li><li>  (as a result) Manual resource management.  For convenient use from C ++ code, it is necessary to write wrappers providing RAII. </li><li>  Very "narrow" interface.  The client is provided with a small set of C-methods and types through which it interacts with the kernel. </li><li>  (as a result) rather poor set of functionality.  Many of the tools provided by the clang API are simply not available to the client, or are provided in a reduced form. </li></ol><br>  It makes sense to use this API option in cases where the existing set of ‚Äúpluses‚Äù is essential for client code.  Well, or "cons" are not so principled.  This API is quite suitable for extracting semantic information from the source text (both in the form of AST and in the form of the semantic load of each specific token in the source text), its infrequent indexing, on-the-fly verification with the collection of all diagnostics, etc. tasks.  Accordingly, it is suitable for various kinds of standalone translators, meta-information generators, static analyzers and code verifiers, etc. <br>  And, in turn, this API is poorly suited for tasks that require increased performance, or more dense interaction with the compiler core. <br><br><h5>  1.2 clang API </h5><br>  This version of the API is essentially the interface of the compiler core itself.  This API is purely C ++, and provides wide access to all features of the clang kernel.  Its advantages include: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  As already mentioned, direct and convenient access to all features of the compiler. </li><li>  Convenient (at least compared to clang-c) interface. </li><li>  A large number of all kinds of customizations. </li><li>  Slightly higher performance (compared to clang-c). </li></ol><br>  And, partly as a result, disadvantages: <br><ol><li>  Client security from possible drops inside the kernel. </li><li>  No warranty backward compatibility on the interface. </li><li>  Delivery in the form of static libraries.  The client is forced to link directly to the kernel and, as a result, build clang and llvm for its configuration. </li><li>  "Verbosity."  In a number of source code scenarios (compared to the clang-c API), this is more. </li><li>  Not everything is documented. </li><li>  High degree of connectivity with llvm API.  Without llvm, you cannot use clang.  With this you just need to accept. </li></ol><br>  How significant are the disadvantages, and whether they outweigh the advantages - it is necessary to decide on the situation.  In my opinion, this use case of clang should be chosen everywhere, good performance is required, or access to specific features not available through clang-c.  In particular, when using clang as an on-the-fly-parser for IDE, it makes sense to use this particular API version. <br><br><h4>  2. Getting started, or source parsing </h4><br>  Why then, one wonders, is this clang needed at all?  Indeed, parsing the source text in order to extract information from the developer or to turn it into a byte-code is the main task of the clang frontend.  And to solve this problem, clang provides rich opportunities.  Probably too rich.  Frankly, I was slightly taken aback when I first opened one of the examples for clang - the manipulations it produced seemed to me from the field of black magic, because they did not coincide with the intuitive ideas about how this parsing should look like.  In the end, everything turned out to be quite logical, although the installation of the parsing options by passing an array of strings describing the command line arguments still discourages me. <br><br><h5>  2.1 Parsing with clang-c </h5><br>  If my acquaintance with clang would start with an example built on the basis of this API, there would be less surprise.  In fact, file parsing is done in two calls.  The first creates an instance of the CXIndex object, the second - initiates the actual parsing of the source text and the construction of the AST.  Here is what it looks like in the source code: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;clang-c/Index.h&gt; int main (int argc, char** argv) { CXIndex index = clang_createIndex ( false, // excludeDeclarationFromPCH true // displayDiagnostics ); CXTranslationUnit unit = clang_parseTranslationUnit ( index, // CIdx "main.cpp", // source_filename argv + 1 , // command_line_args argc - 1 , // num_command_line_args 0, // unsave_files 0, // num_unsaved_files CXTranslationUnit_None // options ); if (unit != 0 ) std::cout &lt;&lt; "Translation unit successfully created" &lt;&lt; std::endl; else std::cout &lt;&lt; "Translation unit was not created" &lt;&lt; std::endl; clang_disposeTranslationUnit(unit); clang_disposeIndex(index); }</span></span></span></span></code> </pre> <br><br>  The first method ( <i>clang_createIndex</i> ) creates a context within which instances of translation units ( <i>CXTranslationUnit</i> ) will be created and parsed.  It takes two parameters.  The first ( <i>excludeDeclarationsFromPCH</i> ) controls the visibility of ads read from the precompiled header during the crawling process of the received AST.  A value of 1 means that such ads will be excluded from the final AST.  The second parameter ( <i>displayDiagnostics</i> ) controls the <i>display of</i> diagnostics obtained during the translation process to the console. <br>  The second method ( <i>clang_parseTranslationUnit</i> ) performs the actual parsing of the file with the source text.  This method has the following parameters: <br><ul><li>  <i>CIdx</i> is a pointer to the context created by calling clang_createIndex. </li><li>  <i>source_filename</i> - path to the file to be parsed. </li><li>  <i>command_line_args</i> - command line arguments that will be converted to compiler options. </li><li>  <i>num_command_line_args</i> - the number of arguments in the command line passed as the previous parameter. </li><li>  <i>unsaved_files</i> - a collection of files whose actual contents is in memory, and not on disk. </li><li>  <i>num_unsaved_files</i> - the number of elements in the collection of unrecorded files. </li><li>  <i>options</i> - additional parsing options. </li></ul><br>  As you can see, the entire configuration of the parser is done by passing the command line arguments to the parser in text form.  The <i>unsaved_files</i> parameter <i>is</i> useful in clang use scenarios from editors or IDEs.  Through it, you can transfer to the parser those files that have been modified by the user but have not yet been saved to disk.  This is a collection of structures of type <i>CXUnsavedFile</i> , containing the file name, its contents, and the size of the content in bytes.  The name and content are specified as C-lines, and the size as an unsigned integer. <br>  The last parameter ( <i>options</i> ) is a set of the following flags: <br><ul><li>  <i>CXTranslationUnit_None</i> - everything is obvious.  No special parsing options are set. </li><li>  <i>CXTranslationUnit_DetailedPreprocessingRecord</i> - setting this option indicates that the parser will have to generate detailed information about how and where the preprocessor is used in the source text.  As is clear from the documentation, the option is rarely used, leads to the consumption of a large amount of memory, and it should be installed only in cases where such information is really required. </li><li>  <i>CXTranslationUnit_Incomplete</i> ‚Äî setting this option indicates that an <i>incomplete</i> (not completed) translation unit is being processed.  For example, the header file.  In this case, the translator will not attempt to instantiate templates that should have been instantiated before the translation is completed. </li><li>  <i>CXTranslationUnit_PrecompiledPreamble</i> - setting this option indicates that the parser should automatically create a precompiled header for all header files that are included at the beginning of the translation unit.  This option is useful if the file will be repaired frequently (using the clang_reparseTranslationUnit method), but with its own features, which will be described in the next section. </li><li>  <i>CXTranslationUnit_CacheCompletionResults</i> - setting this option causes that after each subsequent reparsing some of the code completion results will be saved. </li><li>  <i>CXTranslationUnit_SkipFunctionBodies</i> ‚Äî setting this option causes the body of functions and methods to not be processed during the translation.  Useful for quick search of ads and definitions of certain characters. </li></ul><br>  Flags can be combined using the '|' operation. <br><br>  The last two methods ( <i>clang_disposeTranslationUnit</i> and <i>clang_disposeIndex</i> ) remove previously created handles that describe the translation unit and context. <br>  To successfully build this sample code, simply add the libclang library. <br><br><h5>  2.1 Parsing with the clang API </h5><br>  Similar (by functionality) code using the clang API looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt; #include &lt;iostream&gt; #include &lt;clang/Basic/Diagnostic.h&gt; #include &lt;clang/Frontend/DiagnosticOptions.h&gt; #include &lt;clang/Frontend/CompilerInstance.h&gt; #include &lt;clang/Frontend/CompilerInvocation.h&gt; #include &lt;clang/Frontend/Utils.h&gt; #include &lt;clang/Frontend/ASTUnit.h&gt; int main(int argc, char ** argv) { using namespace clang ; using namespace llvm ; // Initialize compiler options list std::vector&lt; const char *&gt; args; for (int n = 1; n &lt; argc; ++ n) args.push_back(argv[n]); args.push_back("main_clang.cpp" ); const char** opts = &amp;args.front(); int opts_num = args.size(); // Create and setup diagnostic consumer DiagnosticOptions diagOpts; IntrusiveRefCntPtr&lt; DiagnosticsEngine&gt; diags(CompilerInstance::createDiagnostics( diagOpts, // Opts opts_num, // Argc opts, // Argv 0, // Client true, // ShouldOwnClient false // ShouldCloneClient )); // Create compiler invocation IntrusiveRefCntPtr&lt; CompilerInvocation&gt; compInvoke = clang::createInvocationFromCommandLine( makeArrayRef(opts, opts + opts_num), // Args diags // Diags ); if (!compInvoke) { std::cout &lt;&lt; "Can't create compiler invocation for given args" ; return -1; } // Parse file clang::ASTUnit *tu = ASTUnit ::LoadFromCompilerInvocation( compInvoke.getPtr(), // CI diags, // Diags false, // OnlyLocalDecls true, // CaptureDiagnostics false, // PrecompilePreamble TU_Complete, // TUKind false // CacheCodeCompletionResults ); if (tu == 0 ) std::cout &lt;&lt; "Translation unit was not created" ; else std::cout &lt;&lt; "Translation unit successfully created" ; return 0; }</span></span></span></span></code> </pre><br><br>  There are much more letters in it, and assembly requires the following set of libraries: <i>clangLex, clangBasic, clangAST, clangSerialization, clangEdit, clangAnalysis, clangFrontend, clangSema, clangDriver, clangParse, LLVMCO,,,,,,</i> <i>llanMeSema</i>  When building under Windows, you also need to add advapi32 and shell32.  But the output will be an executable module without unnecessary external dependencies. <br>  The above code can be divided into four parts: <br><ol><li>  Creating a collection of command line parameters for the compiler.  In this API version, the path to the file that needs to be parsed is also passed as one of the elements of the collection; therefore, in this case, argv and argc cannot be transmitted directly. </li><li>  Create an instance of the Diagnostic Engine.  The object of this class is responsible for collecting and storing all error messages, warnings and other diagnostics that can be generated by the parser in the process of parsing the source text. </li><li>  Creating an instance of the Compiler Invocation. </li><li>  Actually parsing the source text. </li></ol><br><br><h6>  Creating a collection of command line arguments </h6><br>  As I wrote above, clang operation options are set by passing to the appropriate classes a collection of strings describing these settings.  Strings are transmitted as an array of pointers and it is most convenient to do this by means of an intermediate vector.  In this case, you can add to your arguments from the outside any number of your own.  In particular, the name of the file to be parsed. <br><br><h6>  Creating a Diagnostic Engine </h6><br>  Creating a DE is necessary in order to get various diagnostic information from the clang parser, which it generates when parsing the source text.  Parameters such as the maximum number of displayed errors, which errors / warnings to display, etc. DE takes from the command line, which are transmitted by the second and third parameters.  The last three parameters describe the ‚Äúdiagnostic client‚Äù.  This is a special class to which DE will transmit parser messages (as they arise) for further processing in a user-specific clang manner.  DE can take control of the client‚Äôs lifetime for itself, or work with a clone of the transferred object.  This allows you to use different client implementation scenarios - in the form of a static / automatic object, in the form of an object on the heap, as part of the class, in whose methods you work with the clang API, etc. <br><br><h6>  Creating a Compiler Invocation </h6><br>  At this step, in fact, a context is created within which parsing will be performed.  All parameters of the transmitted command line, environment variables are analyzed, the entire internal infrastructure is created (in accordance with these parameters), the Diagnostic Engine is connected.  After that, the clang is fully ready to parse the file that was passed as the last parameter. <br><br><h6>  Source parsing </h6><br>  It is implemented by calling one of the static methods of the clang: ASTUnit class.  There are several such methods, they are sharpened for different scenarios.  The example shows one of the possible options.  In this case, the compiler invocation instance is passed to the parser (the parser will then delete it itself!), The Diagnostic Engine instance (its parser will not be automatically deleted), and several parameters controlling the behavior of the parser: <br><ul><li>  <i>OnlyLocalDecls</i> - only the declarations from the translation unit that parsed will be included in the final AST.  Declarations from PCH and attached header files will be excluded. </li><li>  <i>CaptureDiagnostic</i> - controls the way diagnostics are collected.  If this parameter is set to false, then all collected diagnostics will be transferred to the diagnostic client specified when the Diagnostic Engine was created.  Otherwise, the diagnostics will be stored in the internal structures of ASTUnit. </li><li>  <i>PrecompilePreamble</i> - as mentioned above, when this option is enabled, the parser will automatically create PCH for all included headers in the source code.  Yes indeed.  Useful when repeating parsing.  But, as it turned out, there are some not quite pleasant moments.  First, PCH is actually created by the first call to the <i>ASTUnit :: Reparse method</i> for the received ASTUnit instance.  Secondly, in case if the header file with # ifdef-guards is parsed, then, alas, nothing will be created. </li><li>  <i>TUKind</i> - type of translation unit.  Here are the following options: <br><ul><li>  <i>TU_Complete</i> - the fully completed translation unit is parsed.  In this case, all template instances used in the source text will also be placed in the final AST. </li><li>  <i>TU_Prefix</i> - parse the ‚Äúprefix for the translation unit‚Äù, in this case the source text is not considered complete. </li><li>  <i>TU_Module</i> - a certain "module" is parsed.  What it is - the documentation is silent. </li></ul></li><li>  <i>CacheCodeCompletionResults</i> - the code completion results will be cached during parsing.  Really helps with subsequent requests code completion. </li></ul><br><br><h4>  3. Little tricks in the set of options </h4><br>  In my first experiments (it was the parsing of header files for extracting declarations), I didn‚Äôt understand the reason why parsing ended with a lot of errors.  In the end, everything was quite simple.  So, options that may be useful: <br><ul><li>  <b>-x</b> <i>language</i> - indicates the specific type of file that is being parsed.  Compatible with the similar gcc compiler option. </li><li>  <b>-std =</b> <i>standard</i> - specifies the standard to which the source text corresponds.  By value compatible with the similar compiler option gcc. </li><li>  <b>-ferror-limit =</b> <i>N</i> - sets the maximum number of errors in N, after which the parsing will be completed.  If you want to parse the file completely ignoring any errors, then N must be equal to 0. </li><li>  <b>-include</b> <i>&lt;prefix-file&gt;</i> - specifies the file (usually the header file) that should be parsed before parsing the main file.  In general, this option is originally intended for connecting a PCH header, but when parsing files it may be useful, for example, to define various macros. </li></ul><br><br>  At this first acquaintance with the clang API can be considered complete.  You can read more about the clang-c API on the official clang website: <a href="http://clang.llvm.org/doxygen/group__CINDEX.html">clang.llvm.org/doxygen/group__CINDEX.html</a> <br>  <a href="http://clang.llvm.org/doxygen/annotated.html">There you</a> can also get acquainted with the entire class hierarchy of clang API.  Unfortunately, the documentation is automatically generated from the upstream clang, so the function signatures, their set, etc., described on the documentation site, may differ from those presented in this or that release. <br><br>  In the next article I will discuss how you can get a declaration tree from the AST created with clang. </div><p>Source: <a href="https://habr.com/ru/post/148508/">https://habr.com/ru/post/148508/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../148501/index.html">10 critical event ID to monitor</a></li>
<li><a href="../148502/index.html">NASA has developed a technology for 3D printing of spare parts for spacecraft.</a></li>
<li><a href="../148503/index.html">The first criminal case for failing to pay 1% to Mikhalkov</a></li>
<li><a href="../148505/index.html">Gabe Newell is going to support Linux, because Windows 8 is a ‚Äúdisaster‚Äù</a></li>
<li><a href="../148506/index.html">Testing the order form in the online store</a></li>
<li><a href="../148510/index.html">Video review tablet Acer Iconia Tab A700 (A701)</a></li>
<li><a href="../148511/index.html">Escape from Vlan. Bug Hack ?! Feature ... Or about the benefits of reading documentation</a></li>
<li><a href="../148512/index.html">Emulator Bluestacks + Eclipse: accelerates debugging and testing of Android applications</a></li>
<li><a href="../148513/index.html">The second tournament Habraigre "Startup"</a></li>
<li><a href="../148514/index.html">Search for a lost phone on Windows Phone 7 - in practice</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>