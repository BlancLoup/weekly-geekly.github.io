<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Richard Hamming: Chapter 11. Coding Theory - II</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúThe goal of this course is to prepare you for your technical future.‚Äù 
 Hi, Habr. Remember the awesome article "You and your work" (+219, 2442 bookma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Richard Hamming: Chapter 11. Coding Theory - II</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  ‚ÄúThe goal of this course is to prepare you for your technical future.‚Äù </blockquote><br><img src="https://habrastorage.org/getpro/habr/post_images/d67/6ff/9ea/d676ff9eadd2a38b0948de76bbf27fd4.jpg" alt="image" align="right">  Hi, Habr.  Remember the awesome article <a href="https://habrahabr.ru/post/209100/">"You and your work"</a> (+219, 2442 bookmarks, 393k reads)? <br><br>  So Hamming (yes, yes, self-checking and self-correcting <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25B4_%25D0%25A5%25D1%258D%25D0%25BC%25D0%25BC%25D0%25B8%25D0%25BD%25D0%25B3%25D0%25B0">Hamming codes</a> ) has a whole <a href="http://worrydream.com/refs/Hamming-TheArtOfDoingScienceAndEngineering.pdf">book</a> based on his lectures.  We translate it, because the man is talking. <br><br>  This book is not just about IT, it is a book about the thinking style of incredibly cool people.  <i>‚ÄúThis is not just a charge of positive thinking;</i>  <i>it describes the conditions that increase the chances of doing a great job. ‚Äù</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We have already translated 25 (out of 30) chapters.  And <a href="http://hamming.ru/">we are working</a> on the publication "in paper." <br><br><h3>  11. Coding Theory - II </h3><br>  <i>(For the translation, thanks to <a href="https://habr.com/users/erosinka/" class="user_link">erosinka</a> , who responded to my call in the "previous chapter.") Who wants to help with the translation - write in a personal or mail magisterludi2016@yandex.ru</i> <br><br>  Two things should be clear from the previous chapter.  First, we want the average length L of the sent message to be as small as possible (to save resources).  Secondly, this should be supported by statistical theory, since we cannot know which message will be sent, but we may know some statistical data using previous messages, and the subsequent output data may be similar to the previous ones.  For the simplest theory, the only one we can discuss here, we need the probabilities of the appearance of individual characters in the message.  The question of obtaining them is not part of the theory, but they can be obtained by examining past experience or imagined divination about the future use of the system you are designing. <br><a name="habracut"></a><br>  Thus, we want instantly uniquely decoded code for a given set of input symbols, si, along with their probabilities, pi.  What length li should we set (given that we have to obey Kraft's inequality) to get the minimum average code length?  Huffman solved this code design problem. <br><br>  Huffman was the first to show that the following inequalities must be true for a code of minimal length.  If pi is in descending order, then li should be in ascending order. <br><br><img src="https://habrastorage.org/webt/aj/pd/3c/ajpd3cczx2d_ornj6xn0wsppsq8.jpeg" alt="image"><br><br>  Suppose pi is in the specified order, but at least one pair li is not.  Consider the effect of permuting characters associated with those two that are not in the specified order.  Before permutation, the contribution of these two terms of the equation to the average code length L <br><br><img src="https://habrastorage.org/webt/ss/s5/js/sss5jsfaqyaxgdjwaoa4-3q6iaq.jpeg" alt="image"><br><br>  and after permutation <br><br><img src="https://habrastorage.org/webt/g-/x_/0l/g-x_0lg5kos5icnezktuhqruo-k.jpeg" alt="image"><br><br>  All other terms in the sum L remain the same.  The difference can be written as <br><br><img src="https://habrastorage.org/webt/8z/ga/9y/8zga9yqp8khhat7ghr_ytoecjps.jpeg" alt="image"><br><br>  One of these terms is assumed to be negative; therefore, after rearranging two characters, the average length of the L code will decrease.  Thus for the minimum code length we must have two inequalities. <br><br>  Further, Huffman discovered that the code to be instantly decrypted has a decision tree, and each node must have two exits, otherwise it is an empty attempt, therefore, there are two characters with the longest length that have the same length. <br><br><img src="https://habrastorage.org/webt/iy/b2/do/iyb2doffuxd7dbzgoyrojdnuz60.jpeg" alt="image"><br><br>  To illustrate the HUffman code, we use the classic example.  Let p (s1) = 0.4, p (s2) = 0.2, p (s3) = 0.2, p (s4) = 0.1 and p (s5) = 0.1.  This is depicted in Figure 11.I Then Huffman argued, based on the values ‚Äã‚Äãabove, that he could combine (combine) two least frequent characters (which should have the same length) into one character with a common probability with common bits up to the last bit that is discarded, thus getting the code one character less.  (?) Repeating it again and again he came to a system with two characters, for which he knew how to attribute the presentation of a code, namely one symbol - 0, and the other - 1. <br><br><img src="https://habrastorage.org/webt/pn/y0/hw/pny0hwm37isue5mrjvh3xd8keuc.jpeg" alt="image"><br><br>  Now going in the opposite direction, at each stage we need to separate the character that came out of a combination of two characters, keeping the same leading bits, but adding 0 to one character and 1 to the other. In this way we will arrive at a code of minimum length L, See Figure 11.I again. As if there were another code with a shorter length L ', then performing steps forward that change the average code length by a given number, it would come to two characters with an average code length less than 1, which is impossible .  Consequently, the Huffman code has a minimum length.  See Figure 11.II with the corresponding decoding tree. <br><br>  This code is not unique.  First of all, at each step of the process, assigning 0 and 1 to each of the characters is an arbitrary process.  Secondly, if at any stage there are two symbols with the same probabilities, it does not matter which one will be the first.  This may in some cases lead to the appearance of very different codes, but they both will have the same average length. <br><br>  If we place the combined terms as high as possible, we get Figure 11.III with the corresponding decoding tree in Figure 11.IV.  The average length of the two codes is the same, but the codes and decoding trees are different;  the first is long, and the second is ‚Äúbranched,‚Äù and the second is less volatile than the first. <br><br>  Now we will give a second example so that you can be sure of how Huffman coding works, since it is a natural desire to use a code with the shortest possible average length in the process of developing a coding system.  For example, you may have a lot of data intended for storage backups, and it is known that coding it with a suitable Huffman code will save more than half the expected storage capacity.  Let p (s1) = ‚Öì, p (s2) =, p (s3) =, p (s4) = 1/10, p (s5) = 1/12, p (s6) 1/20, p ( s7) = 1/30, p (s8) = 1/30.  First we check that the sum of the probabilities is 1. The common denominator of fractions is 60. Thus, we get the total probability <br><br><img src="https://habrastorage.org/webt/ab/ns/x-/abnsx-g4mhg0_zkvwrm-e2hvjxu.jpeg" alt="image"><br><br><img src="https://habrastorage.org/webt/sl/xe/wo/slxewo6mrjbhqq3xjw6u7qfgtke.jpeg" alt="image"><br><br><img src="https://habrastorage.org/webt/rs/ct/6x/rsct6xpcfnswen86mlqts60kzi8.jpeg" alt="image"><br><br>  The second example is illustrated in Figure 11.V, where we omitted 60 in the denominator of probabilities, since only relative values ‚Äã‚Äãmatter.  What is the average code length per character?  We calculate <br><br><img src="https://habrastorage.org/webt/gx/ax/4w/gxax4waonsylhldsofmsdnjprvk.jpeg" alt="image"><br><br>  For a code block of 8 characters each character will be 3 length and the average length will be 3, which is greater than 2.58 <br><br>  Notice how this mechanical process is suitable for the machine.  Each straight step for Huffman coding is a repetition of the same process: combine the 2 lowest probabilities, put the new amount in the right place in the array and mark it.  In the reverse process, we take the marked symbol and share it.  These programs are easy to write for a computer, so a computer program can calculate the Huffman code from the data si and their probabilities pi.  Remember, in practice, you want to assign a return character with a very small probability, so that you can complete the decoding process at the end of the message.  In fact, you can write a program that can select data for storage and find an estimate of the probabilities (small errors lead only to small changes in L), find the Huffman code, encode and send the first decoding algorithm (tree) and then the encoded data, and all this without human intervention!  At the end of the decoding, you have already received a decoding tree.  Thus, once having written a program, you can use it in cases where you find it useful. <br><br>  The Huffman codes were used even in some computers in the instructions, since they had a very small chance of being used.  Therefore, we need to look at the improvement in the average length of the L code, which we can expect when using Huffman coding, compared to simple block coding, which uses the same length for all characters. <br><br>  If all probabilities are the same and there are exactly 2 ^ k characters, then a study of Huffman coding will show that you get a standard block code with the same length.  If there are not exactly 2 ^ k characters, then some of them will be shorter, but it is difficult to say whether most of them will be shorter by 1 bit, or some will be shorter by 2 or more bits.  In any case, the value of L will be the same, and not much shorter than in the corresponding block code. <br><br>  On the other hand, if each of pi is greater than ‚Öî (the sum of all subsequent probabilities, except the last), then you will get a code with a comma, in which 1 character is 1 (0) long, one character is 2 (10), and so on until end where you will have two characters of the same length (q-1): (1111 ... 10) and (1111 ... 11).  In this case, the length L may be much shorter than that of the corresponding block code. <br><br>  Rule: Huffman coding pays off if the probabilities of the characters are very different, and it does not pay off when they are approximately equal. <br><br>  When two equal probabilities appear in the HUffman process, they can be arranged in any order, and thus the codes can be very different, although the average length of the L code in both cases will be the same.  It is natural to ask what order should be chosen in the case of two equal probabilities.  A reasonable criterion is to minimize the variation of the code so that messages of the same length in the original characters have approximately the same length in coded form, you do not want the original short message to be randomly encoded with a long message.  The rule is simple: each new probability to insert into the table as high as possible.  In fact, if you place it above the symbol with a slightly higher probability, you will significantly reduce the variation and only slightly increase L;  so this is a good strategy. <br><br>  After completing all the steps, we will proceed to coding the source code (although we have by no means gone through the whole topic).  We turn to the coding channel with simulated noise.  The channel is assumed to have noise, which means that some bits have been changed during transmission (or storage).  What can be done? <br><br>  Finding a single error is pretty simple.  To the block of (n-1) bits you need to attach the n-th bit with such a value that all n bits have an even number 1 (or odd if you want, but we will use an even number).  This is called an even parity (odd) check. <br><br>  Thus, if all sent messages have this property, then at the receiving end you can check whether it is executed.  If the parity check fails, it will be known that there is at least one error, in fact, an odd number of errors.  Since it is prudent to use systems with a low probability of error in any position, the probability of several errors should be even lower. <br><br>  For mathematical suitability, we assume that the channel has white noise, which means 1) each position in a block of n bits has the same error probability with any other position and 2) errors in different positions are uncorrelated, which means independent.  With these assumptions, the error probabilities are equal <br><br><img src="https://habrastorage.org/webt/51/zu/gp/51zugpjnbbcrdxr22yncrjfog1g.jpeg" alt="image"><br><br>  From this it follows that if, as usual, p is small relative to the length of the block n (which means the product of np is small), then multiple errors are much less likely than single errors.  The choice of the length n for a given probability p is an engineering solution.  If n is small, then you will have more redundancy (the ratio of the number of bits sent to the minimum possible number of bits n / (n-1)) than with a large n, but if np is large, then you will have a small redundancy, but a higher probability not detect the error.  You must make an engineering decision on how to balance these two effects. <br>  If a single error is detected, you can ask to resend the message, expecting a correct result a second time, or a third, and so on.  However, if the stored message is incorrect, you will ask for a retransmission until another error occurs, and you may have two undetected errors in the single error detection scheme.  Thus, retransmissions should depend on the expected nature of the errors. <br><br>  Such codes were widely used even in relay times.  The telephone company used code 2-of-5 in central offices and in early relay machines, which meant that only 2 out of 5 relays were in the ‚Äúon‚Äù position.  This code was used to represent the decimal digit, since C (5, 2) = 10.  If not exactly 2 relays were in the ‚Äúon‚Äù position, this meant an error, and there was a repeat.  There was also a 3-out-7 code, obviously, an odd-check code. <br><br>  I first met these 2-of-5 codes when using the Model 5 relay at Bell Labs, and I was impressed not only by their help in getting the right answer, but more importantly in my opinion, they gave technicians the opportunity to Actually maintain the machine.  Any error was detected by the machine almost at the time of the commission, and therefore instructed the technical staff in the right direction, instead of leading them by the nose, forcing them to change the settings of the correctly working parts in an attempt to find a fault. <br><br>  Violating the temporal sequence of the narrative, but remaining in the ideological, AT &amp; T (approx. American transnational telecommunications conglomerate) once asked me how to use coding if people used an alphabet of 26 letters, 10 decimal digits and a space.  This is typical of inventory naming, part naming, and many other item names, including building naming.  I knew from the data on the mistakes of dialing phone numbers and from a long experience in programming that people have a pronounced tendency to rearrange adjacent numbers: 67 can become 76, as well as replacing isolated numbers (usually doubling the number: 556 will probably become 566) .  Thus, the detection of one-time errors is not enough.  I brought two very capable people into the meeting room and asked them a question.  I rejected sentence by sentence as not good enough, until at last one of them, Ed Gilbert, proposed a weighted code.  In particular, he proposed to designate the numbers 0, 1, 2, ... 36 characters 0, 1, ... 9, A, B, ..., Z, space.  Then he didn‚Äôt calculate the sum of the values, but whether the kth symbol had a value (noted for convenience) Sk, then for a message of n symbols we calculate <br><br><img src="https://habrastorage.org/webt/j9/yy/6y/j9yy6yqpi_zx-qjjrzjzpbubgdi.jpeg" alt="image"><br><br>  ‚ÄúModulo‚Äù here means that the weighted sum is divided by 37 and only the remainder of the division is used.  To encode a message of n characters, leave the first character, k = 1, empty and regardless of the remainder value, which is less than 37, subtract it from 37, and use the appropriate character to check which you need to put in the first position.  Thus, the entire message with the verification character in the first position will have a verification amount equal to 0. If you consider rearranging any two different characters or replacing a single character, you will notice that this will break the weighted parity check, modulo 37 (assuming that the replaced characters are at a distance not equal to 37 characters).  Without going into details, we note that it is important that the module is a simple number, which is 37. <br><br>  To get a weighted sum of a symbol (in fact, their values), if you wish, you can avoid the products and use only additions and subtractions.  Arrange the characters in order in the column and calculate the subtotals, then the subtotals of subtotals modulo 37, then add this to 37, and you will get a check digit.  As an illustration using w, x, y, z. <br><br><img src="https://habrastorage.org/webt/r-/ys/9g/r-ys9gpmz-o4zolyzltakti9_fy.jpeg" alt="image"><br><br>  On the receiving side, you re-subtract the module until you get either a-0 (the correct character) or a is a negative number (the wrong character). <br><br>  If you need to use this coding, for example, to name the inventory, then if the wrong name appeared for the first time during the transfer, if not earlier (perhaps in the preliminary process), then the error will be detected, you will not have to wait until the order is will be delivered to headquarters to receive a reply later that there is no such name, or to receive an incorrect order.  The error will be detected before the order leaves you and therefore it is easy to fix.  Simply?  Yes!  Effectively against human error (as opposed to the white noise example), yes! <br><br>  Indeed, these days you can see a similar code on books with an ISBN number.  This is the same code, only it uses 10 decimal digits, and the number 10 is not a prime number, so they had to enter the 11th character X, which may appear at times during a parity check - indeed, approximately every 11th book will be have X as the last character in the ISBN parity number.  Dash mainly perform a decorative function and are not used in coding.  Check it yourself on your textbooks.  Many other large organizations could use such codes for good effect if they wanted to make an effort. <br><br>  I have repeatedly pointed out that I believe that in the future information in the form of symbols will be important, and material things will be less important, and therefore, the theory of coding (representing) information into convenient codes is a non-trivial topic.  The material above gives simple error detection code for machines, and weighted code for human use.  These are just 2 examples of how coding theory can help in situations where machine and human error is possible. <br><br>  When you think about the human-computer interface, one of the things that can be useful to you is the need to make as few keystrokes as possible with a person ‚Äî Huffman coding under cover!  Obviously, given the probabilities of various branches in the program menus, you can, if you wish, think up a way to reduce the total number of keystrokes.  Thus, the same menu set can be customized to the habits of different people, instead of offering everyone the same interface.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In a broader sense, ‚Äúautomated programming‚Äù in high-level languages ‚Äã‚Äãis an attempt to achieve something like Huffman coding, to use relatively few keystrokes to solve desired tasks, and to use other keys for other tasks. </font></font><br><br>  <i>To be continued...</i> <br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Who wants to help with the translation, layout and publication of the book - write in a personal or mail magisterludi2016@yandex.ru</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> By the way, we also started the translation of another cool book - </font></font><a href="https://habrahabr.ru/post/349916/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúThe Dream Machine: The History of Computer Revolution‚Äù</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Book content and translated chapters</font></font></b> <div class="spoiler_text">  <a href="https://habr.com/post/345752/">Foreword</a> <br><ol><li> Intro to The Art of Doing Science and Engineering: Learning to Learn (March 28, 1995) <a href="https://habrahabr.ru/post/348770/">:  1</a> </li><li> ¬´Foundations of the Digital (Discrete) Revolution¬ª (March 30, 1995) <a href="https://habrahabr.ru/post/345836/"> 2.   () </a> </li><li> ¬´History of Computers ‚Äî Hardware¬ª (March 31, 1995) <a href="https://habr.com/post/349936/"> 3.   ‚Äî </a> </li><li> ¬´History of Computers ‚Äî Software¬ª (April 4, 1995) <a href="https://habrahabr.ru/post/346566/"> 4.   ‚Äî </a> </li><li> ¬´History of Computers ‚Äî Applications¬ª (April 6, 1995) <a href="https://habr.com/post/351148/"> 5.   ‚Äî  </a> </li><li> ¬´Artificial Intelligence ‚Äî Part I¬ª (April 7, 1995) <a href="https://habr.com/post/351404/"> 6.   ‚Äî 1</a> </li><li> ¬´Artificial Intelligence ‚Äî Part II¬ª (April 11, 1995) <a href="https://habr.com/post/414265/"> 7.   ‚Äî II</a> </li><li> ¬´Artificial Intelligence III¬ª (April 13, 1995) <a href="https://habrahabr.ru/post/349934/"> 8.  -III</a> </li><li> ¬´n-Dimensional Space¬ª (April 14, 1995) <a href="https://habrahabr.ru/post/348264/"> 9. N- </a> </li><li> ¬´Coding Theory ‚Äî The Representation of Information, Part I¬ª (April 18, 1995) <i>(  :((( )</i> </li><li> ¬´Coding Theory ‚Äî The Representation of Information, Part II¬ª (April 20, 1995) </li><li> ¬´Error-Correcting Codes¬ª (April 21, 1995) <i>()</i> </li><li> ¬´Information Theory¬ª (April 25, 1995) <i>(  :((( )</i> </li><li> ¬´Digital Filters, Part I¬ª (April 27, 1995) <a href="https://habr.com/post/348276/"> 14.   ‚Äî 1</a> </li><li> ¬´Digital Filters, Part II¬ª (April 28, 1995) <a href="https://habr.com/post/354878/"> 15.   ‚Äî 2</a> </li><li> ¬´Digital Filters, Part III¬ª (May 2, 1995) <a href="https://habr.com/post/354964/"> 16.   ‚Äî 3</a> </li><li> ¬´Digital Filters, Part IV¬ª (May 4, 1995) <a href="https://habr.com/post/414927/"> 17.   ‚Äî IV</a> </li><li> ¬´Simulation, Part I¬ª (May 5, 1995) <i>( )</i> </li><li> ¬´Simulation, Part II¬ª (May 9, 1995) <a href="https://habr.com/post/346564/"> 19.  ‚Äî II</a> </li><li> ¬´Simulation, Part III¬ª (May 11, 1995) </li><li> ¬´Fiber Optics¬ª (May 12, 1995) <a href="https://habr.com/post/413253/"> 21.  </a> </li><li> ¬´Computer Aided Instruction¬ª (May 16, 1995) <i>(  :((( )</i> </li><li> ¬´Mathematics¬ª (May 18, 1995) <a href="https://habrahabr.ru/post/346562/"> 23. </a> </li><li> ¬´Quantum Mechanics¬ª (May 19, 1995) <a href="https://habrahabr.ru/post/345366/"> 24.  </a> </li><li> ¬´Creativity¬ª (May 23, 1995). : <a href="https://habrahabr.ru/post/336846/"> 25. </a> </li><li> ¬´Experts¬ª (May 25, 1995) <a href="https://habrahabr.ru/post/346560/"> 26. </a> </li><li> ¬´Unreliable Data¬ª (May 26, 1995) <a href="https://habr.com/post/413255/"> 27.  </a> </li><li> ¬´Systems Engineering¬ª (May 30, 1995) <a href="https://habrahabr.ru/post/346556/"> 28.  </a> </li><li> ¬´You Get What You Measure¬ª (June 1, 1995) <a href="https://habrahabr.ru/post/350144/"> 29.   ,   </a> </li><li> ¬´How Do We Know What We Know¬ª (June 2, 1995) <i>  :(((</i> </li><li> Hamming, ¬´You and Your Research¬ª (June 6, 1995). <a href="https://habrahabr.ru/post/209100/">:    </a> </li></ol><br>     ,     ‚Äî       magisterludi2016@yandex.ru <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/354872/">https://habr.com/ru/post/354872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354862/index.html">Angular and Spring authentication without Spring Security (Spring server)</a></li>
<li><a href="../354864/index.html">Richard Hamming: Chapter 12. Error Correction Codes</a></li>
<li><a href="../354866/index.html">Dapp features that make life easier</a></li>
<li><a href="../354868/index.html">How much is the habraburger</a></li>
<li><a href="../354870/index.html">The experience of creating a mobile application: it did not work the first time</a></li>
<li><a href="../354874/index.html">MIT course "Computer Systems Security". Lecture 1: Introduction: Threat Models, Part 1</a></li>
<li><a href="../354876/index.html">Swift for data scientist: quick dive in 2 hours</a></li>
<li><a href="../354878/index.html">Richard Hamming: Chapter 15. Digital Filters - 2</a></li>
<li><a href="../354880/index.html">Is it possible to consciously refuse functional programming?</a></li>
<li><a href="../354882/index.html">LAppS application server for microservice architecture</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>