<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimization of work with prototypes in JavaScript engines</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The material, the translation of which we are publishing today, was prepared by Mathias Beinens and Benedict Meirer. They are working on the V8 JS eng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimization of work with prototypes in JavaScript engines</h1><div class="post__text post__text-html js-mediator-article">  The material, the translation of which we are publishing today, was prepared by Mathias Beinens and Benedict Meirer.  They are working on the <a href="https://twitter.com/v8js">V8</a> JS engine at Google.  This article is devoted to some basic mechanisms that are typical not only for the V8, but also for other engines.  Familiarity with the internal structure of such mechanisms allows those who are engaged in JavaScript development to better navigate in terms of code performance.  In particular, here we will focus on the features of the engine optimization pipelines, and how to accelerate access to the properties of prototypes of objects. <br><br> <a href="https://habr.com/company/ruvds/blog/422321/"><img src="https://habrastorage.org/webt/za/lq/gg/zalqgg3vwvoc-wprqwob9r0fosq.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Code Optimization Levels and Tradeoffs</font> </h2><br>  The process of converting the texts of programs written in JavaScript into suitable for execution code looks approximately the same in different engines. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/534/0ab/f1e/5340abf1e4b0dfa64f1e2bb294765560.png"></div>  <i><font color="#999999">The process of converting source JS code to executable code</font></i> <br><br>  Details on this can be found <a href="https://mathiasbynens.be/notes/shapes-ics">here</a> .  In addition, it should be noted that although, at a high level, the pipelines for converting source code to executable are very similar for different engines, their code optimization systems often differ.  Why is this so?  Why do some engines have more optimization levels than others?  It turns out that the engines have to compromise one way or another, which is that they can either quickly generate a code that is not the most effective, but suitable for execution, or spend more time to create such code, but due to this, achieve optimal performance. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c56/e35/973/c56e359735f983dae9b32294192bd26d.png"></div>  <i><font color="#999999">Fast code preparation for execution and optimized code that prepares longer, but runs faster</font></i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The interpreter is able to quickly form a bytecode, but such code is usually not very effective.  An optimizing compiler, on the other hand, takes more time to generate code, but in the end it produces an optimized, faster machine code. <br><br>  This model of code preparation for execution is used in V8.  The V8 interpreter is called Ignition, it is the fastest of the existing interpreters (in terms of the execution of the original bytecode).  The optimizing V8 compiler is called TurboFan, it is responsible for creating highly optimized machine code. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e2b/624/62a/e2b62462a5f2563b27a6c362d031b7f2.png"></div>  <i><font color="#999999">Ignition interpreter and TurboFan optimizing compiler</font></i> <br><br>  The compromise between program launch delay and execution speed is the reason for some JS engines to have additional optimization levels.  For example, in SpiderMonkey, between the interpreter and the IonMonkey optimizing compiler, there is an intermediate level represented by the basic compiler (it is called ‚ÄúThe Baseline Compiler‚Äù in the Mozilla <a href="https://blog.mozilla.org/javascript/2013/04/05/the-baseline-compiler-has-landed/">documentation</a> , but ‚Äúbaseline‚Äù is not a proper name). <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c8/212/702/0c821270298b4860ab99918d2dd575a3.png"></div>  <i><font color="#999999">SpiderMonkey code optimization levels</font></i> <br><br>  The interpreter quickly generates bytecode, but such code runs relatively slowly.  The base compiler takes more time to generate code, but this code is already running faster.  Finally, the IonMonkey optimizing compiler takes the most time to create machine code, but this code can be executed very efficiently. <br><br>  Let's take a look at a specific example and look at how the conveyors of various engines handle the code.  In the example presented here, there is a ‚Äúhot‚Äù loop containing code that repeats so many times. <br><br><pre><code class="hljs matlab">let result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">4242424242</span></span>; ++<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) {    result += <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; } console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(result);</code> </pre> <br>  V8 starts bytecode execution in the Ignition interpreter.  At some point in time, the engine finds out that the code is ‚Äúhot‚Äù and starts the TurboFan frontend, which is part of TurboFan, which works with profiling data and creates a basic machine code representation.  The data is then passed to the TurboFan optimizer, which runs in a separate thread, for further improvements. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db3/20b/52a/db320b52a7d116d205dc13004852418c.png"></div>  <i><font color="#999999">Hot code optimization in V8</font></i> <br><br>  During optimization, V8 continues to execute bytecode in Ignition.  When the optimizer finishes, we have executable machine code that can be used later. <br><br>  The SpiderMonkey engine also starts to execute bytecode in the interpreter.  But it has an extra level, represented by the base compiler, which leads to the fact that the ‚Äúhot‚Äù code first gets to this compiler.  It generates the base code in the main thread, the transition to the execution of this code is made when it is ready. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef4/782/299/ef4782299d5b523414d85adc16f79d07.png"></div>  <i><font color="#999999">Optimization of "hot" code in SpiderMonkey</font></i> <br><br>  If the base code runs long enough, SpiderMonkey eventually launches the IonMonkey frontend and optimizer, which is very similar to what happens in V8.  The base code continues to run as part of the code optimization process performed by IonMonkey.  As a result, when the optimization is complete, the optimized code is executed instead of the base code. <br><br>  The architecture of the Chakra engine is very similar to the SpiderMonkey architecture, but Chakra tends to a higher level of parallelism in order to avoid blocking the main thread.  Instead of solving any compilation problems in the main stream, Chakra copies and sends the bytecode and profiling data that the compiler most likely needs in a separate compilation process. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f44/6f7/5e8/f446f75e844d7be0086fde0237f63b9d.png"></div>  <i><font color="#999999">Optimization of the "hot" code in Chakra</font></i> <br><br>  When the generated code prepared by SimpleJIT means is ready, the engine will execute it instead of bytecode.  This process is repeated to proceed to the execution of the code prepared by means of FullJIT.  The advantage of this approach is that the pauses associated with copying data are usually much shorter than those caused by the work of a full-fledged compiler (frontend).  However, the disadvantage of this approach is the fact that heuristic copying algorithms may skip some information that may be useful for performing some optimization.  Here we see an example of a compromise between the quality of the received code and the delays. <br><br>  In JavaScriptCore, all tasks of optimizing compilation are performed in parallel with the main thread responsible for executing JavaScript code.  At the same time there is no copying stage.  Instead, the main thread simply invokes compilation tasks on another thread.  The compiler then uses a complex locking scheme to access profiling data from the main thread. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f7/0ab/101/2f70ab101c3ea308d1275a44bde4eecd.png"></div>  <i><font color="#999999">Optimize Hot Code in JavaScriptCore</font></i> <br><br>  The advantage of this approach is that it reduces the forced blocking of the main thread, due to the fact that it performs code optimization tasks.  The disadvantages of such an architecture are that its implementation requires the solution of complex tasks of multi-threaded data processing, and that during the work, to perform various operations, it is necessary to resort to locks. <br><br>  We have just discussed the trade-offs that engines have to go to, choosing between fast code generation using interpreters and creating fast code using optimizing compilers.  However, this is not all the problems that confront engines.  Memory is another system resource, which, when used, has to resort to compromise solutions.  In order to demonstrate this, consider a simple JS program that adds numbers. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(x, y) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; } <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Here is the byte-code of the <code>add</code> function generated by the Ignition interpreter in V8: <br><br><pre> <code class="hljs pgsql">StackCheck Ldar a1 <span class="hljs-keyword"><span class="hljs-keyword">Add</span></span> a0, [<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">Return</span></span></code> </pre> <br>  The meaning of this bytecode can not go into, in fact, we are not particularly interested in its contents.  The main thing here is that there are only four instructions in it. <br><br>  When this code snippet turns out to be ‚Äúhot,‚Äù TurboFan is taken into account, which generates the following highly optimized machine code: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">leaq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rcx</span></span>,<span class="hljs-selector-attr"><span class="hljs-selector-attr">[rip+0x0]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">movq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rcx</span></span>,<span class="hljs-selector-attr"><span class="hljs-selector-attr">[rcx-0x37]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">testb</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[rcx+0xf]</span></span>,0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jnz</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">CompileLazyDeoptimizedCode</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">push</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rbp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">movq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rbp</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">rsp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">push</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rsi</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">push</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rdi</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">cmpq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rsp</span></span>,<span class="hljs-selector-attr"><span class="hljs-selector-attr">[r13+0xe88]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jna</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">StackOverflow</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">movq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rax</span></span>,<span class="hljs-selector-attr"><span class="hljs-selector-attr">[rbp+0x18]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">test</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">al</span></span>,0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jnz</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Deoptimize</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">movq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rbx</span></span>,<span class="hljs-selector-attr"><span class="hljs-selector-attr">[rbp+0x10]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">testb</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rbx</span></span>,0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jnz</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Deoptimize</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">movq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rdx</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">rbx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">shrq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rdx</span></span>, 32 <span class="hljs-selector-tag"><span class="hljs-selector-tag">movq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rcx</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">rax</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">shrq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rcx</span></span>, 32 <span class="hljs-selector-tag"><span class="hljs-selector-tag">addl</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rdx</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">rcx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jo</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Deoptimize</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">shlq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rdx</span></span>, 32 <span class="hljs-selector-tag"><span class="hljs-selector-tag">movq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rax</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">rdx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">movq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rsp</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">rbp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">pop</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rbp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ret</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x18</span></span></code> </pre> <br>  As you can see, the amount of code, in comparison with the above example of the four instructions, is very large.  As a rule, the byte code is much more compact than the machine code, and in particular - the optimized machine code.  On the other hand, an interpreter is needed to execute the bytecode, and the optimized code can be executed directly on the processor. <br>  This is one of the main reasons why JavaScript engines do not optimize absolutely all code.  As we saw earlier, creating optimized machine code takes a lot of time, and, moreover, as we just found out, it takes more memory to store optimized machine code. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0b/c84/e9a/f0bc84e9ac477b1e85eb19f306c99597.png"></div>  <i><font color="#999999">Memory usage and optimization level</font></i> <br><br>  As a result, it can be said that the reason why JS engines have different levels of optimization is the fundamental problem of choosing between fast code generation, for example, using an interpreter, and fast code generation performed by the optimizing compiler.  If we talk about the levels of code optimization used in engines, the larger they are, the more subtle optimizations the code can be subjected to, but this is achieved due to the complexity of the engines and due to the additional load on the system.  In addition, here we must not forget that the level of code optimization affects the amount of memory that this code occupies.  That is why JS-engines are trying to optimize only the "hot" features. <br><br><h2>  <font color="#3AC1EF">Optimize access to object prototype properties</font> </h2><br>  JavaScript engines optimize access to object properties through the use of so-called object shapes (Shape) and inline caches (Inline Cache, IC).  Details about this can be read in <a href="https://mathiasbynens.be/notes/shapes-ics">this</a> material, if we express it in a nutshell, then we can say that the engine keeps the shape of the object separately from the values ‚Äã‚Äãof the object. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c63/861/ba8/c63861ba87ef40cdeea866edefe8b000.png"></div>  <i><font color="#999999">Objects of the same shape</font></i> <br><br>  The use of object forms makes it possible to perform optimization, called inline caching.  Sharing of forms of objects and inline-caches allows you to speed up repeated operations of accessing the properties of objects performed from the same place in the code. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mr/5n/cn/mr5ncnmioer4qo4o-aiwlqslo_q.png"></div>  <i><font color="#999999">Acceleration of access to the property of the object</font></i> <br><br><h2>  <font color="#3AC1EF">Classes and prototypes</font> </h2><br>  Now that we know how to speed up access to the properties of objects in JavaScript, take a look at one of the recent JavaScript innovations ‚Äî classes.  Here is the class declaration: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x;   }   getX() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x;   } }</code> </pre> <br>  Although it may look like the appearance of a completely new concept in JS, classes, in fact, are only syntactic sugar for the prototype object design system that has always been present in JavaScript: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } Bar.prototype.getX = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; };</code> </pre> <br>  Here we write the function in the <code>getX</code> property of the <code>getX</code> object.  Such an operation works in the same way as when creating a property of any other object, since the prototypes in JavaScript are objects.  In languages ‚Äã‚Äãbased on the use of prototypes, such as JavaScript, methods that all objects of a certain type can share are stored in prototypes, and the fields of individual objects are stored in their instances. <br><br>  Look at what is happening, so to speak, behind the scenes, when we create a new instance of the <code>Bar</code> object, assigning it to the constant <code>foo</code> . <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  After executing such code, the instance of the object created here will have a form containing the only property <code>x</code> .  The prototype of the <code>foo</code> object is <code>Bar.prototype</code> , which belongs to the class <code>Bar</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26b/52a/630/26b52a63051f760544368abc000ff13d.png"></div>  <i><font color="#999999">Object and its prototype</font></i> <br><br>  <code>Bar.prototype</code> has its own form containing a single property <code>getX</code> , the value of which is a function that, when called, returns the value of <code>this.x</code>  The prototype of the <code>Bar.prototype</code> prototype is the <code>Object.prototype</code> , which is part of the language.  <code>Object.prototype</code> is the root element of the prototype tree, so its prototype is <code>null</code> . <br><br>  Now let's see what happens if we create another <code>Bar</code> object. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a0/972/b2f/7a0972b2f7e264f2e58e399d7f29f5c6.png"></div>  <i><font color="#999999">Several objects of the same type</font></i> <br><br>  As you can see, both the <code>foo</code> object and the <code>qux</code> object, which are instances of <code>Bar</code> , as we have said, use the same object form.  Both of them use the same prototype - the <code>Bar.prototype</code> object. <br><br><h2>  <font color="#3AC1EF">Access to prototype properties</font> </h2><br>  So now we know what happens when we declare a new class and create instances of it.  And what about the method call object?  Consider the following code snippet: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">//        ^^^^^^^^^^</span></span></code> </pre> <br>  The method call can be perceived as an operation consisting of two steps: <br><br><pre> <code class="hljs ruby">const x = foo.getX(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         : const $getX = foo.getX; const x = $getX.call(foo);</code> </pre> <br>  The first step is loading the method, which is just a property of the prototype (the value of which is a function).  In the second step, the function is called with the setting <code>this</code> .  Consider the first step in which you load the <code>getX</code> method from the <code>foo</code> object: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b94/46f/291/b9446f291449153c1de7b7f6fafcbb5b.png"></div>  <i><font color="#999999">Loading the getX method from the foo object</font></i> <br><br>  The engine analyzes the <code>foo</code> object and finds out that there is no <code>getX</code> property in the form of the <code>foo</code> object.  This means that the engine needs to view a chain of object prototypes in order to find this method.  The engine refers to the prototype <code>Bar.prototype</code> and looks at the shape of the object of this prototype.  There, he finds the desired property at offset 0. Next, it accesses the value stored by this offset in <code>Bar.prototype</code> , there <code>JSFunction</code> <code>getX</code> is <code>getX</code> - and this is exactly what we are looking for.  This completes the search method. <br><br>  The flexibility of javascript makes it possible to change prototype chains.  For example: <br><br><pre> <code class="hljs pgsql">const foo = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Bar(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); foo.getX(); // <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.setPrototypeOf(foo, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); foo.getX(); // Uncaught TypeError: foo.getX <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">function</span></span></code> </pre> <br>  In this example, we call the <code>foo.getX()</code> method twice, but each of these calls has a completely different meaning and result.  That is why, although prototypes in JavaScript are just objects, accelerating access to the properties of prototypes is even more difficult for JS engines than accelerating access to the proper properties of ordinary objects. <br><br>  If we consider the real-life programs, it turns out that the loading of the properties of the prototypes is an operation that occurs very often.  It is executed every time the method is called. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">//        ^^^^^^^^^^</span></span></code> </pre> <br>  Earlier we talked about how the engines optimize the loading of ordinary, own properties of objects through the use of object shapes and inline caches.  How to optimize repeated loadings of properties of a prototype for objects with the same form?  Above, we have seen how properties are loaded. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/020/076/65c/02007665c3b9d613e5ccb1daa53a55cd.png"></div>  <i><font color="#999999">Loading the getX method from the foo object</font></i> <br><br>  In order to speed up access to the method with repeated calls to it, in our case, you need to know the following: <br><br><ol><li>  The form of the <code>foo</code> object does not contain the <code>getX</code> method and does not change.  This means that the <code>foo</code> object is not modified by adding properties to it or deleting them, or changing the attributes of properties. </li><li>  The <code>foo</code> prototype is still the original <code>Bar.prototype</code> .  This means that the prototype <code>foo</code> does not change using the <code>Object.setPrototypeOf()</code> method or by assigning a new prototype to the special property <code>_proto_</code> . </li><li>  The form <code>Bar.prototype</code> contains <code>getX</code> and does not change.  That is, <code>Bar.prototype</code> not changed by deleting properties, adding them, or changing their attributes. </li></ol><br>  In general, this means that we need to make 1 check of the object itself, and 2 checks for each prototype, up to the prototype that stores the property we are looking for.  That is, you need to carry out 1 + 2N checks (where N is the number of prototypes to be checked), which in this case does not look so bad, since the chain of prototypes is rather short.  However, engines often have to work with much longer chains of prototypes.  This, for example, is typical of ordinary DOM elements.  Here is an example: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anchor = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// HTMLAnchorElement const title = anchor.getAttribute('title');</span></span></code> </pre> <br>  Here we have <code>HTMLAnchorElement</code> and we call its <code>getAttribute()</code> method.  The prototype chain of this simple element representing an HTML link includes 6 prototypes!  Most of the interesting DOM methods are not in their own prototype of <code>HTMLAnchorElement</code> .  They are in prototypes, located further in the chain. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/753/e76/10d/753e7610da32acbfd576fd0c61226bc7.png"></div>  <i><font color="#999999">Prototype chain</font></i> <br><br>  The <code>getAttribute()</code> method is found in the <code>Element.prototype</code> .  This means that each time the <code>anchor.getAttribute()</code> method is <code>anchor.getAttribute()</code> , the engine must perform the following actions: <br><br><ol><li>  Checking the <code>anchor</code> object itself for the presence of <code>getAttribute</code> . </li><li>  Verifying that the direct prototype of the object is <code>HTMLAnchorElement.prototype</code> . </li><li>  Finding out that in <code>HTMLAnchorElement.prototype</code> there is no <code>getAttribute</code> method. </li><li>  Verifying that the next prototype is the <code>HTMLElement.prototype</code> . </li><li>  Figuring out that here there is no necessary method. </li><li>  Finally, figuring out that the next prototype is <code>Element.prototype</code> . </li><li>  <code>getAttribute</code> out that there is a <code>getAttribute</code> method. </li></ol><br>  As you can see, 7 checks are performed here.  Since such code is very common in web programming, the engines use optimizations to reduce the number of checks needed to load prototype properties. <br><br>  If you go back to one of the previous examples, you can remember that when accessing the <code>getX</code> method of the <code>getX</code> object, we perform 3 checks: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> $getX = foo.getX;</code> </pre> <br>  For each object that exists in the chain of prototypes, down to the one that contains the desired property, we need to check the shape of the object only to find out the absence of what we are looking for.  It would be nice if we could reduce the number of checks by reducing the prototype check to checking the presence or absence of what we are looking for.  This is exactly what the engine does with a simple move: instead of storing the reference to the prototype in the instance itself, the engine stores it in the form of an object. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/643/1d0/c33/6431d0c33d2d03bea86e6adfffed4569.png"></div>  <i><font color="#999999">Storing references to prototypes</font></i> <br><br>  Each form has a link to the prototype.  This also means that whenever the prototype of <code>foo</code> changes, the engine moves to a new form of the object.  Now we just need to check the shape of the object for the presence of properties in it and take care of protecting the reference to the prototype. <br><br>  Thanks to this approach, we can reduce the number of checks from 1 + 2N to 1 + N, which will speed up access to the properties of prototypes.  However, such operations are still quite resource-intensive, since there is a linear relationship between their number and the length of the prototype chain.  In the engines, various mechanisms are implemented to ensure that the number of checks does not depend on the length of the prototype chain, to be expressed as a constant.  This is especially true in situations where the same property is loaded several times. <br><br><h2>  <font color="#3AC1EF">ValidityCell property</font> </h2><br>  V8 refers to prototype forms specifically for the above purpose.  Each prototype has a unique form, which is not used in conjunction with other objects (in particular, with other prototypes), and each of the forms of prototype objects has a <code>ValidityCell</code> property associated with them. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fb/f9c/3f9/7fbf9c3f987b8def69855e849c71c01a.png"></div>  <i><font color="#999999">ValidityCell property</font></i> <br><br>  This property is declared invalid if the prototype associated with the form or any overlying prototype changes.  Consider this mechanism in more detail. <br><br>  In order to speed up sequential operations for loading properties from prototypes, V8 uses an inline cache that contains four fields: <code>ValidityCell</code> , <code>Prototype</code> , <code>Shape</code> , <code>Offset</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ba/a3b/04f/0baa3b04faebad191e769279c6eb1cd8.png"></div>  <i><font color="#999999">Inline cache fields</font></i> <br><br>  During the ‚Äúwarming up‚Äù of the inline cache when the code is first run, V8 remembers the offset by which the property was found in the prototype, the prototype in which the property was found (in this example, <code>Bar.prototype</code> ), the shape of the object ( <code>foo</code> in this case) , and, in addition, a reference to the current parameter <code>ValidityCell</code> immediate prototype, which is referenced in the form of an object (in this case, it is also <code>Bar.prototype</code> ). <br><br>  The next time the inline cache is accessed, the engine will need to check the shape of the object and <code>ValidityCell</code> .  If the <code>ValidityCell</code> indicator is still valid, the engine can directly use the previously saved offset in the prototype, without performing additional search operations. <br><br>  When the prototype changes, a new form is created, and the previous property <code>ValidityCell</code> declared invalid.  As a result, the next attempt to access the inline cache does not bring any benefit, which results in poor performance. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c95/c30/c97/c95c30c97ee0429bf1400163309c6354.png"></div>  <i><font color="#999999">Implications of a prototype change</font></i> <br><br>  If you go back to the example with the DOM element, this means that any change, for example, in the prototype <code>Object.prototype</code> , will lead not only to the inline cache invalidation for the <code>Object.prototype</code> itself, but also for any prototypes located below it in the prototype chain , including <code>EventTarget.prototype</code> , <code>Node.prototype</code> , <code>Element.prototype</code> , and so on, up to <code>HTMLAnchorElement.prototype</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/444/5f7/ff7/4445f7ff7b11c00e40aeac4fd1945ae1.png"></div>  <i><font color="#999999">Implications of changing Object.prototype</font></i> <br><br>  In fact, modifying the <code>Object.prototype</code> in the process of executing code means causing serious harm to performance.  Do not do this. <br><br>  We investigate the above with an example.  Suppose we have a class <code>Bar</code> , and a function <code>loadX</code> , which calls the method of objects created on the basis of the class <code>Bar</code> .  We call the <code>loadX</code> function several times, passing it instances of the same class. <br><br><pre> <code class="hljs ruby">function loadX(bar) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar.getX(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> IC  <span class="hljs-string"><span class="hljs-string">'getX'</span></span>   <span class="hljs-string"><span class="hljs-string">`Bar`</span></span>. } loadX(new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)); loadX(new Bar(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> IC  <span class="hljs-string"><span class="hljs-string">`loadX`</span></span>    <span class="hljs-string"><span class="hljs-string">`ValidityCell`</span></span>  /<span class="hljs-regexp"><span class="hljs-regexp">/ `Bar.prototype`. Object.prototype.newMethod = y =&gt; y; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ `ValidityCell`  IC `loadX`   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    `Object.prototype`  .</span></span></code> </pre> <br>  Inline cache in <code>loadX</code> now points to <code>ValidityCell</code> for <code>Bar.prototype</code> .  , ,  <code>Object.prototype</code> ‚Äî    JavaScript,   <code>ValidityCell</code>  ,   -          ,     . <br><br>  <code>Object.prototype</code> ‚Äî   ,        -      ,       .     ,    : <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ‚Ä¶ */</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//    : someObject.foo(); //     . delete Object.prototype.foo;</span></span></code> </pre> <br>   <code>Object.prototype</code> ,     - ,   .     ,    .      -   ,          .       , ¬´  ¬ª,   ,  . <br><br> ,  ,  .             .    <code>Object.prototype</code> ,   ,   -            . <br><br>       ,    ‚Äî   , JS-    -  ,       .        .       ,     ,      .  ,   ,       ,      . <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>       ,  JS-    ,  ,   , -,  <code>ValidityCell</code>   ,     .            JavaScript,    ,       (       , ,  ,        ). <br><br>  <b>Dear readers!</b>       ,    - ,   JS,          ? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/422321/">https://habr.com/ru/post/422321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../422309/index.html">How to protect data in cloud neural networks - a new encryption method is proposed</a></li>
<li><a href="../422311/index.html">Python interesting and useful. Part 2</a></li>
<li><a href="../422315/index.html">How to survive the hunter bugs: the daily struggle for income</a></li>
<li><a href="../422317/index.html">Why are TPUs so well suited for depth learning?</a></li>
<li><a href="../422319/index.html">For the first time the Russian team got into the largest scientific accelerator IndieBio</a></li>
<li><a href="../422323/index.html">Hackers: Russia and China</a></li>
<li><a href="../422325/index.html">DevDay about testing: Relax. Test it easy</a></li>
<li><a href="../422327/index.html">Project schedule vs Backlog: a battle without chances</a></li>
<li><a href="../422329/index.html">Information security of bank non-cash payments. Part 8 - Typical Threat Models</a></li>
<li><a href="../422331/index.html">How hybrid self-checkout boosts store efficiency</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>