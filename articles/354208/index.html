<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Learn OpenGL. Lesson 5.4 - Omnidirectional Shadow Maps</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Omnidirectional shadow maps 
 In the previous lesson we dealt with the creation of dynamic projection shadows. This technique works fine, but, alas, i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Learn OpenGL. Lesson 5.4 - Omnidirectional Shadow Maps</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="Ogl3" align="left" width="300"><br><h1>  Omnidirectional shadow maps </h1><br>  In the previous lesson we dealt with the creation of dynamic projection shadows.  This technique works fine, but, alas, it is only suitable for directional light sources, since the shadow map is created in one direction, which coincides with the direction of the source.  That is why this technique is also called a directional shadow map, since the depth map (shadow map) is created along the direction of the light source. <br><br>  This lesson will be devoted to the creation of dynamic shadows, projected in all directions.  This approach is great for working with point sources of lighting, because they must cast shadows in all directions at once.  Accordingly, this technique is called an <b>omnidirectional shadow map</b> . <br><blockquote>  The lesson relies heavily on materials from the <a href="https://habrahabr.ru/post/353956/">previous lesson</a> , so if you have not practiced with ordinary shadow maps, you should do this before continuing to study this article. </blockquote><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text">  Part 1. Start <br><br><ol><li>  <a href="https://habrahabr.ru/post/310790/">Opengl</a> </li><li>  <a href="https://habrahabr.ru/post/311198/">Creating a window</a> </li><li>  <a href="https://habrahabr.ru/post/311234/">Hello window</a> </li><li>  <a href="https://habrahabr.ru/post/311808/">Hello triangle</a> </li><li>  <a href="https://habrahabr.ru/post/313380/">Shaders</a> </li><li>  <a href="https://habrahabr.ru/post/315294/">Textures</a> </li><li>  <a href="https://habrahabr.ru/post/319144/">Transformations</a> </li><li>  <a href="https://habrahabr.ru/post/324968/">Coordinate systems</a> </li><li>  <a href="https://habrahabr.ru/post/327604/">Camera</a> </li></ol><br>  Part 2. Basic lighting 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  <a href="https://habrahabr.ru/post/329592/">Colors</a> </li><li>  <a href="https://habrahabr.ru/post/333932/">Lighting Basics</a> </li><li>  <a href="https://habrahabr.ru/post/336166/">Materials</a> </li><li>  <a href="https://habrahabr.ru/post/337550/">Texture Cards</a> </li><li>  <a href="https://habrahabr.ru/post/337642/">Sources of light</a> </li><li>  <a href="https://habrahabr.ru/post/338254/">Multiple light sources</a> </li></ol><br>  Part 3. Loading 3D Models <br><br><ol><li>  <a href="https://habrahabr.ru/post/338436/">Assimp library</a> </li><li>  <a href="https://habrahabr.ru/post/338436/">Mesh mesh class</a> </li><li>  <a href="https://habrahabr.ru/post/338998/">Model class</a> </li></ol><br>  Part 4. OpenGL advanced features <br><br><ol><li>  <a href="https://habrahabr.ru/post/342610/">Depth test</a> </li><li>  <a href="https://habrahabr.ru/post/344238/">Stencil test</a> </li><li>  <a href="https://habrahabr.ru/post/343096/">Mixing colors</a> </li><li>  <a href="https://habrahabr.ru/post/346964/">Face clipping</a> </li><li>  <a href="https://habrahabr.ru/post/347354/">Frame buffer</a> </li><li>  <a href="https://habrahabr.ru/post/347750/">Cubic cards</a> </li><li>  <a href="https://habrahabr.ru/post/350008/">Advanced data handling</a> </li><li>  <a href="https://habrahabr.ru/post/350156/">Advanced GLSL</a> </li><li>  <a href="https://habrahabr.ru/post/350782/">Geometric shader</a> </li><li>  <a href="https://habrahabr.ru/post/352962/">Instancing</a> </li><li>  <a href="https://habrahabr.ru/post/351706/">Smoothing</a> </li></ol><br>  Part 5. Advanced Lighting <br><br><ol><li>  <a href="https://habrahabr.ru/post/353054/">Advanced lighting.</a>  <a href="https://habrahabr.ru/post/353054/">Model Blinna-Phong.</a> </li><li>  <a href="https://habrahabr.ru/post/353632/">Gamma Correction</a> </li><li>  <a href="https://habrahabr.ru/post/353956/">Shadow maps</a> </li><li>  Omnidirectional shadows </li></ol><br></div></div><br>  In general, the algorithm of work remains almost identical to that for directional shadows: we create a depth map from the point of view of the light source and for each fragment we compare the values ‚Äã‚Äãof its depth and those read from the depth map.  The main difference between the directional and omnidirectional approach in the type of depth map used. <br><br>  The shadow map we need implies rendering the scene in all directions around the light source and the usual 2D texture is not suitable here.  So maybe use a <a href="https://habrahabr.ru/post/347750">cubic card</a> ?  Since a cubic map can store environmental data with just six faces, you can draw the entire scene onto each of these faces and then select a depth from the cube map. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8v/oo/qq/8vooqqs7lhow7siw-3dskx8ufeq.png"></div><br>  The created cubic shadow map eventually ends up in a fragmentary shader, where it is sampled from it using the direction vector to obtain the fragment depth value (from the point of view of the source).  Most of the technically complex parts we have already discussed in the previous lesson, so there remains one subtlety - the use of a cube map. <br><br><h3>  Create a cubic map </h3><br>  To create a cube map that stores the depth values ‚Äã‚Äãof the light source, we need to render the scene six times: once for each edge of the map.  One of the (obvious) ways to accomplish this is to simply draw the scene six times, using six different viewports, and connecting a separate face of the cube map to each color attachment of the frame buffer object: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>; i++) { GLenum face = GL_TEXTURE_CUBE_MAP_POSITIVE_X + i; glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, face, depthCubemap, <span class="hljs-number"><span class="hljs-number">0</span></span>); BindViewMatrix(lightViewMatrices[i]); RenderScene(); }</code> </pre> <br>  This approach can be very costly in performance, since many draw calls are made to create a single shadow map.  In the lesson, we will try to implement a more optimal approach, using a small trick associated with using a geometric shader.  This will create a cubic depth map in just one pass. <br><br>  First create a cubic map: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> depthCubemap; glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthCubemap);</code> </pre> <br>  And we define each face as a 2D texture that stores the depth values: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SHADOW_WIDTH = <span class="hljs-number"><span class="hljs-number">1024</span></span>, SHADOW_HEIGHT = <span class="hljs-number"><span class="hljs-number">1024</span></span>; glBindTexture(GL_TEXTURE_CUBE_MAP, depthCubemap); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>; ++i) glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_DEPTH_COMPONENT, SHADOW_WIDTH, SHADOW_HEIGHT, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre> <br>  Also, do not forget to set the appropriate texture parameters: <br><br><pre> <code class="cpp hljs">glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);</code> </pre> <br>  In the usual approach, we would connect each face of the cube map to the frame buffer and render the scene six times, replacing the face of the cube map connected to attaching the frame buffer depth in each pass.  But using the geometric shader, we can bring the scene to all faces at once in one pass, and therefore connect the cubic map directly to the depth attachment: <br><br><pre> <code class="cpp hljs">glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO); glFramebufferTexture(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, depthCubemap, <span class="hljs-number"><span class="hljs-number">0</span></span>); glDrawBuffer(GL_NONE); glReadBuffer(GL_NONE); glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Again, I‚Äôll note the calls to <i>glDrawBuffer</i> and <i>glReadBuffer</i> : since only the depth values ‚Äã‚Äãare important to us, we explicitly tell OpenGL not to write to the color buffer. <br>  In the end, two passes will be applied here: the shadow map is prepared first, the scene is drawn second, and the map is used to create shading.  Using the framebuffer and the cube map, the code looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 1.      glViewport(0, 0, SHADOW_WIDTH, SHADOW_HEIGHT); glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO); glClear(GL_DEPTH_BUFFER_BIT); ConfigureShaderAndMatrices(); RenderScene(); glBindFramebuffer(GL_FRAMEBUFFER, 0); // 2.           glViewport(0, 0, SCR_WIDTH, SCR_HEIGHT); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); ConfigureShaderAndMatrices(); glBindTexture(GL_TEXTURE_CUBE_MAP, depthCubemap); RenderScene();</span></span></code> </pre> <br>  In the first approximation, the process is the same as when using directional shadow maps.  The only difference is that we render to a cubic depth map, and not to the usual 2D texture. <br><br>  Before we proceed to direct rendering of the scene from the directions, relative to the source, we need to prepare suitable transformation matrices. <br><br><h3>  Conversion to a light source coordinate system </h3><br>  Having a prepared frame buffer object and a cubic map, we turn to the question of transforming all the objects of the scene into coordinate spaces corresponding to all six directions from the light source.  We will create transformation matrices in the same way as in the <a href="https://habrahabr.ru/post/353956/">previous lesson</a> , but this time we will need a separate matrix for each face. <br><br>  Each final transformation to the source space contains both a projection matrix and a view matrix.  For the projection matrix, we use the perspective projection matrix: the source is a point in space, so the perspective projection here is most suitable.  This matrix will be the same for all final conversions: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> aspect = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)SHADOW_WIDTH/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)SHADOW_HEIGHT; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> near = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> far = <span class="hljs-number"><span class="hljs-number">25.0f</span></span>; glm::mat4 shadowProj = glm::perspective(glm::radians(<span class="hljs-number"><span class="hljs-number">90.0f</span></span>), aspect, near, far);</code> </pre> <br>  I note an important point: the parameter of the viewing angle when forming the matrix is ‚Äã‚Äãset to 90 ¬∞.  It is this value of the viewing angle that provides us with a projection that allows us to correctly fill the faces of the cube map so that they converge without gaps. <br><br>  Since the projection matrix remains constant, the same matrix can be reused to create all six final transformation matrices.  But species matrices are needed unique for each face.  Using <i>glm :: lookAt</i> we will create six matrices representing six directions in the following order: right, left, up, down, near edge, far edge: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;glm::mat4&gt; shadowTransforms; shadowTransforms.push_back(shadowProj * glm::lookAt(lightPos, lightPos + glm::vec3( <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>), glm::vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">-1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>)); shadowTransforms.push_back(shadowProj * glm::lookAt(lightPos, lightPos + glm::vec3(<span class="hljs-number"><span class="hljs-number">-1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>), glm::vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">-1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>)); shadowTransforms.push_back(shadowProj * glm::lookAt(lightPos, lightPos + glm::vec3( <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>), glm::vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); shadowTransforms.push_back(shadowProj * glm::lookAt(lightPos, lightPos + glm::vec3( <span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">-1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>), glm::vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">-1.0</span></span>)); shadowTransforms.push_back(shadowProj * glm::lookAt(lightPos, lightPos + glm::vec3( <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>), glm::vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">-1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>)); shadowTransforms.push_back(shadowProj * glm::lookAt(lightPos, lightPos + glm::vec3( <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">-1.0</span></span>), glm::vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">-1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>));</code> </pre> <br>  In the above code, the six created species matrices are multiplied by the projection matrix to specify the six unique matrices that transform into the light source space.  The <i>target</i> parameter in the call to <i>glm :: lookAt</i> is the direction of looking at each of the faces of the cube map. <br><br>  Further, this list of matrices is transmitted to the shaders when rendering a cubic depth map. <br><br><h3>  Depth recording shaders </h3><br>  To record the depth in a cubic map, we use three shaders: a vertex, a fragment, and an additional geometric one, which is executed between these stages. <br><br>  It is the geometric shader that will be responsible for transforming all the vertices in world space into six separate spaces of the light source.  Thus, the vertex shader is trivial and simply gives the coordinates of the vertex in world space, which will go to the geometric shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) in vec3 aPos; uniform mat4 model; void main() { gl_Position = model * vec4(aPos, 1.0); }</span></span></code> </pre> <br>  The geometric shader accepts three vertices of the triangle as well as uniforms with an array of matrixes of transformation into the light source space.  Here lies an interesting point: it is the geometric shader that will deal with converting vertices from world coordinates into source spaces. <br><br>  For the geometry shader, the built-in variable <i>gl_Layer is available</i> , which specifies the face number of the cube map for which the shader will form the primitive.  Normally, the shader simply sends all primitives further to the pipeline without additional actions.  But by changing the value of this variable, we can control which side of the cube map we are going to render each of the primitives being processed.  Of course, this only works if a cubic map is connected to the frame buffer. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (triangles) in; layout (triangle_strip, max_vertices=18) out; uniform mat4 shadowMatrices[6]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  FragPos     //      EmitVertex() out vec4 FragPos; void main() { for(int face = 0; face &lt; 6; ++face) { //  ,    //      gl_Layer = face; for(int i = 0; i &lt; 3; ++i) //      { FragPos = gl_in[i].gl_Position; gl_Position = shadowMatrices[face] * FragPos; EmitVertex(); } EndPrimitive(); } }</span></span></span></span></code> </pre> <br>  The code presented should be pretty straightforward.  The shader receives a primitive type triangle at the input, and as a result produces six triangles (6 * 3 = 18 vertices).  In the main function, we loop through all six faces of the cube map, setting the current index as the number of the active face of the cube map with the corresponding entry in the <i>gl_Layer</i> variable.  We also transform each input vertex from the world coordinate system into the space of the light source corresponding to the current face of the cubic art.  To do this, <i>FragPos</i> is multiplied by a suitable transformation matrix from the uniformal <i>shadowMatrices</i> .  Note that the <i>FragPos</i> value <i>is</i> also passed to the fragment shader to calculate the fragment depth. <br><br>  In the last lesson, we used an empty fragmentary shader, and OpenGL itself was busy calculating the depth for the shadow map.  This time we will manually form a linear depth value, taking as a basis the distance between the position of the fragment and the light source.  This calculation of the depth value makes subsequent shading calculations a little more intuitive. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core in vec4 FragPos; uniform vec3 lightPos; uniform float far_plane; void main() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//       float lightDistance = length(FragPos.xyz - lightPos); //    [0, 1]    far_plane lightDistance = lightDistance / far_plane; //       gl_FragDepth = lightDistance; }</span></span></span></span></code> </pre> <br>  The fragment <i>FragPos</i> from the geometric shader, the source position vector, and the distance to the far clipping plane of the pyramid of the light source projection are placed at the input of the fragment shader.  In this code, we simply calculate the distance between the fragment and the source, we reduce it to the range of values ‚Äã‚Äã[0., 1.] and write it as the result of the shader. <br><br>  A render of a scene with these shaders and a cubic card connected to the frame buffer object should generate a fully prepared shadow map for use in the next render pass. <br><br><h2>  Omnidirectional shadow maps </h2><br>  Once we have everything prepared, we can proceed to the immediate rendering of the omnidirectional shadows.  The procedure is similar to that presented in the previous lesson for directional shadows, but this time we use a cubic texture instead of a two-dimensional one as a depth map, and also transfer uniforms with the far plane value of the projection pyramid for the light source to shaders. <br><br><pre> <code class="cpp hljs">glViewport(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, SCR_WIDTH, SCR_HEIGHT); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); shader.use(); <span class="hljs-comment"><span class="hljs-comment">// ...      (      far_plane) glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_CUBE_MAP, depthCubemap); // ...   RenderScene();</span></span></code> </pre> <br>  In the example, the renderScene function displays several cubes located in a large cubic room that will cast shadows from a light source located in the center of the scene. <br><br>  The summit and fragment shaders are almost identical to those considered in the lesson in directional shadows.  So, in the fragment shader, the input parameter of the fragment position in the light source space is no longer required, since the selection from the shadow map is now done using the direction vector. <br><br>  The vertex shader, accordingly, now does not have to convert the position vector to the light source space, so we can throw out the <i>FragPosLightSpace</i> variable: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) in vec3 aPos; layout (location = 1) in vec3 aNormal; layout (location = 2) in vec2 aTexCoords; out vec2 TexCoords; out VS_OUT { vec3 FragPos; vec3 Normal; vec2 TexCoords; } vs_out; uniform mat4 projection; uniform mat4 view; uniform mat4 model; void main() { vs_out.FragPos = vec3(model * vec4(aPos, 1.0)); vs_out.Normal = transpose(inverse(mat3(model))) * aNormal; vs_out.TexCoords = aTexCoords; gl_Position = projection * view * model * vec4(aPos, 1.0); }</span></span></code> </pre> <br>  The code for the Blinna-Phong lighting model in the fragment shader remains intact, and it also leaves the multiplication by the shading factor at the end: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in VS_OUT { vec3 FragPos; vec3 Normal; vec2 TexCoords; } fs_in; uniform sampler2D diffuseTexture; uniform samplerCube depthMap; uniform vec3 lightPos; uniform vec3 viewPos; uniform float far_plane; float ShadowCalculation(vec3 fragPos) { [...] } void main() { vec3 color = texture(diffuseTexture, fs_in.TexCoords).rgb; vec3 normal = normalize(fs_in.Normal); vec3 lightColor = vec3(0.3); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   vec3 ambient = 0.3 * color; //   vec3 lightDir = normalize(lightPos - fs_in.FragPos); float diff = max(dot(lightDir, normal), 0.0); vec3 diffuse = diff * lightColor; //   vec3 viewDir = normalize(viewPos - fs_in.FragPos); vec3 reflectDir = reflect(-lightDir, normal); float spec = 0.0; vec3 halfwayDir = normalize(lightDir + viewDir); spec = pow(max(dot(normal, halfwayDir), 0.0), 64.0); vec3 specular = spec * lightColor; //   float shadow = ShadowCalculation(fs_in.FragPos); vec3 lighting = (ambient + (1.0 - shadow) * (diffuse + specular)) * color; FragColor = vec4(lighting, 1.0); }</span></span></span></span></code> </pre> <br>  I will also note a few subtle differences: the lighting model code is really unchanged, but now a sampler of the <i>samplerCubemap</i> type is <i>used</i> , and the <i>ShadowCalculation</i> function takes the coordinates of the fragment in world coordinates, instead of the light source space.  We also use the pyramid parameter of the <i>far_plane</i> light source projection in further calculations.  At the end of the shader, we calculate the shading factor, which is 1 when the fragment is in the shadow;  or 0 when the fragment is outside the shadow.  This coefficient is used to influence the prepared values ‚Äã‚Äãof the diffuse and specular components of the illumination. <br><br>  The biggest changes relate to the body of the <i>ShadowCalculation</i> function, where the depth value is now sampled from a cube map, rather than a 2D texture.  Let's sort the code of this function in order. <br><br>  The first step is to get the immediate depth value from the cube map.  As you remember, when preparing a cubic map, we wrote down the depth in it, represented as the distance between the fragment and the light source.  The same approach is used here: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShadowCalculation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 fragPos)</span></span></span><span class="hljs-function"> </span></span>{ vec3 fragToLight = fragPos - lightPos; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> closestDepth = texture(depthMap, fragToLight).r; }</code> </pre> <br>  The difference vector between the position of the fragment and the light source is calculated, which is used as the direction vector for the sample from the cube map.  As we remember, the sampling vector from a cubic map does not have to be of unit length, then there is no need to normalize it.  The obtained value of <i>closestDepth</i> is the normalized value of the depth of the nearest visible fragment relative to the light source. <br><br>  Since the value of <i>closestDepth is</i> enclosed in the interval [0., 1.], then you should first perform the inverse transformation in the interval [0., <i>far_plane</i> ]: <br><br><pre> <code class="cpp hljs">closestDepth *= far_plane;</code> </pre> <br>  Next, we get the depth value for the current fragment relative to the light source.  For the chosen approach, this is extremely simple: you only need to calculate the length of the already prepared vector <i>fragToLight</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> currentDepth = length(fragToLight);</code> </pre> <br>  Thus, we obtain the depth value that lies in the same (or, perhaps, in a larger) interval as the <i>closestDepth</i> . <br><br>  Now we can proceed to the comparison of both depth values ‚Äã‚Äãin order to find out if the current fragment is in the shadow or not.  We also immediately include the offset value in the comparison in order not to encounter the problem of ‚Äúshadow ripples‚Äù explained in the <a href="https://habrahabr.ru/post/353956/">previous lesson</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bias = <span class="hljs-number"><span class="hljs-number">0.05</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shadow = currentDepth - bias &gt; closestDepth ? <span class="hljs-number"><span class="hljs-number">1.0</span></span> : <span class="hljs-number"><span class="hljs-number">0.0</span></span>;</code> </pre> <br>  Full <i>ShadowCalculation</i> Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShadowCalculation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 fragPos)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//          vec3 fragToLight = fragPos - lightPos; //        //        float closestDepth = texture(depthMap, fragToLight).r; //       [0,1] //       closestDepth *= far_plane; //        //        float currentDepth = length(fragToLight); //   float bias = 0.05; float shadow = currentDepth - bias &gt; closestDepth ? 1.0 : 0.0; return shadow; }</span></span></code> </pre> <br>  With the given shaders, the application already displays quite tolerable shadows and this time they are dropped to all sides from the source.  For a scene with a source in the center, the picture appears as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/f3/84/j4/f384j4ifw_irmso-v883luer7ja.png"></div><br><br>  The full source code is <a href="https://learnopengl.com/code_viewer_gh.php%3Fcode%3Dsrc/5.advanced_lighting/3.2.1.point_shadows/point_shadows.cpp">here</a> . <br><br><h3>  Visualization of a cubic depth map </h3><br>  If you are somewhat similar to me, then, I think, you will not be able to do everything right the first time, and therefore some means of debugging the application would be quite useful.  As the most obvious option, it would be nice to be able to verify the correctness of the preparation of the depth map.  Since we now use a cubic map, rather than a two-dimensional texture, the question of visualization requires a somewhat more elaborate approach. <br><br>  A simple solution would be to take the normalized value of <i>closestDepth</i> from the body of the <i>ShadowCalculation</i> function and output it as the result of a fragment shader: <br><br><pre> <code class="cpp hljs">FragColor = vec4(vec3(closestDepth / far_plane), <span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre> <br>  The result is a scene in grayscale, where the intensity of the color corresponds to the linear depth value in the scene: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lc/xo/y5/lcxoy5pgkyae0drjkuvafcahwic.png"></div><br>  Also visible areas of shading on the walls of the room.  If the result of visualization is similar to the above, then you can be sure that shadow maps have been prepared correctly.  Otherwise, an error somewhere crept in: for example, the value of <i>closestDepth</i> was taken from the interval [0., <i>far_plane</i> ]. <br><br><h2>  Percentage-closer filtering </h2><br>  Since omnidirectional shadows are built on the same principles as directed shadows, they inherited all the artifacts associated with the accuracy and finiteness of texture resolution.  If you approach the borders of the shaded areas, the jagged edges become visible, i.e.  aliasing artifacts.  <i>Percentage-closer filtering</i> ( <i>PCF</i> ) <i>filtering</i> allows you to smooth out the aliasing traces by filtering multiple depth samples around the current fragment and averaging the result of depth comparison. <br><br>  Take the PCF code from the previous lesson and add the third dimension (sampling from a cube map because it requires a direction vector): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shadow = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bias = <span class="hljs-number"><span class="hljs-number">0.05</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> samples = <span class="hljs-number"><span class="hljs-number">4.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> offset = <span class="hljs-number"><span class="hljs-number">0.1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = -offset; x &lt; offset; x += offset / (samples * <span class="hljs-number"><span class="hljs-number">0.5</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y = -offset; y &lt; offset; y += offset / (samples * <span class="hljs-number"><span class="hljs-number">0.5</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> z = -offset; z &lt; offset; z += offset / (samples * <span class="hljs-number"><span class="hljs-number">0.5</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> closestDepth = texture(depthMap, fragToLight + vec3(x, y, z)).r; closestDepth *= far_plane; <span class="hljs-comment"><span class="hljs-comment">//     [0;1] if(currentDepth - bias &gt; closestDepth) shadow += 1.0; } } } shadow /= (samples * samples * samples);</span></span></code> </pre> <br>  Little difference.  We calculate the displacements for texture coordinates dynamically, based on the number of samples that we want to do along each axis and average the result by dividing by the number of samples raised to a cube. <br><br>  Now the shadows look much more reliable and their edges are quite smooth. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6r/ah/0t/6rah0tgtckfdqcygk_yt4mmj4y4.png"></div><br>  However, by setting the number of <i>samples = 4</i> , we actually spend as many as 64 samples on each fragment, which is a lot. <br><br>  And in most cases, these samples will be redundant, since they will be very close to the original vector of the sample.  It would probably be more useful to do samples in directions perpendicular to the original vector of the sample.  Alas, a simple method for finding out which of the generated additional directions will be redundant does not exist.  You can use one technique and set an array of directions of displacement, all of which are almost completely separable vectors, i.e.  each of them will point in completely different directions.  This will reduce the number of directions of displacement, which will be too close to each other.  Below is just a similar array with twenty specially selected directions of displacement: <br><br><pre> <code class="cpp hljs">vec3 sampleOffsetDirections[<span class="hljs-number"><span class="hljs-number">20</span></span>] = vec3[] ( vec3( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), vec3( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), vec3(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), vec3(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), vec3( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), vec3( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), vec3(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), vec3(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), vec3( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), vec3( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), vec3(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), vec3(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), vec3( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), vec3(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), vec3( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), vec3(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), vec3( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), vec3( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), vec3( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), vec3( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) );</code> </pre> <br> ,     PCF        <i>sampleOffsetDirections</i>      .        ,     ,       . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shadow = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bias = <span class="hljs-number"><span class="hljs-number">0.15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> samples = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> viewDistance = length(viewPos - fragPos); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> diskRadius = <span class="hljs-number"><span class="hljs-number">0.05</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; samples; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> closestDepth = texture(depthMap, fragToLight + sampleOffsetDirections[i] * diskRadius).r; closestDepth *= far_plane; <span class="hljs-comment"><span class="hljs-comment">//     [0;1] if(currentDepth - bias &gt; closestDepth) shadow += 1.0; } shadow /= float(samples);</span></span></code> </pre> <br>         <i>diskRadius</i> ,   ,      <i>fragToLight</i>       . <br><br>        :    <i>diskRadius</i>       .             ,      : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> diskRadius = (<span class="hljs-number"><span class="hljs-number">1.0</span></span> + (viewDistance / far_plane)) / <span class="hljs-number"><span class="hljs-number">25.0</span></span>;</code> </pre> <br>    PCF     ,   ,   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v_/fi/ts/v_fitsr4ivsezlwdiwznxmbogla.png"></div><br> ,  <i>bias</i> ,             ,        .     ,       . <br><br>      <a href="https://learnopengl.com/code_viewer_gh.php%3Fcode%3Dsrc/5.advanced_lighting/3.2.2.point_shadows_soft/point_shadows_soft.cpp"></a> . <br><br>  ,             ,        .        ,  .  ,                 . , ,    ,     ,       ,      . ,      ,                 .           ,       . <br><br><h4>  Additional materials: </h4><br><ul><li> <a href="http://www.sunandblackcat.com/tipFullView.php%3Fl%3Deng%26topicid%3D36">Shadow Mapping for point light sources in OpenGL</a> :       <b>sunandblackcat</b> . </li><li> <a href="http://ogldev.atspace.co.uk/www/tutorial43/tutorial43.html">Multipass Shadow Mapping With Point Lights</a> : ,    <b>ogldev</b> . </li><li> <a href="http://www.cg.tuwien.ac.at/~husky/RTR/OmnidirShadows-whyCaps.pdf">Omni-directional Shadows</a> :  ,    ,  <b>Peter Houska</b> . </li></ul><br> <b>PS</b> :    <a href="https://t.me/joinchat/Cpb05A46UPpMWdNVVCb4Vg">-</a>   .       ,   ! </div><p>Source: <a href="https://habr.com/ru/post/354208/">https://habr.com/ru/post/354208/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354196/index.html">Creating the main menu of the game</a></li>
<li><a href="../354198/index.html">How to transfer a polymorphic object to the STL algorithm</a></li>
<li><a href="../354200/index.html">Unified Scalable Remuneration System: Our Experience</a></li>
<li><a href="../354204/index.html">Morrowind speedran planning using simulated annealing</a></li>
<li><a href="../354206/index.html">Start with full stack and not regret: from senior developer to head of department for six years</a></li>
<li><a href="../354210/index.html">The announcement of the mitap ThinkPHP # 16 in Kharkov</a></li>
<li><a href="../354214/index.html">Payment Management Privat24 from Google-tables</a></li>
<li><a href="../354216/index.html">Forbes: Alibaba and Uber have become the most profitable companies for investors</a></li>
<li><a href="../354220/index.html">Applying recurrent layers to solve multiple paths</a></li>
<li><a href="../354224/index.html">slowpoke is not the fastest database</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>