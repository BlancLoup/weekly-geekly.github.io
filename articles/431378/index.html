<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The whole truth about the RTOS. Article # 23. Queues: introduction and basic services</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Queues were mentioned in a previous article (# 5). They provide a more flexible way to transfer simple messages between tasks compared to mailboxes. 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The whole truth about the RTOS. Article # 23. Queues: introduction and basic services</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/oy/fg/jv/oyfgjvk1xivp4zfhajjwfzycshs.jpeg"><br><br>  Queues were mentioned in a previous article (# 5).  They provide a more flexible way to transfer simple messages between tasks compared to mailboxes. <br><a name="habracut"></a><br>  Previous articles in the series: <br>  <a href="https://habr.com/post/431118/">Article # 22.</a>  <a href="https://habr.com/post/431118/">Mailboxes: ancillary services and data structures</a> <br>  <a href="https://habr.com/post/430856/">Article # 21.</a>  <a href="https://habr.com/post/430856/">Mailboxes: Introduction and Basic Services</a> <br>  <a href="https://habr.com/post/429588/">Article # 20.</a>  <a href="https://habr.com/post/429588/">Semaphores: helper services and data structures</a> <br>  <a href="https://habr.com/post/429156/">Article # 19.</a>  <a href="https://habr.com/post/429156/">Semaphores: introduction and basic services</a> <br>  <a href="https://habr.com/post/428890/">Article # 18.</a>  <a href="https://habr.com/post/428890/">Event flag groups: helper services and data structures</a> <br>  <a href="https://habr.com/post/428131/">Article # 17.</a>  <a href="https://habr.com/post/428131/">Event flag groups: introduction and basic services</a> <br>  <a href="https://habr.com/post/427439/">Article # 16.</a>  <a href="https://habr.com/post/427439/">Signals</a> <br>  <a href="https://habr.com/post/426477/">Article # 15.</a>  <a href="https://habr.com/post/426477/">Memory sections: services and data structures</a> <br>  <a href="https://habr.com/post/426425/">Article # 14.</a>  <a href="https://habr.com/post/426425/">Memory sections: introduction and basic services</a> <br>  <a href="https://habr.com/post/425353/">Article # 13.</a>  <a href="https://habr.com/post/425353/">Task data structures and unsupported API calls</a> <br>  <a href="https://habr.com/post/424713/">Article # 12.</a>  <a href="https://habr.com/post/424713/">Task Services</a> <br>  <a href="https://habr.com/post/424481/">Article # 11.</a>  <a href="https://habr.com/post/424481/">Tasks: configuration and introduction to the API</a> <br>  <a href="https://habr.com/post/423967/">Article # 10.</a>  <a href="https://habr.com/post/423967/">Scheduler: additional features and context preservation</a> <br>  <a href="https://habr.com/post/422615/">Article # 9.</a>  <a href="https://habr.com/post/422615/">Scheduler: implementation</a> <br>  <a href="https://habr.com/post/422617/">Article # 8.</a>  <a href="https://habr.com/post/422617/">Nucleus SE: Inside and Deployment</a> <br>  <a href="https://habr.com/post/418601/">Article # 7.</a>  <a href="https://habr.com/post/418601/">Nucleus SE: introduction</a> <br>  <a href="https://habr.com/post/418677/">Article # 6.</a>  <a href="https://habr.com/post/418677/">Other RTOS services</a> <br>  <a href="https://habr.com/post/415429/">Article # 5.</a>  <a href="https://habr.com/post/415429/">Interaction between tasks and synchronization</a> <br>  <a href="https://habr.com/post/415427/">Article # 4.</a>  <a href="https://habr.com/post/415427/">Tasks, context switching and interrupts</a> <br>  <a href="https://habr.com/post/415329/">Article # 3.</a>  <a href="https://habr.com/post/415329/">Tasks and planning</a> <br>  <a href="https://habr.com/post/414093/">Article # 2.</a>  <a href="https://habr.com/post/414093/">RTOS: Structure and Real Time</a> <a href="https://habr.com/post/414093/"><br></a>  <a href="https://habr.com/post/414093/">Article # 1.</a>  <a href="https://habr.com/post/414093/">RTOS: introduction.</a> <br><br><h2>  Using Queues </h2><br>  In the Nucleus SE, the queues are determined at the assembly stage.  The application can have up to 16 queues.  If there are no queues in the application, neither the data structures, nor the service code related to the queues are included in the application. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A queue is a set of areas in memory, the size of which is sufficient for one element of the type <b>ADDR</b> and the safe access to which is controlled so that it can be used by several tasks.  Tasks can write data to the queue until all areas are filled.  Tasks can read data from a queue, and data is usually received on a FIFO (First-in-First-Out) basis.  Attempting to write data to an overflowing queue or read data from an empty queue may result in an error or suspension of the task, depending on the selected API call parameters and the configuration of the Nucleus SE. <br><br><h2>  Queues and data channels </h2><br>  Nucleus SE supports data links, which were also mentioned in one of the previous articles (# 5) and will be discussed in detail in one of the following.  The main difference between queues and channels is the size of the message.  Queues contain messages consisting of one variable of type <b>ADDR</b> (usually these are pointers).  The channel contains messages of arbitrary size, individual for each channel in the application and assigned during parameter setting. <br><br><h2>  Setting up queues </h2><br><h3>  Number of queues </h3><br>  As with most Nucleus SE objects, the configuration of queues is mainly controlled by the <b>#define</b> directives in the <b>nuse_config.h</b> file.  The main parameter is <b>NUSE_QUEUE_NUMBER</b> , which determines the number of configured queues in the application.  The default value is zero (that is, there are no queues in the application) and can take values ‚Äã‚Äãup to 16. An incorrect value will cause a compile-time error, which will be generated when checking in the <b>nuse_config_check.h</b> file (it is included in the <b>nuse_config.c</b> file and compiled with it), which will trigger the <b>#error</b> directive. <br><br>  The choice of a non-zero value serves as the main activator for the queues.  This parameter is used when defining data structures and their size depends on its value (for more details, in the next article).  In addition, a non-zero value activates the API settings. <br><br><h3>  Activate API calls </h3><br>  Each API function (service call) in Nucleus SE has an activating <b>#define</b> directive in <b>nuse_config.h</b> .  For queues, these directives are: <br><br><pre><code class="plaintext hljs">NUSE_QUEUE_SEND NUSE_QUEUE_RECEIVE NUSE_QUEUE_JAM NUSE_QUEUE_RESET NUSE_QUEUE_INFORMATION NUSE_QUEUE_COUNT</code> </pre> <br>  By default, they are assigned the value <b>FALSE</b> , thus disabling all service calls and blocking the inclusion of the code implementing them.  To configure the queues in the application, you need to select the necessary API calls and set them to <b>TRUE</b> . <br><br>  Below is a snippet of code from the <b>nuse_config.h</b> file: <br><br><pre> <code class="plaintext hljs">#define NUSE_QUEUE_NUMBER 0 /* Number of queues in the system - 0-16 */ /* Service call enablers */ #define NUSE_QUEUE_SEND FALSE #define NUSE_QUEUE_RECEIVE FALSE #define NUSE_QUEUE_JAM FALSE #define NUSE_QUEUE_RESET FALSE #define NUSE_QUEUE_INFORMATION FALSE #define NUSE_QUEUE_COUNT FALSE</code> </pre><br>  If the queue API functions are activated, but there are no queues in the application (except <b>NUSE_Queue_Count ()</b> , which is always enabled), a compilation error will appear.  If your code uses an API call that has not been activated, it will cause a build error, since the implementation code was not included in the application. <br><br><h2>  Queue service calls </h2><br>  Nucleus RTOS supports ten queue-related service calls, which provide the following functionality: <br><br><ul><li>  Queuing a message.  The Nucleus SE is implemented as a <b>NUSE_Queue_Send ()</b> function. </li><li>  Receive a message from the queue.  Nucleus SE is implemented as a <b>NUSE_Queue_Receive ()</b> function. </li><li>  Putting a message in the head queue.  Nucleus SE is implemented in <b>NUSE_Queue_Jam ()</b> . </li><li>  Restore the queue to an unused state with the release of all suspended tasks (reset).  In Nucleus SE, implemented in <b>NUSE_Queue_Reset ()</b> . </li><li>  Providing information about a specific queue.  Nucleus SE is implemented in <b>NUSE_Queue_Information ()</b> . </li><li>  Return the number of currently configured queues in the application.  Nucleus SE is implemented in <b>NUSE_Queue_Count ()</b> . </li><li>  Adding a new queue to the application (creating a queue).  Nucleus SE is not implemented. </li><li>  Deleting a queue from an application.  Nucleus SE is not implemented. </li><li>  Return pointers to all queues in the application.  Nucleus SE is not implemented. </li><li>  Sending a message to all tasks suspended in a queue (broadcast).  Nucleus SE is not implemented. </li></ul><br>  The implementation of each of these service calls is described in detail below. <br><br><h2>  Service calls for writing and reading from queues </h2><br>  The basic operations that are performed on queues are writing (which is sometimes called queuing messages) and reading (also known as receiving messages).  It is also possible to record at the beginning of the queue (jamming).  Nucleus RTOS and Nucleus SE provide three basic API calls for these operations, which will be discussed below. <br><br><h3>  Write to the queue </h3><br>  The Nucleus RTOS API service call for writing to the queue is very flexible and allows you to pause the task implicitly or with a specific timeout if the operation cannot be completed immediately (for example, when you try to write to a filled queue).  Nucleus SE provides the same functions, but task suspension is optional, and timeout is not implemented. <br><br>  <b><i>Call to queue a message in the Nucleus RTOS</i></b> <br><br>  Service Call Prototype: <br><br>  <b>STATUS NU_Send_To_Queue (NU_QUEUE * queue, VOID * message, UNSIGNED size, UNSIGNED suspend);</b> <br><br>  Options: <br><br>  <b>queue</b> - pointer to the queue management block provided by the user; <br>  <b>message</b> - a pointer to the message to be sent; <br>  <b>size</b> - the number of data elements of type <b>UNSIGNED</b> in the message.  If the queue supports variable length messages, this parameter must be equal to the size of the message or be smaller than the size of the message supported by the queue.  If the queue supports fixed-size messages, this parameter must exactly match the size of the message supported by the queue; <br>  <b>suspend</b> - task suspension specification, can be <b>NU_NO_SUSPEND</b> or <b>NU_SUSPEND,</b> or timeout value. <br><br>  Return value: <br><br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br>  <b>NU_INVALID_QUEUE</b> - invalid pointer to the queue; <br>  <b>NU_INVALID_POINTER</b> - null pointer to the message ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - the message size is incompatible with the message size supported by the queue; <br>  <b>NU_INVALID_SUSPEND</b> - the suspension was made from a thread not associated with the task; <br>  <b>NU_QUEUE_FULL</b> - the queue is full and the suspension has not been specified; <br>  <b>NU_TIMEOUT</b> - the queue is full even after pausing the task for the specified timeout; <br>  <b>NU_QUEUE_DELETED</b> - the queue was deleted while the task was suspended; <br>  <b>NU_QUEUE_RESET</b> ‚Äî The queue was reset while the task was suspended. <br><br>  <b><i>Call to queue a message in the Nucleus SE</i></b> <br>  This API service call supports the core functionality of the Nucleus RTOS API. <br><br>  Service Call Prototype: <br><br>  <b>STATUS NUSE_Queue_Send (NUSE_QUEUE queue, ADDR * message, U8 suspend);</b> <br><br>  Options: <br><br>  <b>queue</b> - the <b>queue</b> index; <br>  <b>message</b> - pointer to the message to be sent, is one variable of type <b>ADDR</b> ; <br>  <b>suspend</b> - specification for pausing tasks, can be <b>NUSE_NO_SUSPEND or NUSE_SUSPEND</b> . <br><br>  Return value: <br><br>  <b>NUSE_SUCCESS</b> - the call was successfully completed; <br>  <b>NUSE_INVALID_QUEUE</b> - invalid queue index; <br>  <b>NUSE_INVALID_POINTER</b> - null pointer to the message ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> - attempt to pause a task from a <b>thread that</b> is not associated with the task or when the API for blocking tasks is disabled; <br>  <b>NUSE_QUEUE_FULL</b> - the queue is full and the suspension has not been specified; <br>  <b>NUSE_QUEUE_WAS_RESET</b> ‚Äî The queue was reset while the task was suspended. <br><br>  <b><i>Implement Message Queuing in the Nucleus SE</i></b> <br>  The code variant of the <b>NUSE_Queue_Send ()</b> API function (after checking the parameters) is selected using conditional compilation, depending on whether support for blocking tasks is activated or not.  We will consider both options. <br><br>  If task lock is not activated, the code for this service call is fairly simple: <br><br><pre> <code class="plaintext hljs">if (NUSE_Queue_Items[queue] == NUSE_Queue_Size[queue]) /* queue full */ { return_value = NUSE_QUEUE_FULL; } else /* queue element available */ { NUSE_Queue_Data[queue][NUSE_Queue_Head[queue]++] = *message; if (NUSE_Queue_Head[queue] == NUSE_Queue_Size[queue]) { NUSE_Queue_Head[queue] = 0; } NUSE_Queue_Items[queue]++; return_value = NUSE_SUCCESS; }</code> </pre><br>  The function simply checks if there is free space in the queue, and uses the <b>NUSE_Queue_Head []</b> index to store the message in the queue data area. <br><br>  If task lock is activated, the code becomes more complex: <br><br><pre> <code class="plaintext hljs">do { if (NUSE_Queue_Items[queue] == NUSE_Queue_Size[queue]) /* queue full */ { if (suspend == NUSE_NO_SUSPEND) { return_value = NUSE_QUEUE_FULL; } else { /* block task */ NUSE_Queue_Blocking_Count[queue]++; NUSE_Suspend_Task(NUSE_Task_Active, (queue &lt;&lt; 4) | NUSE_QUEUE_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; if (return_value != NUSE_SUCCESS) { suspend = NUSE_NO_SUSPEND; } } } else { /* queue element available */ NUSE_Queue_Data[queue][NUSE_Queue_Head[queue]++] = *message; if (NUSE_Queue_Head[queue] == NUSE_Queue_Size[queue]) { NUSE_Queue_Head[queue] = 0; } NUSE_Queue_Items[queue]++; if (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; /* check whether a task is blocked on this queue */ NUSE_Queue_Blocking_Count[queue]--; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Wake_Task(index); break; } } } return_value = NUSE_SUCCESS; suspend = NUSE_NO_SUSPEND; } } while (suspend == NUSE_SUSPEND);</code> </pre><br>  Some explanations may be helpful. <br><br>  The code is enclosed in a <b>do ... while loop</b> , which runs until the task suspend parameter is <b>NUSE_SUSPEND</b> . <br><br>  If the queue is full and the <b>suspend</b> parameter is <b>NUSE_NO_SUSPEND</b> , the API call ends with <b>NUSE_QUEUE_FULL</b> .  If the suspend parameter is set to <b>NUSE_SUSPEND</b> , the task is suspended.  On completion (that is, when the task is resumed), if the return value is <b>NUSE_SUCCESS</b> , that is, the task was resumed because the message was read (and not because the queue was reset), the code returns to the beginning of the cycle. <br>  If the queue is not full, the provided message is stored using the <b>NUSE_Queue_Head []</b> index in the queue data area.  Checks whether there are any pending tasks (waiting for messages) in the queue.  If there are such tasks, the first one resumes.  The variable suspend is assigned the value <b>NUSE_NO_SUSPEND</b> , and the API call ends with the value <b>NUSE_SUCCESS</b> . <br><br><h3>  Reading from the queue </h3><br>  The Nucleus RTOS API call to read from the queue is very flexible and allows you to suspend tasks implicitly or with a specific timeout if the operation cannot be completed immediately (for example, when trying to read from an empty queue).  Nucleus SE provides the same functionality, but task suspension is optional, and timeout is not implemented. <br><br>  <b><i>Call to receive messages from the queue at the Nucleus RTOS</i></b> <br>  Service Call Prototype: <br><br>  <b>STATUS NU_Receive_From_Queue (NU_QUEUE * queue, VOID * message, UNSIGNED size, UNSIGNED * actual_size, UNSIGNED suspend);</b> <br><br>  Options: <br><br>  <b>queue</b> - a pointer to the queue management block provided by the user; <br>  <b>message</b> - pointer to the repository for received messages; <br>  <b>size</b> - the number of data elements of type <b>UNSIGNED</b> in the message.  This number must match the size of the message as determined when the queue was created; <br>  <b>suspend</b> - task suspension specification, can be <b>NU_NO_SUSPEND</b> or <b>NU_SUSPEND,</b> or timeout value. <br><br>  Return value: <br><br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br>  <b>NU_INVALID_QUEUE</b> - invalid pointer to the queue; <br>  <b>NU_INVALID_POINTER</b> - null pointer to the message ( <b>NULL</b> ); <br>  <b>NU_INVALID_SUSPEND - an</b> attempt to pause a task from a thread unrelated to a task; <br>  <b>NU_QUEUE_EMPTY</b> - the queue is empty, and the suspension was not specified; <br>  <b>NU_TIMEOUT</b> - says that the queue is still empty, even after pausing the task for a specified period of time; <br>  <b>NU_QUEUE_DELETED</b> - the queue was deleted while the task was suspended; <br>  <b>NU_QUEUE_RESET</b> ‚Äî The queue was reset while the task was suspended. <br><br>  <b><i>Call to receive messages from the Nucleus SE queue</i></b> <br>  This API call supports the core Nucleus RTOS API. <br><br>  Service Call Prototype: <br><br>  <b>STATUS NUSE_Queue_Receive (NUSE_QUEUE queue, ADDR * message, U8 suspend);</b> <br><br>  Options: <br><br>  <b>queue</b> - the <b>queue</b> index; <br>  <b>message</b> - pointer to the repository for received messages, is a single variable of type <b>ADDR</b> ; <br>  <b>suspend</b> - task suspension specification, can be <b>NUSE_NO_SUSPEND</b> or <b>NUSE_SUSPEND</b> . <br><br>  Return value: <br><br>  <b>NUSE_SUCCESS</b> - the call was successfully completed; <br>  <b>NUSE_INVALID_QUEUE</b> - invalid queue index; <br>  <b>NUSE_INVALID_POINTER</b> - null pointer to the message ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> - attempt to pause a task from a <b>thread that</b> is not associated with the task or when the task lock support is disabled; <br>  <b>NUSE_QUEUE_EMPTY</b> - the queue is empty, and the suspension was not specified; <br>  <b>NUSE_QUEUE_WAS_RESET</b> ‚Äî The queue was reset while the task was suspended. <br><br>  <b><i>Implementing queuing messages in the Nucleus SE</i></b> <br>  The code variant of the <b>NUSE_Queue_Receive ()</b> API function (after checking the parameters) is selected using conditional compilation, depending on whether support for blocking tasks is activated or not.  Consider both options. <br><br>  If lock support is activated, the code for this API call is quite simple: <br><br><pre> <code class="plaintext hljs">if (NUSE_Queue_Items[queue] == 0) /* queue empty */ { return_value = NUSE_QUEUE_EMPTY; } else { /* message available */ *message = NUSE_Queue_Data[queue][NUSE_Queue_Tail[queue]++]; if (NUSE_Queue_Tail[queue] == NUSE_Queue_Size[queue]) { NUSE_Queue_Tail[queue] = 0; } NUSE_Queue_Items[queue]--; return_value = NUSE_SUCCESS; }</code> </pre><br>  The function simply checks if there is a message in the queue, and uses the <b>NUSE_Queue_Tail []</b> index to retrieve the message from the queue and return the data with a pointer to the message. <br><br>  If task lock is activated, the code becomes more complex: <br><br><pre> <code class="plaintext hljs">do { if (NUSE_Queue_Items[queue] == 0) /* queue empty */ { if (suspend == NUSE_NO_SUSPEND) { return_value = NUSE_QUEUE_EMPTY; } else { /* block task */ NUSE_Queue_Blocking_Count[queue]++; NUSE_Suspend_Task(NUSE_Task_Active, (queue &lt;&lt; 4) | NUSE_QUEUE_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; if (return_value != NUSE_SUCCESS) { suspend = NUSE_NO_SUSPEND; } } } else { /* message available */ *message = NUSE_Queue_Data[queue][NUSE_Queue_Tail[queue]++]; if (NUSE_Queue_Tail[queue] == NUSE_Queue_Size[queue]) { NUSE_Queue_Tail[queue] = 0; } NUSE_Queue_Items[queue]--; if (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; /* check whether a task is blocked */ /* on this queue */ NUSE_Queue_Blocking_Count[queue]--; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Wake_Task(index); break; } } } return_value = NUSE_SUCCESS; suspend = NUSE_NO_SUSPEND; } } while (suspend == NUSE_SUSPEND);</code> </pre><br>  Some explanations will be helpful. <br><br>  The code is enclosed in a <b>do ... while loop</b> , which runs until the task suspend parameter is <b>NUSE_SUSPEND</b> . <br><br>  If the queue is empty and the suspend parameter is <b>NUSE_NO_SUSPEND</b> , the API call ends with the value <b>NUSE_QUEUE_EMPTY</b> .  If the <b>suspend</b> parameter is set to <b>NUSE_SUSPEND</b> , the task is suspended.  Upon completion (that is, when the task resumes), if the return value is <b>NUSE_SUCCESS</b> , that is, the task was resumed because the message was sent (and not because the queue was reset), the code returns to the beginning of the cycle. <br><br>  If the queue contains messages, the stored message is returned using the <b>NUSE_Queue_Tail []</b> index.  Checks whether there are any suspended (pending) tasks in this queue.  If there are such tasks, the first one resumes.  The variable suspend is assigned the value <b>NUSE_NO_SUSPEND</b> , and the API call ends with the code <b>NUSE_SUCCESS</b> . <br><br><h3>  Writing to head queue </h3><br>  The Nucleus RTOS API service call for writing a message to the queue's head is very flexible and allows you to suspend the task implicitly or with a specific timeout if the operation cannot be completed immediately (for example, when trying to write to a crowded queue).  Nucleus SE provides the same functionality, but task suspension is optional, and timeout is not implemented. <br><br>  <b><i>Call to write message to head Nucleus RTOS queue</i></b> <br>  Service Call Prototype: <br><br>  <b>STATUS NU_Send_To_Front_Of_Queue (NU_QUEUE * queue, VOID * message, UNSIGNED size, UNSIGNED suspend);</b> <br><br>  Options: <br><br>  <b>queue</b> - pointer to the queue management block provided by the user; <br>  <b>message</b> - a pointer to the message to be sent; <br>  <b>size</b> - the number of data elements of type <b>UNSIGNED</b> in the message.  If the queue supports variable length messages, this parameter must be equal to the size of the message or less than the size of the message supported by the queue.  If the queue supports fixed-length messages, this parameter must exactly match the size of the message supported by the queue; <br>  <b>suspend</b> - task suspension specification, can be <b>NU_NO_SUSPEND</b> or <b>NU_SUSPEND,</b> or timeout value. <br><br>  Return value: <br><br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br>  <b>NU_INVALID_QUEUE</b> - invalid pointer to the queue; <br>  <b>NU_INVALID_POINTER</b> - null pointer to the message ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - the message size is incompatible with the size of the message supported by the queue; <br>  <b>NU_INVALID_SUSPEND</b> - an attempt to pause from a stream that is not associated with a task <br>  <b>NU_QUEUE_FULL</b> - the queue is full and the suspension has not been specified; <br>  <b>NU_TIMEOUT</b> - the queue is full, even after pausing the task for a certain timeout; <br>  <b>NU_QUEUE_DELETED</b> - the queue was deleted while the task was suspended; <br>  <b>NU_QUEUE_RESET</b> ‚Äî The queue was reset while the task was suspended. <br><br>  <b><i>Call to write message to head queue in Nucleus SE</i></b> <br>  This API call supports the core Nucleus RTOS API. <br><br>  Service Call Prototype: <br><br>  <b>STATUS NUSE_Queue_Jam (NUSE_QUEUE queue, ADDR * message, U8 suspend);</b> <br><br>  Options: <br><br>  <b>queue</b> - the <b>queue</b> index; <br>  <b>message</b> - a pointer to the message, is a single variable of type <b>ADDR</b> ; <br>  <b>suspend</b> - task suspension specification, can be <b>NUSE_NO_SUSPEND</b> or <b>NUSE_SUSPEND</b> . <br><br>  Return value: <br><br>  <b>NUSE_SUCCESS</b> - the call was successfully completed; <br>  <b>NUSE_INVALID_QUEUE</b> - invalid queue index; <br>  <b>NUSE_INVALID_POINTER</b> - null pointer to the message ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> - attempt to pause a task from a <b>thread that</b> is not associated with the task or when the task lock support is disabled; <br>  <b>NUSE_QUEUE_FULL</b> - the queue is full and the suspension has not been specified; <br>  <b>NUSE_QUEUE_WAS_RESET</b> ‚Äî The queue was reset while the task was suspended. <br><br>  <b><i>Writing a message to the top of the queue in Nucleus SE</i></b> <br>  The <b>NUSE_Queue_Jam ()</b> API function code variant is very similar to <b>NUSE_Queue_Send ()</b> , only data is stored using the <b>NUSE_Queue_Tail []</b> index, thus: <br><br><pre> <code class="plaintext hljs">if (NUSE_Queue_Items[queue] == NUSE_Queue_Size[queue]) /* queue full */ { return_value = NUSE_QUEUE_FULL; } else /* queue element available */ { if (NUSE_Queue_Tail[queue] == 0) { NUSE_Queue_Tail[queue] = NUSE_Queue_Size[queue] - 1; } else { NUSE_Queue_Tail[queue]--; } NUSE_Queue_Data[queue][NUSE_Queue_Tail[queue]] = *message; NUSE_Queue_Items[queue]++; return_value = NUSE_SUCCESS; }</code> </pre><br>  The next article will look at additional API calls related to queues, as well as data structures. <br><br>  <b>About the author:</b> Colin Walls has been working in the electronics industry for more than thirty years, spending a significant amount of time on embedded software.  He is now an embedded software engineer in Mentor Embedded (a division of Mentor Graphics).  Colin Walls often speaks at conferences and seminars, author of numerous technical articles and two books on embedded software.  Lives in the UK.  <a href="http://blogs.mentor.com/colinwalls">Colin's</a> professional <a href="http://blogs.mentor.com/colinwalls">blog</a> , e-mail: colin_walls@mentor.com. </div><p>Source: <a href="https://habr.com/ru/post/431378/">https://habr.com/ru/post/431378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../431366/index.html">Rumors: Corel buys Parallels, the deal will be closed in December, employees were informed yesterday</a></li>
<li><a href="../431370/index.html">The fastest reports in the wild west. And a handful of bugs to boot ...</a></li>
<li><a href="../431372/index.html">Interrupts from external devices in the x86 system. Part 2. Linux kernel boot options</a></li>
<li><a href="../431374/index.html">The last judgment: an analysis of the financial performance of the game in the early access</a></li>
<li><a href="../431376/index.html">Data migration in a bloody enterprise: what to analyze, so as not to overwhelm the project</a></li>
<li><a href="../431380/index.html">Mitap Netologii and Skyeng about soft skills "What a developer needs to know, except for the code"</a></li>
<li><a href="../431382/index.html">JVM Ecosystem Survey Results</a></li>
<li><a href="../431384/index.html">CLion 2018.3: remote development, code profiling, speed and not only</a></li>
<li><a href="../431388/index.html">The world through the eyes of the car. How do drones see it?</a></li>
<li><a href="../431390/index.html">Digital trends in 2019 and their impact on changing consumer behavior</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>