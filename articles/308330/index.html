<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using C ++ in AWS Lambda</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I plan to describe the process of creating and deploying AWS lambda functions that will call native code from the C ++ addon. As you c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using C ++ in AWS Lambda</h1><div class="post__text post__text-html js-mediator-article">  In this article I plan to describe the process of creating and deploying AWS lambda functions that will call native code from the C ++ addon.  As you can see, this process is not much different from creating normal AWS Lambda functions on Node.js ‚Äî all you have to do is configure your environment according to AWS requirements. <br><br><h4>  What is AWS Lambda? </h4><br><br>  Citing documentation: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  AWS Lambda is a computational service into which you can upload your code, which will be run on the AWS infrastructure on your behalf.  After downloading the code and creating what we call a lambda function, AWS Lambda takes responsibility for monitoring and managing the computing power required to execute this code.  You can use AWS Lambda in the following ways: <br><br><ul><li>  As an event-oriented computing service, when AWS Lambda runs your code when certain events occur, such as data changes in Amazon S3 or Amazon DynamoDB table. </li><li>  As a computing service that will run your code in response to an HTTP request to Amazon API Gateway or requests from AWS SDK. </li></ul></blockquote><br><br>  AWS Lambda is a very cool platform, but it supports only a few languages: Java, Node.js, and Python.  What to do if we want to execute some code in C ++?  Well, you can definitely link C ++ code with Java code, and Python can do it.  But we will see how to do this on Node.js.  In the world of Node.js, integration with C ++ code traditionally occurs through addons.  C ++ addon to Node.js is a compiled (native) Node.js module that can be called from JavaScript or any other Node.js module. <br><a name="habracut"></a><br><br>  Addons to Node.js are a big topic - if you haven‚Äôt written them before, you may want to read something like <a href="http://blog.scottfrees.com/c-processing-from-node-js">this series of posts</a> or be more <a href="http://blog.scottfrees.com/getting-your-c-to-the-web-with-node-js">specialized</a> about integrating C ++ and Node.js in web projects.  There is a <a href="https://scottfrees.com/ebooks/nodecpp/">good book</a> on this topic. <br><br><h4>  Addons in AWS Lambda </h4><br><br>  What is the use of add-ons in AWS Lambda differs from the classic scenario of their use?  The biggest problem is that AWS Lambda is not going to call <b>node-gyp</b> or any other build tool before running your function ‚Äî you must build a fully functional binary package.  This means, at a minimum, that you must build your addon on Linux before deploying it to AWS Lambda.  And if you have any dependencies, then you need to build not just on Linux, but on Amazon Linux.  There are other nuances, which I will discuss next. <br><br>  This article is not about building complex mixed applications on Node.js + C ++ in the Amazon infrastructure, it only describes the basic techniques of building and deploying such programs.  For other topics, you can refer to the Amazon documentation - there are a bunch of examples. <br><br>  I'm going to write a C ++ addon that will contain a function that takes three numbers and returns their average value.  Yes, I know, <i>this is something that can only be written in C ++</i> .  We will set this feature as available for use through AWS Lambda and test its operation via the AWS CLI. <br><br><h4>  Setting up the working environment </h4><br>  There is a reason why Java with its slogan " <a href="https://uk.wikipedia.org/wiki/Write_once,_run_anywhere">write once, run everywhere</a> " has become popular - and this reason is in the difficulty of distributing compiled binary code between different platforms.  Java did not solve all these problems perfectly (‚Äúwrite once, debug everywhere‚Äù), but since then we have come a long way.  Most often, we blissfully forget about platform-specific problems when we write code on Node.js - after all, Javascript is a platform-independent language.  And even in cases where Node.js applications depend on native addons, this is easily solved on different platforms thanks to <b>npm</b> and <b>node-gyp</b> . <br><br>  Many of these amenities, however, are lost when using Amazon Lambda - we need to fully build our Node.js program (and its dependencies).  If we use a native addon, this means that we will have to collect everything we need on the same architecture and platform where AWS Lambda (64-bit Linux) works, and in addition, we will need to use the same version of Node.js runtime that is used in AWS Lambda. <br><br><h5>  Requirement # 1: Linux </h5><br><br>  Of course, we can develop / test / debug lambda functions with addons on OS X or Windows, but when we get to the deployment stage in AWS Lambda, we will need a zip file with all the contents of the Node.js module - including all its dependencies .  The native code that is part of this zip file must be run on the AWS Lambda infrastructure.  And this means that we will need to collect it only under Linux.  Please note that in this example I do not use any additional libraries - my C ++ code is completely independent.  As I will explain in more detail later, if you need dependencies on external libraries, you need to go a little deeper. <br><br>  I will do all my experiments in this article on linux mint. <br><br><h5>  Requirement 2: 64-bit </h5><br><br>  This, perhaps, should have been called requirement # 1 ... For the very same reasons described above, you need to create a zip file for binary files for x64 architecture.  So your old dusty 32-bit Linux on a virtual machine will not work. <br><br><h5>  Requirement 3: Node.js version 4.3 </h5><br><br>  At the time of this writing, AWS Lambda supports Node.js 0.10 and 4.3.  Absolutely better for you to choose 4.3.  In the future, the current version may change - follow this.  I love using <a href="https://github.com/creationix/nvm">nvm</a> to install and conveniently switch between Node.js versions.  If you do not already have this tool - go and install it right now: <br><br><pre><code class="bash hljs">curl https://raw.githubusercontent.com/creationix/nvm/master/install.sh | bash <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> ~/.profile</code> </pre> <br><br>  Now install Node.js 4.3 and node-gyp <br><br><pre> <code class="bash hljs">nvm install 4.3 npm install -g node-gyp</code> </pre><br><br><h5>  Requirement 4: tools for building C ++ code (supporting C ++ 11) </h5><br><br>  When you develop an addon for Node.js v4 +, you should use a compiler with C ++ 11 support.  The latest versions of Visual Studio (Windows) and Xcode (Mac OS X) are suitable for development and testing, but since we need to build everything under Linux, we need g ++ 4.7 (or more recent).  Here's how to install g ++ 4.9 on Mint / Ubuntu: <br><br><pre> <code class="bash hljs">sudo add-apt-repository ppa:ubuntu-toolchain-r/<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> sudo apt-get update sudo apt-get install g++-4.9 sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.9 20</code> </pre><br><br><h4>  Create addon (locally) </h4><br><br>  We need to create two Node.js projects.  One will be our C ++ addon, which generally will not contain anything related to AWS Lambda - just a classic native addon.  The second project will be lambda functions in terms of AWS Lambda - that is, the Node.js module, which will import the native addon and take on the challenge of its functionality.  If you want to try it on your machine - all the code <a href="https://github.com/freezer333/nodecpp-demo">here</a> , and specifically this example is in the lambda-cpp folder. <br><br>  Let's start with the addon. <br><br><pre> <code class="bash hljs">mkdir lambda-cpp mkdir lambda-cpp/addon <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> lambda-cpp/addon</code> </pre><br><br>  To create the addon, we need three files - C ++ code, package.json to tell Node.js how to handle this addon and binding.gyp for the build process.  Let's start with the simplest - binding.gyp <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"targets"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"target_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"average"</span></span>, <span class="hljs-string"><span class="hljs-string">"sources"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"average.cpp"</span></span> ] } ] }</code> </pre><br><br>  This is probably the simplest version of the binding.gyp file, which is only possible to create - we set the name of the target and the source code for compilation.  If necessary, you can bloat up the most complicated things, reflecting compiler options, paths to external directories, libraries, etc.  Just remember that everything that you refer to must be statically linked to the binary and compiled for x64 architecture. <br><br>  Now let's create package.json, which should define the entry point of this addon: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"average"</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"./build/Release/average"</span></span>, <span class="hljs-string"><span class="hljs-string">"gypfile"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"Scott Frees &lt;scott.frees@gmail.com&gt; (http://scottfrees.com/)"</span></span>, <span class="hljs-string"><span class="hljs-string">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"ISC"</span></span> }</code> </pre><br><br>  The key point here is the ‚Äúmain‚Äù property, which explains Node.js, that this particular binary is the entry point of this module and it should be loaded every time someone does require ('average'). <br><br>  Now the source code.  Let's open average.cpp and create a simple addon with a function that returns the average of all parameters passed to it (we will not be limited to only three!). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;node.h&gt; using namespace v8; void Average(const FunctionCallbackInfo&lt;Value&gt;&amp; args) { Isolate * isolate = args.GetIsolate(); double sum = 0; int count = 0; for (int i = 0; i &lt; args.Length(); i++){ if ( args[i]-&gt;IsNumber()) { sum += args[i]-&gt;NumberValue(); count++; } } Local&lt;Number&gt; retval = Number::New(isolate, sum / count); args.GetReturnValue().Set(retval); } void init(Local&lt;Object&gt; exports) { NODE_SET_METHOD(exports, "average", Average); } NODE_MODULE(average, init)</span></span></span></span></code> </pre><br><br>  If you are not familiar with using V8, please read some articles or a book about this - this post is not about that.  In short, the <b>NODE_MODULE</b> macro at the end of the file indicates which function should be called when this module is loaded.  The <b>init</b> function adds a new function to the list exported by this module ‚Äî associating the C ++ function <b>Average</b> with the <b>average</b> function called from Javascript. <br><br>  We can build all this with <b>node-gyp configure build</b> .  If everything went well, you will see <b>gyp info ok</b> at the end of the output.  As a simple test, let's create the test.js file and make some calls from it: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// test.js const addon = require('./build/Release/average'); console.log(addon.average(1, 2, 3, 4)); console.log(addon.average(1, "hello", "world", 42));</span></span></code> </pre><br><br>  Run this code using the <b>node test.js command</b> and you will see the responses 2.5 and 21.5 on the console.  Please note that the lines " <b>hello</b> " and " <b>world</b> " did not affect the results of the calculations, because the addon checked the input parameters and used only numbers in the calculations. <br><br>  Now we need to remove test.js - it will not be part of our addon, which we are going to fix in AWS Lambda. <br><br><h4>  Create a lambda function </h4><br><br>  And now let's create, in fact, a lambda function for AWS Lambda.  As you (probably) already know, for AWS Lambda we need to create a handler that will be called each time a certain event occurs.  This handler will receive the description of this event (which may be, for example, an operation of changing data in S3 or DynamoDB) as a JS object.  For this test, we use a simple event described by the following JSON: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">op1</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-attr"><span class="hljs-attr">op2</span></span>: <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-attr"><span class="hljs-attr">op3</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }</code> </pre><br><br>  We can do this right in the addon folder, but I prefer to create a separate Node.js module and pull up the local addon as an npm dependency.  Let's create a new folder somewhere near <b>lambda-cpp / addon</b> , let it be called <b>lambda-cpp / lambda</b> . <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> .. mkdir lambda <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> lambda</code> </pre><br><br>  Now create the index.js file and write the following code in it: <br><br><pre> <code class="javascript hljs">exports.averageHandler = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event, context, callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> addon = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'average'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = addon.average(event.op1, event.op2, event.op3) callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, result); }</code> </pre><br><br>  Notice that we referred to the " <b>average</b> " external dependency.  Let's create a package.json file, in which we will describe a link to a local addon: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"lambda-demo"</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"index.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"Scott Frees &lt;scott.frees@gmail.com&gt; (http://scottfrees.com/)"</span></span>, <span class="hljs-string"><span class="hljs-string">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"ISC"</span></span>, <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span>: { <span class="hljs-string"><span class="hljs-string">"average"</span></span>: <span class="hljs-string"><span class="hljs-string">"file:../addon"</span></span> } }</code> </pre><br><br>  When you run the <b>npm install</b> command, npm will pull out your local addon and copy it to the <b>node_modules</b> subfolder, and also call <b>node-gyp</b> to build it.  The structure of your folders and files after this will look like this: <br><br><pre> / lambda-cpp
  - / addon
     - average.cpp
     - binding.gyp
     - package.json
  - / lambda
     - index.js
     - package.json
     - node_modules /
       - average / (contains the binary addon)
</pre><br><br><h4>  Local testing </h4><br><br>  Now we have an index.js file that exports the AWS Lambda call handler and we can try loading it there.  But let's first test it locally.  There is a great module called <b>lambda-local</b> ‚Äî it can help us with testing. <br><br><pre> <code class="bash hljs">npm install -g lambda-local</code> </pre><br><br>  After its installation, we can call our lambda function by the name of the " <b>averageHandler</b> " handler and pass our test event to it.  Let's create the sample.js file and write to it: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-attr"><span class="hljs-attr">op1</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-attr"><span class="hljs-attr">op2</span></span>: <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-attr"><span class="hljs-attr">op3</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> };</code> </pre><br><br>  Now we can execute our lambda with the command: <br><br><pre> <code class="bash hljs">lambda-local -l index.js -h averageHandler -e sample.js Logs ------ START RequestId: 33711c24-01b6-fb59-803d-b96070ccdda5 END Message ------ 7</code> </pre><br><br>  As expected, the result is 7 (the average of the numbers 4, 15 and 2). <br><br><h4>  Warmth with AWS CLI </h4><br><br>  There are two ways to deploy code in AWS Lambda - through a web interface and through command line utilities (CLI).  I plan to use the CLI, since this approach seems more universal to me.  However, everything described below can also be done via the web interface. <br><br>  If you do not have an AWS account yet, now is the time to create one.  Next you need to create an Administrator.  Full instructions are in the <a href="http://docs.aws.amazon.com/lambda/latest/dg/setup.html">documentation of Amazon</a> .  Do not forget to add the <a href="http://docs.aws.amazon.com/lambda/latest/dg/with-userapp-walkthrough-custom-events-create-iam-role.html">AWSLambdaBasicExecutionRole</a> role to the created Administrator. <br><br>  Now that you have a user with Administrator privileges, you need to get a key for configuring AWS CLI.  You can do this through the IAM console.  How to download your key in the form of a csv-file is described here in <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-set-up.html">this instruction</a> . <br><br>  Once you have the key, you can install the CLI.  There are several ways to do this, and for installation we will need Python in any case.  The easiest way, in my opinion, is to use the installer: <br><br><pre> <code class="bash hljs">curl <span class="hljs-string"><span class="hljs-string">"https://s3.amazonaws.com/aws-cli/awscli-bundle.zip"</span></span> -o <span class="hljs-string"><span class="hljs-string">"awscli-bundle.zip"</span></span> unzip awscli-bundle.zip sudo ./awscli-bundle/install -i /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/aws -b /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/aws</code> </pre><br><br>  Next you need to configure the CLI.  Run the <b>aws configure</b> command and enter your key and secret code.  You can also select a default region and output format.  You will most likely want to attach the profile to this configuration (as you will need it later) with the argument <b>--profile</b> . <br><br><pre> <code class="bash hljs">aws configure --profile lambdaProfile AWS Access Key ID [None]: XXXXXXXXX AWS Secret Access Key [None]: XXXXXXXXXXXXXXXXXXXX Default region name [None]: us-west-2 Default output format [None]:</code> </pre><br><br>  You can check that everything is configured correctly by running the command to view all the lambda functions: <br><br><pre> <code class="bash hljs">aws lambda list-functions { <span class="hljs-string"><span class="hljs-string">"Functions"</span></span>: [] }</code> </pre><br><br>  Since we have just begun work, there are no functions yet.  But at least we have not seen any error messages - this is good. <br><br><h4>  Packaging lambda functions and addon </h4><br><br>  The most important (and often discussed on the Internet) step in the whole process is to make sure that your entire module will be packed into a zip file correctly.  Here are the most important things to check: <br><br><ol><li>  The index.js file must be in the root folder of the zip file.  You should not package the / lambda-addon / lambda folder itself - only its contents.  In other words - if you unzip the created zip file into the current folder - the index.js file should be in the same folder, not in a subfolder. </li><li>  The node_modules folder and all its contents should be packaged in a zip file. </li><li>  You must build the addon and package it in a zip file on the correct platform (see above requirements - Linux, x64, etc.) </li></ol><br><br>  In the folder where index.js is located, pack all the files that need to be packed.  I will create a zip file in the parent folder. <br><br><pre> <code class="bash hljs">zip -r ../average.zip node_modules/ average.cpp index.js binding.gyp package.json</code> </pre><br><br>  * Pay attention to the key "-r" - we need to pack the entire contents of the node_modules folder.  Check the resulting file with the command less, you should get something like this: <br><br><pre> <code class="bash hljs">less ../average.zip Archive: ../average.zip Length Method Size Cmpr Date Time CRC-32 Name -------- ------ ------- ---- ---------- ----- -------- ---- 0 Stored 0 0% 2016-08-17 19:02 00000000 node_modules/ 0 Stored 0 0% 2016-08-17 19:02 00000000 node_modules/average/ 1 Stored 1 0% 2016-08-17 17:39 6abf4a82 node_modules/average/output.txt 478 Defl:N 285 40% 2016-08-17 19:02 e1d45ac4 node_modules/average/package.json 102 Defl:N 70 31% 2016-08-17 15:03 1f1fa0b3 node_modules/average/binding.gyp 0 Stored 0 0% 2016-08-17 19:02 00000000 node_modules/average/build/ 115 Defl:N 110 4% 2016-08-17 19:02 c79d3594 node_modules/average/build/binding.Makefile 3243 Defl:N 990 70% 2016-08-17 19:02 d3905d6b node_modules/average/build/average.target.mk 3805 Defl:N 1294 66% 2016-08-17 19:02 654f090c node_modules/average/build/config.gypi 0 Stored 0 0% 2016-08-17 19:02 00000000 node_modules/average/build/Release/ 0 Stored 0 0% 2016-08-17 19:02 00000000 node_modules/average/build/Release/.deps/ 0 Stored 0 0% 2016-08-17 19:02 00000000 node_modules/average/build/Release/.deps/Release/ 125 Defl:N 67 46% 2016-08-17 19:02 daf7c95b node_modules/average/build/Release/.deps/Release/average.node.d 0 Stored 0 0% 2016-08-17 19:02 00000000 node_modules/average/build/Release/.deps/Release/obj.target/ 0 Stored 0 0% 2016-08-17 19:02 00000000 node_modules/average/build/Release/.deps/Release/obj.target/average/ 1213 Defl:N 386 68% 2016-08-17 19:02 b5e711d9 node_modules/average/build/Release/.deps/Release/obj.target/average/average.od 208 Defl:N 118 43% 2016-08-17 19:02 c8a1d92a node_modules/average/build/Release/.deps/Release/obj.target/average.node.d 13416 Defl:N 3279 76% 2016-08-17 19:02 d18dc3d5 node_modules/average/build/Release/average.node 0 Stored 0 0% 2016-08-17 19:02 00000000 node_modules/average/build/Release/obj.target/ 0 Stored 0 0% 2016-08-17 19:02 00000000 node_modules/average/build/Release/obj.target/average/ 5080 Defl:N 1587 69% 2016-08-17 19:02 6aae9857 node_modules/average/build/Release/obj.target/average/average.o 13416 Defl:N 3279 76% 2016-08-17 19:02 d18dc3d5 node_modules/average/build/Release/obj.target/average.node 12824 Defl:N 4759 63% 2016-08-17 19:02 f8435fef node_modules/average/build/Makefile 554 Defl:N 331 40% 2016-08-17 15:38 18255a6e node_modules/average/average.cpp 237 Defl:N 141 41% 2016-08-17 19:02 7942bb01 index.js 224 Defl:N 159 29% 2016-08-17 18:53 d3d59efb package.json -------- ------- --- ------- 55041 16856 69% 26 files (<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-string"><span class="hljs-string">'q'</span></span> to <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> less)</code> </pre><br><br>  If you don‚Äôt see the contents of the node_modules folder inside the zip file or if the files have an additional level of nesting in the folder hierarchy, reread everything that is written above! <br><br><h4>  Download to AWS Lambda </h4><br><br>  Now we can create a lambda function using the ‚Äúlambda create-function‚Äù command. <br><br><pre> <code class="bash hljs">aws lambda create-function \ --region us-west-2 \ --<span class="hljs-keyword"><span class="hljs-keyword">function</span></span>-name average \ --zip-file fileb://../average.zip \ --handler index.averageHandler \ --runtime nodejs4.3 \ --role arn:aws:iam::729041145942:role/lambda_execute</code> </pre><br><br>  Most of the parameters speak for themselves - but if you are not familiar with AWS Lambda, then the " <b>role</b> " parameter may look somewhat mysterious to you.  As mentioned above, to work with AWS Lambda, you had to create a role that has <b>AWSLambdaBasicExecutionRole</b> permission.  You can get a line starting with " <b>arn:</b> " for this role through the IAM web interface (by clicking on this role). <br><br>  If everything goes well, you should get a JSON with a response that contains some additional information about the newly added lambda function. <br><br><h4>  Testing with AWS CLI </h4><br><br>  Now that we have secured our lambda function, let's test it using the same command line interface.  Let's call our function, passing it the description of the same event as last time. <br><br><pre> <code class="bash hljs">aws lambda invoke \ --invocation-type RequestResponse \ --<span class="hljs-keyword"><span class="hljs-keyword">function</span></span>-name average \ --region us-west-2 \ --<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>-type Tail \ --payload <span class="hljs-string"><span class="hljs-string">'{"op1":4, "op2":15, "op3":2}'</span></span> \ --profile lambdaProfile \ output.txt</code> </pre><br><br>  You will receive an answer in this form: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"LogResult"</span></span>: <span class="hljs-string"><span class="hljs-string">"U1RBUlQgUmVxdWVzdElkOiAxM2UxNTk4ZC02NGMxLTExZTYtODQ0Ny0wZDZjMjJjMTRhZWYgVmVyc2lvbjogJExBVEVTVApFTkQgUmVxdWVzdElkOiAxM2UxNTk4ZC02NGMxLTExZTYtODQ0Ny0wZDZjMjJjMTRhZWYKUkVQT1JUIFJlcXVlc3RJZDogMTNlMTU5OGQtNjRjMS0xMWU2LTg0NDctMGQ2YzIyYzE0YWVmCUR1cmF0aW9uOiAwLjUxIG1zCUJpbGxlZCBEdXJhdGlvbjogMTAwIG1zIAlNZW1vcnkgU2l6ZTogMTI4IE1CCU1heCBNZW1vcnkgVXNlZDogMzUgTUIJCg=="</span></span>, <span class="hljs-string"><span class="hljs-string">"StatusCode"</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span> }</code> , <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"LogResult"</span></span>: <span class="hljs-string"><span class="hljs-string">"U1RBUlQgUmVxdWVzdElkOiAxM2UxNTk4ZC02NGMxLTExZTYtODQ0Ny0wZDZjMjJjMTRhZWYgVmVyc2lvbjogJExBVEVTVApFTkQgUmVxdWVzdElkOiAxM2UxNTk4ZC02NGMxLTExZTYtODQ0Ny0wZDZjMjJjMTRhZWYKUkVQT1JUIFJlcXVlc3RJZDogMTNlMTU5OGQtNjRjMS0xMWU2LTg0NDctMGQ2YzIyYzE0YWVmCUR1cmF0aW9uOiAwLjUxIG1zCUJpbGxlZCBEdXJhdGlvbjogMTAwIG1zIAlNZW1vcnkgU2l6ZTogMTI4IE1CCU1heCBNZW1vcnkgVXNlZDogMzUgTUIJCg=="</span></span>, <span class="hljs-string"><span class="hljs-string">"StatusCode"</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span> }</code> </pre><br><br>  Not very clear yet, but it is easy to fix.  The " <b>LogResult</b> " parameter is encoded in <b>base64</b> , so that we can decode it: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> U1RBUlQgUmVxdWVzdElkOiAxM2UxNTk4ZC02NGMxLTExZTYtODQ0Ny0wZDZjMjJjMTRhZWYgVmVyc2lvbjogJExBVEVTVApFTkQgUmVxdWVzdElkOiAxM2UxNTk4ZC02NGMxLTExZTYtODQ0Ny0wZDZjMjJjMTRhZWYKUkVQT1JUIFJlcXVlc3RJZDogMTNlMTU5OGQtNjRjMS0xMWU2LTg0NDctMGQ2YzIyYzE0YWVmCUR1cmF0aW9uOiAwLjUxIG1zCUJpbGxlZCBEdXJhdGlvbjogMTAwIG1zIAlNZW1vcnkgU2l6ZTogMTI4IE1CCU1heCBNZW1vcnkgVXNlZDogMzUgTUIJCg== | base64 --decode START RequestId: 13e1598d-64c1-11e6-8447-0d6c22c14aef Version: <span class="hljs-variable"><span class="hljs-variable">$LATEST</span></span> END RequestId: 13e1598d-64c1-11e6-8447-0d6c22c14aef REPORT RequestId: 13e1598d-64c1-11e6-8447-0d6c22c14aef Duration: 0.51 ms Billed Duration: 100 ms Memory Size: 128 MB Max Memory Used: 35 MB</code> </pre><br><br>  It became a little more readable, but still gave us not a lot of understanding about what happened.  This is because our lambda function did not write anything to the log file.  If you want to see the result, you can test the function through the web interface, where it is easier to see the input and output parameters.  In the meantime, you can change your index.js file, repack the zip file, redo it and call your function again: <br><br><pre> <code class="javascript hljs">exports.averageHandler = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event, context, callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> addon = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./build/Release/average'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(event); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = addon.average(event.op1, event.op2, event.op3) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result); callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, result); }</code> </pre><br><br>  After decoding the answer, you will see something like this: <br><br><pre> <code class="bash hljs">START RequestId: 1081efc9-64c3-11e6-ac21-43355c8afb1e Version: <span class="hljs-variable"><span class="hljs-variable">$LATEST</span></span> 2016-08-17T21:39:24.013Z 1081efc9-64c3-11e6-ac21-43355c8afb1e { op1: 4, op2: 15, op3: 2 } 2016-08-17T21:39:24.013Z 1081efc9-64c3-11e6-ac21-43355c8afb1e 7 END RequestId: 1081efc9-64c3-11e6-ac21-43355c8afb1e REPORT RequestId: 1081efc9-64c3-11e6-ac21-43355c8afb1e Duration: 1.75 ms Billed Duration: 100 ms Memory Size: 128 MB Max Memory Used: 17 MB</code> </pre><br><br><h4>  Future plans </h4><br><br>  So, at the moment we have a 100% working AWS Lambda function that calls C ++ code from the addon.  Of course, we have not yet done something really useful.  Since our lambda function does some calculations, the next logical step is to bind it to the Gateway API so that input parameters can be taken from HTTP requests.  For information on how to do this, you can read in the <a href="http://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started.html">Getting Started</a> section on calling lambda functions. <br><br>  I hope you have now become convinced that deploying C ++ code in AWS Lambda is possible and not even too complicated - just follow the assembly requirements described at the beginning of the article and everything will be fine.  The remaining steps are quite trivial and are completely analogous to the deployment of any lambda function in AWS.  As I said, if your addon requires some dependencies, they will have to be statically linked to its binary. <br><br>  All code from this article is available <a href="https://github.com/freezer333/nodecpp-demo">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/308330/">https://habr.com/ru/post/308330/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308316/index.html">The book "Web development using Node and Express. Full use of JavaScript stack ¬ª</a></li>
<li><a href="../308318/index.html">Password Visibility Toggle - Android Support Library, revision 24.2.0</a></li>
<li><a href="../308320/index.html">Selection of servers for video surveillance systems</a></li>
<li><a href="../308326/index.html">Ember: Declarative templating with compiled helpers</a></li>
<li><a href="../308328/index.html">How we did monitoring requests mongodb</a></li>
<li><a href="../308332/index.html">Moving to the cloud: everything you wanted to know about Office 365 ProPlus</a></li>
<li><a href="../308334/index.html">Major world events, hacktivism and #OpOlympicHacking</a></li>
<li><a href="../308336/index.html">Analyzing errors in open components of Unity3D</a></li>
<li><a href="../308338/index.html">GPS trackers through the eyes of a system administrator</a></li>
<li><a href="../308340/index.html">What to prefer: own resources, purchase or outsourcing?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>