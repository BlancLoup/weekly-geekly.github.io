<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>FPGA for the programmer, simple recipes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Priority code structure 


 In the development of electronic devices, the line between the developer-circuit designer and the developer programmer is ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>FPGA for the programmer, simple recipes</h1><div class="post__text post__text-html js-mediator-article"><h3 id="prioritetnaya-struktura-koda">  Priority code structure </h3><br><p>  In the development of electronic devices, the line between the developer-circuit designer and the developer programmer is very blurred.  What really says about who should write RTL under FPGA. </p><br><p>  On the one hand, RTL is the territory of the circuits, on the other hand, FPGA resources are getting cheaper, synthesizers are getting smarter.  The price of an RTL designer's error for FPGA does not exceed the price of a programmer's error, and the created schemes can also be updated and expanded in functionality, like a regular processor firmware. </p><br><p>  Chip manufacturers are also not lagging behind, they began to pack FPGAs in one package with a processor, even Intel released a processor for a PC with FPGA inside, having bought Altera for this well-known FPGA manufacturer. </p><br><p>  I think that all true programmers of the Universe are sending signals that they just need to study RTL and start writing ‚Äúcode‚Äù for FPGA no worse than for their usual processors. <br>  Once upon a time, I walked this path and allow myself to give some tips for speeding up. </p><br><a name="habracut"></a><br><p>  First, you need to select a description language.  At the moment, using languages ‚Äã‚Äãlike System Verilog, SystemC, etc., to create schemas, is more like a deal with the devil than a job.  Therefore, in the ranks of the old and basic VHDL and Verilog.  I tried both and I advise you to use the latter.  Verilog is more syntax-friendly to programmers, and generally somewhat more up-to-date. </p><br><p>  If you are determined to go this way, then I believe that you already know the keywords and standard Verilog constructs.  You have spent some time and understand that in the description of the equipment everything happens at the same time, and not in turn, as in the programs. <br>  For the time being we will leave the question of meta-stability and the race of signals, for this we will restrict ourselves only to synchronous circuits with synchronous dumping, and leave all the combinatorics and asynchronism to the old school. </p><br><p>  In the descriptions of schemes, the structure of the code is very important, the organization of which will be discussed later.  The structure not only improves the readability and maintainability of the code, but also affects the outcome of the final scheme. </p><br><p>  Real RTL designers think ‚Äúschematically‚Äù; they organize the code into blocks and thereby determine its structure.  We will not immediately change the way of thinking, but will create ‚Äúprogrammer‚Äù descriptions.  We will focus on what we want to get, and creating a suitable circuit for this will be left to the synthesizer.  Everything is like with high-level languages, we write code, and we hang the optimization and translation into machine codes on the compiler. </p><br><p>  The fee for this approach is about the same, slightly less optimal from the point of view of resources, but as stated above, the price of resources decreases, so we will not regret the ammunition.  Synthesizers have wisely become smarter at the moment, but there are still some problems, consider an example: </p><br><pre><code class="hljs ruby">input clk; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  input data_we; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      input [<span class="hljs-number"><span class="hljs-number">7</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>] data; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    reg [<span class="hljs-number"><span class="hljs-number">7</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>] Data; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> reg DataRdy; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   reg [<span class="hljs-number"><span class="hljs-number">7</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>] ProcessedData; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  /<span class="hljs-regexp"><span class="hljs-regexp">/     ---------------------- always @(posedge clk) begin if(data_we == 1'b1) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    begin Data &lt;= data; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  DataRdy &lt;= 1'b1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    end end   ‚Ññ1</span></span></code> </pre> <br><p>  While there are no problems, the reception was allocated in a separate unit, everything is convenient and clear.  Now let's say that we continue to work with the received data, and we want to uncheck the DataRdy flag at the end of data processing in order to understand when new data will arrive. </p><br><pre> <code class="hljs erlang">//    ---------------------- always @(posedge clk) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(DataRdy == <span class="hljs-number"><span class="hljs-number">1</span></span>'b1) //    <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> //  ProcessedData &lt;= Data; DataRdy &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>'b0; // ,   <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>   ‚Ññ<span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br><p>  Now the problems begin, the fans of Xilinx for sure, but I think that other synthesizers will be in solidarity.  The synthesizer will say that the DataRdy signal has two sources that change its value, it changes on the signal front in 2 blocks and it does not matter that the clock signal is one. </p><br><p>  It may seem that the synthesizer does not know what value to set if the change conditions in both blocks are fulfilled simultaneously, when DataRdy is 1 </p><br><pre> <code class="hljs vhdl">//   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(data_we == <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>) DataRdy &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; ... //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(DataRdy == <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>) DataRdy &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>;   ‚Ññ<span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  But modifying the code that solves this conflict will not help. </p><br><pre> <code class="hljs erlang">//     ---------------------- always @(posedge clk) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> //   ,     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((data_we == <span class="hljs-number"><span class="hljs-number">1</span></span>'b1)&amp;&amp;(DataRdy == <span class="hljs-number"><span class="hljs-number">1</span></span>'b0)) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Data &lt;= data; //  DataRdy &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>'b1; //    <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>   ‚Ññ<span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br><p>  Logically, everything is correct, there are no conflicts, but the synthesizer will persistently complain about the double signal source, and it is impossible to agree with it.  It is impossible to change one signal in different blocks, so that everything will work out, and reception and processing should be put in one block. </p><br><p>  And here is the first sentence, <strong>and let's say we will have only 1 always block in the module</strong> , and everything that our module does will be placed in this block, our example will look like this </p><br><pre> <code class="hljs ruby">input clk; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  input data_we; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      input [<span class="hljs-number"><span class="hljs-number">7</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>] data; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    reg [<span class="hljs-number"><span class="hljs-number">7</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>] Data; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> reg DataRdy; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   reg [<span class="hljs-number"><span class="hljs-number">7</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>] ProcessedData; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  /<span class="hljs-regexp"><span class="hljs-regexp">/--------------------------------------------------- /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/--------------------------------------------------- always @(posedge clk) begin /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ,     if((data_we == 1'b1)&amp;&amp;(DataRdy == 1'b0)) begin Data &lt;= data; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  DataRdy &lt;= 1'b1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    end else if(DataRdy == 1'b1) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    begin /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ProcessedData &lt;= Data; DataRdy &lt;= 1'b0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,   end end   ‚Ññ5</span></span></code> </pre> <br><p>  Now everything works, but the module is no longer so clear, there is no obvious separation between receiving and processing, all in one pile.  Here we can come to the aid of one very pleasant property of the Verilog language.  If in one block you make several assignments to one variable (talking about non-blocking assignments), then the last of them will be executed ( <em>Verilog HDL IEEE Std 1364-2001 Standard</em> ).  It is more correct to say that they are all executed in the order described, but since all such assignments occur simultaneously, the variable will take the last assigned value. <br><br>  That is, if you write this: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">input</span></span> B; reg [<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] A; <span class="hljs-keyword"><span class="hljs-keyword">always</span></span> @(posedge clk) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> A &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; A &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span>; A &lt;= <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(B) A &lt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>   ‚Ññ<span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br><p>  That <strong>A</strong> will take the value 3 if <strong>B is</strong> false, and if <strong>B is</strong> true, then <strong>A</strong> will take the value 4, this can be seen in the next image </p><br><img src="https://habrastorage.org/files/5be/bf7/378/5bebf7378cf64b8b93901293577bc778.jpg"><br><p>  <u><em>Figure 1.</em></u>  <u><em>Timing diagram of the simulation behavior of the description number 6</em></u> </p><br><p>  This is a fully described and synthesized construction of the standard, which gives us interesting possibilities; there is no need to make complex chains of the <strong>if</strong> - <strong>else if construct</strong> separating when to assign a variable to one value and when to another.  You can simply write the condition and value of a variable, write it without thinking about other conditions and assignments of this variable, write it as if in isolation from other code. </p><br><p>  Next, it remains to arrange such assignments in the correct order, thereby setting their priorities in case of simultaneous execution, and everything will turn out on its own.  This is a very convenient way to control the code, while being controlled by a synthesizer, and not by humans. </p><br><p>  The following example shows how this might look. </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/--------------------------------------------------- /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/--------------------------------------------------- always @(posedge clk) begin /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,   ----- if(...) Data &lt;= data; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,   ---- if(...) Data &lt;= Func(Data); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/,   ------------- if(reset_n == 1'b0) Data &lt;= 0; end   ‚Ññ7</span></span></code> </pre> <br><p>  Wherever the module creation curve takes you, you can be sure that the reset state will override everything you've done above, you can make as many errors in logic as you can, the reset will occur and set the variable described in the reset block. </p><br><p>  You can also be sure that if you suddenly coincide at one point in time with the conditions for processing and receiving data, then you will process the data and not wipe them with new arrivals.  This will happen because the processing in our code is lower, it is of higher priority.  If suddenly at some point you realize that it is more important not to lose the incoming data, change the blocks in places and thereby change the priorities. </p><br><p>  If you have several interfaces that can change data, again, you simply arrange the code sections that implement the interface one after another, and thus prioritize data access. <br></p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/--------------------------------------------------- /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/--------------------------------------------------- always @(posedge clk) begin /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   1 , /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ------------------- if(master1_we) Data &lt;= data1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   2 , /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ----------------- if(master2_we) Data &lt;= data2; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,   ---- if(need_process) Data &lt;= (Data &lt;&lt; 1); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/,   ------------- if(reset_n == 1'b0) Data &lt;= 0; end   ‚Ññ8</span></span></code> </pre> <br><p>  A simulation of the job description can be seen below. </p><br><img src="https://habrastorage.org/files/5dc/ceb/3e9/5dcceb3e9177463785d9f0d7b78f8f12.jpg"><br><p>  <u><em>Pic2.</em></u>  <u><em>Timing diagram of the simulation behavior of the description number 8</em></u> </p><br><p>  This system is controlled by several masters and arbitration between them is automatic.  When the masters control the circuit in turn (phase 1 and 2, fig. 2), it receives data from each of them, but if several masters suddenly issue data simultaneously (phase 3, fig. 2), the circuit uses data from a higher priority master , whose interface is described below, from the second in our example. </p><br><p>  In this case, the reset of the circuit overlaps all signals (phase 5, fig. 2), and the processing is higher in priority of any of the masters, but lower than the reset (phase 4, fig. 2). </p><br><p>  Let us return to the initial example and show its final description: </p><br><pre> <code class="hljs ruby">input clk; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  input data_we; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      input [<span class="hljs-number"><span class="hljs-number">7</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>] data; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    reg [<span class="hljs-number"><span class="hljs-number">7</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>] Data; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> reg DataRdy; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   reg [<span class="hljs-number"><span class="hljs-number">7</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>] ProcessedData; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  /<span class="hljs-regexp"><span class="hljs-regexp">/--------------------------------------------------- /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/--------------------------------------------------- always @(posedge clk) begin /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ------------------------------- /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 0 if(data_we == 1'b1)/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    begin Data &lt;= data; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  DataRdy &lt;= 1'b1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    end /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  -------------------------- /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 1 if(DataRdy == 1'b1) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    begin /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ProcessedData &lt;= Data; DataRdy &lt;= 1'b0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,   end end   ‚Ññ9</span></span></code> </pre> <br><p>  It is not even necessary to check in the receiving block that the DataRdy is zero, the processing block will override the receive block by priority, and clear the DataRdy flag, even if new data is received during processing.  And changing the blocks in places, we will not miss any new data. </p><br><pre> <code class="hljs ruby">input clk; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  input data_we; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      input [<span class="hljs-number"><span class="hljs-number">7</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>] data; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    reg [<span class="hljs-number"><span class="hljs-number">7</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>] Data; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> reg DataRdy; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   reg [<span class="hljs-number"><span class="hljs-number">7</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>] ProcessedData; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  /<span class="hljs-regexp"><span class="hljs-regexp">/--------------------------------------------------- /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/--------------------------------------------------- always @(posedge clk) begin /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  -------------------------- /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 0 if(DataRdy == 1'b1) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    begin /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ProcessedData &lt;= Data; DataRdy &lt;= 1'b0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,   end /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ------------------------------- /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 1 if(data_we == 1'b1)/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    begin Data &lt;= data; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  DataRdy &lt;= 1'b1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    end end   ‚Ññ10</span></span></code> </pre> <br><p>  After data processing, the DataRdy flag is reset, but if at the same time new data comes to us, the receiving unit will override the reset priority and set the DataRdy flag again, and the data (updating) will not be lost, the data will be processed in the next cycle. </p><br><p>  What gives such an organization code? </p><br><p>  The code is divided into clear blocks, you can give lengthy comments in front of them, which makes each block.  We have the opportunity to prioritize the blocks, overlapping the assignments of one block to others, while not linking them into huge inconvenient <strong>if</strong> - <strong>else if</strong> - <strong>else if</strong> lists.  You can delete or ‚Äúcomment out‚Äù the block, insert another one between any blocks, the rest of the code will continue to work without edits. </p><br><p>  Since we have a single always, there are no conflicts of double signal sources, if at some point we decide to change the signals in different structural blocks.  We simply change the signal where and when we need it.  There is no need to organize any ‚Äúhandshakes‚Äù and ‚Äúforward‚Äù additional signals, as in the case of separate always. </p><br><p>  The code is manageable, read, change, exists according to understandable laws, you do not need to collect priority encoders and send them to the interface multiplexers, collecting all the signals on the bus and counting all the conditions of the signal change. </p><br><p>  All you need is to simply describe the behavior of the circuit, what you want from it, set priorities by the location of the description blocks and give it all to the synthesizer.  You can be sure that he will perfectly cope with the task and will produce a scheme with the desired behavior, the Xilinx synthesizer is accurate, but I think others will be in solidarity. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/321676/">https://habr.com/ru/post/321676/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321666/index.html">Why I work only remotely</a></li>
<li><a href="../321668/index.html">Versioning build artifacts in Gradle using git tag, brunch and commit names</a></li>
<li><a href="../321670/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ249 (February 6 - 12, 2017)</a></li>
<li><a href="../321672/index.html">PHP Digest number 102 - interesting news, materials and tools (February 1 - 12, 2017)</a></li>
<li><a href="../321674/index.html">How does the FIFO work</a></li>
<li><a href="../321678/index.html">Laravel 5. Hierarchical RBAC for the smallest</a></li>
<li><a href="../321682/index.html">Login to the site using Telegram</a></li>
<li><a href="../321684/index.html">Zeigarnik effect in practice</a></li>
<li><a href="../321686/index.html">Development of transactional microservices using aggregates, Event Sourcing and CQRS (Part 1)</a></li>
<li><a href="../321688/index.html">‚ÄúLike an Iceberg in the Ocean‚Äù: Data Center Cooling Technologies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>