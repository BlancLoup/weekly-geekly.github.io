<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Melange - DSL for Network Protocols</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All programmers have to transfer data sooner or later. It's no secret that Java serialization libraries exist in about> 9000, but in C ++ they seem to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Melange - DSL for Network Protocols</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="https://habrastorage.org/getpro/habr/post_images/694/788/f84/694788f8487decb436713dfcf14518da.png">  All programmers have to transfer data sooner or later.  It's no secret that Java serialization libraries exist in about&gt; 9000, but in C ++ they seem to be there, but they don't seem to exist either.  Fortunately for most, a few years ago Google Protobuf appeared, which brought quite a convenient way to define data structures and quickly won the love of the whole people.  It was actually the first library accessible to the masses, which allows you to drive ready-made data structures across the network without being associated with something like XML.  The year was 2008. <br><br>  Let's go back a bit.  In 2006, a simple Indian programmer (no matter how suspicious it sounded!) Anil Madhavapeddi, one of the most famous OCaml developers in the world now and the author of the freshly-running <a href="http://realworldocaml.org/">Real World OCaml</a> , defended <a href="http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-775.pdf">his Ph.D. thesis</a> at Cambridge.  It is about her that I will tell you today. <br><br>  Anil immediately went further than Google.  He immediately thought, why do people usually send some formalized data structures over the network?  To implement some kind of protocol.  What is a protocol?  This is some kind of <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25B2%25D1%2582%25D0%25BE%25D0%25BC%25D0%25B0%25D1%2582">state machine</a> .  And where can we take a good example of a complex, well-designed and time-tested protocol?  Yes, right in the usual network stack!  So, a set of network data structures and protocols were taken: Ethernet frame, IPv4, ICMP, TCP, UDP, SSH, DNS and DHCP and problem statement: most of these protocols (especially SSH and DNS) are implemented, what is called "hands", and there is a wish that there were no buffer overflows typical for C, all transitions were performed automatically, it could all be verified, and that it worked quickly, and not as usual. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Since no one will read a thesis, I will say straight away: it is more than possible.  Based on the results, reference implementations of DNS and SSH server were written and compared with BIND and OpenSSH.  OCaml-implementation gave compared with traditional performance gains from insignificant to almost twofold.  In addition, an error was found in the RFC at SSH (the working group was notified and the RFC was corrected).  About what has been done, and how to live with it, read under the cut. <a name="habracut"></a><br><br><h5>  MPL </h5><br>  First of all, two description languages ‚Äã‚Äãand their translators were written on OCaml.  The first language is Meta Packet Language or MPL, which describes the structure of the package.  In general, it is analogous to protobuf, but not quite.  First, MPL does not add any overhead to your structure.  At all.  No extra bits indicating the type of data or something else.  On the one hand, it does not allow, as in protobuf, to easily expand the structure by adding new fields to it, on the other - you will never read the TCP header with the protobuf.  Secondly, MPL immediately implements all the logic that is needed in network structures ‚Äî packaging or alignment, as well as such things as a variable set of fields or field values ‚Äã‚Äãdepending on other structure fields.  For an example, look at the IPv4 header: <br><pre><code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">packet</span></span> ipv4 { version: bit[<span class="hljs-number"><span class="hljs-number">4</span></span>] const(<span class="hljs-number"><span class="hljs-number">4</span></span>); ihl: bit[<span class="hljs-number"><span class="hljs-number">4</span></span>] min(<span class="hljs-number"><span class="hljs-number">5</span></span>) value(offset(options) / <span class="hljs-number"><span class="hljs-number">4</span></span>); tos_precedence: bit[<span class="hljs-number"><span class="hljs-number">3</span></span>] variant { |<span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Routine</span></span> |<span class="hljs-number"><span class="hljs-number">1</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Priority</span></span> |<span class="hljs-number"><span class="hljs-number">2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Immediate</span></span> |<span class="hljs-number"><span class="hljs-number">3</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Flash</span></span> |<span class="hljs-number"><span class="hljs-number">4</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Flash_override</span></span> |<span class="hljs-number"><span class="hljs-number">5</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ECP</span></span> |<span class="hljs-number"><span class="hljs-number">6</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Internetwork_control</span></span> |<span class="hljs-number"><span class="hljs-number">7</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Network_control</span></span> }; tos_delay: bit[<span class="hljs-number"><span class="hljs-number">1</span></span>] variant {|<span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Normal</span></span> |<span class="hljs-number"><span class="hljs-number">1</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Low</span></span>}; tos_throughput: bit[<span class="hljs-number"><span class="hljs-number">1</span></span>] variant {|<span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Normal</span></span> |<span class="hljs-number"><span class="hljs-number">1</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Low</span></span>}; tos_reliability: bit[<span class="hljs-number"><span class="hljs-number">1</span></span>] variant {|<span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Normal</span></span> |<span class="hljs-number"><span class="hljs-number">1</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Low</span></span>}; tos_reserved: bit[<span class="hljs-number"><span class="hljs-number">2</span></span>] const(<span class="hljs-number"><span class="hljs-number">0</span></span>); length: uint16 value(offset(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">)); id: uint16; reserved: bit[1] const(0); dont_fragment: bit[1] default(0); can_fragment: bit[1] default(0); frag_offset: bit[13] default(0); ttl: byte; protocol: byte variant {|1-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ICMP</span></span></span><span class="hljs-class"> |2-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IGMP</span></span></span><span class="hljs-class"> |6-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TCP</span></span></span><span class="hljs-class"> |17-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UDP</span></span></span><span class="hljs-class">}; checksum: uint16 default(0); src: uint32; dest: uint32; options: byte[(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ihl</span></span></span><span class="hljs-class"> * 4) - offset(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dest</span></span></span><span class="hljs-class">)] align(32); header_end: label; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">: byte[length-(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ihl</span></span></span><span class="hljs-class">*4)]; }</span></span></code> </pre> <br><br>  Here the contents of the packet are described as an array of data bytes (so as not to describe all other possible protocols), but in its place there could well be a record: <br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">classify</span></span> (protocol) { |<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-string"><span class="hljs-string">"ICMP"</span></span>-&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">: packet icmp(); |2: "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TCP</span></span></span><span class="hljs-class">" -&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">: packet tcp(); |3: "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UDP</span></span></span><span class="hljs-class">" -&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">: packet udp(); };</span></span></code> </pre> <br><br>  And then when reading an IPv4 package, we would immediately parse its contents.  As a result, (de) serialization of any package turns into a fascinating activity that does not require any thoughts on how to properly package the data and where to align it.  So, the almost complete implementation of the popular <a href="http://en.wikipedia.org/wiki/MessagePack">MessagePack</a> format took me about 40 lines. <br><br>  Unfortunately, this language has its drawbacks.  I counted them exactly two.  First: recursive packages are prohibited.  This just caused the impossibility of a complete implementation of the MessagePack - MPL can not be said that lists or maps can lie in a list or map, you have to describe them simply as a pack of bytes, and then parse them with another call for deserialization.  This is done on purpose so that each reading of the package is strictly finite, but this is not easier for us.  The second problem: you can not define your data types.  Anil implemented network-standard types, such as bytes, bits, numbers, strings, or even mpint, which is present in SSH, but this list is fixed.  If you suddenly want to implement the ssh-agent protocol, which uses the mpint1 type, you just have to describe it as an array of bytes and parse it in your code.  The only way to expand the list of supported types is to write MPL compiler patches, which is not a trivial task. <br><br><h5>  SPL </h5><br>  The second language was the Statecall Policy Language or SPL.  This is a language for describing finite automata, that is, the heart of our protocol.  Strictly speaking, libraries for creating finite automata for all languages ‚Äã‚Äãexist decently.  There are only a few differences from the SPL from them (apart from their own description language instead of the software assignment of the automaton).  First, the SPL compiler can immediately generate a PROMELA description for the SPIN <a href="http://ru.wikipedia.org/wiki/SPIN_%2528%25D0%25B2%25D0%25B5%25D1%2580%25D0%25B8%25D1%2584%25D0%25B8%25D0%25BA%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580%2529">software model verifier</a> .  I will be honest, I could not figure out SPIN, so in this place I had to believe the author for the word that this is cool.  Second, by using the state names <b>Receive_NAME</b> and <b>Transmit_NAME</b> (where <b>NAME</b> is the message type from the MPL), you can tightly integrate the state machine with the data structures from the MPL.  We will talk about this later, but for now let's look at an example of the description of the state machine for authorization in SSH: <br><pre> <code class="hljs pgsql">automaton auth (<span class="hljs-type"><span class="hljs-type">bool</span></span> success, <span class="hljs-type"><span class="hljs-type">bool</span></span> failed) { Receive_Transport_ServiceAccept_UserAuth; Transmit_Auth_Req_None; Receive_Auth_Failure; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { either { always_allow (Receive_Auth_Banner) { either { Transmit_Auth_Req_Password_Request; auth_decision (success); } <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> { Transmit_Auth_Req_PublicKey_Request; auth_decision (success); } <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> { Transmit_Auth_Req_PublicKey_Check; either { Receive_Auth_PublicKeyOK; } <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> { Receive_Auth_Failure; } } } } <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> { Notify_Auth_Permanent_Failure; failed = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">until</span></span> (success || failed); }</code> </pre> <br>  As you can see, the state machine in SPL allows you to write quite extensive logic, insert function calls ( <i>auth_decision</i> ) written in the same SPL, and even work with variables. <br><br><h5>  How to work with it? </h5><br>  Unfortunately, the project (the whole of it is called <a href="https://github.com/avsm/melange">Melange</a> ) is not too rich in documentation, its main source is the dissertation itself.  Therefore, I decided to write a small Proof of concept, demonstrating the work of the entire product, and at the same time being a small Quick Start guide.  To do this, write some small network application.  For the role of a simple application with a simple and clear protocol, I chose the good old game - sea battle.  This is what our message structure will look like: <br><pre> <code class="hljs erlang-repl">packet message { message_type: byte; message_id: uint16; classify (message_type) { | <span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-string"><span class="hljs-string">"Shot"</span></span> -&gt; row: bit[<span class="hljs-number"><span class="hljs-number">4</span></span>]; column: bit[<span class="hljs-number"><span class="hljs-number">4</span></span>]; | <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-string"><span class="hljs-string">"ShotResult"</span></span> -&gt; result: byte variant { |<span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; Missed |<span class="hljs-number"><span class="hljs-number">1</span></span> -&gt; Damaged |<span class="hljs-number"><span class="hljs-number">2</span></span> -&gt; Killed }; | <span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-string"><span class="hljs-string">"Disconnect"</span></span> -&gt; (); }; }</code> </pre> <br>  We have three types of messages: a shot, the result of a shot, and the information that for some reason we want to disconnect.  Now let's take a look at the proposed protocol: <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-function">automaton </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seawar</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Initialize; during { multiple(<span class="hljs-number"><span class="hljs-number">1.</span></span>.) { Ready; either { Transmit_Message_Shot; Receive_Message_ShotResult; } <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> { Receive_Message_Shot; Transmit_Message_ShotResult; } } } handle { either { Transmit_Message_Disconnect; <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> { Receive_Message_Disconnect; <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>; } } }</code> </pre> <br>  We start with the initialization (the initial state of our automaton), and then at each step, either we shoot, or at us.  It's simple.  Moreover, if for some reason a Disconnect message appears, this means that the game is over and the machine must be stopped. <br><br>  Now let's see how this is used from the code.  To read messages, we will use a special MPL buffer, which will be filled with data - in our case, we will take them from the network. <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">val</span></span> mutable env_ = <span class="hljs-type"><span class="hljs-type">Mpl_stdlib</span></span>.new_env (<span class="hljs-type"><span class="hljs-type">String</span></span>.make <span class="hljs-number"><span class="hljs-number">4</span></span> '\<span class="hljs-number"><span class="hljs-number">000</span></span>'); val mutable tick_ = <span class="hljs-type"><span class="hljs-type">Protocol</span></span>.init (); method tick state = tick_ &lt;- <span class="hljs-type"><span class="hljs-type">Protocol</span></span>.tick tick_ state; method send_message msg = ( <span class="hljs-type"><span class="hljs-type">Mpl_stdlib</span></span>.reset env_; self#tick (msg#xmit_statecall :&gt; <span class="hljs-type"><span class="hljs-type">Protocol</span></span>.s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> not (<span class="hljs-type"><span class="hljs-type">Thread</span></span>.wait_timed_write sock_ <span class="hljs-number"><span class="hljs-number">10.</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self#disconnect ~exc_text:<span class="hljs-string"><span class="hljs-string">"Timeout"</span></span>; <span class="hljs-type"><span class="hljs-type">Mpl_stdlib</span></span>.flush env_ sock_ ); method receive_message = ( <span class="hljs-type"><span class="hljs-type">Mpl_stdlib</span></span>.reset env_; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> not (<span class="hljs-type"><span class="hljs-type">Thread</span></span>.wait_timed_read sock_ <span class="hljs-number"><span class="hljs-number">300.</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self#disconnect ~exc_text:<span class="hljs-string"><span class="hljs-string">"Timeout"</span></span>; <span class="hljs-type"><span class="hljs-type">Mpl_stdlib</span></span>.fill env_ sock_; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> msg = <span class="hljs-type"><span class="hljs-type">Message</span></span>.unmarshal env_ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = <span class="hljs-type"><span class="hljs-type">Message</span></span>.recv_statecall msg <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self#tick state; msg );</code> </pre> <br>  Please note that each message, both sent and received, necessarily causes the state machine to transition to a new state.  The calls <em>msg # xmit_statecall</em> and <em>Message.recv_statecall msg</em> are responsible for this, which, based on messages (such as ShotResult), create the names of the corresponding states ( <b>Transmit_Message_ShotResult</b> and <b>Receive_Message_ShotResult</b> ).  Due to this, most of the potential errors of the program will be detected here, when the wrong transition of the machine will cause the exception Bad_statecall.  For example, if in the case of AI everything is simple - it works in one stream, completely synchronous and there can never be any problems in such a simple task, then in the graphical interface everything can be more complicated. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/694/065/187/694065187f651f624f0f9255d5b0622e.png"><br>  For example, a simple example of how everything can easily "explode."  For the graphical interface, I took the freshly released Qt 5.2 framework, for which our compatriot Dmitry Kosarev wrote <a href="https://github.com/Kakadu/lablqt/tree/qml-dev">OCaml bindings</a> (interesting enough, if there are any, I‚Äôll tell you in a separate post).  When clicking on the cell of the enemy field in a separate thread, the following code can be executed: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> send_shot col row = ignore(game#send_message (<span class="hljs-type"><span class="hljs-type">Message</span></span>.<span class="hljs-type"><span class="hljs-type">Shot</span></span>.t ~row:row ~column:col)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result, state = game#receive_message <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (match result with | `<span class="hljs-type"><span class="hljs-type">ShotResult</span></span> x -&gt; <span class="hljs-type"><span class="hljs-type">Board</span></span>.mark opp_board row col x#result; next_turn state x#result | `<span class="hljs-type"><span class="hljs-type">Disconnect</span></span> x -&gt; game#disconnect ~send:false | _ -&gt; game#disconnect ~exc_text:<span class="hljs-string"><span class="hljs-string">"Unexpected_Message_Type"</span></span> ~raise_exc:true ~send:true)</code> </pre> <br>  If a double shot is not prevented, this method will be called twice - in this case, either two messages with a shot in a row can be sent, or the second message can be sent after receiving a message about a miss. <br><br>  In order not to overload the article with a full review of the code, I‚Äôd rather give a link to the <a href="https://github.com/torkve/melange-seawar">source code</a> that anyone can download and watch. <br><br><h5>  Conclusion </h5><br>  What's next, the reader will ask me.  Well, some marginal, already 4 years unresolved tool, working in an incomprehensible language.  Why do I need all this if I have Node.js, MongoDB and strawberry smoothies? <br><br>  The reader is right.  The tool is outdated, it has several significant flaws that I mentioned.  But at the same time he shows in which direction it is necessary to develop.  So, all application code, including all declarative descriptions, a graphical interface and not the dumbest AI, is 850 lines.  This is certainly not "30 lines of javascript", but also not too much. <br><br>  Almost 8 years ago, it was shown exactly how the networking should take place, and almost 6 years ago, Google popularized only half of it.  There is no roktsaysaensa in the idea, it is true, and separately all the components have long been written.  You,% USERNAME%, have a great opportunity to realize this idea in the coming New Year, to become world famous and enslave the world.  Well, or something like that. </div><p>Source: <a href="https://habr.com/ru/post/207764/">https://habr.com/ru/post/207764/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../207754/index.html">Microsoft's long arithmetic</a></li>
<li><a href="../207756/index.html">Elections OS</a></li>
<li><a href="../207758/index.html">NSA does not cope with traffic volumes</a></li>
<li><a href="../207760/index.html">How freshman Cauchy's definition has reduced</a></li>
<li><a href="../207762/index.html">January 2, 2014 the Blender project will be 20 years old</a></li>
<li><a href="../207768/index.html">Convenient work in the console, or paint STDERR red</a></li>
<li><a href="../207774/index.html">Hacked openssl.org</a></li>
<li><a href="../207776/index.html">Best PHP frameworks 2013</a></li>
<li><a href="../207778/index.html">Asynchronous JavaScript (book)</a></li>
<li><a href="../207780/index.html">The Mail.Ru Cloud License Agreement changed</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>