<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Top10 mistakes made when developing on AngularJS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Currently AngularJS is one of the most popular javascript frameworks. Its use simplifies the development process, making AngularJS a great tool for cr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Top10 mistakes made when developing on AngularJS</h1><div class="post__text post__text-html js-mediator-article">  Currently AngularJS is one of the most popular javascript frameworks.  Its use simplifies the development process, making AngularJS a great tool for creating small web applications, but the framework's capabilities are not limited to this and allow you to develop large applications filled with various functions.  The combination of ease of development and a large number of possibilities led to a wide spreading, and along with the spread there were typical, often encountered errors.  This topic describes the most common errors encountered when developing large projects on AngularJS. <a name="habracut"></a><h3>  1. Folder structure corresponding to MVC applications </h3>  AngularJS is a MVC framework.  Despite the fact that the models in it are not as clearly defined as in the case of backbone.js, the overall architectural style remains the same.  A common practice when using MVC frameworks is to group files according to the following pattern: <pre><code class="javascript hljs">templates/ _login.html _feed.html app/ app.js controllers/ LoginController.js FeedController.js directives/ FeedEntryDirective.js services/ LoginService.js FeedService.js filters/ CapatalizeFilter.js</code> </pre>  This approach is common, especially among developers who have experience in RoR development.  However, as the application grows, using a similar folder structure results in having to keep several folders open at any given time.  Whatever you use - Sublime, Visual Studio or Vim with NerdTree - you will constantly spend time scrolling through the directory tree.  To avoid this, you can group files by functionality, rather than by type: <pre> <code class="javascript hljs">app/ app.js Feed/ _feed.html FeedController.js FeedEntryDirective.js FeedService.js Login/ _login.html LoginController.js LoginService.js Shared/ CapatalizeFilter.js</code> </pre>  This folder structure makes it much easier to search for related files belonging to the same feature, which can speed up the development process.  Yes, it may seem controversial - to store in the same folder html files with js, but the effect of saving time may be more important. <h3>  2. Modules (or lack thereof) </h3>  Often, at the beginning of the project development all the functionality is added to a single module.  Until a certain moment, this approach works, but as the project progresses, the code becomes unmanageable. <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> app = angular.module(<span class="hljs-string"><span class="hljs-string">'app'</span></span>,[]); app.service(<span class="hljs-string"><span class="hljs-string">'MyService'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//service code }); app.controller('MyCtrl', function($scope, MyService){ //controller code });</span></span></code> </pre>  The next most common approach is to group objects by their type: <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> services = angular.module(<span class="hljs-string"><span class="hljs-string">'services'</span></span>,[]); services.service(<span class="hljs-string"><span class="hljs-string">'MyService'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//service code }); var controllers = angular.module('controllers',['services']); controllers.controller('MyCtrl', function($scope, MyService){ //controller code }); var app = angular.module('app',['controllers', 'services']);</span></span></code> </pre>  This approach does not scale well either, like the directory structure of clause 1. In order to achieve better scalability, we follow the same concept of breaking the code into features: <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sharedServicesModule = angular.module(<span class="hljs-string"><span class="hljs-string">'sharedServices'</span></span>,[]); sharedServices.service(<span class="hljs-string"><span class="hljs-string">'NetworkService'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$http</span></span></span><span class="hljs-function">)</span></span>{}); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loginModule = angular.module(<span class="hljs-string"><span class="hljs-string">'login'</span></span>,[<span class="hljs-string"><span class="hljs-string">'sharedServices'</span></span>]); loginModule.service(<span class="hljs-string"><span class="hljs-string">'loginService'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NetworkService</span></span></span><span class="hljs-function">)</span></span>{}); loginModule.controller(<span class="hljs-string"><span class="hljs-string">'loginCtrl'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$scope, loginService</span></span></span><span class="hljs-function">)</span></span>{}); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> app = angular.module(<span class="hljs-string"><span class="hljs-string">'app'</span></span>, [<span class="hljs-string"><span class="hljs-string">'sharedServices'</span></span>, <span class="hljs-string"><span class="hljs-string">'login'</span></span>]);</code> </pre>  Spreading functionality across modules also allows code reuse across projects. <h3>  3. Introduction of dependencies </h3>  Dependency injection (dependency injection) is one of the best features provided by AngularJS.  DI facilitates the testing process and makes the code cleaner.  AngularJS is very flexible in how dependencies can be implemented.  The easiest way is to pass the dependency to a function as a parameter: <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> app = angular.module(<span class="hljs-string"><span class="hljs-string">'app'</span></span>,[]); app.controller(<span class="hljs-string"><span class="hljs-string">'MainCtrl'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$scope, $timeout</span></span></span><span class="hljs-function">)</span></span>{ $timeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log($scope); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); });</code> </pre>  From the code it is clear that MainCtrl depends on $ scope and $ timeout.  This works great until the project goes into production and you want to minimize your code.  Using UglifyJS to the above code will result in the following: <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> app=angular.module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>,[]);app.controller(<span class="hljs-string"><span class="hljs-string">"MainCtrl"</span></span>,<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e,t</span></span></span><span class="hljs-function">)</span></span>{t(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(e)},<span class="hljs-number"><span class="hljs-number">1e3</span></span>)})</code> </pre>  Now AngularJS doesn‚Äôt know what MainCtrl really depends on.  To prevent this from happening, there is a very simple solution - transfer dependencies as an array of strings, with the last element as a function that accepts all the dependencies listed as parameters: <pre> <code class="javascript hljs">app.controller(<span class="hljs-string"><span class="hljs-string">'MainCtrl'</span></span>, [<span class="hljs-string"><span class="hljs-string">'$scope'</span></span>, <span class="hljs-string"><span class="hljs-string">'$timeout'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$scope, $timeout</span></span></span><span class="hljs-function">)</span></span>{ $timeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log($scope); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); }]);</code> </pre>  The code above will be converted by minifiers into code that AngularJS can already correctly interpret: <pre> <code class="javascript hljs">app.controller(<span class="hljs-string"><span class="hljs-string">"MainCtrl"</span></span>,[<span class="hljs-string"><span class="hljs-string">"$scope"</span></span>,<span class="hljs-string"><span class="hljs-string">"$timeout"</span></span>,<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e,t</span></span></span><span class="hljs-function">)</span></span>{t(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(e)},<span class="hljs-number"><span class="hljs-number">1e3</span></span>)}])</code> </pre><h3>  3.1.  Global dependencies </h3>  Often, when developing an AngularJS application, it becomes necessary to use objects that are available anywhere in the application.  This breaks a coherent model based on dependency injection and leads to bugs and complicates the testing process.  AngularJS allows you to wrap similar objects in modules so that they can be embedded like ordinary AngularJS modules.  For example, the magnificent Underscore.js library can be wrapped in a module as follows: <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> underscore = angular.module(<span class="hljs-string"><span class="hljs-string">'underscore'</span></span>, []); underscore.factory(<span class="hljs-string"><span class="hljs-string">'_'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>._; <span class="hljs-comment"><span class="hljs-comment">//Underscore must already be loaded on the page }); var app = angular.module('app', ['underscore']); app.controller('MainCtrl', ['$scope', '_', function($scope, _) { init = function() { _.keys($scope); } init(); }]);</span></span></code> </pre>  This allows the application to use a single style with mandatory dependency injection and leaves the opportunity to test modules in isolation from the functionality of their dependencies. <h3>  4. Inflating controllers </h3>  Controllers are the backbone of AngularJS.  And often, especially beginners, they write too much logic in the controllers.  Controllers should not manipulate the DOM or contain DOM selectors, for this there are directives.  Similarly, business logic should be in services.  Data should also be stored in services (except when data is tied to $ scope), because services, unlike controllers, are singletons, whose lifetime coincides with the lifetime of the application itself. When developing controllers, it is best to follow the sole responsibility principle (SRP) and consider the controller as the coordinator between the representation and the model, in which case the logic in it will be minimum. <h3>  5. Service vs Factory </h3>  These naming confuses every newcomer to AngularJS, although in reality they are almost the same. Let's look at the source code of AngularJS: <pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, factoryFn</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> provider(name, { <span class="hljs-attr"><span class="hljs-attr">$get</span></span>: factoryFn }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">service</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, constructor</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> factory(name, [<span class="hljs-string"><span class="hljs-string">'$injector'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$injector</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $injector.instantiate(<span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>); }]); }</code> </pre>  The service function simply calls the factory function, which wraps the call to the provider function.  If service simply calls the factory function, what is the difference between them?  The meaning is in $ injector.instantiate, within which $ injector creates a new instance of the service constructor function.  An example of a service and a factory performing the same actions: <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> app = angular.module(<span class="hljs-string"><span class="hljs-string">'app'</span></span>,[]); app.service(<span class="hljs-string"><span class="hljs-string">'helloWorldService'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.hello = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello World"</span></span>; }; }); app.factory(<span class="hljs-string"><span class="hljs-string">'helloWorldFactory'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">hello</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello World"</span></span>; } } });</code> </pre>  The moment helloWorldService or helloWorldFactory is injected into the controller, both of them will have a single method that returns ‚ÄúHello World‚Äù.  Since all providers are singletons, we will always have only one instance of the service and one instance of the factory.  So why are there both factories and services at the same time, if they perform the same function?  Factories offer more flexibility because they can return a function that can create new objects.  In OOP, a factory is an object that creates other objects: <pre> <code class="javascript hljs">app.factory(<span class="hljs-string"><span class="hljs-string">'helloFactory'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.hello = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; }; }; });</code> </pre>  Here is an example of a controller using a service and two factories: <pre> <code class="javascript hljs">app.controller(<span class="hljs-string"><span class="hljs-string">'helloCtrl'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$scope, helloWorldService, helloWorldFactory, helloFactory</span></span></span><span class="hljs-function">) </span></span>{ init = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ helloWorldService.hello(); <span class="hljs-comment"><span class="hljs-comment">//'Hello World' helloWorldFactory.hello(); //'Hello World' new helloFactory('Readers').hello() //'Hello Readers' } init(); });</span></span></code> </pre>  Factories can also be useful when developing classes with private methods: <pre> <code class="javascript hljs">app.factory(<span class="hljs-string"><span class="hljs-string">'privateFactory'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> privateFunc = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name.split(<span class="hljs-string"><span class="hljs-string">""</span></span>).reverse().join(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-comment"><span class="hljs-comment">//reverses the name }; return { hello: function(name){ return "Hello " + privateFunc(name); } }; });</span></span></code> </pre><h3>  6. Non-use of Batarang </h3>  Batarang is a Chrome browser extension for developing and debugging AngularJS applications.  Batarang allows you to: <ul><li>  view models attached to scopes </li><li>  build dependency graph in application </li><li>  analyze application performance </li></ul>  Despite the fact that the performance of AngularJS is not bad out of the box, with the growth of the application, with the addition of custom directives and complex logic, the application can begin to slow down.  Using Batarang it is easy to figure out which of the functions is spending a lot of time when calling.  Batarang also displays a watch tree, which can be useful when using a large number of watchers. <h3>  7. Too many observers </h3>  As noted above, AngularJS is quite productive out of the box.  But, when the number of observers reaches the number 2000, the $ digest cycle, in which the data changes are checked, may begin to slow down the operation of the application.  Although reaching a number of 2000 does not guarantee a slowdown, this is a good starting point from which you can begin to worry.  Using the following code, you can find out the number of observers per page: <pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> root = $(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByTagName(<span class="hljs-string"><span class="hljs-string">'body'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> watchers = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element.data().hasOwnProperty(<span class="hljs-string"><span class="hljs-string">'$scope'</span></span>)) { angular.forEach(element.data().$scope.$$watchers, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">watcher</span></span></span><span class="hljs-function">) </span></span>{ watchers.push(watcher); }); } angular.forEach(element.children(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">childElement</span></span></span><span class="hljs-function">) </span></span>{ f($(childElement)); }); }; f(root); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(watchers.length); })();</code> </pre>  Using the code above and the observer tree of the battery, you can see if you have duplicate observers or observers on immutable data.  In the case of immutable data, you can use the bindonce directive so as not to increase the number of observers per page. <h3>  8. Scopes inheritance ($ scope's) </h3>  Prototype-based JS inheritance is different from classical class inheritance.  This is usually not a problem, but these nuances can manifest themselves when working with scopes.  In AngularJS, the normal (not isolated) $ scope is inherited from the parent to the most senior ancestor of $ rootScope.  The shared data model, shared by the parent with the child, is organized easily due to inheritance on prototypes.  In the following example, we want the user name to be displayed simultaneously in two span elements after the user enters his name. <pre> <code class="javascript hljs">&lt;div ng-controller=<span class="hljs-string"><span class="hljs-string">"navCtrl"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{{user}}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;div ng-controller=<span class="hljs-string"><span class="hljs-string">"loginCtrl"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{{user}}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;input ng-model=<span class="hljs-string"><span class="hljs-string">"user"</span></span>&gt;<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">input</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/div&gt; &lt;/</span></span>div&gt;</code> </pre>  Now the question is: when the user enters his name in the text field, in which elements it will be displayed: navCtrl, loginCtrl, or both?  If your answer is loginCtrl, you understand how prototype-based inheritance works.  In the search for string fields, a chain of prototypes is not used.  To achieve the desired behavior, we want to use the object to correctly update the user name in the child and parent $ scope.  (Remember, in JS, functions and arrays are also objects.) <pre> <code class="javascript hljs">&lt;div ng-controller=<span class="hljs-string"><span class="hljs-string">"navCtrl"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{{user.name}}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;div ng-controller=<span class="hljs-string"><span class="hljs-string">"loginCtrl"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{{user.name}}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;input ng-model=<span class="hljs-string"><span class="hljs-string">"user.name"</span></span>&gt;<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">input</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/div&gt; &lt;/</span></span>div&gt;</code> </pre>  Now, since the user variable is an object, the prototype chain will work and the span element in navCtrl will be updated correctly along with loginCtrl.  This may look like an unnatural example, but when working with directives that create child scopes (like ngRepeat), such moments will arise. <h3>  9. Using manual testing </h3>  Until you start using TDD in your work, you will have to run the project every time and do manual testing to make sure your code works.  There is no excuse for using this approach in the case of AngularJS.  AngularJS was initially corrected so that the code developed on it was testable.  DI, ngMock - your best helpers in this.  There are also several tools that can take you to the next level. <h3>  9.1 Protractor </h3>  Unit tests are the basis for building a fully test-covered application, but as the project grows, using integration tests can be more effective for testing how viable the code is in the application.  Fortunately, the AngularJS team has developed a great tool - Protractor, which is able to simulate user interaction.  Protractor uses the Jasmine framework to write tests and has a good API for describing various interaction scenarios.  Among the many different testing tools, Protractor has an advantage in understanding the internal structure of AngularJS, which is especially useful when you are dealing with something like $ digest cycles. <h3>  9.2.  Karma </h3>  The AngularJS project team didn‚Äôt limit to writing test development tools.  A Karma test runner was also developed.  Karma allows you to perform tests every time you change files with source code.  Karma is able to perform tests in parallel in several browsers.  Various devices can also be targeted to a karma server to more fully cover real-world use cases. <h3>  10. Using jQuery </h3>  jQuery is a great library.  It standardized cross-platform development and became a standard in modern web development.  Despite the fact that jQuery has a large number of features, its philosophy is far from AngularJS.  AngularJS is a framework for building applications, while jQuery is just a library that simplifies the interaction between JavaScript and HTML and provides a convenient API for working with AJAX.  This is the fundamental difference between them.  Angulyar is an approach to building applications, and not a way to control the layout of a document.  To really understand the principles of building AngularJS applications, you should stop using jQuery.  jQuery forces you to conform to an existing HTML standard, while Angular allows you to extend the HTML standard to the needs of your application.  Manipulations with DOM in AngularJS should be made in directives, but it is quite possible to place wrappers in existing directives over existing jQuery components, if you could not find an analogue on angular. <h3>  Conclusion </h3>  AngularJS is a great, constantly evolving framework with a great community.  I hope my list of popular errors will come in handy in your work. </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/253103/">https://habr.com/ru/post/253103/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../253093/index.html">Aaron Levy: Developing B2B Products</a></li>
<li><a href="../253095/index.html">Lectures Technopark. 1 semester C / C ++</a></li>
<li><a href="../253097/index.html">AMI UEFI firmware features</a></li>
<li><a href="../253099/index.html">The digest of interesting materials for mobile developer # 94 (March 10-15)</a></li>
<li><a href="../253101/index.html">Translation of the book "Expressive Javascript" in pdf</a></li>
<li><a href="../253105/index.html">Age of JIT compiling. Part II. CLR is watching you</a></li>
<li><a href="../253107/index.html">Yboard - Yii bulletin board engine</a></li>
<li><a href="../253111/index.html">Create effective styles for carousels</a></li>
<li><a href="../253115/index.html">Review of the most interesting materials on data analysis and machine learning ‚Ññ39 (March 9 - 15, 2015)</a></li>
<li><a href="../253119/index.html">Random and phantom domains (random subdomain, phantom domain), DDoS attack on caching DNS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>