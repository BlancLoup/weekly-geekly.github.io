<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What is so difficult about handling C ++ exceptions?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Exceptions and the associated stack promotion is one of the most enjoyable techniques in C ++. Exception handling is intuitively consistent with the b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What is so difficult about handling C ++ exceptions?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/f08/39d/b9c/f0839db9cde83de4a4d9133f18203c85.jpg" alt="image"><br>  Exceptions and the associated stack promotion is one of the most enjoyable techniques in C ++.  Exception handling is intuitively consistent with the block structure of the program.  Externally, exception handling seems very logical and natural. <br><br>  Careful use of stack objects allows you to create very efficient and safe code, where, unlike systems with garbage collection, reference locality is preserved, which makes it possible to reduce the number of calls to the system behind the memory, reduce its fragmentation, more efficiently use the cache memory. <br><br>  However, in C ++, exceptions are traditionally considered literally as exceptions to error recovery.  It is difficult to say whether this is a cause or a consequence of the fact that the implementation of exception handling by compilers is extremely expensive.  Let's try to figure out why. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Continued <a href="http://habrahabr.ru/post/267771/">here</a> . <br>  <b>How are things.</b> <br><br>  There are two approaches to implementing exception handling: <br><ul><li>  The first can be characterized by the words - ‚Äúlet the loser pay‚Äù.  The compiler tries to minimize costs in cases where exceptions do not occur.  Ideally, the program does not bear any additional load, all the necessary information is located aside from the code in a form suitable for promotion. </li><li>  The second strategy is ‚Äúgradually pay everything and always.‚Äù In other words, the program incurs certain costs in the process of maintaining the relevance of the information necessary for the correct promotion of the stack. In this case, in case of an exception, promotion of the stack is cheaper. </li></ul><br>  A few examples: <br><ul><li>  <b>GCC / SJLJ</b> .  SJLJ is short for setjmp / longjmp.  It refers rather to the first approach, but thanks to the control transfer scheme, it also has a fixed fee for each <i>try</i> .  In essence, this implementation has absorbed the worst that is inherent in both approaches.  Up until the fourth version, this was the main exception handling option. <br>  As the name implies, control is transferred via a call to longjmp, each try generates a call to setjmp.  The corresponding buffer is allocated in the stack for each try block. <br>  At the beginning of each function, a prolog is created that registers the current frame in the context stack.  Similarly, an epilogue is created that removes the current context from the top of the context stack.  Next to each function, an auxiliary code is created to clear the resources. <br>  More precisely, the compiler each return from a function, potentially capable of completing an exception, enters the tree as a key, the value is a pointer to the cleanup code that must be taken at this point to clear the function context.  The linker assembles the pieces of these trees for each link module into a single project tree (very roughly).  This miracle is called LSDA (language specific data area) and it is located in the ".gcc_except_table" section. <br>  When an exception occurs, based on the type_info of the exception being thrown, a block is searched for that can handle the exception.  Starting from the current context and up to the handler context (using navigation through call frames), the addresses of the code that (depending on the scope of local variables) must be executed in this place are retrieved and executed.  Then control is transferred. <br><br>  There is a prejudice that this method is very expensive.  Already due to the fact that for each try-block setjmp is called, which is not cheap.  In fact, you need to fully save the state of the processor, where there may be dozens of registers.  Whereas at the time of the exception, the contents of most of these registers are already useless.  In fact, the compiler does quite rationally.  He deploys setjmp, and saves only useful registers (he already has this information).  The author doubts that the cost of setjmp is so high. <br><br>  But what really catches your eye is a voluminous auxiliary code, especially in non-trivial cases.  The compiler, like YACC, lists all the states of the stack automaton.  And, though, the optimizer of opportunities cleans redundancy and the trivial code, what remains is more than enough. <br></li><li>  <b>GCC / DW2</b> .  This is just an example of the first approach to exception handling.  DW2 means DWARF2 (now already 3) - the storage format of auxiliary, including debugging information in the executable file.  After all, debugging information is also needed so that at any time you can find out the value of any variable, including in the frames of the previous (upper) calls.  Therefore, the compiler in the process of generating code postpones information about what it allocates in the stack, in which registers it allocates variables when it stores them ... In fact, this format is not identical to DWARF, although it is very close to it.  Standard version for the fourth version of GCC. <br><br>  Conceptually, at each address of the program code information is stored on how to get into the higher-level call frame.  In practice, due to the bulk of this information, it is compressed, in fact, calculated using the interpretation of the byte code.  This bytecode is executed when an exception occurs.  All this is located in the sections ".eh_frame" and ".eh_frame_hdr". <br>  Yes, among other things, the DWARF interpreter is a great backdoor, with which, by changing the byte code, you can catch the exception and send it for processing to your heart‚Äôs content. <br>  GCC / DW2 uses almost the same LSDA section as GCC / SJLJ. <br><br>  As we see, the costs associated with the promotion of the stack (in the absence of exceptions) are practically absent.  However, the cost of initiating an exception is high.  In addition, it is impossible not to note the strong integration of the architecture-dependent part of the compiler and its rather high-level layers. <br></li><li>  <b>MS VC ++</b> .  This compiler implements a second processing strategy. <br><ul><li>  For each function that can potentially throw exceptions, the compiler creates as a stack variable a structure from a pointer to the previous similar structure, addresses of the handler function and auxiliary data.  The address of this structure is entered in FS: [0], which is the top of the stack of these structures.  The FS register in Win32 is used as the Thread Information Block ( <a href="http://en.wikipedia.org/wiki/Win32_Thread_Information_Block">TIB</a> ) (GS in Win64).  A handler function is also created (with its own data set) and an epilogue that restores FS: [0] in the event of a successful completion. </li><li>  The compiler creates a table of structures ‚Äî an element for each try block in a function.  Each try block has an index of the beginning and end in this table (the nested block has a nested interval) corresponding to a certain state, the compiler itself keeps track of the relevance of this index.  In this way, the compiler implements a stack of try-blocks. </li><li>  A catch-table table is created for each try-block.  For each type of exception, the type_info table of all base classes in the hierarchy of this type of exception is created. </li><li>  For each function, an unwind table is created, each element of which contains a pointer to the function, which releases some resource and the number of the previous element.  There can be several chains in the table, depending on the scopes of objects with destructors.  At the time of the exception, by the index of the current state, which was mentioned above, you can find the necessary chain and call all the necessary destructors. </li><li>  For the x64 version, the auxiliary stack structures were transferred to .pdata whenever possible, probably in MS they consider the first strategy more promising. </li><li>  When an exception is triggered, the main work is carried out by the operating system, where control falls through SYSENTER. </li></ul>  This method has the same drawbacks as SJLJ - extensive auxiliary code and low portability. </li><li>  The process of raising an exception and selecting the appropriate <i>catch</i> block looks about the same everywhere: <br><ul><li>  When an exception is raised, its handle is created, which contains a copy of the object, its type_info, a pointer to the destructor </li><li>  Going up the stack of <i>try</i> blocks and clearing all registered stack objects, (navigating this stack is different everywhere, but the essence is the same), look through the lists of <i>catch</i> blocks and look for suitable ones. </li><li>  If a suitable <i>catch</i> block is found, the exception object becomes a local variable, and we call this block.  If the <i>catch</i> block accepts an exception by value, not by reference, a copy is created. </li><li>  If there was no exception call, we kill the object - the exception </li><li>  "Mistress on the note": <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">some_exception </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"oioi"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> exc;</code> </pre>  spawns an extra copy / destructor constructor <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> some_exception(<span class="hljs-string"><span class="hljs-string">"oioi"</span></span>);</code> </pre>  leaks memory <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(some_exception exc) ...</code> </pre>  again an extra call to the constructor and destructor <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> some_exception *exc) ...</code> </pre>  the exception will fly by, if you do not throw a pointer <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> some_exception(<span class="hljs-string"><span class="hljs-string">"oioi"</span></span>); ... <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> some_exception &amp;exc)....</code> </pre>  low cost <br></li></ul></li></ul>  Details can be found <a href="http://www.hexblog.com/wp-content/uploads/2012/06/Recon-2012-Skochinsky-Compiler-Internals.pdf">here</a> , <a href="http://www.slideshare.net/hackitoergosum/hes2011-james-oakley-and-sergey-bratusexploitingthehardworkingdwarf">here</a> and <a href="http://www.codeproject.com/Articles/2126/How-a-C-compiler-implements-exception-handling">here</a> . <br><br>  <b>What if ...</b> <br>  And, it would seem, all that matters is to call in the right order destructors whose bodies already exist.  How did it happen that a simple, in general, problem has such viscous, heavy and, moreover, independently developed solutions?  It is difficult to say, it happened so historically. <br>  Let's try to sketch a solution, trying to keep it simple and, whenever possible, architecturally independent. <br><ul><li>  First of all, we choose a strategy - this will be the second option. </li><li>  Transfer control - setjmp / longjmp </li><li>  We create a structure, all descendants of which have the ability to self-register for possible promotion. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unw_item_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unw_item_t</span></span> (); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~<span class="hljs-keyword"><span class="hljs-keyword">unw_item_t</span></span> (); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unreg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unw_item_t</span></span> *prev_; };</code> </pre></li><li>  And another one whose scope is the try block <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jmp_buf_splice</span></span></span><span class="hljs-class"> {</span></span> jmp_buf_splice (); ~jmp_buf_splice (); jmp_buf buf_; jmp_buf_splice *prev_; <span class="hljs-keyword"><span class="hljs-keyword">unw_item_t</span></span> objs_; };</code> </pre></li><li>  For simplicity, we will only throw const char * exceptions using <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throw_slice</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str)</span></span></span></span>;</code> </pre></li><li>  Several macros to simulate a try block <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   #define TRY_BLOCK { \ jmp_buf_splice __sl; \ const char *__exc = (const char *)setjmp (__sl.buf_); \ if (NULL == __exc) { ... // -  catch(‚Ä¶) ..    const char* #define CATCH_BLOCK_FIN \ } else { ... //   #define FIN_BLOCK \ } \ } ... //   #define THROW_IN_BLOCK(exc) \ throw_slice (exc); ... //   , __exc   TRY_BLOCK #define RETHROW_IN_BLOCK \ throw_slice (__exc);</span></span></code> </pre></li><li>  Now we will show the bodies of the jmp_buf_splice class members: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> jmp_buf_splice *root_slice_ = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; jmp_buf_splice::jmp_buf_splice () { objs_ = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; prev_ = root_slice_; root_slice_ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } jmp_buf_splice::~jmp_buf_splice () { root_slice_ = prev_; }</code> </pre>  Here is an option for single-threaded implementation.  If there are multiple threads, instead of root_slice_, we will need to use TLS, similarly to how GCC does, for example. </li><li>  It's time for members of the unw_item_t class: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unw_item_t</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">unw_item_t</span></span> () { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> != root_slice_) { prev_ = root_slice_-&gt;objs_; root_slice_-&gt;objs_ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">unw_item_t</span></span>::~<span class="hljs-keyword"><span class="hljs-keyword">unw_item_t</span></span> () { unreg(); } <span class="hljs-keyword"><span class="hljs-keyword">unw_item_t</span></span>::unreg () { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> != root_slice_ &amp;&amp; (prev_ != <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unw_item_t</span></span> *&gt;(~<span class="hljs-number"><span class="hljs-number">0</span></span>))) { root_slice_-&gt;objs_ = prev_; prev_ = <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unw_item_t</span></span> *&gt;(~<span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre></li><li>  Now consider the process of exclusion exception and promotion of the stack: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop_slice</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ jmp_buf_splice *sl = root_slice_; assert (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> != sl); root_slice_ = sl-&gt;prev_; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throw_slice</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> popstate)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> == str) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; jmp_buf_splice *sl = root_slice_; <span class="hljs-keyword"><span class="hljs-keyword">unw_item_t</span></span> *obj = root_slice_-&gt;objs_; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> != obj) { <span class="hljs-keyword"><span class="hljs-keyword">unw_item_t</span></span> *tmp = obj; obj = obj-&gt;prev_; tmp-&gt;~<span class="hljs-keyword"><span class="hljs-keyword">unw_item_t</span></span> (); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (popstate) pop_slice (); longjmp (sl-&gt;buf_, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(str)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre></li><li><div class="spoiler">  <b class="spoiler_title">Service class - analog std :: auto_ptr:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> cl&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">deleter_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unw_item_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">deleter_t</span></span> (cl *obj){ptr_ = obj;}; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~<span class="hljs-keyword"><span class="hljs-keyword">deleter_t</span></span> () {<span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ptr_;}; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: cl *ptr_; <span class="hljs-keyword"><span class="hljs-keyword">deleter_t</span></span> (); <span class="hljs-keyword"><span class="hljs-keyword">deleter_t</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">deleter_t</span></span> &amp;); <span class="hljs-keyword"><span class="hljs-keyword">deleter_t</span></span> &amp;<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>= (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">deleter_t</span></span> &amp;); };</code> </pre></div></div></li><li><div class="spoiler">  <b class="spoiler_title">Service class - array:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> cl&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vec_deleter_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unw_item_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">vec_deleter_t</span></span> (cl *obj){ptr_ = obj;}; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~ <span class="hljs-keyword"><span class="hljs-keyword">vec_deleter_t</span></span> () {<span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> [] ptr_;}; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: cl *ptr_; <span class="hljs-keyword"><span class="hljs-keyword">vec_deleter_t</span></span> (); <span class="hljs-keyword"><span class="hljs-keyword">vec_deleter_t</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">vec_deleter_t</span></span> &amp;); <span class="hljs-keyword"><span class="hljs-keyword">vec_deleter_t</span></span> &amp;<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>= (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">vec_deleter_t</span></span> &amp;); };</code> </pre></div></div></li><li>  Examples <div class="spoiler">  <b class="spoiler_title">Test class</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: _A():val_(++cnt_){<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"A::A(%d)\n"</span></span>,val_);} _A(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i):val_(i){<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"A::A(%d)\n"</span></span>,val_);} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~_A(){<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"A::~A(%d)\n"</span></span>,val_);} <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cnt_; }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _A::cnt_ = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unw_item_t</span></span>, _A {};</code> </pre> </div></div></li><li><div class="spoiler">  <b class="spoiler_title">Example 1</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">A </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; TRY_BLOCK { <span class="hljs-function"><span class="hljs-function">A </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">b</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; THROW_IN_BLOCK(<span class="hljs-string"><span class="hljs-string">"error\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"notreached\n"</span></span>; } CATCH_BLOCK_FIN { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; __exc; } FIN_BLOCK;</code> </pre> <br>  A :: A (1) <br>  A :: A (2) <br>  A :: ~ A (2) <br>  error <br>  A :: ~ A (1) <br></div></div></li><li><div class="spoiler">  <b class="spoiler_title">Example 2</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">A </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; TRY_BLOCK { <span class="hljs-function"><span class="hljs-function">A </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">b</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; TRY_BLOCK { <span class="hljs-function"><span class="hljs-function">A </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; THROW_IN_BLOCK(<span class="hljs-string"><span class="hljs-string">"error\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"notreached\n"</span></span>; } CATCH_BLOCK_FIN { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"."</span></span> &lt;&lt; __exc; RETHROW_IN_BLOCK; } FIN_BLOCK; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"notreached\n"</span></span>; } CATCH_BLOCK_FIN { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">".."</span></span> &lt;&lt; __exc; } FIN_BLOCK;</code> </pre><br>  A :: A (1) <br>  A :: A (2) <br>  A :: A (3) <br>  A :: ~ A (3) <br>  .error <br>  A :: ~ A (2) <br>  ..error <br>  A :: ~ A (1) <br></div></div></li><li><div class="spoiler">  <b class="spoiler_title">Example 3</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> TRY_BLOCK { <span class="hljs-keyword"><span class="hljs-keyword">vec_deleter_t</span></span>&lt;_A&gt; da(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> _A[<span class="hljs-number"><span class="hljs-number">3</span></span>]); TRY_BLOCK { THROW_IN_BLOCK(<span class="hljs-string"><span class="hljs-string">"error\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"notreached\n"</span></span>; } CATCH_BLOCK_FIN { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"."</span></span> &lt;&lt; __exc; RETHROW_IN_BLOCK; } FIN_BLOCK; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"notreached\n"</span></span>; } CATCH_BLOCK_FIN { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">".."</span></span> &lt;&lt; __exc; } FIN_BLOCK;</code> </pre><br>  A :: A (1) <br>  A :: A (2) <br>  A :: A (3) <br>  .error <br>  A :: ~ A (3) <br>  A :: ~ A (2) <br>  A :: ~ A (1) <br>  ..error <br></div></div></li></ul><br>  <b>Restrictions</b> <br>  This solution has many disadvantages: <br><ul><li>  You can not throw exceptions in the destructor.  The unw_item_t destructor has not yet deleted the link to this instance, as a result, the destructor will be called again. </li><li>  Creating an object inherited from the unw_item_t class using the new operator is very dangerous.  Even if the memory itself is taken care of, such a pointer can fall into another's context or even into someone else's stream, the object on which it looks can suddenly cause a destructor, which will end in a metabolic catastrophe. </li><li>  A class inherited from unw_item_t cannot be aggregated as a member of another class, otherwise its destructor will be called twice. </li><li>  The described method cannot be integrated with hardware exceptions. </li><li>  Restrictions on exception types.  Above, we used only a string pointer.  If you pass as an exception primitive types, then there can be only one option.  If we use the pointer to the object as an exception, we can use RTTI.  Can offer something like <pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CATCH_BLOCK_TYPED(t) \ } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (NULL != dynamic_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;t&gt;(__exc)) {</span></span></span></span></code> </pre>  And this will give us the opportunity to use exceptions of different types.  But then it is impossible to throw exceptions of primitive types. </li><li>  Delete the object thrown exception must be the user. </li></ul><br>  <b>But still.</b> <br>  Despite the described limitations, the described method has inherent advantages: <br><ul><li>  Simplicity.  A few dozen lines of code - and everything works. </li><li>  Transparency concept. </li><li>  Easy portability.  No dependence on architecture. </li></ul>  Is it possible to eliminate the disadvantages of this method, while retaining its advantages?  Yes and no.  Using only C ++ tools, it is impossible to do this. <br><br>  <b>What the author tends.</b> <br>  In the order of technical nonsense, we will think about how to modify the compiler in order to correctly implement the above scheme? <br>  What was missing from the above solution?  Knowledge of how the object was spawned. <br>  For example, if an object is built on memory allocated from a common heap and can migrate between threads, it can in no case be registered in a thread-dependent stack.  It is not necessary to register an object aggregated into another object anywhere. <br>  And with an object of the same type, but on a stack memory, it is necessary to do this.  Of course, it is possible to give a pointer to this stack object to another thread, but it is difficult to imagine in what situation this could be useful. <br>  So: <br><ul><li>  For stack objects of type <i>T, the</i> compiler actually creates a wrapping class of type <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">st_wrapper</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unw_item_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~__st_wrapper() { unreg(); ((T*)data_)-&gt;T::~T(); }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> data_[<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T)]; };</code> </pre>  as well as calling the desired constructor <i>T.</i> <br></li><li>  The static member of the <i>jmp_buf_splice :: root_slice_ class</i> is implemented either via TLS or the corresponding register, if there is </li><li>  The programmer still sees only an object of type <i>T</i> located in <i>data_</i> </li><li>  On stack objects without virtual destructors, it appears in a wrapper. </li><li>  Throw exceptions in destructors can now be  Before calling the destructor itself, we unregistered. </li><li>  We do not support hardware exceptions (kernel exceptions), so at the time of the excitation of an exception, the compiler knows which registers need to be ‚Äúground‚Äù and must do so </li><li>  For normal destruction of stack objects, the compiler creates calls for <i>__st_wrapper</i> 's destructors. </li><li>  The mechanism for selecting the appropriate <i>catch</i> block is left as is.  Those.  we still need auxiliary table information with descriptors of these blocks outside the code. </li><li>  We will transfer control using the setjmp analog.  It is proposed to implement an intermediate (with respect to the two described above) version of the transfer of control.  Setjmp has a significant drawback - the buffer size is quite large, while its small part is actually used. <br>  On the other hand, the execution of a bytecode in the spirit of DWARF is very wasteful. <br>  Therefore, instead of the setjmp buffer, we will store a list of registers that need to be restored and shifted relative to the stack pointer, where the actual values ‚Äã‚Äãlie.  In the case of a computed value, the value is stored in the register itself.  For this, additional memory is allocated in the stack and a shift is given to it.  In fact, a temporary variable is started. <br>  Before raising the exception, the compiler unloads all relevant data from the registers, in this case, you can recover without loss. <br><br>  Nevertheless, it is worth noting that the use of a <i>try</i> block is a conscious act, there is nothing wrong with that it incurs certain costs.  IMHO these (moderate) costs are even useful because  stimulate a responsible attitude to the tools of the language. <br></li><li>  Interception of exceptions when calling the operator <i>new</i> and <i>new [] is</i> left as is.  Those.  we protect each iteration with an internal <i>try</i> block and destroy everything created in the previous iterations if an exception has occurred, which we then relocate.  And, of course, we give back the memory allocated for the object [s.] </li><li>  To implement an array of stack objects and do nothing.  But you can save some memory by implementing a special stack object - a vector similar to that used when calling the operator <i>new []</i> . </li></ul><br><br>  <b>By the way.</b> <br><ul><li>  An object can know that it is a stack.  For this, <i>this</i> must be within the stack stack of the current thread. </li><li>  So you can take an object off the hook?  I can not imagine why this may be necessary, but this possibility exists. </li><li>  If you can remove, then you can and plant.  Allocate memory in the stack through <i>alloca</i> , forcibly call the constructor and connect it to the stack promotion mechanism. </li><li>  For architectures with separate data and control stacks, exception handling can be implemented very effectively using a control stack instead of a list. </li></ul><br><br>  <b>PS:</b> Special thanks to Alexander Artyushin for informative discussion. </div><p>Source: <a href="https://habr.com/ru/post/208006/">https://habr.com/ru/post/208006/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../207990/index.html">Part 2. How many megabits / s can be passed through the optic nerve and what is the resolution of the retina? Some theory</a></li>
<li><a href="../207996/index.html">Syrian e-army hacked blog and Twitter account Skype</a></li>
<li><a href="../208000/index.html">New Year's surprise from Motorola - Moto X is now cheaper</a></li>
<li><a href="../208002/index.html">Online courses, teacher's view + call to developers</a></li>
<li><a href="../208004/index.html">Full analysis of Apple Mac Pro 2013</a></li>
<li><a href="../208008/index.html">Graphene Storage Concept Receives Red Dot Design Awards</a></li>
<li><a href="../208010/index.html">Suspicion of a secret telecommunications hub</a></li>
<li><a href="../208014/index.html">Backdoor in Linksys and Netgear routers</a></li>
<li><a href="../208016/index.html">Measuring the current-voltage characteristics of the transistor using a Cypress microcontroller</a></li>
<li><a href="../208020/index.html">1058 candidates selected for flight to Mars</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>