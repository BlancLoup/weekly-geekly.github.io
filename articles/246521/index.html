<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>LIVR - ‚Äúlanguage independent validation rules‚Äù or data validation without ‚Äúproblems‚Äù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Each programmer has repeatedly encountered the need to validate user input. Being engaged in web development for more than 10 years, I tried a lot of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>LIVR - ‚Äúlanguage independent validation rules‚Äù or data validation without ‚Äúproblems‚Äù</h1><div class="post__text post__text-html js-mediator-article">  Each programmer has repeatedly encountered the need to validate user input.  Being engaged in web development for more than 10 years, I tried a lot of libraries, but did not find the only one that would solve the tasks I set. <br><br>  <b>Main problems encountered in data validation libraries</b> <br><br>  <b>Problem number 1.</b>  Many validators check only the data for which validation rules are described.  For me, it is important that any user input that is not explicitly allowed is ignored.  That is, the validator must cut out all the data for which the validation rules are not described.  This is simply a fundamental requirement. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Problem number 2.</b>  A procedural description of validation rules.  I don‚Äôt want to think about the validation algorithm every time, I just want to declare declaratively what the correct data should look like.  In fact, I want to set the data schema (why not the ‚ÄúJSON Schema‚Äù - at the end of the post). <br><br>  <b>Problem number 3.</b>  Description of the validation rules in the form of code.  It would seem that it is not so bad, but it immediately negates all attempts to serialize the rules of validation and the use of the same rules of validation on the backend and the frontend. <br><br>  <b>Problem number 4</b> .  Validation stops at the first field with an error.  This approach makes it impossible to highlight at once all the erroneous / required fields in the form. <br><br>  <b>Problem number 5.</b>  Non-standardized error messages.  For example, "Field name is required".  This error I can not show the user for several reasons: <br><ul><li>  field in the interface can be called quite differently </li><li>  interface may not be in English </li><li>  need to distinguish between the type of error.  For example, errors on the empty value show in a special way </li></ul><br>  That is, you do not need to return an error message, but standardized error codes. <br><br>  <b>Problem number 6.</b>  Numeric error codes.  This is just inconvenient to use.  I want the error codes to be intuitive.  Agree that the error code "REQUIRED" is clearer than the code "27".  The logic is similar to working with exception classes. <br><br>  <b>Problem number 7.</b>  There is no way to check hierarchical data structures.  Today, at the time of different JSON API, you just can't do without it.  In addition to the actual validation of hierarchical data, it is necessary to provide for the return of error codes for each field. <br><br>  <b>Problem number 8.</b>  Limited set of rules.  Standard rules are always lacking.  The validator must be extensible and allow the addition of rules of any complexity. <br><br>  <b>Problem number 9.</b>  Too wide area of ‚Äã‚Äãresponsibility.  The validator should not generate forms, should not generate code, should not do anything except validation. <br><br>  <b>Problem number 10.</b>  Inability to conduct additional data processing.  Almost always, where there is validation, there is a need for some additional (often preliminary) data processing: cut out forbidden characters, bring in lower case, remove extra spaces.  Especially important is the removal of spaces at the beginning and at the end of the line.  In 99% of cases, they are not needed.  <i>I know that I said before that the validator should not do anything except validation.</i> <br><br>  3 years ago, it was decided to write a validator, which will not have all the problems described above.  This is how LIVR (Language Independent Validation Rules) appeared.  There are implementations in Perl, PHP, JavaScript, Python (we do not write in python - I cannot give feedback on it).  The validator has been used in production for several years in almost every project of the company.  The validator works both on the server and on the client. <a name="habracut"></a>  You can play with the validator here - <a href="http://webbylab.github.io/livr-playground">webbylab.github.io/livr-playground</a> . <br><br>  The key idea was that the kernel of the validator should be minimal, and all the validation logic is in the rules (or rather, in their implementation).  That is, for the validator there is no difference between the ‚Äúrequired‚Äù rules (checks for the presence of a value), ‚Äúmax_length‚Äù (checks the maximum length), ‚Äúto_lc‚Äù (cites data in lower case), ‚Äúlist_of_objects‚Äù (helps to describe the rules for array of objects). <br><br>  In other words, the validator knows nothing: <br><ul><li>  about error codes </li><li>  that he can validate hierarchical objects </li><li>  that he can convert / clean data </li><li>  about many other things </li></ul><br>  All this is the responsibility of the validation rules. <br><br>  <b>LIVR specification</b> <br><br>  Since the task was to make the validator independent of a programming language, such as mustache / handlebars, but only in the world of data validation, we began with writing a specification. <br><br>  Specification Objectives: <br><ol><li>  Standardize data description format. </li><li>  Describe the minimum set of validation rules that must be supported by each implementation. </li><li>  Standardize error codes. </li><li>  To be the uniform basic documentation for all implementations. </li><li>  Have a set of test data that allows you to check the implementation for compliance with specifications </li></ol><br>  The specification is available at <a href="http://livr-spec.org/">livr-spec.org.</a> <br><br>  The basic idea was that the description of the validation rules should look like a data scheme and be as close to the data as possible, only instead of the rule values. <br><br>  Example of description of validation rules for authorization form ( <a href="http://webbylab.github.io/livr-playground/">demo</a> ): <br><pre><code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">email</span></span>: [<span class="hljs-string"><span class="hljs-string">'required'</span></span>, <span class="hljs-string"><span class="hljs-string">'email'</span></span>], <span class="hljs-attr"><span class="hljs-attr">password</span></span>: <span class="hljs-string"><span class="hljs-string">'required'</span></span> }</code> </pre> <br>  Example of validation rules for registration form ( <a href="http://webbylab.github.io/livr-playground/">demo</a> ): <br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'required'</span></span>, <span class="hljs-attr"><span class="hljs-attr">email</span></span>: [<span class="hljs-string"><span class="hljs-string">'required'</span></span>, <span class="hljs-string"><span class="hljs-string">'email'</span></span>], <span class="hljs-attr"><span class="hljs-attr">gender</span></span>: { <span class="hljs-attr"><span class="hljs-attr">one_of</span></span>: [<span class="hljs-string"><span class="hljs-string">'male'</span></span>, <span class="hljs-string"><span class="hljs-string">'female'</span></span>] }, <span class="hljs-attr"><span class="hljs-attr">phone</span></span>: {<span class="hljs-attr"><span class="hljs-attr">max_length</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>}, <span class="hljs-attr"><span class="hljs-attr">password</span></span>: [<span class="hljs-string"><span class="hljs-string">'required'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">min_length</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>} ] password2: { <span class="hljs-attr"><span class="hljs-attr">equal_to_field</span></span>: <span class="hljs-string"><span class="hljs-string">'password'</span></span> } }</code> </pre><br>  Example of validation of a nested object ( <a href="http://webbylab.github.io/livr-playground/">demo</a> ): <br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'required'</span></span>, <span class="hljs-attr"><span class="hljs-attr">phone</span></span>: {<span class="hljs-attr"><span class="hljs-attr">max_length</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>}, <span class="hljs-attr"><span class="hljs-attr">address</span></span>: { <span class="hljs-string"><span class="hljs-string">'nested_object'</span></span>: { <span class="hljs-attr"><span class="hljs-attr">city</span></span>: <span class="hljs-string"><span class="hljs-string">'required'</span></span>, <span class="hljs-attr"><span class="hljs-attr">zip</span></span>: [<span class="hljs-string"><span class="hljs-string">'required'</span></span>, <span class="hljs-string"><span class="hljs-string">'positive_integer'</span></span>] }} }</code> </pre><br>  <b>Validation Rules</b> <br><br>  How are the rules of valicia described?  Each rule consists of a name and arguments (practically, as a function call) and is generally described as follows {"RULE_NAME": ARRAY_OF_ARGUMENTS}.  For each field, an array of rules is described, which are applied in order. <br><br>  For example, <br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"login"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">length_between</span></span>: [ <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span> ] } ] }</code> </pre><br>  That is, we have a ‚Äúlogin‚Äù field and a ‚Äúlength_between‚Äù rule, which has 2 arguments (‚Äú5‚Äù and ‚Äú10‚Äù).  This is the most complete form, but the following simplifications are allowed. <br><br><ul><li>  If the rule to the field is one, then the array is optional </li><li>  If a rule has one argument, then you can only pass it (without framing the array) </li><li>  If the rule has no arguments, then you can simply write the name of the rule. </li></ul><br>  All 3 entries are identical: <br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"login"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">required</span></span>: [] } ]</code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"login"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"required"</span></span> ]</code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"login"</span></span>: <span class="hljs-string"><span class="hljs-string">"required"</span></span></code> </pre><br>  More detailed in the specification in the section "How it works". <br><br>  <b>Supported Rules</b> <br><br>  All rules can be divided into 3 global groups: <br><ul><li>  Rules that validate data (numbers, strings, etc.).  For example, "max_length". </li><li>  Rules that allow you to make more complex rules with simpler ones.  For example, "nested_object". </li><li>  Rules that convert data.  For example, "to_lc" </li></ul><br>  but the validator itself does not distinguish between them, for them they are all equal. <br><br>  Here is a general list of rules that should be supported by each validator implementation: <br><br>  <u>Basic rules</u> <br><ul><li>  required - the field is required and the value must not be empty </li><li>  not_empty - the field is optional, but if it is, it cannot be empty </li><li>  not_empty_list - the value must contain a non-empty array </li></ul><br>  <u>Rules for checking strings</u> <br><ul><li>  one_of </li><li>  max_length </li><li>  min_length </li><li>  length_between </li><li>  length_equal </li><li>  like </li></ul><br>  <u>Rules for checking numbers</u> <br><ul><li>  integer </li><li>  positive_integer </li><li>  decimal </li><li>  positive_decimal </li><li>  max_number </li><li>  min_number </li><li>  number_between </li></ul><br>  <u>Rules for special formats</u> <br><ul><li>  email </li><li>  url </li><li>  iso_date </li><li>  equal_to_field </li></ul><br>  <u>Rules for describing more complex rules (meta-rules)</u> <br><ul><li>  nested_object - describes the rules for the nested object </li><li>  list_of - describes the rules with which each element of the list must comply </li><li>  list_of_objects - the value should be an array of objects in the required format </li><li>  list_of_different_objects - use when you need to check an array of objects of different types. </li></ul><br>  Rules for data conversion (names begin with a verb) <br><ul><li>  trim - removes spaces at the beginning at the end </li><li>  to_lc - results in lower case </li><li>  to_uc - results in upper case </li><li>  remove - removes the specified characters </li><li>  leave_only - leaves only the specified characters </li></ul><br>  <b>Meta-rule</b> <br><br>  An example and error codes for each rule can be found in the LIVR specification.  We will dwell a little more on meta-rules only.  Meta-rules are rules that allow you to combine simple rules into more complex ones for validating complex hierarchical data structures.  It is important to understand that the validator does not distinguish between simple rules and meta-rules.  Meta-rules are no different from the same ‚Äúrequired‚Äù (yes, I repeat). <br><br>  <u>nested_object</u> <br>  Allows you to describe validation rules for nested objects.  You will use this rule all the time. <br>  The error code depends on the nested rules.  If the attached object is not a hash (dictionary), then the field will contain the error: ‚ÄúFORMAT_ERROR‚Äù. <br>  Example of use ( <a href="http://webbylab.github.io/livr-playground/">demo</a> ): <br><br><pre> <code class="javascript hljs">address: { <span class="hljs-string"><span class="hljs-string">'nested_object'</span></span>: { <span class="hljs-attr"><span class="hljs-attr">city</span></span>: <span class="hljs-string"><span class="hljs-string">'required'</span></span>, <span class="hljs-attr"><span class="hljs-attr">zip</span></span>: [<span class="hljs-string"><span class="hljs-string">'required'</span></span>, <span class="hljs-string"><span class="hljs-string">'positive_integer'</span></span>] }}</code> </pre><br>  <u>list_of</u> <br>  Allows you to describe validation rules for a list of values.  Each rule will be applied to each item in the list. <br>  The error code depends on the nested rules. <br>  Example of use ( <a href="http://webbylab.github.io/livr-playground/">demo</a> ): <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">product_ids</span></span>: { <span class="hljs-string"><span class="hljs-string">'list_of'</span></span>: [ <span class="hljs-string"><span class="hljs-string">'required'</span></span>, <span class="hljs-string"><span class="hljs-string">'positive_integer'</span></span>] }}</code> </pre><br>  <u>list_of_objects</u> <br>  Allows you to describe the validation rules for an array of hashes (dictionaries).  Similar to nested_object, but waiting for an array of objects.  The rules apply to each element in the array. <br>  The error code depends on the nested rules.  In case the value is not an array, the code ‚ÄúFORMAT_ERROR‚Äù will be returned for the field. <br>  Example of use ( <a href="http://webbylab.github.io/livr-playground/">demo</a> ): <br><pre> <code class="javascript hljs">products: [<span class="hljs-string"><span class="hljs-string">'required'</span></span>, { <span class="hljs-string"><span class="hljs-string">'list_of_objects'</span></span>: { <span class="hljs-attr"><span class="hljs-attr">product_id</span></span>: [<span class="hljs-string"><span class="hljs-string">'required'</span></span>,<span class="hljs-string"><span class="hljs-string">'positive_integer'</span></span>], <span class="hljs-attr"><span class="hljs-attr">quantity</span></span>: [<span class="hljs-string"><span class="hljs-string">'required'</span></span>, <span class="hljs-string"><span class="hljs-string">'positive_integer'</span></span>] }}]</code> </pre><br>  <u>list_of_different_objects</u> <br>  Similar to ‚Äúlist_of_objects‚Äù, but it happens that the array that comes to us contains objects of different types.  The type of an object we can determine by some field, for example, ‚Äútype‚Äù.  ‚ÄúList_of_different_objects‚Äù allows you to describe the rules for a list of objects of different types. <br>  The error code depends on the nested validation rules.  If the nested object is not a hash, then the field will contain the error ‚ÄúFORMAT_ERROR‚Äù. <br>  Example of use ( <a href="http://webbylab.github.io/livr-playground/">demo</a> ): <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">products</span></span>: [<span class="hljs-string"><span class="hljs-string">'required'</span></span>, { <span class="hljs-string"><span class="hljs-string">'list_of_different_objects'</span></span>: [ product_type, { <span class="hljs-attr"><span class="hljs-attr">material</span></span>: { <span class="hljs-attr"><span class="hljs-attr">product_type</span></span>: <span class="hljs-string"><span class="hljs-string">'required'</span></span>, <span class="hljs-attr"><span class="hljs-attr">material_id</span></span>: [<span class="hljs-string"><span class="hljs-string">'required'</span></span>, <span class="hljs-string"><span class="hljs-string">'positive_integer'</span></span>], <span class="hljs-attr"><span class="hljs-attr">quantity</span></span>: [<span class="hljs-string"><span class="hljs-string">'required'</span></span>, {<span class="hljs-string"><span class="hljs-string">'min_number'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>} ], <span class="hljs-attr"><span class="hljs-attr">warehouse_id</span></span>: <span class="hljs-string"><span class="hljs-string">'positive_integer'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">service</span></span>: { <span class="hljs-attr"><span class="hljs-attr">product_type</span></span>: <span class="hljs-string"><span class="hljs-string">'required'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: [<span class="hljs-string"><span class="hljs-string">'required'</span></span>, {<span class="hljs-string"><span class="hljs-string">'max_length'</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span>} ] } } ]}] }</code> </pre><br>  In this example, the validator will look at the ‚Äúproduct_type‚Äù in each hash and, depending on the value of this field, will use the appropriate validation rules. <br><br>  <b>Error format</b> <br><br>  As already mentioned, the rules return string error codes that are understandable to the developer, for example, ‚ÄúREQUIRED‚Äù, ‚ÄúWRONG_EMAIL‚Äù, ‚ÄúWRONG_DATE‚Äù, and so on.  Now the developer can understand what the error is, it remains convenient to convey in which fields it originated.  For this, the validator returns a structure similar to that passed to it for validation, but it contains only fields in which errors occurred and, instead of initial values ‚Äã‚Äãin the fields, string error codes. <br><br>  For example, there are rules: <br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'required'</span></span>, <span class="hljs-attr"><span class="hljs-attr">phone</span></span>: {<span class="hljs-attr"><span class="hljs-attr">max_length</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>}, <span class="hljs-attr"><span class="hljs-attr">address</span></span>: { <span class="hljs-string"><span class="hljs-string">'nested_object'</span></span>: { <span class="hljs-attr"><span class="hljs-attr">city</span></span>: <span class="hljs-string"><span class="hljs-string">'required'</span></span>, <span class="hljs-attr"><span class="hljs-attr">zip</span></span>: [<span class="hljs-string"><span class="hljs-string">'required'</span></span>, <span class="hljs-string"><span class="hljs-string">'positive_integer'</span></span>] }} }</code> </pre><br>  and data for validation: <br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">phone</span></span>: <span class="hljs-number"><span class="hljs-number">12345678901</span></span>, <span class="hljs-attr"><span class="hljs-attr">address</span></span>: { <span class="hljs-attr"><span class="hljs-attr">city</span></span>: <span class="hljs-string"><span class="hljs-string">'NYC'</span></span> } }</code> </pre><br>  we get the following error at the output <br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"REQUIRED"</span></span>, <span class="hljs-string"><span class="hljs-string">"phone"</span></span>: <span class="hljs-string"><span class="hljs-string">"TOO_LONG"</span></span>, <span class="hljs-string"><span class="hljs-string">"address"</span></span>: { <span class="hljs-string"><span class="hljs-string">"zip"</span></span>: <span class="hljs-string"><span class="hljs-string">"REQUIRED"</span></span> } }</code> </pre><br>  <a href="http://webbylab.github.io/livr-playground/">demo validation</a> <br><br>  <b>REST API and error format</b> <br><br>  Returning sane errors always requires additional efforts from developers.  And very few REST APIs that give detailed information in errors.  Often it's just ‚ÄúBad request‚Äù and that's it.  I would like to look at the error, to which field it belongs, and just the field paths are not enough, because the data can be hierarchical and contain arrays of objects ... In our company, we proceed as follows - absolutely for each request we describe the validation rules using LIVR.  In case of a validation error, we return the error object to the client.  The error object contains the global error code and the error received from the LIVR validator. <br><br>  For example, you transfer data to the server: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"email"</span></span>: <span class="hljs-string"><span class="hljs-string">"user_at_mail_com"</span></span>, <span class="hljs-string"><span class="hljs-string">"age"</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">"address"</span></span>: { <span class="hljs-string"><span class="hljs-string">"country"</span></span>: <span class="hljs-string"><span class="hljs-string">"USQ"</span></span> } }</code> </pre><br>  and in return you receive ( <a href="http://webbylab.github.io/livr-playground/">demo validation on livr playground</a> ): <br><br><pre> <code class="javascript hljs">{<span class="hljs-string"><span class="hljs-string">"error"</span></span>: { <span class="hljs-string"><span class="hljs-string">"code"</span></span>: <span class="hljs-string"><span class="hljs-string">"FORMAT_ERROR"</span></span>, <span class="hljs-string"><span class="hljs-string">"fields"</span></span>: { <span class="hljs-string"><span class="hljs-string">"email"</span></span>: <span class="hljs-string"><span class="hljs-string">"WRONG_EMAIL"</span></span>, <span class="hljs-string"><span class="hljs-string">"age"</span></span>: <span class="hljs-string"><span class="hljs-string">"TOO_LOW"</span></span>, <span class="hljs-string"><span class="hljs-string">"fname"</span></span>: <span class="hljs-string"><span class="hljs-string">"REQUIRED"</span></span>, <span class="hljs-string"><span class="hljs-string">"lname"</span></span>: <span class="hljs-string"><span class="hljs-string">"REQUIRED"</span></span>, <span class="hljs-string"><span class="hljs-string">"address"</span></span>: { <span class="hljs-string"><span class="hljs-string">"country"</span></span>: <span class="hljs-string"><span class="hljs-string">"NOT_ALLOWED_VALUE"</span></span>, <span class="hljs-string"><span class="hljs-string">"city"</span></span>: <span class="hljs-string"><span class="hljs-string">"REQUIRED"</span></span>, <span class="hljs-string"><span class="hljs-string">"zip"</span></span>: <span class="hljs-string"><span class="hljs-string">"REQUIRED"</span></span> } } }}</code> </pre><br>  This is much more informative than some kind of ‚ÄúBad request‚Äù. <br><br>  <b>Work with pseudonyms and register your own rules</b> <br><br>  The specification contains only the most used rules, but each project has its own specifics and there are always situations when there are not enough rules.  In this regard, one of the key requirements for a validator was the possibility of its extension with its own rules of any type.  Initially, each implementation had its own mechanism for describing rules, but starting with the specification of version 0.4, we introduced a standard way of creating rules based on other rules (creating aliases), which covers 70% of situations.  Consider both options. <br><br>  <u>Creating an alias</u> <br>  The way in which the pseudonym is registered depends on the implementation, but how the pseudonym is described is regulated by the specification.  This approach, for example, allows you to serialize pseudonym descriptions and use them with different implementations (for example, on the Perl-backend and JavaScript frontend) <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   "valid_address" validator. registerAliasedRule({ name: 'valid_address', rules: { nested_object: { country: 'required', city: 'required', zip: 'positive_integer' }} }); //   "adult_age" validator.registerAliasedRule( { name: 'adult_age', rules: [ 'positive_integer', { min_number: 18 } ] }); //   ,   . { name: 'required', age: ['required', 'adult_age' ], address: ['required', 'valid_address'] }</span></span></code> </pre><br>  Moreover, you can set your own error codes for the rules. <br><br>  For example, <br><pre> <code class="javascript hljs">validator.registerAliasedRule({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'valid_address'</span></span>, <span class="hljs-attr"><span class="hljs-attr">rules</span></span>: { <span class="hljs-attr"><span class="hljs-attr">nested_object</span></span>: { <span class="hljs-attr"><span class="hljs-attr">country</span></span>: <span class="hljs-string"><span class="hljs-string">'required'</span></span>, <span class="hljs-attr"><span class="hljs-attr">city</span></span>: <span class="hljs-string"><span class="hljs-string">'required'</span></span>, <span class="hljs-attr"><span class="hljs-attr">zip</span></span>: <span class="hljs-string"><span class="hljs-string">'positive_integer'</span></span> }}, <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-string"><span class="hljs-string">'WRONG_ADDRESS'</span></span> });</code> </pre><br>  and in case of an error during address validation, we get the following: <br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">address</span></span>: <span class="hljs-string"><span class="hljs-string">'WRONG_ADDRESS'</span></span> }</code> </pre><br>  <u>Registration of a full-fledged rule on the example of <a href="https://www.npmjs.com/package/livr">JavaScript implementation</a></u> <br>  For validation, callback functions are used to validate values.  Let's try to describe a new rule called ‚Äústrong_password‚Äù.  We will check that the value is more than 8 characters and contains numbers and letters in upper and lower case. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> LIVR = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'livr'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rules = {<span class="hljs-attr"><span class="hljs-attr">password</span></span>: [<span class="hljs-string"><span class="hljs-string">'required'</span></span>, <span class="hljs-string"><span class="hljs-string">'strong_password'</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> validator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LIVR.Validator(rules); validator.registerRules({ <span class="hljs-attr"><span class="hljs-attr">strong_password</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   .           "required" if (val === undefined || val === null || val === '' ) return; if ( length(val) &lt; 8 || !val.match([0-9]) || !val.match([az] || !val.match([AZ] ) ) { return 'WEAK_PASSWORD'; } return; } } });</span></span></code> </pre><br>  Now we add the ability to set the minimum number of characters in the password and register this rule as global (available in all instances of the validator). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> LIVR = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'livr'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rules = {<span class="hljs-attr"><span class="hljs-attr">password</span></span>: [<span class="hljs-string"><span class="hljs-string">'required'</span></span>, {<span class="hljs-string"><span class="hljs-string">'strong_password'</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>}]}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> validator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LIVR.Validator(rules); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> strongPassword = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">minLength</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!minLength) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-string"><span class="hljs-string">"[minLength] parameter required"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   .           "required" if (val === undefined || val === null || val === '' ) return; if ( length(val) &lt; minLength || !val.match([0-9]) || !val.match([az] || !val.match([AZ] ) ) { return 'WEAK_PASSWORD'; } return; } }; LIVR.Validator.registerDefaultRules({ strong_password: strongPassword });</span></span></code> </pre><br><br>  So, simply enough, there is a registration of new rules.  If it is necessary to describe more complex rules, then the best option would be to see the list of standard rules implemented in the validator: <br><ul><li>  <a href="">Common</a> </li><li>  <a href="">Numeric</a> </li><li>  <a href="">String</a> </li><li>  <a href="">Special</a> </li><li>  <a href="">Helpers</a> </li><li>  <a href="">Filters</a> </li></ul><br>  It is possible to register rules that will not only validate the value, but also change it.  For example, result in upper case or remove extra spaces. <br><br>  <b>Its implementation according to the specification</b> <br><br>  If there is a desire to make your own validator implementation, then a set of <a href="https://github.com/koorchik/LIVR/tree/master/test_suite">test cases</a> was created to facilitate the task.  If your implementation passes all tests, then it can be considered correct.  The test suite consists of 4 groups: <br><br><ul><li>  "Positive" - ‚Äã‚Äãpositive tests for the basic rules </li><li>  "Negative" - ‚Äã‚Äãnegative tests for the basic rules </li><li>  ‚ÄúAliases_positive‚Äù - positive tests for rule aliases </li><li>  "Aliases_negative" - ‚Äã‚Äãnegative tests for rule aliases </li></ul><br>  In fact, each test contains several files: <br><br><ul><li>  rules.json - description of validation rules </li><li>  input.json - the structure that is passed to the validator for verification </li><li>  output.json is a clean structure that is obtained after validation </li></ul><br>  Each negative test instead of ‚Äúoutput.json‚Äù contains ‚Äúerrors.json‚Äù with a description of the error that should result from validation.  In alias tests, there is an aliases.json file with aliases that must be registered in advance. <br><br>  <b>Why not JSON Schema?</b> <br><br>  Frequently asked question.  In short, there are several reasons: <br><ul><li>  Difficult format for rules.  It would be desirable, that the structure with rules was as close as possible to the structure with data.  Try to describe <a href="http://webbylab.github.io/livr-playground/">this example</a> in JSON Schema </li><li>  The error format is not specified in any way and different implementations return errors in different formats. </li><li>  There is no data conversion, for example "to_lc". </li></ul><br>  JSON Schema contains interesting things, such as the ability to specify the maximum number of elements in the list, but in LIVR this is implemented simply by adding another rule. <br><br>  <b>LIVR links</b> <br><br><ul><li>  <a href="http://livr-spec.org/">LIVR specification (latest version - 0.4)</a> </li><li>  <a href="https://github.com/koorchik/LIVR/tree/master/test_suite">Test suite</a> </li><li>  <a href="http://webbylab.github.io/livr-playground/">LIVR Playground</a> </li><li>  <a href="https://www.npmjs.com/package/livr">Javascript implementation</a> </li><li>  <a href="https://metacpan.org/pod/Validator::LIVR">Perl implementation</a> </li><li>  <a href="https://github.com/WebbyLab/php-validator-livr">PHP implementation</a> </li><li>  <a href="https://pypi.python.org/pypi/LIVR">Python implementation</a> </li><li>  <a href="http://pragmaticperl.com/issues/05/pragmaticperl-05-livr-language-independent-validation-rules-%25D0%25BD%25D0%25B5%25D0%25B7%25D0%25B0%25D0%25B2%25D0%25B8%25D1%2581%25D0%25B8%25D0%25BC%25D1%258B%25D0%25B5-%25D0%25BE%25D1%2582-%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA%25D0%25B0-%25D0%25BF%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BB%25D0%25B0-%25D0%25B2%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B4%25D0%25B0%25D1%2586%25D0%25B8%25D0%25B8.html">Article about LIVR and Perl implementation in PragmaticPerl</a> </li><li>  <a href="https://vimeo.com/76611833">Video of the LIVR report at the OSDN-UA 2013 conference</a> </li></ul><br><br>  <b>UPD:</b> <br><br>  LIVR 2.0 released ( <a href="http://livr-spec.org/">http://livr-spec.org/</a> ).  With new features: <br><ul><li>  A consistent approach to working with types. </li><li>  ‚ÄúBase rules‚Äù renamed to ‚ÄúCommon rules‚Äù. </li><li>  ‚ÄúFilter rules‚Äù renamed to ‚ÄúModifiers‚Äù.  Because they do not validate, they only modify the data. </li><li>  "Helper rules" renamed to "Metarules" </li><li>  Added rule "any_object", checks that it is an object </li><li>  Added string rule - ‚Äústring‚Äù, just a string of any type </li><li>  Added rule "eq" - checks for string equality </li><li>  Added metadirectory "variable_object".  Dynamically determines which validation to use depending on the fields in the object. </li><li>  Added metadirect ‚Äúor‚Äù.  Allows you to apply the rules alternately to the first match. </li><li>  Added modifier ¬´default¬ª for setting values ‚Äã‚Äãby default, if the user has not transmitted anything. </li><li>  Significantly expanded test suite. </li></ul><br><br>  JavaScript implementation already supports all new features, the rest of the implementation is in the process of updating. </div><p>Source: <a href="https://habr.com/ru/post/246521/">https://habr.com/ru/post/246521/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../246509/index.html">Create an emotional stress tracker.</a></li>
<li><a href="../246511/index.html">MultiCAD.NET: calculation of the total length of the segments in the drawing</a></li>
<li><a href="../246515/index.html">How I was looking for an idea for a startup in Silicon Valley</a></li>
<li><a href="../246517/index.html">We connect NTFS to write to Mac OS X Yosemite 10.10</a></li>
<li><a href="../246519/index.html">How we did cashback service kubish.ru</a></li>
<li><a href="../246523/index.html">Hacker's guide to neural networks. Chapter 2: Machine Learning. Binary classification</a></li>
<li><a href="../246525/index.html">ReactOS Tech Talk at the faculty of the VMK MSU</a></li>
<li><a href="../246527/index.html">Redmine task requests. How we improved them and how we use them</a></li>
<li><a href="../246533/index.html">Trends iOS development 2014</a></li>
<li><a href="../246537/index.html">Announcement of new services and increased performance of the Azure cloud platform</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>