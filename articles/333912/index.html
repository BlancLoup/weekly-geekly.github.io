<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Neural conversational models: how to teach a neural network social conversation. Lecture in Yandex</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A good virtual assistant should not only solve the user's tasks, but also reasonably answer the question ‚ÄúHow are you?‚Äù. There are a lot of replicas w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Neural conversational models: how to teach a neural network social conversation. Lecture in Yandex</h1><div class="post__text post__text-html js-mediator-article">  A good virtual assistant should not only solve the user's tasks, but also reasonably answer the question ‚ÄúHow are you?‚Äù.  There are a lot of replicas without an explicit goal, and to prepare an answer to each one is problematic.  Neural Conversational Models is a relatively new way to create interactive systems for free communication.  It is based on networks trained in large corps conversations from the Internet.  Boris <a href="https://habrahabr.ru/users/hr0nix/" class="user_link">hr0nix</a> Yangel tells how such models are good and how to build them. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/pjiknrtTZi0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Under the cut - the decoding and the main part of the slide. <br><br><a name="habracut"></a><hr><br>  Thank you for coming.  My name is Boria Yangel, I in Yandex are engaged in applying deep learning to natural language texts and dialogue systems.  Today I want to tell you about Neural Conversational Models.  This is a relatively new field of research in deep learning, the task of which is to learn how to develop neural networks that talk with the interlocutor on some common topics, that is, lead what can be called a small talk.  They say "Hello", discuss how you are doing, terrible weather or a film that you recently watched.  And today I want to tell you what has already been done in this area, what can be done in practice, using the results, and what problems remain that need to be solved. <br><img src="https://habrastorage.org/web/bdd/eb2/90b/bddeb290b58048c6af6e5d67c1431c21.jpg"><br>  My report will be structured approximately as follows.  First, we will talk a little about why we might need to teach neural networks to socialize, what data and neural network architectures we will need for this, and how we will train to solve this problem.  In the end, let's talk a little about how to evaluate what we have as a result of, that is, about metrics. <br><img src="https://habrastorage.org/web/7e1/543/5e9/7e15435e92d2454991d2a02c31492e03.jpg"><br>  Why learn networks to talk?  Someone might think that we are learning to make artificial intelligence that will ever enslave someone. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But we do not set ourselves such ambitious tasks.  Moreover, I strongly doubt that the methods I‚Äôm going to talk about today will help us to get very close to creating real artificial intelligence. <br><br>  Instead, we set ourselves the goal of making more interesting voice and conversational products.  There is a class of products, which is called, for example, voice assistants.  These are applications that in the format of a dialogue help you to solve some urgent tasks.  For example, find out what the weather is like now, or call a taxi or find out where the nearest pharmacy is located.  You learn about how such products are made on the <a href="https://youtu.be/UNOGyLGnNM0">second report of</a> my colleague, Zhenya Volkov, and now I am interested in this moment.  It would be desirable that in these products, if the user does not need anything right now, he could have a chat with something about the system.  And the product hypothesis is that if you can sometimes chat with our system, and these dialogues will be good, interesting, unique, not repetitive - then the user will return to this product more often.  These products want to do. <br><br>  How can they be done? <br><br>  There is a way in which the creators of Siri, for example, have gone - you can take and prepare many replicas of answers, some kind of replicas that the user often says.  And when you say one of these replicas and get the answer created by the editors - everything is great, it looks great, users like it.  The problem is that if you take a small step away from this scenario, you immediately see that Siri is nothing more than a stupid program that can use a phrase in one replica, and in the very next remark say that she does not know the meaning of this phrase ‚Äî which, at least, is strange. <br><img src="https://habrastorage.org/web/955/512/848/95551284806a4c8592448379eaf02f5d.jpg"><br>  Here is an example of a similar in structure to the dialogue with the bot, which I did using the methods that I will talk about today.  He may never answer as interestingly and ornately as Siri, but at no point in time does he give the impression of an absolutely stupid program.  And it seems that it may be better in some products.  And if this is combined with the approach used by Siri and responding with editorial cues, when you can otherwise fallback to such a model, it seems that it will turn out even better.  Our goal is to make such systems. <br><img src="https://habrastorage.org/web/753/875/352/753875352dca40bcbf5acb46da20627f.jpg"><br>  What data do we need?  Let me run a little ahead and first I will say what task we will work with, because it is important for the discussion of our question.  We want to make remarks in the dialogue up to the current moment, and also, perhaps, some other contextual information about the dialogue - for example, where and when this dialogue takes place - to predict what the next remark should be.  That is - to predict the answer. <br><br>  To solve such a problem with the help of deep learning, it would be good for us to have a corpus with dialogues.  This case would be better if it was large, because deep learning with small text cases - you yourself probably know how it works.  It would be nice if the dialogues were on the topics we need.  That is, if we want to make a bot who will discuss your feelings with you or talk about the weather, then such dialogues should be in the dialogue box.  Therefore, a case of conversations with the support service of an Internet provider will hardly suit us in solving the problem. <br><br>  It would be nice to know in the corpus the author of each replica at least at the level of the unique identifier.  This will help us somehow to simulate the fact that, for example, different speakers use different vocabulary or even have different properties: they are called differently, they live in different places and answer different questions differently.  Accordingly, if we have any metadata about the speakers - gender, age, place of residence, and so on - then this will help us even more to model their features. <br><br>  Finally, some metadata about the dialogues ‚Äî time or place, if these are dialogues in the real world ‚Äî are also useful.  The fact is that two people can have completely different dialogues depending on the space-time context. <br><br>  In literature, that is, in articles about Neural Conversational Models, two datasets are very fond of. <br><img src="https://habrastorage.org/web/ce7/e81/19a/ce7e8119aee14a2eb2ba6304d64cae93.jpg"><br>  The first one is Open Subtitles.  These are just subtitles from a huge number of American films and TV shows.  What are the advantages of this dataset?  There are a lot of vital dialogues in it, directly those that we need, because these are films, series, there people often say to each other: ‚ÄúHello!  How are you? ‚Äù, Discuss some vital issues.  But since these are films and series, there is also a minus dataset.  There are a lot of fiction, a lot of fantasy that needs to be carefully cleaned up, and a lot of rather peculiar dialogues.  I remember, the first model that we trained in Open Subtitles, she out of place and out of place a lot about vampires for some reason said.  To the question "Where are you from?" Sometimes answered: "I, your mother, are from the FBI."  It seems that not everyone wants his interactive product to behave in this way. <br><br>  This is not the only problem with subtitles.  How is it formed?  I hope many of you know what srt-files are.  In fact, the authors of the dataset simply took the srt-files of these films and TV shows, all the replicas from there and recorded it in a huge text file.  Generally speaking, in srt-files nothing is clear about who is saying what replica and where one dialogue ends and another begins.  You can use different heuristics: for example, suppose that two consecutive replicas are always spoken by different speakers, or, for example, that if more than 10 seconds elapsed between replicas, these are different dialogues.  But such assumptions are fulfilled in 70% of cases, and this creates a lot of noise in dataset. <br><br>  There are works in which the authors try, for example, relying on the vocabulary of the speakers, to segment all remarks in subtitles into who says what and where one dialogue ends and another begins.  But no very good results have been achieved so far.  It seems that if you use additional information - for example, a video or audio track - you can do better.  But I do not know of any such work. <br><br>  What moral?  With subtitles you need to be careful.  On them, you can probably pre-teach the model, but I don‚Äôt recommend teaching to the end with all these drawbacks. <br><br>  The next dataset, which is very much loved in scientific literature, is Twitter.  On Twitter, every tweet knows whether it is root or is an answer to some other tweet.  Root in the sense that it is not written as an answer.  Accordingly, this gives us an accurate breakdown of the dialogues.  Each tweet forms a tree, in which the path from the root, that is, from root tweet to the leaf, is some kind of dialogue, often quite meaningful.  On Twitter, the author is known and the time of each replica, you can get additional information about users, that is, something is written there directly in the user's Twitter profile.  You can patch a profile with profiles in other social networks and learn something else. <br><br>  What are the cons of Twitter?  First of all, it is obviously biased towards the placement and discussion of links.  But it turns out that if you remove all the dialogues in which the root tweet contains a link, then the rest - it is, in many ways, not always, but often resembles the very small talk that we are trying to model.  However, it also turns out that secular topics dialogues, at least on Russian Twitter ‚Äî I will not vouch for English ‚Äî are conducted mainly by schoolchildren. <br><br>  We figured it out as follows.  We trained some model on Twitter for the first time and asked her a few simple questions like ‚ÄúWhere are you?‚Äù And ‚ÄúHow old are you?‚Äù. <br><img src="https://habrastorage.org/web/cc3/664/1d8/cc36641d82cd46dab03d21f490855a48.jpg"><br>  In general, to the question ‚ÄúWhere are you?‚Äù, The only censorship answer was ‚ÄúAt school‚Äù, while everyone else was different, perhaps, with punctuation marks.  But the answer to the question "How old are you?" Finally put everything in its place.  So what is the moral here?  If you want to learn interactive systems on this dataset, then the problem of schoolchildren somehow needs to be solved.  For example, it is necessary to filter.  Your model will speak as part of the speakers - you need to leave only the necessary part or use one of the speaker clustering methods, about which I will talk a little further. <br><br>  These two datasets are loved in scientific literature.  And if you are going to do something in practice, then you are in many ways limited only by your imagination and the name of the company for which you work.  For example, if you are Facebook, then you are lucky to have your own instant messenger, where a huge number of dialogues are just for those topics that interest us.  If you are not Facebook, you still have some options.  For example, you can get data from public chats in Telegram, in Slack, in some IRC channels, you can parse some forums, post some comments on social networks.  You can download movie scripts that actually follow a certain format, which in principle can be automatically parsed - and even understand where one scene ends, where another ends and who is the author of a particular replica.  Finally, some transcripts of TV programs can be found on the Internet, and I'm actually sure that I have listed only a small part of various sources for the interactive corpus. <br><img src="https://habrastorage.org/web/455/489/1f9/4554891f9e3d4190a85a4399de811033.jpg"><br>  We talked about the data.  Now let's get to the main part.  What neural networks do we need to learn from this data in order for us to get something that can talk?  I will remind you of the problem statement.  We want, according to previous remarks, which have been said up to the present moment in the dialogue, to predict what the next replica should be.  And all the approaches that solve this problem can be divided into two.  I call them "generating" and "ranking."  In the generative approach, we model the conditional distribution of the response in a fixed context.  If we have such a distribution, then in order to respond, we take its mode, say, or just sample it from this distribution.  And the ranking approach is when we teach a certain function of the relevance of a response, provided the context is not necessarily probabilistic in nature.  But, in principle, this conditional distribution from the generating approach can also be relevant with this function.  And then we take some pool of candidates of answers and choose from it the best answer for a given context using our relevance function. <br><br>  First, let's talk about the first approach - the generator. <br><img src="https://habrastorage.org/web/b27/d5e/7e0/b27d5e7e046d47ff8d6465f62aeef64f.jpg"><br>  Here we need to know what recurrent networks are.  I honestly hope that if you come to the report, where there are neural networks in the title, then you know what recurrent networks are - because from my confused minute explanation you are still unlikely to understand what it is.  But the rules are such that I have to tell about them. <br><br>  So, recurrent networks are such a neural network architecture for working with sequences of arbitrary length.  It works as follows. <br><br>  A recurrent network has some internal state that it updates by traversing all the elements of a sequence.  Conventionally, we can assume that it passes from left to right.  And as an option, the recurrent network at each step can generate some kind of output that goes somewhere further in your multilayer neural network.  And in classical neural networks called vanilla RNN, the update function of the internal state is just some non-linearity over the linear transformation of the input and the previous state, and the output is also non-linear over the linear transformation of the internal state.  Everyone loves to draw like this, or else unfold in sequences.  We will continue to use the second notation. <br><br>  In fact, nobody uses such update formulas, because if you train such neural networks, many unpleasant problems arise.  Enjoy more advanced architectures.  For example, LSTM (Long short-term memory) and GRU (Gated recurrent units).  Further, when we say ‚Äúrecurrent network‚Äù, we will assume something more advanced than simple recurrent networks. <br><img src="https://habrastorage.org/web/afb/123/332/afb1233328b64e73ab4ff87cfad786c5.jpg"><br>  Generative approach.  Our task of generating a replica in the context-based dialog can be thought of as the task of generating a string by string.  That is, imagine that we take the whole context, all the previous replicas said, and simply concatenate them, separating the replicas of different speakers with some special character.  It turns out the task of generating a string on a string, and such tasks are well studied in machine learning, in particular - in machine translation.  And the standard architecture in machine translation is the so-called sequence-to-sequence.  And state of the art in machine translation is still a modification of the sequence-to-sequence approach.  It was proposed by Suckever in 2014, and later adapted by his co-authors for our task, Neural Conversational Models. <br><br>  What is sequence-to-sequence?  This is the recurrent architecture of the encoder-decoder, that is, these are two recurrent networks: the encoder and the decoder.  The encoder reads the source string and generates some of its condensed representation.  This condensed representation is input to the decoder, which already has to generate the output line or, for each output line, say what probability it has in this conditional distribution that we are trying to model. <br><img src="https://habrastorage.org/web/df0/bf8/e63/df0bf8e633c24bec8a27175ca3f4a2e5.jpg"><br>  It looks like this.  Yellowish - network encoder.  Suppose we have a dialogue of two speakers from two replicas of "Hello" and "Zdarov", for which we want to generate an answer.  Speaker replicas will be separated by a special end-of-sentense symbol, eos.  In fact, they do not always share a sentence, but historically they call it that way.  Every word we first immerse in some vector space, we will do what is called vector embedding.  Then this vector for each word will be fed to the input of the network encoder, and the last state of the network encoder, after it has processed the last word, will be our condensed representation of the context that we give to the input of the decoder.  We can, for example, initialize the first hidden state of the network decoder with this vector or, alternatively, for example, submit it to each timestamp along with the words.  The network decoder at each step generates the next word of the replica and, at the input, receives the previous word that it generated.  This allows you to really model the conditional distribution better.  Why?  I do not want to go into details now. <br><br>  Generates the decoder all until it generates the end-of-sentence token.  This means that ‚ÄúThat's enough.‚Äù  And the decoder at the first step, as a rule, also receives the end-of-sentence token.  And it is not clear what he needs to file at the entrance. <br><img src="https://habrastorage.org/web/a74/a6c/e62/a74a6ce629be41cba84947359044c73f.jpg"><br>  Typically, such architectures are trained through learning maximum likelihood.  That is, we take the conditional distribution of the answers in contexts we know in the training set and try to make the answers we know as possible as possible.  That is, maximize, say, the logarithm of such a probability by the parameters of the neural network.  And when we need to generate a replica, we already have the parameters of the neural network, because we have trained and fixed them.  And we simply maximize the conditional distribution of the answer or sample from it.  In fact, it can not be precisely promaximized, so you have to use some approximate methods.  For example, there is a method of stochastic maximum search in such architectures encoder-decoder.  Called beam search.  I don‚Äôt have time to tell you what it is now, but the answer to this question is easy to find on the Internet. <br><br>  All modifications of this architecture, which were invented for machine translation, you can try to apply for Neural Conversational Models.  For example, the encoder and decoder are usually multi-layered.  They work better than single-layer architecture.  As I said, these are most likely LSTM or GRU networks, and not ordinary RNNs. <br><br>  The encoder is usually bidirectional.  That is, in fact, these are two recurrent networks that are traversed in a sequence from left to right and from right to left.  Practice shows that if you go only from one direction, then until you reach the end, the network will already forget what was there first.  And if you go from two sides, then you have information both on the left and on the right at each moment.  It works better. <br><br>       , ,   attention.     .  ,      ,               timestamp  encoder  -    ,    . ,        -       ,     .  attention   ,      Neural Conversational Models,      ,    . ,   ,                   .         .  ,     - ,  ,    memory networks.  multi-hole potential. <br><br>    ,     ,      Neural Conversational Model ‚Äî  ,     .   -  .   ,    ,       ,      . <br><br>  ,   , ‚Äî     ¬´¬ª .     encoder-decoder sequence-to-sequence,    .           ,      . , ¬´  ¬ª, ¬´¬ª, ¬´   ¬ª  . .   ? , ,  ,          ,        . <br><br>    Neural Conversational Models    ,   , ¬´¬ª    .     ,   -      ,    ,    ,    ,      . <br><img src="https://habrastorage.org/web/23d/e82/380/23de823806c247128dbc976398005b89.jpg"><br>  ,    , ‚Äî         . <br><br>  What does this mean in practice?    ,     .        .   ,     .            .     ‚Äî     .    ,    .         ,     -    . <br><br>     ?     ,           ,        .  ,  ,   ,                ‚Äî    ¬´¬ª, ¬´ ¬ª  . . <br><br>    ,        sequence-to-sequence,    ,          ‚Äî    .     ‚Äî   . <br><img src="https://habrastorage.org/web/a54/d02/9a6/a54d029a629b4fe18351bf3126599f33.jpg"><br>      ,   ‚Äî   ,       .    -.           ,        .     .     ,    ,    ,      .      , ¬´¬ª  ¬´  ¬ª,   ,      .      .    ,     sequence-to-sequence,     ,   sequence-to-sequence,     .        . <br><br>    ,    ICLR,   ,      .   .       -     ‚Äî ,   .      .            .     ,     .      -     ‚Äî  ,  ,    .    ,     ,       Monte Carlo  MMI,      .     ,      ,   -    ,   MMI. <br><br> ,   MMI    ,         ,     ,       ,   .  ,     ,      .  This is bad. <br><img src="https://habrastorage.org/web/ff0/fd0/d59/ff0fd0d59dc24978855fa97933f8cc3b.jpg"><br>  ,    , ‚Äî   .    .       ,  -     ,    .  Why?           ,          .  -     , ,   .           ,       . <br><br>            ,     ,       ,        .   -  . <br><br>    ,     ,   ¬´A Persona-Based Neural Conversation Model¬ª:            .  ,       ,           ,       - ,  ,       .  ,  ,    , , -    . .           .  ,      -   , ,     . <br><img src="https://habrastorage.org/web/c9a/3b4/133/c9a3b4133711429f9d745aebcfd36885.jpg"><br>      sequence-to-sequence   :   ,      ,     timestamp .  ‚Äî    embedding- . <br><br>        :  ,   ,      -   ,   ,      .  ,       .      .     ,   , ,         t-SNE  -      - , ,   . <br><img src="https://habrastorage.org/web/8d2/c0c/685/8d2c0c685600432cb4edefcfeae2131c.jpg"><br> ,          .    ‚Äî ,  , ,    ‚Äî ,   30 ,    .   ,    ,       .   ,    , , ,   30  - .  , -  .  Good. <br><img src="https://habrastorage.org/web/3bb/360/9ec/3bb3609ecc26423f80f4fc906a9b4c12.jpg"><br>    .       ,          ,       . ,  ,        .    ,     . <br><img src="https://habrastorage.org/web/787/9a2/f43/7879a2f4326e4ab1ab59b6976b766cd6.jpg"><br>       ,  ,        .         ,  ,  ,   ,       . .      .     , ,  log-likelihood  ,          . ,  log-likelihood  ,    , . <br><br>    : ¬´     ,        ,             ,         ¬ª.      ,  .  ,       .      . <br><br>   :  ,      -  ,              ,   .     ?     .           , .      ,    ,     ,     .       ,       ‚Äî   , ,   sequence-to-sequence encoder-decoder. <br><br>  , , :  ,    , .  ,  ,      .        ,  ,      . <br><img src="https://habrastorage.org/web/c79/942/608/c79942608160404ab398033e97283c51.jpg"><br>     ?   .   ,     ‚Äî   ,   ‚Äî encoder.    ‚Äî      ,  ‚Äî   .              ,       ,    .       Microsoft Research  DSSM, Deep Structure Semantic Models,  2013 .               Neural Conversational Models. <br><br>  encoder,  ,   ,        . ,       ‚Äî     sequence-to-sequence.      :         .     . <br><br>  ,      ‚Äî - ,       ,     , . <br><br>    ?    ,      ,  .   ,  -     ,   ,    . <br><br>    ?   ‚Äî random sampling,         , ,           .     ,   hard negative mining.   :    ,      ,       . <br><br>     -  <a href="https://habrahabr.ru/company/yandex/blog/314222/">  ¬´¬ª</a> .       ,      ,   hard negative mining  . <br><br>        .     ?  -  .  ,   :     Sim,       ,   softmax          -  ,   .  ,     ,    ,   ,           .      tripletloss.  -   max margin,   ,         ,          margin,   SVN.          . <br><br>  ,   ?        ?     ,      - .   ,     ,            ,       .  ,    ¬´¬ª    ,  ,           ,   .             ,   -    ,        .     .    ,    ,    ,     .      .  ,    . ,     . <br><br>     ?  State of the art,    ,  ‚Äî  ,     mechanical turk,    : ¬´      ?     0  5¬ª. : ¬´        ?¬ª.    ,         . <br><img src="https://habrastorage.org/web/17b/ce2/b94/17bce2b94b724b97a9d9065c2c394d2e.jpg"><br>   :    ?     ,      sequence-to-sequence,   DSSM-                ,     : bad, neutral  good. Bad ,    ,   , ,   . Neutral ,   ,     .  good ‚Äî       .       - ,      baseline,    .    . <br><br>  ,    10%  .  Why it happens? ,      ,         . , -,    : ¬´    ?¬ª.   ¬´42¬ª,  ,   ,   .  9  10 ‚Äî bad. <br><br>    ? ,    .     ‚Äî   ,             .   sequence-to-sequence  ,      . ,   ,       ,  , ,  sequence-to-sequence  .    sequence-to-sequence      - . <br><br>       .     Neural Conversational Models ‚Äî -     deep learning,    .    ,     : Facebook, Google.    .  , -      ,    ,       .  -  ,   .             ,        deep learning    ‚Äî  ,     . <br><br>   ,  , , <a href=""> </a> .   .  Thank. </div><p>Source: <a href="https://habr.com/ru/post/333912/">https://habr.com/ru/post/333912/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../333896/index.html">XBRL: Just About the Complex - Chapter 4. The XBRL Report</a></li>
<li><a href="../333904/index.html">Dismiss, hire, promote - the culture of your company</a></li>
<li><a href="../333906/index.html">Flat Cubik (Rubik's cube on the plane)</a></li>
<li><a href="../333908/index.html">Which languages ‚Äã‚Äãare most in demand in finance: the views of Wall Street recruiters</a></li>
<li><a href="../333910/index.html">Actions upon arrival at work - receiving cases, updating, documenting, auditing</a></li>
<li><a href="../333916/index.html">‚ÄúNecessity arises from both sides‚Äù: the DevOops program committee on the conference and on DevOps</a></li>
<li><a href="../333920/index.html">We raise Linux on MIPSfpga and Altera FPGA</a></li>
<li><a href="../333922/index.html">Release cycle for Infrastructure as Code</a></li>
<li><a href="../333926/index.html">Orchid CMS - another CMS on Laravel</a></li>
<li><a href="../333928/index.html">Integration of Apache CloudStack with third-party systems. Subscribing to events using Apache Kafka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>