<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>And again about recursive queries</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post will cover how to write recursive queries. This topic has been raised more than once and not twice, but usually everything is limited to sim...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>And again about recursive queries</h1><div class="post__text post__text-html js-mediator-article">  This post will cover how to write recursive queries.  This topic has been raised more than once and not twice, but usually everything is limited to simple ‚Äúwooden‚Äù cases: descend from the top to the leaves, rise from the top to the root.  We will deal with a more complicated case of an arbitrary graph. <br><br>  Let's start with repeating the theory (very briefly, because everything is clear with it), and then we will talk about what to do if it is not clear how to approach the real task, or seemingly understandable, but the query does not want to work hard. <br><br>  For the exercise, we will use the demo database, <a href="https://habrahabr.ru/post/316428/">described in detail earlier</a> , and try to write a query in it to search for the shortest path from one airport to another. <br><a name="habracut"></a><br><h2>  Some theory </h2><br>  Good old relational SQL does well with unordered sets: for them, both in the language itself and under the hood, the DBMS has a whole arsenal of tools.  What SQL doesn't like is when it is pulled in a loop, line by line, instead of performing a task with a single statement.  The optimizer lowers hands and moves aside, and you are left alone with performance. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So a recursive query is such a way to arrange a loop right inside SQL.  Not that it is needed very often, but sometimes it still happens.  And here begins the complexity, since the recursive query is not very similar to a normal query, much less a normal cycle. <br><br>  The general scheme of the recursive query is as follows: <br><br> <code><b>WITH RECURSIVE t AS ( <br>        (1) <br> UNION ALL <br>          (2) <br> ) <br> SELECT * FROM t;           (3) <br></b></code> <br><br>  First, the non-recursive part (1) is executed.  Then the recursive part (2) is executed until it returns any rows.  The recursive part is called so because it can refer to the result of the previous iteration, which is available to it under the name t. <br><br>  Along the way, the result of each iteration is added to the resulting table, which will be available under the same name t after the entire query has completed (3).  If instead of UNION ALL we write UNION, then duplicate rows will be eliminated at each iteration. <br><br>  In the form of a pseudo-code, it can be represented like this: <br><br> <code><b>res ‚Üê EMPTY; <br> t ‚Üê ( ); <br> WHILE t IS NOT EMPTY LOOP <br> res ‚Üê res UNION ALL t; <br> aux ‚Üê ( ); <br> t ‚Üê aux; <br> END LOOP; <br> t ‚Üê res; <br></b></code> <br><br>  A simple example: <br><br> <code><b>demo=# WITH RECURSIVE t(n,factorial) AS ( <br> VALUES (0,1) <br> UNION ALL <br> SELECT t.n+1, t.factorial*(t.n+1) FROM t WHERE tn &lt; 5 <br> ) <br> SELECT * FROM t;</b> <br> <br> n | factorial <br> ---+----------- <br> 0 |         1 <br> 1 |         1 <br> 2 |         2 <br> 3 |         6 <br> 4 |        24 <br> 5 |       120 <br> (6 ) <br></code> <br><br>  Well, enough to remember.  If already at this stage, not everything is clear, it's time to <a href="https://postgrespro.ru/docs/postgresql/current/queries-with">read the documentation</a> . <br><br><h2>  Practice </h2><br><br>  Armed with the theory, we can now (theoretically) take and write the query mentioned above: finding the shortest path from, say, Ust-Kut (UKX) to Neryungri (CNN). <br><br>  From the entire demo database, we need two tables: airports (airports) and routes (routes).  Formally, routes are a materialized view, but you can not think about it.  (If you are not familiar with the structure of the demonstration base, see <a href="https://edu.postgrespro.ru/bookings.pdf">its description</a> .) <br><br>  A query might look like this: <br><br> <code><b>WITH RECURSIVE p(last_arrival, destination, hops, flights, found) AS ( <br> SELECT a_from.airport_code, <br> a_to.airport_code, <br> ARRAY[a_from.airport_code], <br> ARRAY[]::char(6)[], <br> a_from.airport_code = a_to.airport_code <br> FROM   airports a_from, airports a_to <br> WHERE  a_from.airport_code = 'UKX' <br> AND    a_to.airport_code = 'CNN' <br> UNION ALL <br> SELECT r.arrival_airport, <br> p.destination, <br> (p.hops || r.arrival_airport)::char(3)[], <br> (p.flights || r.flight_no)::char(6)[], <br> bool_or(r.arrival_airport = p.destination) OVER () <br> FROM   routes r, p <br> WHERE  r.departure_airport = p.last_arrival <br> AND    NOT r.arrival_airport = ANY(p.hops) <br> AND    NOT p.found <br> ) <br> SELECT hops, <br> flights <br> FROM   p <br> WHERE  p.last_arrival = p.destination; <br></b></code> <br><br>  This, of course, is great, but how to get to it, when there is still nothing on the screen, except for a blinking cursor? <br><br><blockquote>  In this place of the cassette he always thinks that he accidentally put a beer on the rewind button: the dancers no longer viciously parody Randy himself and suddenly begin to move in a completely professional manner.  It seems that the movements are the same as before, but damn it, if you can distinguish them in creative execution.  There is no smooth transition, this is what infuriates and always infuriated Randy in these video tutorials.  Any idiot can learn basic steps in half an hour.  But when half an hour expires, the coach for some reason waits for you to start to flutter around the stage, as if the captions ‚Äúa few years‚Äù flashed by.  Probably, the humanities in mathematics lessons feel the same, Randy thinks.  Here the teacher writes a couple of simple equations on the blackboard, and ten minutes later the speed of light in a vacuum is already deduced from them. <br><br>  <em>- Neil Stephenson, "Kryptonomicon" (my translation)</em> <br></blockquote><br>  For example, I can not write such a request from the head.  Therefore, we will move consistently. <br><br>  So we need to get a path.  The route from point A to point B is a sequence of flights.  The first flight takes off from And somewhere, the next one - from somewhere somewhere else and so on, until the last flight ends at the search point B. This is a chain of flights with a fixed start, fixed end and unknown middle, and we need to find. <br><br>  How to present such a chain?  From a relational point of view, it would be logical for it to be a table with columns <em>number in order</em> and <em>airport</em> .  But we need to work with the chain as one object, so the most convenient is to present it with an array: [ <em>airport</em> , <em>airport</em> , ...].  (If there are difficulties with this, then read about <a href="https://postgrespro.ru/docs/postgresql/current/arrays.html">arrays</a> and <a href="https://postgrespro.ru/docs/postgresql/current/functions-array.html">functions</a> for working with them.) <br><br>  Where to start the iteration is clear: from the airport in Ust-Kut. <br><br> <code><b>demo=# SELECT ARRAY[airport_code] FROM airports WHERE airport_code = 'UKX';</b> <br> <br> array <br> ------- <br> {UKX} <br> (1 ) <br></code> <br><br>  Why not just ARRAY ['UKX']?  It is useful to insure a bit: if you suddenly get stuck in the airport code, the request will not return anything. <br><br>  Now let's imagine that the result of this initial iteration lies in the table, and we need to do the second iteration.  You can do this: create and fill in a table and write queries with it.  But it is easier to use WITH: <br><br> <code><b>demo=# <font color="#009900">WITH p(last_arrival, hops) AS (</font> <br> SELECT <font color="#009900">airport_code,</font> <br> ARRAY[airport_code] <br> FROM   airports <br> WHERE  airport_code = 'UKX' <br> <font color="#009900">) <br> SELECT * FROM p;</font></b> <br> <br> last_arrival | hops <br> --------------+------- <br> UKX          | {UKX} <br> (1 ) <br></code> <br><br>  We called the <em>hops</em> column so as not to get confused.  In addition, we added one more ( <em>last_arrival</em> ) for the last item in our future chain.  Instead, one could calculate the last element of the array (p.hops [cardinality (p.hops)]), but this is not so clear. <br><br>  Now the second iteration: <br><br> <code><b>demo=# WITH p(last_arrival, hops) AS ( <br> SELECT airport_code, <br> ARRAY[airport_code] <br> FROM   airports <br> WHERE  airport_code = 'UKX' <br> ) <br> <font color="#009900">SELECT r.arrival_airport AS last_arrival, <br> p.hops || ARRAY[r.arrival_airport] AS hops <br> FROM   routes r, p <br> WHERE  r.departure_airport = p.last_arrival;</font></b> <br> <br> last_arrival |   hops <br> --------------+----------- <br> KJA          | {UKX,KJA} <br> (1 ) <br></code> <br><br>  What have we done?  We took the first iteration (table p) and connected it to the routes.  We indicated the last airport from our chain as the airport of departure, and added the airport of arrival to the chain on the right.  It turns out that you can fly from Ust-Kut to Krasnoyarsk alone. <br><br>  Now it is more or less clear how to build a recursive query.  Add the magic word RESURSIVE, and combine the query with the first iteration using UNION ALL.  And in the main query, we select the chain, which ultimately led to the destination airport (CNN). <br><br>  Like that? <br><br> <code><b>demo=# WITH RECURSIVE p(last_arrival, hops) AS ( <br> SELECT airport_code, <br> ARRAY[airport_code] <br> FROM   airports <br> WHERE  airport_code = 'UKX' <br> <font color="#009900">UNION ALL</font> <br> SELECT r.arrival_airport, <br> p.hops || r.arrival_airport <br> FROM   routes r, p <br> WHERE  r.departure_airport = p.last_arrival <br> ) <br> <font color="#009900">SELECT * <br> FROM   p <br> WHERE  p.last_arrival = ( <br> SELECT airport_code FROM airports WHERE airport_code = 'CNN' <br> );</font></b> <br> <br> :     "p"  2   character(3)[]    ,     bpchar[] <br>  3:          ARRAY[airport_code] <br> ^ <br> :         . <br></code> <br><br>  Hm  Postgres is upset that the second column is of type character (3) [] in the non-recursive part (non-recursive term), but in general the type is bpchar [].  The type bpchar (blank-padded char) is the internal name for the type char;  unfortunately, concatenation of arrays does not preserve the type of elements, so explicit type conversion is required. <br><br> <code><b>demo=# WITH RECURSIVE p(last_arrival, hops) AS ( <br> SELECT airport_code, <br> ARRAY[airport_code] <br> FROM   airports <br> WHERE  airport_code = 'UKX' <br> UNION ALL <br> SELECT r.arrival_airport, <br> <font color="#009900">(</font> p.hops || r.arrival_airport <font color="#009900">)::char(3)[]</font> <br> FROM   routes r, p <br> WHERE  r.departure_airport = p.last_arrival <br> ) <br> SELECT * <br> FROM   p <br> WHERE  p.last_arrival = ( <br> SELECT airport_code FROM airports WHERE airport_code = 'CNN' <br> ); <br></b></code> <br><br>  There is no more error, but alas - the request has hung.  And now what i can do? <br><br>  We'll figure out.  Let's try to execute our query ‚Äústep by step‚Äù and see what happens at each iteration. <br><br>  It is clear that the focus can be repeated with the first iteration crammed into the table and the gradual addition of new iterations, but this is very dreary, and it is easy to make a mistake.  But there is a better way. <br><br>  Let's add to our query another column with an iteration number (let's call it level).  In the first iteration, it will be equal to one, and then we will increase it.  This in itself does not help, but now we can stop the execution of the request anywhere.  The first two iterations we saw, let's look at the third: <br><br> <code><b>demo=# WITH RECURSIVE p(last_arrival, hops, <font color="#009900">level</font> ) AS ( <br> SELECT airport_code, <br> ARRAY[airport_code], <br> <font color="#009900">1</font> <br> FROM   airports <br> WHERE airport_code = 'UKX' <br> UNION ALL <br> SELECT r.arrival_airport, <br> (p.hops || r.arrival_airport)::char(3)[], <br> <font color="#009900">p.level + 1</font> <br> FROM   routes r, p <br> WHERE  r.departure_airport = p.last_arrival <br> <font color="#009900">AND    p.level &lt; 3</font> <br> ) <br> SELECT * FROM p;</b> <br> <br> last_arrival |     hops      | level <br> --------------+---------------+------- <br> UKX          | {UKX}         |     1 <br> KJA          | {UKX,KJA}     |     2 <br> UKX          | {UKX,KJA,UKX} |     3 <br> OVB          | <font color="#990000">{UKX,KJA,OVB}</font> |     3 <br> OVB          | <font color="#990000">{UKX,KJA,OVB}</font> |     3 <br> NOZ          | {UKX,KJA,NOZ} |     3 <br> NOZ          | {UKX,KJA,NOZ} |     3 <br> AER          | {UKX,KJA,AER} |     3 <br> SVO          | {UKX,KJA,SVO} |     3 <br> NUX          | {UKX,KJA,NUX} |     3 <br> UIK          | {UKX,KJA,UIK} |     3 <br> UIK          | {UKX,KJA,UIK} |     3 <br> BAX          | {UKX,KJA,BAX} |     3 <br> KRO          | {UKX,KJA,KRO} |     3 <br> OVS          | {UKX,KJA,OVS} |     3 <br> (15 ) <br></code> <br><br>  Something unexpected. <br><br>  First, some lines are duplicated (for example, {UKX, KJA, OVB}).  This is, in fact, correct, because there are two different flights from Krasnoyarsk (KJA) to Novosibirsk (OVB): <br><br> <code><b>demo=# SELECT flight_no <br> FROM   routes <br> WHERE  departure_airport = 'KJA' <br> AND    arrival_airport = 'OVB';</b> <br> <br> flight_no <br> ----------- <br> PG0206 <br> PG0207 <br> (2 ) <br></code> <br><br>  Add the flight number to the request to distinguish the lines;  we still need it. <br><br> <code><b>demo=# WITH RECURSIVE p(last_arrival, hops, <font color="#009900">flights,</font> level) AS ( <br> SELECT airport_code, <br> ARRAY[airport_code], <br> <font color="#009900">ARRAY[]::char(6)[],</font> <br> 1 <br> FROM   airports <br> WHERE  airport_code = 'UKX' <br> UNION ALL <br> SELECT r.arrival_airport, <br> (p.hops || r.arrival_airport)::char(3)[], <br> <font color="#009900">(p.flights || r.flight_no)::char(6)[],</font> <br> p.level + 1 <br> FROM   routes r, p <br> WHERE  r.departure_airport = p.last_arrival <br> AND    p.level &lt; 3 <br> ) <br> SELECT * FROM p;</b> <br> <br> last_arrival |     hops      |     flights     | level <br> --------------+---------------+-----------------+------- <br> UKX          | {UKX}         | {}              |     1 <br> KJA          | {UKX,KJA}     | {PG0022}        |     2 <br> UKX          | <font color="#990000">{UKX,KJA,UKX}</font> | {PG0022,PG0021} |     3 <br> OVB          | {UKX,KJA,OVB} | {PG0022,PG0206} |     3 <br> OVB          | {UKX,KJA,OVB} | {PG0022,PG0207} |     3 <br> NOZ          | {UKX,KJA,NOZ} | {PG0022,PG0351} |     3 <br> NOZ          | {UKX,KJA,NOZ} | {PG0022,PG0352} |     3 <br> AER          | {UKX,KJA,AER} | {PG0022,PG0501} |     3 <br> SVO          | {UKX,KJA,SVO} | {PG0022,PG0548} |     3 <br> NUX          | {UKX,KJA,NUX} | {PG0022,PG0623} |     3 <br> UIK          | {UKX,KJA,UIK} | {PG0022,PG0625} |     3 <br> UIK          | {UKX,KJA,UIK} | {PG0022,PG0626} |     3 <br> BAX          | {UKX,KJA,BAX} | {PG0022,PG0653} |     3 <br> KRO          | {UKX,KJA,KRO} | {PG0022,PG0673} |     3 <br> OVS          | {UKX,KJA,OVS} | {PG0022,PG0689} |     3 <br> (15 ) <br></code> <br><br>  But the other oddity is worse.  One of the lines shows that we can fly back: {UKX, KJA, UKX}.  And this means that we will fly in a circle indefinitely, the request will not stop.  Here is the key to freeze. <br><br>  What to do with it?  It is necessary to add a condition that each airport can be visited no more than once (in this case, the route will still not be optimal). <br><br> <code><b>demo=# WITH RECURSIVE p(last_arrival, hops, flights, level) AS ( <br> SELECT airport_code, <br> ARRAY[airport_code], <br> ARRAY[]::char(6)[], <br> 1 <br> FROM   airports <br> WHERE  airport_code = 'UKX' <br> UNION ALL <br> SELECT r.arrival_airport, <br> (p.hops || r.arrival_airport)::char(3)[], <br> (p.flights || r.flight_no)::char(6)[], <br> p.level + 1 <br> FROM   routes r, p <br> WHERE  r.departure_airport = p.last_arrival <br> <font color="#009900">AND    NOT r.arrival_airport = ANY(p.hops)</font> <br> AND    p.level &lt; 3 <br> ) <br> SELECT * FROM p;</b> <br> <br> last_arrival |     hops      |     flights     | level <br> --------------+---------------+-----------------+------- <br> UKX          | {UKX}         | {}              |     1 <br> KJA          | {UKX,KJA}     | {PG0022}        |     2 <br> OVB          | {UKX,KJA,OVB} | {PG0022,PG0206} |     3 <br> OVB          | {UKX,KJA,OVB} | {PG0022,PG0207} |     3 <br> NOZ          | {UKX,KJA,NOZ} | {PG0022,PG0351} |     3 <br> NOZ          | {UKX,KJA,NOZ} | {PG0022,PG0352} |     3 <br> AER          | {UKX,KJA,AER} | {PG0022,PG0501} |     3 <br> SVO          | {UKX,KJA,SVO} | {PG0022,PG0548} |     3 <br> NUX          | {UKX,KJA,NUX} | {PG0022,PG0623} |     3 <br> UIK          | {UKX,KJA,UIK} | {PG0022,PG0625} |     3 <br> UIK          | {UKX,KJA,UIK} | {PG0022,PG0626} |     3 <br> BAX          | {UKX,KJA,BAX} | {PG0022,PG0653} |     3 <br> KRO          | {UKX,KJA,KRO} | {PG0022,PG0673} |     3 <br> OVS          | {UKX,KJA,OVS} | {PG0022,PG0689} |     3 <br> (14 ) <br></code> <br><br>  It seems now order.  Run without limits? <br><br> <code><b>demo=# WITH RECURSIVE p(last_arrival, hops, flights, level) AS ( <br> SELECT airport_code, <br> ARRAY[airport_code], <br> ARRAY[]::char(6)[], <br> 1 <br> FROM   airports <br> WHERE  airport_code = 'UKX' <br> UNION ALL <br> SELECT r.arrival_airport, <br> (p.hops || r.arrival_airport)::char(3)[], <br> (p.flights || r.flight_no)::char(6)[], <br> p.level + 1 <br> FROM   routes r, p <br> WHERE  r.departure_airport = p.last_arrival <br> AND    NOT r.arrival_airport = ANY(p.hops) <br> <font color="#009900">--  AND    p.level &lt; 3</font> <br> ) <br> <font color="#009900">SELECT * <br> FROM   p <br> WHERE  p.last_arrival = ( <br> SELECT airport_code FROM airports WHERE airport_code = 'CNN' <br> );</font> <br></b></code> <br><br>  Formally, now everything should work out ... but the request hangs again, and if you have patience, you may fall with the error "the place for temporary files has ended." <br><br>  Why is that?  And because we have to build all possible paths of arbitrary length from point A, and only at the very end we select those that end at point B. This, to put it mildly, is not the most efficient algorithm.  To understand the scale of the disaster, you can see how many lines are obtained at each step by changing the level limit to: <br><br><pre> eleven
 2 2
 3 14
 4,165
 5 1978
 6 22322
 7 249942
 8 2316063
</pre><br><br>  Well and so on, and each following request works significantly slower than the previous one. <br>  Let's think about what number we expect to see in the answer?  If we had big cities, then, most likely, 2 (with a transfer in Moscow).  In our case, it is expected to add at least another couple on regional flights in order to fly to a major city.  That is somewhere 4 or 5, well, maybe 6. However, the request is not going to stop at eight either: it will reach (if you have enough strength and health) up to a hundred, until it can extend any of the chains! <br><br>  In this case, the algorithm works "in width": first, we add <em>all the</em> paths with a length of 1, then <em>all the</em> paths with a length of 2, and so on.  That is, as soon as we find at least <em>some</em> first path from A to B, this path will be the shortest (in the number of transfers).  The question now is how to stop the search in time. <br><br>  The idea is to set the ‚Äúpath found‚Äù attribute at each step if at least one of the newly constructed paths ends at the destination.  Then we can write down the stop condition. <br><br>  Let's start by adding a destination to the request itself (before that, it only appeared at the very end, when it came to filtering all the results found).  We calculate it at the very beginning, and in the recursive part of the query we simply leave it unchanged: <br><br> <code><b>demo=# WITH RECURSIVE p(last_arrival, <font color="#009900">destination,</font> hops, flights, level) AS ( <br> SELECT a_from.airport_code, <br> <font color="#009900">a_to.airport_code,</font> <br> ARRAY[a_from.airport_code], <br> ARRAY[]::char(6)[], <br> 1 <br> FROM   airports a_from, <font color="#009900">airports a_to</font> <br> WHERE  a_from.airport_code = 'UKX' <br> <font color="#009900">AND    a_to.airport_code = 'CNN'</font> <br> UNION ALL <br> SELECT r.arrival_airport, <br> <font color="#009900">p.destination,</font> <br> (p.hops || r.arrival_airport)::char(3)[], <br> (p.flights || r.flight_no)::char(6)[], <br> p.level + 1 <br> FROM   routes r, p <br> WHERE  r.departure_airport = p.hops[cardinality(p.hops)] <br> AND    NOT r.arrival_airport = ANY(p.hops) <br> AND    p.level &lt; 3 <br> ) <br> SELECT * FROM p;</b> <br> <br> last_arrival | destination |     hops      |     flights     | level <br> --------------+-------------+---------------+-----------------+------- <br> UKX          | CNN         | {UKX}         | {}              |     1 <br> KJA          | CNN         | {UKX,KJA}     | {PG0022}        |     2 <br> OVB          | CNN         | {UKX,KJA,OVB} | {PG0022,PG0206} |     3 <br> OVB          | CNN         | {UKX,KJA,OVB} | {PG0022,PG0207} |     3 <br> NOZ          | CNN         | {UKX,KJA,NOZ} | {PG0022,PG0351} |     3 <br> NOZ          | CNN         | {UKX,KJA,NOZ} | {PG0022,PG0352} |     3 <br> AER          | CNN         | {UKX,KJA,AER} | {PG0022,PG0501} |     3 <br> SVO          | CNN         | {UKX,KJA,SVO} | {PG0022,PG0548} |     3 <br> NUX          | CNN         | {UKX,KJA,NUX} | {PG0022,PG0623} |     3 <br> UIK          | CNN         | {UKX,KJA,UIK} | {PG0022,PG0625} |     3 <br> UIK          | CNN         | {UKX,KJA,UIK} | {PG0022,PG0626} |     3 <br> BAX          | CNN         | {UKX,KJA,BAX} | {PG0022,PG0653} |     3 <br> KRO          | CNN         | {UKX,KJA,KRO} | {PG0022,PG0673} |     3 <br> OVS          | CNN         | {UKX,KJA,OVS} | {PG0022,PG0689} |     3 <br> (14 ) <br></code> <br><br>  Now it is easy to calculate the sign of the found path: it must be set if the last point of the path coincides with the destination for at least one line.  For this we need the bool_or window function (if window functions are something new for you, start with an <a href="https://postgrespro.ru/docs/postgresql/current/tutorial-window">introduction</a> , at the end of which there are references to a more detailed description). <br><br> <code><b>demo=# WITH RECURSIVE p(last_arrival, destination, hops, flights, <font color="#009900">found,</font> level) AS ( <br> SELECT a_from.airport_code, <br> a_to.airport_code, <br> ARRAY[a_from.airport_code], <br> ARRAY[]::char(6)[], <br> <font color="#009900">a_from.airport_code = a_to.airport_code,</font> <br> 1 <br> FROM   airports a_from, airports a_to <br> WHERE  a_from.airport_code = 'UKX' <br> AND    a_to.airport_code = <font color="#009900">'OVB' -- CNN</font> <br> UNION ALL <br> SELECT r.arrival_airport, <br> p.destination, <br> (p.hops || r.arrival_airport)::char(3)[], <br> (p.flights || r.flight_no)::char(6)[], <br> <font color="#009900">bool_or(r.arrival_airport = p.destination) OVER (),</font> <br> p.level + 1 <br> FROM   routes r, p <br> WHERE  r.departure_airport = p.last_arrival <br> AND    NOT r.arrival_airport = ANY(p.hops) <br> AND    p.level &lt; 3 <br> ) <br> SELECT * FROM p;</b> <br> <br> last_arrival | destination |     hops      |     flights     | found | level <br> --------------+-------------+---------------+-----------------+-------+------- <br> UKX          | OVB         | {UKX}         | {}              | f     |     1 <br> KJA          | OVB         | {UKX,KJA}     | {PG0022}        | f     |     2 <br> OVB          | OVB         | {UKX,KJA,OVB} | {PG0022,PG0206} | t     |     3 <br> OVB          | OVB         | {UKX,KJA,OVB} | {PG0022,PG0207} | t     |     3 <br> NOZ          | OVB         | {UKX,KJA,NOZ} | {PG0022,PG0351} | t     |     3 <br> NOZ          | OVB         | {UKX,KJA,NOZ} | {PG0022,PG0352} | t     |     3 <br> AER          | OVB         | {UKX,KJA,AER} | {PG0022,PG0501} | t     |     3 <br> SVO          | OVB         | {UKX,KJA,SVO} | {PG0022,PG0548} | t     |     3 <br> NUX          | OVB         | {UKX,KJA,NUX} | {PG0022,PG0623} | t     |     3 <br> UIK          | OVB         | {UKX,KJA,UIK} | {PG0022,PG0625} | t     |     3 <br> UIK          | OVB         | {UKX,KJA,UIK} | {PG0022,PG0626} | t     |     3 <br> BAX          | OVB         | {UKX,KJA,BAX} | {PG0022,PG0653} | t     |     3 <br> KRO          | OVB         | {UKX,KJA,KRO} | {PG0022,PG0673} | t     |     3 <br> OVS          | OVB         | {UKX,KJA,OVS} | {PG0022,PG0689} | t     |     3 <br> (14 ) <br></code> <br><br>  Here we checked how the request will work for the route from Ust-Kut (UKX) to Novosibirsk (OVB), which, as we already know, has a length of 3. (By the way, for this, you had to change CNN to OVB only in one place - a trifle, but nice.) Everything works! <br><br>  The sign we are calculating and in the non-recursive part of the query.  One could simply write false, but the request would be more universal and would correctly determine the number of transfers from A to A. <br><br>  It remains to add a stop condition and you can run: <br><br> <code><b>demo=# WITH RECURSIVE p(last_arrival, destination, hops, flights, found, level) AS ( <br> SELECT a_from.airport_code, <br> a_to.airport_code, <br> ARRAY[a_from.airport_code], <br> ARRAY[]::char(6)[], <br> a_from.airport_code = a_to.airport_code, <br> 1 <br> FROM   airports a_from, airports a_to <br> WHERE  a_from.airport_code = 'UKX' <br> AND    a_to.airport_code = 'CNN' <br> UNION ALL <br> SELECT r.arrival_airport, <br> p.destination, <br> (p.hops || r.arrival_airport)::char(3)[], <br> (p.flights || r.flight_no)::char(6)[], <br> bool_or(r.arrival_airport = p.destination) OVER (), <br> p.level + 1 <br> FROM   routes r, p <br> WHERE  r.departure_airport = p.last_arrival <br> AND    NOT r.arrival_airport = ANY(p.hops) <br> <font color="#009900">AND    NOT p.found</font> <br> <font color="#009900">--  AND    p.level &lt; 3</font> <br> ) <br> <font color="#009900">SELECT hops, flights <br> FROM   p <br> WHERE  p.last_arrival = p.destination;</font></b> <br> <br> hops          |            flights <br> -----------------------+------------------------------- <br> {UKX,KJA,OVB,MJZ,CNN} | {PG0022,PG0206,PG0390,PG0035} <br> {UKX,KJA,OVB,MJZ,CNN} | {PG0022,PG0207,PG0390,PG0035} <br> {UKX,KJA,SVO,MJZ,CNN} | {PG0022,PG0548,PG0120,PG0035} <br> {UKX,KJA,OVB,MJZ,CNN} | {PG0022,PG0206,PG0390,PG0036} <br> {UKX,KJA,OVB,MJZ,CNN} | {PG0022,PG0207,PG0390,PG0036} <br> {UKX,KJA,SVO,MJZ,CNN} | {PG0022,PG0548,PG0120,PG0036} <br> {UKX,KJA,OVS,LED,CNN} | {PG0022,PG0689,PG0686,PG0245} <br> {UKX,KJA,SVO,LED,CNN} | {PG0022,PG0548,PG0472,PG0245} <br> {UKX,KJA,SVO,LED,CNN} | {PG0022,PG0548,PG0471,PG0245} <br> {UKX,KJA,SVO,LED,CNN} | {PG0022,PG0548,PG0470,PG0245} <br> {UKX,KJA,SVO,LED,CNN} | {PG0022,PG0548,PG0469,PG0245} <br> {UKX,KJA,SVO,LED,CNN} | {PG0022,PG0548,PG0468,PG0245} <br> {UKX,KJA,OVB,PEE,CNN} | {PG0022,PG0206,PG0186,PG0394} <br> {UKX,KJA,OVB,PEE,CNN} | {PG0022,PG0207,PG0186,PG0394} <br> {UKX,KJA,BAX,ASF,CNN} | {PG0022,PG0653,PG0595,PG0427} <br> {UKX,KJA,SVO,ASF,CNN} | {PG0022,PG0548,PG0128,PG0427} <br> {UKX,KJA,OVS,DME,CNN} | {PG0022,PG0689,PG0544,PG0709} <br> {UKX,KJA,OVS,DME,CNN} | {PG0022,PG0689,PG0543,PG0709} <br> {UKX,KJA,KRO,DME,CNN} | {PG0022,PG0673,PG0371,PG0709} <br> {UKX,KJA,OVB,DME,CNN} | {PG0022,PG0206,PG0223,PG0709} <br> {UKX,KJA,OVB,DME,CNN} | {PG0022,PG0207,PG0223,PG0709} <br> {UKX,KJA,NUX,DME,CNN} | {PG0022,PG0623,PG0165,PG0709} <br> {UKX,KJA,BAX,DME,CNN} | {PG0022,PG0653,PG0117,PG0709} <br> (23 ) <br></code> <br><br>  That's all.  We came to the request from the beginning of the article, and it works out instantly.  Now you can remove the "debug" level ... but you can leave. <br><br>  Let's summarize the useful tricks: <br><br><ul><li>  Representing the ‚Äúpath‚Äù as an array helps in many cases.  You can concatenate strings instead, but this is less convenient. </li><li>  Prevent looping (using the same array). </li><li>  Debugging by limiting the number of iterations. </li><li>  Sometimes to improve performance you need a way to stop in time. </li><li>  Using window functions allows you to work wonders. </li></ul><br><h2>  As an exercise </h2><br>  To consolidate the skill, you can perform several variations on the same topic. <br><br><ol><li>  What is the maximum number of transfers you need to get from any airport to any other? <br>  Tip 1: The first part of the request should contain all pairs of airports of departure and arrival. <br>  Tip 2: a sign of the path found must be considered separately for each pair of airports. <br><br></li><li>  Find a path (from UKX to CNN) that is optimal for the total duration of flights (excluding the expectation of transfers). <br>  Tip 1: it may turn out that such a path is not optimal in terms of the number of transplants. <br>  Tip 2: you need to come up with a sign that further search is useless. <br><br></li><li>  Find a path (from UKX to CNN) that is optimal for the total duration of flights <em>, taking into account</em> the waiting time for transfers.  Consider that we are ready for the first flight at the time of <code><b>bookings.now() - interval '20 days'</b></code> . <br></li></ol><br>  When you cope with the third task - share your success with us ( <a href="">edu@postgrespro.ru</a> ).  And we will be happy to present an invitation to <a href="https://pgconf.ru/">PgConf.Russia 2017 to the</a> authors of the solutions you like. </div><p>Source: <a href="https://habr.com/ru/post/318398/">https://habr.com/ru/post/318398/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318388/index.html">Backup network spheres (samba) in Linux based on Windows Server Backup</a></li>
<li><a href="../318390/index.html">How to talk with assholes. 7 strategies for communicating with inappropriate people</a></li>
<li><a href="../318392/index.html">The digest of interesting materials for the mobile # 185 developer (December 19-25)</a></li>
<li><a href="../318394/index.html">Camouflage and video game feedback</a></li>
<li><a href="../318396/index.html">Prefer SRW-blocking to critical sections.</a></li>
<li><a href="../318400/index.html">We search and download unpopular and old files on the Internet</a></li>
<li><a href="../318404/index.html">The digest of fresh materials from the world of frontend for the last week ‚Ññ242 (December 18 - 25, 2016)</a></li>
<li><a href="../318406/index.html">Google: Security Keys - the best way to secure your account</a></li>
<li><a href="../318410/index.html">PHP Digest number 99 - the results of 2016 and a selection of interesting links (December 11 - 25, 2016)</a></li>
<li><a href="../318412/index.html">Algorithm for secretly assigning donors to Secret Santa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>