<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Docker for symfony 4 - from lokalki to production</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prehistory 
 One fine day I needed to deploy a development environment for my project. Vagrant was already pretty fed up and wanted to have a single d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Docker for symfony 4 - from lokalki to production</h1><div class="post__text post__text-html js-mediator-article"><h2>  Prehistory </h2><br>  One fine day I needed to deploy a development environment for my project.  Vagrant was already pretty fed up and wanted to have a single development environment for all project participants that would be identical to the production server.  Accordingly, having heard a lot about the hipster docker, I decided to start working with him.  Next, I will try to describe in as much detail as possible all the steps from installing a docker on LAN to deploying a product on KVM. <br><br>  <b>Initial technology stack:</b> <br><br>  - Docker <br>  - symfony 4 <br>  - nginx <br>  - php-fpm <br>  - postgresql <br>  - elasticsearch <br>  - rabbitmq <br>  - jenkins 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Iron:</b> <br><br>  - a laptop under OS Ubuntu 16.04 <br>  - production server on KVM hosting <br><br>  <i>Why, besides the technological stack, I also listed an iron stack?</i> <br><br>  If you have never worked with a docker before, then you may encounter a number of problems related specifically to hardware, the operating system of your laptop, or the type of virtualization on hosting. <br><br>  The first and probably the most important aspect when you start working with a docker is the operating system of your laptop.  The easiest way to work with the docker is on linux systems.  If you are working on Windows or Mac, then you will have 100% of some difficulties, but these difficulties will not be critical and if you want to ‚Äúgoogle‚Äù how this is corrected will not be any problems. <br><br>  The second question is hosting.  Why do we need Hosting with the type of virtualization KVM?  The reason is that virtualization of VPS is very different from KVM and you can‚Äôt install docker on VPS yourself, because VPS allocates server resources dynamically. <br><br>  Subtotal: for the fastest start on Docker, it is most reasonable to choose Ubuntu as a local OS and KVM hosting (or your own server).  Further, the story will go relying on these two components. <br><a name="habracut"></a><br><h2>  Docker-compose for LAN </h2><br><h3>  Installation </h3><br>  First you need to install the docker locally.  Installation instructions can be viewed on the official website <a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">link to the official documentation for ubuntu</a> (you need to install docker and docker-compose), or by running the command in the console: <br><br><pre><code class="bash hljs">curl -sSl https://get.docker.com/ | sh</code> </pre> <br>  This command will install both docker and docker-compose.  After that check the version of the docker with the command: <br><br><pre> <code class="bash hljs">docker --version</code> </pre> <br>  I run this whole thing on docker version 18.06.0-ce. <br><br>  Installation is complete! <br><br><h3>  Awareness </h3><br>  In order to work with something less successfully, you need to have an idea how it works.  If you have previously worked only with Vagrant or something similar, it will be extremely unusual and incomprehensible at first, but this is only at first. <br><br>  I will try to draw an analogy to Vagrant.  Now many may say that comparing Vagrant and Docker is fundamentally wrong.  Yes, I agree with that, but I‚Äôm not going to compare them, I‚Äôll only try to get to the newbies who worked only with Vagrant, the Docker system, appealing with what the newbies know. <br><br>  My vision of the container "on the fingers" is as follows: each container is a tiny isolated world.  Each container can be imagined as if it is a tiny Vagrant on which only 1 tool is installed, for example, nginx or php.  Initially, containers are generally isolated from everything around, but by not tricky manipulations, you can configure everything so that they communicate with each other and work together.  This does not mean that each of the containers is a separate virtual machine, not at all.  But it is easier for the initial understanding, as it seems to me. <br><br>  Vagrant just bites off some of your resources from your computer, creates a virtual machine, installs an operating system on it, installs libraries, installs everything that you have written in the script after vagrant up.  In the end, it looks like this: <br><br>  ‚Üí <a href="">View shemku</a> <br><br>  Docker, in turn, works radically differently.  It does not create virtual machines.  Docker creates containers (for the time being, you can perceive them as micro-virtual machines) with its Alpine operating system and 1-3 libraries that are necessary for the operation of the application, for example, php or nginx.  At the same time, Docker does not block the resources of your system, but simply uses them as needed.  In the end, if you illustrate, it will look something like this: <br><br>  ‚Üí <a href="">View shemku</a> <br><br>  Each of the containers has an image from which it is created.  The overwhelming part of the images is an extension of another image, for example, Ubuntu xenial or Alpine or Debian, to which additional drivers and other components roll over. <br><br>  My first image was for php-fpm.  My image extends the official php image: 7.2-fpm-alpine3.6.  That is, in fact, he takes the official image and delivers the components I need, for example, pdo_pgsql, imagick, zip, and so on.  Thus, you can create an image that is right for you.  If you wish, you can use it <a href="https://hub.docker.com/r/otezvikentiy/php7.2-fpm/">here</a> . <br><br>  With the creation of images, everything is quite simple in my opinion, if they are made on the basis of xenial for example, but deliver a little hemorrhoids, if they are made on the basis of Alpine.  Before working with the docker, I didn‚Äôt even hear about Alpine, since I always worked with Vagrant under Ubuntu xenial.  Alpine is an empty Linux operating system, which is essentially nothing at all (at least).  Therefore, at first it is extremely inconvenient to work with it, since there is no such as the same apt-get install (which you get used to), but there is only apk add and not quite sane set of packages.  A big plus to Alpine is its weight, for example, if Xenial weighs (abstract) 500 bags, then Alpine (abstract) is about 78 bags.  What does this even affect?  And this affects the speed of assembly and the final weight of all the images that will be stored on your server in the end.  Suppose you have 5 different containers and all on the basis of xenial, their total weight will be more than 2.5 gigabytes, and alpine - about 500 bags only.  Therefore, ideally, we should strive to ensure that the containers are as thin as possible.  (Useful link for installing packages in Alpine - <a href="https://pkgs.alpinelinux.org/packages">Alpine packages</a> ). <br><br>  Everywhere they write on the <a href="https://hub.docker.com/">docker hub</a> how to start the container using the <code>docker run</code> , and for some reason they don‚Äôt write how it can be run through docker-compose, and it is through docker-compose that it will run most of the time, since few people want to manually start all containers, grids, ports open and so on.  Docker-compose on behalf of the user looks like a yaml file with settings.  It includes a description of each of the services that need to be launched.  My build for the local environment looks like this: <br><br><pre> <code class="hljs kotlin">version: <span class="hljs-string"><span class="hljs-string">'3.1'</span></span> services: php-fpm: image: otezvikentiy/php7.2-fpm:<span class="hljs-number"><span class="hljs-number">0.0</span></span>.11 ports: - <span class="hljs-string"><span class="hljs-string">'9000:9000'</span></span> volumes: - ../:/app working_dir: /app container_name: <span class="hljs-string"><span class="hljs-string">'php-fpm'</span></span> nginx: image: nginx:<span class="hljs-number"><span class="hljs-number">1.15</span></span>.0 container_name: <span class="hljs-string"><span class="hljs-string">'nginx'</span></span> working_dir: /app ports: - <span class="hljs-string"><span class="hljs-string">'7777:80'</span></span> volumes: - ../:/app - ./nginx/nginx.conf:/etc/nginx/conf.d/<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>.conf postgres: image: postgres:<span class="hljs-number"><span class="hljs-number">9.6</span></span> ports: - <span class="hljs-string"><span class="hljs-string">'5432:5432'</span></span> container_name: <span class="hljs-string"><span class="hljs-string">'postgresql'</span></span> working_dir: /app restart: always environment: POSTGRES_DB: <span class="hljs-string"><span class="hljs-string">'db_name'</span></span> POSTGRES_USER: <span class="hljs-string"><span class="hljs-string">'db_user'</span></span> POSTGRES_PASSWORD: <span class="hljs-string"><span class="hljs-string">'db_pass'</span></span> volumes: - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/dump:/app/dump - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/postgresql:/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/lib/postgresql/<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> rabbitmq: image: rabbitmq:<span class="hljs-number"><span class="hljs-number">3.7</span></span>.5-management working_dir: /app hostname: rabbit-mq container_name: <span class="hljs-string"><span class="hljs-string">'rabbit-mq'</span></span> ports: - <span class="hljs-string"><span class="hljs-string">'15672:15672'</span></span> - <span class="hljs-string"><span class="hljs-string">'5672:5672'</span></span> environment: RABBITMQ_DEFAULT_USER: user RABBITMQ_DEFAULT_PASS: password RABBITMQ_DEFAULT_VHOST: my_vhost elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:<span class="hljs-number"><span class="hljs-number">6.3</span></span>.0 container_name: <span class="hljs-string"><span class="hljs-string">'elastic-search'</span></span> environment: - discovery.type=single-node - <span class="hljs-string"><span class="hljs-string">"discovery.zen.ping.unicast.hosts=elasticsearch"</span></span> - bootstrap.memory_lock=<span class="hljs-literal"><span class="hljs-literal">true</span></span> - <span class="hljs-string"><span class="hljs-string">"ES_JAVA_OPTS=-Xms512m -Xmx512m"</span></span> ports: - <span class="hljs-number"><span class="hljs-number">9200</span></span>:<span class="hljs-number"><span class="hljs-number">9200</span></span> - <span class="hljs-number"><span class="hljs-number">9300</span></span>:<span class="hljs-number"><span class="hljs-number">9300</span></span> working_dir: /app volumes: - ../:/app - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/elasticsearch:/usr/share/elasticsearch/<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> volumes: elasticsearch: postgresql:</code> </pre><br>  docker-compose.yaml for SF4 is a specific set of services: nginx, php-fpm, postgresql, rabbitmq (if you need it), elasticsearch (if you need it).  For the local environment, this is enough.  To make it all work, there is a minimum set of settings, without which nothing will work.  Most often it is image, volumes, ports, environment, working_dir and container_name.  Everything for launching an image is described in its documentation on <a href="https://hub.docker.com/">hub.docker.com</a> .  There is not always a description for docker-compose, but this does not mean that it does not work with it.  You just need to transfer all the incoming data from the docker run command to docker-compose and it will work. <br><br>  For example, there is an image for RabbitMQ <a href="https://hub.docker.com/_/rabbitmq/">here</a> .  When you see THIS for the first time - it causes mixed feelings and emotions, but not everything is so scary.  This image shows tags.  Usually tags - represent different images, different versions of the application with different extensible images.  For example, the tag 3.7.7-alpine means that this image is thinner than, for example, 3.7.7, as it is made on the basis of Alpine.  Well and also in tags are indicated most often the version of the application itself.  I usually choose the most recent version and the stable version of the application itself and the alpine image. <br><br>  After you have studied and selected the tag - then you often see something of this kind: <br><br><pre> <code class="bash hljs">docker run -d --hostname my-rabbit --name some-rabbit -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password rabbitmq:3-management</code> </pre> <br>  And the first thought is WTF?  How to transfer it to docker-compose? <br><br>  It's pretty not difficult.  In fact, this line contains all the same parameters as in the yaml file, only abbreviated.  For example, -e is an environment to which various parameters are passed, there can also be entries of type -p ‚Äî these are ports, which in yaml are called ports.  Accordingly, in order to qualitatively use an unfamiliar image, you just need to ‚Äúgoogle‚Äù the abbreviations of the docker run commands and apply the full names in the yaml file. <br><br>  Now back to docker-compose.yml, which I gave in the sample above. <br><br>  This example uses my image for php7.2 made as an extension for the official image php7.2-fpm-alpine, but if you do not need so many additional libraries, then you can build your extension for the official image and use it.  The rest of the images for LAN I use completely original and official. <br><br>  <b>image</b> - we specify what image to download.  For example (rabbitmq: 3.7.7-management-alpine). <br><br>  <b>ports</b> - specify the ports that the container will use (see the image documentation).  Sample port nginx is 80 by default.  Accordingly, if you want to use port 80, then you must specify 80:80 and your site will be available on localhost.  Or you can specify 7777: 80, and then your site will be url localhost: 7777.  This is necessary so that several projects can be deployed on the same host. <br><br>  <b>volumes</b> - the shared directories are indicated here.  For example, your project is in the ~ / projects / my-sf4-app directory, and the php container is configured to work with the / app directory (the same as in the / var / www / my-sf4-app version).  Accordingly, it would be convenient for the container to have access to the project.  Accordingly, in volumes we prescribe <code>~/projects/my-sf4-app:/app</code> (see this example in docker-compose.yml above (this is indicated by a relative path ../:/app)). <br><br>  Thus, the folder will be shared with the container and it will be able to perform various actions like <code>php bin/console doctrine:migrations:migrate</code> .  It is also convenient to use these directories in order to save application data.  For example, postgresql, you can specify the directory for storing database data, and then during the re-creation of the container you will not need to roll out a dump or fixtures. <br><br>  <b>working_dir</b> - specifies the working directory of the container.  In this case, / app (or by analogy with the / var / www / my-sf4-app). <br><br>  <b>environment</b> - all variables for the container are transferred here.  For example, for rabbitmq, the username and password are transmitted, for postgresql, the base name, username, password are transmitted. <br><br>  <b>container_name</b> is not a required field, but I prefer to specify, for easy connection to containers.  If you do not specify, then the names will be assigned by default with hashes. <br><br>  These are the basic parameters that must be specified.  The rest can be optional for additional settings, or according to the documentation for the container. <br><br>  Now, in order to run all this, you need to run the command <code>docker-compose up -d</code> in the directory where the docker-compose file is located. <br><br><h3>  How and where does all this store for LAN? </h3><br>  For lokalki I use the docker folder in the root of the project. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pv/rg/a8/pvrga87xk7vcujz2-qwbjnqmtjk.png"></div><br>  It contains the data folder in which I store all the postgresql and elasticsearch information so that when re-creating a project, you do not have to roll fixtures from scratch.  There is also a nginx daddy in which I store the config for the local nginx container.  I synchronize these folders in docker-compose.yml with the corresponding files and folders in the containers.  Also in my opinion it is very convenient to write bash scripts to work with the docker.  For example, the start.sh script starts containers, then runs composer install, cleans the cache, and migrates.  For colleagues on the project, it‚Äôs just as convenient, they don‚Äôt have to do anything, they just run the script and everything works. <br><br>  Example script <i>start.sh</i> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash green=$(tput setf 2) toend=$(tput hpa $(tput cols))$(tput cub 6) echo -n '   ?: ' read name echo "  $name!       tutmesto.ru" echo -n "$name,      ? (y/n): " read use_dump echo '    !' docker-compose up -d || exit echo -en '\n' echo -n "  ! ${green}${toend}[OK]" echo -en '\n' echo '    .' ./composer-install.sh echo -en '\n' echo -n "   ${green}${toend}[OK]" echo -en '\n' echo '     40 ,    postgres-' sleep 5 echo '  35 ...' sleep 5 echo '  30 ...' sleep 5 echo '  25 ...' sleep 5 echo '  20 ...' sleep 5 echo '  15 ...' sleep 5 echo '  10 ...' sleep 5 echo '  5 ...' sleep 5 echo ' .   postgres-        !' case "$use_dump" in y|Y) ./dump.sh echo -en '\n' echo -n "  ! ${green}${toend}[OK]" echo -en '\n' ;; *) echo "$name, ,   ! =)" ;; esac echo '    !' ./migrations-migrate.sh echo -en '\n' echo -n "  ! ${green}${toend}[OK]" echo -en '\n' echo '  !' ./php-fpm-command.sh rm -rf var/cache/* ./php-fpm-command.sh chmod 777 var/ -R ./cache-clear.sh echo -en '\n' echo -n "  ! ${green}${toend}[OK]" echo -en '\n' echo '    !' ./env.sh echo -en '\n' echo -n "   ! ${green}${toend}[OK]" echo -en '\n' echo ", $name,    !    localhost:7777  !" echo -en '\n' echo "------------------------------------------------------------------------------" echo -en '\n' echo "    :" echo "./cache-clear.sh |  symfony 4" echo "./composer.sh [command(ex. install)] |  " echo "./composer-install.sh | composer install" echo "./connect-to-php-fpm.sh |   php" echo "./console.sh [command(ex. cache:clear)] |  php bin/console" echo "./destroy.sh |  .    ." echo "./dump.sh | ,     (dump.sql)" echo "./env.sh |   " echo "./migrations-migrate.sh | " echo "./php-fpm-command.sh [command(ex. php -m)] |   php-fpm " echo "./start.sh |  ( )" echo "./stop.sh |Gracefull shutdown " echo -en '\n' echo "        :" echo "client@c.cc | QWEasd123" echo "admin@a.aa | QWEasd123" echo "moderator@m.mm | QWEasd123" echo -en '\n' echo "------------------------------------------------------------------------------" echo -en '\n' echo -en '\n' echo 'OtezVikentiy brain corporation!' echo -en '\n' echo -en '\n'</span></span></code> </pre><br>  Sample <i>php-fpm-command.sh</i> script <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash cd "`dirname \"$0\"`" &amp;&amp; \ docker-compose exec -T "php-fpm" sh -c "cd /app &amp;&amp; $*"</span></span></code> </pre><br>  Example script <i>connect-to-php-fpm.sh</i> <br><br><pre> <code class="bash hljs"><span class="hljs-meta"><span class="hljs-meta">#!/usr/bin/env bash docker exec -i -t --privileged php-fpm bash</span></span></code> </pre><br>  The local development environment ends there.  Congratulations, you can share with your colleagues the finished result!  ) <br><br><h2>  Productive </h2><br><h3>  Training </h3><br>  Suppose you have already written something on LAN and want to put it on a production server or on a test server.  You have hosting on KVM virtualization or your server in the next room with air conditioning. <br><br>  To deploy a product or beta, the server should have an operating system (ideally linux) and an installed docker.  Docker can be installed exactly the same as on LAN, no difference. <br><br>  Docker in a product differs from a lokalka a little.  First, you can no longer just take and specify passwords and other information and docker-compose.  Secondly, you cannot use docker-compose directly. <br><br>  Docker for a product uses docker swarm and docker stack.  If it is right on the fingers, then this system differs only in other commands and in that docker swarm is the load balancer for the cluster (again, a little abstract, but it will be easier to understand). <br><br>  PS: I advise you to practice setting up a docker swarm on Vagrant (no matter how paradoxical it sounds).  A simple recipe for training - pick up an empty Vagrant with the same operating system as in production and set it up to start. <br><br>  To configure docker swarm, you just need to run a few commands: <br><br><pre> <code class="bash hljs">docker swarm init --advertise-addr 192.168.***.** (ip-  ) mkdir /app (          app) chown docker /app (     ) docker stack deploy -c docker-compose.yml my-first-sf4-docker-app</code> </pre><br>  Consider now all this a little more. <br><br>  <b>docker swarm init --advertise-addr</b> - it launches docker swarm itself and fumbles the link itself so that you can hook up another server to this ‚Äúswarm‚Äù so that they work in a cluster. <br>  <b>mkdir / app &amp;&amp; chown ..</b> - it is necessary to create in advance all the necessary directories for the work of the docker, so that during the build it would not complain about the absence of directories. <br>  <b>docker stack deploy -c docker-compose.yml my-first-sf4-docker-app</b> - this command starts the build of your application itself, analogous to docker-compose up -d for docker swarm only. <br><br>  In order for any build to begin, you need the same docker-compose.yaml, but already slightly modified just for the production / beta. <br><br><pre> <code class="hljs javascript">version: <span class="hljs-string"><span class="hljs-string">'3.1'</span></span> services: php-fpm: image: otezvikentiy/php7<span class="hljs-number"><span class="hljs-number">.2</span></span>-fpm:<span class="hljs-number"><span class="hljs-number">0.0</span></span><span class="hljs-number"><span class="hljs-number">.11</span></span> ports: - <span class="hljs-string"><span class="hljs-string">'9000:9000'</span></span> networks: - my-test-network depends_on: - postgres - rabbitmq volumes: - <span class="hljs-regexp"><span class="hljs-regexp">/app:/</span></span>app working_dir: <span class="hljs-regexp"><span class="hljs-regexp">/app deploy: replicas: 1 restart_policy: condition: on-failure placement: constraints: [node.role == manager] nginx: image: nginx:1.15.0 networks: - my-test-network working_dir: /</span></span>app ports: - <span class="hljs-string"><span class="hljs-string">'80:80'</span></span> depends_on: - php-fpm volumes: - <span class="hljs-regexp"><span class="hljs-regexp">/app:/</span></span>app - ./nginx/nginx.conf:<span class="hljs-regexp"><span class="hljs-regexp">/etc/</span></span>nginx/conf.d/<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>.conf deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on-failure placement: constraints: [node.role == manager] postgres: image: postgres:<span class="hljs-number"><span class="hljs-number">9.6</span></span> ports: - <span class="hljs-string"><span class="hljs-string">'5432:5432'</span></span> working_dir: <span class="hljs-regexp"><span class="hljs-regexp">/app networks: - my-test-network secrets: - postgres_db - postgres_user - postgres_pass environment: POSTGRES_DB_FILE: /</span></span>run/secrets/postgres_db POSTGRES_USER_FILE: <span class="hljs-regexp"><span class="hljs-regexp">/run/</span></span>secrets/postgres_user POSTGRES_PASSWORD_FILE: <span class="hljs-regexp"><span class="hljs-regexp">/run/</span></span>secrets/postgres_pass volumes: - ./data/dump:<span class="hljs-regexp"><span class="hljs-regexp">/app/</span></span>dump - ./data/postgresql:<span class="hljs-regexp"><span class="hljs-regexp">/var/</span></span>lib/postgresql/data deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on-failure placement: constraints: [node.role == manager] rabbitmq: image: rabbitmq:<span class="hljs-number"><span class="hljs-number">3.7</span></span><span class="hljs-number"><span class="hljs-number">.5</span></span>-management networks: - my-test-network working_dir: <span class="hljs-regexp"><span class="hljs-regexp">/app hostname: my-test-sf4-app-rabbit-mq volumes: - /</span></span>app:<span class="hljs-regexp"><span class="hljs-regexp">/app ports: - '5672:5672' - '15672:15672' secrets: - rabbitmq_default_user - rabbitmq_default_pass - rabbitmq_default_vhost environment: RABBITMQ_DEFAULT_USER_FILE: /</span></span>run/secrets/rabbitmq_default_user RABBITMQ_DEFAULT_PASS_FILE: <span class="hljs-regexp"><span class="hljs-regexp">/run/</span></span>secrets/rabbitmq_default_pass RABBITMQ_DEFAULT_VHOST_FILE: <span class="hljs-regexp"><span class="hljs-regexp">/run/</span></span>secrets/rabbitmq_default_vhost deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on-failure placement: constraints: [node.role == manager] elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:<span class="hljs-number"><span class="hljs-number">6.3</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> networks: - my-test-network depends_on: - postgres environment: - discovery.type=single-node - discovery.zen.ping.unicast.hosts=elasticsearch - bootstrap.memory_lock=<span class="hljs-literal"><span class="hljs-literal">true</span></span> - ES_JAVA_OPTS=-Xms512m -Xmx512m ports: - <span class="hljs-number"><span class="hljs-number">9200</span></span>:<span class="hljs-number"><span class="hljs-number">9200</span></span> - <span class="hljs-number"><span class="hljs-number">9300</span></span>:<span class="hljs-number"><span class="hljs-number">9300</span></span> working_dir: <span class="hljs-regexp"><span class="hljs-regexp">/app volumes: - /</span></span>app:<span class="hljs-regexp"><span class="hljs-regexp">/app - ./</span></span>data/elasticsearch:<span class="hljs-regexp"><span class="hljs-regexp">/usr/</span></span>share/elasticsearch/data deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on-failure placement: constraints: [node.role == manager] jenkins: image: otezvikentiy/jenkins:<span class="hljs-number"><span class="hljs-number">0.0</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span> networks: - my-test-network ports: - <span class="hljs-string"><span class="hljs-string">'8080:8080'</span></span> - <span class="hljs-string"><span class="hljs-string">'50000:50000'</span></span> volumes: - <span class="hljs-regexp"><span class="hljs-regexp">/app:/</span></span>app - ./data/jenkins:<span class="hljs-regexp"><span class="hljs-regexp">/var/</span></span>jenkins_home - <span class="hljs-regexp"><span class="hljs-regexp">/var/</span></span>run/docker.sock:<span class="hljs-regexp"><span class="hljs-regexp">/var/</span></span>run/docker.sock - <span class="hljs-regexp"><span class="hljs-regexp">/usr/</span></span>bin/docker:<span class="hljs-regexp"><span class="hljs-regexp">/usr/</span></span>bin/docker deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on-failure placement: constraints: [node.role == manager] volumes: elasticsearch: postgresql: jenkins: networks: my-test-network: secrets: rabbitmq_default_user: file: ./secrets/rabbitmq_default_user rabbitmq_default_pass: file: ./secrets/rabbitmq_default_pass rabbitmq_default_vhost: file: ./secrets/rabbitmq_default_vhost postgres_db: file: ./secrets/postgres_db postgres_user: file: ./secrets/postgres_user postgres_pass: file: ./secrets/postgres_pass</code> </pre><br>  As you can see - the file with the settings for the product is slightly different from the file for LAN.  It added secrets, deploy and networks. <br><br>  <b>secrets</b> - files for storing keys.  Keys are pretty simple to create.  You create a file with the name of the key - write the value inside.  After that, you specify the secrets section in docker-compose.yml and transfer to it the entire list of files with keys.  <a href="https://docs.docker.com/engine/swarm/secrets/">More details</a> . <br>  <b>Networks</b> - this will create some kind of internal grid through which containers communicate with each other.  On LAN, this is done automatically, but on a production basis, it needs to be done a little by hand.  Plus, you can specify additional settings other than default.  <a href="https://docs.docker.com/network/">More details</a> . <br>  <b>deploy</b> is the main difference between locale and product / beta. <br><br><pre> <code class="hljs pgsql"> deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>-failure placement: constraints: [node.<span class="hljs-keyword"><span class="hljs-keyword">role</span></span> == manager]</code> </pre><br>  Minimum fighter set: <br><br>  <b>replicas</b> - specify the number of replicas that you want to run (in fact, this is used if you have a cluster and you use the load balancer from the docker).  For example, you have two servers and you connected them through docker swarm.  Pointing here the number 2, for example, 1 instance you will have created on 1 server, and the second on the second server.  Thus, the load on the server will be divided in half. <br>  <b>restart_policy</b> - the policy of automatic "re-raising" the container in case it fell down for some reason. <br>  <b>placement</b> is the location of the container instance.  For example, there are cases when you want all container instances to rotate exactly on 1 out of 5 servers, and not to be distributed between them. <br><br>  <a href="https://docs.docker.com/compose/compose-file/">I want to read the documentation!</a> <br><br>  So, we have a little bit to understand what distinguishes docker-compose.yaml for lokalki from the version for productive / beta.  Now let's try to run this thing. <br><br> <i>,    Vagrant'             docker-compose.yml</i> <br><br><pre> <code class="bash hljs">sudo apt-get update sudo apt-get -y upgrade sudo apt-get install -y language-pack-en-base <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> LC_ALL=en_US.UTF-8 <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> LANGUAGE=en_US.UTF-8 <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> LANG=en_US.UTF-8 curl -sSl https://get.docker.com/ | sh sudo usermod -aG docker ubuntu sudo apt-get install git sudo docker swarm init --advertise-addr 192.168.128.77 sudo mkdir /app sudo chmod 777 /app -R docker stack deploy -c /docker-compose.yml my-app git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git@bitbucket.org:JohnDoe/my-app.git /app docker stack ps my-app docker stack ls docker stack services my-app</code> </pre><br> <b>PS:</b>    sudo  777,       .     . <br><br> ,        . <br>    ¬´¬ª (docker swarm). <br>   ,   . <br>       SF4   /app. <br>     : ps, ls  services. <br><br>    - .     ps,         ,  ,   . <br><br> ,    ,  -         docker stack ps my-app    .       docker container ps -a ‚Äî     ,   .         ,  my-app_php-fpm.1.*-  hash*. <br><br> , ,    ‚Äî  docker logs my-app_php-fpm.1.*-  hash*   .     .       : <br><br><pre> <code class="bash hljs">docker stack rm my-app</code> </pre> <br>       swarm  - .   ‚Äî   docker stack deploy -c docker-compose.yml my-app. </div><p>Source: <a href="https://habr.com/ru/post/420673/">https://habr.com/ru/post/420673/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420663/index.html">Simple metrics and a way to save time when searching for problems in the infrastructure</a></li>
<li><a href="../420665/index.html">Creating an application on .NET Core and Kubernetes: our experience</a></li>
<li><a href="../420667/index.html">How does the EIGRP protocol work?</a></li>
<li><a href="../420669/index.html">Overview of the enterprise automation market: solutions for construction and management companies in the housing and utilities sector</a></li>
<li><a href="../420671/index.html">[Yekaterinburg, Announcement] UralJS # 9 - three reports on microservices, testing and logging errors on the front</a></li>
<li><a href="../420675/index.html">SOC is people. ‚ÄúHello, we are looking for talents‚Äù or where do analysts from the center for monitoring and responding to cyber attacks come from</a></li>
<li><a href="../420677/index.html">The tale of how the Epson planet 30 million "Factories" provided</a></li>
<li><a href="../420679/index.html">New Python courses from Mail.Ru Group</a></li>
<li><a href="../420681/index.html">AMD ThreadRipper 2: First Meet</a></li>
<li><a href="../420685/index.html">To fix and neutralize: how we tamed silver. A word about bactericides for water</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>