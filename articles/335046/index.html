<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>In the footsteps of Petya: find and exploit a software vulnerability</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sensational events of recent months clearly show how urgent the problem of critical software vulnerabilities is. Mass attacks against users using encr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>In the footsteps of Petya: find and exploit a software vulnerability</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/web/c81/fa1/43a/c81fa143ad644823bc46baad00fb208b.jpg" alt="image"></div><br>  Sensational events of recent months clearly show how urgent the problem of critical software vulnerabilities is.  Mass attacks against users using encryption viruses <a href="http://malware.wikia.com/wiki/WannaCry">WannaCry</a> and <a href="https://www.avast.ru/c-petya">Petya were</a> carried out by remotely exploiting zero-day vulnerabilities in Windows network services - SMBv1 and SMBv2.  Finding and exploiting vulnerabilities for remote code execution is obviously not an easy task.  However, the best of the best information security experts can do it all! <br><br>  In one of the tasks of the on <a href="http://neoquest.ru/timeline.php%3Fyear%3D2017%26part%3D2">-site tour of NeoQuest-2017,</a> it was necessary to find vulnerabilities in the program interpreter of commands accessible over the network, and with the help of their operation, execute the code on a remote server.  To prove the hacking, it was necessary to read the contents of the file directory on the server - there, by condition, the task key was placed.  The participants had access to a binary interpreter file.  So, the ice has broken! <br><a name="habracut"></a><br><h2>  We start the study </h2><br>  First, <a href="https://yadi.sk/d/xH09BX973Lp6mp">launch the binary</a> and see what it is.  It becomes clear that the executable file of the PE format interpreter is intended for the Intel x64 architecture.  It is also clear that it is compiled with <a href="https://blogs.technet.microsoft.com/srd/2010/12/08/on-the-effectiveness-of-dep-and-aslr/">DEP / ASLR</a> support, but without <a href="https://msdn.microsoft.com/ru-ru/library/windows/desktop/mt637065%2528v%3Dvs.85%2529.aspx">CFG</a> .  Third-party libraries are also not loaded. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/920/280/444/920280444f514378b03b9b09fab71e7e.jpg"></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The program itself is a simple interpreter of commands for working with an integer vector.  The syntax of the supported commands is available at the entrance to the program.  The vector supports writing and reading values ‚Äã‚Äãfrom cells, writing to a vector entirely. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/968/f03/bdf/968f03bdf1ee46e7a5a95a42cd0d7dea.jpg"></div><br><br>  With surface analysis finished, it's time to reverse - a full-time tour, time is running out! <br><br><h2>  And what to submit to the entrance? </h2><br>  The first intermediate task that needs to be addressed is the precise definition of <a href="https://www.owasp.org/index.php/Attack_Surface_Analysis_Cheat_Sheet">the attack surface</a> .  We specify the number and format of commands by loading the binary into IDA Pro.  The <b><i>main</i></b> function is easily found by searching for the displayed lines. <br><br>  The analysis of the <b><i>main</i></b> function allows us to state the following: <br><br>  1. 1. First, the address of the array <i><b>array</b></i> on the stack of the <b><i>main</i></b> function is stored in the variable <b><i>array_base</i></b> .  In a loop, the array cells are initialized with zeros.  The condition for exiting the loop allows you to know the size of the array - 100 (0x64) integer cells. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/190/da1/7d5/190da17d5b124c24bdda51f26c728ff3.jpg"></div><br><br>  2. 2. The welcome screen is displayed and the user's command is read.  The presence of the lines <b><i>‚Äúcls‚Äù</i></b> and <b><i>‚Äúwhoami‚Äù</i></b> indicates the calling of the function <b><i>system</i></b> (in the future, this will come in handy for us). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/7aa/49d/030/7aa49d030a9c49f8b8403ff856cf6d63.jpg"></div><br><br>  3. Variable expressions are initialized to check the syntax correctness.  It is seen that there are no undocumented commands.  In addition, it becomes clear the set of permissible parameters for each instruction. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/654/307/690/654307690a3a4c1b868579bb63d6119c.jpg"></div><br><br>  4. Consistently in an infinite loop, the entered command is checked for compliance with regular expressions.  If a match is found for a command, the arguments of the command are calculated and its handler is called. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/112/7f1/d2d/1127f1d2dce7435db539eda324902225.jpg"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/8b2/85e/220/8b285e2202a343a5a53f587aa92caf0f.jpg"></div><br><br>  As a result of the analysis of the <b><i>main</i></b> function code, it was found that there are no undocumented commands.  It is possible to influence the following parameters: <br><br><ul><li>  indexes in the <b><i>set / get</i></b> commands; </li><li>  put value in the <b><i>set</i></b> command; </li><li>  The size and contents of the buffer to write to the array. </li></ul><br>  Due to the presence of ASLR and DEP protection mechanisms, 2 vulnerabilities need to be found and implemented: <br><br><ul><li>  Address expansion vulnerability in executable memory ‚Äî to bypass the ASLR and build a ROP chain with a DEP bypass; </li><li>  vulnerability to intercept control flow at the address we control ‚Äî to transfer control to the beginning of the ROP chain and execute code. </li></ul><br>  ROP (Return Oriented Programming) is a modern exploitation technique aimed at circumventing the DEP protection mechanism.  The essence of this technique lies in reusing small fragments (gadgets) of executable memory before <b><i>ret</i></b> instructions.  Chained addresses of gadgets are sequentially removed from the stack, executing commands in the gadget up to the <b><i>ret</i></b> command.  She, in turn, removes from the stack the address of the next gadget, etc. <br><br><h2>  Vulnerability # 1 </h2><br>  Now we know that the target array has a constant size and is located on the stack of the <b><i>main</i></b> function.  Let's try to read a cell with an index that goes beyond the array. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/18b/278/e5c/18b278e5ccd147bbb364a5c021620122.jpg"></div><br><br>  First, at values ‚Äã‚Äãlarger than the array size, we observe normal behavior ‚Äî output with an error message.  However, when the values ‚Äã‚Äãof the index are larger than 2147483647, the program either falls or returns some values. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/3b9/02d/81f/3b902d81f083475cb79043b060bdcf51.jpg"></div><br><br>  It seems that the indices, which are treated as negative numbers, pass the bounds checking and return the contents of the memory at a negative index outside the bounds of the array.  Vulnerability found! <br><br>  Why it happens?  The vulnerability lies in the incorrect processing of the index commands <b><i>set / get</i></b> .  The numeric index in the array is read as a parameter of the <b><i>set</i></b> command and converted from string to numeric form by calling <b><i>stoul</i></b> .  This function returns an <b>unsigned integer</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/e2a/aa0/0b1/e2aaa00b1321482f9dfbd861110e54e3.jpg"></div><br><br>  However, when a parameter is passed to the <b><i>SET / GET</i></b> function, the same value is erroneously reduced <b>to the</b> significant <b>integer</b> y - it is compared with the size of the array and affects the result of the signed comparison command <b><i>jl</i></b> .  The <b><i>GET</i></b> command <b><i>returns the</i></b> value of the memory cell counted from the beginning of the array. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/ce5/7f5/e8f/ce57f5e8fcc04243b48d1333f5f6f664.jpg"></div><br><br>  This feature can be used to read from the memory of any executable address.  Since the array is located on the stack, by reading the cells of the array with negative indices we can view the contents of the stack before the array is located in it.  Since the architecture is x64, addresses in memory occupy 8 bytes.  Reading from the array is carried out by 4 bytes.  Therefore, to read the address from memory, you must print two consecutive cells. <br><br>  Using the debugger, we experimentally find such memory cells in front of the buffer where the executable address is located ‚Äî for example, 4294967282 == -14 and 4294967283 == -13.  We further use their meanings when building the ROP chain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/0a8/56a/469/0a856a469f1f4d8d9f4d0bf7a66c23fd.jpg"></div><br><br>  In addition, in the future, during operation, we need the address of the buffer on the stack.  How to find it?  Let's look at the beginning of the <b><i>main</i></b> function and see that the variable <b><i>array_base</i></b> stores a pointer to the beginning of the buffer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/02f/e97/2ea/02fe972eab704f1c9db914a5776ab8fb.jpg"></div><br><br>  On the stack, this variable is located at rsp + 0x358-0x328, and the buffer itself starts at rsp + 0x358-0x198. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/e62/f89/d97/e62f89d9771149fe8dd584abc7a73cfe.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/web/28f/be9/2a3/28fbe92a3eb848aaab2fb283f6f5f091.jpg"></div><br><br>  Therefore, it is necessary to retreat (0x328-0x198) / 4 = 100 four-byte cells from the beginning of the array to read the variable <b><i>array_base</i></b> .  Seeking offsets: 4294967196, 4294967197. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/9f0/459/2d9/9f04592d9e6c46b68c92d5157f614fc2.jpg"></div><br><br>  Due to this vulnerability, we opened the executable address in the process memory, and also found the address of the required buffer to accommodate the parameters of the ROP chain.  Now you need to find a way to intercept the control flow of the program. <br><br><h2>  Vulnerability # 2 </h2><br>  Until now, we have not investigated the <b><i>load</i></b> interpreter function.  Let's look at it more closely.  Very soon there is a classic buffer overflow on the stack.  The string entered from the keyboard, the argument of the <b><i>load</i></b> command, is selected and transmitted as the first parameter of the <b><i>LOAD</i></b> handler function.  The second parameter is the address of the required buffer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/f53/ec1/ce6/f53ec1ce60864c1bbf82c0db844f3756.jpg"></div><br><br>  The LOAD function writes the buffer to this buffer without any checks on its size.  As you can see, the number of bytes written depends only on the size of the input string. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/4ea/dd0/334/4eadd0334b6542d4a037ae164bf3e6a6.jpg"></div><br><br>  Having transferred a sufficiently large number of characters to the <b><i>load</i></b> command, it is possible to rewrite the return address on the stack and, with the exit from the interpreter, transfer control to the address we control.  Taking into account the size and location of the buffer on the stack, the primary control transfer address must be placed with an offset of 4 * (100 + 2) bytes (an additional 8 bytes will overwrite the value of the <b><i>rbp</i></b> register stored on the stack). <br><br>  Since the overflowed buffer is located on the stack, and not on the heap, we will locate the whole ROP chain in the same place - starting with the offset 4 * (100 + 2) in the input parameter of the <b><i>load</i></b> command. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/f7f/c16/058/f7fc16058b6f4097941f4868eb3215ce.jpg"></div><br><br>  Now all the ingredients are in place.  The time has come to collect from them a combat exploit! <br><br><h2>  Pwn it! </h2><br>  To get the job key, you must read and display the contents of the local directory on the server.  Earlier in the analysis, we noted that before displaying the greeting, the contents of the screen are cleared, and the username is present in the greeting. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/699/18b/66b/69918b66b3e94e07a0e1310483f39869.jpg"></div><br><br>  Obviously, the function that does this and accepts the <b><i>‚Äúcls‚Äù</i></b> and <b><i>‚Äúwhoami‚Äù</i></b> strings as parameters behaves like the library function system.  You must call this function, but take <b><i>‚Äúdir‚Äù</i></b> as the executable command ‚Äî display the contents of the local directory on the server. <br><br>  Construct a ROP chain that allows this.  The sequence of operations is as follows: <br><br><ol><li>  Place the string <b><i>‚Äúdir‚Äù</i></b> at the address that is known at the time the vulnerability was triggered. </li><li>  Put the address of this string in the <b><i>rcx register</i></b> . </li><li>  Transfer control to the <b><i>system_func</i></b> function. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/web/071/b79/c0b/071b79c0b8794bad9486e1b32d37b7c8.jpg"></div><br><br>  When placing the addresses in the buffer, you need to remember about the presence of ASLR, and calculate them dynamically, using previously readable addresses of the executable memory and the beginning of the buffer.  In addition, they are written to the buffer in accordance with the <b>Little Endian</b> notation, that is, from low bytes to high bytes. <br><br>  Now you need to find the offset of the necessary gadgets in the executable file of the interpreter.  The first is needed to put the address of the string <b><i>‚Äúdir</i> ‚Äù</b> in <b><i>rcx</i></b> , the second - to call the function <b><i>system_fun</i> c</b> .  By the offsets 0x24c00 and 0x16ce6, respectively, in the code section of the executable file of the interpreter are the necessary parts of the code. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/27b/a2d/9df/27ba2d9df5284db0bfd99ff714fedd62.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/web/fcc/2a6/a87/fcc2a6a87ae1485fb20aa065c15f8798.jpg"></div><br><br>  The string <b><i>"dir"</i></b> we put after the gadgets.  Its address, therefore, will be 4 * (100 + 2) + 6 * 4 bytes more than the buffer address. <br><br>  Below is our version of the script to generate the contents of the buffer: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> print_function <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys n = <span class="hljs-number"><span class="hljs-number">102</span></span> f=open(<span class="hljs-string"><span class="hljs-string">"buf.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"w"</span></span>) base_l = <span class="hljs-number"><span class="hljs-number">0x2f150000</span></span> - <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment"># get 4294967282 base_h = 0x7ff6 # get 4294967283 buffer_l = 0x0afcf6e0 # get 4294967196 buffer_h = 0xe8 # get 4294967197 def rev(x): return ((x &lt;&lt; 24) &amp; 0xff000000 | (x &lt;&lt; 8) &amp; 0x00ff0000 | (x &gt;&gt; 8) &amp; 0x0000ff00 | (x &gt;&gt; 24) &amp; 0x000000ff) arr = [ base_l + 0x24c00, base_h, # pop rcx ; ret buffer_l + n*0x4 + 6*0x4, buffer_h, # buffer ptr - in rdi base_l + 0x16ce6, base_h # &amp;system in our binary ] for i in range(0,n): # dumb print("%08x" % rev(0xdeadbeef), end='', file=f) for i in arr: print("%08x" % rev(i), end='', file=f) # "dir\0" print("%08x" % 0x64697200, end='', file=f) f.close()</span></span></code> </pre> <br>  Everything is ready, it's time to go for the key! <br><br><ul><li>  Connect to a remote server, get the necessary addresses with the get command. </li><li>  We generate a vulnerable buffer based on them. </li><li>  Execute the load command, rewrite the return address from the main function. </li><li>  Execute the exit command, which terminates the main function and launches the exploit. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/web/3ca/9c5/9a9/3ca9c59a9d6e4dd8a57003a49cabdffa.jpg"></div><br><br>  Seeking key: <b>fb520eb552747437c09f2770a9a282ea</b> . <br><br><h2>  What is the result? </h2><br>  In <a href="http://neoquest.ru/timeline.php%3Fyear%3D2017%26part%3D2">NeoQUEST,</a> we collect a wide variety of tasks that require knowledge from different areas of information security and are able to show what a careless attitude to security is fraught with: weak passwords, poor server implementation (we searched for the vulnerability in this <a href="https://habrahabr.ru/company/neobit/blog/321912/">article</a> using fuzzing and described it in detail in this <a href="https://habrahabr.ru/company/neobit/blog/321912/">article</a> ), weak ciphers.  And the example of this task clearly shows how carelessness in programming can cause critical damage to the security of information. </div><p>Source: <a href="https://habr.com/ru/post/335046/">https://habr.com/ru/post/335046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../335036/index.html">Clearing the flow of calls without magic and SMS</a></li>
<li><a href="../335038/index.html">Virtual network environment for testing network protocols. Use QEMU + YOCTO + TAP</a></li>
<li><a href="../335040/index.html">Basic Linux fortification: choosing hedgehogs and learning to dig trenches</a></li>
<li><a href="../335042/index.html">Look up from the bottom or Ubuntu Server for the developer of electronics. Part 2</a></li>
<li><a href="../335044/index.html">vCloud Director</a></li>
<li><a href="../335048/index.html">Start learning Elixir right now! Translation of the entire series of articles is ready.</a></li>
<li><a href="../335050/index.html">Anatomy of GraphQL Queries</a></li>
<li><a href="../335052/index.html">True neural network implementation from scratch in the C # programming language</a></li>
<li><a href="../335056/index.html">Reliability Go in Dropbox infrastructure</a></li>
<li><a href="../335058/index.html">Puzzle game Neo Angle. Continuing development history and release in Appstore</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>