<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Sectioning Auto add sections</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In version 11g, Oracle has several new remarkable partitioning schemes ‚Äî for example, convenient interval partitioning functionality ‚Äî automatic secti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Sectioning Auto add sections</h1><div class="post__text post__text-html js-mediator-article">  In version 11g, Oracle has several new remarkable partitioning schemes ‚Äî for example, convenient interval partitioning functionality ‚Äî automatic section creation as the range leaves the specified boundaries. <br>  In versions up to 11g, you must periodically manually either add sections in advance or split the default section.  That is, it is constantly necessary to monitor the status of such tables.  In this article, I will share my solutions for automating such partitioning tasks. <br>  First give an example for 11g: <br><blockquote><ol><li> <code><font color="black"><font color="#0000ff">create</font> <font color="#0000ff">table</font> res ( res_id     number <font color="#0000ff">not</font> <font color="#0000ff">null</font> , res_date <font color="#0000ff">date</font> , hotel_id  number(3), guest_id  number ) partition <font color="#0000ff">by</font> range (res_id) <font color="#0000ff">interval</font> (100) store <font color="#0000ff">in</font> (users) ( partition p1 <font color="#0000ff">values</font> <font color="#0000ff">less</font> <font color="#0000ff">than</font> (101) );</font></code> </li> <li> <code><font color="black"><font color="#0000ff">create</font> <font color="#0000ff">table</font> res ( res_id     number <font color="#0000ff">not</font> <font color="#0000ff">null</font> , res_date <font color="#0000ff">date</font> , hotel_id  number(3), guest_id  number ) partition <font color="#0000ff">by</font> range (res_id) <font color="#0000ff">interval</font> (100) store <font color="#0000ff">in</font> (users) ( partition p1 <font color="#0000ff">values</font> <font color="#0000ff">less</font> <font color="#0000ff">than</font> (101) );</font></code> </li> <li> <code><font color="black"><font color="#0000ff">create</font> <font color="#0000ff">table</font> res ( res_id     number <font color="#0000ff">not</font> <font color="#0000ff">null</font> , res_date <font color="#0000ff">date</font> , hotel_id  number(3), guest_id  number ) partition <font color="#0000ff">by</font> range (res_id) <font color="#0000ff">interval</font> (100) store <font color="#0000ff">in</font> (users) ( partition p1 <font color="#0000ff">values</font> <font color="#0000ff">less</font> <font color="#0000ff">than</font> (101) );</font></code> </li> <li> <code><font color="black"><font color="#0000ff">create</font> <font color="#0000ff">table</font> res ( res_id     number <font color="#0000ff">not</font> <font color="#0000ff">null</font> , res_date <font color="#0000ff">date</font> , hotel_id  number(3), guest_id  number ) partition <font color="#0000ff">by</font> range (res_id) <font color="#0000ff">interval</font> (100) store <font color="#0000ff">in</font> (users) ( partition p1 <font color="#0000ff">values</font> <font color="#0000ff">less</font> <font color="#0000ff">than</font> (101) );</font></code> </li> <li> <code><font color="black"><font color="#0000ff">create</font> <font color="#0000ff">table</font> res ( res_id     number <font color="#0000ff">not</font> <font color="#0000ff">null</font> , res_date <font color="#0000ff">date</font> , hotel_id  number(3), guest_id  number ) partition <font color="#0000ff">by</font> range (res_id) <font color="#0000ff">interval</font> (100) store <font color="#0000ff">in</font> (users) ( partition p1 <font color="#0000ff">values</font> <font color="#0000ff">less</font> <font color="#0000ff">than</font> (101) );</font></code> </li> <li> <code><font color="black"><font color="#0000ff">create</font> <font color="#0000ff">table</font> res ( res_id     number <font color="#0000ff">not</font> <font color="#0000ff">null</font> , res_date <font color="#0000ff">date</font> , hotel_id  number(3), guest_id  number ) partition <font color="#0000ff">by</font> range (res_id) <font color="#0000ff">interval</font> (100) store <font color="#0000ff">in</font> (users) ( partition p1 <font color="#0000ff">values</font> <font color="#0000ff">less</font> <font color="#0000ff">than</font> (101) );</font></code> </li> <li> <code><font color="black"><font color="#0000ff">create</font> <font color="#0000ff">table</font> res ( res_id     number <font color="#0000ff">not</font> <font color="#0000ff">null</font> , res_date <font color="#0000ff">date</font> , hotel_id  number(3), guest_id  number ) partition <font color="#0000ff">by</font> range (res_id) <font color="#0000ff">interval</font> (100) store <font color="#0000ff">in</font> (users) ( partition p1 <font color="#0000ff">values</font> <font color="#0000ff">less</font> <font color="#0000ff">than</font> (101) );</font></code> </li> <li> <code><font color="black"><font color="#0000ff">create</font> <font color="#0000ff">table</font> res ( res_id     number <font color="#0000ff">not</font> <font color="#0000ff">null</font> , res_date <font color="#0000ff">date</font> , hotel_id  number(3), guest_id  number ) partition <font color="#0000ff">by</font> range (res_id) <font color="#0000ff">interval</font> (100) store <font color="#0000ff">in</font> (users) ( partition p1 <font color="#0000ff">values</font> <font color="#0000ff">less</font> <font color="#0000ff">than</font> (101) );</font></code> </li> <li> <code><font color="black"><font color="#0000ff">create</font> <font color="#0000ff">table</font> res ( res_id     number <font color="#0000ff">not</font> <font color="#0000ff">null</font> , res_date <font color="#0000ff">date</font> , hotel_id  number(3), guest_id  number ) partition <font color="#0000ff">by</font> range (res_id) <font color="#0000ff">interval</font> (100) store <font color="#0000ff">in</font> (users) ( partition p1 <font color="#0000ff">values</font> <font color="#0000ff">less</font> <font color="#0000ff">than</font> (101) );</font></code> </li> <li> <code><font color="black"><font color="#0000ff">create</font> <font color="#0000ff">table</font> res ( res_id     number <font color="#0000ff">not</font> <font color="#0000ff">null</font> , res_date <font color="#0000ff">date</font> , hotel_id  number(3), guest_id  number ) partition <font color="#0000ff">by</font> range (res_id) <font color="#0000ff">interval</font> (100) store <font color="#0000ff">in</font> (users) ( partition p1 <font color="#0000ff">values</font> <font color="#0000ff">less</font> <font color="#0000ff">than</font> (101) );</font></code> </li> <li> <code><font color="black"><font color="#0000ff">create</font> <font color="#0000ff">table</font> res ( res_id     number <font color="#0000ff">not</font> <font color="#0000ff">null</font> , res_date <font color="#0000ff">date</font> , hotel_id  number(3), guest_id  number ) partition <font color="#0000ff">by</font> range (res_id) <font color="#0000ff">interval</font> (100) store <font color="#0000ff">in</font> (users) ( partition p1 <font color="#0000ff">values</font> <font color="#0000ff">less</font> <font color="#0000ff">than</font> (101) );</font></code> </li> </ol></blockquote><br>  This script creates a section p1 for records whose column value of res_id is in the range of 1-100.  When records with a res_id column value less than 101 are inserted, they are placed in section p1, and when in the new record the value of this column is equal to or greater than 101, Oracle Database 11g creates a new section, the name of which is generated by the system.  You can learn more about this example and other new partitioning schemes in the <a href="http://www.oracle.com/global/ru/oramag/dec2007/w_adm_nanda_o57.html">translation of the article by Arup Nanda in the Russian edition of Oracle Magazine</a> . <br>  The solutions discussed below can be applied to other DBMSs that do not support automatic addition of sections. <br><a name="habracut"></a><br><h3>  Solution for a uniformly increasing partitioning key without gaps </h3><br>  Create a test table: <br><blockquote><ol><li>  <font color="#0000ff">create</font> <font color="#0000ff">table</font> test_part ( </li><li>  id number <font color="#0000ff">not</font> <font color="#0000ff">null</font> </li><li>  name varchar2 (100) <font color="#0000ff">not</font> <font color="#0000ff">null</font> , </li><li>  owner varchar2 (100) <font color="#0000ff">not</font> <font color="#0000ff">null</font> , </li><li>  type varchar2 (100) <font color="#0000ff">not</font> <font color="#0000ff">null</font> , </li><li>  created <font color="#0000ff">date</font> <font color="#0000ff">not</font> <font color="#0000ff">null</font> , </li><li>  <font color="#0000ff">constraint</font> test_part_pk </li><li>  <font color="#0000ff">primary</font> <font color="#0000ff">key</font> (id) </li><li>  ) </li><li>  partition <font color="#0000ff">by</font> range (id) (partition p1 <font color="#0000ff">values</font> <font color="#0000ff">less</font> <font color="#0000ff">than</font> (10000)); </li></ol></blockquote><br>  It is logical that if there are no gaps in such a table, it would be desirable to create new sections before the partition key approaches the border of the maximum section.  How many key values ‚Äã‚Äãwe have left up to the border, we can easily determine according to a simple formula: <b>partition_size - (key-start_key_in_partition)</b> , where key is the current partitioning key, start_key_in_partition is the first key that falls into this section, partition_size is the number of keys in the section, and% is an integer division (div) operation.  Typically, such a partitioning is made into equal sections, and with this in mind, we can simplify this formula to this: partition_size - key% partition_size. <br>  What it gives us: knowing the moment we can create a trigger that will add sections when this event occurs. <br>  Create this trigger: <br><blockquote><ol><li>  <font color="#0000ff">create</font> <font color="#0000ff">or</font> replace <font color="#0000ff">trigger</font> tr_test_part </li><li>  <font color="#0000ff">before</font> <font color="#0000ff">insert</font> <font color="#0000ff">on</font> test_part </li><li>  <font color="#0000ff">for</font> <font color="#0000ff">each</font> <font color="#0000ff">row</font> </li><li>  <font color="#0000ff">when</font> (mod ( <font color="#0000ff">NEW</font> .id, 10000) = 6000) </li><li>  <font color="#0000ff">declare</font> </li><li>  l_part_name number; </li><li>  l_maxvalue number; </li><li>  l_exist number; </li><li>  l_partition_exists <font color="#0000ff">exception</font> ; </li><li>  PRAGMA EXCEPTION_INIT (l_partition_exists, -14074); </li><li>  PRAGMA AUTONOMOUS_TRANSACTION; </li><li>  <font color="#0000ff">begin</font> </li><li>  l_part_name: = ceil (: <font color="#0000ff">NEW</font> .ID / 10000) +1; </li><li>  <font color="#0000ff">BEGIN</font> </li><li>  <font color="#0000ff">execute</font> <font color="#0000ff">immediate</font> <font color="#A31515">alter table xtender.test_part add partition p</font> ||| l_part_name ||  <font color="#A31515">'values ‚Äã‚Äãless than ('</font> || l_maxvalue || <font color="#A31515">')'</font> ; </li><li>  <font color="#0000ff">EXCEPTION</font> </li><li>  <font color="#0000ff">when</font> l_partition_exists <font color="#0000ff">then</font> <font color="#0000ff">null</font> ; </li><li>  <font color="#0000ff">END</font> ; </li><li>  <font color="#0000ff">end</font> tr_test_part; </li></ol></blockquote><br><br>  This trigger using autonomous transactions automatically creates a new section named 'P' + a section number of 10,000 in size when the ID - our partition key - remains 4,000 values ‚Äã‚Äãbefore the section boundary (10,000‚Äì4,000 = 6000, i.e. ID = 6000, 16000.26000, and so on.), But first it is checked whether this section already exists (this can happen, for example, when you add the 6000th record again, or manually add a section).  The partitioning parameters are 10,000 and 4,000, you should select based on your specific situation, but note that the border (4,000 in the example) must be greater than the maximum number of records that are added at once.  otherwise, at the time of the insert data transaction, the transaction will not be ‚Äúaware‚Äù of the new section, since  it did not exist at the beginning of the transaction, therefore the data will not be inserted with a complaint about the absence of a section mapping to this key.  This could have been avoided with the use of <b>alter table split default_partition</b> , which I will discuss further, but this will affect the runtime. <br>  Check our trigger by filling out the section: <br><blockquote> <code><font color="black"><font color="#0000ff">insert</font> <font color="#0000ff">into</font> xtender.test_part <br> <font color="#0000ff">select</font> rownum, o.OBJECT_NAME, o.OWNER, o.OBJECT_TYPE, o.CREATED <br> <font color="#0000ff">from</font> all_objects o <br> <font color="#0000ff">where</font> rownum&lt;1000;</font> <br></code> </blockquote><br>  In addition, in the case of using sequences that, due to caching, ‚Äústep out‚Äù, the trigger cannot be consistently changed so that it is executed for a set of values ‚Äã‚Äãfrom 4000 to 3900 records from the end of the section: <br>  replace the condition <br><pre>  when (mod (NEW.id, 10000) = 6000) </pre>  on <br><pre>  when (mod (NEW.id, 10000) between 6000 and 6100) </pre><br><br><h3>  Solution for other cases </h3><br>  In cases where we specify a section by default, we can split it when records have already got there, the question is how to automatically track this. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the Data dictionary, we can get information about all sections of partitioned tables by sampling from <b>dba_tab_partitions</b> , in which <b>partition_position</b> indicates the order of the section in the table, and <b>high_value indicates</b> the section parameters.  Therefore, we can get the name of the last section in the table and select from it to get the number of records in it. <br><br>  After receiving information about the tables in which writing into the default sections began, we should send a notification.  For this we can use the options: <br><ul><li>  if you have set up automatic sending of alerts by mail, then just write the event in alert.log; </li><li>  just write a procedure for sending notification emails. </li></ul><br><br>  The first option is implemented using the <b>dbms_system.ksdwrt</b> procedure, which has two parameters: <ul><li>  the first (BINARY_INTEGER) is where to record, with possible values: 1 - to the standard trace file, 2 - to alert.log, 3 - to both; </li><li>  and the second (varchar2) is the string itself, which we write. </li></ul><br>  Example: <br><pre> exec dbms_system.ksdwrt (2, 'Test Alert Message');
</pre><br><br>  The second option is to use the <b>utl_mail</b> package or lower-level ones - <b>utl_smtp</b> or <b>utl_tcp</b> . <br>  <b>utl_mail</b> is a more convenient wrapper for <b>utl_smtp</b> , but to use it, it is necessary to set the smtp_out_server parameter.  You can do this as soon as for the session - <i>‚ÄúALTER SESSION SET smtp_out_server = ...‚Äù</i> and for the <i>‚ÄúALTER SYSTEM SET smtp_out_server = ...‚Äù system</i> . <br>  Do not be surprised if you cannot find this package in your home - initially it is not included and to create it you must execute two scripts: <br><pre> <code class="hljs pgsql">sqlplus sys/&lt;pwd&gt; <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>&gt; @$ORACLE_HOME/rdbms/<span class="hljs-keyword"><span class="hljs-keyword">admin</span></span>/utlmail.<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>&gt; @$ORACLE_HOME/rdbms/<span class="hljs-keyword"><span class="hljs-keyword">admin</span></span>/prvtmail.plb</code> </pre><br><br>  Putting it all together in the <b>pkg_partitions</b> package <br>  Package methods: <br><ul><li>  function <b>get_penultimate_maxvalue</b> (p_table_owner varchar2, p_table_name varchar2) return varchar2; <br>  The function accepts the owner and table name as parameters and returns the condition value (high_value) of the last but one section.  This information may be needed, for example, in cases where the last section is a section with a maxvalue parameter, and, accordingly, the parameter of the penultimate section may be needed to define a parameter for a new section. <br></li><li>  function <b>get_maxvalued_partitions</b> return tables_props_array pipelined; <br>  The function returns the names of the tables and their owners, who have started filling out the last section. <br>  Example of use: <br><blockquote><ol><li>  <font color="#0000ff">select</font> </li><li>  p. *, </li><li>  sys.pkg_partitions.get_penultimate_maxvalue (p.table_owner, p.table_name) pre_maxvalue </li><li>  <font color="#0000ff">from</font> </li><li>  <font color="#0000ff">table</font> (sys.pkg_partitions.get_maxvalued_partitions) p </li></ol></blockquote><br></li><li>  function <b>get_maxvalued_partitions_html</b> return varchar2; <br>  The function returns the same as get_maxvalued_partitions, but in the form of an html table <br></li><li>  procedure <b>send_partitions_report</b> (mail varchar2); <br>  The procedure for sending a report with tables that have started filling out the last section.  The only parameter is the address to send to. <br></li></ul><br><br>  <b>Package Code:</b> <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a></code> <ol><li>  <font color="#0000ff">create</font> <font color="#0000ff">or</font> replace package body pkg_partitions <font color="#0000ff">is</font> </li><li>  / ** Function returning parameter for the penultimate section </li><li>  * @param i_table_name Table Name </li><li>  * @ <font color="#0000ff">return</font> varchar2 </li><li>  * / </li><li>  <font color="#0000ff">function</font> get_penultimate_maxvalue (p_table_owner varchar2, p_table_name varchar2) <font color="#0000ff">return</font> varchar2 <font color="#0000ff">is</font> </li><li>  l_cursor <font color="#0000ff">integer</font> <font color="#0000ff">default</font> dbms_sql.open_cursor; </li><li>  l_ignore number; </li><li>  l_long_val varchar2 (4000); </li><li>  l_long_len number; </li><li>  l_buflen number: = 4000; </li><li>  l_curpos number: = 0; </li><li>  <font color="#0000ff">begin</font> </li><li>  dbms_sql.parse (l_cursor, </li><li>  <font color="#A31515">'select p.high_value</font> from all_tab_partitions p where p.table_owner like: o and p.table_name like: x and p.partition_position = (select max (p1.partition_position) -1 from all_tab_partitions p1 where p.table_owner like: o and p1. table_name like: x) ' </li><li>  , </li><li>  dbms_sql.native); </li><li>  dbms_sql.bind_variable (l_cursor, <font color="#A31515">': x'</font> , p_table_name); </li><li>  dbms_sql.bind_variable (l_cursor, <font color="#A31515">': o'</font> , p_table_owner); </li><li></li><li>  dbms_sql.define_column_long (l_cursor, 1); </li><li>  l_ignore: = dbms_sql.  <font color="#0000ff">execute</font> (l_cursor); </li><li>  <font color="#0000ff">if</font> (dbms_sql.fetch_rows (l_cursor)&gt; 0) </li><li>  <font color="#0000ff">then</font> </li><li>  dbms_sql.column_value_long (l_cursor, 1, l_buflen, l_curpos, </li><li>  l_long_val, l_long_len); </li><li>  <font color="#0000ff">end</font> <font color="#0000ff">if</font> ; </li><li>  dbms_sql.close_cursor (l_cursor); </li><li>  <font color="#0000ff">return</font> l_long_val; </li><li>  <font color="#0000ff">end</font> ; </li><li></li><li>  / ** Function returning the names of tables and their owners, who have started filling out the last section </li><li>  * @ <font color="#0000ff">return</font> </li><li>  * table_name varchar2 (4000), </li><li>  * table_owner varchar2 (4000), </li><li>  * partitions_count number, </li><li>  * partition_name varchar2 (4000)); </li><li>  * / </li><li>  <font color="#0000ff">function</font> get_maxvalued_partitions <font color="#0000ff">return</font> tables_props_array pipelined <font color="#0000ff">is</font> </li><li>  l_cursor <font color="#0000ff">integer</font> <font color="#0000ff">default</font> dbms_sql.open_cursor; </li><li>  l_count number; </li><li>  l_ignore <font color="#0000ff">integer</font> ; </li><li>  l_data table_props; </li><li>  <font color="#0000ff">cursor</font> l_partitions <font color="#0000ff">is</font> </li><li>  <font color="#0000ff">select</font> </li><li>  pl.table_owner, </li><li>  pl.table_name, </li><li>  <font color="#0000ff">count</font> (1) cnt, </li><li>  <font color="#0000ff">max</font> (pl.partition_name) keep (dense_rank <font color="#0000ff">last</font> <font color="#0000ff">order</font> <font color="#0000ff">by</font> (pl.partition_position)) partition_name </li><li>  <font color="#0000ff">from</font> dba_tab_partitions pl </li><li>  <font color="#0000ff">where</font> pl.table_name <font color="#0000ff">not</font> <font color="#0000ff">like</font> <font color="#A31515">'BIN $%'</font> </li><li>  <font color="#0000ff">group</font> <font color="#0000ff">by</font> pl.table_owner, pl.table_name </li><li>  <font color="#0000ff">having</font> <font color="#0000ff">count</font> (1)&gt; 1; </li><li>  <font color="#0000ff">BEGIN</font> </li><li>  <font color="#0000ff">FOR</font> part <font color="#0000ff">in</font> l_partitions </li><li>  LOOP </li><li>  dbms_sql.parse (l_cursor, </li><li>  <font color="#A31515">'select count (1)</font> from' || part.table_owner ||  <font color="#A31515">'.'</font>  || part.table_name </li><li>  ||  <font color="#A31515">'partition ('</font> || part.partition_name || <font color="#A31515">')'</font> </li><li>  ||  <font color="#A31515">'where rownum &lt;2'</font> </li><li>  , </li><li>  dbms_sql.native); </li><li>  dbms_sql.define_column (l_cursor, 1, l_count); </li><li>  l_ignore: = dbms_sql.execute_and_fetch (l_cursor); </li><li>  dbms_sql.column_value (l_cursor, 1, l_count); </li><li>  <font color="#0000ff">if</font> (l_count&gt; 0) <font color="#0000ff">then</font> </li><li>  l_data.table_name: = part.table_name; </li><li>  l_data.table_owner: = part.table_owner; </li><li>  l_data.partitions_count: = part.cnt; </li><li>  l_data.partition_name: = part.partition_name; </li><li>  pipe <font color="#0000ff">row</font> (l_data); </li><li>  <font color="#0000ff">end</font> <font color="#0000ff">if</font> ; </li><li>  <font color="#0000ff">END</font> LOOP; </li><li>  <font color="#0000ff">END</font> ; </li><li></li><li>  / ** The function returns the names of the tables and their owners in the form of html, which began to fill the last section </li><li>  * @ <font color="#0000ff">return</font> </li><li>  * table_name varchar2 (4000), </li><li>  * table_owner varchar2 (4000), </li><li>  * partitions_count number, </li><li>  * partition_name varchar2 (4000)); </li><li>  * / </li><li>  <font color="#0000ff">function</font> get_maxvalued_partitions_html <font color="#0000ff">return</font> varchar2 <font color="#0000ff">is</font> </li><li>  l_cursor <font color="#0000ff">integer</font> <font color="#0000ff">default</font> dbms_sql.open_cursor; </li><li>  l_count number; </li><li>  l_ignore <font color="#0000ff">integer</font> ; </li><li>  l_data varchar2 (4000); </li><li>  <font color="#0000ff">cursor</font> l_partitions <font color="#0000ff">is</font> </li><li>  <font color="#0000ff">select</font> </li><li>  pl.table_owner, </li><li>  pl.table_name, </li><li>  <font color="#0000ff">count</font> (1) cnt, </li><li>  <font color="#0000ff">max</font> (pl.partition_name) keep (dense_rank <font color="#0000ff">last</font> <font color="#0000ff">order</font> <font color="#0000ff">by</font> (pl.partition_position)) partition_name </li><li>  <font color="#0000ff">from</font> dba_tab_partitions pl </li><li>  <font color="#0000ff">where</font> pl.table_name <font color="#0000ff">not</font> <font color="#0000ff">like</font> <font color="#A31515">'BIN $%'</font> </li><li>  <font color="#0000ff">group</font> <font color="#0000ff">by</font> pl.table_owner, pl.table_name </li><li>  <font color="#0000ff">having</font> <font color="#0000ff">count</font> (1)&gt; 1; </li><li>  <font color="#0000ff">BEGIN</font> </li><li>  l_data: = <font color="#A31515">'&lt;html&gt; &lt;body&gt; &lt;table border = 1&gt;'</font> </li><li>  ||  <font color="#A31515">'&lt;tr&gt; &lt;th&gt; Table name &lt;/ th&gt;'</font> </li><li>  ||  <font color="#A31515">'&lt;th&gt; Table owner &lt;/ th&gt;'</font> </li><li>  ||  <font color="#A31515">'&lt;th&gt; Partitions count &lt;/ th&gt;'</font> </li><li>  ||  <font color="#A31515">'&lt;th&gt; Partition name &lt;/ th&gt;'</font> </li><li>  ||  <font color="#A31515">'&lt;th&gt; Pre maxvalue &lt;/ th&gt;'</font> ; </li><li></li><li>  <font color="#0000ff">FOR</font> part <font color="#0000ff">in</font> l_partitions </li><li>  LOOP </li><li>  dbms_sql.parse (l_cursor, </li><li>  <font color="#A31515">'select count (1)</font> from' || part.table_owner ||  <font color="#A31515">'.'</font>  || part.table_name </li><li>  ||  <font color="#A31515">'partition ('</font> || part.partition_name || <font color="#A31515">')'</font> </li><li>  ||  <font color="#A31515">'where rownum &lt;2'</font> </li><li>  , </li><li>  dbms_sql.native); </li><li>  dbms_sql.define_column (l_cursor, 1, l_count); </li><li>  l_ignore: = dbms_sql.execute_and_fetch (l_cursor); </li><li>  dbms_sql.column_value (l_cursor, 1, l_count); </li><li>  <font color="#0000ff">if</font> (l_count&gt; 0) <font color="#0000ff">then</font> </li><li>  l_data: = l_data ||  <font color="#A31515">'&lt;tr&gt; &lt;td&gt;'</font> </li><li>  || part.table_name </li><li>  ||  <font color="#A31515">'&lt;/ td&gt; &lt;td&gt;'</font> </li><li>  || part.table_owner </li><li>  ||  <font color="#A31515">'&lt;/ td&gt; &lt;td&gt;'</font> </li><li>  || part.cnt </li><li>  ||  <font color="#A31515">'&lt;/ td&gt; &lt;td&gt;'</font> </li><li>  || part.partition_name </li><li>  ||  <font color="#A31515">'&lt;/ td&gt; &lt;/ tr&gt;'</font> ; </li><li>  <font color="#0000ff">end</font> <font color="#0000ff">if</font> ; </li><li>  <font color="#0000ff">END</font> LOOP; </li><li>  l_data: = l_data ||  <font color="#A31515">'&lt;/ table&gt; &lt;/ body&gt; &lt;/ html&gt;'</font> ; </li><li>  <font color="#0000ff">return</font> l_data; </li><li>  <font color="#0000ff">END</font> ; </li><li>  / ** </li><li>  * The procedure for sending a report with tables that have started to fill the last section </li><li>  * / </li><li>  <font color="#0000ff">procedure</font> send_partitions_report (mail varchar2) </li><li>  <font color="#0000ff">is</font> </li><li>  msg_body varchar2 (4000); </li><li>  <font color="#0000ff">BEGIN</font> </li><li>  <font color="#0000ff">select</font> pkg_partitions.get_maxvalued_partitions_html <font color="#0000ff">into</font> msg_body <font color="#0000ff">from</font> dual; </li><li>  - <font color="#0000ff">EXECUTE</font> <font color="#0000ff">IMMEDIATE</font> <font color="#A31515">'ALTER SESSION SET smtp_out_server ='</font> <font color="#A31515">'our_mailserver'</font> <font color="#A31515">''</font> ; </li><li>  utl_mail.send ( </li><li>  sender =&gt; <font color="#A31515">'oracleDBA@dbdomain.com'</font> , </li><li>  recipients =&gt; mail, </li><li>  subject =&gt; <font color="#A31515">'Maxvalued partitions Report'</font> , </li><li>  message =&gt; msg_body, </li><li>  mime_type =&gt; <font color="#A31515">'text / html'</font> ); </li><li>  <font color="#0000ff">END</font> ; </li><li>  <font color="#0000ff">end</font> pkg_partitions; </li></ol>  <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font> </blockquote><br>  <b>UPD</b> <br>  As correctly suggested by <a href="https://habrahabr.ru/users/zhekappp/" class="user_link">zhekappp,</a> you can use num_rows when you turn on automatic statistics collection.  Statistics collection can be enabled by adding a job using dbms_job with dbms_stats.gather_table_stats. <br>  Then you will need to remove the request for the number of records in the section and change the request to: <br><blockquote><ol><li>  <font color="#0000ff">select</font> </li><li>  pl.table_owner, </li><li>  pl.table_name, </li><li>  <font color="#0000ff">count</font> (1) cnt, </li><li>  <font color="#0000ff">max</font> (pl.num_rows) keep (dense_rank <font color="#0000ff">last</font> <font color="#0000ff">order</font> <font color="#0000ff">by</font> (pl.partition_position)) partition_rows, </li><li>  <font color="#0000ff">max</font> (pl.partition_name) keep (dense_rank <font color="#0000ff">last</font> <font color="#0000ff">order</font> <font color="#0000ff">by</font> (pl.partition_position)) partition_name </li><li>  <font color="#0000ff">from</font> dba_tab_partitions pl </li><li>  <font color="#0000ff">where</font> pl.table_name <font color="#0000ff">not</font> <font color="#0000ff">like</font> <font color="#A31515">'BIN $%'</font> </li><li>  <font color="#0000ff">group</font> <font color="#0000ff">by</font> pl.table_owner, pl.table_name </li></ol></blockquote><br>  The full package code for this case can be found here: <a href="http://www.xt-r.com/2010/10/pkgpartitions.html">http://www.xt-r.com/2010/10/pkgpartitions.html</a> <br><br><h3>  Automatic execution </h3><br>  It remains only to configure the automatic execution.  We do this with dbms_job. <br>  For example, the daily automatic execution of the data retrieval script: <br><blockquote><ol><li>  <font color="#0000ff">declare</font> </li><li>  job binary_integer; </li><li>  <font color="#0000ff">begin</font> </li><li>  dbms_job.submit ( </li><li>  job, </li><li>  <font color="#A31515">'pkg_partitions.send_partitions_report ('</font> <font color="#A31515">'dba@domain.ru'</font> <font color="#A31515">');'</font>  , </li><li>  sysdate </li><li>  <font color="#A31515">'trunc (sysdate) +1'</font> ); </li><li>  dbms_output.put_line (job); </li><li>  <font color="#0000ff">end</font> ; </li></ol></blockquote></div><p>Source: <a href="https://habr.com/ru/post/105759/">https://habr.com/ru/post/105759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../105752/index.html">Spam from Samsung?</a></li>
<li><a href="../105753/index.html">Google code-in</a></li>
<li><a href="../105755/index.html">DevPoint 2. Results</a></li>
<li><a href="../105756/index.html">IPad Abacus</a></li>
<li><a href="../105758/index.html">Parallels and VMware War, yesterday and today</a></li>
<li><a href="../105761/index.html">Form Validation Development</a></li>
<li><a href="../105762/index.html">Articles on ISN</a></li>
<li><a href="../105763/index.html">If you are bored with domain capture stories ...</a></li>
<li><a href="../105764/index.html">Friday task</a></li>
<li><a href="../105766/index.html">Why is it so hard to make a good user interface?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>