<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Managing Internet modules Laurent from RouterOS MikroTik</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What are Mikrotik routers (MikroTik), in our time is known to almost everyone who is interested in network technologies a little more than just a user...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Managing Internet modules Laurent from RouterOS MikroTik</h1><div class="post__text post__text-html js-mediator-article">  What are Mikrotik routers (MikroTik), in our time is known to almost everyone who is interested in network technologies a little more than just a user.  Thanks to reliable hardware and low cost, these routers are becoming increasingly popular not only in the professional environment of large network administrators, but also in office and home use.  An important component of the success of this equipment among professionals and amateurs is the Mikrotik specialized RouterOS (RouterOS, ROS), uniform for all devices, a powerful operating system equipped with a convenient graphical shell WINBOX, which allows to configure the router flexibly and universally.  Sometimes the possibilities of RouterOS are not limited to this ... <br><br><h4>  This article discusses the possibility of using the ROS MikroTik functionality to send commands to the Laurent Internet modules from KernelChip, which accept direct http requests, through the integration of these devices in the network by creating special firmware - ROS script functions. </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/b2a/07d/d94/b2a07dd94d4aa96f92edd1a79a9d678b.jpg" alt="image"><br><a name="habracut"></a><br><h4>  Laurent2 module </h4><br>  The Laurent2 module has on board a fairly rich ‚Äúsnap-in‚Äù available on the terminal block pads along the edges of the board.  The module includes: <br><br><ul><li>  optoisolated discrete input lines (6 pcs.) </li><li>  powerful output discrete lines (12 pcs.) </li><li>  Analog-to-digital converters (for measuring voltage and connecting various sensors) -2 </li><li>  pulse counters (4 pcs.) </li><li>  high-voltage electromagnetic relays for switching different loads (4 pcs.) </li><li>  PWM output </li><li>  KTS-18B20 temperature sensor input </li><li>  serial port RS - 232 </li></ul><br><h4>  Laurent112 </h4><br>  Laurent112 looks more modest, not having the above-mentioned variety of Laurent2 possibilities, but carrying on itself ‚Äúin compensation‚Äù 12 relays capable of switching the standard load of household appliances. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To support these modules, the following script functions were written in Mikrotik RouterOs: <br><br>  <a href="https://habr.com/ru/post/348120/"><b>FuncLaurent2REL</b></a> - <a href="https://habr.com/ru/post/348120/"><b>Laurent2</b></a> relay function <br>  <a href="https://habr.com/ru/post/348120/"><b>FuncLaurent2OUT</b></a> - function of work with module OUT-lines <br>  <a href="https://habr.com/ru/post/348120/"><b>FuncLaurent2PWM</b></a> - setting the power of the PWM signal <br>  <a href="https://habr.com/ru/post/348120/"><b>FuncLaurent2Status</b></a> - Laurent2 Status Request <br>  <a href="https://habr.com/ru/post/348120/"><b>FuncLaurent112REL</b></a> - Laurent112 module relay function <br>  <a href="https://habr.com/ru/post/348120/"><b>FuncLaurent112Status</b></a> - Laurent112 Status Request <br>  <i>FuncPing</i> - a service function for requesting an IP address response to a "ping", used by all functions <br>  <i>FuncMail</i> - an additional function of sending an arbitrary message to the mail <br><br>  For ease of use, the listed functions together with some service and example scripts of their call are combined into a single Laurent.rsc file, which can be imported into the Router with a terminal command <br><br><pre><code class="lua hljs">/import file=Laurent.rsc</code> </pre> <br>  (import time can take from 20-30 seconds to 1 minute depending on the performance of your Mikrotik router model). <br><br>  If the Laurent script library file is not damaged and the import of scripts into the repository is correct, we will see the message ‚ÄúScript file loaded finished successfully‚Äù in the console of the WINBOX utility: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/387/2cb/66d/3872cb66deb51f82e3b78268a448f011.jpg" alt="image"><br><br>  At the same time, in the repository of the router, in addition to your existing scripts, the following should appear: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c27/a2e/471/c27a2e471448a2c489af5581f93994b5.jpg" alt="image"><br><br>  They are easily distinguished by the label owner-creator (owner), which will be marked "Laurent". <br><br>  You can call Laurent functions from any other scripts as follows: <br>  First you need to execute scripts that place the necessary functions in the form of global variables in the environment of the variables of the router's repository.  For the Laurent2 module, these are the <b>Func_Laurent2_library</b> , <b>Func_Ping</b> and <b>Func_Mail scripts</b> (an optional, but convenient ‚Äúmail‚Äù function).  For Laurent112, these are the <b>Func_Laurent112_REL</b> , <b>Func_Laurent112_Status</b> , <b>Func_Ping</b> and <b>Func_Mail scripts</b> . <br><br>  These scripts can be run once, when they need these functions.  If they are used in a permanent job, it is convenient to implement the launch of their scripts immediately at the start of the router from the RouterOS scheduler ( <b>/ system schduler</b> ).  Or you can use the launch of a special script <b>Laurent_START.rsc</b> , which does everything necessary to install all the functions of both modules at once.  After executing this script from WINBOX or console with the command <pre> <code class="lua hljs">/system script run Laurent_START.rsc</code> </pre>  library functions are located in the environment of repository variables and part of the Jaga melody sounds. <br><br>  The log of the router displays a message about the successful start of the library: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7e3/12e/cc0/7e312ecc0621870471655c4e6e566625.jpg" alt="image"><br><br>  In consequence, you can edit the installation file so that only the functions you need (according to the model of your Laurent board) are put in the environment, or you can call them yourself using the example from the text of the Laurent_START.rsc file <br><br>  Now, in the environment of variables, we can see our functions, defined in RouterOS as global variables (: global), ready to work: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c1c/bae/343/c1cbae3431ad2d64635581f4dfdf53e2.jpg" alt="image"><br><br>  After defining the function, you can call it in your scripts, the router scheduler (for scheduled execution) or any special cases (DHCP-server Alerts, PPP-profile scripts, etc.) by announcing their global names in the calling script. <br><br>  It should be noted that the functions of working with the relays of both modules, setting the output lines and the power of the PWM signal Laurent2 can only work in the ‚Äúunprotected‚Äù mode of the modules.  When the protect mode is enabled in modules, these http commands are not executed with the corresponding error messages (see below).  The functions for requesting the status of modules work in both protected and unprotected modes. <br><br><h3>  Consider the features and functions for the module Laurent2 </h3><a name="f2REL"></a><br>  <b>FuncLaurent2REL - Laurent2 relay on / off / inversion function</b> <br><br>  The function allows you to: turn on the specified relay, turn off the relay, reset the relay for a specified time. <br><br>  The syntax of the function is as follows: <br><br><pre> <code class="lua hljs">[$FuncLaurent2REL Ladr=<span class="hljs-string"><span class="hljs-string">"IP-address"</span></span> Lport=<span class="hljs-string"><span class="hljs-string">"http-port"</span></span> Rele=<span class="hljs-string"><span class="hljs-string">"nRele"</span></span> Action=<span class="hljs-string"><span class="hljs-string">"m"</span></span> Time=<span class="hljs-string"><span class="hljs-string">"time s"</span></span>]</code> </pre> <br>  Where: <br><br>  <i>Ladr</i> - <i>Laurent2</i> module IP address in the network in the generally accepted format; <br><br>  <i>Lport</i> - http-port module.  In the current versions of all Laurent modules, only the standard http-port 80 is used, an arbitrary port is not configured.  This parameter Lport can not be specified; <br><br>  <i>Rele</i> - the number of the relay to which the function refers in the range from 1 to 4; <br><br>  <i>Action</i> - the action performed on the relay.  It can take the value (m) equal to 1, which is equivalent to switching on the relay (on) or 0 (off); <br><br>  <i>Time</i> - the time of action on the relay in seconds in the range allowed by the module firmware [1-255].  If not specified, the action takes place once.  If the Time value is specified, the relay is ‚Äúreset‚Äù ‚Äîthe relay status changes to the seconds specified in the Action for Time and returns to the opposite state. <br><br>  The result of the function can be returned to the string variable Lanswer (this is the value of functions, in contrast to simple commands). <br><br>  To return the result, you need to use the construction of the definition (: local or: global) or assigning a value (: set) to a previously defined variable, for example: <br><br><pre> <code class="lua hljs">:<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Lanswer [$FuncLaurent2REL Ladr=<span class="hljs-string"><span class="hljs-string">"IP-address"</span></span> Lport=<span class="hljs-string"><span class="hljs-string">"http-port"</span></span> Rele=<span class="hljs-string"><span class="hljs-string">"nRele"</span></span> Action=<span class="hljs-string"><span class="hljs-string">"m"</span></span> Time=<span class="hljs-string"><span class="hljs-string">"time s"</span></span>]</code> </pre> <br>  If the function is successfully executed, ‚Äú <b>DONE</b> ‚Äù will be returned to Lanswer, or an error message will be returned.  If the function is successfully performed, if <i>Action</i> = "1", a router equipped with a beeper emits one short beep.  When the relay is turned off or inverse inversion, two consecutive short beeps sound. <br><br>  The function can return the following error messages: <br><br>  "&gt; ERROR: rele range mismath" - if an invalid relay number is specified in the Rele variable; <br>  "&gt; ERROR: rele set set mismatch" - in the case of not specified or incorrectly specified Action; <br>  "&gt; ERROR: time mismatch" - in case of an erroneous Time value (not in the range [1-255]); <br>  "&gt; ERROR: device not responded" - in the absence of a response from Laurent to ping; <br>  "&gt; ERROR: command ROS" - in case of an error while executing the RouterOs / tool fetch URL command (if the Lrr is set incorrectly, Ladr is set incorrectly, the specific user Mikrotik is unavailable for the service / tool fetch, etc.); <br>  "&gt; ERROR: device protect" - if the "protected device mode" is set and the command cannot be executed; <br>  "&gt; ERROR: command syntax" - syntax error in the command (* not all variants of errors can be eliminated, script may hang if the syntax is incorrect in the function, for example, if the format is Ladr and Lport is incorrect or not specified) <br><br>  <i>Examples of using FuncLaurent2REL</i> <br><br>  <i>Switching on the relay ‚Ññ1 of the Laurent2 module with the IP address 192.168.0.101 with the return of the function response to the variable:</i> <br><br><pre> <code class="lua hljs">:global FuncLaurent2REL; :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Lanswer [$FuncLaurent2REL Ladr=<span class="hljs-string"><span class="hljs-string">"192.168.0.101"</span></span> Lport=<span class="hljs-string"><span class="hljs-string">"80"</span></span> Rele=<span class="hljs-string"><span class="hljs-string">"1"</span></span> Action=<span class="hljs-string"><span class="hljs-string">"1"</span></span>]; :<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([:<span class="hljs-built_in"><span class="hljs-built_in">find</span></span> $Lanswer <span class="hljs-string"><span class="hljs-string">"DONE"</span></span>]=<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>={:<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> warning $Lanswer}</code> </pre> <br>  Of course, instead of any direct values ‚Äã‚Äãof the function parameters specified in quotation marks, you can use RooterOS variables with arbitrary names: <br><br>  <i>Invert relay number 4 for 20 seconds without returning the function response:</i> <br><br><pre> <code class="lua hljs">:<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> LaurentIPadr <span class="hljs-string"><span class="hljs-string">"192.168.10.5"</span></span> :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> LaurentRele <span class="hljs-number"><span class="hljs-number">4</span></span> :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> LTime <span class="hljs-number"><span class="hljs-number">20</span></span> [$FuncLaurent2REL Ladr=$LaurentIPadr Lport=<span class="hljs-string"><span class="hljs-string">"8021"</span></span> Rele=$LaurentRele Action=<span class="hljs-string"><span class="hljs-string">"1"</span></span> Time=$Ltime]</code> </pre> <br>  Laurent2 and Laurent112 functions can be applied to any constructions allowed by the Lua ROS language (loops, nesting, branching, etc ...). <br><br>  That is, using the cycle, you can, <i>for example, turn on all the relays of the board:</i> <br><br><pre> <code class="lua hljs">:<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i from=<span class="hljs-number"><span class="hljs-number">1</span></span> to=<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>={[$FuncLaurent2REL Ladr=<span class="hljs-string"><span class="hljs-string">"192.168.0.101"</span></span> Lport=<span class="hljs-string"><span class="hljs-string">"80"</span></span> Rele=$i Action=<span class="hljs-string"><span class="hljs-string">"1"</span></span>];}</code> </pre> <br>  Or, in a similar way, perform group operations on i / o lines. <br><a name="f2OUT"></a><br>  <b>FuncLaurent2OUT - Laurent2 output line state setting function</b> <br><br>  The function is absolutely similar to the previous one.  It has the same parameters, except for replacing the Rele parameter with the Line parameter, which can take values ‚Äã‚Äãin the range of 1-12 (remember that Laurent2 has 12 output lines).  When specifying Action = "1" on the line, a high logic level is set, with Action = "0" - low.  Inverting a line for a specified time also works in the same way as FuncLaurent2REL when setting Time. <br><br>  <i>An example of a function call with setting the output line No. 12 in the ‚ÄúHigh level‚Äù:</i> <br><br><pre> <code class="lua hljs">[$FuncLaurent2OUT Ladr=<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">"92.168.0.1"</span></span> Line=<span class="hljs-string"><span class="hljs-string">"12"</span></span> Action=<span class="hljs-string"><span class="hljs-string">"1"</span></span>]</code> </pre> <br>  The function FuncLaurent2OUT sends the answer ‚ÄúDONE‚Äù in case of a successful completion. <br><br>  Error messages are similar to FuncLaurent2REL, but output lines are reported: <br><br>  "&gt; ERROR: line range mismath" - if an invalid line number is specified in the Line variable; <br>  "&gt; ERROR: line set set mismatch" - in the case of not specified or incorrectly specified Action; <br>  "&gt; ERROR: time mismatch" - in case of an erroneous Time value (not in the range [1-255]); <br>  "&gt; ERROR: device not responded" - in the absence of a response from Laurent to ping; <br>  "&gt; ERROR: command ROS" - in case of an error while executing the URL command RouterOs / tool fetch; <br>  "&gt; ERROR: device protect" - if the "protected device mode" is set and the command cannot be executed; <br>  "&gt; ERROR: command syntax" - syntax error in command entry. <br><cut></cut><br><a name="f2PWM"></a><br>  <b>FuncLaurent2PWM - PWM Signal Power Adjustment Function</b> <br><br>  The function sets the signal power at the PWM output, which can be used to adjust the brightness of the light, for example, or the speed of the fan connected to this output. <br><br>  The syntax of the function is as follows: <br><br><pre> <code class="lua hljs">[$FuncLaurent2PWM Ladr=<span class="hljs-string"><span class="hljs-string">"IP-address"</span></span> Lport=<span class="hljs-string"><span class="hljs-string">"http-port"</span></span> PW=<span class="hljs-string"><span class="hljs-string">"n(%)"</span></span>]</code> </pre> <br>  In the PW parameter, the PWM signal power should be specified in percent (without indicating the% sign), respectively, in the range of 0-100. <br><br>  If the PW parameter is specified incorrectly, the error "&gt; ERROR: PWM range mismath" is issued, other error messages are similar to those for FuncLaurent2REL and FuncLaurent2OUT. <br><a name="f2ST"></a><br>  <b>FuncLaurent2Status - Laurent2 module status request function</b> <br><br>  The function can request the full status of the module in various formats, separately for each of the parameters (all relays, all input lines, all output lines, temperature sensor readings, PWM output power, pulse counters, etc ...), as well as separately from the elements of multielement parameters (specific relay or discrete line).  Laurent modules allow you to query the status of the board regardless of whether the protect mode is enabled or disabled. <br><br>  The recording format of the function is as follows: <br><br><pre> <code class="lua hljs">[$FuncLaurent2Status Ladr=<span class="hljs-string"><span class="hljs-string">"IP-address"</span></span> Lport=<span class="hljs-string"><span class="hljs-string">"http-port"</span></span> Type=<span class="hljs-string"><span class="hljs-string">"all, xml or name"</span></span> N=<span class="hljs-string"><span class="hljs-string">"el. number"</span></span>]</code> </pre> <br>  Wherein: <br><br>  <b>Ladr</b> and <b>Lport</b> - IP address and http-port (the port can be omitted) of the Laurent2 device in the network; <br><br>  <b>Type</b> is a required requested parameter that can take values ‚Äã‚Äã(systime, rele, in, out, adc1, adc2, count1, count2, count2, count4, temp, pwm) according to the technical description of the Laurent2 board.  You can also set Type = ‚Äúall‚Äù or Type = ‚Äúxml‚Äù, not specifying Type at all is not allowed; <br><br>  <b>N</b> is an optional function parameter.  It is used only for for multi-element Type (rele, in, out) and for them determines the number of the requested element of the Type parameter status (for rele N = [1-4], for out N = [1-12], for in N = [1 -6]); <br><br>  If successful (without any errors), the response of the function can be returned in the Lanswer variable, or in the one-dimensional key array of the same name (if the entire module status is queried for Type = "ll" (see below). <br><br>  When setting <b>Type = ‚Äúxml‚Äù, the</b> function returns the module status without changes in the xml format returned by the board.  In RouterOS Mikrotik, this format is hardly convenient, but this feature is preserved. <br><br>  When <b>Type = "all", the</b> function returns the full module status in the one-dimensional Lanswer key array.  The status of individual elements can be extracted from it by the names of the elements.  The keys of the elements have names according to the technical description of the module status parameters (systime, rele, in, out, adc1, adc2, count1, count2, count2, count4, temp, pwm), where: <br><br>  <i>systime</i> - the current system time of the module in seconds, calculated from the moment of power supply; <br><br>  <i>rele</i> - module relay state as a summary data line.  The first character in the line corresponds to relay number 1, the second character to number 2, and so on.  1 in the corresponding position corresponds to the "relay on", 0 - off; <br><br>  <i>in</i> - states on all 6 input discrete lines in the form of a summary line of data.  The first character in the line corresponds to line number 1, the second character is line number 2, and so on.  ‚Äú0‚Äù - low logic level is set on the line, ‚Äú1‚Äù - high logic level, respectively; <br><br>  <i>out</i> - similarly for 12 output lines; <br><br>  <i>adc1</i> - indications of measurements of the channel of the ADC-1 module in Volts; <br><br>  <i>adc2</i> - readings of measurements of the channel of the ADC-2 module in Volts; <br><br>  <i>temp</i> - temperature sensor reading in degrees Celsius; <br><br>  <i>count1</i> is the value of the pulse counter No. 1, an integer in the range of 0‚Äì32766; <br><br>  <i>count2</i> - similarly for the other three pulse counters ...; <br>  <i>count3</i> - <br>  <i>count4</i> - ... <br><br>  <i>pwm</i> is the output power of the signal at the PWM output.  Can take values ‚Äã‚Äãfrom 0 to 100, <br>  in percents <br><br>  <i>As an example, we will get the full status of the device and output only its individual parameters to the router's log - the temperature value of the temperature sensor (temp) and the status of all relays (rele):</i> <br><br><div class="spoiler">  <b class="spoiler_title">Script example number 1 with the function FuncLaurent2Status</b> <div class="spoiler_text"><pre> <code class="lua hljs">:global FuncLaurent2Status; ; #    Lanswer   ; :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Lanswer [$FuncLaurent2Status Ladr=<span class="hljs-string"><span class="hljs-string">"192.168.0.101"</span></span> Type=<span class="hljs-string"><span class="hljs-string">"all"</span></span>]; #      ; :<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> info <span class="hljs-string"><span class="hljs-string">"  Laurent2        -:"</span></span>; :<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> info $Lanswer; :<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> info <span class="hljs-string"><span class="hljs-string">""</span></span>; ; #              : :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> termokey <span class="hljs-string"><span class="hljs-string">"temp"</span></span>; :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> relekey <span class="hljs-string"><span class="hljs-string">"rele"</span></span>; :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Tsend <span class="hljs-string"><span class="hljs-string">""</span></span>; :set Tsend ($Lanswer-&gt;$termokey); :<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> info (<span class="hljs-string"><span class="hljs-string">" : "</span></span>.<span class="hljs-string"><span class="hljs-string">"$Tsend"</span></span>); :<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> info <span class="hljs-string"><span class="hljs-string">""</span></span>; :set Tsend ($Lanswer-&gt;$relekey); :<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> info (<span class="hljs-string"><span class="hljs-string">"-  : "</span></span>.<span class="hljs-string"><span class="hljs-string">"$Tsend"</span></span>); :<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> info <span class="hljs-string"><span class="hljs-string">""</span></span>; ; #        : :<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> info (<span class="hljs-string"><span class="hljs-string">"  :"</span></span>.<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> rezult; <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Saction; :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Reletext; :<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i from=<span class="hljs-number"><span class="hljs-number">1</span></span> to <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:set rezult [:pick $Tsend ($i<span class="hljs-number"><span class="hljs-number">-1</span></span>) $i]; :<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rezult=<span class="hljs-string"><span class="hljs-string">"0"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>={:set Saction <span class="hljs-string"><span class="hljs-string">"&lt;  &gt;"</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>={:set Saction <span class="hljs-string"><span class="hljs-string">"&lt;  &gt;"</span></span>} :<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> info (<span class="hljs-string"><span class="hljs-string">" ‚Ññ"</span></span>.<span class="hljs-string"><span class="hljs-string">"$i"</span></span>.<span class="hljs-string"><span class="hljs-string">" "</span></span>.<span class="hljs-string"><span class="hljs-string">"$Saction"</span></span>); :set Reletext (<span class="hljs-string"><span class="hljs-string">"$Reletext"</span></span>.<span class="hljs-string"><span class="hljs-string">" ‚Ññ"</span></span>.<span class="hljs-string"><span class="hljs-string">"$i"</span></span>.<span class="hljs-string"><span class="hljs-string">" "</span></span>.<span class="hljs-string"><span class="hljs-string">"$Saction"</span></span>.<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)} :<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> info <span class="hljs-string"><span class="hljs-string">""</span></span>;</code> </pre> <br></div></div><br>  The output of the above script to the log of the router: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd1/988/91d/dd198891d9152b83b6cd7e9e9259c87b.jpg" alt="image"><br><br>  * Note: <br><br>  - In RouterOS, the elements of the key arrays are arranged in alphabetical order according to the names of the keys.  This does not affect their selective output, you can query the necessary elements of the array by name or in any order. <br>  - The temperature sensor in this case shows -273 ¬∞ C (not connected). <br>  - Clearly shows the status of all four built-in relays of the module (on / off). <br><br>  For multi-element parameters (such as rele, in, or out) that contain the status of all the corresponding elements in their line, respectively, their position number, you can only output a specific element (the status of a specific relay, input line or output line).  This is useful when you need to get the status of individual heterogeneous parameters and elements or the status of a group of elements so as not to call the function of requesting the status of a specific element using the N parameter in the loop. <br><br>  <i>For example, from the already received full status of the module, we derive the state of only the input line No. 6:</i> <br><br><pre> <code class="lua hljs">#     ; :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> numelem <span class="hljs-number"><span class="hljs-number">6</span></span>; #       ; :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Par ($Lanswer-&gt;<span class="hljs-string"><span class="hljs-string">"in"</span></span>) :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> elem [:pick $Par ($numelem<span class="hljs-number"><span class="hljs-number">-1</span></span>) $numelem] :<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> info $elem</code> </pre> <br>  <i>You can also directly request not the full status of the board, but only the state of the desired parameter, for example, all output lines (out):</i> <br><br><pre> <code class="lua hljs">:<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Lanswer [$FuncLaurent2Status Ladr=<span class="hljs-string"><span class="hljs-string">"192.168.0.101"</span></span> Type=<span class="hljs-string"><span class="hljs-string">"out"</span></span>]; :set Lanswer (<span class="hljs-string"><span class="hljs-string">"   : "</span></span>.<span class="hljs-string"><span class="hljs-string">"$Lanswer"</span></span>); :<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> info $Lanswer;</code> </pre><br>  <i>Or just one element of the multi-element parameter (let it be relay number 7):</i> <br><br><pre> <code class="lua hljs">:<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Lanswer [$FuncLaurent2Status Ladr=<span class="hljs-string"><span class="hljs-string">"192.168.0.101"</span></span> Type=<span class="hljs-string"><span class="hljs-string">"rele"</span></span> N=<span class="hljs-string"><span class="hljs-string">"7"</span></span>]; :<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> info $Lanswer;</code> </pre> <br>  For parameters with one element (such as temp, cont2, adc1, systime, etc.) N is not specified, and if specified, it is ignored. <br><br>  For Type, for which N is possible (in, out, rele), but not specified, the status of the entire field specified in Type as a string is returned, say ‚Äú0100011000‚Äù (taking into account the number of elements of this Type), where each position corresponds to the value log 1 or log 0. <br><br>  If a multi-element parameter is requested and N is specified in the function, and it is specified incorrectly (N &lt;1 or N&gt; possible for this Type) - the entire Type parameter is also returned (the error of the incorrect range N is not output). <br><br>  In case of unsuccessful input / execution, the function may issue the following error messages to the Lanswser variable in the log: <br><br>  &gt; ERROR: device not responded - in the absence of a response from the Laurent module to ping; <br>  &gt; ERROR: command ROS - in case of an error while executing the URL command RouterOs / tool fetch; <br>  &gt; ERROR: TYPE MISMATCH - in case of a wrong status parameter specified in the request (rele, out, in, all, etc ...) <br><br>  Below is a sample script code that allows you to work entirely or selectively with the status of a Laurent device.  After analyzing the logic of his work, I hope you can write any custom scripts for querying the status of a module. <br><br><div class="spoiler">  <b class="spoiler_title">Script example number 2 of the function FuncLaurent2Status</b> <div class="spoiler_text"><pre> <code class="lua hljs">:global FuncLaurent2Status; ; :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Ltype <span class="hljs-string"><span class="hljs-string">"out"</span></span>; # all ‚Äì          (rele, out, temp ...); :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Npar <span class="hljs-string"><span class="hljs-string">""</span></span>; # -               (<span class="hljs-string"><span class="hljs-string">""</span></span>); :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> PR <span class="hljs-string"><span class="hljs-string">"all"</span></span>; #-  <span class="hljs-string"><span class="hljs-string">"all"</span></span>               ‚Ññ Npar; ; :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Lanswer [$FuncLaurent2Status Ladr=<span class="hljs-string"><span class="hljs-string">"192.168.0.101"</span></span> Lport=<span class="hljs-string"><span class="hljs-string">"80"</span></span> Type=$Ltype]; :<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($Lanswer=<span class="hljs-string"><span class="hljs-string">"&gt;ERROR: device protect"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>={:<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> <span class="hljs-string"><span class="hljs-string">"  .    "</span></span>}; :<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([:<span class="hljs-built_in"><span class="hljs-built_in">find</span></span> $Lanswer <span class="hljs-string"><span class="hljs-string">"ERROR"</span></span>]=<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>={:<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> $Lanswer;} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>={ :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> keytype [:toarray <span class="hljs-string"><span class="hljs-string">"systime, rele, in, out, adc1, adc2, count1, count2, count3, count4, temp, pwm"</span></span>]; :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> typepar {<span class="hljs-string"><span class="hljs-string">"systime"</span></span>=<span class="hljs-string"><span class="hljs-string">"1"</span></span>; <span class="hljs-string"><span class="hljs-string">"rele"</span></span>=<span class="hljs-string"><span class="hljs-string">"4"</span></span>; <span class="hljs-string"><span class="hljs-string">"in"</span></span>=<span class="hljs-string"><span class="hljs-string">"6"</span></span>; <span class="hljs-string"><span class="hljs-string">"out"</span></span>=<span class="hljs-string"><span class="hljs-string">"12"</span></span>; <span class="hljs-string"><span class="hljs-string">"adc1"</span></span>=<span class="hljs-string"><span class="hljs-string">"1"</span></span>; <span class="hljs-string"><span class="hljs-string">"adc2"</span></span>=<span class="hljs-string"><span class="hljs-string">"1"</span></span>; <span class="hljs-string"><span class="hljs-string">"count1"</span></span>=<span class="hljs-string"><span class="hljs-string">"1"</span></span>; <span class="hljs-string"><span class="hljs-string">"count2"</span></span>=<span class="hljs-string"><span class="hljs-string">"1"</span></span>; <span class="hljs-string"><span class="hljs-string">"count3"</span></span>=<span class="hljs-string"><span class="hljs-string">"1"</span></span>; <span class="hljs-string"><span class="hljs-string">"count4"</span></span>=<span class="hljs-string"><span class="hljs-string">"1"</span></span>; <span class="hljs-string"><span class="hljs-string">"temp"</span></span>=<span class="hljs-string"><span class="hljs-string">"1"</span></span>; <span class="hljs-string"><span class="hljs-string">"pwm"</span></span>=<span class="hljs-string"><span class="hljs-string">"1"</span></span>}; :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> T; :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> row; :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> rezult; :<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($Ltype=<span class="hljs-string"><span class="hljs-string">"all"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>={ :<span class="hljs-built_in"><span class="hljs-built_in">foreach</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>=$keytype <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>={ :set row ($Lanswer-&gt;$i); <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> info (<span class="hljs-string"><span class="hljs-string">"$i"</span></span>.<span class="hljs-string"><span class="hljs-string">" = "</span></span>.<span class="hljs-string"><span class="hljs-string">"$row"</span></span>);} } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>={:set T ($typepar-&gt;<span class="hljs-string"><span class="hljs-string">"$Ltype"</span></span>); :<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($PR=<span class="hljs-string"><span class="hljs-string">"all"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>={:set rezult $Lanswer} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>={:set rezult (<span class="hljs-string"><span class="hljs-string">". . "</span></span>. <span class="hljs-string"><span class="hljs-string">"$[:pick $Lanswer ($Npar-1) $Npar]"</span></span>)} :<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> info (<span class="hljs-string"><span class="hljs-string">"$Ltype"</span></span>.<span class="hljs-string"><span class="hljs-string">"  "</span></span>.<span class="hljs-string"><span class="hljs-string">"$T"</span></span>.<span class="hljs-string"><span class="hljs-string">"; "</span></span>.<span class="hljs-string"><span class="hljs-string">"$Ltype "</span></span>.<span class="hljs-string"><span class="hljs-string">"$Npar"</span></span>.<span class="hljs-string"><span class="hljs-string">": "</span></span>.<span class="hljs-string"><span class="hljs-string">"$rezult"</span></span>);}}; :<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> info <span class="hljs-string"><span class="hljs-string">""</span></span>;</code> </pre> <br></div></div><br><h3>  Functions for the Laurent112 module </h3><br>  <b>The Laurent112 module is</b> intended only for connecting loads, but the number of built-in relays is 12. Accordingly, only two functions were created to support its functionality - the installation of the <b>FuncLaurent112REL</b> relay and the request for the status of the <b>FuncLaurent112Status</b> module. <br><a name="f112REL"></a><br>  <b>FuncLaurent112REL</b> - the function of working with the relay module Laurent112 is completely similar to that for Laurent2, described above.  The Rele parameter of this function can vary in the range [1-12]. <br><a name="f112ST"></a><br>  <b>FuncLaurent112Status</b> - <b>Laurent112</b> status request function is limited to issuing only two status parameters - system time elapsed from power supply to the module (systime) in seconds and the satus of the relay (rele). <br><br>  Similar to the Laurent2 status request function, the FuncLaurent112Status function can display the full Laurent112 status in the xml module format (when setting Type = "xml"), the full status as a key array placed in Lanswer (with Type = "all") or separately for systime and rele.  For Type = ‚Äúrele‚Äù, the task is supported in the request of the parameter N with the indication of the number of the relay whose status is to be requested.  If N is not specified, or is set not in the correct range of possible values ‚Äã‚Äã(from 1 to 12), the function returns a string containing the status of all relays where the relay status is encoded with zeros (0) or units (1) in the corresponding position of each relay position of the relay in the string . <br><br>  The format for accessing these functions and returning error messages is similar to the corresponding Laurent2 functions (see above). <br><br><h3>  How to practice using the implemented integration of the Mikrotik router and Laurent Internet modules? </h3><br>  One of the Important moments of the integration results of the Mikrotik router and the Laurent Internet modules mentioned should be considered autonomy - that is, the possibility of its existence between two network devices, none of which are PCs and each of which can work without human intervention (user, administrator).  In this case, the router is the main device of any local network and, as a rule, the gateway to the Internet.  Considering the capabilities of the RouterOS and the wide hardware spectrum of the RouterBoard, all possible applications of this integration are difficult to imagine, it all depends on the technical tasks and imagination of the applicator. <br><br>  Most of the autonomous operation of the Laurent board, after appropriate configuration, including the CAT system, can generally be performed independently. <br><br>  <b><i>The main applications of Laurent in integration with the Mikrotik router are the following:</i></b> <br><br><ol><li>    -  ,     . </li><li> /       (,  ,   ) </li><li>  ¬´¬ª           . </li><li> ¬´ ¬ª   Laurent,    /,  )      . </li><li> /   (,    ‚Ä¶),          ,         SMS. </li></ol><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, we consider examples of the implementation of some of them.</font></font></b></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1. ‚ÄúPhysical protection‚Äù of access to an important network resource.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suppose there is an important device in your local network that you would like to additionally protect against access from outside. As you know, there are a great number of network protections, for example, the port knoking method, the organization of various VPN tunnels, etc ...</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">They are all good, but almost all have been opened for a long time. Of course, if you are not a banker, then professionals will not engage in hacking your network, and, as a rule, even hack even lightweight defenses for ordinary users.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nevertheless, there are quite a few hacking facts about remote desktops, file servers, etc ..., which is not very pleasant. What can our integration offer in this sense?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mainly - the physical limitation of access to a resource in time, and this is one of the most important factors affecting the possibility of hacking the network from the outside. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, remember that all software methods of network protection (for example, NAT and FIREWALL of the router itself) protect access to any network resource that is constantly running on the network. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With the help of Mikrotik-network relay integration (in this case, the Laurent module), it is easy and convenient, in addition to these protection methods, to make a ‚Äúphysical block‚Äù of access to the device we need on the network.</font></font> How to implement it? <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connect the power of our protected device (for example, a secret file server with your personal archive of data about your company) to one of the Laurent module's relays, for example, to relay 1. We will configure any VPN server, for example, one of the most popular routers, such as one of the most popular ones - pptp server . RouterOc allows you to flexibly configure individual PPP-profiles for server user users (PPP-profile), individually for each VPN client or group of clients. For example, we have a configured PPP-profile for a VPN client named D_Ivanov. In addition to setting the login and password for the client login and a host of other possible network settings for each PPP-profile, RouterOS allows you to set the PPP-scripts options ‚Äúon Up‚Äù and ‚Äúon Down‚Äù, into which you can put the directly executed script code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Put the following code in these fields:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/41b/678/f78/41b678f787cdfc00b5b8c83015dec77f.jpg" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then, when the D_Ivanov VPN client is connected to the router with its username and password (first stage of protection), the script located in ‚Äúon Up‚Äù will be executed in 5 seconds, which will switch on relay No. 1 using the FuncLaurent2REL function (remember that 1 is powered by our "secret" file server, our second stage of "physical protection"). The server power will be turned on, it will boot up and the client will get access to it ‚Äúoutside‚Äù via VPN. As soon as the VPN client breaks the tunnel (terminates the session or the session is terminated due to violations of Internet traffic), the second script located in the ‚Äúon Down‚Äù field will turn off the power of our file server and the server will not be physically accessible. This allows the server (or any other device,whichever you want) is not always in working condition (and be a potentially vulnerable target for password pickers all 24 hours a day), and physically be activated only for the duration of the VPN client access.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This method of double protection is very effective, because ‚ÄúGetting close‚Äù to a non-working device, standing already behind the protected router, finding out its model, pinging ports is simply not possible, and it‚Äôs very difficult to do it in a short time of its operation (the hacker doesn‚Äôt know when you decide to connect via VPN to your router). Of course, in the same fields of PPP profile scripts, you can add a code that sends messages to the mail or mobile phone about entering the VPN client (which will additionally inform, in particular, the administrator about hacking the router's VPN server, but not your secret file server yet! will quickly protect). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Turn on / off individual network segments.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operating with functions of working with relays or output lines (you should not forget that they can also be connected to relays or relay blocks), for example, you can physically turn on / off the subsidiary networks and subnets behind the router. The Laurent2 module has 4 built-in relays and 12 output lines, if you use them all (connect relay or relay blocks to the output lines), you get 16 power outputs. Laurent112 carries 12 pre-built built-in relays. That is, having one of these Laurent modules, it is possible to organize the separate inclusion of 16 or 12, respectively, wifi access points, switches or similar network devices.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, it is possible to regulate the operation of the network of a whole large office or enterprise, turning on / off, rebooting physically ‚Äúguest‚Äù networks, ‚Äústreet‚Äù access points, network bridges and other points. And this can be done not by the operator / network administrator, but by the Mikrotik router in automatic mode, including on a schedule or under any conditions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, enable through our function wifi-access point. If it does not turn on, that is, it does not respond to ping, does not connect clients (this is also checked by our script) - turn off its power and turn on another, backup point, etc. ... It will also limit the expenditure of traffic and additionally ensure the safety of certain network segments ( for example, street). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Monitoring of Laurent modules and the work of integration with Mikrotik on a schedule</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the Laurent modules themselves "do not know how" to read time from the servers of the exact time, the work on schedule in them is very limited. Modules can only rely on their own system time, which starts counting from the power supply to the board itself. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Router Mikrotik operates with a ‚Äúreal‚Äù daily time date and can perform any actions on RouterOS on an exact schedule by tracking this time with a script or in its own ‚Äúscheduler‚Äù (in WINBOX it is available in the / system scheduler tab). There we can put scripts that use our functions to support Laurent modules, adjusting the operation logic for them (you can ‚Äútrigger‚Äù at the start of the router, at the start with the necessary delay, at a certain time of day once or with regular repetition).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using these capabilities, you can, in addition to the CAT system of Laurent modules, not only manage any loads and lines, but also read the status of the module or its individual elements in RouterOS Mikrotik. Further, you can make any decisions similar to the conditions of the CAT system, as well as inform the administrator and the users of the router about the events to their email addresses and / or mobile numbers via SMS. In this case, you can use the free features of sending messages from a postal address to a mobile number, for example, a resource sms.ru or similar. You can also send data from Mikrotik to Telegram bots. There are special instructions on how to set it up.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As an example, the following is a script for obtaining full status from the Laurent module with the formation of a convenient visual report and sending this report to the user's email address (do not forget to change the user‚Äôs Smail variable to your own). </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laurent2 status request script with email report</font></font></b> <div class="spoiler_text"><pre> <code class="lua hljs"># #   Laurent2 c   E-mail  # ; #     ; :global FuncMail; # -    ; :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Smail <span class="hljs-string"><span class="hljs-string">"user@mail.ru"</span></span>; # -       ; ; :global FuncLaurent2Status; # -     Laurent2; :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Sadr <span class="hljs-string"><span class="hljs-string">"192.168.1.101"</span></span>; # - IP- ; :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Sport <span class="hljs-string"><span class="hljs-string">"80"</span></span>; # - http-,    :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Stype <span class="hljs-string"><span class="hljs-string">"all"</span></span>; # -    :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> keytype [:toarray <span class="hljs-string"><span class="hljs-string">"systime, rele, in, out, adc1, adc2, count1, count2, count3, count4, temp, pwm"</span></span>]; :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Tsend <span class="hljs-string"><span class="hljs-string">""</span></span>; ; #    Laurent; ; :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Lanswer [$FuncLaurent2Status Ladr=<span class="hljs-string"><span class="hljs-string">"192.168.0.101"</span></span> Lport=$Sport Type=$Stype]; ; #      Mtext ; :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Mtext; :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Stext; :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> row; :<span class="hljs-built_in"><span class="hljs-built_in">foreach</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>=$keytype <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>={ :set row ($Lanswer-&gt;$i); :set Stext (<span class="hljs-string"><span class="hljs-string">"$i"</span></span>.<span class="hljs-string"><span class="hljs-string">" = "</span></span>.<span class="hljs-string"><span class="hljs-string">"$row"</span></span>.<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); :set Mtext (<span class="hljs-string"><span class="hljs-string">"$Mtext"</span></span>.<span class="hljs-string"><span class="hljs-string">"$Stext"</span></span>)} ; #   -     Reletext ; :set Tsend ($Lanswer-&gt;<span class="hljs-string"><span class="hljs-string">"rele"</span></span>); :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> rezult; <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Saction; :<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Reletext; :<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i from=<span class="hljs-number"><span class="hljs-number">1</span></span> to <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:set rezult [:pick $Tsend ($i<span class="hljs-number"><span class="hljs-number">-1</span></span>) $i]; :<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rezult=<span class="hljs-string"><span class="hljs-string">"0"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>={:set Saction <span class="hljs-string"><span class="hljs-string">"&lt;  &gt;"</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>={:set Saction <span class="hljs-string"><span class="hljs-string">"&lt;  &gt;"</span></span>} :set Reletext (<span class="hljs-string"><span class="hljs-string">"$Reletext"</span></span>.<span class="hljs-string"><span class="hljs-string">" ‚Ññ"</span></span>.<span class="hljs-string"><span class="hljs-string">"$i"</span></span>.<span class="hljs-string"><span class="hljs-string">" "</span></span>.<span class="hljs-string"><span class="hljs-string">"$Saction"</span></span>.<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)} ; #           ; :<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> info (<span class="hljs-string"><span class="hljs-string">"STATUS Laurent2 module IP "</span></span>.<span class="hljs-string"><span class="hljs-string">"$Sadr"</span></span>.<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); :<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> info $Mtext; :<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> info <span class="hljs-string"><span class="hljs-string">""</span></span>; :<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> info $Reletext; :set Mtext (<span class="hljs-string"><span class="hljs-string">"Router "</span></span>.<span class="hljs-string"><span class="hljs-string">"$[/system identity get name]"</span></span>.<span class="hljs-string"><span class="hljs-string">" about STATUS Laurent2 module IP "</span></span>.<span class="hljs-string"><span class="hljs-string">"$Sadr"</span></span>.<span class="hljs-string"><span class="hljs-string">"\n"</span></span>.<span class="hljs-string"><span class="hljs-string">"\n"</span></span>.<span class="hljs-string"><span class="hljs-string">"$Mtext"</span></span>.<span class="hljs-string"><span class="hljs-string">"\n"</span></span>.<span class="hljs-string"><span class="hljs-string">"$Reletext"</span></span>); [$FuncMail Email=$Smail Mailtext=$Mtext]</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When executing the script code of the above example, the mail.ru mail server receives a letter of the following type and content: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/770/d1e/0b4/770d1e0b4a23a68b1fab8400ed9b8623.jpg" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can improve and extend the given example script code at your discretion. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The possibilities of implementing the Mikrotik and Laurent ingraction are not limited to the examples described above. </font><font style="vertical-align: inherit;">It is quite realistic to create almost any solutions, depending on the specific tasks of the user.</font></font><br><br><h3>  Conclusion </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is possible that during the operation of the first version of the library of support scripts for the modules Laurent2 and Laurent112, any errors will be revealed, or the users will have comments or suggestions. </font><font style="vertical-align: inherit;">The author will be glad if you tell him about it, to improve the library scripts. </font><font style="vertical-align: inherit;">It is also possible in principle to create support for other KernelChip modules with an RJ45 network interface, such as the JEROME Internet module. </font></font><br><br> <b><a href="https://cloud.mail.ru/public/CWXE/36yN6p9pp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Download a library of scripts for managing Internet modules Laurent2 and Laurent112. A </font></font></a></b> <br><br> <b><a href="https://apimikrotik.blogspot.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blog about managing Internet modules from Mikrotik RouterOS.</font></font></a></b> <br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">01.02.2018 Serkov Sergey Vladimirovich </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">serkov1375@mail.ru</font></font></div><p>Source: <a href="https://habr.com/ru/post/348120/">https://habr.com/ru/post/348120/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348108/index.html">How to destroy the Internet?</a></li>
<li><a href="../348110/index.html">Visualization of data for moviegoers: scrap movie recommendations and make interactive graph</a></li>
<li><a href="../348112/index.html">Wolfram Language (Mathematica) Virtual Textbook, 5th Edition</a></li>
<li><a href="../348116/index.html">‚ÄúProgrammer pragmatist. The journey from the apprentice to the master ": briefly about the main thing (part one)</a></li>
<li><a href="../348118/index.html">Expanding Ansible functionality with modules</a></li>
<li><a href="../348122/index.html">Issue # 9: IT training - current issues and challenges from leading companies</a></li>
<li><a href="../348124/index.html">Why most people do not use two-factor authentication?</a></li>
<li><a href="../348126/index.html">Can I use the CQRS pattern in GO?</a></li>
<li><a href="../348128/index.html">R as a lifeline for the system administrator</a></li>
<li><a href="../348130/index.html">[DotNetBook] Stackalloc: forgotten C # command</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>