<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CFD 3D: a simple water simulator</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 CFD (Computational fluid dynamics) - computational fluid dynamics. 
 It is used to simulate different processes in liquids, as well as ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>CFD 3D: a simple water simulator</h1><div class="post__text post__text-html js-mediator-article"><table><tbody><tr><td><img src="https://habrastorage.org/storage3/ca2/c08/d2a/ca2c08d2ad18d4d1d9c7b0062cde53aa.png"><br></td><td><img src="https://habrastorage.org/storage3/4ca/d01/7cf/4cad017cf7034140929e9927a249846c.png"><br></td></tr></tbody></table><br><br><h4>  Introduction </h4><br>  <b>CFD (Computational fluid dynamics)</b> - computational fluid dynamics. <br>  It is used to simulate different processes in liquids, as well as different types of liquids (for example, honey, oil is all liquids). <br><br>  In this post we consider a 2D simulator of ordinary water with an open surface and obstacles (for the 3D version, everything is the same as + <a href="https://sourceforge.net/projects/cfdfreesurface3d/files/%3Fsource%3Dnavbar">source codes</a> are available). <br>  The surface of the water is a boundary separating the water from the air. This allows you to simulate waves, falling drops, etc. <br><a name="habracut"></a><br>  I decided to write my simulator for several reasons.  One of them is the lack of normally written source codes on this topic on the Internet.  All that I found was either on Fortran, or only 2d, or it was written very difficult to understand. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, the main features of the simulator: <br><ul><li>  real-time mode </li><li>  simple and clear calculation scheme + explicit, implicit </li><li>  open source </li><li>  there are both 2d and 3d </li><li>  built-in simple opengl render </li><li>  xml scene description </li></ul><br><br>  In terms of calculations, I pushed away from the Navier-Stokes equations (as well as from the sources found in the internet). <br>  This is a system of partial differential equations describing the motion of a viscous incompressible fluid.  The word incompressible here is rather a tick, since all liquids are by definition incompressible.  Viscosity refers to friction between individual particles, it does not allow them to scatter in different directions, as is the case with gas, when it fills all the volume allocated to it.  Particles of a liquid try to keep together whenever possible. <br><br>  In my simulator, I used a slightly modified set of equations, more on that below ... <br><br><h4>  <b>Hydrodynamic equations</b> </h4><br>  So, here are the basic Navier-Stokes equations in general (vector) form: <br><img src="https://habrastorage.org/storage3/6c5/b00/3d5/6c5b003d500f5be1ac72c59f4b4e65b4.png"><br>  Here: <br><ul><li>  u is the traditional designation of the velocity field (in 2D, the speed consists of 2 components in x and in y directions - they are designated respectively as u and v) <br></li><li>  p is the pressure </li><li>  t - time </li><li>  the symbol rho is the density of the fluid </li><li>  nu symbol - kinematic viscosity coefficient </li><li>  Fext - any external forces acting on the fluid, such as gravity (g) </li></ul><br>  The first of the equations is the equation of motion, the second is the continuity equation. <br>  The equation of motion looks like Newton's equation ma = F, where we have on the right - the sum of the forces acting on the fluid is pressure, diffusion, gravity ... <br><br>  For the 2D version of the equation take the form (here they are already presented in a dimensionless form): <br><br><img src="https://habrastorage.org/storage3/b71/7c6/009/b717c600929e15c4f7cdad103d18f0cb.png"><br><br>  The motion equation is now represented by 2 equations - for 2 speed components - u and v. <br>  Regarding the new coefficient, Re is the Reynolds number (it turned out in the transition to dimensionless variables), which replaces 2 previous coefficients at once ‚Äî coeff.  density and viscosity.  It depends on him what water will be like - honey or ordinary water.  The more Re the more liquid is like ordinary water. <br>  In parentheses, this is our expression that defines the viscous behavior of a fluid (or diffusion).  The remaining members on the right side (except gravity) are convection.  In the left side - the speed and pressure. <br><br>  Next, I slightly simplified these equations: <br><br><img src="https://habrastorage.org/storage3/fea/f45/921/feaf459212eeaca1ac6928997bc67e63.png"><br><br>  As you can see, convection has disappeared, which slightly impairs the behavior of the liquid, but overall it looks visually quite normal. The absence of convection gives several advantages at once ‚Äî the non-linearity disappears, stability improves and the time step can be made longer, and convection is usually a very expensive term in terms of the necessary calculations. , besides, in order to correctly discretize convection, special schemes are used - which looks rather cumbersome. <br><br>  When solving equations, a special scheme is used, called Splitting. I would like to dwell on this in more detail, but this is more likely for a separate post. The topic is quite large. It is very well described in the book <br>  Bridson R. Fluid Simulation for Computer Graphics.pdf in the Overview of numerical simulation section. <br>  And here Numerical simulation in fluid dynamics Griebel M Dornseifer T Neunhoeffer T SIAM 1998 <br><br>  Here is the split equation scheme: <br><br><img src="https://habrastorage.org/storage3/81b/b3b/19d/81bb3b19dbb27fe9391f7774bb873ce5.png"><br><br>  For the time step, the Euler method is used. Also, at the first step, we lower the pressure and get an intermediate calculation of the speeds F and G. These speeds, besides not taking the pressure into account, will not yet satisfy the continuity equation.  By cunning manipulation, an equation is found for calculating pressure, which also solves the problem with the continuity equation.  Solving this equation using the already calculated F and G we find the new pressure P. <br>  Further, at the 3rd step, the velocity correction takes into account the calculated pressure. <br>  This completes one full time step and at the next step everything repeats again. <br><br><h4>  Discretization of equations </h4><br>  For discretization of equations, the finite difference method is used.  For the time step, the standard Euler method is used - it looks schematically like this: u (n + 1) = u (n) + dt * f, <br>  where f means the whole part of the equation which does not include the time differential. <br><br>  In general, the value of speed at a new time (u (n + 1)) is found from the value at the previous time (u (n)). <br>  I will not describe the discrete analogues of the equations in this post. This is very well done in the book ‚ÄúNumerical simulation in fluid dynamics‚Äù (Griebel M Dornseifer T Neunhoeffer T SIAM 1998). <br><br>  To solve discrete equations, a non-matrix method of solving is used, but an iterative one - Gauss-Seidel.  It does not require pre-assembly of matrices and does not require any intermediate arrays at all, makes it easy to modify the design scheme, the approximate solution is already after 1 iteration - which greatly speeds up the whole simulation. <br><br>  In this post we will consider the 2D case, the main focus will be on explaining the boundary conditions, since  they cause the greatest difficulties in solving equations.  The entire simulated area is divided into imax points horizontally and jmax vertically.  It turns out the grid imax * jmax cells. <br>  To them from 4 borders are added boundary points.  The total is an array of size (imax + 2) * (jmax + 2). <br><br>  Each cell has its own velocity and pressure values ‚Äã‚Äã- it‚Äôs customary to talk about the velocity vector field and the scalar pressure field on the computational grid. <br>  U is the velocity of a particle in a cell in x <br>  V is the particle velocity in the cell along y <br>  P - pressure <br><br>  It is usually customary to place the calculated variables (U, V, P) in the center of the cells, but in the case of fluid modeling this always causes problems with the solution ‚Äî it turns out to be not entirely correct and oscillating.  Therefore, CFD uses an exploded grid (staggered grid) - it is also called leapfrog. <br><br><img src="https://habrastorage.org/storage3/50e/d48/9ab/50ed489ab58268cfca313f0315370870.png"><br><br>  It can be seen from the figure that the speeds are not in the cell itself but on its faces, u is on the right border of the cell, and v is on the upper border. <br><br><h4>  Boundary conditions on the walls </h4><br>  For the calculation by the finite difference method, we need to set the values ‚Äã‚Äã(u, v, p) at the boundaries of the computational grid. These are 4 walls - on the left, right, below and above. The boundary conditions can be of types no-slip and free-sleep;  There are other types, but these are more specialized conditions than general ones. <br><br>  <b>free-sleep</b> - this means that the fluid slides freely along the wall, as if there is no friction and nothing prevents it from moving along it. <br>  In this post we do not consider this type of boundary conditions. <br><br>  <b>no-slip</b> is a sticking condition - that is, the liquid slows down when it hits a wall. <br>  This means that the velocity of the fluid coincides with the velocity of the wall (that is, in our case it is equal to zero on the fixed boundary). <br><br>  Consider, for example, only the right boundary: the velocity component u = 0, since  it is perpendicular to the wall and water should not penetrate the boundary. <br>  The v component for the no-slip border case is also 0, but for our staggered grid it will have to be adjusted. For the v component, given that v is not right on the border, you need to correct the expression a little. <br>  v on the wall will be equal to the average between the 2 nd last cells.  v_g = (v [imax + 1] [j] + v [imax] [j]) / 2 <br>  v_g equate zero ((v [imax + 1] [j] + v [imax] [j]) / 2 = 0) and find the value v [imax + 1] [j], which we need to specify in the program: <br>  v [imax + 1] [j] = - v [imax] [j]; <br>  The same must be done for u components at the upper boundary. <br><br><img src="https://habrastorage.org/storage3/f35/b1b/dac/f35b1bdac569af6786ede2f43261ec18.png"><br><br>  4 borders are represented in the array with the following coordinates: <br><br>  <b>left wall</b> <br><br>  u [0] [j], where j runs through the whole wall <br>  v [0] [j] <br><br>  Here is how it looks in code: <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt;= jmax + <span class="hljs-number"><span class="hljs-number">1</span></span>; j++) { U[<span class="hljs-number"><span class="hljs-number">0</span></span>][j] = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; V[<span class="hljs-number"><span class="hljs-number">0</span></span>][j] = -V[<span class="hljs-number"><span class="hljs-number">1</span></span>][j]; }</code> </pre> <br><br>  <b>bottom wall</b> <br><br>  u [i] [0] <br>  v [i] [0] <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= imax + <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { U[i][<span class="hljs-number"><span class="hljs-number">0</span></span>] = -U[i][<span class="hljs-number"><span class="hljs-number">1</span></span>]; V[i][<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; }</code> </pre><br><br>  <b>right wall</b> <br>  Because we have a spaced grid, then on the right wall we have a border for the values ‚Äã‚Äãof u that do not pass along the last column but on the penultimate one ‚Äî therefore, we set the values ‚Äã‚Äãfor U in the cell - U [imax] [j]. <br><br>  u [imax] [j] <br>  v [imax + 1] [j] <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt;= jmax + <span class="hljs-number"><span class="hljs-number">1</span></span>; j++) { U[imax][j] = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; V[imax + <span class="hljs-number"><span class="hljs-number">1</span></span>][j] = -V[imax][j]; }</code> </pre><br><br>  <b>upper wall</b> <br>  Here, for values ‚Äã‚Äãof v, the boundary passes along the penultimate line - jmax - therefore, we set the values ‚Äã‚Äãfor V in the cell - V [i] [jmax] <br><br>  u [i] [jmax + 1] <br>  v [i] [jmax] <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= imax + <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { U[i][jmax + <span class="hljs-number"><span class="hljs-number">1</span></span>] = -U[i][jmax]; V[i][jmax] = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; }</code> </pre><br><br>  To test the basic solver, all boundary values ‚Äã‚Äãcan be set = 0. <br><br>  We also need to put pressure on the borders. The pressure is set at the center of the cells and not at the edges as speed. Therefore, everything is very simple with it. The pressure at the borders can be set the same as in the neighboring cells. Just copy the values ‚Äã‚Äãfrom the neighboring cells. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt;= jmax; j++) { <span class="hljs-comment"><span class="hljs-comment">//   P[0][j] = P[1][j]; //   P[imax + 1][j] = P[imax][j]; } for (i = 1; i &lt;= imax; i++) { P[i][0] = P[i][1]; P[i][jmax + 1] = P[i][jmax]; }</span></span></code> </pre><br><br><h4>  Boundary conditions on obstacles </h4><br>  Obstacles are represented by the C_B flag.  The boundary conditions for them are set on the same principle as for the external walls. I will give 2 examples of pressure setting: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsObstacle(i, j)) { <span class="hljs-comment"><span class="hljs-comment">//     -  -    P   if (IsFluid(i, j - 1)) { P[i][j] = P[i][j - 1]; } //   -  ... else if (IsFluid(i - 1, j)) { P[i][j] = P[i - 1][j]; } // ....... }</span></span></code> </pre><br><br>  For an angular cell, we take the average of the values ‚Äã‚Äãof the water cells surrounding it. For example, let's take an obstacle; there will be water on the left and on top of it. Then we consider the pressure in the obstacle cell as: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsFluid(i - <span class="hljs-number"><span class="hljs-number">1</span></span>, j) &amp;&amp; IsFluid(i, j + <span class="hljs-number"><span class="hljs-number">1</span></span>)) { P[i][j] = (P[i][j + <span class="hljs-number"><span class="hljs-number">1</span></span>] + P[i - <span class="hljs-number"><span class="hljs-number">1</span></span>][j]) / <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre><br><br><h4>  Surface boundary conditions </h4><br>  The surface and its movement is modeled with particles.  (Sources with boundary conditions on the surface, made as described in this section are in the folder simpletestobstacle.) <br><br>  Initially, the particles are placed in cells with liquid, 4 pieces per cell (1 next to each corner).  Then the particles at each step are moved using the simple Euler method from classical mechanics.  The speeds for movement are taken in each cell as average across the entire cell (although it is not a problem to use, for example, interpolation). <br><br><pre> <code class="cs hljs"> x = particles[k].x; y = particles[k].y; <span class="hljs-comment"><span class="hljs-comment">//        i = (int)(x / delx); j = (int)(y / dely); u = U[i][j]; v = V[i][j]; //        x += delt * u; y += delt * v;</span></span></code> </pre><br><br>  At each step, the cells with particles are labeled as water. The rest are empty cells, in which the calculation of the main variables (u, v, p) is not performed. <br><br>  To calculate the main variables, it is necessary to set the boundary conditions on the surface and adjacent cells, as well as it was required for the walls.  But first you need to determine which cells, from those labeled as water, belong to the surface, and also from which side the air is located.  For this purpose, 2 arrays are used - FLAG and FLAGSURF.  In the first, only cell types are specified - water, air (empty) and obstacles.  Here are the corresponding flags (abbreviations B - boundary F - fluid E - empty): <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> C_B = <span class="hljs-number"><span class="hljs-number">0x0000</span></span>; <span class="hljs-comment"><span class="hljs-comment">// public const int C_F = 0x0010;// public const int C_E = 0x1000;//</span></span></code> </pre><br><br>  The FLAGSURF array is used to determine surface cells, for other cells the value there is = 0.  Flags in this array determine not only the cell type, but also all combinations of neighboring cells in which it is empty.  Flags are made as standard bit masks so that they can be combined. <br>  Each value in FLAGSURF contains 4 bits that correspond to 4 sides (adjacent cells). <br>  If the bit is set to 1, then in the corresponding adjacent cell it is empty.  If 0, then there is water. <br>  Bit location: 0000 NSWO 0000 0000 - the letters denote the 4 sides N (North north) S (South south) W (West east) and O (west). <br><br>  The entire list of flags is in the source, so I‚Äôll give just some examples of the values: <br><br>  public const int C_W = 0x0200; // 512 <br>  in binary form, the value looks like this 0000 0010 0000 0000 <br>  Here the flag corresponding to the side W is set to 1. This means that to the left of the current cell is empty. <br>  At the same time, the remaining 3 bits are set to 0 - it means the remaining neighboring cells are filled with water. <br><br><img src="http://habrastorage.org/storage3/b25/77e/078/b2577e07876044c13bc0e653ee7172d0.png"><br><br>  public const int C_SW = 0x0600; // 1536 0000 0110 0000 0000 <br>  Here the flag corresponding to the sides of W and S is set to 1. This means that to the left and below of the current cell is empty, and the remaining cells are aquatic. <br><br><img src="http://habrastorage.org/storage3/9c7/0b9/be2/9c70b9be202d9b2edcb43380494e312a.png"><br><br>  When determining the types of surface cells and filling in the FLAGSURF array, the corresponding bits are set to 1 thus: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,      1 if (FLAG[i-1][j] == GG.C_E) FLAGSURF[i][j] = FLAGSURF[i][j] | GG.C_W;</span></span></code> </pre><br><br>  The FLAGSURF array is mainly needed only for the convenience of setting the boundary conditions on the surface.  Since for different types of surface cells apply different boundary conditions.  As already mentioned, we need to put the boundary conditions in the empty cells that are near the surface cells and also the boundary conditions are needed in the surface cells themselves, since we have a staggered grid and not all surface cells are included in the calculation of the uv variables. <br><br>  The principle of setting values ‚Äã‚Äãis simple.  Since  the air pressure is 1000 times less than the pressure in water - then they can be neglected and allow water to move freely along the surface, without limiting its speed in any way or changing the direction of movement.  Of course, my scheme does not take into account surface tension, otherwise everything would be much more complicated. <br><br>  We affix the values ‚Äã‚Äãof the velocities U and V in the superficial cells and the empty cells bordering on them, while not forgetting that we have a staggered grid. <br>  Values ‚Äã‚Äãfor prostanovki taken from neighboring water cells. It only remained to decide from which neighboring cells all this is taken, because there can be several such cells. <br><br><img src="http://habrastorage.org/storage3/a0a/169/832/a0a169832f715b85127f7ab50e504f0a.png"><br><br>  Here is a screen with the boundary conditions that need to be put down. The blue squares are water.  Black marks - required boundary conditions.  Note that the tags are located partly in the surface cells and partly in the empty cells.  This happens because we have such conditions in the solver code (as you can see, UV is not calculated in the cells in front of the right boundary wall): <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsFluid(i, j) &amp;&amp; IsFluid(i+<span class="hljs-number"><span class="hljs-number">1</span></span>, j)){ F[i][j] = ... }</code> </pre><br><br>  Consider a few examples: <br><br>  <b>cage with flag C_SW</b> <br><img src="http://habrastorage.org/storage3/511/79f/750/51179f7501e8af6e57a1d4f0dbeefcdc.png"><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GG.C_SW: { U[i][j - <span class="hljs-number"><span class="hljs-number">1</span></span>] = U[i][j]; V[i][j - <span class="hljs-number"><span class="hljs-number">1</span></span>] = V[i][j]; U[i - <span class="hljs-number"><span class="hljs-number">1</span></span>][j] = U[i][j]; V[i - <span class="hljs-number"><span class="hljs-number">1</span></span>][j] = V[i][j]; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br><br>  Here, the values ‚Äã‚Äãin the cell itself are not needed - they will be calculated in the solver.  But we need values ‚Äã‚Äãin the neighboring empty cells - because  there are terms with U [i] [j - 1] in the solver, etc. <br><br>  The nearest water cell to these empty cells is the cell [i] [j] from it and take the values ‚Äã‚ÄãU and V. <br>  The figure shows that the value for V [i - 1] [j] could be taken both from the cell [i] [j] and from [i - 1] [j + 1] - but in the general case, the cell [ i - 1] [j + 1] may not be water; besides, the value of V in it may also be boundary and not yet put down. Therefore, the correct version is [i] [j] because the values ‚Äã‚Äãin it will be calculated in the solver . <br><br>  <b>cage with flag C_W</b> <br><img src="http://habrastorage.org/storage3/797/739/ccc/797739ccc59f87f0847aafc272b92e5b.png"><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GG.C_W: { U[i - <span class="hljs-number"><span class="hljs-number">1</span></span>][j] = U[i][j]; V[i - <span class="hljs-number"><span class="hljs-number">1</span></span>][j] = V[i][j]; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br><br>  Here everything is similar. <br><br>  <b>cage with flag C_NW</b> <br><img src="http://habrastorage.org/storage3/135/d49/c4f/135d49c4f8ab710f6d474369d2bd2ab6.png"><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GG.C_NW: { V[i][j] = V[i][j - <span class="hljs-number"><span class="hljs-number">1</span></span>]; U[i - <span class="hljs-number"><span class="hljs-number">1</span></span>][j] = U[i][j]; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br><br>  Here, the value of U in the cell itself will be calculated in the solver, since  to her right there is a water cell.  But V must be stamped, since the cell on top is empty. It is also necessary to set the value U [i - 1] [j], and TK when calculating U [i] [j], the values ‚Äã‚Äãwill also be required in the cells next to it, including U [i - 1] [j]. <br><br>  Just as in the previous case, the value of V [i] [j] is taken from the cell V [i] [j - 1], and not from V [i-1] [j] - the value in V [i-1 ] [j] may be boundary and not yet known. <br><br>  Set the pressure in empty cells and surface cells = 0. This is not entirely correct, but it works. <br>  In surface cells, pressure is needed, because when solving the equation for pressure, these cells are boundary and in them pressure is not calculated directly. <br><br><h4>  Algorithm of fluid motion using particles only on the surface </h4><br>  The source contains variants named track in the title.  This is a method of moving a free surface in which particles move only on the surface itself, and not in the entire volume of the liquid.  This is somewhat similar to the VOF method - but a preliminary surface reconstruction is being done there, which is quite cumbersome.  In my method, if a particle leaves the cell, it is marked empty, and in the nearby cells of the fluid in which there are no particles, particles are added to know where the surface is.  If the particle goes into an empty cell, then the cell is labeled as liquid.  Of course, this method has a decent amount of inaccuracy, but it is fast and does not require complicated coding. <br><br><h4>  Implicit calculation scheme </h4><br>  There is also an implicit version of the solver in the source code - it applies to equations for speeds, the differences in the code from the explicit version are minimal.  With discretization, all the terms with U and V [i] [j] simply go to the left side of the equation and not to the right, as in an explicit.Implicit (implicit) scheme allows for much larger time steps, which is impossible in the case of explicit. <br>  About implicit you can read here <a href="http://math.mit.edu/cse/codes/mit18086_navierstokes.pdf">http://math.mit.edu/cse/codes/mit18086_navierstokes.pdf</a> . <br><br><h4>  3D version </h4><br>  In the 3D version, everything is done by analogy with 2D. <br>  Key management F1-F8 + WASD, arrows and ER PgUp PgDown to rotate the camera. <br>  For scenes with a water source - the P key - to enable water pressure off. <br>  G - better surface rendering (spheres are used instead of cubes), but it terribly slows down. <br>  In the Demos folder - there are scenes and parameters (dimensions, time step, gravity and number of particles per cell) as an xml file.  It is also possible to paint your HeightMap (height map) in paint, any sizes can be - there is autoresize. <br><br>  In conclusion, I will give screenshots from 2D and 3D: <br><br><img src="http://habrastorage.org/storage3/8bf/222/c48/8bf222c48db3b19efda9a0a267b70c1d.png"><br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/AARvudxM9Go%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700191,15700253&amp;usg=ALkJrhgLqA4u77Zg6fIb7tkzB13QPLDhtA" frameborder="0" allowfullscreen=""></iframe><br><br><div class="spoiler">  <b class="spoiler_title">The remaining screenshots here</b> <div class="spoiler_text"><img src="http://habrastorage.org/storage3/7fd/65c/979/7fd65c9795961d1b74ad599080d7ac22.png"><br><img src="http://habrastorage.org/storage3/bba/e27/0af/bbae270af237a97bd1478746dfad0c01.png"><br><br><img src="http://habrastorage.org/storage3/9a3/f0a/66e/9a3f0a66ec9053e05df7308e1f9e6df3.png"><br><img src="http://habrastorage.org/storage3/3fb/352/131/3fb3521310d547b24f1fb5afd71e21e7.png"><br><img src="http://habrastorage.org/storage3/f36/c73/2fe/f36c732fe5176243ceb7e3742e0b2eaa.png"><br><br><img src="http://habrastorage.org/storage3/8da/fc4/8d4/8dafc48d47dc09f4e069db0bc0637aff.png"><br><img src="http://habrastorage.org/storage3/f12/256/c41/f12256c41f30209a17236b9ed581d376.png"><br><img src="http://habrastorage.org/storage3/d78/201/337/d782013377bbe0ac8e8d25957c4a545d.png"><br></div></div><br><br>  Source codes are here <a href="https://sourceforge.net/projects/cfdfreesurface3d/files/%3Fsource%3Dnavbar">sourceforge</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Projects that are in the source</b> <div class="spoiler_text">  Everything is written in Visual Studio 2010 <br>  <b>- Adaptive Mesh Refinement</b> - cells are broken into smaller parts and in these daughter cells are also considered <br>  all variables, while the large cells are adjacent to the children during the discrimination <br>  fluid2subcell * <br>  <b>- implicit version</b> <br>  fluide2dimplicit \ and fluide2dimplicitfree \ <br>  <b>- the program is divided into modules</b> that are easy to replace with other versions without removing the old ones <br>  fluide2dmodule \ <br>  <b>- the movement of water is realized through the movement of particles only on the surface</b> <br>  fluide2dtrack * <br>  <b>- working version with an explicit method</b> and boundary conditions on the surface, which are described in this post <br>  simpletestobstacle \ <br>  <b>- instead of dimensionless Re - real coefficients of water density and viscosity are used</b> , <br>  what allows at the solution of the equations at once to receive the real speeds and real pressure in arrays of UVP <br>  simpletestobstaclereal \ <br>  <b>- all that is in the finite volume folder refers to this method</b> <br>  made by book: <br>  Finality volume method Versteeg HK Malalasek <br><br>  - now 3D <br>  <b>- the simplest option - without surface and obstacles</b> <br>  SimpleFluid3D \ <br>  <b>- the latest version with everything everything on c ++</b> <br>  fluid3dunion \ <br>  <b>- option for GPU (only water)</b> , written in OpenCL, on my GeForce 550 acceleration 7 times (without any optimizations specifically for gpu) <br>  fluid3clsimple \ <br>  <b>- a very early version of what is in fluid3dunion</b> - a working version, but there are many flaws, on c #, explicit <br>  fluide3tao <br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Related Links</b> <div class="spoiler_text">  Good article is here <a href="https://code.google.com/p/kmkns/downloads/list">Kalland_Master.pdf</a> <br>  and here <a href="http://habrahabr.ru/post/171327/">Briefly about hydrodynamics: equations of motion</a> <br><br>  Books: <br>  - Griebel M Dornseifer T Numerical simulation in fluid dynamics SIAM 1998 <br>  // I‚Äôll especially note this book, in fact everything started with it, the source code for it can be easily found, I still haven‚Äôt found a better description of the cfd implementation) <br><br>  - Bridson R. Fluid Simulation for Computer Graphics <br>  - Anderson JDJr Computational Fluid Dynamics <br>  - Charles Hirsch-Numerical Computation of Internal and External Flows 2007 <br>  - Gretar Tryggvason Direct Numerical Simulation of Gas-Liquid Multiphase Flows <br>  - Versteeg HK Malalasek <br><br>  All books can be found yourself know where. <br></div></div><br><br>  <i>PS If there are people familiar with CFD, it would be interesting to improve the project together in terms of speed and correctness of the solution (especially when modeling the surface).</i> <i><br></i>  <i>Rendering myself I can gash more or less, but math and physics is not my main direction.</i>  <i>I will welcome any comments and helpful advice.</i> </div><p>Source: <a href="https://habr.com/ru/post/197074/">https://habr.com/ru/post/197074/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../197058/index.html">Metric # 25 - A podcast about technologies, products, and services from the IT world</a></li>
<li><a href="../197060/index.html">The process of testing mobile applications</a></li>
<li><a href="../197062/index.html">Details about the Nexus 5</a></li>
<li><a href="../197066/index.html">(M) VC Framework Locomotive</a></li>
<li><a href="../197068/index.html">Audiofocus - control access to the audio subsystem</a></li>
<li><a href="../197076/index.html">Frankenpad: history of the phenomenon</a></li>
<li><a href="../197078/index.html">Cable connectivity management system AMPTRAC from TE connectivity</a></li>
<li><a href="../197080/index.html">We connect Asterisk to Avaya under the H.323 protocol</a></li>
<li><a href="../197084/index.html">Synology RS2414 + / RS2414RP + Productive and Scalable NAS Server</a></li>
<li><a href="../197086/index.html">Habrahabr entered the registry of banned sites</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>