<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimizing the rendering of scenes from the Disney cartoon "Moana". Parts 4 and 5</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I have a pbrt branch, which I use to test new ideas, implement interesting ideas from scientific articles and in general to research everything that u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimizing the rendering of scenes from the Disney cartoon "Moana". Parts 4 and 5</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fe/8a1/30a/6fe8a130ad8c4f43d16d964991b3852f.jpg" alt="image"></div><br>  I have a pbrt branch, which I use to test new ideas, implement interesting ideas from scientific articles and in general to research everything that usually results in the new edition of the book <em>Physically Based Rendering</em> .  Unlike <a href="https://github.com/mmp/pbrt-v3">pbrt-v3</a> , which we strive to keep as close as possible to the system described in the book, in this thread we can change anything.  Today we will see how more radical changes to the system will significantly reduce the use of memory in the scene with an island from the Disney cartoon <em>"Moana"</em> . <br><br>  A note on the methodology: in the previous three posts, all statistics were measured for the WIP version (Work In Progress) of the scene with which I worked before its release.  In this article we will move on to the final version, which is a bit more complicated. <br><br>  When rendering the latest island scene from <em>Moana, the</em> pbrt-v3 used 81 GB of RAM to store the pbrt-v3 scene description.  Currently, pbrt-next uses 41 GB - approximately two times less.  To obtain such a result, it was enough to make small changes that resulted in several hundred lines of code. <br><a name="habracut"></a><br><h2>  Reduced primitives </h2><br>  Let us recall that in pbrt <code>Primitive</code> is a combination of geometry, its material, the function of radiation (if it is a source of illumination), and the record of the environment inside and outside the surface.  The pbrt-v3 <code>GeometricPrimitive</code> stores the following: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Shape&gt; shape; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Material&gt; material; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;AreaLight&gt; areaLight; MediumInterface mediumInterface;</code> </pre> <br>  As <a href="https://habr.com/post/417445/">mentioned earlier</a> , most of the time <code>areaLight</code> is <code>nullptr</code> , and the <code>MediumInterface</code> contains a pair of <code>nullptr</code> .  Therefore, in pbrt-next, I added a <code>Primitive</code> variant called <code>SimplePrimitive</code> , which stores only pointers to geometry and material.  Where possible, it is used where possible instead of <code>GeometricPrimitive</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimplePrimitive</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Primitive { <span class="hljs-comment"><span class="hljs-comment">// ... std::shared_ptr&lt;Shape&gt; shape; std::shared_ptr&lt;Material&gt; material; };</span></span></code> </pre> <br>  For non-animated object instances, we now have a <code>TransformedPrimitive</code> , which stores only a pointer to a primitive and a transformation, which saves us about 500 bytes of <a href="https://habr.com/post/417445/">wasted space</a> that the <code>AnimatedTransform</code> instance added to the <code>TransformedPrimitive</code> renderer pbrt-v3. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TransformedPrimitive</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Primitive { <span class="hljs-comment"><span class="hljs-comment">// ... std::shared_ptr&lt;Primitive&gt; primitive; std::shared_ptr&lt;Transform&gt; PrimitiveToWorld; };</span></span></code> </pre> <br>  (in case you need an animated conversion to pbrt-next there is an <code>AnimatedPrimitive</code> .) <br><br>  After all these changes, the statistics report that only 7.8 GB is used for <code>Primitive</code> , instead of 28.9 GB used in pbrt-v3.  Although it's great that we saved 21 GB, this is not as much as the reduction we could expect from previous estimates;  we will return to this discrepancy by the end of this part. <br><br><h2>  Reduced geometry </h2><br>  Also in pbrt-next, the amount of memory occupied by the geometry was significantly reduced: the space used for triangle meshes decreased from 19.4 GB to 9.9 GB, and the space for storing curves from 1.4 to 1.1 GB.  Slightly more than half of this savings came from the simplification of the base class <code>Shape</code> . <br><br>  In pbrt-v3, <code>Shape</code> carries with it several members that are transferred to all implementations of <code>Shape</code> ‚Äî these are several aspects that are convenient to access in implementations of <code>Shape</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// .... const Transform *ObjectToWorld, *WorldToObject; const bool reverseOrientation; const bool transformSwapsHandedness; };</span></span></code> </pre> <br>  To understand why these member variables cause problems, it is helpful to understand how meshes of triangles are represented in pbrt.  First, there is the <code>TriangleMesh</code> class, in which the vertices and index buffers for the entire mesh are stored: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TriangleMesh</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nTriangles, nVertices; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vertexIndices; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Point3f[]&gt; p; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Normal3f[]&gt; n; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br>  Each triangle in the mesh is represented by the <code>Triangle</code> class, which is inherited from <code>Shape</code> .  The idea is to keep the <code>Triangle</code> as small as possible: they only store a pointer to the mesh of which they are part, and a pointer to an offset in the index buffer, from which the indices of its vertices begin: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Triangle</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Shape { <span class="hljs-comment"><span class="hljs-comment">// ... std::shared_ptr&lt;TriangleMesh&gt; mesh; const int *v; };</span></span></code> </pre> <br>  When the <code>Triangle</code> implementation needs to find the positions of its vertices, it performs the appropriate indexing to get them from <code>TriangleMesh</code> . <br><br>  The problem with <code>Shape</code> pbrt-v3 is that the values ‚Äã‚Äãstored in it are the same for all the triangles of the mesh, so it‚Äôs best to save them from each whole mesh in <code>TriangleMesh</code> and then give <code>Triangle</code> access to a single copy of the common values. <br><br>  This problem is fixed in pbrt-next: the base class <code>Shape</code> in pbrt-next does not contain such members, and therefore each <code>Triangle</code> is 24 bytes less.  Geometry <code>Curve</code> uses a similar strategy and also benefits from using a more compact <code>Shape</code> . <br><br><h2>  Triangle common buffers </h2><br>  Despite the fact that the <em>Moana</em> island scene actively uses the creation of object instances for clearly repetitive geometry, I was wondering how often reuse of index buffers, texture coordinate buffers and so on is used for various triangle meshes. <br><br>  I wrote a small class that hashed these buffers on receipt and saved them to the cache, and modified <code>TriangleMesh</code> so that it checks the cache and uses the already saved version of any excess buffer it needs.  The win turned out to be very good: I managed to get rid of 4.7 GB of excess capacity, which is much more than what I expected. <br><br><h2>  Catastrophe with std :: shared_ptr </h2><br>  After all these changes, the statistics reports approximately 36 GB of known allocated memory, and at the beginning of rendering, <code>top</code> indicates the use of 53 GB.  Cause <br><br>  I was afraid of another series of slow runs of <code>massif</code> to find out which allocated memory is missing in the statistics, but then a letter from <a href="https://zeuxcg.org/">Arseny Kapulkin</a> appeared in my inbox.  Arseny explained to me that <a href="https://habr.com/post/417445/">my previous estimates</a> of the <code>GeometricPrimitive</code> memory usage were badly flawed.  I had to understand for a long time, but then I understood;  Many thanks to Arseny for pointing out the error and detailed explanations. <br><br>  Before writing Arseny, I mentally imagined the implementation of <code>std::shared_ptr</code> as follows: in these lines there is a common descriptor that stores the reference counter and a pointer to the object itself: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_ptr_info</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; refCount; T *ptr; };</code> </pre> <br>  Then I assumed that the <code>shared_ptr</code> instance simply points to it and uses it: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... T *operator-&gt;() { return info-&gt;ptr; } shared_ptr_info&lt;T&gt; *info; };</span></span></code> </pre> <br>  In short, I assumed that <code>sizeof(shared_ptr&lt;&gt;)</code> is the same as pointer size, and that for every shared pointer, 16 bytes of extra space are wasted. <br><br>  But it is not. <br><br>  In the implementation of my system, the total descriptor is 32 bytes, and <code>sizeof(shared_ptr&lt;&gt;)</code> is 16 bytes.  Consequently, <code>GeometricPrimitive</code> , which mainly consists of <code>std::shared_ptr</code> , is approximately twice as large as my ratings.  If you are wondering why this happened, then in these two posts on Stack Overflow the reasons are explained in detail: <a href="https://stackoverflow.com/a/9201435">1</a> and <a href="https://stackoverflow.com/a/34046853">2</a> . <br><br>  In almost all cases of using <code>std::shared_ptr</code> in pbrt-next, they are not required to be general pointers.  Being engaged in crazy hacking, I replaced everything that I could with <code>std::unique_ptr</code> , which actually has the same size as a regular pointer.  For example, here is how <code>SimplePrimitive</code> now looks <code>SimplePrimitive</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimplePrimitive</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Primitive { <span class="hljs-comment"><span class="hljs-comment">// ... std::unique_ptr&lt;Shape&gt; shape; const Material *material; };</span></span></code> </pre> <br>  The reward turned out to be more than I expected: memory usage at the beginning of rendering dropped from 53 GB to 41 GB - saving 12 GB, quite unexpected a few days ago, and the total volume is almost two times less than the pbrt-v3 used.  Fine! <br><br>  In the next part, we will finally complete this series of articles - examine the rendering speed in pbrt-next and discuss ideas for other ways to reduce the amount of memory needed for this scene. <br><br><h2>  Part 5. </h2><br>  To summarize this series of articles, we will start by examining the rendering speed of the island scene from the Disney cartoon <em>‚ÄúMoana‚Äù</em> in pbrt-next - the pbrt branch, which I use to test new ideas.  We will make more radical changes than is possible in pbrt-v3, which should adhere to the system described in our book.  We conclude with a discussion of the directions for further improvements, from the simplest to the bit extreme. <br><br><h2>  Rendering time </h2><br>  In pbrt-next, many changes have been made to the light transfer algorithms, including changes in BSDF sampling and improvements to Russian roulette algorithms.  As a result, it renders more rays than pbrt-v3 to render this scene, so it‚Äôs impossible to directly compare the execution time of these two renderers.  The speed is generally close, with one important exception: when rendering the island scene from <em>Moana</em> , shown below, pbrt-v3 spends 14.5% of its execution time on performing texture searches for <a href="https://ptex.us/">ptex</a> .  Previously, it seemed to me quite normal, but pbrt-next spends only 2.2% of the execution time.  All this is terribly interesting. <br><br>  After studying the statistics, we get <sup>1</sup> : <br><br> <code>pbrt-v3: <br>   Ptex 20828624 <br>  Ptex 712324767 <br> <br> pbrt-next: <br>   Ptex 3378524 <br>  Ptex 825826507</code> <br> <br>  As we see in pbrt-v3, the ptex texture is read from the disk on average every 34 texture searches.  In pbrt-next, it is read only every 244 searches ‚Äî that is, disk I / O has decreased by about 7 times.  I assumed that this happens because pbrt-next calculates ray differences for indirect rays, and this results in accessing higher MIP levels of textures, which in turn creates a more complete series of access to the ptex texture cache, reduces the number of cache misses, and hence the number of I / O operations <sup>2</sup> .  A brief check confirmed my guess: when disabling the difference in rays, the ptex speed became much worse. <br><br>  The increase in ptex speed has not only affected the savings in computing and I / O.  In the system with 32 CPUs, the pbrt-v3 had an acceleration of just 14.9 times after the parsing of the scene description was completed.  pbrt usually demonstrates close to linear parallel scaling, which is why it pretty much disappointed me.  Due to a much smaller number of conflicts with locks in ptex, the pbrt-next version was 29.2 times faster in the system with 32 CPUs, and 94.9 times faster in the system with 96 CPUs - we returned to our indicators again. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fe/8a1/30a/6fe8a130ad8c4f43d16d964991b3852f.jpg"></div><br>  <i>The roots of the island scene "Moana", rendered pbrt with a resolution of 2048x858 with 256 samples per pixel.</i>  <i>The total rendering time on a Google Compute Engine instance with 96 virtual CPUs with a frequency of 2 GHz in pbrt-next is 41 minutes 22 seconds.</i>  <i>Acceleration due to mulithreading during rendering was 94.9 times.</i>  <i>(I do not quite understand what is happening with the bump mapping here.)</i> <br><br><h2>  Work for the future </h2><br>  Reducing the amount of memory used in such complex scenes is a fascinating exercise: saving a few gigabytes with a small change is much more pleasing than dozens of megabytes saved in a simpler scene.  I have a good list of what I hope to explore in the future, if time allows.  Here is a quick overview. <br><br><h3>  Further decrease in triangle buffer memory </h3><br>  Even with repeated use of buffers that store the same values ‚Äã‚Äãfor several triangle meshes for triangle buffers, quite a lot of memory is still used.  Here is a breakdown of memory usage for different types of triangle buffers in a scene: <br><br><table><thead><tr><th>  Type of </th><th>  Memory </th></tr></thead><tbody><tr><td>  Positions </td><td>  2.5 GB </td></tr><tr><td>  Normals </td><td>  2.5 GB </td></tr><tr><td>  UV </td><td>  98 MB </td></tr><tr><td>  Indices </td><td>  252 MB </td></tr></tbody></table><br>  I understand that nothing can be done with the transmitted vertex positions, but for other data there are opportunities for saving.  There are many <a href="http://jcgt.org/published/0003/02/01/">types of representation of normal vectors in a memory-efficient way</a> , providing different trade-offs between the amount of memory / number of calculations.  Using one of the 24-bit or 32-bit representations will reduce the space occupied by the normals to 663 MB and 864 MB, which will save us more than 1.5 GB of RAM. <br><br>  In this scene, the amount of memory used for storing texture coordinates and index buffers is surprisingly small.  I suppose that this happened because of the presence of a set of procedurally generated plants in the scene and due to the fact that all variations of the same type of plants have the same topology (and hence the index buffer) with parametrization (and therefore UV coordinates).  In turn, reuse of matching buffers is quite effective. <br><br>  For other scenes, it may be quite appropriate to sample the 16-bit UV coordinates of the textures or to use half-precision float values, depending on their range of values.  It seems that in this scene all the coordinates of the textures are equal to zero or one, which means that they can be represented by one <em>bit</em> - that is, the memory can be reduced by 32 times.  This state of affairs probably arose from the use of the ptex format for texturing, which eliminates the need for UV atlases.  Taking into account the small volume occupied now by the coordinates of the textures, the implementation of this optimization is not particularly necessary. <br><br>  pbrt always uses 32-bit integers for index buffers.  For small meshes of less than 256 vertices, just 8 bits per index is enough, and for meshes less than 65,536 vertices, 16 bits can be used.  Modifying pbrt to adapt it to this format will not be very difficult.  If we wanted to optimize to the maximum, we could allocate exactly as many bits as necessary to represent the required range in the indices, while the price would be an increase in the complexity of finding their values.  With the fact that now only a quarter of a gigabyte of memory is used for vertex indices, this task, compared to others, does not look very interesting. <br><br><h3>  Peak memory usage build bvh </h3><br>  We have not discussed yet another detail of memory use: there is a short-term peak of 10 GB of additional memory immediately before rendering.  This happens when the (big) BVH of the entire scene is built.  The pbrt renderer's BVH build code is written to run in two phases: first, it creates a BVH with the <a href="">traditional presentation</a> : two child pointers to each node.  After building the tree, it is converted to <a href="">a memory efficient scheme</a> , in which the first child of the node is in memory immediately behind it, and the offset to the second child node is stored as an integer. <br><br>  This separation was necessary from the point of view of teaching students - it is much easier to understand the algorithms for constructing BVH without the chaos associated with the need to transform the tree into a compact form in the construction process.  However, the result is this peak memory usage;  given its influence on the scene, the elimination of this problem seems attractive. <br><br><h3>  Converting pointers to integers </h3><br>  There are many 64-bit pointers in various data structures that can be represented as 32-bit integers.  For example, each <code>SimplePrimitive</code> contains a pointer to <code>Material</code> .  Most <code>Material</code> instances are common to many primitive scenes and are never more than a few thousand;  therefore, we can store a single global <code>vector</code> all materials: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Material *&gt; allMaterials;</code> </pre> <br>  and just store 32-bit integer offsets to this vector in <code>SimplePrimitive</code> , which saves us 4 bytes.  The same trick can be used with a pointer to <code>TriangleMesh</code> in each <code>Triangle</code> , as well as in many other places. <br><br>  After such a change, there will be a slight redundancy in accessing the pointers themselves, and the system will become a little less understandable for students trying to understand its work;  In addition, this is probably the case when, in the context of pbrt, it is better to maintain a slightly greater clarity of implementation, although at the cost of incomplete memory optimization. <br><br><h3>  Accommodation based on arenas (regions) </h3><br>  For each separate <code>Triangle</code> and primitive, a separate call is made to <code>new</code> (in fact, <code>make_unique</code> , but this is the same).  Such memory allocations lead to the use of additional resource accounting, which occupies about five gigabytes of memory, which is not taken into account in statistics.  Since the lifespan of all such placements is the same - until the rendering is complete - we can get rid of this additional accounting by selecting them from <a href="">the memory arena (memory arena)</a> . <br><br><h3>  Khaki vtable </h3><br>  My last idea is terrible, and I apologize for it, but it intrigued me. <br><br>  Each triangle in the scene has an extra load of at least two vtable pointers: one for <code>Triangle</code> , and one for <code>SimplePrimitive</code> .  This is 16 bytes.  In the island scene <em>of Moana,</em> there are a total of <em>146,162,124</em> unique triangles, which adds almost 2.2 GB of redundant vtable pointers. <br><br>  What if we didn‚Äôt have an abstract base class for <code>Shape</code> and each geometry implementation didn‚Äôt inherit from anything?  This would save us a place on vtable pointers, but, of course, when we passed a pointer to a geometry, we would not know what kind of geometry it is, that is, it would be useless. <br><br>  It turns out that on modern x86 CPUs, in fact, <a href="https://en.wikipedia.org/wiki/X86-64">only 48 bits of 64-bit pointers are used</a> .  Therefore, there are extra 16 bits that we can borrow to store some information ... for example, the type of geometry we are pointing to.  In turn, by adding a bit of work, we can make a way back to the possibility of creating an analogue of calls to virtual functions. <br><br>  Here's how it will happen: first, we define a <code>ShapeMethods</code> structure that contains function pointers, for example, <sup>3</sup> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShapeMethods</span></span></span><span class="hljs-class"> {</span></span> Bounds3f (*WorldBound)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *); <span class="hljs-comment"><span class="hljs-comment">// Intersect, etc. ... };</span></span></code> </pre> <br>  Each geometry implementation will implement a constraint function, an intersection function, and so on, taking the analogue of <code>this</code> as the first argument: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Bounds3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangleWorldBound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       Triangle. Triangle *tri = (Triangle *)t; // ...</span></span></code> </pre> <br>  We would have a global table of structures <code>ShapeMethods</code> , in which the <em>n</em> -th element would be for a geometry type with index <em>n</em> : <br><br><pre> <code class="cpp hljs">ShapeMethods shapeMethods[] = { { TriangleWorldBound, <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> }, { CurveWorldBound, <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br>  When creating a geometry, we encode its type into some of the unused bits of the returned pointer.  Then, taking into account the pointer to the geometry, the specific call of which we want to perform, we would extract this type index from the pointer and use it as an index in <code>shapeMethods</code> to find the corresponding function pointer.  In fact, we would implement vtable manually, handling dispatch on our own.  If we did this both for geometry and for primitives, we would save 16 bytes on <code>Triangle</code> , however, having done a rather difficult path. <br><br>  I suppose that such a hack for implementing virtual functions management is not new, but I could not find links to it on the Internet.  Here is a Wikipedia page about <a href="https://en.wikipedia.org/wiki/Tagged_pointer">tagged pointers</a> , but it deals with things like reference counters.  If you know the link better, then send me her letter. <br><br>  By sharing this clunky hack, I can complete a series of posts.  Again I express my deep gratitude to Disney for publishing this scene.  It was amazing to work with her;  the gears in my head keep spinning. <br><br><h2>  Notes </h2><br><ol><li>  In the end, pbrt-next traces more rays in this scene than pbrt-v3, which probably explains the increase in the number of search operations. </li><li>  The ray differences for indirect rays in pbrt-next are calculated using the same <a href="">hack</a> used in <a href="http://pbrt.org/texcache.pdf">expanding the texture cache</a> for pbrt-v3.  It seems that it works quite well, but its principles do not seem to me very tested. </li><li>   <a href="">Rayshade   </a> .   ,   C    .  Rayshade          . </li></ol></div><p>Source: <a href="https://habr.com/ru/post/417939/">https://habr.com/ru/post/417939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417929/index.html">An excerpt from the book ‚ÄúOne Day in the Life of the Brain. Neurobiology of consciousness from dawn to dusk "</a></li>
<li><a href="../417931/index.html">Methods of retaining players: examples from games of various genres</a></li>
<li><a href="../417933/index.html">Security Week 27: Counterfeit iPhone and Security Price</a></li>
<li><a href="../417935/index.html">Memo on artificial intelligence, machine learning, deep learning and big data</a></li>
<li><a href="../417937/index.html">Do "iron" people make software?</a></li>
<li><a href="../417941/index.html">Where does the water in the kettle go?</a></li>
<li><a href="../417943/index.html">Serverless and React 2: sleight of hand and no fraud</a></li>
<li><a href="../417945/index.html">What tools does the Parker sun probe have?</a></li>
<li><a href="../417947/index.html">Data visualization for your web project</a></li>
<li><a href="../417949/index.html">As I wrote the standard C ++ 11 library or why the boost is so scary. Chapter 4.2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>