<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to tie a normal search to an outdated SQL backend</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Suppose you need to collect personal information, such as birthdays, name, gender, number of children, etc., as well as some marketing data ‚Äî how ofte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to tie a normal search to an outdated SQL backend</h1><div class="post__text post__text-html js-mediator-article">  Suppose you need to collect personal information, such as birthdays, name, gender, number of children, etc., as well as some marketing data ‚Äî how often users use buttons in the mobile app cart, etc.  We already have a SQL-based application, but (as we will see later) continuing to use SQL for searching is not the best idea.  For the search you will have to fasten some NoSQL engine. <br><br>  How to combine the worlds of SQL and NoSQL?  In this article there will be several living examples of integrating Elasticsearch's advanced search engine into legacy applications that work with RestX, Hibernate, and PostgreSQL / MySQL. <br><br>  David Pilato (David Pilato) - the expert of the Elastic company (these are the guys who did Elasticsearch, Kibana, Beats, and Logstash - that is, the Elastic Stack).  David has a wealth of experience in conducting reports on Elastic products (Devoxx conferences in England, Belgium and France, various JUG, Web5, Agile France, Mix-IT, Javazone, reports for specific companies, and so on).  In other words, David sets out very clearly and intelligibly, and his reports replace training for hundreds of oil. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The basis of this publication is David's <a href="http://2016.jokerconf.com/talks/advanced-search-for-your-legacy-application/">report</a> at the <a href="https://jokerconf.com/">Joker 2016</a> conference, which was held in St. Petersburg last October.  Nevertheless, the topics discussed over the past year have not lost their relevance. <br><br>  The article is available in two versions: a video recording of the report and a full text transcript (press the "read more" button).  In the text version, all the necessary data is presented in the form of screenshots, so that you do not lose anything. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/sidqRZyywP4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  My name is David Pilato, I have been working at Elastic for four years now. <br>  This report is based on personal experience gained while working in the French customs service, where I was involved in installing Elasticsearch and connecting SQL-based applications to it. <br><br>  Now we look at a similar example - the search for marketing data.  Suppose you need to collect personal information, such as birthdays, name, gender, number of children, etc., as well as some marketing data ‚Äî how often users use buttons in the mobile app cart, etc.  We already have a SQL-based application, but the search requires using a third-party engine. <br><br><h2>  application </h2><br>  The application is as follows: <br><img src="https://habrastorage.org/getpro/habr/post_images/5f9/78e/fd2/5f978efd213a2b56f7575222f3335bcd.png"><br>  This is a web application running, say, in a Tomcat container.  It stores data inside the MySQL database.  Over there is a REST interface. <br><br>  For example, build a certain application.  Of course, I didn‚Äôt use all the JSP tools, since the object of today's conversation is the backend, not the frontend. <br><br><h2>  Domain </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/8b4/057/302/8b40573029c556a45031c38e6babceb8.png"><br><br>  Here are 4 types of beans (beans): <br><br><ul><li>  Person - this bean contains information such as name, date of birth, gender, etc. <br></li><li>  Address, <br></li><li>  GeoPoint - geographic coordinates, <br></li><li>  Marketing - I mentioned earlier marketing information that is stored here. <br></li></ul><br>  If we look at MySQL, where we have a database, we will see a similar picture, that is, the tables: <br><br><ul><li>  person, <br></li><li>  united address <br></li><li>  marketing. <br></li></ul><br><h2>  Let's go over to examples. </h2><br>  If you want to repeat all these examples, you can find the necessary materials on <a href="https://github.com/dadoonet/legacy-search/tree/01-direct">GitHub</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/511/2b3/0845112b33637936ed2f9ae2226fca27.png"></div><br>  You can repeat everything we do today: <br><br><pre><code class="java hljs">$ git clone &lt;a href=<span class="hljs-string"><span class="hljs-string">"https://github.com/dadoonet/legacy-search.git"</span></span>&gt;https:<span class="hljs-comment"><span class="hljs-comment">//github.com/dadoonet/legacy-search.git&lt;/a&gt; $ git checkout 00-legacy $ mvn clean install jetty:run</span></span></code> </pre> <br>  I use IDEA in my examples. <br><br><h2>  What we have at the start </h2><br>  The application has a small search part: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc2/929/06e/bc292906ee4cb60bdd3f16106b65de11.png"><br><br>  First you need to insert some data.  To do this, we use a random generator.  It generates random personal data and adds it to an array. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b79/ede/7b6/b79ede7b678c0a03ccf1eda1290c50cd.png"><br><br>  While the data is generated, you can use the search: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f6/5b2/e51/2f65b2e5148225785099b520e4218a63.png"><br><br>  It's like a Google search: you can search by name, country, etc.  In addition, an advanced search is implemented - by several fields at the same time: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e3/84e/9e7/3e384e9e766be3eaad9bf25e4fad293f.png"><br>  Let's look at the code (SearchDaoImpl.java). <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/**    * Find persons by any column (like full text).    */</span></span>   <span class="hljs-meta"><span class="hljs-meta">@SuppressWarnings</span></span>(<span class="hljs-string"><span class="hljs-string">"unchecked"</span></span>)   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Collection&lt;Person&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findLikeGoogle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String query, Integer from, Integer size)</span></span></span><span class="hljs-function"> </span></span>{       Criteria criteria = generateQuery(hibernateService.getSession(), Person.class, query);       criteria.setFirstResult(from);       criteria.setMaxResults(size);       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> criteria.list();   }</code> </pre><br>  There is a fingLikeGoogle method.  From the interface comes a query query.  There is also a division of search results per page (from and size variables).  To connect to the database using hibernate. <br><br>  That is, we generate hibernateQuery.  Here is what it looks like: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Criteria </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateQuery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Session session, Class clazz, String query)</span></span></span><span class="hljs-function"> </span></span>{       String toLikeQuery = <span class="hljs-string"><span class="hljs-string">"%"</span></span> + query + <span class="hljs-string"><span class="hljs-string">"%"</span></span>;       Criteria c = session.createCriteria(clazz);       c.createAlias(<span class="hljs-string"><span class="hljs-string">"address"</span></span>, <span class="hljs-string"><span class="hljs-string">"address"</span></span>);       c.add(Restrictions.disjunction()                       .add(Restrictions.ilike(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, toLikeQuery))                       .add(Restrictions.ilike(<span class="hljs-string"><span class="hljs-string">"address.country"</span></span>, toLikeQuery))                       .add(Restrictions.ilike(<span class="hljs-string"><span class="hljs-string">"address.city"</span></span>, toLikeQuery))       );       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c;   }</code> </pre> <br><br>  This uses the toLikeQuery query.  You must also combine the address field: c.createAlias ‚Äã‚Äã("address", "address").  Further, if there is an element in the database that matches the query by the name, address.country or address.city fields, we return it as a result. <br><br>  Let's look at the advanced search: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">advancedSearch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name, String country, String city, Integer from, Integer size)</span></span></span><span class="hljs-function"> </span></span>{       List&lt;Criterion&gt; criterions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) {           criterions.add(Restrictions.ilike(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"%"</span></span> + name + <span class="hljs-string"><span class="hljs-string">"%"</span></span>));       }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (country != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) {           criterions.add(Restrictions.ilike(<span class="hljs-string"><span class="hljs-string">"address.country"</span></span>, <span class="hljs-string"><span class="hljs-string">"%"</span></span> + country + <span class="hljs-string"><span class="hljs-string">"%"</span></span>));       }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (city != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) {           criterions.add(Restrictions.ilike(<span class="hljs-string"><span class="hljs-string">"address.city"</span></span>, <span class="hljs-string"><span class="hljs-string">"%"</span></span> + city + <span class="hljs-string"><span class="hljs-string">"%"</span></span>));       }       <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> start = System.currentTimeMillis();       hibernateService.beginTransaction();       <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> total = searchDao.countWithCriterias(criterions);       Collection&lt;Person&gt; personsFound = searchDao.findWithCriterias(criterions, from, size);       hibernateService.commitTransaction();       <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> took = System.currentTimeMillis() - start;       RestSearchResponse&lt;Person&gt; response = buildResponse(personsFound, total, took);       logger.debug(<span class="hljs-string"><span class="hljs-string">"advancedSearch({},{},{})={} persons"</span></span>, name, country, city, response.getHits().getTotalHits());       String json = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {           json = mapper.writeValueAsString(response);       } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (JsonProcessingException e) {           logger.error(<span class="hljs-string"><span class="hljs-string">"can not serialize to json"</span></span>, e);       }       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json;   }</code> </pre> <br>  From the interface, we get the fields name, country, city.  If the combination entered in these interface elements is found in the corresponding fields of the database element, this element is returned as a result. <br><br><h2>  Formulation of the problem </h2><br>  Before changing anything, you need to answer the question what problem in this SQL search we want to fix.  Let me give you some examples. <br><br>  This is a simple table with two fields - name and comments.  Insert four of these documents into the database: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08a/649/649/08a64964968c0326d91694bebb82c92c.png"><br><br>  Perform a simple search.  Suppose the user has entered David into the search box in the application.  There are no matches in this database: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d15/4b2/ac4/d154b2ac487d2f7f3acf9ea4cac1906e.png"><br><br>  How to fix it?  You can use LIKE by enclosing a custom search string in% signs: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/84f/f5a/d72/84ff5ad72a8d328db27499c3e0a96c0b.png"><br><br>  As a result, we found some information.  This method works. <br><br>  Take another example.  Now look for David Pilato: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c2e/c71/05b/c2ec7105ba28ad787d4b7413407c2d83.png"><br><br>  Between individual words, you can put both the% sign and the space.  It will still work. <br><br>  But what if the user searches for Pilato David instead of David Pilato? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f2b/639/d74/f2b639d74c8bb20932ba11f96b2ac8e8.png"><br><br>  This does not work anymore, despite the fact that this combination is present in the database. <br><br>  How can I fix this?  We divide the user query entered in the interface and use several queries into the database. <br><br>  Another example is searching by two fields - both in the name field and in the comments field: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f4/f4a/6f0/0f4f4a6f064a1688957a14b123a0a3ad.png"><br><br>  As a result, I get all the information.  But what happens if it is a million or billion records?  What information is more relevant here?  Probably the fourth line.  Since the discovery of the required information in the name field, most likely, is more relevant than in the comments field.  That is, I want to get this information at the top of the list.  However, there is no relevance view in the SQL database.  It's like looking for a needle in a haystack. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/733/8c3/947/7338c39474ffaee64a09d3588d53548f.png"><br><br>  In addition, you must remember about spelling errors.  How to consider them in the search?  Using a question mark for each letter of the request and trying to replace it is inefficient. <br><br>  Imagine if your database is really in demand, and a lot of information is constantly being requested from it.  Can you search in parallel with the addition of new information?  Perhaps in a hundred thousand documents, perhaps in a million documents.  But what about a billion documents (petabytes of data)? <br><br>  Why not search using the search engine? <br><br>  This is what we will do today. <br><br><h2>  Solution Architecture </h2><br>  Suppose we chose Elasticsearch as the search engine, because, in my opinion, it is the best.  And we need to connect our application to it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/786/a4c/36d/786a4c36dcb6876112defabdfd71df5a.png"><br><br>  How can I do that? <br><br>  You can use ETL.  ETL provides getting data from the source (sending a request to the database), converting the data to a JSON document, and loading it into Elasticsearch.  You can use talend or other existing tools. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/095/827/ff3/095827ff35471cad7c56f36a0b137d07.png"><br><br>  However, there is one problem.  The ETL tool will run in batch mode.  This means that we will probably have to run the request every 5 minutes.  That is, the user enters a query, and the search result can be obtained only 5 seconds later.  This is not perfect. <br><br>  There are problems with the removal.  Suppose you need to remove something from the database.  By running the SELECT query again, I will have to delete something that is not returned as an answer.  This is a super difficult task.  You can use the technical table, perhaps the triggers, but all this is not easy. <br><br>  My favorite way to solve such problems is to make a direct connection between the application and Elasticsearch.  If you can do it, do it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fdb/73a/c87/fdb73ac87f6ac1bc8b52f5ea0a402d75.png"><br><br>  You can use the same transaction as when loading a bean into the database: just transform it into a JSON document and send it to Elasticsearch.  You do not have to read the database after five minutes - it is already in memory. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/274/50c/9ef/27450c9ef4cfc605678c8813aa186885.png"><br><br>  Before you do this, I want to note one thing.  When you move from a relational model to a document system, as in Elasticsearch (or another similar solution), you need to think carefully about the model itself, since they reflect different approaches.  Instead of adding a single document to a table and attempting to merge in memory <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9fa/d30/c54/9fad30c54762d29f8165d3f0ba0076ef.png"><br><br>  You can create one document with all the necessary information: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb3/504/a27/eb3504a27c708e609a8b970aad965adc.png"><br><br>  When you connect a search engine, you need to answer two questions for yourself: <br><br><ul><li>  what am i looking for?  Am I looking for a person (i .e. I am going to index a person) <br></li><li>  What parameters am I looking for this person?  What fields do I need?  For example, I am looking for people living in France.  Then I need to index the country inside the document. <br></li></ul><br>  Let us turn to examples. <br><br><h2>  Direct connection </h2><br>  All the steps in the examples are explained in the readme, so you can reproduce everything yourself. <br><br><pre> <code class="java hljs">$ git clone &lt;a href=<span class="hljs-string"><span class="hljs-string">"https://github.com/dadoonet/legacy-search.git"</span></span>&gt;https:<span class="hljs-comment"><span class="hljs-comment">//github.com/dadoonet/legacy-search.git&lt;/a&gt; $ git checkout 01-direct $ git checkout 02-bulk $ git checkout 03-mapping $ git checkout 04-aggs $ git checkout 05-compute $ mvn clean install jetty:run $ cat README.markdown</span></span></code> </pre> <br>  So, you need to add to the project Elasticsearch.  We use maven here, so the first thing to do is add elasticsearch as a dependency (here I use the latest version of elasticsearch). <br><br><pre> <code class="java hljs">&lt;!-- Elasticsearch --&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">5.0</span></span>.0-rc1&lt;/version&gt; &lt;/dependency&gt;</code> </pre> <br>  We now turn directly to the application.  Here is how saving personal data of a person in the database at the service level (in PersonService.java) looks like: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Person </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Person person)</span></span></span><span class="hljs-function"> </span></span>{       hibernateService.beginTransaction();       Person personDb = personDao.save(person);       hibernateService.commitTransaction();       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> personDb;   }</code> </pre><br>  We open a hibernate transaction, then call personDao.save, and then we complete the transaction. <br><br>  Here you can also index data using Elasticsearch.  We create a new class ‚Äî elasticsearchDao ‚Äî and we will save our personDB object (personID, since I would like to use the same ID for Elasticsearch that was generated by hibernate). <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Person </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Person person)</span></span></span><span class="hljs-function"> </span></span>{       hibernateService.beginTransaction();       Person personDb = personDao.save(person);       elasticsearchDao.save(personDb);       hibernateService.commitTransaction();       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> personDb;   }</code> </pre> <br>  You must add a class: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ElasticsearchDao elasticsearchDao;</code> </pre> <br>  And create this class (in ElasticsearchDao.java). <br><br>  Here I use the restiks framework, so I have some annotation that allows you to inject it automatically. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> restx.factory.Component;</code> </pre> <br>  Here I use the <a href="https://habrahabr.ru/users/component/" class="user_link">Component</a> annotation, so in my PersonService class (PersonService.java) I need to inject this component. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Inject</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PersonService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PersonDao personDao, SearchDao searchDao,                        HibernateService hibernateService,                      &lt;b&gt;  ElasticsearchDao elasticsearchDao,&lt;/b&gt;                        ObjectMapper mapper, DozerBeanMapper dozerBeanMapper)</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.personDao = personDao;       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.searchDao = searchDao;       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.hibernateService = hibernateService;       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mapper = mapper;       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dozerBeanMapper = dozerBeanMapper; &lt;b&gt;        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elasticsearchDao = elasticsearchDao;&lt;/b&gt;   }</code> </pre><br>  Now you need to implement the elasticsearchDao.save (personDb) method in ElasticsearchDao.java.  To do this, you first need to create Elasticsearch clients.  To do this, add: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ElasticsearchDao</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Client esClient; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Person person)</span></span></span><span class="hljs-function"> </span></span>{ } }</code> </pre><br>  It is necessary to implement the client.  You can use an existing class to transport existing artifacts. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ElasticsearchDao</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Client esClient; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ElasticsearchDao</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.esClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PreBuiltTransportClient(Settings.EMPTY); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Person person)</span></span></span><span class="hljs-function"> </span></span>{ } }</code> </pre><br>  Next, you need to declare on which machine and on which port Elasticsearch is located.  To do this, add addransportAddress and indicate that Elasticsearch is running locally in this case.  By default, Elasticsearch starts on port 9300. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ElasticsearchDao</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.esClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PreBuiltTransportClient(Settings.EMPTY); .addTransportAddress(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InetSocketTransportAddress( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InetSocketAddress(<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-number"><span class="hljs-number">9300</span></span>) ));   }</code> </pre><br>  You also need something that converts a bean to a JSON document.  For this we use the Jackson library.  It is already present in my Restix, you only need to inject it. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ElasticsearchDao</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Client esClient; &lt;b&gt;<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ObjectMapper mapper;&lt;/b&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ElasticsearchDao</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&lt;b&gt;ObjectMapper mapper&lt;/b&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.esClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PreBuiltTransportClient(Settings.EMPTY); .addTransportAddress(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InetSocketTransportAddress( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InetSocketAddress(<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-number"><span class="hljs-number">9300</span></span>) )); &lt;b&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mapper = mapper;&lt;/b&gt; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Person person)</span></span></span><span class="hljs-function"> </span></span>{ } }</code> </pre><br>  Now you can implement the save method. <br><br>  I need to convert my bean to a JSON document.  Here you need to choose whether you want the output to produce a JSON document String or Byte (writeValueAsString or writeValueAsBytes, respectively) - we will use Byte, but if necessary, you can use String. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Person person)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ &lt;b&gt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bytes = mapper.writeValueAsBytes(person);&lt;/b&gt;   }</code> </pre><br>  Now the JSON document is in the byte array.  You need to send it to Elasticsearch. <br><br>  Elasticsearch provides different levels of access, so with the same notation you can index different types of data.  Here we use the document ID obtained earlier from hibernate. <br><br>  .source allows us to get the JSON document itself. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Person person)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bytes = mapper.writeValueAsBytes(person); &lt;b&gt;esClient.index(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IndexRequest(<span class="hljs-string"><span class="hljs-string">"person"</span></span>, <span class="hljs-string"><span class="hljs-string">"person"</span></span>, person.idAsString()).source(bytes).actionGet());&lt;/b&gt;   }</code> </pre> <br>  Thus, using these two strings, I converted the bean to JSON and sent the latter to Elasticsearch. <br><br>  Let's try to compile it.  Get Exception: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5b9/6fc/a1a/5b96fca1afc51ae48f7fa587f3e6d360.png"><br><br>  Suppose something bad is happening in the process of interacting with Elasticsearch.  What can you do with this exception?  Something like rollback of transaction in hibernate. <br><br>  To do this, you can add to PersonService.java: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Person </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Person person)</span></span></span><span class="hljs-function"> </span></span>{ hibernateService.beginTransaction(); Person personDb = personDao.save(person); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { elasticsearchDao.save(personDb); } &lt;b&gt;<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { hibernateService.rollbackTransaction(); e.printStackTrace(); }&lt;/b&gt; hibernateService.commitTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> personDb;   }</code> </pre> <br>  But I do not want to do that, because I believe that the presence of data in the database is much more important than the work of the search engine.  Therefore, I do not want to lose user input.  Instead of rolling back the transaction, simply log the exception so that you can later find out the cause of the error and correct it: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Person </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Person person)</span></span></span><span class="hljs-function"> </span></span>{ hibernateService.beginTransaction(); Person personDb = personDao.save(person); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { elasticsearchDao.save(personDb); } &lt;b&gt;<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { logger.error(<span class="hljs-string"><span class="hljs-string">"Houston, we have a problem!"</span></span>, e); }&lt;/b&gt; hibernateService.commitTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> personDb;   }</code> </pre> <br>  Now let's look at the delete record operation.  It is identical.  Elasticsearch makes it easier to delete an entry using the same transaction. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer id)</span></span></span><span class="hljs-function"> </span></span>{       logger.debug(<span class="hljs-string"><span class="hljs-string">"Person: {}"</span></span>, id);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;       }       hibernateService.beginTransaction();       Person person = personDao.get(id);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (person == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) {           logger.debug(<span class="hljs-string"><span class="hljs-string">"Person with reference {} does not exist"</span></span>, id);           hibernateService.commitTransaction();           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;       }       personDao.delete(person);    &lt;b&gt;   elasticsearchDao.delete(person.idAsString());&lt;/b&gt;       hibernateService.commitTransaction();       logger.debug(<span class="hljs-string"><span class="hljs-string">"Person deleted: {}"</span></span>, id);       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;   }</code> </pre><br>  You can implement this method in ElasticsearchDao.java.  Call DeleteRequest using index name - person and type - also person: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String idAsString)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{       esClient.delete(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeleteRequest(<span class="hljs-string"><span class="hljs-string">"person"</span></span>, <span class="hljs-string"><span class="hljs-string">"person"</span></span>, idAsString)).get();   }</code> </pre><br>  Similarly, we put catch in PersonService.java: <br><br><pre> <code class="java hljs"> personDao.delete(person); &lt;b&gt;<span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {&lt;/b&gt; elasticsearchDao.delete(person.idAsString()); &lt;b&gt;} <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { e.printStackTrace(); }&lt;/b&gt; hibernateService.commitTransaction();</code> </pre><br>  Now let's restart the application.  It remains to run Elasticsearch (I have the usual installation of Elasticsearch): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ec/dd3/9be/6ecdd39bec2c79456141f58e8c7adc1c.png"><br><br>  Elasticsearch starts listening to 2 ports: <br><ul><li>  9300 for a Java client; <br></li><li>  9200 - REST API. <br></li></ul><br>  I will also launch another tool in parallel - kibana.  This open source tool we created in Elastic.  Use it to view data.  But today, kibana will be used to access the Console tab, which allows you to perform individual requests. <br><br>  Let's generate 10,000 documents again: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d51/449/214/d5144921475202b8423e4092ad08a398.png"><br><br>  Kibana shows that the index person has already been created. <br><img src="https://habrastorage.org/getpro/habr/post_images/50c/ded/9e4/50cded9e4ed9aeffa251ba1bb9363807.png"><br><br>  And if we run the simplest search for any document, we get the newly generated document: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c29/b28/8ae/c29b288ae50eeb3de5e0d2d9af09125a.png"><br><br>  This is the JSON document that was generated from the bean. <br><br>  Here you can search for individual fields. <br><br>  But back to the application.  Despite the changes, the interface is still getting a search on the database, because the search engine is not integrated yet.  Let's do it. <br><br>  PersonService.java has a search method.  Let's try to replace it.  Earlier I called findLikeGoogle there, now the decision will be different. <br><br>  First you need to build a query to Elasticsearch. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String q, String f_country, String f_date, Integer from, Integer size)</span></span></span><span class="hljs-function"> </span></span>{ &lt;b&gt;QueryBuilder query;&lt;/b&gt; }</code> </pre><br>  Suppose the user has not entered anything.  In this case, I want to make a special request - matchAll - issuing all that is. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String q, String f_country, String f_date, Integer from, Integer size)</span></span></span><span class="hljs-function"> </span></span>{ QueryBuilder query; &lt;b&gt;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Strings.hasText(q)) { query = QueryBuilders.matchAllQuery(); }&lt;/b&gt; }</code> </pre> <br>  Otherwise, I would like to use a different type of query - simpleQueryStringQuery.  I will search for the text entered by the user in certain fields. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String q, String f_country, String f_date, Integer from, Integer size)</span></span></span><span class="hljs-function"> </span></span>{ QueryBuilder query; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Strings.hasText(q)) { query = QueryBuilders.matchAllQuery(); }&lt;b&gt; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {           query = QueryBuilders.simpleQueryStringQuery(q)                       .field(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)                       .field(<span class="hljs-string"><span class="hljs-string">"gender"</span></span>)                       .field(<span class="hljs-string"><span class="hljs-string">"address.country"</span></span>)                       .field(<span class="hljs-string"><span class="hljs-string">"address.city"</span></span>); }&lt;/b&gt; }</code> </pre> <br>  Now use elasticsearchDao to send a search query: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String q, String f_country, String f_date, Integer from, Integer size)</span></span></span><span class="hljs-function"> </span></span>{ QueryBuilder query; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Strings.hasText(q)) { query = QueryBuilders.matchAllQuery(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {           query = QueryBuilders.simpleQueryStringQuery(q)                       .field(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)                       .field(<span class="hljs-string"><span class="hljs-string">"gender"</span></span>)                       .field(<span class="hljs-string"><span class="hljs-string">"address.country"</span></span>)                       .field(<span class="hljs-string"><span class="hljs-string">"address.city"</span></span>); } &lt;b&gt;elasticsearchDao.search(query, from, size);&lt;/b&gt; }</code> </pre><br>  Let's implement this method. <br><br>  Again you need to use esClient.  Here the prepareSearch () method is used;  at the same time, the search will be carried out in the person index (if necessary, I can simultaneously search in several entities), set the type and run the query created earlier.  Set the pagination options.  Here it is super-easy (pagination in databases is a real nightmare). <br><br>  Using the get () method, I run the query, and then return the result: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> SearchResponse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QueryBuilder query, Integer from, Integer size)</span></span></span><span class="hljs-function"> </span></span>{ SearchResponse response = esClient.prepareSearch(<span class="hljs-string"><span class="hljs-string">"person"</span></span>) .setTypes(<span class="hljs-string"><span class="hljs-string">"person"</span></span>) .setQuery(query)                       .setFrom(from)                       .setSize(size) .get(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response; }</code> </pre> <br>  Let's fix the code in PersonService.java to get an answer to the search query.  All that remains is to return the result as a string (initially the answer is a JSON document): <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String q, String f_country, String f_date, Integer from, Integer size)</span></span></span><span class="hljs-function"> </span></span>{ QueryBuilder query; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Strings.hasText(q)) { query = QueryBuilders.matchAllQuery(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {           query = QueryBuilders.simpleQueryStringQuery(q)                       .field(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)                       .field(<span class="hljs-string"><span class="hljs-string">"gender"</span></span>)                       .field(<span class="hljs-string"><span class="hljs-string">"address.country"</span></span>)                       .field(<span class="hljs-string"><span class="hljs-string">"address.city"</span></span>); } &lt;b&gt;SearchResponse response =&lt;/b&gt; elasticsearchDao.search(query, from, size); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.toString(); }</code> </pre> <br>  We turn to the modernization of the advanced search.  Here everything is similar to what we have done earlier. <br><br>  If the user has not entered any requests in the name, country and city fields, run the matchAll query to get the entire document.  Otherwise, we want to build a boolean request: if we have something in the name field, we need to look for it in the name field of our JSON document (similar to the country and city). <br><br>  After that, use the same elasticsearchDao and send the result to the user. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">advancedSearch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name, String country, String city, Integer from, Integer size)</span></span></span><span class="hljs-function"> </span></span>{       QueryBuilder query;       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Strings.hasText(name) &amp;&amp; !Strings.hasText(country) &amp;&amp; !Strings.hasText(city)) {           query = QueryBuilders.matchAllQuery();       } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {           BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();           <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Strings.hasText(name)) {               boolQueryBuilder.must(                       QueryBuilders.matchQuery(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, name)               );           }           <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Strings.hasText(country)) {               boolQueryBuilder.must(                       QueryBuilders.matchQuery(<span class="hljs-string"><span class="hljs-string">"address.country"</span></span>, country)               );           }           <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Strings.hasText(city)) {               boolQueryBuilder.must(                       QueryBuilders.matchQuery(<span class="hljs-string"><span class="hljs-string">"address.city"</span></span>, city)               );           }           query = boolQueryBuilder;       }       SearchResponse response = elasticsearchDao.search(query, from, size);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (logger.isDebugEnabled()) logger.debug(<span class="hljs-string"><span class="hljs-string">"advancedSearch({},{},{})={} persons"</span></span>, name, country, city, response.getHits().getTotalHits());       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.toString();   }</code> </pre> <br>  Check how it works.  Restart our application. <br>  Now, entering a certain request, I will send it to Elasticsearch. <br><br>  The experiment shows that only the search by complete match (not part of the string) works.  This we will fix later.  However, we can now search both by first name, last name, and last name by first name.  In addition, the relevance of the results appeared.  If we search for Joe Smith, then a full-match entry (Joe Smith) will be at the top of the list of results as the most relevant.  Further records will go with the same name or surname. <br><br><h2>  Batch mode </h2><br>  I want to introduce another concept.  Regardless of whether you use a Java client for Elasticsearch, it is better to use the Bulk API.  Instead of inserting documents into Elasticsearch one by one, Bulk API allows you to batch them.  In the Java client, the Bulk API is called bulkProcessor. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ElasticsearchDao</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ObjectMapper mapper)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.esClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PreBuiltTransportClient(Settings.EMPTY) .addTransportAddress(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InternetSocketTransportAddress( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InetSocketAddress(<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-number"><span class="hljs-number">9300</span></span>) )); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mapper = mapper; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bulkProcessor = BulkProcessor.builder(esClient, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BulkProcessor.Listener() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beforeBulk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> executionID, BulkRequest request)</span></span></span><span class="hljs-function"> </span></span>{ logger.debug(<span class="hljs-string"><span class="hljs-string">"going to execute bulk of {} requests"</span></span>, request.numberOfActions()); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">afterBulk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> executionID, BulkRequest request, BulkResponse response)</span></span></span><span class="hljs-function"> </span></span>{ logger.debug(<span class="hljs-string"><span class="hljs-string">"bulk executed {} failures"</span></span>, response.hasFailures() ? <span class="hljs-string"><span class="hljs-string">"with"</span></span> : <span class="hljs-string"><span class="hljs-string">"without"</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">afterBulk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> executionID, BulkRequest request, Throwable failure)</span></span></span><span class="hljs-function"> </span></span>{ logger.warn(<span class="hljs-string"><span class="hljs-string">"error while executing bulk"</span></span>, failure); } }) .setBulkActions(<span class="hljs-number"><span class="hljs-number">10000</span></span>) .setFlushInterval(TimeValue.timeValueSeconds(<span class="hljs-number"><span class="hljs-number">5</span></span>)) .build(); }</code> </pre><br>  You also need to add bulkProcessor and logger: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BulkProcessor bulkProcessor; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger logger = LoggerFactory.getLogger(ElasticsearchDao.class);</code> </pre> <br>  bulkProcessor works with esClient, which was created earlier.  It is filled with requests and every 10,000 operations starts a batch sending of requests to Elasticsearch.  Sending will also be performed every 5 seconds, even if you do not type 10,000 requests.  You can add your listener here and specify the actions to be performed before the batch sending of requests, after it, or if an exception was received during the execution of the requests. <br><br>  Let's make changes to the rest of the code. <br>  Now, instead of esClient.index will be bulkProcessor.  And do not have to run the request, since the launch provides bulkProcessor. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Person person)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bytes = mapper.writeValueAsBytes(person);    bulkProcessor.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IndexRequest(<span class="hljs-string"><span class="hljs-string">"person"</span></span>, <span class="hljs-string"><span class="hljs-string">"person"</span></span>, person.idAsString()).source(bytes));   }</code> </pre><br>  Same for deletion: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String id)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{       bulkProcessor.delete(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeleteRequest(<span class="hljs-string"><span class="hljs-string">"person"</span></span>, <span class="hljs-string"><span class="hljs-string">"person"</span></span>, idAsString));   }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Previously, we had a problem - the word search did not work. This is the usual behavior of Elasticsearch. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we look at what Elasticsearch generates by default (mapping is analogous to schema in traditional databases), for example, in the city field inside the person document, we see that this field is marked as text: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/455/021/f4b/455021f4b0b6e3ea8d921218c91db726.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And this means that only the entire match is taken into account lines. To fix this, you need to implement your own mapping for Elasticsearch (get it to use our own search strategy). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For this, I will use the open source Beyonder library. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add this artifact to the maven project:</font></font><br><br><pre> <code class="java hljs">&lt;!-- Elasticsearch-Beyonder --&gt; &lt;dependency&gt; &lt;groupId&gt;fr.pilato.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-beyonder&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">2.1</span></span>.0&lt;/version&gt; &lt;/dependency&gt;</code> </pre><br>     ,      elasticsearch  resources,    ,    index (   ‚Äî person), beyonder   ,    type.json (  type ‚Äî  person,   ‚Äî person.json).      mapping. <br><br>   mapping,  REST- Elasticsearch,  Beyonder    . <br><br>     ,  city    text (    ),          (address.city.autocomplete)  text,             ‚Äî   . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In addition, at the indexing stage, I copy what is in the address.city field in the fulltext field, for which the same indexing and search strategy will be applied. </font></font><br><br><pre> <code class="java hljs">                  <span class="hljs-string"><span class="hljs-string">"city"</span></span>: {                       <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"text"</span></span>,                       <span class="hljs-string"><span class="hljs-string">"copy_to"</span></span>: <span class="hljs-string"><span class="hljs-string">"fulltext"</span></span>,                       <span class="hljs-string"><span class="hljs-string">"fields"</span></span>: { &lt;b&gt;                            <span class="hljs-string"><span class="hljs-string">"autocomplete"</span></span> : {                               <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"text"</span></span>,                               <span class="hljs-string"><span class="hljs-string">"analyzer"</span></span>: <span class="hljs-string"><span class="hljs-string">"ngram"</span></span>,                               <span class="hljs-string"><span class="hljs-string">"search_analyzer"</span></span>: <span class="hljs-string"><span class="hljs-string">"simple"</span></span>                           },&lt;/b&gt;                           <span class="hljs-string"><span class="hljs-string">"aggs"</span></span> : {                               <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"keyword"</span></span>                           }                       }                   },</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We make similar changes for the fields address.coutry, name and gender. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, you need to determine the ngram analyzer. </font><font style="vertical-align: inherit;">To do this, set the indexing parameters for Elasticsearch in the _settings.json file. </font><font style="vertical-align: inherit;">If this file is available, Beyonder will read it automatically. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this file, I just ask and ask the tokenizer (unfortunately, the explanation of the process is beyond the scope of our conversation). </font><font style="vertical-align: inherit;">For each word, I'm going to use an inverted index. </font><font style="vertical-align: inherit;">I generate ‚Äúunderflows,‚Äù meaning Joe will be indexed as j, jo, and joe. </font><font style="vertical-align: inherit;">Thus, the inverted index will be larger, but I can search more efficiently.</font></font><br><br><pre> <code class="java hljs">{   <span class="hljs-string"><span class="hljs-string">"analysis"</span></span>: {       <span class="hljs-string"><span class="hljs-string">"analyzer"</span></span>: {           <span class="hljs-string"><span class="hljs-string">"ngram"</span></span>: {               <span class="hljs-string"><span class="hljs-string">"tokenizer"</span></span>: <span class="hljs-string"><span class="hljs-string">"ngram_tokenizer"</span></span>,               <span class="hljs-string"><span class="hljs-string">"filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"lowercase"</span></span> ]           }       },       <span class="hljs-string"><span class="hljs-string">"tokenizer"</span></span>: {           <span class="hljs-string"><span class="hljs-string">"ngram_tokenizer"</span></span>: {               <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"edgeNGram"</span></span>,               <span class="hljs-string"><span class="hljs-string">"min_gram"</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>,               <span class="hljs-string"><span class="hljs-string">"max_gram"</span></span>: <span class="hljs-string"><span class="hljs-string">"10"</span></span>,               <span class="hljs-string"><span class="hljs-string">"token_chars"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"letter"</span></span>, <span class="hljs-string"><span class="hljs-string">"digit"</span></span> ]           }       }   } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the code, you need to call Beyonder somewhere. </font><font style="vertical-align: inherit;">In ElasticsearchDao.java, where our client is specified:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ElasticsearchDao</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ObjectMapper mapper)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.esClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PreBuiltTransportClient(Settings.EMPTY) .addTransportAddress(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InternetSocketTransportAddress( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InetSocketAddress(<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-number"><span class="hljs-number">9300</span></span>) )); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mapper = mapper; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bulkProcessor = BulkProcessor.builder(esClient, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BulkProcessor.Listener() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beforeBulk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> executionID, BulkRequest request)</span></span></span><span class="hljs-function"> </span></span>{ logger.debug(<span class="hljs-string"><span class="hljs-string">"going to execute bulk of {} requests"</span></span>, request.numberOfActions()); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">afterBulk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> executionID, BulkRequest request, BulkResponse response)</span></span></span><span class="hljs-function"> </span></span>{ logger.debug(<span class="hljs-string"><span class="hljs-string">"bulk executed {} failures"</span></span>, response.hasFailures() ? <span class="hljs-string"><span class="hljs-string">"with"</span></span> : <span class="hljs-string"><span class="hljs-string">"without"</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">afterBulk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> executionID, BulkRequest request, Throwable failure)</span></span></span><span class="hljs-function"> </span></span>{ logger.warn(<span class="hljs-string"><span class="hljs-string">"error while executing bulk"</span></span>, failure); } }) .setBulkActions(<span class="hljs-number"><span class="hljs-number">10000</span></span>) .setFlushInterval(TimeValue.timeValueSeconds(<span class="hljs-number"><span class="hljs-number">5</span></span>)) .build(); &lt;b&gt;<span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ElasticsearchBeyonder.start(esClient); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { e.ptintStackTrace(); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beyonder will not delete an existing index. </font><font style="vertical-align: inherit;">Therefore, it must be removed manually via kibana: We </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f0d/a76/d55/f0da76d55a5a425fff83faef7e73c057.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">check that there is no person index: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ab/905/ec9/5ab905ec925cd929afa1e7c7f3e60f5a.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we restart the application (in debug mode). </font><font style="vertical-align: inherit;">In the console, we see that Beyonder is up and running: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/399/39a/5c8/39939a5c80e478ef1af3dfbbb961f6e0.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Through kibana, you can check that the index person is created and it looks like it was set in resources. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's generate 10,000 documents again. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/325/ead/53e/325ead53e5b3330b1bd0cceccd0f66dc.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, we still see standard behavior in the search field.</font></font> Let's fix it.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you look at the search query in PersonService.java, we see that the search is performed in the name, gender, address.country and address.city fields. Now I have a fulltext field that I can use. You can also search by the name field, but if the result matches, you must raise the result in the search results (since if a complete match is found in the name field, the result is more relevant, and it should be at the top of the list):</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String q, String f_country, String f_date, Integer from, Integer size)</span></span></span><span class="hljs-function"> </span></span>{ QueryBuilder query; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Strings.hasText(q)) { query = QueryBuilders.matchAllQuery(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {           query = QueryBuilders.simpleQueryStringQuery(q)                       .field(&lt;b&gt;<span class="hljs-string"><span class="hljs-string">"fulltext"</span></span>&lt;/b&gt;)                       .field(&lt;b&gt;<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-number"><span class="hljs-number">3.0f</span></span>&lt;/b&gt;) } SearchResponse response = elasticsearchDao.search(query, from, size); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.toString(); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After making changes, the search works correctly. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/38b/71e/efc/38b71eefc33dca82f0366c750f5bf8fc.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the same time, in search results for Joe, people named Joe will be at the top of the list. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same works for country and city. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's fix the advanced search where the standard strategy is being used. </font><font style="vertical-align: inherit;">In the advanced search method in PersonService.java, instead of searching by the name field, you must search by the name.autocomplete field that was generated during the indexing (the same for the address.country and address.city fields):</font></font><br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">advancedSearch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name, String country, String city, Integer from, Integer size)</span></span></span><span class="hljs-function"> </span></span>{       QueryBuilder query;       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Strings.hasText(name) &amp;&amp; !Strings.hasText(country) &amp;&amp; !Strings.hasText(city)) {           query = QueryBuilders.matchAllQuery();       } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {           BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();           <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Strings.hasText(name)) {               boolQueryBuilder.must(                       QueryBuilders.matchQuery(<span class="hljs-string"><span class="hljs-string">"&lt;b&gt;name.autocomplete&lt;/b&gt;"</span></span>, name)               );           }           <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Strings.hasText(country)) {               boolQueryBuilder.must(                       QueryBuilders.matchQuery(<span class="hljs-string"><span class="hljs-string">"&lt;b&gt;address.country.autocomplete&lt;/b&gt;"</span></span>, country)               );           }           <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Strings.hasText(city)) {               boolQueryBuilder.must(                       QueryBuilders.matchQuery(<span class="hljs-string"><span class="hljs-string">"&lt;b&gt;address.city.autocomplete&lt;/b&gt;"</span></span>, city)               );           }           query = boolQueryBuilder;       }       SearchResponse response = elasticsearchDao.search(query, from, size);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (logger.isDebugEnabled()) logger.debug(<span class="hljs-string"><span class="hljs-string">"advancedSearch({},{},{})={} persons"</span></span>, name, country, city, response.getHits().getTotalHits());       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.toString();   }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now everything works. </font></font><br><br><h2>  Work speed </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As part of such conversations, I am haunted by this question: you send data to Elasticsearch using the same transaction with which you send it to the database. </font><font style="vertical-align: inherit;">Does this slow down the application? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's test it out. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the code, instead of calling the database, I will simply access Elasticsearch.</font></font><br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Person </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Person person)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// hibernateService.beginTransaction(); // Person personDb = personDao.save(person); try { elasticsearchDao.save(&lt;b&gt;person&lt;/b&gt;); } catch (Exception e) { logger.error("Houston, we have a problem!", e); } // hibernateService.commitTransaction(); return person;   }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compile. </font><font style="vertical-align: inherit;">Now I use bulk API only with Elasticsearch. </font><font style="vertical-align: inherit;">Let's generate 10,000 documents again. </font><font style="vertical-align: inherit;">The request is executed almost instantly. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/84a/a1b/632/84aa1b63215f8fc89f72166e74c68f7b.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, it does not slow down the application. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even if we generate a million documents, the search will still be performed efficiently. </font><font style="vertical-align: inherit;">It is seen that the results were obtained in 4 ms.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c78/cf2/66c/c78cf266ca11e206b0fbe3be418eb5a4.png"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aggregation </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Based on the results obtained, Elasticsearch makes it possible to read various analytics. You can try to understand the data set. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In ElasticsearchDao, in addition to launching the query, add an aggregation.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> SearchResponse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QueryBuilder query, Integer from, Integer size)</span></span></span><span class="hljs-function"> </span></span>{       SearchResponse response = esClient.prepareSearch(<span class="hljs-string"><span class="hljs-string">"person"</span></span>) .setTypes(<span class="hljs-string"><span class="hljs-string">"person"</span></span>) .setQuery(query) &lt;b&gt;                        .addAggregation(                               AggregationBuilders.terms(<span class="hljs-string"><span class="hljs-string">"by_country"</span></span>).field(<span class="hljs-string"><span class="hljs-string">"address.country.aggs"</span></span>)                       )                       .addAggregation(                               AggregationBuilders.dateHistogram(<span class="hljs-string"><span class="hljs-string">"by_year"</span></span>)                                       .field(<span class="hljs-string"><span class="hljs-string">"dateOfBirth"</span></span>)    .minDocCount(<span class="hljs-number"><span class="hljs-number">0</span></span>)                                       .dateHistogramInterval(DateHistogramInterval.YEAR)                                       .extendedBounds(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExtendedBounds(<span class="hljs-number"><span class="hljs-number">1940L</span></span>, <span class="hljs-number"><span class="hljs-number">2009L</span></span>))                                       .format(<span class="hljs-string"><span class="hljs-string">"YYYY"</span></span>)                       )&lt;/b&gt;                       .setFrom(from)                       .setSize(size) .get();         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response;   }</code> </pre><br>  What's going on here?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Based on the search results, the Aggregation framework builds a by_country distribution across the address.country field (.aggs is a ‚Äúsubfield‚Äù of keyword type in Elasticsearch starting from version 5, which I need to generate at the indexing stage). As a result, he will issue the TOP-10 countries mentioned in the document (and the number of persons corresponding to each country). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I also want to build a by_year aggregation over the dateOfBirth field. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's compile it. The interface has already implemented everything, so you don‚Äôt need to change it. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/475/c14/0ab/475c140ab8e6957207c700055b63a1fc.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We get the distribution by country and by decades. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e7b/196/248/e7b1962482e33028768dce8c6ddaff3f.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose I want to click on the field and get a list of documents corresponding to this field - what is called faceted navigation. This is not automatically implemented.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you look at the PersonService.java code, I have here a filter by country and date from the interface. </font><font style="vertical-align: inherit;">I can use them to filter the results:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String q, String &lt;b&gt;f_country&lt;/b&gt;, String &lt;b&gt;f_date&lt;/b&gt;, Integer from, Integer size)</span></span></span><span class="hljs-function"> </span></span>{ QueryBuilder query; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Strings.hasText(q)) { query = QueryBuilders.matchAllQuery(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {           query = QueryBuilders.simpleQueryStringQuery(q)                       .field(<span class="hljs-string"><span class="hljs-string">"fulltext"</span></span>)                       .field(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-number"><span class="hljs-number">3.0f</span></span>) } &lt;b&gt;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Strings.hasText(f_country) || Strings.hasText(f_date)) { query = QueryBuilders.boolQuery().must(query); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Strings.hasText(f_country)) { ((BoolQueryBuilder) query).filter(QueryBuilders.termQuery(<span class="hljs-string"><span class="hljs-string">"address.country.aggs"</span></span>, f_country));           }           <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Strings.hasText(f_date)) { String endDate = <span class="hljs-string"><span class="hljs-string">""</span></span> + (Integer.parseInt(f_date) + <span class="hljs-number"><span class="hljs-number">10</span></span>); ((BoolQueryBuilder) query).filter(QueryBuilders.rangeQuery(<span class="hljs-string"><span class="hljs-string">"dateOfBirth"</span></span>).gte(f_date).lt(endDate)); } } SearchResponse response = elasticsearchDao.search(query, from, size); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.toString(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If there is anything in the f_country or f_date fields, we build a boolean query, including our previous query (it must match the previous query). </font><font style="vertical-align: inherit;">If there is anything in the filter pr country (f_country), I filter by country. </font><font style="vertical-align: inherit;">Similarly, with f_date (I consider the bounds of the user of interest for a decade and filter by date). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Checking - everything works:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7d2/765/fb4/7d2765fb4cc2f7d3be798322fe87f968.png"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aggregation tree </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also Elasticsearch allows you to make an aggregation tree (aggregation from aggregation, etc.). </font><font style="vertical-align: inherit;">Let's implement this in ElasticsearchDao.java.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> SearchResponse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QueryBuilder query, Integer from, Integer size)</span></span></span><span class="hljs-function"> </span></span>{ SearchResponse response = esClient.prepareSearch(<span class="hljs-string"><span class="hljs-string">"person"</span></span>) .setTypes(<span class="hljs-string"><span class="hljs-string">"person"</span></span>) .setQuery(query) .addAggregation( AggregationBuilders.terms(<span class="hljs-string"><span class="hljs-string">"by_country"</span></span>).field(<span class="hljs-string"><span class="hljs-string">"address.country.aggs"</span></span>) .subAggregation(AggregationBuilders.dateHistogram(<span class="hljs-string"><span class="hljs-string">"by_year"</span></span>) .field(<span class="hljs-string"><span class="hljs-string">"dateOfBirth"</span></span>) .minDocCount(<span class="hljs-number"><span class="hljs-number">0</span></span>) .dateHistogramInterval(DateHistogramInterval.days(<span class="hljs-number"><span class="hljs-number">3652</span></span>)) .extendedBounds(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExtendedBounds(<span class="hljs-number"><span class="hljs-number">1940L</span></span>, <span class="hljs-number"><span class="hljs-number">2009L</span></span>)) .format(<span class="hljs-string"><span class="hljs-string">"YYYY"</span></span>) .subAggregation(AggregationBuilders.avg(<span class="hljs-string"><span class="hljs-string">"avg_children"</span></span>).field(<span class="hljs-string"><span class="hljs-string">"children"</span></span>)) ) ) .addAggregation( AggregationBuilders.dateHistogram(<span class="hljs-string"><span class="hljs-string">"by_year"</span></span>) .field(<span class="hljs-string"><span class="hljs-string">"dateOfBirth"</span></span>) .minDocCount(<span class="hljs-number"><span class="hljs-number">0</span></span>) .dateHistogramInterval(DateHistogramInterval.YEAR) .extendedBounds(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExtendedBounds(<span class="hljs-number"><span class="hljs-number">1940L</span></span>, <span class="hljs-number"><span class="hljs-number">2009L</span></span>)) .format(<span class="hljs-string"><span class="hljs-string">"YYYY"</span></span>)             )             .setFrom(from)             .setSize(size)          ));       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response;   }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, I use the same aggregation across the country. </font><font style="vertical-align: inherit;">Then, for each individual country, I make my distribution by decades of birth, counting the average number of children that people in the database have. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the result (for this I changed the interface a little):</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/14c/3fe/7ff/14c3fe7ffba859abea0794100426d64f.png"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exception </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You saw how we integrated Elasticsearch in a synchronous manner. But what happens if I need to understand the behavior of Elasticsearch. You saw how I receive exception, I log it. If you want to do this asynchronously, you can use a broker. Instead of sending data directly to Elasticsearch, we can send them to any message queue system, then, using a request similar to what we wrote earlier, read from the message queue and send the request to Elasticsearch via esClient. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7a2/f17/184/7a2f17184b0a35a8abc07efa0c4e69b2.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And if you don‚Äôt want to write your own code that will read from the message queue, you can use something like logstash: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7bc/00d/ddb/7bc00dddba0d9839bccfcdf3b791a934.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is an open source tool created by Elastic. It provides data transfer from source, on-the-fly transformation and sending to Elasticsearch or data storage.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Logstash can be scaled - just create several different instances: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e24/1e4/327/e241e4327b8bda35d66076ccd9c6d6f3.png"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Instead of totals </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you have any data in your company, take 1-2 days to a test project (‚Äúproof of concept‚Äù), transfer the data to Elasticsearch, build the application on the similarity of what I showed you today, and get benefits. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I already mentioned one of them - kibana, a free tool that you can use to build panels, like: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a4b/761/82d/a4b76182de381eb79209267297bb2b45.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So you can explore your data from any side in real time.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If this topic is close to you and you live in Java, you will certainly be interested in the following </font></font><a href="https://jokerconf.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reports of the upcoming November Joker 2017 conference</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><ul><li> <a href="https://jokerconf.com/2017/talks/g3wijzyyfamwe6gqsgawa/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java 9: ‚Äã‚Äãthe good parts</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Cay Horstmann, San Jose State University)</font></font><br></li><li> <a href="https://jokerconf.com/2017/talks/6riwnli6hk2ms4ogqwwyg8/">Java 8: , , </a> ( , XP Injection) <br></li><li> <a href="https://jokerconf.com/2017/talks/5wyrdrwkjyuswcwacakam4/">Birth, life and death of a class</a> (Volker Simonis, SAP) <br></li><li> <a href="https://jokerconf.com/2017/talks/6ghxf0lrm4mwugguokgesy/">Java Code Coverage mechanics</a> (Evgeny Mandrikov, Marc Hoffmann) <br></li></ul></div><p>Source: <a href="https://habr.com/ru/post/340856/">https://habr.com/ru/post/340856/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340842/index.html">Galloping in Europe: the journey of the "Formula Student" from the Czech Republic to Moscow</a></li>
<li><a href="../340846/index.html">Life after banning Google Global Cache: Implications for providers and customers</a></li>
<li><a href="../340850/index.html">Internet content blocking: the situation on the world stage</a></li>
<li><a href="../340852/index.html">Adaptive emails without pain and suffering</a></li>
<li><a href="../340854/index.html">Smart nets for fishermen: how we taught smartphones to recognize fish</a></li>
<li><a href="../340858/index.html">As I stopped worrying and started cutting rectangles in Unity correctly</a></li>
<li><a href="../340860/index.html">Forward to the past: IT departments of companies 2018</a></li>
<li><a href="../340862/index.html">Linux Piter # 3: what about this time?</a></li>
<li><a href="../340866/index.html">Google Forms: we fix event of sending the form in Google Analytics</a></li>
<li><a href="../340868/index.html">Design for iPhone X. Guidelines for iOS 11</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>