<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Animations in Android based on Kotlin and RxJava</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! Last year, Ivan ≈†koriƒá from PSPDFKit spoke at MBLT DEV with a report on creating animations in Android based on Kotlin and the RxJava librar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Animations in Android based on Kotlin and RxJava</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://mbltdev.ru/ru%3Futm_source%3DIvan%26utm_medium%3DHabr"><img src="https://habrastorage.org/webt/2g/5z/pi/2g5zpitzszs5lxzgdighjoo14u4.png"></a> <br><br>  Hi, Habr!  Last year, Ivan ≈†koriƒá from PSPDFKit spoke at <a href="https://mbltdev.ru/ru%3Futm_source%3DIvan%26utm_medium%3DHabr">MBLT DEV</a> with a report on creating animations in Android based on Kotlin and the RxJava library. <br><br>  I now use the techniques from the report in working on my project, they are great help.  Under the cut - the transcript of the report and the video, now you can use these techniques. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Animation </h2><br>  There are 4 classes in Android, which are applied as if by default: <br><br><ol><li>  <b>ValueAnimator</b> - this class provides a simple synchronization mechanism for launching animations that calculate animated values ‚Äã‚Äãand set them for View. </li><li>  <b>ObjectAnimator</b> is a subclass of ValueAnimator that allows you to support animation for object properties. </li><li>  <b>AnimatorSet</b> is used to create a sequence of animations.  For example, you have a sequence of animations: <br><br><ol><li>  View leaves on the left of the screen. </li><li>  After completing the first animation, we want to animate the appearance for another View, etc. </li></ol></li><li>  <b>ViewPropertyAnimator</b> - automatically launches and optimizes animations for the selected View property.  Basically we will use it.  Therefore, we will apply this API and then put it into RxJava as part of reactive programming. </li></ol><br><cut></cut><br><h3>  ValueAnimator </h3><br>  Let's <b>sort the ValueAnimator</b> framework.  It is used to change the value.  You set the range of values ‚Äã‚Äãthrough <b>ValueAnimator.ofFloat</b> for the primitive type float from 0 to 100. Specify the value of the <b>Duration</b> and start the animation. <br>  Consider an example: <br><br><pre><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> animator = ValueAnimator.ofFloat(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">100f</span></span>) animator.duration = <span class="hljs-number"><span class="hljs-number">1000</span></span> animator.start() animator.addUpdateListener(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ValueAnimator.AnimatorUpdateListener { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ValueAnimator</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> animatedValue = animation.animatedValue <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> textView.translationX = animatedValue } })</code> </pre> <br>  Here we add <b>UpdateListener</b> and with each update we will move our View horizontally and change its position from 0 to 100, although this is not a very good way to perform this operation. <br><br><h3>  ObjectAnimator </h3><br>  Another example of animation implementation is ObjectAnimator: <br><br><pre> <code class="hljs pgsql">val objectAnimator = ObjectAnimator.ofFloat(textView, "translationX", <span class="hljs-number"><span class="hljs-number">100</span></span>f) objectAnimator.duration = <span class="hljs-number"><span class="hljs-number">1000</span></span> objectAnimator.<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>()</code> </pre> <br>  We give him the command to change the specific parameter of the desired View to a certain value and set the time using the <b>setDuration</b> method.  The bottom line is that the <b>setTranslationX</b> method should be in your class, then the system will find this method through reflection, and then the View will be animated.  The problem is that reflection is used here. <br><br><h3>  Animatorset </h3><br>  Now consider the <b>AnimatorSet</b> class: <br><br><pre> <code class="hljs pgsql">val bouncer = AnimatorSet() bouncer.play(bounceAnim).<span class="hljs-keyword"><span class="hljs-keyword">before</span></span>(squashAnim1) bouncer.play(squashAnim1).<span class="hljs-keyword"><span class="hljs-keyword">before</span></span>(squashAnim2) val fadeAnim = ObjectAnimator.ofFloat(newBall, "alpha", <span class="hljs-number"><span class="hljs-number">1</span></span>f, <span class="hljs-number"><span class="hljs-number">0</span></span>f) fadeAnim.duration = <span class="hljs-number"><span class="hljs-number">250</span></span> val animatorSet = AnimatorSet() animatorSet.play(bouncer).<span class="hljs-keyword"><span class="hljs-keyword">before</span></span>(fadeAnim) animatorSet.<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>()</code> </pre> <br>  In fact, it is not very convenient to use, especially for a large number of objects.  If you want to make more complex animations - for example, setting a delay between the appearance of animations, and the more animations you want to perform, the more difficult it is to control it all. <br><br><h3>  ViewPropertyAnimator </h3><br>  The last class is <b>ViewPropertyAnimator</b> .  It is one of the best classes for animating View.  This is a great API for introducing the sequence of animations you run: <br><br><pre> <code class="hljs kotlin">ViewCompat.animate(textView) .translationX(<span class="hljs-number"><span class="hljs-number">50f</span></span>) .translationY(<span class="hljs-number"><span class="hljs-number">100f</span></span>) .setDuration(<span class="hljs-number"><span class="hljs-number">1000</span></span>) .setInterpolator(AccelerateDecelerateInterpolator()) .setStartDelay(<span class="hljs-number"><span class="hljs-number">50</span></span>) .setListener(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : Animator.AnimatorListener { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationRepeat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Animator</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Animator</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationCancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Animator</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Animator</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} })</code> </pre><br>  Run the <b>ViewCompat.animate</b> method, which returns a <b>ViewPropertyAnimator</b> , and set the value 50 to animate <b>translationX</b> , 100 for the <b>translatonY</b> parameter. Then specify the duration of the animation, as well as the interpolator.  The interpolator determines the sequence in which the animations will appear.  In this example, an interpolator is used, which accelerates the beginning of the animation and adds a slowdown at the end.  Also add a delay to start the animation.  In addition, we have <b>AnimatorListener</b> .  With it, you can subscribe to certain events that occur during the execution of the animation.  This interface has 4 methods: <b>onAnimationStart</b> , <b>onAnimationCancel</b> , <b>onAnimationEnd</b> , <b>onAnimationRepeat</b> . <br><br>  As a rule, we are only interested in the completion of the animation.  In API Level 16 <br>  added withEndAction: <br><br><pre> <code class="hljs pgsql">.withEndAction({ //API <span class="hljs-number"><span class="hljs-number">16</span></span>+ //<span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something here <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> animation ends })</code> </pre> <br>  In it, you can define the <b>Runnable</b> interface, and after the specific animation is finished, the action will be executed. <br><br>  Now a few comments on the process of creating animations in general: <br><br><ol><li>  The <b>start ()</b> method is optional: as soon as you call the <b>animate ()</b> method, a sequence of animations is entered.  When <b>ViewPropertyAnimator</b> is configured, the system will start the animation as soon as it is ready to do it. </li><li>  Only one <b>ViewPropertyAnimator</b> class can only animate a specific View.  Therefore, if you want to perform several animations, for example, you want something to move, and at the same time increase in size, then you need to specify it in one animator. </li></ol><br><h3>  Why did we choose RxJava? </h3><br>  Let's start with a simple example.  Suppose we create a fadeIn method: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, duration: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Completable { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> animationSubject = CompletableSubject.create() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> animationSubject.doOnSubscribe { ViewCompat.animate(view) .setDuration(duration) .alpha(<span class="hljs-number"><span class="hljs-number">1f</span></span>) .withEndAction { animationSubject.onComplete() } } }</code> </pre> <br>  This is a rather primitive decision, and to apply it to your project, you will need to take into account some of the nuances. <br><br>  We are going to create a <b>CompletableSubject</b> that we will use to wait for the animations to complete, and then use the <b>onComplete</b> method to send messages to subscribers.  To launch animations sequentially, it is necessary to start the animation not immediately, but as soon as someone signs up for it.  In this way, you can sequentially run several animations in a reactive style. <br><br>  Consider the animation itself.  In it we transfer View, over which animation will be made, and also we specify duration of animation.  And since this is an animation - appearance, we must specify transparency 1. <br><br>  Let's try to use our method and create a simple animation.  Suppose we have 4 buttons on the screen, and we want to add an appearance animation of 1 second for them: <br><br><pre> <code class="hljs go">val durationMs = <span class="hljs-number"><span class="hljs-number">1000</span></span>L button1.alpha = <span class="hljs-number"><span class="hljs-number">0f</span></span> button2.alpha = <span class="hljs-number"><span class="hljs-number">0f</span></span> button3.alpha = <span class="hljs-number"><span class="hljs-number">0f</span></span> button4.alpha = <span class="hljs-number"><span class="hljs-number">0f</span></span> fadeIn(button1, durationMs) .andThen(fadeIn(button2, durationMs)) .andThen(fadeIn(button3, durationMs)) .andThen(fadeIn(button4, durationMs)) .subscribe()</code> </pre><br>  The result is such a concise code.  With the help of the operator <b>andThen</b> you can run animations sequentially.  When we subscribe to it, it will send the <b>doOnSubscribe</b> event to the <b>Completable</b> , which is first in the queue for execution.  After its completion, he will subscribe to the second, third, and so on the chain.  Therefore, if at some stage an error occurs, then the entire sequence produces an error.  You must also specify an alpha value of 0 before the animation starts so that the buttons are invisible.  And this is how it will look like: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sq/-m/02/sq-m02uv2i1uu85udver9fwzqww.gif"></div><br>  Using <b>Kotlin</b> , we can use extensions: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(duration: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Completable { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> animationSubject = CompletableSubject.create() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> animationSubject.doOnSubscribe { ViewCompat.animate(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .setDuration(duration) .alpha(<span class="hljs-number"><span class="hljs-number">1f</span></span>) .withEndAction { animationSubject.onComplete() } } }</code> </pre> <br>  For the View class, an extension function has been added.  In the future, there is no need to pass the View argument to the fadeIn method.  Now you can replace all the calls to the View with the keyword <b>this</b> .  This is what <b>Kotlin</b> is capable of <b>.</b> <br><br>  Let's see how the call to this function has changed in our animation chain: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">button1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">durationMs</span></span>) <span class="hljs-selector-class"><span class="hljs-selector-class">.andThen</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">durationMs</span></span>)) <span class="hljs-selector-class"><span class="hljs-selector-class">.andThen</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button3</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">durationMs</span></span>)) <span class="hljs-selector-class"><span class="hljs-selector-class">.andThen</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button4</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">durationMs</span></span>)) <span class="hljs-selector-class"><span class="hljs-selector-class">.subscribe</span></span>()</code> </pre><br>  Now the code looks more understandable.  It explicitly states that we want to apply an animation with a specific duration to the desired display.  With the help of the <b>andThen</b> operator, <b>we</b> create a sequential chain of animations to the second, third button, and so on. <br><br>  Always specify the duration of the animations, this value is the same for all mappings - 1000 milliseconds.  <b>Kotlin</b> comes to the rescue again.  We can make the time default. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(duration: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1000</span></span></span></span><span class="hljs-function"><span class="hljs-params">L)</span></span></span></span>:</code> </pre> <br>  If you do not specify the <b>duration</b> parameter, the time will automatically be set to 1 second.  But if we want for the button at number 2 to increase this time to 2 seconds, we simply specify this value in the method: <br><br><pre> <code class="hljs erlang">button1.fadeIn() .<span class="hljs-keyword"><span class="hljs-keyword">and</span></span>Then(button2.fadeIn(duration = <span class="hljs-number"><span class="hljs-number">2000</span></span>L)) .<span class="hljs-keyword"><span class="hljs-keyword">and</span></span>Then(button3.fadeIn()) .<span class="hljs-keyword"><span class="hljs-keyword">and</span></span>Then(button4.fadeIn()) .subscribe()</code> </pre><br><h3>  Running two animations </h3><br>  We were able to start a sequence of animations using the <b>andThen</b> operator.  What to do if you need to run 2 animations simultaneously?  For this, there is a <b>mergeWith</b> operator in <b>RxJava</b> , which allows you to combine the elements <b>Completable</b> in such a way that they will run simultaneously.  This statement starts all items and finishes work after the last item is shown.  If we change <b>andThen</b> to <b>mergeWith</b> , we get an animation in which all the buttons appear simultaneously, but button 2 will appear a little longer than the others: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">button1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>() <span class="hljs-selector-class"><span class="hljs-selector-class">.mergeWith</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>(2000)) <span class="hljs-selector-class"><span class="hljs-selector-class">.mergeWith</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button3</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>()) <span class="hljs-selector-class"><span class="hljs-selector-class">.mergeWith</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button4</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>()) <span class="hljs-selector-class"><span class="hljs-selector-class">.subscribe</span></span>()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jd/fw/xb/jdfwxbgedu3gnufrsrfqezc46ga.gif"></div><br>  Now we can group the animations.  Let's try to complicate the task: for example, we want to first appear at the same time button 1 and button 2, and then button 3 and button 4: <br><br><pre> <code class="hljs css">(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>()<span class="hljs-selector-class"><span class="hljs-selector-class">.mergeWith</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>())) <span class="hljs-selector-class"><span class="hljs-selector-class">.andThen</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button3</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>()<span class="hljs-selector-class"><span class="hljs-selector-class">.mergeWith</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button4</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>())) <span class="hljs-selector-class"><span class="hljs-selector-class">.subscribe</span></span>()</code> </pre> <br>  We combine the first and second buttons with the operator <b>mergeWith</b> , repeat the action for the third and fourth, and launch these groups sequentially using the operator <b>andThen</b> .  Now let's improve the code by adding the <b>fadeInTogether</b> method: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeInTogether</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, second: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Completable { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first.fadeIn() .mergeWith(second.fadeIn()) }</code> </pre> <br>  It allows you to run fadeIn animation for two views at the same time.  How the animation chain has changed: <br><br><pre> <code class="hljs erlang"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeInTogether</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(button1, button2)</span></span></span><span class="hljs-function"> .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">andThen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fadeInTogether(button3, button4))</span></span></span><span class="hljs-function"> .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre> <br>  The result is the following animation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hk/xw/pe/hkxwpemdtbmksyv_r7mq2qx3bcw.gif"></div><br>  Consider a more complex example.  Suppose we need to show the animation with some predetermined delay.  This will help the operator <b>interval</b> : <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> timeObservable = Observable.interval(<span class="hljs-number"><span class="hljs-number">100</span></span>, TimeUnit.MILLISECONDS) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> btnObservable = Observable.just(button1, button2, button3, button4) }</code> </pre> <br>  It will generate values ‚Äã‚Äãevery 100 milliseconds.  Each button will appear after 100 milliseconds.  Next, specify another Observable, which will emit buttons.  In this case, we have 4 buttons.  Let's use the <b>zip</b> operator. <br><br><img src="https://habrastorage.org/webt/g5/qq/yi/g5qqyih178patmj5cjpfyoevkkw.png" alt="image"><br><br>  Before us are streams of events: <br><br><pre> <code class="hljs mel">Observable.zip(timeObservable, btnObservable, BiFunction&lt;Long, View, Disposable&gt; { _, <span class="hljs-keyword"><span class="hljs-keyword">button</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">button</span></span>.fadeIn().subscribe() })</code> </pre> <br>  The first is <b>timeObservable</b> .  This <b>Observable</b> will generate numbers at regular intervals.  Suppose it will be 100 milliseconds. <br><br>  The second <b>Observable</b> will generate a view.  The <b>zip</b> operator waits until the first object appears in the first stream, and connects it with the first object from the second stream.  Despite the fact that all these 4 objects in the second stream will appear immediately, it will wait until the objects begin to appear on the first stream.  Thus, the first object from the first stream will connect to the first object from the second in the form of our view, and 100 milliseconds later, when a new object appears, the operator will merge it with the second object.  Therefore, the view will appear with a certain delay. <br><br>  Let's <b>deal</b> with <b>BiFinction</b> in <b>RxJava</b> .  This function receives two objects as input, performs some operations on them and returns the third object.  We want to take time and view objects and get <b>Disposable</b> because we <b>invoke the fadeIn</b> animation and subscribe to <b>subscribe</b> .  The value of time is not important to us.  As a result, we get the following animation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8q/wa/1z/8qwa1z75xolp2jb-hsznqzncykw.gif"></div><br><h3>  Vangogh </h3><br>  I'll tell you about the <a href="https://github.com/PSPDFKit-labs/VanGogh">project</a> that Ivan began to develop for MBLT DEV 2017. <br><br>  The library, which was developed by Ivan, presents various skins for animations.  We have already considered this above.  It also contains ready-made animations that you can use.  You get a generalized set of tools for creating your own animations.  This library will provide you with more powerful components for reactive programming. <br><br>  Consider the library by example: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> : AnimationCompletable { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AnimationBuilder.forView(view) .alpha(<span class="hljs-number"><span class="hljs-number">1f</span></span>) .duration(<span class="hljs-number"><span class="hljs-number">2000L</span></span>) .build().toCompletable() }</code> </pre> <br>  Suppose you want to create an animation that appears, but this time, instead of the <b>Completable</b> object, there is an <b>AnimationCompletable</b> .  This class is inherited from <b>Completable</b> , so now more functions appear.  One important feature of the previous code was that it was impossible to cancel animations.  Now you can create an <b>AnimationCompletable</b> object that makes the animation stop as soon as we unsubscribe from it. <br><br>  Create an emerging animation using <b>AnimationBuilder</b> - one of the library classes.  Specify which view will be applied to the animation.  In essence, this class copies the behavior of <b>ViewPropertyAnimator</b> , but with the difference that at the output we get a stream. <br><br>  Next, set alpha 1f and a duration of 2 seconds.  Then we collect the animation.  As soon as we call the <b>build</b> statement, an animation appears.  We assign the animation property of an unmodifiable object, so it will save these characteristics for its launch.  But the animation itself will not start. <br><br>  Call <b>toCompletable</b> , which will create an <b>AnimationCompletable</b> .  Wrap the parameters of this animation into a kind of shell for reactive programming, and as soon as you subscribe to it, it will start the animation.  If you disable it before the process is complete, the animation will end.  You can now also add a callback function.  You can set the operators <b>doOnAnimationReady</b> , <b>doOnAnimationStart</b> , <b>doOnAnimationEnd,</b> and the like: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> : AnimationCompletable { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AnimationBuilder.forView(view) .alpha(<span class="hljs-number"><span class="hljs-number">1f</span></span>) .duration(<span class="hljs-number"><span class="hljs-number">2000L</span></span>) .buildCompletable() .doOnAnimationReady { view.alpha = <span class="hljs-number"><span class="hljs-number">0f</span></span> } }</code> </pre> <br>  In this example, we showed how to use <b>AnimationBuilder</b> conveniently, and change the state of our View before starting the animation. <br><br><h3>  Video of the report </h3><br>  We looked at one of the options for creating, compositing, and customizing animations using Kotlin and RxJava.  Here is a link to the <a href="https://github.com/PSPDFKit-labs/VanGogh">project</a> , which describes the basic animations and examples for them, as well as the basic shell for working with animation. <br><br>  In addition to decoding, I share a video of the report: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Yv80bdUnJgw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Speakers MBLT DEV 2018 </h3><br>  Before <a href="https://mbltdev.ru/ru%3Futm_source%3DIvan%26utm_medium%3DHabr">MBLT DEV 2018</a> , a little more than two months are left.  We will perform: <br><br><ul><li>  Laura Morinigo, Google Developer Developer </li><li>  Kaushik Gopal, author of the Fragmented podcast </li><li>  Artyom Rudoy, ‚Äã‚ÄãBadoo </li><li>  Dina Sidorova, Google, and <a href="https://mbltdev.ru/ru%3Futm_source%3DIvan%26utm_medium%3DHabr">others</a> . </li></ul><br>  Tomorrow the ticket price will change.  <a href="https://mbltdev.ru/ru/registration%3Futm_source%3DIvan%26utm_medium%3DHabr">Sign up</a> today. </div><p>Source: <a href="https://habr.com/ru/post/418383/">https://habr.com/ru/post/418383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418371/index.html">Microtasks for programmers and an alternative cryptocurrency payment method</a></li>
<li><a href="../418375/index.html">Review of the photopolymer 3D-printer Uniz Slash +</a></li>
<li><a href="../418377/index.html">Kotlin: two fly in the ointment</a></li>
<li><a href="../418379/index.html">Children's bioelectric prosthesis. Part 2</a></li>
<li><a href="../418381/index.html">What's new in DevTools in Chrome version 68</a></li>
<li><a href="../418385/index.html">How I assembled a computer for old games</a></li>
<li><a href="../418387/index.html">The dialogue of physicists about the soul</a></li>
<li><a href="../418389/index.html">RabbitMQ vs. Kafka: Kafka application in event-oriented applications</a></li>
<li><a href="../418391/index.html">OSPF (Part One)</a></li>
<li><a href="../418393/index.html">[Friday] How we sawed the 3d web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>