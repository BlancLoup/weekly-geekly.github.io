<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How we gopher apples fed or effective backend on Go for iOS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As promised, I talk about how we migrated our backend to Go and were able to reduce the amount of business logic on the client by more than a third. 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How we gopher apples fed or effective backend on Go for iOS</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/cb0/102/c37/cb0102c37db8430180860688da0c9ed6.png"></p><br><p>  As promised, I talk about how we migrated our backend to Go and were able to reduce the amount of business logic on the client by more than a third. </p><br><p>  <strong>For whom</strong> : small companies, Go and mobile developers, as well as everyone who is in trend or just interested in this topic. <br>  <strong>What about</strong> : the reasons for switching to Go, the difficulties encountered, as well as instructions and tips for improving the architecture of a mobile application and its backend. <br>  <strong>Level</strong> : junior and middle. </p><br><a name="habracut"></a><br><p>  For a long time, our mobile outsourcing development team worked on third-party projects that had their own backend developers, and we acted as a contractor for a specific product.  Despite the fact that the agreements have always been clearly stated that it was we, as mobile developers, who dictated the music and API, but this did not always help. </p><br><p><img src="https://habrastorage.org/web/7e4/9c3/177/7e49c317728b416cab9f0b1f0c34ac59.png"></p><br><p>  So not always, that recently I made a small collection of traumatic situations that I posted in one of my past articles. </p><br><p>  It so happened that we had a pretty strong Java (Spring) developer in the team, and we decided to firmly declare to each new customer: we write the backend ourselves, or look for someone else.  At first, they were afraid that such a principled position would frighten off, and we would end up remaining naked on bread and water.  But it turned out that if we already liked someone at the negotiation stage and want to work with us, then we can agree on almost everything.  Even when the client already has his own people in the team, whom he initially planned to use.  Then we learned such a clever word as microservices, and what can be done by a separate server with business logic, performing tasks strictly for a mobile application.  I will not argue that such an approach is not appropriate everywhere, but this will not be further discussed. </p><br><h2 id="prichiny-perehoda-na-go">  Reasons to Go </h2><br><p>  After several successful Java projects, it was too hard for us.  A lot of time was spent on routine to make everything as convenient as possible for the application. </p><br><p>  I don‚Äôt want to say anything bad about Spring and Java in general, it‚Äôs an amazing tool for serious tasks, like a huge bulky Spanish galleon.  And we were looking for something more like a lightweight pirate clipper. </p><br><p>  We had to quickly implement features, change them easily and not warm our heads in search of the most optimal solution in every situation.  You know how it happens when you google for a long time on the subject of a typical solution of your task, so that it is the most suitable, then it turns out that 5 out of 10 of them are already outdated.  And then you spend half an hour choosing a name for a variable. </p><br><p>  Go has no such problem.  From the word at all.  Sometimes even through too much: you sit, you look for the perfect solution, and StackOverflow answers you: ‚ÄúWell, yes, just with a for loop, and what did you wait for?‚Äù </p><br><p>  Over time, you get used to it and you stop to google all sorts of trivia over trifles, and you start to turn on your head and just write code. </p><br><h2 id="kakie-voznikli-slozhnosti">  What are the difficulties </h2><br><p>  To begin with, there is no inheritance.  At first, it just took out the brain.  You have to break all your ideas about OOP and get used to <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D1%2582%25D0%25B8%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2582%25D0%25B8%25D0%25BF%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">duck typing</a> .  Formulating in simple terms: if it looks like a duck, swims like a duck and quacks like a duck, then this may be the duck. </p><br><p>  In essence, there is only interface inheritance. </p><br><p>  And secondly, from essential minuses, - a small amount of ready tools, but there are a lot of bugs.  Many things can not be done in the usual way, but something is missing as a class.  For example, there is no normal framework for IoC ( <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF_%25D0%25B8%25D0%25BD%25D0%25B2%25D0%25B5%25D1%2580%25D1%2581%25D0%25B8%25D0%25B8_%25D0%25B7%25D0%25B0%25D0%25B2%25D0%25B8%25D1%2581%25D0%25B8%25D0%25BC%25D0%25BE%25D1%2581%25D1%2582%25D0%25B5%25D0%25B9">dependency inversion</a> ).  Experienced gopher will say that there is either from Facebook.  But maybe I just do not know how to cook it, or after all its convenience actually leaves much to be desired.  It simply cannot compare with Spring and therefore has to work a lot with its hands. </p><br><p>  Another of the small limitations of Go in general, for example, cannot make an API of the form: </p><br><pre><code class="hljs objectivec">/cards/:<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> /cards/something</code> </pre> <br><p>  As for the existing http router, these are mutually exclusive requests.  It is confused between the wildcard variable and the specific address something.  Stupid limitation, but you have to live with it.  If someone knows the solution, I will be glad to hear. </p><br><p>  There is also no hibernate or less adequate counterparts.  Yes, there are many ORM, but all of them are still quite weak.  The best I've met during development on Go is <a href="http://jinzhu.me/gorm/">gorm</a> .  Its main advantage is the most convenient mapping of the response from the base into the structure.  And requests will have to be written on bare sql if you don‚Äôt want to spend long hours debugging dubious behavior. </p><br><p>  <strong>Ps</strong> .  I want to separately share the workaround that arose in the process of working with this liby.  If you need to write the id after insert into some variable using gorm, and not into the structure as usual, the following crutch will help.  At the request level, rename the returning result to any other than id: </p><br><pre> <code class="sql hljs">... returning id as value</code> </pre> <br><p>  With a subsequent scan to variable: </p><br><pre> <code class="go hljs">... Row().Scan(&amp;variable)</code> </pre> <br><p>  It turns out that the 'id' field is perceived by the gorm as a specific field of the object.  And to be unleashed, you need to rename it to something else at the request level. </p><br><h2 id="plyusy-ili-pochemu-my-vse-taki-pishem-na-go">  Pros or why we still write on Go </h2><br><p>  I want to start at the threshold of entry: it is minimal.  Remembering what rattle caused in the development of the same Spring, Go, compared with him, can be taught in elementary grades, it is so simple. </p><br><p>  And this simplicity lies not only in the language, but also in the environment that it carries.  You do not need to read long mana by gradle and maven, you do not need to write long configs so that at least everything will start at once.  Here, everything costs a couple of teams, and a decent builder and profiler is already part of the language and does not require in-depth research to start. <br>  As they say: easy to learn, hard to master.  This is something that I have always personally lacked in modern technologies: they seem to be made not for people. </p><br><p>  It also follows the speed of development.  The language was made for one purpose: </p><br><p><img src="https://habrastorage.org/web/f39/67e/d1f/f3967ed1f2ad47418c135945934daed9.jpg"></p><br><p>  In fact, it is a backend language for business.  He is fast, he is simple and allows you to solve complex problems in understandable ways.  As for complex tasks and clarity, this is a separate topic for conversation, because Go has such a cool thing as gorutinki and channels.  This is the most convenient multithreading with minimal opportunity to shoot yourself in the foot. </p><br><h1 id="arhitektura">  Architecture </h1><br><h2 id="web">  Web </h2><br><p>  As a web framework, <a href="https://github.com/gin-gonic/gin">Gin was</a> chosen.  There is also <a href="https://revel.github.io/">Revel</a> , but it seemed to us too narrow and unshakably dictating its paradigm.  We prefer a little more untied hands so that you can be flexible. </p><br><p>  Gin seduced by a convenient API and the absence of unnecessary difficulties.  The threshold of entry for him is just low.  So much so that the interns understood it literally in a day.  There is simply nowhere to get confused.  All the necessary functionality in full view. </p><br><p>  Of course, he is not without problems.  Some decisions, such as cache, are made by a third party.  And there is a conflict of imports, if you are accustomed to using import through github, and they have done through gopkg and vice versa.  As a result, the two plug-ins can simply be mutually exclusive. <br>  If someone knows a solution to this problem, please write in the comments. </p><br><h2 id="menedzher-zavisimostey">  Dependency manager </h2><br><p>  I will not write for a long time, but I will immediately say that this is without a doubt <a href="https://github.com/Masterminds/glide">Glide</a> .  If you have worked with gradle or maven, then you probably know the paradigm of dependency declarations in a certain file and their subsequent use as necessary.  So Glide is a hamster gradle, with conflict resolution and other goodies. </p><br><p>  By the way, if you have any problems with testing, when the go test climbs into the vendor folder, eagerly testing each lib, then the problem is solved simply: </p><br><pre> <code class="bash hljs">go <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> $(glide novendor)</code> </pre> <br><p>  This option excludes the vendor folder from testing.  In the repository itself is enough to put glide.yaml and glide.lock files. </p><br><p>  Mobile development is not going to help, but just so you know) </p><br><h2 id="orm-i-realm">  ORM and Realm </h2><br><p>  This will be a voluminous section on transferring and storing data from the backend to the client.  Let's start with Go, smoothly moving to the mobile platform. </p><br><div class="spoiler">  <b class="spoiler_title">What is Realm and why is it better than CoreData / Arrays / SQLite?</b> <div class="spoiler_text"><p>  If you have never encountered Realm and do not understand what it is about, then the spoiler was correctly opened. </p><br><p>  Realm is a mobile database that makes it easier to work with data synchronization throughout the entire application.  It does not have such problems as in CoreData, where you constantly have to work in contexts, even when the object has not been saved yet.  Easier to maintain consistency. <br>  It is enough just to create an entity and work with it as with an ordinary object, transferring it between threads and juggling it as you please. </p><br><p>  It does a lot of operations for you, but, of course, it also has jambs: there is no case-insensitive search, in general, the search is not completed normally, it consumes memory as not in itself (especially on android), there is no grouping like in the FRC, and etc. </p><br><p>  We felt that it was worthwhile to put up with these problems and it is worth it. </p></div></div><br><p>  In order not to repeat, let me briefly say that we use <a href="http://jinzhu.me/gorm/">Gorm</a> as an orm and will give a couple of recommendations: </p><br><ul><li>  Write SQL queries with your hands, do not be lazy.  At the same time learn SQL, if you have not done it yet. </li><li>  Try to make requests within a single transaction, if possible. </li><li>  Choose from the database the minimum required fields. </li><li>  Be sure to map everything into structures.  The fewer intermediate variables, the better. </li></ul><br><p>  Probably, this is all applicable to any technology, here I‚Äôm a little skapitanil, but still.  Remind once again does not hurt, this is important. </p><br><p>  Now, as for the mobile application.  Your main task is to make the fields returned in the queries have the same name with the corresponding names on the client.  This can be easily achieved using so-called tags: </p><br><p><img src="https://habrastorage.org/web/352/9b7/e2b/3529b7e2b08a475098d61db4b8284787.png"><br><br>  Make sure the json tag has the correct name.  And it is desirable that he had the omitempty flag set, as in the example.  This avoids cluttering up the response with empty fields. </p><br><div class="spoiler">  <b class="spoiler_title">Why go?</b> <div class="spoiler_text"><p>  You may well have a question: what‚Äôs the point of Go in general, if the same names can be made in any language?  And you will be right, but one of the advantages of Go is the easiest formatting of anything through reflection and structure.  Let reflection be in many languages, but Go is the easiest to work with. </p></div></div><br><p>  By the way, if you need to hide an empty structure from the response, then the best way is to overload the MarshalJSON method on the structure: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// ,     Pharmacy   Object func (r Object) MarshalJSON() ([]byte, error) { type Alias Object var pharmacy *Pharmacy = nil //  id != 0,   .   -  nil if r.Pharmacy.ID != 0 { pharmacy = &amp;r.Pharmacy } return json.Marshal(&amp;struct { Pharmacy *Pharmacy `json:"pharmacy,omitempty"` Alias }{ Pharmacy: pharmacy, Alias: (Alias)(r), }) }</span></span></code> </pre> <br><p>  Many do not bother and immediately write a pointer instead of a value in the structures, but this is not the Go way.  Go doesn't like pointers where they are not needed.  This makes it impossible to optimize your code and use its full potential. </p><br><p>  In addition to the names of the fields still pay attention to their types.  Numbers should be numbers, and strings should be strings (thanks, cap).  In terms of dates, RFC3339 is best used.  On the server, the date can also be formatted via overload: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *Comment)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MarshalJSON</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Alias Comment <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json.Marshal(&amp;<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { CreatedAt <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"createdAt"`</span></span> *Alias }{ CreatedAt: c.CreatedAt.Format(time.RFC3339), Alias: (*Alias)(c), }) }</code> </pre> <br><p>  And on the client, this is done through date formatting using the following template: </p><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"yyyy-MM-dd'T'HH:mm:ssZ"</span></span></code> </pre> <br><p>  Another advantage of RFC3339 is that it acts as the default date format for Swagger.  And the date itself formatted in this way is quite readable for a person, especially in comparison with posix time. </p><br><p>  On the client (the example is for iOS, but on Android is similar), with the perfect match of the names of all the fields and class relationships, saving can be done by one generic method: </p><br><pre> <code class="hljs pgsql">func save(<span class="hljs-keyword"><span class="hljs-keyword">dictionary</span></span>: [String : AnyObject]) -&gt; Promise&lt;<span class="hljs-type"><span class="hljs-type">Void</span></span>&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise {fulfill, reject <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> let realm = Realm.instance //       ,       . //          . try! realm.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span> { realm.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(T.self, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">dictionary</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">update</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) } fulfill() } }</code> </pre> <br><p>  For arrays, the situation is similar, but saving will have to be driven already in the loop.  Often, inexperienced developers make a mistake and wrap the entire write block into a loop: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">array</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> try! realm.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span> { realm.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(T.self, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">update</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) } }</code> </pre> <br><p>  Which is just fundamentally wrong, because this is how you open a new transaction for each object, instead of saving everything together.  And if you have more notifications for updates, then everything becomes even more 'fun'.  It is more correct to do this as follows, bringing the transaction to a higher level: </p><br><pre> <code class="hljs pgsql">try! realm.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> realm.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(T.self, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">update</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) } }</code> </pre> <br><p>  As you can see, the intermediate layer responsible for the mapping has completely fallen off.  When the data is sufficiently prepared, they can immediately peel into the database without additional processing.  And the better the backend you have, the less this additional processing will be required.  Ideally, only the date convert to the object.  Everything else must be done in advance. </p><br><p>  By the way, moving away from the topic.  If you do not need to have a persistent database on the client, then this is not a reason to refuse Realm.  It allows you to work with yourself strictly in RAM, dropping its content on demand. </p><br><p>  ‚Üí Links for <a href="https://realm.io/docs/swift/latest/">iOS</a> and <a href="https://realm.io/docs/java/latest/">Android</a> . </p><br><p>  This approach allows you to use all the advantages of the reactive database and the above mapping. </p><br><p>  I also want to add for those who are especially attentive to trifles: there is no assertion that Go is the only right decision and a panacea for mobile development.  Everyone can solve this problem in their own way.  We chose this path. </p><br><h2 id="struktura-go-proekta">  Go project structure </h2><br><p>  Now there will be a lot of code for Go developers.  If you are a mobile developer, you can freely browse to the next section. </p><br><p>  Now we come to the most interesting, if you are a Go developer.  Suppose you are writing a backend for some typical application: you have a layer with the REST API, some business logic, model, database logic, utilities, migration scripts, and a config with resources.  You somehow have to tie all this together in your project by classes and daddies, observe the principles of <strong>SOLID</strong> and, preferably, do not go crazy with it. </p><br><p>  For now, we distribute abstractly, without plunging too deeply, but so that the overall structure is clear.  If it is interesting, then I will devote to this a full-fledged separate material.  Still, now we are talking about a mobile application in conjunction with Go. </p><br><p>  At once I will make a reservation that I do not pretend to the dogma of my statements, everyone is free to work in his project as he sees fit. </p><br><p>  Let's start with a screenshot of our structure: </p><br><p><img src="https://habrastorage.org/web/3c9/6b0/7b0/3c96b07b04bf4560be9cb00894120fc3.png"><br>  (What a cute hamster in Intellij Idea, isn't it? Every time I am moved) </p><br><p>  Non-expanded directories contain either Go files or resource files immediately.  Simply put, everything is disclosed so as to see the maximum immersion. </p><br><p>  In this article I will tell only about what is responsible for the business logic: api, services, work with the database and how it all depends on each other.  If you, dear public, show interest in this topic, then I'll sign for the rest, because there is too much information for one article. </p><br><p>  So, in order: </p><br><p>  <strong>Web</strong> </p><br><p>  Everything that is responsible for processing requests is stored in the web: binders, filters and controllers - and their entire spike occurs in <em>api.go.</em>  An example of such bonding: </p><br><pre> <code class="go hljs">regions := r.Group(<span class="hljs-string"><span class="hljs-string">"/regions"</span></span>) regions.GET(<span class="hljs-string"><span class="hljs-string">"/list"</span></span>, Cache.Gin, rc.List) regions.GET(<span class="hljs-string"><span class="hljs-string">"/list/active"</span></span>, Cache.Gin, regionController.ListActive) regions.GET(<span class="hljs-string"><span class="hljs-string">""</span></span>, binders.Coordinates, regionController.RegionByCoord)</code> </pre> <br><p>  In the same place there is an initialization of controllers and an injection of dependences.  In fact, the entire <em>api.go</em> file consists of the Run method, where a router is formed and started, and heaps of auxiliary methods for creating controllers with all dependencies and their groups. </p><br><p>  <strong>Web.Binders</strong> </p><br><p>  In the <em>binders</em> folder, <em>there</em> are binders that parse the parameters from the requests, convert them to a convenient format and put them into context for further work. </p><br><p>  An example of the method from this package.  It takes a parameter from the query, converts to bool, and puts it in context: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpenNow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *gin.Context)</span></span></span></span> { openNow, _ := strconv.ParseBool(c.Query(BindingOpenNow)) c.Set(BindingOpenNow, openNow) }</code> </pre> <br><p>  The easiest option without error handling.  Just for clarity. </p><br><p>  <strong>Web.Controllers</strong> </p><br><p>  Usually at the level of controllers, they make the most mistakes: they cram excess logic, forget about interfaces and isolation, and then generally slide into functional programming.  In general, Go controllers suffer from the same disease as in iOS: they are constantly being overloaded.  Therefore, we will immediately determine which tasks they should perform: </p><br><ul><li>  receive request parameters; </li><li>  call the appropriate service method; </li><li>  send a success or error response with formatting as necessary. <br>  Necessity is, for example, when the service logically returns the number of id of an object, there is nothing criminal in that the controller will wrap it in a map before sending it: <br><pre> <code class="go hljs">c.IndentedJSON(http.StatusCreated, gin.H { <span class="hljs-string"><span class="hljs-string">"identifier"</span></span>: m.ID })</code> </pre> </li></ul><br><p>  Take an example of a typical controller. </p><br><p>  The class, if you omit imports, begins with the controller interface.  Yes, yes, we keep the letter 'D' in the word SOLID, even if you always have only one implementation.  This makes testing much easier, giving you the opportunity to replace the controller with its mock: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Order <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { PlaceOrder(c *gin.Context) AroundWithPrices(c *gin.Context) }</code> </pre> <br><p>  Next we have the controller structure itself and its constructor, which takes dependencies, which we will call when creating the controller in <em>api.go</em> : </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,      type order struct { service services.Order } func NewOrder(service services.Order) Order { return &amp;order { service: service, } }</span></span></code> </pre> <br><p>  And finally, the method that processes the request.  Since we have successfully completed the binding layer, we can be sure that we have all the parameters guaranteed and we can get them with the help of MustGet, without fear of panic attacks: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(o order)</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PlaceOrder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *gin.Context)</span></span></span></span> { m := c.MustGet(BindingOrder).(*model.Order) o.service.PlaceOrder(m) c.IndentedJSON(http.StatusCreated, gin.H { <span class="hljs-string"><span class="hljs-string">"identifier"</span></span>: m.ID, }) }</code> </pre> <br><p>  With the optional parameters, the same story, but only at the Binder level, it is worth laying a certain zero value, which you will check in the controller, substituting the default value in the absence, or simply ignoring it. </p><br><p>  <strong>Services</strong> </p><br><p>  The situation with services is largely identical, they also begin with the interface, structure and constructor, followed by a set of methods.  I want to focus on one detail - this is the principle of working with the base. </p><br><p>  The service designer must accept the set of repositories with which it will work and the transaction factory: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewOrder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(repo repositories.Order, txFactory TransactionFactory)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Order</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;order { repo: repo, txFactory: txFactory } }</code> </pre> <br><p>  A transaction factory is simply a class that generates transactions; nothing complicated here: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TransactionFactory <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { BeginNewTransaction() Transaction }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Full factory code for gorm</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TransactionFactory <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { BeginNewTransaction() Transaction } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> transactionFactory <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { db *gorm.DB } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewTransactionFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(db *gorm.DB)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TransactionFactory</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;transactionFactory{db: db} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t transactionFactory)</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginNewTransaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Transaction</span></span></span></span> { tx := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(transaction) tx.db = t.db tx.Begin() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tx }</code> </pre> </div></div><br><p>  But on the transactions themselves stop worth.  Let's start with what it is all about.  A transaction is the same interface with an implementation that contains methods for starting a transaction, completing, rolling back, and accessing the engine implementation a level below: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Transaction <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Begin() Commit() Rollback() DataSource() <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Full transaction code for gorm</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Transaction <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Begin() Commit() Rollback() DataSource() <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> transaction <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Transaction db *gorm.DB tx *gorm.DB } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *transaction)</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Begin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { t.tx = t.db.Begin() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *transaction)</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Commit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { t.tx.Commit() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *transaction)</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rollback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { t.tx.Rollback() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *transaction)</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DataSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t.tx }</code> </pre> </div></div><br><p>  If everything should be clear with <a href="https://postgrespro.ru/docs/postgresql/9.6/sql-begin.html">begin</a> , <a href="https://postgrespro.ru/docs/postgresql/9.6/sql-commit.html">commit</a> , <a href="https://postgrespro.ru/docs/postgresql/9.6/sql-rollback.html">rollback</a> , then Datasource is just a crutch for accessing a low-level implementation, because working with any database in Go is designed so that the transaction is just a copy of the accessor to the database with its changed settings.  We will need it later when working in repositories. </p><br><p>  Actually, here is an example of working with transactions in the service method: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(o order)</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PlaceOrder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *model.Order)</span></span></span></span> { tx := o.txFactory.BeginNewTransaction() <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> tx.Commit() o.repo.Insert(tx, m) }</code> </pre> <br><p>  Started a transaction, accessed the database, commited, or rolled back as you like. </p><br><p>  Of course, the whole advantage of transactions is especially revealed in several operations, but even if you have only one, as in the example, it will not be worse. </p><br><div class="spoiler">  <b class="spoiler_title">To experts</b> <div class="spoiler_text"><p>  I know that there is no control over isolation levels. <br>  If you have found any other shoals - write in the comments. </p></div></div><br><p>  As an additional advice to juniors, I want to say that the transaction should be open as soon as possible.  Try to prepare all the data so that in the period between begin and commit you have the minimum amount of logic and computation. </p><br><p>  It happens that the transaction is opened and go to smoke, sending, for example, a request to Google.  And then they wonder why it was all stuffed up with the deadlock. </p><br><blockquote>  <em>Interesting fact</em> <br>  In many modern databases, <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B7%25D0%25B0%25D0%25B8%25D0%25BC%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BA%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0">deadlock</a> is determined as simply as possible: by timeout.  With a heavy load, scanning resources for blocking is expensive.  Therefore, the usual timeout is often used instead.  For example, in <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html">mysql</a> .  If you do not know this feature, then you can give yourself the most wonderful hours of fun debugging. </blockquote><br><p>  <strong>Repositories</strong> </p><br><p>  The same: interface, structure, constructor, which, as a rule, already without parameters. <br>  Just give an example of the Insert operation that we called in the service code: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(order)</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx Transaction, m *model.Order)</span></span></span></span> { db := tx.DataSource().(*gorm.DB) query := <span class="hljs-string"><span class="hljs-string">"insert into orders (shop_id) values (?) returning id"</span></span> db.Raw(query, m.Shop.ID).Scan(m) }</code> </pre> <br><p>  We received a low-level access modifier from the transaction, made a request, executed it.  Is done. </p><br><p>  All this should be enough to not ruin the architecture.  At least too fast.  If you have any questions or objections, then write in the comments, I will be glad to discuss. </p><br><h2 id="prilozhenie">  application </h2><br><p>  Okay, gophers are cute, but now how to work with this on the client? </p><br><p>  We start, as with Go, from our stack.  In general, we actively use the reagent almost everywhere, but now I‚Äôll tell you about a more benign version of the architecture so as not to injure the psyche so immediately. </p><br><h3 id="stek">  Stack </h3><br><p>  <strong>Network layer</strong> : </p><br><p>  <a href="https://github.com/Alamofire/Alamofire">Alamofire</a> for Swift projects and <a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a> for Objective-C. </p><br><p>  By the way, did you know that Alamofire is AFNetworking?  <em>AF</em> prefix means Alamofire, as can be seen by looking at the AFNetworking license: <br><img src="https://habrastorage.org/web/bad/a03/31d/bada0331df76481b911dc9454842dcb5.png"></p><br><p>  <strong>Closures</strong> : </p><br><p>    callback-          /     .               ,       .       ,   . </p><br><p>      .  iOS: <a href="https://github.com/mxcl/PromiseKit">PromiseKit</a> .   ‚Äî   ,   ,   ,        success/failure ,     always,  ,   / .    ,      . </p><br><p>   ,    ‚Äî    .   flow     ,    .  , ,      ,   : </p><br><pre> <code class="hljs pgsql">func details(id: <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; Promise&lt;<span class="hljs-type"><span class="hljs-type">Void</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getDetails(id) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">execute</span></span>: parse) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">execute</span></span>: save) }</code> </pre> <br><p>     getDetails,      : </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDetails</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Promise</span></span>&lt;<span class="hljs-type"><span class="hljs-type">DataResponse</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Any</span></span>&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">Promise</span></span> { fulfill, reject <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">Alamofire</span></span>.request(<span class="hljs-type"><span class="hljs-type">NetworkRouter</span></span>.drugDetails(id: id)).responseJSON { fulfill($<span class="hljs-number"><span class="hljs-number">0</span></span>) } } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><p>    ,    .   ,     .  ,   .     ,     . </p><br><pre> <code class="hljs pgsql">func parseAsDictionary(response: DataResponse&lt;<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>&gt;) -&gt; Promise&lt;[String:AnyObject]&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise {fulfill, reject <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> switch response.result { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .success(let <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): let <span class="hljs-type"><span class="hljs-type">json</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! [String : AnyObject] guard response.response!.statusCode &lt; <span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { let error = Error(<span class="hljs-keyword"><span class="hljs-keyword">dictionary</span></span>: <span class="hljs-type"><span class="hljs-type">json</span></span>) reject(error) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } fulfill(<span class="hljs-type"><span class="hljs-type">json</span></span>) break <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .failure(let nserror): let error = Error(error: nserror <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> NSError) reject(error) break } } } //     ,   func save(items: [[String : AnyObject]]) -&gt; Promise&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise {fulfill, reject <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> let realm = Realm.instance try! realm.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span> { items.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span> { item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> //       generic realm.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(Item.self, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: item, <span class="hljs-keyword"><span class="hljs-keyword">update</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) } } fulfill(items.count) } }</code> </pre> </div></div><br><p>    ,    MVC,   : </p><br><pre> <code class="hljs objectivec">_ = service.details().then {[<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] array -&gt; Void <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">// Success. Do w/e you like. }</span></span></code> </pre> <br><p>  <strong>Database</strong> </p><br><p>      ,      ORM  Go-side,    ,   <a href="https://realm.io/docs/swift/latest/"></a>            .      - ,      .   ,       datasource    .             ,   . </p><br><p>      <a href="https://realm.io/docs/swift/latest/"></a>  fine-grained notifications  ,    . </p><br><div class="spoiler"> <b class="spoiler_title"> extra-</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ViewController: UITableViewController { var notificationToken: NotificationToken? = nil override func viewDidLoad() { super.viewDidLoad() let realm = try! Realm() let results = realm.objects(Person.self).<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>("age &gt; 5") // Observe Results Notifications notificationToken = results.addNotificationBlock { [weak self] (changes: RealmCollectionChange) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> guard let tableView = self?.tableView <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } switch changes { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .initial: // Results are now populated <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> can be accessed <span class="hljs-keyword"><span class="hljs-keyword">without</span></span> blocking the UI tableView.reloadData() break <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>(_, let deletions, let insertions, let modifications): // Query results have changed, so apply them <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the UITableView tableView.beginUpdates() tableView.insertRows(at: insertions.map({ IndexPath(<span class="hljs-keyword"><span class="hljs-keyword">row</span></span>: <span class="hljs-meta"><span class="hljs-meta">$0</span></span>, section: <span class="hljs-number"><span class="hljs-number">0</span></span>) }), <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>: .automatic) tableView.deleteRows(at: deletions.map({ IndexPath(<span class="hljs-keyword"><span class="hljs-keyword">row</span></span>: <span class="hljs-meta"><span class="hljs-meta">$0</span></span>, section: <span class="hljs-number"><span class="hljs-number">0</span></span>)}), <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>: .automatic) tableView.reloadRows(at: modifications.map({ IndexPath(<span class="hljs-keyword"><span class="hljs-keyword">row</span></span>: <span class="hljs-meta"><span class="hljs-meta">$0</span></span>, section: <span class="hljs-number"><span class="hljs-number">0</span></span>) }), <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>: .automatic) tableView.endUpdates() break <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .error(let error): // An error occurred <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> opening the Realm file <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> the background worker thread fatalError("\(error)") break } } } deinit { notificationToken?.stop() } }</code> </pre> </div></div><br><h3 id="vzaimodeystvie-vnutri-proekta">    </h3><br><p>    ,               <em>ApiManager.swift</em> .     ,       ,   ‚Äî  extension  ApiManager,       . <br>         singleton,    .     ,    ,       . </p><br><p>     SOA (service oriented architecture).   <a href="https://www.youtube.com/watch%3Fv%3DEman1j06YsU">  Rambler</a> ,    ,        ,           . </p><br><p>      .   ‚Äî           .      ,  .      ,            viewDidLoad. ,   ,    .  ,             ,      ,   ,   ,   . </p><br><p>       : </p><br><p><img src="https://habrastorage.org/web/47e/1d8/459/47e1d8459595468caad42dd265d4bbc3.png"></p><br><p>        ,        . ,     200-300 .      ,        ,   . </p><br><p>  ,        :   ,       . ,   . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p> .         Realm-  mobile-side           ,      .   ,  -,    .   ,       iOS  Android, ‚Äî       ! </p><br><p>     ,    .        ,        ,  -         . </p><br><p>      .          . </p><br><p>   ,    .  ,   ,     ,     ,   ,  ,        ?    MVP  MVVM  ,    . </p><br><p>  ,     ,        : ‚Äú,    ?‚Äù   : ‚Äú,   .‚Äù <br>     . </p><br><p>  , ,  .   ,     ,   . </p><br><p> <strong>PS</strong>  .              ?    ,   ,    . ,  ,  ,   ,      . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/331456/">https://habr.com/ru/post/331456/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331446/index.html">Abnormal GraphQL in Electron or as I wrote a desktop client for Tinder</a></li>
<li><a href="../331448/index.html">‚ÄúI can't just walk with the flag‚Äú Postgres - our everything ‚Äù. We need to prove with our hands that this works ‚Äù- Alexey Lustin</a></li>
<li><a href="../331450/index.html">Post-mortem Age of Empires</a></li>
<li><a href="../331452/index.html">Make QR Codes Great Again or Apple‚Äôs Camera Revolution</a></li>
<li><a href="../331454/index.html">Using music instead of a language course in learning a foreign language</a></li>
<li><a href="../331458/index.html">The history of the development and life of one small game. Release</a></li>
<li><a href="../331460/index.html">PostgreSQL features for those who migrated from MySQL</a></li>
<li><a href="../331462/index.html">Web sockets for php. Choosing a web server server</a></li>
<li><a href="../331466/index.html">Lessons from three million downloads on the AppStore</a></li>
<li><a href="../331468/index.html">Use template + constexpr to create mask masks for microcontroller peripherals at compile time (C ++ 14)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>