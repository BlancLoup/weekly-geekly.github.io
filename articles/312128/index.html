<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tender friendship of agents and exceptions in SObjectizer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sooner or later something goes wrong in the program. The file did not open, the working thread was not created, the memory did not stand out ... And w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tender friendship of agents and exceptions in SObjectizer</h1><div class="post__text post__text-html js-mediator-article">  Sooner or later something goes wrong in the program.  The file did not open, the working thread was not created, the memory did not stand out ... And with this you need to somehow live.  In a small single-threaded application it is quite simple: you can interrupt all the work and restart.  This is one of the factors due to which Erlang has earned itself a well-deserved popularity, because the ideology of <a href="https://en.wikipedia.org/wiki/Fail-fast">fail fast</a> is one of the cornerstones of Erlang with its lightweight processes.  If the application is large, complex, and multi-threaded, then it is not reasonable to restart the entire application if only one of its threads has encountered problems.  Even worse in the situation with the implementation of the Model Actors, in which hundreds of thousands of actors can work on dozens of working threads.  The problem of one actor is unlikely to affect all other actors. <br><br>  In this article, we will explain how we approached error handling in our <a href="https://habrahabr.ru/post/304386/">SObjectizer framework</a> . <br><br><h1>  Exceptions - yes, return codes - no! </h1><br>  When SObjectizer-4 appeared in 2002, we made a big mistake - we preferred to use return codes for exceptions.  And all the subsequent development experience on SObjectizer-4 again and again convinced one simple truth: if the error can be predicted by the developer, then it will be ignored by him.  Therefore, when creating SObjectizer-5, we decided to use exceptions to report errors. <br><a name="habracut"></a><br>  It was the right choice.  In the ‚Äúexceptions against return codes‚Äù disputes, the spears still break, but our experience shows that development only benefits if you cannot accidentally miss, for example, an agent subscription error or agent cooperation registration. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, SObjectizer-5 throws an exception if it cannot perform a particular operation.  Most often, these operations are performed by agents already registered in the SObjectizer.  What should an agent do if he faces an exception? <br><br><h1>  A normal agent should not let exceptions out! </h1><br>  This is the main rule that exists for exclusion agents.  If an agent receives an exception when processing its event (it does not matter if a SObjectizer exception or someone else threw an exception), then the agent should not throw this exception out. <br>  The explanation is simple.  An agent in a SObjectizer does not own its own working context.  Roughly speaking, the agent does not own the working thread on which he works.  The working context is provided by the dispatcher to which the agent is attached, during the processing of the next event, and then may be provided to another agent.  When an agent releases an exception to the outside, the exception will fall to the dispatcher, which highlighted the working context.  If the application does not want the dispatcher to decide whether to kill the application or allow it to continue, then the agents of this application should attend to the exception handling. <br><br>  Ideally, this means that agent events must be noexcept methods.  But this is an ideal case.  And the noexcept mechanism in C ++ is a good thing, but it only guarantees that an exception from the noexcept method will not arrive.  At the same time, it can fly out, but the compiler doesn‚Äôt beat on hands if non-noexcept methods are called in noexcept methods.  And if the exception crashes, it leads straight to std :: terminate ().  That does not always suit us.  How to be in that non-ideal world in which we live? <br><br><h1>  SObjectizer can tell you how to react to an exception that has escaped from an agent. </h1><br>  Since shit does happen from time to time, even when we undertake to provide a <a href="http://www.stroustrup.com/except.pdf">no exception guarantee</a> for agents, we can make a mistake and the exception will still go outside.  He will be caught by the dispatcher and will decide what to do next. <br><br>  To do this, the dispatcher will call the so_exception_reaction () virtual method on the problem agent.  This method should return one of the following values: <br><br><ul><li>  so_5 :: abort_on_exception.  This will cause std :: abort () and terminate the entire application; <br><br></li><li>  so_5 :: shutdown_sobjectizer_on_exception.  This value means that the agent provides basic exception guarantee (i.e., the absence of resource leaks and / or damage to something), but there is no sense to continue further.  Therefore, the agent is transferred to a special state in which the agent cannot handle any events, and the SObjectizer Environment operation completes normally, without calling std :: abort ().  In this case, all registered cooperations are properly deregistered, which allows other agents to complete their work normally and clean up resources.  Note that in an application several SObjectizer Environment can work simultaneously.  In the case of shutdown_sobjectizer_on_exception, only the SObjectizer Environment in which the exception was caught was terminated; <br><br></li><li>  so_5 :: deregister_coop_on_exception.  This value means that the agent provides basic exception guarantee and the application can continue its work without this agent and its cooperation.  Therefore, the agent is transferred to a special state, and his cooperation is deregistered in the usual way (which allows other cooperative agents to complete their work normally); <br><br></li><li>  so_5 :: ignore_exception.  This value means that the agent provides a strong exception guarantee (i.e. there are no resource leaks and / or damage to something + the agent remains in the correct state) and can continue its work.  Therefore, the dispatcher simply ignores the exception, as if it did not exist. </li></ul><br>  The presence of such a variant as ignore_exception may seem strange after it was stated that normal agents should not throw exceptions outside.  However, in practice, having such a value is convenient for agents with very simple event handlers.  For example, an agent receives a message of type M1 and converts it into messages of type M2.  During the conversion, an exception may occur, but it has little effect: the state of the agent is not violated, the message M2 is lost, well, so the messages may be lost for one reason or another.  In such cases, it is easier to allow exceptions to fly out of simple agents so that the dispatcher ignores them, rather than include a try-catch block in each event handler. <br><br>  Thus, the programmer can decide himself which option is best for his agent, override the so_exception_reaction () method and thereby inform the SObjectizer about how to be after catching the exception: <br><br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">so_5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,    M1  mbox- src    //   M2  mbox- dest. ,     // , . class my_simple_message_translator final : public agent_t { public : my_simple_message_translator( context_t ctx, mbox_t src, mbox_t dest ) : agent_t( ctx ) { so_subscribe( src ).event( [dest]( const M1 &amp; msg ){ send&lt; M2 &gt;( dest, ... );} ); } //  SO-5,     . virtual exception_reaction_t so_exception_reaction() const override { return ignore_exception; } };</span></span></code> </pre> <br><h1>  Reaction to exceptions at the level of cooperation </h1><br>  The standard implementation of agent_t :: so_exception_reaction () pulls the exception_reaction () method of the cooperation, which includes the agent.  Those.  By default, the agent inherits the exception reaction from its cooperation.  And this reaction can be set during the registration of cooperation. <br><br>  For example: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//    ,     //        . env.introduce_coop( []( coop_t &amp; coop ) { coop.set_exception_reaction( deregister_coop_on_exception ); coop.make_agent&lt; some_agent &gt;(...); ... } );</span></span></code> </pre> <br>  Thus, in SObjectizer, the reaction to an exception can be set at the agent level, and if this has not been done, then the reaction to the exception specified for the agent's cooperation is used. <br><br>  But what happens if the set_exception_reaction () method is not called when creating a cooperation (and in most cases it is not called)? <br><br>  If the programmer did not explicitly call coop_t :: set_exception_reaction (), then coop_t :: exception_reaction () will return a special value - so_5 :: inherit_exception_reaction.  This value indicates that the cooperation inherits the reaction to expulsion from its parent cooperation.  If this parent cooperation exists, the SObjectizer will call exception_reaction () for it.  If the parent cooperation returns the value so_5 :: inherit_exception_reaction, then the SObjectizer will cause exception_reaction () for the parent of the parent cooperation, etc. <br><br>  In the end, it may turn out that there is no regular parental cooperation.  In this case, the SObjectizer will call exception_reaction () for the entire environment_t.  And already environment_t :: exception_reaction () will return the value so_5 :: abort_on_exception.  Which will lead to the collapse of the entire application through a call to std :: abort (). <br><br><img src="https://habrastorage.org/files/4dd/502/801/4dd50280113b43018e76b07530f4ef78.png"><br><br>  However, the programmer can specify an exception response for the entire SObjectizer Environment.  This is done through setting the properties of the SObjectizer at startup: <br><br><pre> <code class="hljs cpp">so_5::launch( []( <span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) {...}, []( <span class="hljs-keyword"><span class="hljs-keyword">environment_params_t</span></span> &amp; params ) { params.exception_reaction( shutdown_sobjectizer_on_exception ); ... } );</code> </pre> <br><h1>  Small intermediate summary </h1><br>  So, if the agent throws an exception, the SObjectizer intercepts it and asks the agent what to do with the exception through the call agent_t :: so_exception_reaction ().  If the programmer did not redefine so_exception_reaction (), then the response to the exception is determined by the cooperation the agent belongs to. <br><br>  Usually, the co-operation tells SObjectizer that it inherits the reaction to the exception from its parent.  And SObjectizer will ask parent cooperation.  Then the parent of the parental cooperation, etc.  And when the parents run out, SObjectizer will ask the environment_t for the exception reaction, within which the problem agent works.  By default, environment_t will say that the application needs to be interrupted via a call to std :: abort ().  Thus, the programmer can influence the occurrence of exceptions at different levels: <br><br><ul><li>  in the agent itself, catching all exceptions inside the agent's events or overriding so_exception_reaction (); </li><li>  in agent cooperation or parental cooperation; </li><li>  in the SObjectizer Environment, within which agents and cooperatives operate. </li></ul><br><h1>  How to react to the deregistration of cooperation? </h1><br>  As shown above, the SObjectizer may react to exceptions issued from the agent in different ways.  For example, it can deregister only problematic cooperation.  But what is the point of this reaction?  After all, the cooperation solved some applied task in the application, and if it did not solve it, then it would not exist.  And here this cooperation suddenly disappears ... How to find out about it and how to react to it? <br><br>  SObjectizer allows you to receive a notification that some kind of cooperation has been deregistered.  In some ways, this mechanism resembles the ability to monitor processes in Erlang: for example, you can call erlang: monitor (process, Pid) and, if the Pid process is terminated, then the message {'DOWN', ...} comes. <br><br>  In SObjectizer, it is possible to ‚Äúhang‚Äù the notifier on a deregistration event.  The notifier is a functor that SObjectizer will call automatically when it completes the deregistration of a cooperation.  In this functor, SObjectizer will pass both the name of the deregistered cooperation and the reason for its deregistration.  This functor can do what the application needs.  For example, you can send a message to a interested agent about the disappearance of cooperation.  And you can simply re-register the cooperation: <br><br><pre> <code class="hljs markdown">//       //     -  . #include <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">iostream</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> #include <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">so_5</span></span></span></span><span class="xml"><span class="hljs-tag">/</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">all.hpp</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> void start<span class="hljs-emphasis"><span class="hljs-emphasis">_coop( so_</span></span>5::environment<span class="hljs-emphasis"><span class="hljs-emphasis">_t &amp; env ) { env.introduce_</span></span>coop( [<span class="hljs-string"><span class="hljs-string">&amp;</span></span>](<span class="hljs-link"><span class="hljs-link"> so_5::coop_t &amp; coop </span></span>) { struct raise<span class="hljs-emphasis"><span class="hljs-emphasis">_exception : public so_</span></span>5::signal<span class="hljs-emphasis"><span class="hljs-emphasis">_t {}; //     . //        . auto agent = coop.define_</span></span>agent(); agent.on<span class="hljs-emphasis"><span class="hljs-emphasis">_start( [agent] { so_</span></span>5::send<span class="hljs-emphasis"><span class="hljs-emphasis">_delayed&lt; raise_</span></span>exception &gt;( agent, std::chrono::seconds(1) ); } ) .event<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">raise_exception</span></span></span></span><span class="xml"><span class="hljs-tag"> &gt;</span></span></span></span>( agent, [<span class="hljs-string"></span><span class="hljs-string"></span>] { throw std::runtime<span class="hljs-emphasis"><span class="hljs-emphasis">_error( "Just a test exception" ); } ); //  SObjectizer-     . coop.set_</span></span>exception<span class="hljs-emphasis"><span class="hljs-emphasis">_reaction( so_</span></span>5::deregister<span class="hljs-emphasis"><span class="hljs-emphasis">_coop_</span></span>on<span class="hljs-emphasis"><span class="hljs-emphasis">_exception ); //  ,      // ,   ,     . coop.add_</span></span>dereg<span class="hljs-emphasis"><span class="hljs-emphasis">_notificator( []( so_</span></span>5::environment<span class="hljs-emphasis"><span class="hljs-emphasis">_t &amp; env, const std::string &amp; coop_</span></span>name, const so<span class="hljs-emphasis"><span class="hljs-emphasis">_5::coop_</span></span>dereg<span class="hljs-emphasis"><span class="hljs-emphasis">_reason_</span></span>t &amp; why ) { std::cout <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Deregistered:</span></span></span></span><span class="xml"><span class="hljs-tag"> " &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">coop_name</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; ", </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">reason:</span></span></span></span><span class="xml"><span class="hljs-tag"> " &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">why.reason</span></span></span></span><span class="xml"><span class="hljs-tag">() &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::endl</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">if</span></span></span></span><span class="xml"><span class="hljs-tag">( </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">so_5::dereg_reason::unhandled_exception</span></span></span></span><span class="xml"><span class="hljs-tag"> == </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">why.reason()</span></span></span></span><span class="xml"><span class="hljs-tag"> ) </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">start_coop</span></span></span></span><span class="xml"><span class="hljs-tag">( </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">env</span></span></span></span><span class="xml"><span class="hljs-tag"> ); } ); } ); } </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">main</span></span></span></span><span class="xml"><span class="hljs-tag">() { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">so_5::launch</span></span></span></span><span class="xml"><span class="hljs-tag">( []( </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">so_5::environment_t</span></span></span></span><span class="xml"><span class="hljs-tag"> &amp; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">env</span></span></span></span><span class="xml"><span class="hljs-tag"> ) { //     </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">start_coop</span></span></span></span><span class="xml"><span class="hljs-tag">( </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">env</span></span></span></span><span class="xml"><span class="hljs-tag"> ); //     </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::this_thread::sleep_for</span></span></span></span><span class="xml"><span class="hljs-tag">( </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::chrono::seconds</span></span></span></span><span class="xml"><span class="hljs-tag">( </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">5</span></span></span></span><span class="xml"><span class="hljs-tag"> ) ); //  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">env.stop</span></span></span></span><span class="xml"><span class="hljs-tag">(); } ); }</span></span></span></span></code> </pre> <br>  There is no ready <a href="http://erlang.org/doc/design_principles/sup_princ.html">-made supervisor system, as in Erlang</a> , in SObjectizer.  Somehow it was possible to do without it.  But, if it is needed for an application, then something similar can be collected on the basis of notifiers. <br><br><h1>  A little philosophical remark finally </h1><br>  C ++ is an unsafe language.  And writing code that provides at least basic guarantees for the security of exceptions requires some effort from the developer.  Therefore, when implementing actors in C ++, you need to be wary of using the principle of fail fast.  This is good in Erlang ‚Äî if they discovered some problem in the process, they simply killed the process, after which Erlang VM cleaned everything up after it, and the corresponding supervisor executed the launch of the new process instead of the failed one. <br><br>  In C ++, all agents live in the same process.  Therefore, if any of the agents is not implemented with sufficient quality, allows for the leakage of resources and / or damage to something in the process memory, then its deregistration and subsequent creation of a new agent instead of deregistered may be not a solution, but an even bigger problem. <br><br>  It is because of this that in SObjectizer, by default, the work of the entire application is interrupted if an agent throws an exception.  If the programmer is not satisfied and he is going to change the reaction to some other (especially the ignore_exception reaction), then you should think twice and carefully check the agent code to ensure that exception safefy. <br><br><h1>  Conclusion </h1><br>  Perhaps with this article we close the story about the main distinguishing features of SObjectizer.  We are going to release the following articles on SObjectizer when something new will appear.  Well, or if they come across interesting questions, it is difficult to give an exhaustive answer to which in the comments. <br><br>  At the same time, taking this opportunity, we invite you to attend the <a href="http://conference.corehard.by/">conference Corehard C ++ Autumn 2016, which will be held on October 22 in Minsk</a> .  And on which there will be a report on the Model of Actors as applied to C ++.  Including about SObjectizer. </div><p>Source: <a href="https://habr.com/ru/post/312128/">https://habr.com/ru/post/312128/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../312118/index.html">‚ÄúFaster, higher, stronger‚Äù: New data-cent technologies</a></li>
<li><a href="../312120/index.html">Customer focus as the basis of business: Experience IaaS-provider "1cloud"</a></li>
<li><a href="../312122/index.html">The digest of interesting materials for the mobile # 174 developer (October 3-9)</a></li>
<li><a href="../312124/index.html">The benefits of using software-defined storage in a corporate environment</a></li>
<li><a href="../312126/index.html">How to optimize the memorization of foreign words</a></li>
<li><a href="../312130/index.html">Success on autopilot. How to find a hobby, earn a lot of money on it and buy happiness</a></li>
<li><a href="../312132/index.html">"Everywhere at Home": What technologies does Airbnb use?</a></li>
<li><a href="../312134/index.html">Implementing Business Logic in MySQL</a></li>
<li><a href="../312136/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ231 (October 3 - 9, 2016)</a></li>
<li><a href="../312140/index.html">Cybersecurity games in Rio: how it was</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>