<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Wireless data transmission, ISM range</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, Habr√© has described many examples of the implementation of weather thermometers, information collection systems, control in smart home syste...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Wireless data transmission, ISM range</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/f45/8ba/57f/f458ba57fe24688ac36a1f53c69634b4.jpg"><br>  Recently, Habr√© has described many examples of the implementation of weather thermometers, information collection systems, control in smart home systems - both wired, transmitting information via Ethernet, and wireless, via WiFi ‚Ñ¢.  In each case - there is a specificity, there are pros and cons.  And in this article we will discuss another way to transfer data - transmission in the ISM-band at 868 MHz. <br><a name="habracut"></a><br>  In the Russian Federation, the unlicensed range of frequencies that can be used without obtaining the permission of the SCRF, subject to the requirements for bandwidth, radiated power and purpose of the finished product, include: <br><br><ol><li>  433.075‚Äî434.750 MHz </li><li>  868.0‚Äî868.2 MHz </li><li>  868.7‚Äî869.2 MHz </li><li>  2400.0‚Äî2483.5 MHz </li></ol><br>  In short, for 434 MHz, the transmitter power should be no more than 10 mW, for 868.0‚Äì868.2 MHz - up to 10 mW, for 868.7‚Äî869.2 MHz - up to 25 mW, for 2.4 GHz - no more than 100 mW.  For more information about restrictions, see ‚Äú <a href="http://minsvyaz.ru/ru/doc/index.php%3Fid_4%3D62">Decree of the Government of the Russian Federation of October 12, 2004 N 539‚Äú On the procedure for registration of radio-electronic means and high-frequency devices</a> ‚Äù. <br><br>  The main difference between these ISM bands is determined by the frequency of the radiation and, as a consequence, the properties of radio waves.  With regard to the task - data collection, wireless control and monitoring systems, the most optimal solution is to use the 868 MHz band.  Compared to the 2.4 GHz microwave range, the longer wavelengths of 868 MHz have a lower attenuation intensity, a correspondingly higher permeability through the obstacles and the signal transmission distance is much higher.  For example, a brick wall 89 mm thick absorbs about 3.5 dB of wave power at 868 MHz and 6 dB at 2.4 GHz.  Also in comparison with the range of 433 MHz, 868 MHz has a lower frequency load, which contributes to more reliable operation of the radio channel. <br><table><tbody><tr><td colspan="3">  <b>Maximum thickness of an obstacle through which a radio signal can pass</b> </td></tr><tr><td>  <b>Frequencies</b> </td><td width="250">  <b>Brick wall, m</b> </td><td width="250">  <b>Concrete, m</b> </td></tr><tr><td>  <b>434 MHz</b> </td><td>  4.3 </td><td>  0.47 </td></tr><tr><td>  <b>868 MHz</b> </td><td>  2.18 </td><td>  0.24 </td></tr><tr><td>  <b>2.4 GHz</b> </td><td>  0.78 </td><td>  0.09 </td></tr></tbody></table><br>  The next important feature is the data transfer rate.  Modern ISM transceivers have quite high rates, on average, this value is from 256 to 1000 kbit / s, which is quite enough for this kind of task. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Thus, we can conclude that in the aggregate of such parameters as - high permeability, less busy frequency range, as well as a fairly high data transfer rate, 868 MHz radio waves is the most optimal solution for this kind of problem compared to the rest of the ISM range. <br><br>  For an example of data transmission in the ISM-range, we will assemble a reading device from remote sensors.  Let's say it will be temperature and humidity.  Those.  we need to collect 2 spaced devices - the first will play the role of the head and display summary information, and the second - the sensor will periodically take measurements and send data to the head device.  Moreover, both devices will be placed out of line of sight, in two different buildings. <br><br>  As a platform that allows you to organize a radio channel 868 MHz, we will use the <a href="http://jt5.ru/arduino/colibri/">Kolibri</a> shawl (Arduino Mini + RF).  It uses an EZRadioPRO Si4431 transceiver with a programmable output power from -8 to + 13dbM, which corresponds to the standards of GKRCH (20 mW).  3dbM setup step.  Receiver sensitivity ‚Äì121 dBm.  The power consumption is 18.5 mA for reception and 30 mA for transmission.  Permissible board power from 5V or 3.3V.  The data transfer rate is 0.123 - 256 kbps.  In addition, the board is software compatible with the Arduino IDE, which makes it easy to program.  <a href="">Schematic diagram</a> . <br><br>  To measure humidity and temperature, we use a digital sensor <a href="http://www.sensirion.com/en/products/humidity-temperature/humidity-sensor-sht10/">SHT10</a> .  It is quite compact and requires minimal strapping.  The accuracy of measuring temperature readings is ¬± 0.5, and humidity 4.5%.  <a href="http://www.sensirion.com/fileadmin/user_upload/customers/sensirion/Dokumente/Humidity/Sensirion_Humidity_SHT1x_Datasheet_V5.pdf">Datashit</a> . <br><br>  To display information on the head unit, we take a graphic LCD display with a resolution of 128 * 64 pixels ( <a href="http://www.winstar.com.tw/products_detail_ov.php%3Flang%3Dru%26ProID%3D48">WG12864A-TGH-VNW</a> ).  The backlight is white, the dot color is gray.  And, in order not to occupy all the pins of the microcontroller under the display, we will connect it via SPI using the <a href="http://www.microchip.com/wwwproducts/Devices.aspx%3FdDocName%3Den023500">MCP23S17</a> microcircuit.  But more on that later. <br><br><table><tbody><tr><td colspan="2">  <b>Key system components</b> </td></tr><tr><td>  <b>For head unit</b> </td><td>  <b>For remote sensor</b> </td></tr><tr><td colspan="2">  <b>"Iron"</b> </td></tr><tr><td><ul><li>  Hummingbirds - 1 pc. </li><li>  LCD display - 1 pc. </li><li>  Development board - 1 pc. </li><li>  Microcircuit MCP23S17 - 1 pc. </li><li>  Power supply 5V - 1 pc. </li><li>  Whip antenna - 1 pc. </li></ul></td><td><ul><li>  Hummingbirds - 1 pc. </li><li>  SHT10 - 1 pc. </li><li>  Development board - 1 pc. </li><li>  Battery compartment for 2AA - 1 pc. </li><li>  AA batteries at 1.5V - 2 pcs. </li><li>  Whip antenna - 1 pc. </li></ul></td></tr><tr><td colspan="2">  <b>Soft</b> </td></tr><tr><td><ul><li>  <a href="https://github.com/jt5/EZRadioPRO">EZRadioPRO</a> </li><li>  <a href="">I2C_graphical_LCD_display</a> </li></ul></td><td><ul><li>  <a href="https://github.com/jt5/EZRadioPRO">EZRadioPRO</a> </li><li>  <a href="https://github.com/practicalarduino/SHT1x">SHT1x</a> </li></ul></td></tr></tbody></table><br><h1>  Head device </h1><br><h2>  1. Build </h2><br>  To begin with we will collect the scheme of the head device <br>  The head unit will consist of a Hummingbird board, which will receive and display data on the LCD.  And as mentioned above, we will work with the LCD display through the SPI interface, using the MCP23S17 chip. <br><img src="https://habrastorage.org/storage2/5fd/7d4/d3a/5fd7d4d3a49f1f30df4918391806e461.gif"><br>  This scheme will collect on the breadboard.  The terminals marked with blue lines are connected to the Hummingbird board - these are digital contacts 10, 11, 12, 13 (SPI).  On the prototyping board and on the Hummingbird it remains to supply 5V power.  Power supply of the device is assumed either from the power supply, where the ‚Äúhonest‚Äù is 5V, or through a linear stabilizer. <br><img src="https://habrastorage.org/storage2/c69/b7d/1b5/c69b7d1b5289c13f63e86e3a04c46427.jpg"><br><br><h2>  2. Firmware </h2><br>  To work with the Kolibri board radio module, we will use the ready-made EZRadioPRO library under the Arduino IDE.  It needs to be downloaded and installed inside the IDE.  We also need the I2C_graphical_LCD_display library for working with the LCD display.  It also needs to be downloaded and installed. <br><br><div class="spoiler">  <b class="spoiler_title">We start the Arduino IDE and create a sketch like this based on an example.</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#include &lt;SI4431.h&gt; #include "SimRF.h" #include &lt;Wire.h&gt; #include &lt;SPI.h&gt; #include &lt;I2C_graphical_LCD_display.h&gt; I2C_graphical_LCD_display lcd; //    (0  ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LOCAL_ADDR (0) //  1:     #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RF_FUNC01 (1) //  2:    #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RF_FUNC02 (2) //    unsigned char RFTX_buffer[32]; //    unsigned char RFRX_buffer[32]; char i2a_buf[6]; /*   4- 16-    */ typedef struct { u16 Register0; u16 Register1; u16 Register2; u16 Register3; } tRemoteSensor; tRemoteSensor RemoteSensorStatus[2]; //      1  2 tRemoteSensor RemoteSensorCmd[2]; //        1  2 void print_P (const char* s) { char c; while ((c = pgm_read_byte(s++)) != 0) Serial.print(c); } u8 get_xor(u8* Src, u8 len) { u8 xoracc = 0; while (len--) { xoracc ^= *Src++; } return xoracc; } //   02       RemoteSensorCmd[]; void RFTX_FUNC02(u8 addr) { RemoteSensorCmd[addr -1].Register0 = RemoteSensorStatus[addr -1].Register0; RemoteSensorCmd[addr -1].Register1 = RemoteSensorStatus[addr -1].Register1; RemoteSensorCmd[addr -1].Register2 = RemoteSensorStatus[addr -1].Register2; RemoteSensorCmd[addr -1].Register3 = RemoteSensorStatus[addr -1].Register3; RFTX_buffer[0] = addr; //  RFTX_buffer[1] = LOCAL_ADDR; //  RFTX_buffer[2] = RF_FUNC02; //  02 u16* p16 = (u16*) &amp;RFTX_buffer[3]; *p16++ = RemoteSensorCmd[addr -1].Register0; *p16++ = RemoteSensorCmd[addr -1].Register1; *p16++ = RemoteSensorCmd[addr -1].Register2; *p16++ = RemoteSensorCmd[addr -1].Register3; //      RFTX_buffer[11] = get_xor ((u8*)RFTX_buffer, 11); //     /*print_P(PSTR("\r\nData to TX: ")); for (u8 i = 0; i&lt; 12; i++) { Serial.print((u8)RFTX_buffer[i], HEX); print_P(PSTR(",")); }*/ SI4431.TXData((u8*) RFTX_buffer, 12); } void RFRX_FUNC01(u8 SlaveAddr, u16* Payload) { RemoteSensorStatus [SlaveAddr - 1].Register0 = *Payload++; RemoteSensorStatus [SlaveAddr - 1].Register1 = *Payload++; RemoteSensorStatus [SlaveAddr - 1].Register2 = *Payload++; RemoteSensorStatus [SlaveAddr - 1].Register3 = *Payload++; } /**     * : * addr -     * len -    * pData -       SRAM * : * (0..127)    * -1  */ void RFRX_MASTER_PROCESS(u8 len) { s8 funccode; u8 SlaveAddr; //      </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (len &lt; 3) return; //print_P(PSTR("\r\n Dump:")); /*for (u8 i = 0; i&lt; len; i++) { Serial.print(RFRX_buffer[i], HEX); print_P(PSTR(",")); i2a((u16)RFRX_buffer[i], i2a_buf); lcd.string(i2a_buf); lcd.string("-"); } */ SlaveAddr = RFRX_buffer[1]; //    </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((RFRX_buffer[0] == LOCAL_ADDR)&amp;&amp;(SlaveAddr != LOCAL_ADDR)) { //    MASTER    SLAVE ( &gt;= 1) //  XOR // print_P(PSTR("\r\n Correct Addr!")); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (get_xor((u8*)RFRX_buffer, len - 1) == (u8) RFRX_buffer[len-1]) { funccode = RFRX_buffer[2]; //   switch (funccode) { case RF_FUNC01: { //     //print_P(PSTR("\r\nData from sensor: ")); //Serial.print(SlaveAddr, HEX); tRemoteSensor* pSensorData = (tRemoteSensor*)&amp;RFRX_buffer[3]; //        //     s16 Temperature_x100 = (s16) (pSensorData-&gt; Register0); u16 Humidity_x100 = pSensorData-&gt; Register1; u16 Data1 = pSensorData-&gt; Register2; u16 Data2 = pSensorData-&gt; Register3; //   lcd.gotoxy (0, 16); lcd.string("Temperature: "); lcd.gotoxy (80, 16); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (Temperature_x100 &lt; 0) { lcd.string("-"); Temperature_x100 = -Temperature_x100;//    } u16 Temp = Temperature_x100 / 100; //  i2a(Temp, i2a_buf); showString(i2a_buf); //lcd.string(i2a_buf); showString("."); i2a(Temperature_x100 - Temp * 100, i2a_buf); //  showString(i2a_buf); lcd.string("C "); //   lcd.gotoxy (0, 32); lcd.string("Humidity: "); lcd.gotoxy (80, 32); Temp = Humidity_x100 / 100; i2a(Temp, i2a_buf); showString(i2a_buf); showString("."); i2a(Humidity_x100 - Temp * 100, i2a_buf); showString(i2a_buf); lcd.string("% "); //    //i2a(Data, i2a_buf); //lcd.string(i2a_buf); //         01  02 </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (SlaveAddr &lt;= 0x02) { RFRX_FUNC01(SlaveAddr, (u16*) &amp;RFRX_buffer[3]); } //   500  delay (500); //      02 RFTX_FUNC02(SlaveAddr); } break; case RF_FUNC02: { //      //      -    ,    print_P(PSTR("\r\nACK from sensor:")); Serial.print(SlaveAddr, HEX); } break; default: break; } } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> print_P(PSTR("\r\n XOR </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta">!")); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> print_P(PSTR("\r\n ADDR </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta">!")); } //     01 void RFRX_RESP_FUNC02(t_cmd_servo* pcmd_servo) { s16 POS1, POS2, POS3, POS4; POS1 = pcmd_servo-&gt;POS1; POS2 = pcmd_servo-&gt;POS2; POS3 = pcmd_servo-&gt;POS3; POS4 = pcmd_servo-&gt;POS4; /*print_P(PSTR("\r\nServo function response OK!")); print_P(PSTR("\r\nPOS1:")); Serial.print(POS1, HEX); Serial.print(POS2, HEX); Serial.print(POS3, HEX); Serial.print(POS4, HEX); */ } void setup(){ u8 ItStatus1, ItStatus2; lcd.begin(0x20, 0, 10); Serial.begin(38400); u8 length; u8 temp8; delay (1000); SI4431.begin(); //   ,   SPI  /*for (u8 reg = 0; reg &lt;=0x7f; reg++) { print_P(PSTR("\r\nReg:")); u8 c = SI4431.ReadRegister(reg); Serial.print(reg, HEX); print_P(PSTR(", ")); Serial.print(c, HEX); }*/ SI4431.Init(7); lcd.gotoxy(36, 0); lcd.string("I'm Ready!"); } void loop(){ u8 ItStatus1, ItStatus2; u8 len; // 2 : // a)     : 'ipkval' // )        CRC: 'icrcerror' SI4431.RXIRQEnable(); //           NIRQ SI4431.ReadStatus(&amp;ItStatus1, &amp;ItStatus2); /*   */ SI4431.RXEnable(); //    //   ,       CRC </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(SI4431.IRQstate() == 0 ){ //   SI4431.RXDisable(); //           NIRQ SI4431.ReadStatus(&amp;ItStatus1, &amp;ItStatus2); //     CRC </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">( (ItStatus1 &amp; 0x01) == 0x01 ){ print_P(PSTR("\r\n Received CRC Error!")); // FIFO  SI4431.FIFOReset(); //      /*TX_LED_SET RX_LED_SET delay(500); TX_LED_CLR RX_LED_CLR*/ } //       </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">( (ItStatus1 &amp; 0x02) == 0x02 ){ print_P(PSTR("\r\n Received good packet! Len = ")); //    len = SI4431.RXPacketLen(); Serial.print(len, HEX); //,         </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(len &lt;= sizeof(RFRX_buffer)) { SI4431.RXData((u8 *)RFRX_buffer, len); //   RFRX_MASTER_PROCESS (len); } } // RX FIFO SI4431.FIFOReset(); //   SI4431.RXEnable(); } } void i2a( unsigned int i, char* pOut_buf ){ int ii; char int_buf[5]; for (ii=0; ii &lt; 5; ){ int_buf[ii++] = '0'+ i % 10; i = i / 10; } do{ ii--; }while( (int_buf[ii] == '0') &amp;&amp; (ii != 0) ); do { *pOut_buf++= int_buf[ii--]; } while (ii &gt;= 0); *pOut_buf = 0x00; }</span></span></code> </pre> <br></div></div><br>  This sketch initializes the radio channel, the head unit is assigned the address 0. The maximum transmitter power is set to 13dBm: SI4431.Init (7); <br>  In this example, readings from 1 remote sensor are displayed, if necessary, you can display readings from a variety of sensors in the same way. <br><br>  Next, the firmware needs to be loaded into the Hummingbird board.  This can be done in several ways. <br><ol><li>  With the Arduino board </li><li>  Using USB-Serial Converter </li><li>  With the help of an in-circuit programmer. </li></ol><br>  For firmware using Arduino, you first need to extract a microcontroller from it.  After that you need to connect both boards with the following pins: <br><table><tbody><tr><td>  <b>Arduino</b> </td><td>  <b>Hummingbird</b> </td></tr><tr><td>  Pin 0 </td><td>  Pin 0 </td></tr><tr><td>  Pin 1 </td><td>  Pin 1 </td></tr><tr><td>  RESET </td><td>  RESET </td></tr><tr><td>  + 5V </td><td>  + 5V </td></tr><tr><td>  GND </td><td>  GND </td></tr></tbody></table><br>  After you have connected and set the power jumper to the 5V position on the Hummingbird, you can connect Arduino to the PC.  In the Arduino IDE, specify the correct port and in the Tools -&gt; Board section, select the ‚ÄúArduino Nano w / Atmega 168‚Äù option, and then click on the ‚ÄúDownload‚Äù button. <br><br>  Similar actions are taken when booting with a USB-Serial converter.  Well, the easiest way is to download using the programmer.  In the Arduino IDE, click the ‚ÄúCompile‚Äù button, then ‚Äúfind‚Äù the hex file with the firmware.  You connect the programmer to the ICSP Hummingbird connector, apply power to the board, load the firmware into it, specifying in the shell of your programmer MK ATMEGA168A.  Fuses: 0xF8, 0xDF, 0xFF.  Lockbit: 0xCF. <br><br>  Flashed, disconnected all the extra wiring from the hummingbird.  Now we serve on the power board and the inscription should appear on the LCD: I'm Ready!  The head unit is assembled, go to the next step. <br><br><h1>  Sensor </h1><br><h2>  1. Build </h2><br>  The board with the sensor will consist of only one digital sensor.  The board power will be battery, 3V. <br><br>  Sensor circuit SHT10. <br><img src="https://habrastorage.org/storage2/beb/b92/2e2/bebb922e260341a55c7c48782e174691.gif"><br>  Let's collect according to the scheme on the breadboard.  The sensor is connected to the Hummingbird by 4 wiring (digital pins 6 and 7 and power). <br><br><img src="https://habrastorage.org/storage2/0c9/454/b17/0c9454b177c259e12848eadf7947727d.jpg"><br><br>  Before you connect the battery compartment to the hummingbird, you must download the firmware.  And after that we connect the battery compartment to the Hummingbird to the 3V power connector and also set the jumper to the 3V position. <br><br>  A few words about nutrition.  If the sensor is to be used outdoors, then the appropriate batteries must be used.  The most frost-resistant batteries are lithium-thionyl-chloride (LiSOCl2), lithium-iron-phosphate (LiFePO4). <br><br><h2>  2. Firmware </h2><br>  In addition to the EZRadioPRO library, you will need the SHT1x library for the sensor, with its help we will read the temperature and humidity readings.  Download and install this library. <br><br><div class="spoiler">  <b class="spoiler_title">We start the Arduino IDE and create a sketch like this based on an example.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;SI4431.h&gt; #include "SimRF.h" #include &lt;avr/sleep.h&gt; #include &lt;avr/wdt.h&gt; #include &lt;SHT1x.h&gt; #define dataPin 7 #define clockPin 6 SHT1x sht1x(dataPin, clockPin); //#define DEBUG_MODE //    (0  ) #define SLAVE_ADDR (1) //    //  1:    #define RF_FUNC01 (1) //  2:     #define RF_FUNC02 (2) //    unsigned char RFTX_buffer[32]; //    unsigned char RFRX_buffer[32]; unsigned char putch(unsigned char send_char) { while (!(UCSR0A &amp; 0x20)); UDR0 = (unsigned char) send_char; while (!(UCSR0A &amp; 0x20)); return(send_char); } /*      FLASH  */ void print_P (const char* s) { char c; while ((c = pgm_read_byte(s++)) != 0) putch(c); } /*  XOR    u8* Src -       u8 len -    */ u8 get_xor(u8* Src, u8 len){ u8 xoracc = 0; while (len--){ xoracc ^= *Src++; } return xoracc; } /*   01    u8 addr -   u8* Data -      u8 Len -    */ void RFTX_FUNC01(u8 addr, u8* Data, u8 Len){ RFTX_buffer[0] = addr; //  RFTX_buffer[1] = SLAVE_ADDR; //  RFTX_buffer[2] = 0x01; //  01 //       for (u8 i = 0 ; i &lt; Len; i++){ RFTX_buffer[3+i] = *Data++; } //  XOR    RFTX_buffer[3 + Len] = get_xor ((u8*)RFTX_buffer, Len + 3); SI4431.TXData((u8*) RFTX_buffer, 3 + Len + 1); //       } /**    * : * addr -     * len -    * pData -       SRAM * : * (0..127)    * -1  */ s8 RFRX_PROCESS(u8 addr, u8 len, u8* pData){ s8 funccode; //      if (len &lt; 3) return -1; if ((RFRX_buffer[0] == SLAVE_ADDR)&amp;&amp;(RFRX_buffer[1] == addr)) { //           if (get_xor((u8*)RFRX_buffer, len - 1) == RFRX_buffer[len-1]){ funccode = RFRX_buffer[2]; pData = (u8*) &amp;RFRX_buffer[3]; return funccode; } else return -1; } else return -1; } /*       02 u8* PayloadData -    u8 PayloadLen -    */ void RFRX_RESP_FUNC02(u8* PayloadData, u8 PayloadLen){ //          #ifdef DEBUG_MODE for (u8 i = 0; i&lt; PayloadLen; i++){ Serial.print(*PayloadData++, HEX); } #endif } //      void RFTX_ACK_FUNC02(u8 addr, u8* Data, u8 Len){ RFTX_buffer[0] = 0x00; //  RFTX_buffer[1] = SLAVE_ADDR; //  RFTX_buffer[2] = RF_FUNC02; //       for (u8 i = 0 ; i &lt; Len; i++){ RFTX_buffer[3+i] = *Data++; } //  XOR    RFTX_buffer[3 + Len] = get_xor ((u8*)RFTX_buffer, Len+3); SI4431.TXData((u8*) RFTX_buffer, 3 + Len + 1); //       } u16 SensorData [4]; //   4 16    volatile unsigned char WDT_wake; volatile unsigned char SLEEP_TIME = 15; //volatile unsigned char WDT_counter; //    /*       */ ISR(WDT_vect) { static unsigned char WDT_counter; //    if (WDT_counter++ == SLEEP_TIME) { WDT_counter = 0; WDT_wake = 1; } //Serial.print(WDT_counter, HEX); asm ("WDR"); } void setup_WDT(void) { asm ("CLI"); asm ("WDR"); MCUSR &amp;= ~(1&lt;&lt;WDRF); //   WDTCSR = (1 &lt;&lt; WDCE)|(1&lt;&lt;WDE); WDTCSR = (1 &lt;&lt; WDP2)|(1 &lt;&lt; WDP1)|(1 &lt;&lt; WDIE)|(1 &lt;&lt; WDIF); //      1 .       asm ("SEI"); } void off_WDT(void){ asm ("CLI"); asm ("WDR"); MCUSR &amp;= ~(1&lt;&lt;WDRF); //   WDTCSR = (1 &lt;&lt; WDCE)|(1&lt;&lt;WDE)|(1 &lt;&lt; WDIF); /* Turn off WDT */ WDTCSR = 0x00; asm ("SEI"); } void sys_sleep(void){ asm ("CLI"); ADCSRA &amp;= ~(1 &lt;&lt; ADEN); //   SMCR |= (1&lt;&lt;SE); //   power-down asm ("SEI"); asm ("SLEEP"); } void sys_wake(void){ //     } void RF_sleep (void){ u8 ItStatus1, ItStatus2; //           NIRQ SI4431.ReadStatus(&amp;ItStatus1, &amp;ItStatus2); SI4431.WriteRegister(0x08, 0x03); // FIFO SI4431.WriteRegister(0x08, 0x00); SI4431.WriteRegister(0x07, 0x00); //   } void setup(){ Serial.begin(38400); delay (1000); u8 ItStatus1, ItStatus2; u8 length; u8 temp8; #ifdef DEBUG_MODE print_P (PSTR("\r\nHello!")); #endif delay (100); SI4431.begin(); #ifdef DEBUG_MODE //   ,   SPI  for (u8 reg = 0; reg &lt;=0x7f; reg++){ print_P(PSTR("\r\nReg:")); u8 c = SI4431.ReadRegister (reg); Serial.print(reg, HEX); print_P(PSTR(", ")); Serial.print(c, HEX); } #endif SI4431.Init(7); #ifdef DEBUG_MODE print_P(PSTR("\r\nRadio initialisation is OK")); #endif delay (1000); setup_WDT(); SMCR = (1&lt;&lt;SE)|(1&lt;&lt;SM1); //   power-down sys_sleep(); } void loop(){ u8 ItStatus1, ItStatus2; unsigned long Timer; if (WDT_wake){ Timer = 0; WDT_wake = 0; //    N  //    off_WDT(); //digitalWrite(13, HIGH); //   (   ) #ifdef DEBUG_MODE print_P(PSTR("\r\n WAKE UP!")); #endif // 1)   ,      SHT11x float Temp = sht1x.readTemperatureC(); s16 Temp_x100 = (s16) (Temp * 100.0); //   100.0 SensorData[0] = (u16) Temp_x100; float Humidity = sht1x.readHumidity(); u16 Humidity_x100 = (s16) (Humidity * 100.0); //   100.0 SensorData[1] = Humidity_x100; SensorData[2] = 0; SensorData[3] = 0; // 2) ,         // 3) ,      // 4)      0 (   ...     ) for (u8 TXcnt = 0; TXcnt&lt; 4; TXcnt++) { #ifdef DEBUG_MODE print_P(PSTR("\r\n TX to MASTER #")); #endif Serial.print(TXcnt + 1, DEC); RFTX_FUNC01(0x00, (u8*) SensorData, 8); //    0 8     // 4)       0      } // 5)     RX //         // 2 : // a)     : 'ipkval' // )        CRC: 'icrcerror' SI4431.RXIRQEnable(); //           NIRQ SI4431.ReadStatus(&amp;ItStatus1, &amp;ItStatus2); // FIFO  SI4431.FIFOReset(); /*   */ SI4431.RXEnable(); // 6)       1  #ifdef DEBUG_MODE print_P(PSTR("\r\n Wait Resp")); #endif Timer = 0; #define RESP_TIMEOUT (65535 * 32) while (Timer &lt; RESP_TIMEOUT){ //asm ("WDR"); if(SI4431.IRQstate() == 0 ) { //     CRC //   SI4431.RXDisable(); //           NIRQ SI4431.ReadStatus(&amp;ItStatus1, &amp;ItStatus2); //     CRC if( (ItStatus1 &amp; 0x01) == 0x01 ) { #ifdef DEBUG_MODE print_P(PSTR("\r\n RX CRC Error!")); #endif // FIFO  SI4431.FIFOReset(); //      break; //      } else if( (ItStatus1 &amp; 0x02) == 0x02 ) { //       #ifdef DEBUG_MODE print_P(PSTR("\r\n RX packet Len = ")); #endif //    u8 len = SI4431.RXPacketLen(); #ifdef DEBUG_MODE Serial.print(len, HEX); #endif //,         if(len &lt;= sizeof(RFRX_buffer)) { SI4431.RXData((u8 *)RFRX_buffer, len); //   s8 funccode = RFRX_PROCESS (0x00, len, (u8*)RFRX_buffer); switch (funccode) { case RF_FUNC02: { //     ! #ifdef DEBUG_MODE print_P(PSTR("\r\n MASTER RESPONSE!")); #endif u8* PayloadData = (u8*) &amp;RFRX_buffer[3]; //   u8 PayloadLen = len - 4; //   RFRX_RESP_FUNC02(PayloadData, PayloadLen); //  // 7)   ,        //       for (u8 TXcnt = 0; TXcnt&lt; 4; TXcnt++) { #ifdef DEBUG_MODE print_P(PSTR("\r\n ACK MASTER RESPONSE!")); #endif RFTX_ACK_FUNC02(0x00, PayloadData, PayloadLen); } } break; default: #ifdef DEBUG_MODE print_P(PSTR("\r\nInvalid RX packet!")); #endif break; } } } break; //      } else { Timer++; } } #ifdef DEBUG_MODE if (Timer == RESP_TIMEOUT) print_P(PSTR("\r\n Response Timeout!")); print_P(PSTR("\r\n SLEEP...")); #endif // 8)      RF_sleep(); setup_WDT(); //digitalWrite(13, LOW); } // 9)     ,    N    // 10)  ,   . 1. sys_sleep(); }</span></span></span></span></code> </pre></div></div><br>  The scheme of this program is simple.  After initialization of the radio channel, where it is assigned the address 1 and the first data transmission to the device with the address 0, the microcontroller puts the transceiver into sleep mode and then falls asleep for 15 seconds.  After this time has elapsed, the watchdog timer wakes up, turns on the transceiver and transmits the data again. <br><br>  A set of such sensors can be tied to a single head unit. <br><br>  Load this sketch into a Hummingbird.  After downloading, turn off all unnecessary, connect the battery power and turn on the power.  After some time, on the head unit we will receive readings from a remote sensor. <br><br><hr><br>  Uh, it seems everything is written.  If something is not clear, ask :) </div><p>Source: <a href="https://habr.com/ru/post/164215/">https://habr.com/ru/post/164215/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../164201/index.html">Hackathon through the eyes of the participant and the winner</a></li>
<li><a href="../164203/index.html">Diameter. The basic protocol. Part 1</a></li>
<li><a href="../164205/index.html">ION Piano Apprentice - controller for Garage Band</a></li>
<li><a href="../164207/index.html">"It works - do not touch." Should I break the rules?</a></li>
<li><a href="../164213/index.html">How do you feel about anonymity on the Internet?</a></li>
<li><a href="../164217/index.html">Introduction to developing games for Windows 8 using XNA and MonoGame</a></li>
<li><a href="../164221/index.html">The noexcept compile time specifier in C ++ 11</a></li>
<li><a href="../164223/index.html">New Year's Report Habrapost</a></li>
<li><a href="../164225/index.html">ReactOS 2012</a></li>
<li><a href="../164227/index.html">ICANN expert: domains for pornography and sexual minorities do not violate anyone‚Äôs rights</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>