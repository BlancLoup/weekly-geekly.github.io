<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Standard exchange 1C-Bitrix on BASH: Detailed parsing of the script of incremental unloading</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="To ensure synchronization of the product catalog between the 1C system and the site on the Bitrix management system, the standard for Bitrix is ‚Äã‚Äãthe ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Standard exchange 1C-Bitrix on BASH: Detailed parsing of the script of incremental unloading</h1><div class="post__text post__text-html js-mediator-article">  To ensure synchronization of the product catalog between the 1C system and the site on the Bitrix management system, the standard for Bitrix is ‚Äã‚Äãthe XML file exchange protocol in CommerceML format, based on the transfer from 1C to the Bitrix HTTP GET and POST requests with certain parameters, and receiving standard responses containing operations, denoting the result of its implementation. <br><br>  In the <a href="https://habr.com/post/321096/">first article of this series</a> , the rationale is given for the possibility of using a separate script that takes XML files generated by 1C or another system or program, and transmits them to Bitrix using a standard protocol. <br><br>  In this article I will give detailed comments on each line of the script.  This will simplify its modification for your needs. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The script is written in BASH and is one of several scripts providing various exchanges through the same standard that 1C-Bitrix offers for transferring goods from 1C and downloading orders from a site built on the basis of the Bitrix management system. <br><br>  Next comes the text of the script with comments.  A brief view of the script, containing only the code, is given in the <a href="https://habr.com/post/321096/">previous article</a> , and is available on <a href="https://github.com/parserme/bitrexchange">github</a> of the bitrexchange project. <br><a name="habracut"></a><br><h3>  Script and local file settings </h3><br>  In order to prevent the transfer of empty or broken files, to prevent data corruption, if any error we terminate the script. <br><br><pre><code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e</code> </pre> <br>  This is such an interesting method of switching to the current directory, and at the same time saving the full current path to the variable <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> $(dirname <span class="hljs-variable"><span class="hljs-variable">$0</span></span>) cdir=$(<span class="hljs-built_in"><span class="hljs-built_in">pwd</span></span>)<span class="hljs-string"><span class="hljs-string">"/"</span></span></code> </pre> <br>  Usually, 1C uploads files to some shared folder on the server on the network, which we will pre-mount.  But it can be a local directory for you, which you share on the network. <br><br><pre> <code class="bash hljs">remote_dir=<span class="hljs-string"><span class="hljs-string">"/mnt/localwinserver_fs/import/webdata/"</span></span></code> </pre> <br>  The name of the zip file in which the xml files will be packed.  Instead, you can use just a temporary name.  But this hard-coded file name is used to save copies of previously transferred files.  Very convenient: you can see at any time what day a product appeared and at what price, etc. <br><br><pre> <code class="bash hljs">zip_fname=<span class="hljs-string"><span class="hljs-string">"catalogue.zip"</span></span></code> </pre> <br>  The names of the files that we will transfer.  These files form 1C, they usually have such names, but there may be others!  Need to check it out!  Files are listed through a space. <br><br><pre> <code class="bash hljs">xml_files=<span class="hljs-string"><span class="hljs-string">"import0_1.xml offers0_1.xml"</span></span></code> </pre> <br>  Administrator mail to which error messages are sent. <br><br><pre> <code class="bash hljs">email1=<span class="hljs-string"><span class="hljs-string">"admin@yourinternetshop.com"</span></span>; email2=<span class="hljs-string"><span class="hljs-string">"alert@yourinternetshop.com"</span></span>;</code> </pre> <br>  Determine the current time: <br><br><pre> <code class="bash hljs">ctime=$(date +%Y-%m-%d-%H%M)</code> </pre> <br><h4>  Check and prepare files </h4><br>  This script is a special case of all the numerous types of downloads.  In addition to uploading the catalog, which we are doing now, there are other exchanges for which there are separate scripts.  But within the framework of this unloading - unloading of the catalog, two types are defined: the so-called incremental unloading, that is, unloading changes, and full unloading.  In format, they differ from each other only in one parameter: attribute value <br><br><pre> <code class="hljs"></code> </pre> <br>  - it is either true or false.  Speaking about the contents of XML files, we can say that incremental uploading can contain a full set of products, the difference is different: if the bitrix receives a full download, it completely erases the entire existing catalog of goods and fills it again.  All product pictures are also lost, so full uploading necessarily includes all images, while incremental may not include.  And of course, if it is important to save any bindings you create in the site database, then it is better not to delete the existing directory.  In general, one way or another, there is a huge, decisive difference, which type of unloading to use.  Therefore, we will definitely check, by no means trusting 1C, that this upload is really incremental, and check it in both files.  At the same time, we will verify that these files exist at all, and that there are two of them.  Sometimes, for example, 1C for some reason only unloads the number plate, and it may happen that the ball fell off and the files did not upload at all.  Therefore, in case of a problem, we inform ourselves about it and exit. <br><br><pre> <code class="bash hljs">chan=$(grep -e <span class="hljs-string"><span class="hljs-string">"=\"true"</span></span> <span class="hljs-variable"><span class="hljs-variable">${remote_dir}</span></span>*.xml | wc -l) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$chan</span></span></span><span class="hljs-string">"</span></span> != <span class="hljs-string"><span class="hljs-string">"2"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Error: XMLs are not in 'changes only' mode or file(s) are missing"</span></span> mail -s <span class="hljs-string"><span class="hljs-string">" "</span></span> -a <span class="hljs-string"><span class="hljs-string">"From: bitrexchange &lt;</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${email1}</span></span></span><span class="hljs-string">&gt;"</span></span> <span class="hljs-variable"><span class="hljs-variable">$email1</span></span>,<span class="hljs-variable"><span class="hljs-variable">$email2</span></span> &lt;&lt;&lt; <span class="hljs-string"><span class="hljs-string">"     ."</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1 <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"OK: Format of XMLs are 'changes only'"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  We start the actual work: we pack the files and make the archive of the previous file with the current date.  Please note that this command packs all xml files in the directory. <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ -f <span class="hljs-variable"><span class="hljs-variable">$zip_fname</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> mv <span class="hljs-variable"><span class="hljs-variable">$zip_fname</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${zip_fname}</span></span></span><span class="hljs-string">.</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${ctime}</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> /usr/bin/zip -9j <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$zip_fname</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-variable"><span class="hljs-variable">${remote_dir}</span></span>*.xml</code> </pre> <br><h3>  HTTP request settings </h3><br>  Set the HTTP request headers.  Actually, this is, firstly, completely optional, and secondly, you can specify some of your own, for example, the user-agent, by which you can then catch these requests in the Apache logs on the receiving side. <br><br><pre> <code class="bash hljs">headers=<span class="hljs-string"><span class="hljs-string">"--header=\"User-Agent: 1C+Enterprise/8.2\" --header=\"Accept-Encoding: deflate\""</span></span></code> </pre> <br>  Username and password of the user under which the download will be logged.  This is usually 1c_import or import.  These username and password are set in the Bitrix control panel!  For the test, you can use your administrator account, admin. <br><br><pre> <code class="bash hljs">login=<span class="hljs-string"><span class="hljs-string">"import"</span></span> password=<span class="hljs-string"><span class="hljs-string">"yourpasswordonbitrix"</span></span></code> </pre> <br>  In order not to clutter up the script, we will place all requests in a separate variable base url.  usually this is your <a href="http://xn--80adhe8ahe2f/bitrix/admin/1c_exchange.php">domain / bitrix / admin / 1c_exchange.php</a> <br><br><pre> <code class="bash hljs">baseurl=<span class="hljs-string"><span class="hljs-string">"http://yourinternetshop.com/bitrix/admin/1c_exchange.php"</span></span></code> </pre> <br><h3>  Proper exchange </h3><br>  Since the documentation is very (!) Superficial, and the specific methods of using the protocol differ from the 1C configuration, the exchange method used is verified and verified experimentally and works without changes on several working projects, which confirms the possibility of its mass use. <br><br>  According to the exchange protocol, requests of several types are transmitted sequentially.  The type of request is determined by the parameter that is added to the base url, which we have already specified above as baseurl.  Two variables in the url specify the type of request.  The first, type, takes the values ‚Äã‚Äãeither sale or catalog.  You can try to change it, at least for the first query, and always use catalog.  The second, more important for us, as it defines the stage of exchange, in the variable mode. <br><br>  First request, mode = checkauth <br>  The second request, mode = init <br>  The third request, mode = file + POST zip file. <br>  Subsequent requests, mode = import <br><br><h4>  First request </h4><br>  We login using HTTP protocol authentication!  Usually, this method is included in the bitrix, but if not, check the server settings.  As far as I know, there are no settings for turning this method on or off in the bitrix, but authentication can be turned off programmatically in many ways.  The so-called ‚Äúproactive protection‚Äù can also interfere, if you cannot login in any way, try disabling it for the duration of the test. <br><br><pre> <code class="bash hljs">ret_line=$( wget <span class="hljs-variable"><span class="hljs-variable">$headers</span></span> --user=<span class="hljs-variable"><span class="hljs-variable">${login}</span></span> --password=<span class="hljs-variable"><span class="hljs-variable">${password}</span></span> --auth-no-challenge -O - -q <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${baseurl}</span></span></span><span class="hljs-string">?type=sale&amp;mode=checkauth"</span></span> ) <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -a ret_ar &lt;&lt;&lt; <span class="hljs-variable"><span class="hljs-variable">$ret_line</span></span></code> </pre> <br>  According to the protocol, in case of a successful entry, the bitrix gives the answer in the form of three lines in the body of the HTTP response: <br><br>  The first is the success string. <br>  The second is a session variable, usually PHPSESSID <br>  The third is the session value, a string. <br><br>  If sussecc is received, save the session variable and its value for further use, if not, exit the script.  At this moment in case of an error, we can get an HTML page that you can save and somehow view, and, most likely, you will find in it a message that you need to login.  At this stage - most likely - check the username and password of the user, try, first of all, to log in with the username and password into the control panel of the bitrix. <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-variable"><span class="hljs-variable">${ret_ar[0]}</span></span> != <span class="hljs-string"><span class="hljs-string">"success"</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Login error\r\n"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> -1; <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> sessvar=<span class="hljs-variable"><span class="hljs-variable">${ret_ar[1]}</span></span> sessid=<span class="hljs-variable"><span class="hljs-variable">${ret_ar[2]}</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> sessid=<span class="hljs-variable"><span class="hljs-variable">$sessid</span></span></code> </pre> <br><h4>  Second request </h4><br>  The second request is Init.  When you receive this request, the / upload / 1c_catalog / directory is completely cleared (!) Be careful if you need any data from the previous upload.  For example, it will be important if you transfer pictures of goods.  1C version 8.3, as it was discovered, for some reason this request does not transmit, but goes straight to the file request.  At this stage, an error may occur, which will be described later in the appendix; see possible errors (1). <br><br><pre> <code class="bash hljs">ret=$(wget <span class="hljs-variable"><span class="hljs-variable">$headers</span></span> --header=<span class="hljs-string"><span class="hljs-string">"Cookie: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${sessvar}</span></span></span><span class="hljs-string">=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${sessid}</span></span></span><span class="hljs-string">"</span></span> -O - -q <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${baseurl}</span></span></span><span class="hljs-string">?type=catalog&amp;mode=init"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$ret</span></span></code> </pre> <br><h4>  Third request </h4><br>  In the third request, you need to send a zip file with a POST request.  mode should be = file, but the file name is the filename parameter ‚Äî as I understand it, it can be any, because it does not appear anywhere else in the request, and specifies only the name under which the transmitted data is saved as a file (the file is transmitted via A POST request and, therefore, in the context of HTTP, this is not a file but just some piece of data that can be anything). <br><br>  At this step in the upload / 1c_catalog directory is the import.zip file, unpacked.  Interestingly, no further requests for it need to be sent.  As soon as there is a first import request, it will be unpacked. <br><br><pre> <code class="bash hljs">ret=$(wget <span class="hljs-variable"><span class="hljs-variable">$headers</span></span> --post-file <span class="hljs-variable"><span class="hljs-variable">${zip_fname}</span></span> --header=<span class="hljs-string"><span class="hljs-string">"Cookie: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${sessvar}</span></span></span><span class="hljs-string">=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${sessid}</span></span></span><span class="hljs-string">"</span></span> -O - -q <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${baseurl}</span></span></span><span class="hljs-string">?type=catalog&amp;mode=file&amp;filename=import.zip"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$ret</span></span></code> </pre> <br><h4>  Import requests </h4><br>  Further, according to the exchange protocol 1C-Bitrix, you need to send requests with mode = file, until the success string is received.  In fact, you need to check not success, but the fact that every request has a response progress, and if it is, then you can continue the import, and if something else came, then the import ended for some reason, one of which maybe success.  One of the many undocumented moments is that such a cycle of requests must be repeated for each unpacked file, and the name of the zip file should not be specified anywhere else, since it is unpacked immediately upon receipt.  See also appendix, possible errors (2). <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> fname <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-variable"><span class="hljs-variable">$xml_files</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> st=<span class="hljs-string"><span class="hljs-string">"progress"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$st</span></span></span><span class="hljs-string">"</span></span> = <span class="hljs-string"><span class="hljs-string">"progress"</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ret=$(wget <span class="hljs-variable"><span class="hljs-variable">$headers</span></span> --header=<span class="hljs-string"><span class="hljs-string">"Cookie: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${sessvar}</span></span></span><span class="hljs-string">=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${sessid}</span></span></span><span class="hljs-string">"</span></span> -O - -q <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${baseurl}</span></span></span><span class="hljs-string">?type=catalog&amp;mode=import&amp;filename=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${fname}</span></span></span><span class="hljs-string">"</span></span>); st=$( &lt;&lt;&lt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ret</span></span></span><span class="hljs-string">"</span></span> head -n1 | cut -c1-8); <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ret</span></span></span><span class="hljs-string">"</span></span> | iconv -f cp1251 -t utf-8 <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  After this cycle, you need to check that the last message = success, and otherwise, notify yourself again.  This can be done within the framework of this script, or in some other way, for example, check the log. <br><br><h4>  Last request </h4><br>  According to the documentation, the last request should be type = success, 1C sends this request, but this script does without it. <br><br><h3>  Application: </h3><br><h4>  Possible mistakes (1) </h4><br>  On the second request, an ‚Äúfailure‚Äù error is issued.  The component should output the word ‚Äúfailure‚Äù in error and further the description of the error.  But, apparently, can not determine the language when requesting, and therefore simply failure without detailing the error is given.  Although there must be some kind of default language.  Perhaps the reason is something else, but the fact is that there is a failure and that's all.  The source of the error cannot be determined.  Solved, as always, by climbing into the code. <br><br><pre> <code class="php hljs">COption::GetOptionString(<span class="hljs-string"><span class="hljs-string">"sale"</span></span>, <span class="hljs-string"><span class="hljs-string">"secure_1c_exchange"</span></span>, <span class="hljs-string"><span class="hljs-string">"N"</span></span>) == <span class="hljs-string"><span class="hljs-string">"Y"</span></span></code> </pre> <br>  You can disable the check of this parameter directly in the code, you can set it to N: <br>  Settings - Tools - PHP command line. <br><br><pre> <code class="php hljs">COption::SetOptionString(<span class="hljs-string"><span class="hljs-string">"catalog"</span></span>, <span class="hljs-string"><span class="hljs-string">"DEFAULT_SKIP_SOURCE_CHECK"</span></span>, <span class="hljs-string"><span class="hljs-string">"Y"</span></span> ); COption::SetOptionString(<span class="hljs-string"><span class="hljs-string">"sale"</span></span>, <span class="hljs-string"><span class="hljs-string">"secure_1c_exchange"</span></span>, <span class="hljs-string"><span class="hljs-string">"N"</span></span> );</code> </pre> <br><h4>  Possible mistakes (2) </h4><br>  An obvious mistake: at each stage two lines are given: the first is progress, and the second is a description of what is being done.  So, there must necessarily be progress blocks.  Processed XXXX from YYYYY elements. <br><br>  - This is "processed so many of so many elements" - this is the import.  if not, then the import is not done.  such cases were in certain configurations. <br><br>  Standard exchange 1C-Bitrix for BASH: <a href="https://habr.com/post/321096/">The first article in a series of publications</a> . </div><p>Source: <a href="https://habr.com/ru/post/321266/">https://habr.com/ru/post/321266/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321254/index.html">Pass to the ground - how Apple Pay and Samsung Pay were launched in Yandex.Money</a></li>
<li><a href="../321256/index.html">The logic of consciousness. Part 11. Natural coding of visual and sound information</a></li>
<li><a href="../321258/index.html">ReactOS at FOSDEM 2017</a></li>
<li><a href="../321260/index.html">Procedural level generation for MERC in Unity</a></li>
<li><a href="../321262/index.html">Logging with rsyslog, file names in tags, multi-line messages and fault tolerance</a></li>
<li><a href="../321268/index.html">Let's Encrypt and Express. To each server - on the green lock</a></li>
<li><a href="../321270/index.html">How to evaluate big tasks</a></li>
<li><a href="../321274/index.html">Features of the distributed storage architecture in Dropbox</a></li>
<li><a href="../321276/index.html">As we did not go to Y Combinator, ‚Äú... the profit plan is simple - here the drugs are legal, $ 70 cant ...‚Äù</a></li>
<li><a href="../321278/index.html">Local multiplayer in Unity using Unet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>