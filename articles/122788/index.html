<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Haskell Quest Tutorial - View of the canyon</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Canyon view 
 You are at the top of the Great Canyon on its west wall. From here there is a marvelous view of the canyon and parts of the Frigid River...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Haskell Quest Tutorial - View of the canyon</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  Canyon view <br>  You are at the top of the Great Canyon on its west wall.  From here there is a marvelous view of the canyon and parts of the Frigid River upstream.  The Cliffs and the Cliffs join the mighty ramparts of the Flathead Mountains to the east.  Following the Canyon upstream to the north, Aragain Falls may be seen, complete with rainbow.  The mighty frigid river cavern.  Stretching for miles around.  A path leads northwest.  It is possible to climb down into the canyon here. </blockquote><br><br>  Content: <br>  <a href="http://habrahabr.ru/blogs/Haskell/120590/">Greeting</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/120759/">Part 1 - The Threshold</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/121189/">Part 2 - Forest</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/122259/">Part 3 - Polyana</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/122788/">Part 4 - View of the canyon</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/123422/">Part 5 - Hall</a> <br><br>  Part 4, <br>  in which we will do refactoring, implement a couple of actions, learn about pattern matching and recursion, and also make a real program from the quest. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And let's enter the current location?  And it‚Äôs time to say something.  We already have a run function, where all the most important things happen, which means that it should contain the current location.  Suppose, in the run function, the location description is first displayed, and then everything else.  This means that the run function is aware of the current location.  Let's give her this location as a parameter: <br><br><blockquote>  run curLoc <font color="#66cc66">=</font> <font color="#06c">do</font> <br>  <font>putStrLn</font> <font>(</font> describeLocation curLoc <font>)</font> <br>  <font>putStr</font> <i><font color="#808080">"Enter command:"</font></i> <br>  x <font color="#339933">&lt;-</font> <font>getLine</font> <br>  <font>putStrLn</font> <font>(</font> evalAction <font>(</font> convertStringToAction x <font>)</font> <font>)</font> </blockquote><br><br>  Good.  We try: <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> run Home <br>  Home <br>  You are standing <font color="#06c">in</font> the middle of the wooden table <font color="#339933">.</font> <br>  Enter command: Look <br>  Action: Look <font color="#339933">!</font> <br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> </blockquote><br><br>  What a short program, however!  It works as expected, but ends right there.  Well, this is not a game.  In games, the event handler is usually spinning in a loop until it is explicitly interrupted by the ‚ÄúExit‚Äù button.  I would like something like this: the game should work until we say ‚ÄúQuit‚Äù to it.  How to do it?  First we need to organize continuous processing of commands from the user.  The easiest way is to call run from itself.  It has a parameter, - the current location, - while transmitting the old current location, and later we will think of something. <br><br><blockquote>  run curLoc <font color="#66cc66">=</font> <font color="#06c">do</font> <br>  <font>putStrLn</font> <font>(</font> describeLocation curLoc <font>)</font> <br>  <font>putStr</font> <i><font color="#808080">"Enter command:"</font></i> <br>  x <font color="#339933">&lt;-</font> <font>getLine</font> <br>  <font>putStrLn</font> <font>(</font> evalAction <font>(</font> convertStringToAction x <font>)</font> <font>)</font> <br>  <font>putStrLn</font> <i><font color="#808080">‚ÄúEnd of turn.</font></i>  <i><font color="#808080"><font>\ n</font> "</font></i> <font color="#5d478b">- New move - from the new line.</font> <br>  run curLoc <br><br>  <font color="#5d478b">- We are testing:</font> <br><br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> run Home <br>  Home <br>  You are standing <font color="#06c">in</font> the middle of the wooden table <font color="#339933">.</font> <br>  Enter command: Look <br>  Action: Look <font color="#339933">!</font> <br>  End <font color="#06c">of</font> turn <font color="#339933">.</font> <br><br>  Home <br>  You are standing <font color="#06c">in</font> the middle of the wooden table <font color="#339933">.</font> <br>  Enter command: <font color="#339933">&lt;</font> Ctrl <font color="#339933">+</font> C <font color="#339933">&gt;</font> Interrupted <font color="#339933">.</font> </blockquote><br><br>  The program obediently started a street organ from the beginning.  We do not yet have adequate event handling, so the only way to interrupt the program is to press &lt;Ctrl + C&gt;.  And to make her react to the ‚ÄúQuit‚Äù command, a little refactoring is needed.  Rewrite the run function as follows: <br><br><blockquote>  run curLoc <font color="#66cc66">=</font> <font color="#06c">do</font> <br>  <font>putStrLn</font> <font>(</font> describeLocation curLoc <font>)</font> <br>  <font>putStr</font> <i><font color="#808080">"Enter command:"</font></i> <br>  x <font color="#339933">&lt;-</font> <font>getLine</font> <br>  <font color="#06c">case</font> <font>(</font> convertStringToAction x <font>)</font> <font color="#06c">of</font> <br>  Quit <font color="#66cc66">-&gt;</font> <font>putStrLn</font> <i><font color="#808080">"Be seen you ..."</font></i> <br>  <font><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">otherwise</a></font> <font color="#66cc66">-&gt;</font> <font color="#06c">do</font> <br>  <font>putStrLn</font> <font>(</font> evalAction <font>(</font> convertStringToAction x <font>)</font> <font>)</font> <br>  <font>putStrLn</font> <i><font color="#808080">‚ÄúEnd of turn.</font></i>  <i><font color="#808080"><font>\ n</font> "</font></i> <br>  run curLoc </blockquote><br><br>  Yeah, something is unclean here! .. Let's see.  The beginning of the run function is familiar to you.  The ‚Äúdo‚Äù keyword, which stands at the very beginning, links actions into a chain.  What actions are included in this chain?  Only four: (print the location description) - (output the line ‚ÄúEnter command:‚Äû) - (get the string from the user and link it to the variable x) - (execute the expression inside the case structure).  When execution comes to case, it jumps to the right alternative and continues there.  Suppose a user has entered ‚ÄúQuit‚Äù, and then the function (convertStringToAction x) returns the Quit constructor, which means that the first alternative should work.  In this alternative, only one action - printing the string "Be seen you ...".  There is no other action anywhere ‚Äî neither inside the Quit alternative, nor after the case construct, so the run function has nothing more to do and it will end.  Now suppose that the user entered not ‚ÄúQuit‚Äù, but ‚ÄúLook‚Äù, - what will happen?  It is clear that the alternative to Quit will not work, but <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">otherwise is</a> always on guard - that is where the execution will continue.  And what's there?  Another keyword "do"!  It means that a new chain of actions has begun here, and it is performed in the same way, in steps.  What actions are included in this chain?  Only three: (print the processed command) - (display the line "End of turn. \ N") - (start the run function). <br><br>  At first glance, the function is incomprehensible: all these cases, do, left and right arrows!  But everything is in place, if you carefully trace the implementation.  We only need to check whether the program really works, as we think. <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> run Home <br>  Home <br>  You are standing <font color="#06c">in</font> the middle of the wooden table <font color="#339933">.</font> <br>  Enter command: Look <br>  Action: Look <font color="#339933">!</font> <br>  End <font color="#06c">of</font> turn <font color="#339933">.</font> <br><br>  Home <br>  You are standing <font color="#06c">in</font> the middle of the wooden table <font color="#339933">.</font> <br>  Enter command: Quit <br>  Be seen you <font color="#339933">...</font> <br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> </blockquote><br><br>  Hooray!  We are great!  But our run function is still far from ideal.  Note: there is a call (convertStringToAction x) twice in it, and this is bad.  Fortunately, the convertStringToAction function is simple, it does not require resources, otherwise it would be an overrun.  In Haskell, and in any other language, you need to avoid repetition.  Since we have this call in the case-construction, its result can be put in a variable.  Slightly change the run function: <br><br><blockquote>  run curLoc <font color="#66cc66">=</font> <font color="#06c">do</font> <br>  <font>putStrLn</font> <font>(</font> describeLocation curLoc <font>)</font> <br>  <font>putStr</font> <i><font color="#808080">"Enter command:"</font></i> <br>  x <font color="#339933">&lt;-</font> <font>getLine</font> <br>  <font color="#06c">case</font> <font>(</font> convertStringToAction x <font>)</font> <font color="#06c">of</font> <br>  Quit <font color="#66cc66">-&gt;</font> <font>putStrLn</font> <i><font color="#808080">"Be seen you ..."</font></i> <br>  convertResult <font color="#66cc66">-&gt;</font> <font color="#06c">do</font> <br>  <font>putStrLn</font> <font>(</font> evalAction convertResult <font>)</font> <br>  <font>putStrLn</font> <i><font color="#808080">‚ÄúEnd of turn.</font></i>  <i><font color="#808080"><font>\ n</font> "</font></i> <font color="#5d478b">- New move - from the new line.</font> <br>  run curLoc </blockquote><br><br>  Yes, instead of <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">otherwise</a> now the convertResult variable.  If past alternatives on some value did not work, then this value, calculated once, is placed in the variable and then used.  And this is a good practice, which is even more common than <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">otherwise</a> , for obvious reasons. <br><br>  Well, it was very difficult, so that's all for today. <br><br><blockquote><blockquote>  Do not forget about indents, they are important here;  for the first and second ‚Äúdo‚Äù all actions are located strictly where the first one began.  It would be possible to align it in another way, for example, as follows: <br><br><blockquote>  run curLoc <font color="#66cc66">=</font> <font color="#06c">do</font> <br>  <font>putStrLn</font> <font>(</font> describeLocation curLoc <font>)</font> <br>  <font>putStr</font> <font>"Enter command:"</font> <br>  x <font color="#339933">&lt;-</font> <font>getLine</font> <br>  <font color="#06c">case</font> <font>(</font> convertStringToAction x <font>)</font> <font color="#06c">of</font> <br>  Quit <font color="#339933">-&gt;</font> <font>putStrLn</font> <font>"Be seen you ..."</font> <br>  <font><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">otherwise</a></font> <font color="#339933">-&gt;</font> <font color="#06c">do</font> <br>  <font>putStrLn</font> <font>(</font> evalAction <font>(</font> convertStringToAction x <font>)</font> <font>)</font> <br>  <font>putStrLn</font> <font>"End of turn. <font>\ n</font> "</font> <font color="#5d478b">- New turn - from a new line.</font> <br>  run curLoc <br></blockquote><br><br>  Each block has its own indents, and there is no need to mix them. </blockquote></blockquote><br><br>  Who said you can disperse?  We continue!  Of course, you are already making plans for how to improve the program.  And right!  Add some actual (and not fictitious) processing of the Look command yourself, but for now let's think about the Go command.  How is it implemented in Zork? <br><br><blockquote>  Clearing <br>  ... <br><br>  &gt; Go West <br>  Forest <br>  ... </blockquote><br><br>  If we write ‚ÄúGo West‚Äù, the command parser will be unhappy because it doesn‚Äôt understand how to parse this line: <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> run Home <br>  Home <br>  You are standing <font color="#06c">in</font> the middle of the wooden table <font color="#339933">.</font> <br>  Enter command: Go West <br>  <font color="#339933">***</font> Exception: <font>Prelude</font> <font color="#339933">.</font>  <font>read</font> : no parse </blockquote><br><br>  Maybe we break the line ‚ÄúGo West‚Äù into two and separate them, because we have the designers Go and West?  The thought is certainly correct, and it certainly will work, but ... Haskell would not be a magic language if it didn‚Äôt allow Go West to be parsed even easier, but for that you need to prepare something.  Come from afar.  As you remember, in the third part there was a tie-in that the constructors of ATD-types are special functions.  For example, Home is a function of type Location, Go is a function of type Action, and West is a function of type Direction. <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> : <font color="#06c">type</font> Home <br>  Home <font color="#339933">::</font> Location <br><br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> : <font color="#06c">type</font> West <br>  West <font color="#339933">::</font> Direction <br><br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> : <font color="#06c">type</font> Go <br>  Go <font color="#339933">::</font> Action </blockquote><br><br>  And what do we know about the function?  Right.  That they may have arguments.  And what question should we ask?  Right.  ‚ÄúIf constructors are functions, then does this mean that they can also have arguments?‚Äù As you may have guessed, yes!  When defining an ATD type, you can specify which type arguments are passed to one or another constructor.  Add a Direction type argument to the Go constructor. <br><br><blockquote>  <font color="#06c">data</font> Action <font color="#66cc66">=</font> <br>  Look <br>  <font color="#339933">|</font>  Go direction <br>  <font color="#339933">|</font>  Inventory <br>  <font color="#339933">|</font>  Take <br>  <font color="#339933">|</font>  Drop <br>  <font color="#339933">|</font>  Investigate <br>  <font color="#339933">|</font>  Quit <br>  <font color="#339933">|</font>  Save <br>  <font color="#339933">|</font>  Load <br>  <font color="#339933">|</font>  New <br>  <font color="#06c">deriving</font> <font>(</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Eq</a></font> <font color="#339933">,</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Show</a></font> <font color="#339933">,</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Read</a></font> <font>)</font> </blockquote><br><br>  In this case, the type of the constructor slightly changes, because we have made a function that accepts Direction, and returns an Action.  Check how the translation of the constructor into the string and vice versa will work: <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> <font>show</font> <font>(</font> Go West <font>)</font> <br>  <i><font color="#808080">"Go West"</font></i> <br><br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> <font>read</font> <i><font color="#808080">"Go North"</font></i> <font color="#339933">::</font> Action <br>  Go north <br><br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> : t Go <br>  Go <font color="#339933">::</font> Direction <font color="#66cc66">-&gt;</font> Action </blockquote><br><br>  Here it is.  And, best of all, almost no effort on our part.  The composite constructor is no more difficult than the others; it is even better because it intuitively sets the data.  And working with him is very easy!  Update the run case with: <br><br><blockquote>  run curLoc <font color="#66cc66">=</font> <font color="#06c">do</font> <br>  <font>putStrLn</font> <font>(</font> describeLocation curLoc <font>)</font> <br>  <font>putStr</font> <i><font color="#808080">"Enter command:"</font></i> <br>  x <font color="#339933">&lt;-</font> <font>getLine</font> <br>  <font color="#06c">case</font> <font>(</font> convertStringToAction x <font>)</font> <font color="#06c">of</font> <br>  Quit <font color="#66cc66">-&gt;</font> <font>putStrLn</font> <i><font color="#808080">"Be seen you ..."</font></i> <br>  Go dir <font color="#66cc66">-&gt;</font> <font>putStrLn</font> <font>(</font> <i><font color="#808080">"You going to"</font></i> <font color="#339933">++</font> <font>show</font> dir <font color="#339933">++</font> <i><font color="#808080">"!"</font></i> <font>)</font> <br>  convertResult <font color="#66cc66">-&gt;</font> <font color="#06c">do</font> <br>  <font>putStrLn</font> <font>(</font> evalAction convertResult <font>)</font> <br>  <font>putStrLn</font> <i><font color="#808080">‚ÄúEnd of turn.</font></i>  <i><font color="#808080"><font>\ n</font> "</font></i> <font color="#5d478b">- New move - from the new line.</font> <br>  run curLoc <br><br>  <font color="#5d478b">- Check:</font> <br><br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> run Home <br>  Home <br>  You are standing <font color="#06c">in</font> the middle of the wooden table <font color="#339933">.</font> <br>  Enter command: Go West <br>  You going to West <font color="#339933">!</font> </blockquote><br><br>  If the parser recognizes in the ‚ÄúGo Something‚Äù line, the alternative ‚ÄúGo dir‚Äù will work, and that ‚ÄúSomething‚Äù will fall into the dir variable.  Well, then we are working with the variable dir.  Magic! <br><br><blockquote><blockquote>  Algebraic data types in Haskell are even better.  Perhaps you have already figured out how to rewrite the ‚ÄúBlunt Calculator‚Äù puzzle from the third part, using constructors with arguments.  You could have something like this: <br><br><blockquote> <font color="#06c">data</font> IntegerArithmOperation <font color="#66cc66">=</font> <br>  Plus <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Integer</a></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Integer</a></font> <br>  <font color="#339933">|</font>  Minus <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">integer</a></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">integer</a></font> <br>  <font color="#339933">|</font>  Prod <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">integer</a></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">integer</a></font> <br>  <font color="#339933">|</font>  Negate <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">integer</a></font> <br><br>  evalOp <font color="#339933">::</font> IntegerArithmOperation <font color="#66cc66">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Integer</a></font> <br>  evalOp op <font color="#66cc66">=</font> <font color="#06c">case</font> op <font color="#06c">of</font> <br>  Plus x y <font color="#66cc66">-&gt;</font> x <font color="#339933">+</font> y <font color="#5d478b">- The ‚Äúop‚Äù parameter is matched with each option in turn.</font> <br>  Minus x y <font color="#66cc66">-&gt;</font> x <font color="#339933">-</font> y <font color="#5d478b">- Which sample came up, this alternative is chosen.</font> <br>  Prod x y <font color="#66cc66">-&gt;</font> x <font color="#339933">*</font> y <font color="#5d478b">- Instead of x and y, the numbers that we passed along with the constructor are substituted.</font> <br>  Negate x <font color="#66cc66">-&gt;</font> <font color="#339933">-</font> x <font color="#5d478b">- Returns the result of the calculation.</font>  <font color="#5d478b">For example, 2 * 3 = 6.</font> <br><br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> evalOp <font>(</font> Plus <font color="red">2</font> <font color="red">3</font> <font>)</font> <font color="#5d478b">- (Plus 2 3) is a constructor with two arguments.</font> <br>  <font color="red">five</font> <br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> evalOp <font>(</font> Minus <font color="red">2</font> <font color="red">3</font> <font>)</font> <br>  <font color="#339933">-</font> <font color="red">1</font> <br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> evalOp <font>(</font> Prod <font color="red">2</font> <font color="red">3</font> <font>)</font> <br>  <font color="red">6</font> <br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> evalOp <font>(</font> Negate <font color="red">5</font> <font>)</font> <br>  <font color="#339933">-</font> <font color="red">5</font> </blockquote></blockquote></blockquote><br><br>  What are we adventurers, if we are marking time in the same location?  It is necessary to gather strength into a fist and make the transition between locations already!  Suppose we have a function walk (task from the second part), which takes the current location and direction of movement, and returns a new location.  Here it is: <br><br><blockquote>  walk <font color="#339933">::</font> Location <font color="#66cc66">-&gt;</font> Direction <font color="#66cc66">-&gt;</font> Location <br>  walk curLoc toDir <font color="#66cc66">=</font> <font color="#06c">case</font> curLoc <font color="#06c">of</font> <br>  Home <font color="#66cc66">-&gt;</font> <font color="#06c">case</font> toDir <font color="#06c">of</font> <br>  North <font color="#66cc66">-&gt;</font> Garden <br>  South <font color="#66cc66">-&gt;</font> Friend'sYard <br>  <font><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">otherwise</a></font> <font color="#66cc66">-&gt;</font> Home <br>  Garden <font color="#66cc66">-&gt;</font> <font color="#06c">case</font> toDir <font color="#06c">of</font> <br>  North <font color="#66cc66">-&gt;</font> Friend'sYard <br>  South <font color="#66cc66">-&gt;</font> Home <br>  <font><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">otherwise</a></font> <font color="#66cc66">-&gt;</font> Garden <br>  <font color="#5d478b">- ... Add the remaining options here.</font> </blockquote><br><br>  In fact, a terrible approach.  So much extra work!  So many nested cases!  We will definitely come up with something else when we have enough knowledge, and now we can only improve the walk function so that there is no case: <br><br><blockquote>  walk <font color="#339933">::</font> Location <font color="#66cc66">-&gt;</font> Direction <font color="#66cc66">-&gt;</font> Location <br><br>  walk Home North <font color="#66cc66">=</font> Garden <br>  walk Home South <font color="#66cc66">=</font> Friend'sYard <br>  walk Garden North <font color="#66cc66">=</font> Friend'sYard <br>  walk Garden South <font color="#66cc66">=</font> Home <br>  walk Friend'sYard North <font color="#66cc66">=</font> Home <br>  walk Friend'sYard South <font color="#66cc66">=</font> Garden <br>  walk curLoc <font color="#339933">_</font> <font color="#66cc66">=</font> curLoc </blockquote><br><br>  Wow, so many walk functions!  And all the same - the lines are smaller than in the previous example, and there is more functionality.  How it works?  Very simple.  When we call the walk function with arguments, the appropriate option is selected.  For example, ‚Äúwalk Garden South‚Äù - and the fourth one will be selected, which will return Home. <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> walk Garden South <br>  Home </blockquote><br><br>  Interest is the last walk.  It just leaves us in the current location.  One can guess that when all the others do not work, it will work.  In it, the first parameter will fit into the curLoc variable, and the second parameter will not fit anywhere.  We, in general, and it does not matter what is in the second parameter, we will not use it, that's why we put the underscore sign.  You can, of course, slip some variable, but the underlining is more obvious.  Do not specify an argument;  if you do that, ghci will scream, they say, why are you so inconstant? .. <br><br><blockquote>  <font color="#339933">......</font> <br>  walk Friend'sYard North <font color="#66cc66">=</font> Home <br>  walk Friend'sYard South <font color="#66cc66">=</font> Garden <br>  walk curLoc <font color="#66cc66">=</font> curLoc <br><br><br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> : r <br>  <font>[</font> <font color="red">1</font> <font color="#06c">of</font> <font color="red">1</font> <font>]</font> Compiling Main <font>(</font> H: \ Haskell \ QuestTutorial \ Quest \ QuestMain <font color="#339933">.</font> Hs <font color="#339933">,</font> interpreted <font>)</font> <br><br>  H: \ Haskell \ QuestTutorial \ Quest \ QuestMain <font color="#339933">.</font>  hs: <font color="red">50</font> : <font color="red">1</font> : <br>  Equations for 'walk' have different numbers <font color="#06c">of</font> arguments <br>  H: \ Haskell \ QuestTutorial \ Quest \ QuestMain <font color="#339933">.</font>  hs: <font color="red">50</font> : <font color="red">1</font> <font color="#339933">-</font> <font color="red">24</font> <br>  H: \ Haskell \ QuestTutorial \ Quest \ QuestMain <font color="#339933">.</font>  hs: <font color="red">56</font> : <font color="red">1</font> <font color="#339933">-</font> <font color="red">22</font> <br>  Failed <font color="#339933">,</font> modules loaded: none <font color="#339933">.</font> </blockquote><br><br><blockquote><blockquote>  Pattern matching (pattern matching), which is used here, is a useful tool, with which the code becomes clearer, safer, and shorter.  There are other nice features of pattern matching.  You can ‚Äúslip‚Äù not only constants, but also variables, and even disassemble a term into its constituent parts.  With the help of a special record it is easy to separate the first element of the list and the rest.  Here‚Äôs how it looks for strings: <br><br><blockquote>  headLetter <font color="#339933">::</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <font color="#66cc66">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Char</a></font> <br>  headLetter <font>(</font> ch: chs <font>)</font> <font color="#66cc66">=</font> ch <br><br>  tailLetters <font color="#339933">::</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <font color="#66cc66">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <br>  tailLetters <font>(</font> ch: chs <font>)</font> <font color="#66cc66">=</font> chs <br><br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> headLetter <i><font color="#808080">"Abduction"</font></i> <br>  'A' <br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> tailLetters <i><font color="#808080">"Abduction"</font></i> <br>  <i><font color="#808080">"Bduction"</font></i> </blockquote></blockquote></blockquote><br><br>  The last step is to modify the run function.  Everything is trivial: add a chain of actions to an alternative to Go dir, output the line "\ nYou walking to" ++ show dir ++ ". \ N", and run the run function again, but this time we will get a new current location using walk . <br><br><blockquote>  run curLoc <font color="#66cc66">=</font> <font color="#06c">do</font> <br>  <font>putStrLn</font> <font>(</font> describeLocation curLoc <font>)</font> <br>  <font>putStr</font> <i><font color="#808080">"Enter command:"</font></i> <br>  x <font color="#339933">&lt;-</font> <font>getLine</font> <br>  <font color="#06c">case</font> <font>(</font> convertStringToAction x <font>)</font> <font color="#06c">of</font> <br>  Quit <font color="#66cc66">-&gt;</font> <font>putStrLn</font> <i><font color="#808080">"Be seen you ..."</font></i> <br>  Go dir <font color="#66cc66">-&gt;</font> <font color="#06c">do</font> <br>  <font>putStrLn</font> <font>(</font> <i><font color="#808080">" <font>\ n</font> You walking to"</font></i> <font color="#339933">++</font> <font>show</font> dir <font color="#339933">++</font> <i><font color="#808080">". <font>\ n</font> "</font></i> <font>)</font> <br>  run <font>(</font> walk curLoc dir <font>)</font> <br>  convertResult <font color="#66cc66">-&gt;</font> <font color="#06c">do</font> <br>  <font>putStrLn</font> <font>(</font> evalAction convertResult <font>)</font> <br>  <font>putStrLn</font> <i><font color="#808080">‚ÄúEnd of turn.</font></i>  <i><font color="#808080"><font>\ n</font> "</font></i> <br>  run curLoc <br><br>  <font color="#5d478b">- Check</font> <br><br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> run Home <br>  Home <br>  You are standing <font color="#339933">...</font> <br>  Enter command: Go North <br><br>  You walking to North <font color="#339933">.</font> <br><br>  Garden <br>  You are <font color="#06c">in</font> the garden <font color="#339933">.</font>  <font color="#339933">...</font> </blockquote><br><br>  That's all.  Go action works. <br><br><blockquote><blockquote>  Recursion is <s>recursion.</s>  it is a function call from itself.  We are actively using recursion in Haskell - and there is nothing wrong with that.  Unlike imperative languages ‚Äã‚Äãsuch as C ++, functional languages ‚Äã‚Äãencourage us to use recursion where it is difficult to do with other methods.  In this case, recursion is acceptable;  we don‚Äôt produce a lot of data, we don‚Äôt twist recursion even a thousand times, so you shouldn‚Äôt be afraid of resource leaks, which could be in the same C ++.  In Haskell, there are mechanisms with which recursion becomes a safe means.  So, only those expressions that are directly needed here and now are calculated, which means that resources are not spent on a huge layer of other code.  The compiler can reuse what was once computed.  There is no stack as such in Haskell - the memory will not overflow.  Finally, by optimizing recursion into a tail call, the compiler can ensure that there is no recursion in the usual sense at all. <br><br>  You can compile a simple program and look at the dynamics of the use of resources.  The program calculates the Fibonacci numbers at each step of the recursion and displays the last of them. <br><br><blockquote>  <font color="#5d478b">- test.hs:</font> <br><br>  <font color="#06c">module</font> Main <font color="#06c">where</font> <br><br>  fibs <font color="#66cc66">=</font> <font color="red">0</font> : <font color="red">1</font> : <font>zipWith</font> <font>(</font> <font color="#339933">+</font> <font>)</font> fibs <font>(</font> <font>tail</font> fibs <font>)</font> <br><br>  run cnt <font color="#66cc66">=</font> <font color="#06c">do</font> <br>  <font>putStrLn</font> <font>(</font> <i><font color="#808080">" <font>\ n</font> Turns count:"</font></i> <font color="#339933">++</font> <font>show</font> cnt <font>)</font> <br>  <font>putStrLn</font> <font color="#339933">$</font> <font>show</font> <font color="#339933">$</font> <font>last</font> <font color="#339933">$</font> <font>take</font> cnt fibs <br>  run <font>(</font> cnt <font color="#339933">+</font> <font color="red">1</font> <font>)</font> <br><br>  main <font color="#66cc66">=</font> <font color="#06c">do</font> <br>  run <font color="red">1</font> </blockquote><br><br>  Compile with optimization: <br><br><blockquote>  ghc <font color="#339933">-</font> O test <font color="#339933">.</font>  hs </blockquote></blockquote></blockquote><br><br>  Do you like order in code?  The code of our quest looks, in general, not bad, only it lacks one important thing: the entry point to the program.  It cannot even be compiled into an executable file.  While we were using the GHCi interpreter, we didn‚Äôt think about it, but what if a friend wants to play our game?  It‚Äôs not the Haskell code to give it to - a friend in general, maybe not a programmer, and he will not understand anything.  But the executable file is easy.  To compile a program for real, on the command line, run ghc, specifying the path to QuestMain.hs: <br><br><blockquote>  H: \ Haskell \ QuestTutorial \ Quest <font color="#339933">&gt;</font> ghc QuestMain <font color="#339933">.</font>  hs <br>  <font>[</font> <font color="red">1</font> <font color="#06c">of</font> <font color="red">1</font> <font>]</font> Compiling Main <font>(</font> QuestMain <font color="#339933">.</font> Hs <font color="#339933">,</font> QuestMain <font color="#339933">.</font> O <font>)</font> <br><br>  QuestMain <font color="#339933">.</font>  hs: <font color="red">1</font> : <font color="red">1</font> <br>  The function "Main" is <font>not</font> defined <font color="#06c">in the</font> <font color="#06c">module</font> . </blockquote><br><br>  The GHC compiler says that the main function was not found in the Main module.  This is the way the entry point is entered into a Haskell program.  It looks like other languages ‚Äã‚Äãwhere there is a main function in one form or another.  Add it to the bottom of the QuestMain.hs file: <br><br><blockquote>  main <font color="#66cc66">=</font> <font color="#06c">do</font> <br>  <font>putStrLn</font> <i><font color="#808080">"Quest adventure on Haskell.</font></i>  <i><font color="#808080"><font>\ n</font> "</font></i> <br>  run home </blockquote><br><br>  And at the very beginning of the file we define the Main module, in which all our functions will lie: <br><br><blockquote>  <font color="#06c">module</font> Main <font color="#06c">where</font> </blockquote><br><br>  Now the compiler safely eats the source, and you will see the executable file.  I have this QuestMain.exe.  Among other things, there will be files with the extensions .o and .hi - these are temporary files (object and file with interfaces).  If they bother you, you can remove them.  While the project is small, they do not play a special role.  Then they, as in other languages, can be used for partial compilation, which is much faster than compiling from scratch.  For example, if a module was once combined and never changed again, as well as the modules on which it depends did not change, then it does not need to be recompiled, it is enough to take old .o- and .hi-files.  Therefore, it will be good practice to divide the code into modules;  even better - by module and folder;  and even better - by modules, folders and libraries. <br><br>  Let's divide our quest into two modules: the Types module and the Main module.  To do this, create the Types.hs file, at the very top define it as a module using the line ‚Äúmodule Types where‚Äù and transfer all the ATD types from the QuestMain.hs file there. <br><br><blockquote>  <font color="#5d478b">- Types.hs:</font> <br><br>  <font color="#06c">module</font> Types <font color="#06c">where</font> <br><br>  <font color="#06c">data</font> Location <font color="#66cc66">=</font> <br>  Home <br>  <font color="#339933">|</font>  <font color="#339933">...</font> <br>  <font color="#06c">deriving</font> <font>(</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Eq</a></font> <font color="#339933">,</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Show</a></font> <font color="#339933">,</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Read</a></font> <font>)</font> <br><br>  <font color="#06c">data</font> direction <font color="#66cc66">=</font> <br>  North <br>  <font color="#339933">|</font>  <font color="#339933">...</font> <br>  <font color="#06c">deriving</font> <font>(</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Eq</a></font> <font color="#339933">,</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Show</a></font> <font color="#339933">,</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Read</a></font> <font>)</font> <br><br>  <font color="#06c">data</font> Action <font color="#66cc66">=</font> <br>  Look <br>  <font color="#339933">|</font>  Go direction <br>  <font color="#339933">|</font>  <font color="#339933">...</font> <br>  <font color="#06c">deriving</font> <font>(</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Eq</a></font> <font color="#339933">,</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Show</a></font> <font color="#339933">,</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Read</a></font> <font>)</font> </blockquote><br><br>  If in ghci now execute the command: r, the interpreter will panic: he does not know these types! <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> : r <br>  <font>[</font> <font color="red">1</font> <font color="#06c">of</font> <font color="red">1</font> <font>]</font> Compiling Main <font>(</font> H: \ Haskell \ QuestTutorial \ Quest \ QuestMain <font color="#339933">.</font> Hs <font color="#339933">,</font> interpreted <font>)</font> <br><br>  H: \ Haskell \ QuestTutorial \ Quest \ QuestMain <font color="#339933">.</font>  hs: <font color="red">4</font> : <font color="red">21</font> : <br>  Not <font color="#06c">in</font> scope: <font color="#06c">type</font> constructor <font>or</font> <font color="#06c">class</font> 'Location' <br><br>  H: \ Haskell \ QuestTutorial \ Quest \ QuestMain <font color="#339933">.</font>  hs: <font color="red">7</font> : <font color="red">13</font> : <br>  Not <font color="#06c">in</font> scope: <font color="#06c">data</font> constructor 'Home' <br><br>  H: \ Haskell \ QuestTutorial \ Quest \ QuestMain <font color="#339933">.</font>  hs: <font color="red">8</font> : <font color="red">13</font> : <br>  Not <font color="#06c">in</font> scope: <font color="#06c">data</font> constructor 'Friend'sYard' <br><br>  <font color="#339933">...</font> and there are twenty more such lines <font color="#339933">.</font> <br><br>  Prelude <font color="#339933">&gt;</font> </blockquote><br><br>  No problem!  We have to connect our module with types, and they will be visible in Main.  Somewhere at the top of the Main module, under ‚Äúmodule Main where‚Äù, add a simple line: <br><br><blockquote>  <font color="#5d478b">- QuestMain.hs:</font> <br>  <font color="#06c">module</font> Main <font color="#06c">where</font> <br><br>  <font color="#06c">import</font> types <br>  <font color="#5d478b">- ... the rest of the code ...</font> </blockquote><br><br>  Now the compilation is successful.  We have time to notice: there are already two compiled files, which is logical. <br><br><blockquote>  Prelude <font color="#339933">&gt;</font> : r <br>  <font>[</font> <font color="red">1</font> <font color="#06c">of</font> <font color="red">2</font> <font>]</font> Compiling Types <font>(</font> H: \ Haskell \ QuestTutorial \ Quest \ Types <font color="#339933">.</font> Hs <font color="#339933">,</font> interpreted <font>)</font> <br>  <font>[</font> <font color="red">2</font> <font color="#06c">of</font> <font color="red">2</font> <font>]</font> Compiling Main <font>(</font> H: \ Haskell \ QuestTutorial \ Quest \ QuestMain <font color="#339933">.</font> Hs <font color="#339933">,</font> interpreted <font>)</font> <br>  Ok <font color="#339933">,</font> modules loaded: Main <font color="#339933">,</font> Types <font color="#339933">.</font> <br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> </blockquote><br><br>  We have divided the code into modules, which is good.  We added an entry point - and the code became a real program.  It's also good.  We finally got acquainted with recursion and pattern matching, and also came up with one composite constructor of type Action.  Great job!  Now you should have a good rest and consolidate knowledge <br><br><blockquote><blockquote>  Tasks for fixing. <br><br>  1. Create a GameAction module in the GameAction.hs file and bring all the functions from Main into it, except main and run. <br>  2. Add (if not already) handling the Look command next to Quit, Go dir.  Think about how you can improve duplicate code "(describeLocation curLoc)", so as not to call it twice. <br>  3. Add the processing of the New command to check whether the user is sure that he wants to start a new game. </blockquote></blockquote><br><br>  <a href="https://github.com/graninas/Quest-Tutorial-Code/archives/c1d81091d37932a54633238d08caa15632ff3771">Sources to this part</a> . <br><br>  Table of contents, list of references and additional information can be found in the <a href="http://habrahabr.ru/blogs/Haskell/120590/">"Welcome"</a> . </div><p>Source: <a href="https://habr.com/ru/post/122788/">https://habr.com/ru/post/122788/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../122777/index.html">Manage to return - Amazon Kindle 3 Wifi</a></li>
<li><a href="../122778/index.html">Overview of one docking station</a></li>
<li><a href="../122780/index.html">Kinect for Windows SDK, learning resources and usage examples</a></li>
<li><a href="../122783/index.html">Implementing HTTP server push using Server-Sent Events</a></li>
<li><a href="../122784/index.html">Oracle. Row level security</a></li>
<li><a href="../122789/index.html">Network Tablet Scanner</a></li>
<li><a href="../122790/index.html">Methods of ineffective promotion of Facebook applications</a></li>
<li><a href="../122792/index.html">In the USA, an anti-piracy agreement may be concluded between the RIAA, the MRAA and the country's largest providers.</a></li>
<li><a href="../122793/index.html">On the ISS will install HD cameras for live broadcast</a></li>
<li><a href="../122796/index.html">There is a photo gallery, but no visitors. How to be?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>