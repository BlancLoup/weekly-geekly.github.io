<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using closures and higher-order functions in Delphi</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a continuation of the previous publication , which was devoted to anonymous methods. This time we will discuss examples of the use of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using closures and higher-order functions in Delphi</h1><div class="post__text post__text-html js-mediator-article">  This article is a continuation of the <a href="http://habrahabr.ru/post/243721/">previous publication</a> , which was devoted to anonymous methods.  This time we will discuss examples of the use of higher-order functions and closures that seemed interesting to the author. <br><a name="habracut"></a><br>  Delphi is not a functional programming language, but the fact that programs on it can manipulate functions as objects means that you can use the techniques of the functional paradigm in Delphi.  The purpose of the article is not to push to use this style, but to identify some examples and possibilities. <br><br><h5>  <b>Construction of functions</b> </h5><br>  Higher-order functions (FVPs) are functions that operate on functions, taking one or more functions, and returning a new function. <br>  The following example shows how other functions can be constructed with the help of an AFP. <br><br><pre><code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TRef&lt;AT, RT&gt; = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X: AT)</span></span></span><span class="hljs-function">:</span></span> RT; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Negate: TRef&lt;TRef&lt;Integer, Boolean&gt;, TRef&lt;Integer, Boolean&gt;&gt;; IsOdd, IsEven: TRef&lt;Integer, Boolean&gt;; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//   ,    IsOdd := function(X: Integer): Boolean begin Result := X mod 2 &lt;&gt; 0; end; //    Negate := function(F: TRef&lt;Integer, Boolean&gt;): TRef&lt;Integer, Boolean&gt; begin Result := function(X: Integer): Boolean begin Result := not F(X); end; end; //     IsEven := Negate(IsOdd); WriteLn(IsOdd(4)); // =&gt; False WriteLn(IsEven(4)); // =&gt; True end;</span></span></code> </pre> <br>  The Negate function in the example above is a FER, because it takes the function IsOdd as an argument and returns a new function IsEven, which passes its arguments to Negate and returns a logical negation of the value returned by the function IsOdd. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Since the use of generic types does not contribute to clarity of presentation, in the following examples we will avoid them if possible. <br><br><h5>  <b>Composition of functions</b> </h5><br>  Below is an example of another, more universal function that takes two functions, F and G, and returns a new function that returns the result F (G ()). <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TOneArgRef = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X: Single)</span></span></span><span class="hljs-function">:</span></span> Single; TTwoArgRef = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X, Y: Single)</span></span></span><span class="hljs-function">:</span></span> Single; TCompose = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F: TOneArgRef; G: TTwoArgRef)</span></span></span><span class="hljs-function">:</span></span> TTwoArgRef; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Compose: TCompose; Square: TOneArgRef; Half: TOneArgRef; Sum: TTwoArgRef; SquareOfSum: TTwoArgRef; HalfSum: TTwoArgRef; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//     "" Compose := function(F: TOneArgRef; G: TTwoArgRef): TTwoArgRef begin Result := function(X, Y: Single): Single begin Result := F(G(X, Y)); end; end; //   : // 1.    Square := function(X: Single): Single begin Result := X * X; end; // 2.    Half := function(X: Single): Single begin Result := X / 2; end; // 3.     Sum := function(X, Y: Single): Single begin Result := X + Y; end; //   " " SquareOfSum := Compose(Square, Sum); //   "" HalfSum := Compose(Half, Sum); WriteLn(SquareOfSum(2.0, 3.0)); // =&gt; 25.0 WriteLn(HalfSum(3.0, 7.0)); // =&gt; 5.0 end;</span></span></code> </pre><br>  Here, the Compose function calculates F (G (X, Y)).  The returned function passes all its arguments to the function G, then passes the value received from G to function F and returns the result of calling F. <br><br><h5>  <b>Partial application</b> </h5><br>  This term describes the conversion of a function with several arguments to a function that takes a smaller number of arguments, with the values ‚Äã‚Äãfor the omitted arguments set in advance.  This technique is quite adequate to its name: it "partially applies" some of the arguments of the function, returning a function that takes the remaining arguments. <br>  In the example below, the BindLeft function takes a Calc function that takes <i>n</i> arguments, connects the first <i>k</i> of them with pre-specified values, and returns a Partial function that can take <i>(nk)</i> arguments (the first <i>k</i> arguments will already be applied to it). <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TManyArgRef = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args: TArray&lt;Double&gt;)</span></span></span><span class="hljs-function">:</span></span> Double; TBindRef = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args: TArray&lt;Double&gt;; F: TManyArgRef)</span></span></span><span class="hljs-function">:</span></span> TManyArgRef; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> BindLeft: TBindRef; Calc, Partial: TManyArgRef; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//  ,     Args //   F . BindLeft := function(Args: TArray&lt;Double&gt;; F: TManyArgRef): TManyArgRef var StoredArgs: TArray&lt;Double&gt;; begin StoredArgs := Args; Result := function(Args: TArray&lt;Double&gt;): Double begin Result := F(StoredArgs + Args); end; end; //     //     Calc := function(A: TArray&lt;Double&gt;): Double begin Result := A[0] * (A[1] - A[2]); end; //    Partial := BindLeft([2, 3], Calc); //      WriteLn(Partial([4])); // =&gt; -2.0 //  Partial   Calc([2, 3, 4]) end;</span></span></code> </pre><br>  Here the moment is interesting when, after a call to BindLeft, the local variable StoredArgs does not cease to exist and is used further, keeping in itself the values ‚Äã‚Äãof the arguments, which are then used in the call to Partial and passed to Calc.  This effect is called closure.  In addition, each call to BindLeft will generate new ‚Äúinstances‚Äù of StoredArgs.  Closures were also used in the previous examples, when the arguments of the PID were stored in them. <br>  Partial application on the right can be determined as follows: <br><br><pre> <code class="delphi hljs"> BindRight := <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args: TArray&lt;Double&gt;; F: TManyArgRef)</span></span></span><span class="hljs-function">:</span></span> TManyArgRef <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> StoredArgs: TArray&lt;Double&gt;; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> StoredArgs := Args; Result := <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args: TArray&lt;Double&gt;)</span></span></span><span class="hljs-function">:</span></span> Double <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := F(Args + StoredArgs); <span class="hljs-comment"><span class="hljs-comment">//   end; end;</span></span></code> </pre><br><br><h5>  <b>Carring</b> </h5><br>  While partial application converts a function with <i>n</i> parameters into a function with <i>nk</i> parameters, applying <i>k</i> arguments, currying decomposes the function into functions from a single argument.  We do not pass any additional arguments to the Curry method, except for the function being converted: <br><ul><li>  Curry (F) returns a function F1, such that ... </li><li>  F1 (A) returns the function F2, such that ... </li><li>  F2 (B) returns a function F3, such that ... </li><li>  F3 (C) causes F (A, B, C) </li></ul><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TOneArgRef = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X: Double)</span></span></span><span class="hljs-function">:</span></span> Double; TThreeArgRef = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X, Y, Z: Double)</span></span></span><span class="hljs-function">:</span></span> Double; TSecondStepRef = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X: Double)</span></span></span><span class="hljs-function">:</span></span> TOneArgRef; TFirstStepRef = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X: Double)</span></span></span><span class="hljs-function">:</span></span> TSecondStepRef; TCurryRef = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F: TThreeArgRef)</span></span></span><span class="hljs-function">:</span></span> TFirstStepRef; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Curry: TCurryRef; Calc: TThreeArgRef; F1: TFirstStepRef; F2: TSecondStepRef; F3: TOneArgRef; Re: Double; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//        Curry := function(F: TThreeArgRef): TFirstStepRef begin Result := function(A: Double): TSecondStepRef begin Result := function(B: Double): TOneArgRef begin Result := function(C: Double): Double begin Result := F(A, B, C); end; end; end; end; //     , //    Calc := function(A, B, C: Double): Double begin Result := A + B + C; end; //     Calc,   F1 := Curry(Calc); F2 := F1(1); F3 := F2(2); Re := F3(3); WriteLn(Re); // =&gt; 6.0 end;</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Slightly more compact looks like a generalized version of Curry.</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TRef&lt;AT, RT&gt; = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args: AT)</span></span></span><span class="hljs-function">:</span></span> RT; TCalc&lt;T&gt; = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X, Y, Z: T)</span></span></span><span class="hljs-function">:</span></span> T; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Curry: TRef&lt;TCalc&lt;Double&gt;,TRef&lt;Double,TRef&lt;Double,TRef&lt;Double,Double&gt;&gt;&gt;&gt;; Calc: TCalc&lt;Double&gt;; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//    Curry := function(F: TCalc&lt;Double&gt;): TRef&lt;Double,TRef&lt;Double,TRef&lt;Double,Double&gt;&gt;&gt; begin Result := function(A: Double): TRef&lt;Double,TRef&lt;Double,Double&gt;&gt; begin Result := function(B: Double): TRef&lt;Double,Double&gt; begin Result := function(C: Double): Double begin Result := F(A, B, C); end; end; end; end; //    Calc := function(A, B, C: Double): Double begin Result := A + B + C; end; //  WriteLn(Curry(Calc)(1)(2)(3)); // =&gt; 6.0 end;</span></span></code> </pre><br></div></div><br><h5>  <b>Memoization</b> </h5><br>  Memoisated function is a function that stores previously calculated results.  In other words, a result table is created for the function, and, being calculated for certain values ‚Äã‚Äãof parameters, the result is recorded in this table.  In the future, the result is taken from this table.  This technique allows using the additional memory to speed up the program.  Of course, the function to be memorized must work without side effects and it is desirable for it to have a discrete domain of definition. <br>  The following example demonstrates the higher-order Memoize function, which takes a function as an argument and returns its memoized version. <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TRef = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X: Integer)</span></span></span><span class="hljs-function">:</span></span> Double; TMemoize = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F: TRef)</span></span></span><span class="hljs-function">:</span></span> TRef; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Memoize: TMemoize; Calc: TRef; MemoizedCalc: TRef; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//  Memoize Memoize := function(F: TRef): TRef var Cache: ICache&lt;Integer, Double&gt;; begin Cache := TCache&lt;Integer, Double&gt;.Create; Result := function(X: Integer): Double begin //      ... if not Cache.TryGetValue(X, Result) then begin Result := F(X); // ...   Cache.Add(X, Result); //    end; end; end; // ,     Calc := function(X: Integer): Double var I: Integer; begin Result := 0; for I := 1 to High(Word) do Result := Result + Ln(I) / Sin(I) * X; end; //    Calc MemoizedCalc := Memoize(Calc); end;</span></span></code> </pre><br>  The Memoize function creates a TCache object for use as a cache and assigns it to a local variable, so that it remains available (through a closure) only for the returned function.  The returned function converts its argument to the key.  If the value is present in the cache, it is simply returned as a result.  Otherwise, the original function is called, which calculates the value for the given argument;  The resulting value is cached and returned. <br><br><div class="spoiler">  <b class="spoiler_title">Cache implementation</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Generics.Collections; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-comment"><span class="hljs-comment">//       ICache&lt;TKey, TValue&gt; = interface function TryGetValue(Key: TKey; out Value: TValue): Boolean; procedure Add(Key: TKey; Value: TValue); end; TCache&lt;TKey, TValue&gt; = class(TInterfacedObject, ICache&lt;TKey, TValue&gt;) private FDictionary: TDictionary&lt;TKey, TValue&gt;; public constructor Create; destructor Destroy; override; function TryGetValue(Key: TKey; out Value: TValue): Boolean; procedure Add(Key: TKey; Value: TValue); end; implementation constructor TCache&lt;TKey, TValue&gt;.Create; begin FDictionary := TDictionary&lt;TKey, TValue&gt;.Create; end; destructor TCache&lt;TKey, TValue&gt;.Destroy; begin FDictionary.Free; inherited; end; procedure TCache&lt;TKey, TValue&gt;.Add(Key: TKey; Value: TValue); begin FDictionary.Add(Key, Value); end; function TCache&lt;TKey, TValue&gt;.TryGetValue(Key: TKey; out Value: TValue): Boolean; begin Result := FDictionary.TryGetValue(Key, Value); end;</span></span></code> </pre><br></div></div><br>  A program with a memosized function that is periodically called with the same arguments must run faster than a similar program without the use of memoization.  Check the difference: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> SysUtils, DateUtils; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; Time: TDateTime; Ms1, Ms2: Int64; Res1, Res2: Double; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Res1 := <span class="hljs-number"><span class="hljs-number">0</span></span>; Res2 := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   Time := Now; for I := 1 to 1000 do Res1 := Res1 + Calc(I mod 100); Ms1 := MilliSecondsBetween(Now, Time); //   Time := Now; for I := 1 to 1000 do Res2 := Res2 + MemoizedCalc(I mod 100); Ms2 := MilliSecondsBetween(Now, Time); WriteLn(Res1 = Res2); // =&gt; True WriteLn(Ms1 &gt; Ms2); // =&gt; True end;</span></span></code> </pre><br><br><h5>  <b>Generators</b> </h5><br>  Here, a generator is understood as a FER, which returns a function, the call of which results in the next member of some sequence.  In the example below, two generators are created: for the Fibonacci sequence and factorial generator.  The previous elements of the generators are stored in the circuit. <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TRef = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">:</span></span> Cardinal; TGenRef = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">:</span></span> TRef; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> FibGen, FactGen: TGenRef; FibVal, FactVal: TRef; I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// -,     FibGen := function: TRef var X, Y: Cardinal; begin X := 0; Y := 1; Result := function: Cardinal begin Result := Y; Y := X + Y; X := Result; end; end; // -,    FactGen := function: TRef var X, Y: Cardinal; begin X := 1; Y := 1; Result := function: Cardinal begin Result := Y; Y := Y * X; Inc(X); end; end; //   -    . //     Delphi,     . FibVal := FibGen(); FactVal := FactGen(); for I := 1 to 10 do WriteLn(FibVal, #9, FactVal); end;</span></span></code> </pre><br><br>  The advantage of generators is that to calculate each next element it is not required to calculate the entire sequence from the very beginning.  Generators allow you to work even with infinite sequences, but they provide only sequential access to their elements and do not allow you to access your elements by index: to get ne value you have to perform n-1 iterations. <br><br><h5>  <b>Deferred calculations</b> </h5><br>  Generators can be conveniently used for sequential processing of data - elements of a list, strings of text, lexemes in a lexical analyzer, etc.  Generators can be chained together, like a command pipeline to Unix.  The most interesting thing about this approach is that it follows the principle of <i>deferred calculations</i> : the values ‚Äã‚Äãare ‚Äúextracted‚Äù from the generator (or from the conveyor) as needed, and not all at once.  This feature is demonstrated by the following example, in which the source text is filtered, passing line by line through a chain of generators. <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TStringRef = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; TEachLineRef = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> TStringRef; TArgMap = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; TMap = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A: TStringRef; F: TArgMap)</span></span></span><span class="hljs-function">:</span></span> TStringRef; TArgSelect = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> Boolean; TSelect = reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A: TStringRef; F: TArgSelect)</span></span></span><span class="hljs-function">:</span></span> TStringRef; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-comment"><span class="hljs-comment">//  ,    TEXT = '#comment ' + sLineBreak + '' + sLineBreak + ' hello' + sLineBreak + ' world ' + sLineBreak + ' quit ' + sLineBreak + ' unreached'; var EachLine: TEachLineRef; Map: TMap; Select: TSelect; Lines, Trimmed, Nonblank: TStringRef; S: string; begin // ,     . EachLine := function(S: string): TStringRef begin Result := function: string begin Result := S.Substring(0, S.IndexOf(sLineBreak)); S := S.Substring(S.IndexOf(sLineBreak) + 1); end; end; // ,  ,   -  F  A Map := function(A: TStringRef; F: TArgMap): TStringRef begin Result := function: string begin Result := F(A); end; end; // -,   A,  F(A) = True Select := function(A: TStringRef; F: TArgSelect): TStringRef begin Result := function: string begin repeat Result := A; until F(Result); end; end; //      : //      Lines := EachLine(TEXT); //          Trimmed := Map(Lines, function(S: string): string begin Result := S.Trim; end); // ,      Nonblank := Select(Trimmed, function(S: string): Boolean begin Result := (S.Length &gt; 0) and (S[1] &lt;&gt; '#'); end); //         , // ,    'quit' repeat S := Nonblank; if S = 'quit' then Break; WriteLn(S); until False; end;</span></span></code> </pre><br><br>  The source for the article can be downloaded <a href="https://yadi.sk/d/yc8KEghYdHhEz">here.</a> </div><p>Source: <a href="https://habr.com/ru/post/244945/">https://habr.com/ru/post/244945/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../244925/index.html">AngularJS 1.x - translation course from CodeSchool</a></li>
<li><a href="../244929/index.html">Ten Typical Questions at HTML Interviews</a></li>
<li><a href="../244935/index.html">Hacker's guide to neural networks. Schemes of real values. Strategy number 2: Numerical gradient</a></li>
<li><a href="../244937/index.html">Lathe CNC Siemens Sinumerik 840D sl: making cutting tools [shot 02]</a></li>
<li><a href="../244943/index.html">IBM technology helped improve ski production and the skis themselves</a></li>
<li><a href="../244947/index.html">How we experimented with the Theory of Constraints in Ukraine</a></li>
<li><a href="../244949/index.html">Javascript birthday</a></li>
<li><a href="../244951/index.html">Administration of our days: ‚ÄúI have a lift hung!‚Äù</a></li>
<li><a href="../244953/index.html">Increase conversion Landing Page</a></li>
<li><a href="../244955/index.html">New GNS3 - step forward or jump on the spot?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>