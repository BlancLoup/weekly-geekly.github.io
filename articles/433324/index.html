<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Build a Dream Bundle with Webpack</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JS applications, websites and other resources are becoming more complex and build tools are a reality of web development. Bandlers help package, compi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Build a Dream Bundle with Webpack</h1><div class="post__text post__text-html js-mediator-article">  JS applications, websites and other resources are becoming more complex and build tools are a reality of web development.  Bandlers help package, compile, and organize libraries.  One of the powerful and flexible open source tools that can be perfectly customized to build a client application is Webpack. <br><br>  Maxim Sosnov ( <a href="https://habr.com/ru/users/crazymax11/" class="user_link">crazymax11</a> ) - Frontend Lead in N1.RU implemented Webpack in several large projects that previously had its own custom build, and associated several projects with it.  Maxim knows how to build a dream bundle with Webpack, do it quickly and configure it so that the config remains clean, supported and modular. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/4ClK_0fxsVM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Decryption is different from the report - this is a highly enhanced version of the link.  Throughout the decoding, Easter eggs are scattered on articles, plug-ins, minifiers, options, transporters and proof words of the speaker, links to which simply can not be put into a speech.  If you collect everything, the bonus level in Webpack will open :-) <br><a name="habracut"></a><br><h2>  Integrating a Webpack into a typical project </h2><br>  Usually, the order of implementation is as follows: a developer read an article about a Webpack somewhere, decides to connect it, starts to embed it, somehow it works out, everything starts up, and for a while the webpack-config works - for six months, a year, two.  Locally everything is fine - the sun, rainbow and butterflies.  And then come the real users: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <em>- With mobile devices, your site does not load.</em> <em><br></em>  <em>- Everything works with us.</em>  <em>All is well locally!</em> <br><br>  Just in case, the developer goes all the profiling and sees that for mobile devices the <strong>bundle weighs 7 MB and loads for 30 seconds</strong> .  This does not suit anyone and the developer begins to look for how to solve the problem - he can plug in a loader or find a magic plugin that solves all problems.  Miraculously, this plugin is located.  Our developer goes to the webpack-config, tries to install, but the line of code interferes: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (process.env.NODE_ENV === <span class="hljs-string"><span class="hljs-string">'production'</span></span>) { config.module.rules[<span class="hljs-number"><span class="hljs-number">7</span></span>].options.magic = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  The line translates as follows: "If the config is set up for production, then take the seventh rule, and put the <code>magic = true</code> option there."  The developer does not know what to do with it and how to solve it.  This is a situation when you need a dream bundle. <br><br><h2>  How to build a dream bundle? </h2><br>  First, let's define what it is.  First of all, the dream bundle has two main characteristics: <br><br><ul><li>  <strong>It weighs a little</strong> .  The less weight - the faster the user will get a working application.  You do not want your site to open 15 seconds. </li><li>  The user <strong>downloads only what you need to</strong> download to display the current page of the site, and not a byte anymore! </li></ul><br>  And in order to reduce the size of the bundle, you must first estimate its size. <br><br><h3>  Estimate the size of the bundle </h3><br>  The most popular solution is the <a href="https://www.npmjs.com/package/webpack-bundle-analyzer">WebpackBundleAnalyzer</a> plugin.  It collects application build statistics and renders an interactive page where you can see the location and weight of each module. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/27a/803/6b9/27a8036b994a09b7371c567b6df6cd82.png" alt="image"><br><br>  If this is not enough, you can build a <strong>dependency graph</strong> using <a href="https://www.npmjs.com/package/webpack-runtime-analyzer">another plugin</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c3/900/24a/7c390024a9d902ca99e3d00c0d8081b3.png" alt="image"><br><br>  Or <a href="https://alexkuz.github.io/webpack-chart/">a pie chart</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/350/14a/ec4/35014aec45623d06972bca310b3f8edf.png" alt="image"><br><br>  If this is not enough, and you want to sell Webpack to marketers, then you can <a href="https://alexkuz.github.io/stellar-webpack/">build a whole universe</a> , where each point is a module, like a star in the Universe. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45b/a6e/2d2/45ba6e2d2daff144c69df2a43e8ef53a.png" alt="image"><br><br>  There are a lot of tools that estimate the size of the bundle and monitor it.  There is <a href="https://webpack.js.org/configuration/performance/">an option in the Webpack config</a> that destroys the build if the bundle weighs too much, for example.  There is a <a href="https://www.npmjs.com/package/duplicate-package-checker-webpack-plugin">duplicate-package-checker-webpack-plugin plugin</a> that won't let you build a bundle if you have 2 npm packages of different versions, for example, Lodash 4.15 and Lodash 4.14. <br><br><h3>  How to shrink a bundle </h3><br><ul><li>  The most obvious is to connect <strong>UglifyJS</strong> so that it mines JavaScript. </li><li>  Use <strong>special loaders and plugins</strong> that compress and optimize a certain resource.  For example, <strong>css-nano</strong> for css, or <a href="https://github.com/rpominov/svgo-loader">SVGO</a> , which optimizes SVG. </li><li>  Compress all files directly to Webpack via <a href="https://github.com/webpack-contrib/compression-webpack-plugin">gzip / brotli plugins</a> . </li><li>  Other tools. </li></ul><br>  Now we understand how to throw out too much of the bundle. <br><br><h3>  Throw out too much </h3><br>  Consider this in a popular example from <strong>moment.js</strong> : <code>import moment from 'moment'</code> .  If you take an empty application, import moment.js and <strong>ReactDOM</strong> into it, and then pass it through <strong>WebpackBundleAnalyzer</strong> , you will see the following picture. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/105/e0f/833/105e0f8334a83c529077c693fda3d3de.png" alt="image"><br><br>  It turns out that when you add a date to the date, hour or just want to put the link ‚Äúin 15 minutes‚Äù with the help of moment.js, you connect as much as <strong>230 KB code</strong> !  Why is this happening and how is it solved? <br><br><h4>  Loading locale at the moment </h4><br>  At the moment.js there is a function that sets the locale: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setLocale</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">locale</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> localePath = <span class="hljs-string"><span class="hljs-string">'locale/'</span></span> + locale + <span class="hljs-string"><span class="hljs-string">'.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentLocale = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(localePath); }</code> </pre><br>  The code shows that the locale is loaded in a dynamic way, i.e.  calculated in runtime.  Webpack comes smart and tries to make sure that your bundle does not crash during the execution of the code: it finds all possible locales in the project, and bundles them.  Therefore, the application weighs so much. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a03/4cc/b3f/a034ccb3fc36dd03b916b0bc28acb057.png" alt="image"><br><br>  The solution is very simple - we take the <a href="https://webpack.js.org/plugins/context-replacement-plugin/">standard plug-in</a> from Webpack and tell it: ‚ÄúIf you see that someone wants to load many locales, because they cannot determine which, take only Russian!‚Äù <br><br><img src="https://habrastorage.org/getpro/habr/post_images/587/fe6/e38/587fe6e38333e8b482fed615e3c00ee1.png" alt="image"><br><br>  Webpack will take only Russian, and WebpackBundleAnalyzer will show 54 Kb, which is already 200 Kb easier. <br><br><h3>  Dead code elimination </h3><br>  The next optimization that interests us is <strong>Dead code elimination</strong> .  Consider the following code. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cond = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cond) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; someFunction(<span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre><br>  Most of the lines from this code are not needed in the final bundle - the block with the condition is not executed, the function after return is also not.  All you need to leave is <code>return true</code> .  This is precisely Dead code elimination: the build tool detects code that cannot be executed and cuts it.  There is a nice feature that UglifyJS can do this. <br><br>  We now turn to a more advanced method Dead code elimination - <strong>Tree shaking</strong> . <br><br><h3>  Tree shaking </h3><br>  Suppose we have an application that uses <strong>Lodash</strong> .  I strongly doubt that anyone is applying the whole Lodash.  Most likely, several functions such as <strong>get</strong> , <strong>IsEmpty</strong> , <strong>unionBy</strong> or similar are being <strong>exploited</strong> . <br><br>  When we do Tree shaking, we want Webpack to ‚Äúshake‚Äù unnecessary modules and throw them out, and we only have the necessary ones left.  This is Tree shaking. <br><br><h4>  How tree shaking works in webpack </h4><br>  Suppose you have this code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { a } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./a.js'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a);</code> </pre><br>  The code is very simple: import a variable from some module and output it.  But in this module there are two variables: <strong>a</strong> and <strong>b</strong> .  We do not need the variable <b>b</b> , and we want to remove it. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre><br>  When the Webpack comes, it converts the code with the import into this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(d[<span class="hljs-string"><span class="hljs-string">"a"</span></span>]);</code> </pre><br>  Our <code>import</code> turned into <code>require</code> , and <code>console.log</code> not changed. <br><br>  The Webpack dependency converts to the following code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports[<span class="hljs-string"><span class="hljs-string">"a¬´] = a; /* unused harmony export b */ var b = 4;</span></span></code> </pre><br><br>  Webpack left the export variable <b>a</b> , and removed the export variable <b>b</b> , but left the variable itself, marking it with a special comment.  In the converted code, the variable <b>b is</b> not used, and UglifyJS can remove it. <br><br><blockquote>  Tree shaking in a Webpack only works if you have some kind of code minifiers, for example, UglifyJS or <b><a href="https://github.com/babel/minify">babel-minify</a></b> . </blockquote><br>  Consider the cases more interesting - when the Tree shaking does not work. <br><br><h4>  When tree shaking is not working </h4><br>  Case number 1. You write code: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.a = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.b = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br>  Run the code through the Webpack, and it remains the same.  That's because the bandler organizes Tree shaking only if you are using ES6 modules.  If you use CommonJS modules, the Tree shaking will not work. <br><br>  Case number 2. You write code with ES6 modules and named exports. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre><br>  If your code runs through Babel and you have not set the <a href="https://babeljs.io/docs/en/babel-preset-env">modules</a> option <a href="https://babeljs.io/docs/en/babel-preset-env">to false</a> , then Babel will lead your modules to CommonJS, and Webpack will not be able to perform Tree shaking again, because it only works with ES6 modules. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.a = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.b = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br>  Accordingly, we need to be sure that no one in our assembly plan will transport the ES6 modules. <br><br>  Case number 3. Suppose we have such a useless class that does nothing: <code>export class ShakeMe {}</code> .  Moreover, we still do not use it.  When Webpack goes through imports and exports, Babel will turn the class into a function, and the bundler will note that the function is not used: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* unused harmony e[port b */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ShakeMe = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShakeMe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ babelHelpers.classCallCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, ShakeMe); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ShakeMe; }();</code> </pre><br>  It seems everything should be fine, but if we look closely, we will see that inside this function there is a global variable <code>babelHelpers</code> , from which some function is called.  This is the <b>side effect</b> : UglifyJS sees that some global function is called and will not cut out the code, because it is afraid that something will break. <br><br>  When you write classes and run them through Babel, they are never cut out.  How is this fixed?  There is a standardized hack - add a comment <code>/*#__PURE__*/</code> before the function: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* unused harmony export b */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ShakeMe = <span class="hljs-comment"><span class="hljs-comment">/*#__PURE__*/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShakeMe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ babelHelpers.classCallCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, ShakeMe); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ShakeMe; }();</code> </pre><br>  Then UglifyJS will take the word that the following function is pure.  Fortunately, <b><a href="">Babel 7</a></b> is doing this right now, and Babel 6 is still not deleting anything. <br><br><blockquote>  The rule is: if you have a side effect somewhere, UglifyJS will not do anything. </blockquote><br>  Let's sum up: <br><br><ul><li>  <b>Tree shaking does not work for most libraries from npm</b> , because they are all from CommonJS and are collected by old Babel. </li><li>  Most likely, <b>Tree shaking will work adequately for those libraries that are already prepared for this</b> , for example, Lodash-es, Date-fns, and your code or libraries. </li><li>  UglifyJS is involved in the build. </li><li>  ES6 modules are used. </li><li>  No side effects. </li></ul><br>  We figured out how to reduce the weight of the bundle, and now let's teach it to load only the necessary functionality. <br><br><h3>  We load only the necessary functionality. </h3><br>  This part is divided into two.  In the first part, <b>only the code that the user requires is downloaded</b> : if the user visits the main page of your site, he does not load the pages of the personal account.  In the second, <b>edits in the code lead to the lowest possible reload of resources</b> . <br><br><h4>  We load only the necessary code. </h4><br>  Consider the structure of an imaginary application.  He has: <br><br><ul><li>  Entry point - APP. </li><li>  Three pages: home, search and card. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/872/142/14e/87214214e5fc6514a1a72cb20f6be4b2.png" alt="image"><br><br>  The first problem we want to solve is <b>making the common code</b> .  Denote by red square the common code for all pages, green circle for the main page and the search page.  The remaining figures are not particularly important. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/854/ec8/80f/854ec880feff7813d267ca834209db71.png" alt="image"><br><br>  When the user comes to search from the main page, he will reload the square and circle a second time, although he already has them.  Ideally, we would like to see about that. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b75/290/36d/b7529036de4cf6923a279666d00ca297.png" alt="image"><br><br>  It's good that Webpack 4 already has a built-in plugin that does it for us - <a href="https://webpack.js.org/plugins/split-chunks-plugin/">SplitChunksPlugin</a> .  The plug-in takes out the application code or the node modules code, which is used by several chunks in a separate chunk, while ensuring that the common-code chunk will be more than 30 Kb, and for the page load no more than 5 chunks are required to load.  The strategy is optimal: too small chunks are unprofitable to load, and downloading too many chunks is <a href="http2.htm">long and not as effective</a> as downloading fewer chunks even on http2.  To repeat this behavior on 2 or 3 versions of the Webpack, you had to write 20-30 lines with not documented features.  Now it is solved in one line. <br><br><h4>  Takeout CSS </h4><br>  It would be great if we also rendered the CSS for each chunk to a separate file.  For this there is a ready-made solution - <b><a href="https://github.com/webpack-contrib/mini-css-extract-plugin">Mini-Css-Extract-Plugin</a></b> .  The plugin appeared only in Webpack 4, but before it there were no adequate solutions for this task - only khaki, pain and shot through legs.  The plugin <b>takes CSS out of asynchronous chunks</b> and was created <b>specifically for this task</b> , which it performs perfectly. <br><br><h4>  Minimally possible reloading of resources </h4><br>  Let us figure out how to make sure that when we release, for example, a new promo block on the main page, the user <b>would reload the minimum possible part of the code</b> . <br><br>  If we had versioning, everything would be fine.  Here we have the main page of version N, and after the release of the promotional block - version N + 1.  Webpack provides a similar mechanism right out of the box using hashing.  After the Webpack collects all assets, - in this case, app.js, - then it counts its content hash, and adds it to the file name to make the app. [Hash] .js.  This is the <b>versioning</b> that we need. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd1/3f2/1a9/fd13f21a9daeddd3a1af9083b8134257.png" alt="image"><br><br>  Let's now check how it works.  Turn on the hashes, edit the main page, and see if the code of the main page really changed. We‚Äôll see that two files have changed: main and app.js. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a2/bc0/b44/2a2bc0b447b7baf927ac729e28ace633.png" alt="image"><br><br>  Why did this happen, because it is illogical?  To understand why, let's <b>break down app.js.</b>  It consists of three parts: <br><br><ul><li>  application code; </li><li>  webpack runtime; </li><li>  links to asynchronous chunks. </li></ul><br>  When we change the code in main, its content and hash change, which means that the <b>link</b> to it also changes in the app.  The app itself will also change and you need to restart it.  The solution to this problem is to <b>divide</b> app.js into two chunks: application code and webpack runtime and links to asynchronous chunks.  Webpack 4 does everything for us with one <b>runtimeChunk</b> option, which weighs very little ‚Äî less than 2 KB in gzip.  Restarting it for the user is almost worthless.  RuntimeChunk is enabled with just one option: <br><br><pre> <code class="javascript hljs">optimization: { <span class="hljs-attr"><span class="hljs-attr">runtimeChunk</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre><br>  In Webpack 3 and 2, we would write 5-6 lines, instead of one.  It is not much more, but still superfluous inconvenience. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e4/125/5d8/6e41255d837ac2a5c4bb8a6e9b74f686.png" alt="image"><br><br>  Everything is great, we learned to make links and runtime!  Let's write a new module in main, release, and - op!  - now everything is rebooted. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc7/8f6/a5f/cc78f6a5f6ffcd8b2da956d5463fefc8.png" alt="image"><br><br>  Why is that?  Let's see how the modules work in the webpack. <br><br><h4>  Modules in webpack </h4><br>  Suppose there is a code in which you add the modules <b>a</b> , <b>b</b> , <b>d</b> and <b>e</b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'b'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'d'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span>;</code> </pre><br>  Webpack converts imports to require: <b>a</b> , <b>b</b> , <b>d,</b> and <b>e</b> replaced by require (0), require (1), require (2), and require (3). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> e = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre><br>  Imagine a picture that happens very often: you write a new module c <code>import c from 'c';</code>  and insert it somewhere in the middle: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'b'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'c'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'d'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span>;</code> </pre><br>  When Webpack processes everything, it will convert the import of a new module to require (2): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> e = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre><br>  Modules <b>d</b> and <b>e</b> , which were 2 and 3, will receive the digits 3 and 4 - the new id.  A simple conclusion follows from this: using sequence numbers like id is a bit silly, but Webpack does. <br><br><blockquote>  Do not use the sequence number as a unique id. </blockquote><br>  To fix the problem, there is a built-in Webpack solution - <b>HashedModuleIdsPlugin</b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> webpack.HashedModuleIdsPlugin({ <span class="hljs-attr"><span class="hljs-attr">hashFunction</span></span>: <span class="hljs-string"><span class="hljs-string">'md4‚Ä≤, hashDigest:'</span></span>base64‚Ä≤, <span class="hljs-attr"><span class="hljs-attr">hashDigestLength</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, }),</code> </pre><br>  This plugin instead of numeric id uses 4 characters <b>md4-hash</b> from the absolute path to the file.  With him, our require will turn into such: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'YmRl'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'N2Fl'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'OWE4‚Ä≤); var d = require('</span></span>NWQz<span class="hljs-string"><span class="hljs-string">'); var e = require('</span></span>YWVj<span class="hljs-string"><span class="hljs-string">');</span></span></code> </pre><br>  Instead of numbers, letters appeared.  Of course, there is a hidden problem - this is a <b>hash collision</b> .  We stumbled upon it once and can advise you to use 8 characters, instead of 4. Having configured the hashes correctly, everything will work as we originally wanted. <br><br>  We now know how to collect a dream bundle. <br><br><ul><li>  <b>Minify</b> . </li><li>  <b>Use code-split</b> . </li><li>  <b>Configure hashes</b> . </li></ul><br>  We've learned how to collect, and now let's work on speed. <br><br><h2>  How to build a dream bundle <b>quickly</b> ? </h2><br>  In our N1.RU, the largest application consists of 10,000 modules and is going to be 28 minutes without optimizations.  We were able to speed up the build up to two minutes!  How did we do it?  There are 3 ways to speed up any calculations, and all three are applicable to the Webpack. <br><br><h3>  Assembly parallelization </h3><br>  The first thing we did was <b>parallelize the build</b> .  For this we have: <br><br><ul><li>  <b><a href="https://github.com/amireh/happypack">HappyPackPlugin</a></b> , which wraps your loaders in other loaders, and puts all the calculations that are wrapped into separate processes.  This allows, for example, to parallelize Babel and node-sass. </li><li>  <b><a href="https://github.com/webpack-contrib/thread-loader">thread-loader</a></b> .  Performs approximately the same as HappyPackPlugin, only uses not processes, but thread pool.  Switching to a separate thread is a costly operation, use it carefully, and only if you want to wrap up resource-intensive and heavy operations, such as babel or node-sass.  To load json, for example, parallelization is not needed, because it loads quickly. </li><li>  In the plugins and loaders you use, most likely, there are already <b>built-in parallelization tools</b> - just look.  For example, this option is in <a href="https://github.com/webpack-contrib/uglifyjs-webpack-plugin">UglifyJS</a> . </li></ul><br><h3>  Caching build results </h3><br>  <b>Caching build results</b> is the most efficient way to speed up a Webpack build. <br><br>  The first solution we have is a <b><a href="https://github.com/webpack-contrib/cache-loader">cache-loader</a></b> .  This is a loader that gets into a chain of loaders and saves to the file system the result of assembling a specific file for a specific chain of loaders.  On the next build of the bundle, if this file is on the file system and has already been processed with this chain, the cache-loader will take the results and will not call those loaders behind them, for example, Babel-loader or node-sass. <br><br>  The graph shows the assembly time.  Blue bar - 100% build time, no cache loader, and with it - 7% slower.  This is because the cache-loader spends extra time saving caches to the file system.  Already on the second assembly, we received a tangible profit - the assembly was 2 times faster. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6bc/e73/210/6bce732104fda8263464528d91d1a8a1.png" alt="image"><br><br>  The second solution is more <b><a href="https://github.com/mzgoddard/hard-source-webpack-plugin">sophisticated</a></b> - <b><a href="https://github.com/mzgoddard/hard-source-webpack-plugin">HardSourcePlugin</a></b> .  The main difference: the cache-loader is just a loader, which can only operate in a chain of loaders with code or files, and HardSourcePlugin has almost complete access to the Webpack ecosystem, can operate with other plug-ins and loaders, and slightly expands the ecosystem for caching.  The graph above shows that on the first run the build time increased by 37%, but by the second run with all the caches we accelerated 5 times. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb6/acf/d36/cb6acfd36adbaaadffd68af19889f960.png" alt="image"><br><br>  The best part is that you can use both solutions together, which we are doing in N1.RU.  Be careful, because there are problems with caches, which I will discuss later. <br><br>  In the plugins / loaders you already use, there may be <b>built-in caching mechanisms</b> .  For example, the <a href="https://github.com/babel/babel-loader">babel-loader is a</a> very efficient caching system, but for some reason it is turned off by default.  The same functionality is in <a href="https://github.com/s-panferov/awesome-typescript-loader">awesome-typeScript-loader</a> .  The <a href="https://github.com/webpack-contrib/uglifyjs-webpack-plugin">UglifyJS</a> plugin also has caching, which works great.  He sped us for a few minutes. <br><br>  And now the problems. <br><br><h4>  Caching problems </h4><br><ul><li>  The cache may <b>not be validated correctly</b> . </li><li>  Applied solutions may <b>not work with connected plug-ins, loaders, your code or with each other</b> .  In this regard, the cache-loader is a simple and problem-free solution.  But with HardSourcePlugin you need to be more careful. </li><li>  <b>It is difficult to debug if everything is broken</b> .  When caching works incorrectly and an incomprehensible error occurs, it will be very difficult to figure out what the problem is. </li></ul><br><h3>  What to save in production? </h3><br>  The last way to speed up a process is to not do any part of the process.  Let's think about what can be saved in production?  What can we not do?  The answer is short - <b>we can do nothing</b> !  We have no right to refuse something in production, but we can save well in <b>dev</b> . <br><br>  What to save: <br><br><ul><li>  <b>Do not collect the source map</b> until we need them. </li><li>  <b>Use the style-loader</b> instead of a cool scheme with the removal of css and processing through css-loaders.  The style-loader itself is very fast, because it takes the css line and drives it into a function that inserts this line into the style tag. </li><li>  <b>You can leave only the browser you specifically use in your browserlist - most likely it is the last chrome</b> .  <a href="https://www.smashingmagazine.com/2018/10/smart-bundling-legacy-code-browsers/">This will greatly accelerate</a> . </li><li>  <b>Completely refuse any resource optimization</b> : from UglifyJS, css-nano, gzip / brotli. </li></ul><br><blockquote>  Accelerating an assembly is parallelization, caching, and rejecting calculations.  By completing these three simple steps, you can accelerate very much. </blockquote><br><h2>  How to configure a webpack? </h2><br>  We figured out how to build a dream bundle and how to assemble it quickly, and now let's figure out how to configure the Webpack, so as not to shoot yourself in the foot every time you change the config. <br><br><h3>  Evolution of the config in the project </h3><br>  A typical webpack configuration path in a project begins with a <b>simple</b> config.  First you just insert the webpack, babel-loader, sass-loader and all is well.  Then, unexpectedly, some <b>conditions</b> appear <b>on process.env</b> , and you insert conditions.  One, second, third, more and more, until a condition is added with a ‚Äúmagic‚Äù option.  You understand that everything is already very bad, and it is better to just <b>duplicate the configs</b> for dev and production, and edit twice.  Everything will be clearer.  If your thought flashed: ‚ÄúIs something wrong here?‚Äù, Then the only working advice is <b>to keep the config in order</b> .  I'll tell you how we do it. <br><br><h3>  Keep config fine </h3><br>  We use <b><a href="https://github.com/survivejs/webpack-merge">webpack-merge</a></b> package.  This is an npm-package, which is created to merge several configs into one.  If you are not satisfied with the default merge strategy, you can customize. <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The structure of the project with the config </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We have 4 main folders: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Loaders. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plugins. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Presets. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parts. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I'll tell you about each separately. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plugin / Loader </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> These are folders that contain files for each loader and plug-in, with detailed documentation and more human APIs than those provided by plugin and loader developers. </font></font><br><br>  It looks like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *  JSdoc * @param {Object} options * @see    */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPlugin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Plugin(options); };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a module, it exports a function that has options, and there is documentation. </font><font style="vertical-align: inherit;">In words it looks good, but in reality our docks to the url-loader look like this:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * url-loader    file-loader.        * * @example * -   some-image.png.     url-loader,  url-loader    * 1.    ,  url-loader    base64  * 2. , url-loader    outputPath + name     ,     . *    some-image.png,     outputPath/images/some-image.12345678hash.png,  url-loader  * publicPath/images/some-image.12345678hash.png * * @param {string} prefix    * @param {number} limit    ,    * @return {Object} loader   * @see https://www.npmjs.com/package/url-loader */</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We tell in a simple form what it does, how it works, describe which parameters accept functions, what the loader creates, and give a link to the docks. </font><font style="vertical-align: inherit;">I hope that the one who comes here will understand exactly how the url-loader works. </font><font style="vertical-align: inherit;">The function itself looks like this:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">urlLoader</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prefix = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'assets'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, limit = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">loader</span></span>: <span class="hljs-string"><span class="hljs-string">'url-loader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">options</span></span>: { limit, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${prefix}</span></span></span><span class="hljs-string">/[name].[hash].[ext]`</span></span> } }; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We take two parameters and return the description from the loader. </font><font style="vertical-align: inherit;">Do not be afraid that the Loader folder will be cumbersome and each file will have a file.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Preset </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a set of webpack options. </font><font style="vertical-align: inherit;">They are responsible for one functionality, while operating with loaders and plug-ins, which we have already described, and the webpack settings that it has. </font><font style="vertical-align: inherit;">The simplest example is a preset that tells you how to load scss files correctly:</font></font><br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\.scss$/</span></span>, <span class="hljs-attr"><span class="hljs-attr">use</span></span>: [cssLoader, postCssLoader, scssLoader] }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> He uses already prepared loaders. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The parts are what is already in the application itself. </font><font style="vertical-align: inherit;">They configure the entry and exit points of your application, and can adjust or connect specific plugins, loaders and options. </font><font style="vertical-align: inherit;">A typical example where we declare an entry and exit point:</font></font><br><br><pre> <code class="javascript hljs">entry: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: <span class="hljs-string"><span class="hljs-string">'./src/Frontend/app.js'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">output</span></span>: { <span class="hljs-attr"><span class="hljs-attr">publicPath</span></span>: <span class="hljs-string"><span class="hljs-string">'/static/cabinet/app/'</span></span>, <span class="hljs-attr"><span class="hljs-attr">path</span></span>: path.resolve(<span class="hljs-string"><span class="hljs-string">'www/static/app'</span></span>) },</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In our practice we use: </font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The base preset</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in which we describe how to load templates, json, which plugins should always be used, for example, splitChunks.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Preset for dev</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which describes how to properly load js / css and plugins for optimization</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Part</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which describes the output, publicPath, entry-point, and some specific rules, for example, how the source map is rewritten separately.</font></font></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/7ee/20f/fa6/7ee20ffa6f453c35f11d92e3583d8caf.png" alt="image"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Webpack-merge</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> just gives us a ready config. </font><font style="vertical-align: inherit;">With this approach, we always have documentation for the configuration, which is easy enough to understand. </font><font style="vertical-align: inherit;">With webpack-merge we do not climb 3-7 configs to fix Babel-loader everywhere, because we have a consistent configuration of individual parts throughout the project. </font><font style="vertical-align: inherit;">And it is also intuitively clear where to edit.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Config management </font></font></h3><br>  Let's sum up. <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use ready-made tools</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and do not build bicycles. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Document the solutions</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , because webpack configs are rarely ruled by different people - so the documentation is very important there. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separate and reuse</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> what you write. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now you know how to build a dream bundle!</font></font><br><br><blockquote>   ‚Äî     <a href="https://frontendconf.ru/">Frontend Conf</a> . ,    ‚Äî  <a href="https://onticolist.us8.list-manage.com/subscribe%3Fu%3D719c4e65585ea6013f361815e%26id%3Db6209f5edf"> </a> ,           ,    <a href="https://frontendconf.ru/moscow-rit/2019">Frontend Conf ++</a>  . <br><br>    -      ?    <a href="https://frontendconf.ru/moscow-rit/2019">FrontenConf ++</a> ,   27  28   . <a href="https://conf.ontico.ru/users/login.html%3Furl%3D/lectures/propose"> </a>  27 ,   15          .     ‚Äî ! </blockquote></div><p>Source: <a href="https://habr.com/ru/post/433324/">https://habr.com/ru/post/433324/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../433308/index.html">Transferring PBX configuration to 3CX PBX Express service</a></li>
<li><a href="../433316/index.html">Design Digest: onboarding, feedback, search for ideas and decision making</a></li>
<li><a href="../433318/index.html">garbage.collect ()</a></li>
<li><a href="../433320/index.html">Grid Layout as the basis of modern layouts</a></li>
<li><a href="../433322/index.html">JSON API - we work according to the specification</a></li>
<li><a href="../433330/index.html">Solving Japanese Crosswords with SAT Solver</a></li>
<li><a href="../433332/index.html">Python support in Azure Functions</a></li>
<li><a href="../433334/index.html">XAML Behaviors for WPF is now open source</a></li>
<li><a href="../433336/index.html">Implementation of the Babylon Library</a></li>
<li><a href="../433338/index.html">Creality 3D 3D Printer Manufacturer Overview</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>