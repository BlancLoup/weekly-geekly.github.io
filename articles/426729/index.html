<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>TypeScript magic school: generics and type extensions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The author of the article, the translation of which we are publishing today, says that TypeScript is simply amazing. When he first started using TS, h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>TypeScript magic school: generics and type extensions</h1><div class="post__text post__text-html js-mediator-article"> The author of the article, the translation of which we are publishing today, says that TypeScript is simply amazing.  When he first started using TS, he terribly liked the freedom that is inherent in this language.  The more power a programmer puts into his work with TS-specific mechanisms, the more significant his benefits are.  Then he used type annotations only periodically.  Sometimes he used the code auto-completion capabilities and compiler hints, but mostly relied only on his own vision of the problems he was solving. <br><br>  Over time, the author of this material realized that every time he bypasses the errors detected at the compilation stage, he lays in his code a time bomb that can explode during program execution.  Every time he ‚Äústruggled‚Äù with errors, using the simple <code>as any</code> construction, he had to pay for this with many hours of hard debugging. <br><br> <a href="https://habr.com/company/ruvds/blog/426729/"><img src="https://habrastorage.org/webt/8x/yn/4p/8xyn4p7bv34meq9s1o9k1i-hy0e.jpeg"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the end, he concluded that it is better not to do so.  He became friends with the compiler, began to pay attention to his tips.  The compiler finds problems in the code and reports them long before they can cause real harm.  The author of the article, looking at himself as a developer, realized that the compiler is his best friend, since he protects him from himself.  How not to recall the words of Albus Dumbledore: ‚ÄúIt takes a lot of courage to take a stand against its enemies, but not less it takes a lot to take a stand against its friends.‚Äù <br><br>  No matter how good the compiler is, it‚Äôs not always easy to please.  Sometimes avoiding the use of the <code>any</code> type is very difficult.  And sometimes it seems that <code>any</code> is the only reasonable solution to a certain problem. <br><br>  This material is dedicated to two situations.  By avoiding the use of the <code>any</code> type in them, you can ensure the type safety of the code, open up opportunities for its reuse and make it intuitive. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Generics</font> </h2><br>  Suppose we are working on a database of a certain educational institution.  We have written a very <code>getBy</code> helper function.  In order to get an object representing a student by its name, we can use the command like <code>getBy(model, "name", "Harry")</code> .  Take a look at the implementation of this mechanism (here, in order not to complicate the code, the database is represented by a regular array). <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Student = { <span class="hljs-type"><span class="hljs-type">name</span></span>: string; age: number; hasScar: <span class="hljs-type"><span class="hljs-type">boolean</span></span>; }; const students: Student[] = [ { <span class="hljs-type"><span class="hljs-type">name</span></span>: "Harry", age: <span class="hljs-number"><span class="hljs-number">17</span></span>, hasScar: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> }, { <span class="hljs-type"><span class="hljs-type">name</span></span>: "Ron", age: <span class="hljs-number"><span class="hljs-number">17</span></span>, hasScar: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> }, { <span class="hljs-type"><span class="hljs-type">name</span></span>: "Hermione", age: <span class="hljs-number"><span class="hljs-number">16</span></span>, hasScar: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> } ]; <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> getBy(model, prop, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(item =&gt; item[prop] === <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>] }</code> </pre> <br>  As you can see, we have a good function, but it does not use type annotations, and their absence also means that such a function cannot be called type safe.  Fix it. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">model: Student[], prop: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">): Student | </span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-literal">null</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.filter(item =&gt; item[prop] === <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || <span class="hljs-literal"><span class="hljs-literal">null</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = getBy(students, <span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hermione"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// result: Student</span></span></code> </pre> <br>  So our function already looks much better.  The compiler now knows the type of result expected from it, it will be useful to us later.  However, in order to achieve safe working with types, we donated features to reuse the function.  What if we ever need to use it to get some other entity?  It cannot be that this function cannot be improved in any way.  And indeed it is. <br><br>  In TypeScript, as well as in other languages ‚Äã‚Äãwith strict typification, we can use generics, which are also called ‚Äúgeneric types‚Äù, ‚Äúuniversal types‚Äù, ‚Äúgeneralizations‚Äù. <br><br>  A generic is similar to a regular variable, but instead of a certain value, it contains a type definition.  We rewrite the code of our function so that instead of the type <code>Student</code> it would use the universal type <code>T</code> <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBy</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">model: T[], prop: string, value</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function"> =&gt;</span></span> item[prop] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = getBy&lt;Student&gt;(students, <span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hermione"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// result: Student</span></span></code> </pre> <br>  Beauty!  Now the function is ideal for reuse while the type safety is still on our side.  Notice how in the last line of the above code snippet, the type <code>Student</code> explicitly set where generic <code>T</code> .  This is done to make the example as clear as possible, but the compiler, in fact, can independently deduce the required type, so in the following examples we will not make such type specifications. <br><br>  So now we have a reliable auxiliary function suitable for reuse.  However, it can still be improved.  What if an error is made when entering the second parameter and instead of <code>"name"</code> there will be <code>"naem"</code> ?  The function will behave as if the desired student is simply not in the database, and, most worryingly, will not give any errors.  This can lead to long-term debugging. <br><br>  In order to protect against such errors, we introduce another universal type, <code>P</code>  In this case, it is necessary that <code>P</code> be a key of type <code>T</code> , therefore, if the type of <code>Student</code> used here, then it is necessary that <code>P</code> be the string <code>"name"</code> , <code>"age"</code> or <code>"hasScar"</code> .  Here's how to do it. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> getBy&lt;T, P extends keyof T&gt;(model: T[], prop: P, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): T | <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(item =&gt; item[prop] === <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } const result = getBy(students, "naem", "Hermione") // Error: Argument <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'"naem"'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> assignable <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parameter <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'"name" | "age" | "hasScar"'</span></span>.</code> </pre> <br>  Using generics and the <code>keyof</code> is a very powerful technique.  If you are writing programs to an IDE that supports TypeScript, then by entering arguments, you can take advantage of the auto-completion features, which is very convenient. <br><br>  However, we have not yet completed work on the <code>getBy</code> function.  It has a third argument, the type of which we have not yet specified.  It does not suit us at all.  Until now, we could not know in advance about what type it should be, since it depends on what we pass as the second argument.  But now, since we have type <code>P</code> , we can dynamically infer the type for the third argument.  The type of the third argument will be <code>T[P]</code> .  As a result, if <code>T</code> is <code>Student</code> , and <code>P</code> is <code>"age"</code> , then <code>T[P]</code> will correspond to the <code>number</code> type. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> getBy&lt;T, P extends keyof T&gt;(model: T[], prop: P, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: T[P]): T | <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(item =&gt; item[prop] === <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } const result = getBy(students, "age", "17") // Error: Argument <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'"17"'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> assignable <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parameter <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'number'</span></span>. const anotherResult = getBy(students, "hasScar", "true") // Error: Argument <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'"true"'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> assignable <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parameter <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'boolean'</span></span>. const yetAnotherResult = getBy(students, "name", "Harry") //     </code> </pre> <br>  I hope that now you have formed a completely clear understanding of how to use generics in TypeScript, but if you want to learn everything very well, you want to experiment with the code reviewed here, you can look <a href="https://www.typescriptlang.org/play/index.html">here</a> . <br><br><h2>  <font color="#3AC1EF">Extending existing types</font> </h2><br>  Sometimes we may encounter the need to add data or functionality to interfaces, the code of which we cannot change.  You may need to change the standard object, say, add some property to the <code>window</code> object, or extend the behavior of some external library like <code>Express</code> .  Both in that and in other cases you have no opportunity to directly influence the object with which you want to work. <br><br>  We will look at solving a similar problem using the example of adding the <code>getBy</code> function you already know to the <code>Array</code> prototype.  This will allow us, using this function, to build more accurate syntactic constructions.  At the moment we are not talking about whether it is good or bad to expand standard objects, since our main goal is to study the approach under consideration. <br><br>  If we try to add a function to the <code>Array</code> prototype, the compiler will not like it very much: <br><br><pre> <code class="hljs coffeescript">Array.prototype.getBy = function &lt;T, P extends keyof T&gt;(   this: T[],   prop: P,   value: T[P] ): T | <span class="hljs-literal"><span class="hljs-literal">null</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.filter(item =&gt; item[prop] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Error: Property <span class="hljs-string"><span class="hljs-string">'getBy'</span></span> does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> exist <span class="hljs-literal"><span class="hljs-literal">on</span></span> type <span class="hljs-string"><span class="hljs-string">'any[]'</span></span>. const bestie = students.getBy(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Ron"</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Error: Property <span class="hljs-string"><span class="hljs-string">'getBy'</span></span> does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> exist <span class="hljs-literal"><span class="hljs-literal">on</span></span> type <span class="hljs-string"><span class="hljs-string">'Student[]'</span></span>. const potionsTeacher = (teachers <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> any).getBy(<span class="hljs-string"><span class="hljs-string">"subject"</span></span>, <span class="hljs-string"><span class="hljs-string">"Potions"</span></span>) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ...   ?</code> </pre> <br>  If we try to reassure the compiler, periodically using the <code>as any</code> construct, we negate everything we have achieved.  The compiler will be silent, but you can forget about safe work with types. <br><br>  It would be better to extend the <code>Array</code> type, but before doing this, let's talk about how TypeScript handles situations of presence in the code of two interfaces of the same type.  Here is a simple scheme of action.  Ads will, if possible, be merged.  If you can not combine them - the system will give an error. <br><br>  So this code works: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Wand</span></span> { length: number } <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Wand</span></span> {   core: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myWand: Wand = { length: <span class="hljs-number"><span class="hljs-number">11</span></span>, core: <span class="hljs-string"><span class="hljs-string">"phoenix feather"</span></span> } <span class="hljs-comment"><span class="hljs-comment">//  !</span></span></code> </pre> <br>  And this one is not: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Wand</span></span> { length: number } <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Wand</span></span> {   length: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-comment"><span class="hljs-comment">// Error: Subsequent property declarations must have the same type.  Property 'length' must be of type 'number', but here has type 'string'.</span></span></code> </pre> <br>  Now, having dealt with this, we see that we are faced with a rather simple task.  Namely, all we have to do is declare the <code>Array&lt;T&gt;</code> interface and add the <code>getBy</code> function to it. <br><br><pre> <code class="hljs pgsql">interface <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>&lt;T&gt; {  getBy&lt;P extends keyof T&gt;(prop: P, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: T[P]): T | <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>.prototype.getBy = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> &lt;T, P extends keyof T&gt;(   this: T[],   prop: P,   <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: T[P] ): T | <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(item =&gt; item[prop] === <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }; const bestie = students.getBy("name", "Ron"); //   ! const potionsTeacher = (teachers <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>).getBy("subject", "Potions") //    </code> </pre> <br>  Note that you will probably write most of the code in the module files, so in order to make changes to the <code>Array</code> interface, you will need access to the global scope.  This can be done by putting the type definition inside <code>declare global</code> .  For example - so: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> {   interface <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>&lt;T&gt; {       getBy&lt;P extends keyof T&gt;(prop: P, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: T[P]): T | <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;   } }</code> </pre> <br>  If you are going to expand the interface of an external library, then you will most likely need access to the <code>namespace</code> this library.  Here is an example of how to add the <code>userId</code> field to the <code>Request</code> from the <code>Express</code> library: <br><br><pre> <code class="hljs cs">declare <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Express</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Request</span></span> {     userId: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;   } } }</code> </pre> <br>  You can experiment with the code in this section <a href="https://www.typescriptlang.org/play/index.html">here</a> . <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  In this article, we looked at techniques for using generics and type extensions in TypeScript.  We hope that what you learned today will help you in writing reliable, understandable and type-safe code. <br><br>  <b>Dear readers!</b>  How do you feel about type in TypeScript? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/426729/">https://habr.com/ru/post/426729/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426719/index.html">Hackathon on Data Science in SIBUR: how it was</a></li>
<li><a href="../426721/index.html">Avoiding Fails in Product Development: 10 Tips from Rookee</a></li>
<li><a href="../426723/index.html">Microsoft partners are hoping to create a time capsule on the moon</a></li>
<li><a href="../426725/index.html">How to do things when they do not want to do</a></li>
<li><a href="../426727/index.html">Eme? CDM? DRM? CENC? IDK! What you need to make your own video player in the browser</a></li>
<li><a href="../426731/index.html">CSS: interesting border-radius features</a></li>
<li><a href="../426733/index.html">Iron will not fail. How I prepare dozens of servers a day for a fight</a></li>
<li><a href="../426735/index.html">Welcome to the JETHACK hackathon</a></li>
<li><a href="../426737/index.html">Briefly about the architecture of neuromorphic processors: a view from the inside</a></li>
<li><a href="../426739/index.html">Proxy files from AWS S3 using nginx</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>