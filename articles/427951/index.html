<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Testing an application on Go as a black box using Rspec</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Well-written tests significantly reduce the risk of ‚Äúbreaking‚Äù the application when adding a new feature or fixing an error. In complex systems consis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Testing an application on Go as a black box using Rspec</h1><div class="post__text post__text-html js-mediator-article">  Well-written tests significantly reduce the risk of ‚Äúbreaking‚Äù the application when adding a new feature or fixing an error.  In complex systems consisting of several interconnected components, the most difficult is to test their points of contact. <br><br>  In this article, I will talk about how we faced the difficulty of writing good tests while developing a component on Go and how we solved this problem using the RSpec library in Ruby on Rails. <br><a name="habracut"></a><br><h2>  Adding Go to the project's technological stack </h2><br>  One of the projects developed by eTeam, where I work, can be divided into: admin area, user account, report generator, and request processing from various services with which we are integrated. <br><br>  The part responsible for processing requests is most important, so I wanted to make it as reliable and accessible as possible.  As part of a monolithic application, she risked getting a bug when changing unrelated areas of code.  There was also a risk of dropping processing while loading other components of the application.  The number of Ngnix workers on an application is limited, and as the load increases, for example, opening many heavy pages in the admin area, free workers ended and the processing of requests slowed down, or even completely dropped. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      These risks, as well as the maturity of this system (for months it did not have to make changes in it) made it an ideal candidate for allocation to a separate service. <br>  This separate service was decided to write on Go.  He had to share access to the database with the Rails application.  Responsibility for possible changes to the table structure remained with Rails.  In principle, such a scheme with a common database works well, while there are only two applications.  It looked like this: <br><br><img src="https://habrastorage.org/webt/67/19/wy/6719wyo52lzxj3ofrjy4epnitjq.png" alt="image"><br><br>  The service was written and deployed to separate Rails instances.  Now, with the Rails deployment, it was possible not to worry that this would affect the processing of requests.  The service accepted HTTP requests directly, without Ngnix, used little memory, was in some way minimalistic. <br><br><h2>  The problem with our unit tests in Go </h2><br>  In the Go application, unit tests were implemented, and all requests to the database were locked.  Among other arguments in favor of such a decision was the following: the main Rails application is responsible for the database structure, so the go-application does not ‚Äúown‚Äù the information for creating the test database.  The processing of requests for half consisted of business logic and half of the work with the base, and this half was completely locked.  Mocks in Go look less ‚Äúreadable‚Äù than in Ruby.  When adding a new function to read data from the database, it was necessary to add moki for it to the set of fallen tests that worked before.  As a result, such unit tests were ineffective and extremely fragile. <br><br><h2>  Solution Method </h2><br>  To eliminate these shortcomings, it was decided to cover the service with functional tests hosted in a Rails application and test the service on Go as a black box.  As a white box, it would still not work, because from ruby, even with all the desire, it would be impossible to intervene in the service, for example, to wet some of its methods to check if it is being called.  It also meant that the requests sent by the service being tested are also impossible to lock, so another application is needed to capture and record them.  Something like RequestBin, but local.  We have already written a similar utility, so we used it. <br><br>  The following scheme turned out: <br><br><ol><li>  rspec compiles and runs the service on go, passing it a config, which registers access to the test database and some port for receiving HTTP requests, for example, 8082 </li><li>  also runs a utility to record incoming HTTP requests to it, on port 8083 </li><li>  write normal tests for RSpec, i.e.  we create the necessary data in the database and send a request to localhost: 8082, as if to an external service, for example using HTTParty </li><li>  parsim answer;  check changes in the database;  get the list of recorded requests from ‚ÄúRequestBin‚Äù and check them. </li></ol><br><h2>  Implementation details: </h2><br>  Now how it was implemented.  For the purpose of the demonstration, let's call the service being tested: ‚ÄúTheService‚Äù and create a wrapper for it: <br><br><pre><code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#/spec/support/the_service.rb #ensure that after all specs TheService will be stopped RSpec.configure do |config| config.after :suite do TheServiceControl.stop end end class TheServiceControl class &lt;&lt; self </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@pid</span></span></span><span class="hljs-comment"> = nil </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@config</span></span></span><span class="hljs-comment"> = nil def config puts "Please create file: #{config_path}" unless File.exist?(config_path) </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@config</span></span></span><span class="hljs-comment"> = YAML.load_file(config_path) end def host TheServiceControl.config['server']['addr'] end def config_path Rails.root.join('spec', 'support', 'the_service_config.yml') end def start # will be described below end def stop # will be described below end def post(params, headers) HTTParty.post("http://#{host}/request", body: params, headers: headers ) end end end</span></span></code> </pre> <br>  Just in case, I‚Äôll make a reservation that the Rspec should be configured to autoload the files from the ‚Äúsupport‚Äù folder: <br><br><pre> <code class="ruby hljs">Dir[Rails.root.join(<span class="hljs-string"><span class="hljs-string">'spec/support/**/*.rb'</span></span>)].each {<span class="hljs-params"><span class="hljs-params">|f|</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> f}</code> </pre><br>  ‚ÄúStart‚Äù method: <br><br><ul><li>  reads from the separate config the path to the source code for TheService and the information needed to run  Since  This information may differ from different developers, this config is excluded from Git.  The same config contains the settings required by the program being run.  These heterogeneous configs are in the same place just so as not to produce unnecessary files. <br></li><li>  compiles and runs the program via ‚Äúgo run {path to main.go} {path to config}‚Äù </li><li>  interrogating every second, waits until the running program is ready to accept requests <br></li><li>  remembers the process identifier in order not to restart and be able to stop it. </li></ul><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#/spec/support/the_service.rb class TheServiceControl #.... def start return unless </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@pid</span></span></span><span class="hljs-comment">.nil? puts "TheService starting. " env = config['rails']['env'] cmd = "go run #{config['rails']['main_go']} --config.file=#{config_path}" puts cmd #useful for debug when need run project manually #compile and run Dir.chdir(File.dirname(config['rails']['main_go'])) { </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@pid</span></span></span><span class="hljs-comment"> = Process.spawn(env, cmd, pgroup: true) } #wait until it ready to accept connections VCR.configure { |c| c.allow_http_connections_when_no_cassette = true } 1.upto(10) do response = HTTParty.get("http://#{host}/monitor") rescue nil break if response.try(:code) == 200 sleep(1) end VCR.configure { |c| c.allow_http_connections_when_no_cassette = false } puts "TheService started. PID: #{</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@pid</span></span></span><span class="hljs-comment">}" end #.... end</span></span></code> </pre><br>  config itself: <br><br><pre> <code class="hljs pgsql">#/spec/support/the_service_config.yml <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>: addr: <span class="hljs-number"><span class="hljs-number">127.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">8082</span></span> db: dsn: dbname=project_test sslmode=<span class="hljs-keyword"><span class="hljs-keyword">disable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>=postgres <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>=secret redis: url: redis://<span class="hljs-number"><span class="hljs-number">127.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">6379</span></span>/<span class="hljs-number"><span class="hljs-number">1</span></span> rails: main_go: /home/me/go/src/github.com/company/theservice/main.go recorder_addr: <span class="hljs-number"><span class="hljs-number">127.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">8083</span></span> env: <span class="hljs-type"><span class="hljs-type">PATH</span></span>: <span class="hljs-string"><span class="hljs-string">'/home/me/.gvm/gos/go1.10.3/bin'</span></span> GOROOT: <span class="hljs-string"><span class="hljs-string">'/home/me/.gvm/gos/go1.10.3'</span></span> GOPATH: <span class="hljs-string"><span class="hljs-string">'/home/me/go'</span></span></code> </pre><br>  The ‚Äústop‚Äù method simply stops the process.  Newans is that ruby ‚Äã‚Äãruns the ‚Äúgo run‚Äù command that runs the compiled binary in a child process whose ID is unknown.  If you simply stop a process started from ruby, the child process does not automatically stop and the port remains busy.  Therefore, the stop occurs by Process Group ID: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#/spec/support/the_service.rb class TheServiceControl #.... def stop return if </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@pid</span></span></span><span class="hljs-comment">.nil? print "Stopping TheService (PID: #{</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@pid</span></span></span><span class="hljs-comment">}). " Process.kill("KILL", -Process.getpgid(</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@pid</span></span></span><span class="hljs-comment">)) res = Process.wait </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@pid</span></span></span><span class="hljs-comment"> = nil puts "Stopped. #{res}" end #.... end</span></span></code> </pre><br>  Now let's prepare a shared_context in which we define variables by default, start TheService if it was not started, and temporarily disable the VCR (from his point of view we communicate to an external service, but for us now it is not quite like that): <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#spec/support/shared_contexts/the_service_black_box.rb shared_context 'the_service_black_box' do let(:params) do { type: 'save', data: 1 } end let(:headers) { { 'HTTPS' =&gt; 'on', 'Content-Type' =&gt; 'application/json; charset=utf-8' } } subject(:response) { TheServiceControl.post(params, headers)} before(:all) { TheServiceControl.start } around(:each) do |example| VCR.configure { |c| c.allow_http_connections_when_no_cassette = true } example.run VCR.configure { |c| c.allow_http_connections_when_no_cassette = false } end end</span></span></code> </pre><br>  and now you can start writing the specs themselves: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#spec/requests/the_service/ping_spec.rb require 'spec_helper' describe 'ping request' do include_context 'the_service_black_box' it 'returns response back' do params[:type] = 'ping' params[:data] = '123' parsed_response = JSON.parse(response.body) # make request and parse response expect(parsed_response['error']).to be nil expect(parsed_response['result']).to eq '123' expect(Log.count).to eq 1 #check something in DB end # more specs... end</span></span></code> </pre><br>  TheService can make its HTTP requests to external services.  With the help of the config, we redirect to a local utility that writes them.  For her, too, there is a wrapper for starting and stopping; it is similar to the ‚ÄúTheServiceControl‚Äù class, except that the utility can be simply run, without compilation. <br><br><h2>  Extra buns </h2><br>  The Go application was written in such a way that all logs and debug information are output to STDOUT.  When run in production, this output is sent to a file.  And when it starts from Rspec, it is output to the console, which helps a lot with debugging. <br><br>  If the specs are selectively chased away for which TheService is not needed, then it will not start. <br><br>  In order not to waste time on development at the start of the service each time the spec is restarted, you can start the service manually in the terminal and not turn it off.  If necessary, you can even run it in IDE in debug mode, and then the spec will prepare everything you need, throw a request for service, it will stop and you can debug it without any fuss.  This makes TDD approach very convenient. <br><br><h2>  findings </h2><br>  This scheme has been working for about a year and has never failed.  The specs are much more readable than the unit tests on Go, and do not rely on the knowledge of the internal structure of the service.  If for some reason we need to rewrite the service in another language, then we will not have to change the specs, except for the wrapper, which simply will have to start the service being tested by another team. </div><p>Source: <a href="https://habr.com/ru/post/427951/">https://habr.com/ru/post/427951/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../427941/index.html">We deploy Kubernetes HA-cluster on Baremetal using Kubeadm and Keepalived (simple tutorial)</a></li>
<li><a href="../427943/index.html">LG's 8K OLED TVs are waiting for June 2019, maybe the release will be delayed</a></li>
<li><a href="../427945/index.html">Hypervisor for Dummies</a></li>
<li><a href="../427947/index.html">Neural networks do not understand what optical illusions are</a></li>
<li><a href="../427949/index.html">Understanding statistics is hindered by our unwillingness to change.</a></li>
<li><a href="../427953/index.html">Microservices make the world easier (and here and not)</a></li>
<li><a href="../427955/index.html">Why I don't use story points for sprint planning</a></li>
<li><a href="../427957/index.html">DNS over TLS - We encrypt our DNS queries using Stunnel and Lua</a></li>
<li><a href="../427959/index.html">Check it out: made the table</a></li>
<li><a href="../427961/index.html">How Yandex tried to copy my heat map service</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>