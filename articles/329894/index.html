<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reactive Stream Log Processing with RxJava - Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Reactive log stream processing with RxJava - Part l 


 In the previous post, the author considered the cases of using the ELK stack and collecting lo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reactive Stream Log Processing with RxJava - Part 1</h1><div class="post__text post__text-html js-mediator-article"><p><img src="http://blog.isatimur.xyz/content/images/2017/04/1084-Do_More_With_DialVision_Phonathon_Software.jpg" alt="image"><br>  <strong><em><a href="https://balamaci.ro/reactive-log-processing/">Reactive log stream processing with RxJava - Part l</a></em></strong> </p><br><p>  In the previous post, the author considered the cases of using the <a href="http://www.elasticsearch.org/">ELK</a> stack and collecting logs. <br>  Taking into account the movement towards microservices and containerization of applications, centralized processing of logs and their storage becomes a de facto <strong>standard</strong> . </p><br><p>  Maybe we should try to take the next step and more actively use the information obtained in order to find the causes of a number of problems long before they appear. * </p><a name="habracut"></a><br><p>  <em>Footnote - The streams and data streams in this translation are interchangeable words.</em>  <em>Also, the word log can mean a log, although in most cases we use a different meaning in the text.</em> </p><br><p>  If <strong>we viewed the event log as a data stream of what is happening in real time</strong> on your system, it would be very interesting to <strong>analyze the real-time data</strong> and all possible uses, for example, to <strong>detect fraudulent behavior</strong> by aggregating various information flows directly during the <em>"attack"</em> , and immediately block the attacker instead of <em>"traditionally"</em> collecting log data and investigating after the incident. </p><br><p>  Or another example, we can filter ( <strong><em>filter</em></strong> ) only those events that correspond to a certain type of events, group ( <strong><em>group by</em></strong> ) them by the common key as userID and calculate the total number in the time window, getting the number of events of this type that the user performs in a certain period of time. </p><br><pre><code class="hljs pgsql">failedLogStream() .<span class="hljs-keyword"><span class="hljs-keyword">window</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>,TimeUnit.SECONDS) .flatMap(<span class="hljs-keyword"><span class="hljs-keyword">window</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">window</span></span> .groupBy(propertyStringValue("remoteIP")) .flatMap(grouped -&gt; grouped .count() .map( failedLoginsCount -&gt; { final String remoteIp = grouped.getKey(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Pair&lt;&gt;(remoteIp, failedLoginsCount); })) ) .<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(pair -&gt; pair.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> &gt; <span class="hljs-number"><span class="hljs-number">10</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span>::println);</code> </pre> <br><p>  We can initiate requests in other systems and work with their answers as data streams, to which we can subscribe and apply <strong><em>several familiar operators to work with streams</em></strong> (data streams) that are represented in the <strong><em>reactive streams</em></strong> frameworks. </p><br><h3 id="uchim-novuyu-paradigmu-razrabotki">  Learning a new development paradigm </h3><br><p>  It would be nice to make out what <strong><em>reactive programming of streams is</em></strong> , for this we don‚Äôt need to deploy something big, such as <a href="https://www.confluent.io/blog/introducing-kafka-streams-stream-processing-made-simple/">Kafka</a> <a href="https://spark.apache.org/docs/latest/streaming-programming-guide.html">Streams Spark</a> or <a href="https://flink.apache.org/">Flink</a> . </p><br><p>  Reactive programming is <strong>non-blocking</strong> , <strong>event</strong> - <strong>driven</strong> applications that scale even with a small number of threads with load opposition (a feedback mechanism in which the amount of data from manufacturers does not exceed the number of data received by consumers). </p><br><p>  The biggest topic <strong>Spring5 brings</strong> will be <strong><a href="https://spring.io/blog/2016/04/19/understanding-reactive-types">Support for Reactive Programming</a></strong> .  The new <strong><a href="https://github.com/spring-projects/spring-framework/tree/master/spring-web-reactive">spring-web-reactive module</a></strong> is a framework similar to <strong>spring-web-mvc</strong> , which will allow to give asynchronous (non-blocking) responses for REST services and a reactive web client, which implies the possibility of using this solution for microservice architecture.  The concept of reactive streams is not specific to Spring, since there is a general specification of <a href="https://github.com/reactive-streams/reactive-streams-jvm">reactive-streams-jvm</a> agreed upon by most of the reactive frameworks (it may not have an identical name for it yet, but the concept should be simple enough to become a replacement for frameworks). </p><br><p>  Historically, the model of <strong><em>reactive streams</em></strong> was represented by Rx.NET, and then ported to java using Netflix, with the name RxJava.  At the same time, the concept has also been successfully implemented in other languages, called <strong><a href="http://reactivex.io/">Reactive EXtensions</a></strong> .  Since then, companies have moved in the same direction as the specification of jet streams.  Now <strong>RxJava</strong> , since it was a pioneer, needs significant <em>refactoring</em> (code rewriting) - accordingly, version 2.x better meets the specification, and while Spring reactor is still a beginner, it will not be difficult for the company to rewrite the implementation according to the specification.  We recommend reading more about how they are interrelated. </p><br><p>  Doug Lea said that he wants to include jet streams in the java.util.concurrent.Flow object, which means that jet streams will be supplied as part of <strong>Java 9</strong> . </p><br><h3 id="preimuschestva-s-tochki-zreniya-proizvoditelnosti">  Performance Benefits </h3><br><p>  Also, another fashionable word now is microservice architecture with the obligatory ability to make requests for many different services.  Ideally, it is best to perform non-blocking requests, without waiting for the next request to receive the entire response.  Think, instead of waiting for the moment when some service returns you a large list of results, it may be worthwhile at the same time when you receive the first fragment to send a new request to another system. </p><br><p><img src="http://blog.isatimur.xyz/content/images/2017/04/image-1.png" alt="Never block"></p><br><p>  If we consider a response from a remote request as a Stream (Stream-data stream), a subscription to which triggers an action when an answer is received, instead of blocking the stream that is waiting for its response, we can use a smaller number of streams in general, which, in turn, , will reduce the cost of resources (for example, processor time for context switching between threads and memory for each stack of threads). </p><br><p>  Thus, the use of reactive programming will allow us to process more event logs than usual on a standard hardware. </p><br><p>  Example: a service, such as Gmail, needs to display user emails.  However, emails, in turn, can have many people in a copy (CC).  It would be cool to display a photo for those users who are in your contacts, which means calling REST - ContactService. </p><br><p>  It turns out like this: </p><br><pre> <code class="hljs ruby">Future&lt;List&lt;Mail<span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span>emailsFuture = mailstoreService.getUnreadEmails(); List&lt;Mail&gt; emails = emailsFuture.get(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   /<span class="hljs-regexp"><span class="hljs-regexp">/  ,        /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,      ? Future&lt;List&lt;Contacts&gt;&gt; contacts = getContactsForEmails(emails); for(Mail mail : emails) { streamRenderEmails(mail, contacts); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/push() emails  }</span></span></code> </pre> <br><p>  Part of the problem was solved with the arrival of support for reactive programming in Java 8 with the Completable Future (with its thenCompose, thenCombine, thenAccept and 50 more methods, although this does not negate the fact that you need to remember everything they do, but it does not help in reading code). </p><br><pre> <code class="hljs django"><span class="xml"><span class="xml">CompletableFuture</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">List</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Mail</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">&gt; emailsFuture = mailstoreService.getUnreadEmails(); CompletableFuture</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">List</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Contact</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">&gt; emailsFuture .thenCompose(emails -&gt; getContactsForEmails(emails)) //     List</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Mail</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> .thenAccept(emailsContactsPair -&gt; streamRenderEmails(emailsContactsPair.getKey(), emailsContactsPair.getValue()))</span></span></code> </pre> <br><p>  We can switch to Iterator instead of List, and at the same time there are no methods to perform any action when new values ‚Äã‚Äãappear.  In SQL, there is such a possibility, for example, ResultSet (in which you can execute rs.next ()) instead of loading all data into memory. </p><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterator</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** *  {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> true},     . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** *    . */</span></span> <span class="hljs-function"><span class="hljs-function">E </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  But we still need to constantly ask, "Do you have a new meaning?" </p><br><pre> <code class="hljs ruby">Iterable&lt;Mail&gt; emails = mailstoreService.getUnreadEmails(); Iterator&lt;Mail&gt; emailsIt = emails.iterator(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(emailsIt.hasNext()) { Mail mail = emailsIt.<span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mail != null) { .... } }</code> </pre> <br><p>  What we need is a reactive iterator, a data type that can subscribe and perform an action as soon as a new value is received.  This is where reactive stream programming begins. </p><br><h3 id="tak-chto-zhe-takoe-stream">  So what is Stream? </h3><br><p><img src="https://camo.githubusercontent.com/e581baffb3db3e4f749350326af32de8d5ba4363/687474703a2f2f692e696d6775722e636f6d2f4149696d5138432e6a7067" alt="Everything is a stream"></p><br><p>  Stream is simply a <strong>sequence of events arranged in time</strong> ( <strong>event</strong> X occurs after event Y, so <strong>events do not compete with each other</strong> ). </p><br><p>  Stream is modeled so that it releases <strong>0..N</strong> events and <strong>one of two terminal operations</strong> : </p><br><ul><li>  a <strong>termination</strong> event through which subscribers are informed that data release is over </li><li>  <strong>error</strong> event informing about the end of the stream with an error (exception) </li></ul><br><p>  We can describe it visually with the help of ' <em>marble diagrams</em> '. </p><br><p><img src="https://balamaci.ro/content/images/2016/08/RxJava1.svg" alt="Marble diagram for Observable"></p><br><p>  Thus, we can imagine that the stream is everything, and not just the event log.  Even a single value can be expressed as a Stream issuing a value, followed by an <strong>event of completion.</strong> </p><br><p>  Endless stream - a stream that releases events, but without a single terminal event (completion | error). </p><br><p>  RxJava defines the <strong>Observable</strong> (Observable) data type for Stream modeling a type event.  In Spring Reactor, it is equal to the type <a href="https://projectreactor.io/core/docs/api/reactor/core/publisher/Flux.html">Flux</a> . <br></p><p>  Observable is a stream of temperatures taken at various intervals. <br></p><p>  Observable is a stream of products purchased in our web store. <br></p><p>  Observable is a single user (User), returned on request to the database. <br></p><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Observable&lt;User&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserId</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">String userId</span></span></span><span class="hljs-function">)</span></span> {...} <span class="hljs-comment"><span class="hljs-comment">//  Single    public Single&lt;User&gt; findByUserId(String userId) {...}</span></span></code> </pre> <br><p>  But <strong>Observable is just a data type, so, as is the case with the Publish / Subscriber (Publish / Subscriber) design template, we need a Subscriber (Subscriber) to handle 3 types of events</strong> <br></p><pre> <code class="hljs java"> Observable&lt;CartItem&gt; cartItemsStream = ...; Subscriber&lt;CartItem&gt; subscriber = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subscriber&lt;CartItem&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CartItem cartItem)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Cart Item added "</span></span> + cartItem); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCompleted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable e)</span></span></span><span class="hljs-function"> </span></span>{ e.printStackTrace(); } }; cartItemsStream.subscribe(subscriber);</code> </pre> <br><h3 id="reaktivnye-operatory">  Reactive operators </h3><br><p>  But this is just a part of Stream, but until now we have not used anything unusual, just the classic Observer design pattern. </p><br><p>  The Reactive (Reactive) part means that we can define some Function (operators - functions) that will be executed when stream triggers an event. </p><br><p>  This means that another stream will be created ( <strong>immutable</strong> stream), to which we can sign another operator, etc. </p><br><pre> <code class="hljs kotlin">Observable&lt;CartItem&gt; filteredCartStream = cartStream.filter(new Func1&lt;CartItem, <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> call(CartItem cartItem) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cartItem.isLaptop(); } }); Observable&lt;<span class="hljs-built_in"><span class="hljs-built_in">Long</span></span>&gt; laptopCartItemsPriceStream = filteredCartStream.map(new Func1&lt;CartItem, <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span>&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span> call(CartItem cartItem) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> priceService.getPrice(cartItem.getId()); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(PriceServiceException e) { thrown new RuntimeException(e); } } });</code> </pre> <br><p>  Since the operators (methods) of the Observable class (filter, map, groupBy, ...) return Observable, this means that we can use a chain of operators to combine them with the lambda syntax and write something beautiful. </p><br><pre> <code class="hljs coffeescript">Observable&lt;BigDecimal&gt; priceStream = cartStream .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cartItem)</span></span></span><span class="hljs-function"> -&gt;</span></span> cartItem.isLaptop()). .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(laptop)</span></span></span><span class="hljs-function"> -&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> priceService.getPrice(cartItem.getId()); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(PriceServiceException e) { thrown <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(e); } });</code> </pre> <br><p>  Note that above, when <code>priceStream</code> is created, nothing happens - <code>priceService.getPrice()</code> not called until there is an element passing through the chain of operators.  This means that we created a similarity of the plan through an rx-operator, how the managed data will go down the chain (the signing is registered). </p><br><p>  When asked to explain reactive programming, they usually jokingly give an example of Excel sheets, where the columns contain formulas that are called when a cell is updated, which in turn updates another cell, which, in turn, updates another one and so on along the chain. </p><br><p>  Just like an rx-operator who does nothing, these formulas simply control the data and each one gets its chance to do something until the data goes down the chain. </p><br><p>  To better understand how events travel along with a chain of operators, I found a useful analogy, in the example of moving from one house to another, the movers act as operators, with whom things move from your house - this is how Thomas Nild portrayed. </p><br><p>  His example with the code: </p><br><pre> <code class="hljs rust">Observable&lt;Item&gt; mover1 = Observable.create(s -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (house.hasItems()) { s.onNext(house.getItem()); } s.onCompleted(); }); Observable&lt;Item&gt; mover2 = mover1.map(item -&gt; putInBox(item)); Subscription mover3 = mover2.subscribe(<span class="hljs-keyword"><span class="hljs-keyword">box</span></span> -&gt; putInTruck(<span class="hljs-keyword"><span class="hljs-keyword">box</span></span>), () -&gt; closeTruck()); <span class="hljs-comment"><span class="hljs-comment">//    OnCompleted()</span></span></code> </pre> <br><p><img src="https://1.bp.blogspot.com/-1RuGVz4-U9Q/VjT0AsfiiUI/AAAAAAAAAKQ/xWQaOwNtS7o/s640/animation_2.gif"></p><br><p>  "Loader 1 on the one hand is an <code>Observable</code> source. It creates outliers by taking things out of the house. It calls Loader 2 with the <code>onNext()</code> method, which performs a <code>map()</code> operation. When its <code>onNext()</code> method is called, it takes a thing and shifts to the box. Then he calls Loader 3, the final <code>Subscriber</code> (subscriber), with the <code>onNext()</code> method, which loads the box in the car. " </p><br><p>  The magic of RxJava is a large set of available operators, but your job is to combine them all together to control the flow of data. </p><br><p><img src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/Composition.1.png"></p><br><p>  Many Stream operators help to compile a glossary of terms for actions performed with streams that can be implemented in popular languages ‚Äã‚Äã(RxJava, RxJS, Rx.NET, etc) from among the ReactiveX framework (Reactive Extensions). </p><br><p>  These concepts should be known even when using different frameworks for working with jet streams, such as Spring Reactor (in the hope of having some operators common to these frameworks). </p><br><p>  So far, we have only seen simple operators, such as filtering: </p><br><p><img src="http://reactivex.io/documentation/operators/images/filter.png" alt="** Filter **"></p><br><p>  Which only pass elements that fall under the condition of the filter (one loader will carry only those things that cost less than $ 100, instead of transferring everything at once to another loader) </p><br><p>  However, there are operators that can break the stream into many separate streams - <code>Observable&lt;Observable&lt;T&gt;&gt;</code> (Stream streams) are such operators as <code>groupBy</code> </p><br><p><img src="https://blogs.endjin.com/wp-content/uploads/2014/04/event-stream-with-groupby1.png" alt="> ** group by **"></p><br><pre> <code class="hljs pgsql"> Observable&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> = Observable.just(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>); Observable&lt;GroupedObservable&lt;String, <span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt;&gt; oddEvenStream = <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>.groupBy((number) -&gt; number % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> ? "odd":"even"); Observable&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; remergedStream = Observable.concat(oddEvenStream); remergedStream.subscribe(number -&gt; <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span>.print(number +" "));</code> </pre> <br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// //1 5 7 9 4 8 10</span></span></code> </pre> <br><p>  and a fairly simple <code>concat</code> operator, which again creates a single stream from even and odd streams, and establishes a subscription to it. <br><img src="http://reactivex.io/documentation/operators/images/concat.png" alt="> ** Concat **"></p><br><p>  We see that the <code>concat</code> operator waits for the end of the stream before adding another one, again creating one stream.  Thus, odd numbers are displayed first. </p><br><p>  We also have the ability to combine together many streams, such as the <code>zip</code> operator <br><img src="https://balamaci.ro/content/images/2016/08/zip.png" alt="> ** Zip operator **"></p><br><p>  <code>Zip</code> is named so not because it works as an archiver, but rather because it, like lightning (on a jacket), combines events from two stream-s. </p><br><p><img src="https://upload.wikimedia.org/wikipedia/commons/f/f0/Zipper_animated.gif" alt="> Lightning (Latch)"></p><br><p>  It takes one event from one stream and connects it with an event from another (making a pair).  Once this is done, he applies the gluing operator before going further down the chain. </p><br><p>  <em>PS:</em> it works for more streams. </p><br><p>  So, even if one stream releases events faster, then the listener will see only the combined event, which will be released from the slower stream. </p><br><p>  Having the ability to <strong>"wait" for a</strong> response from the many remote calls we receive from streaming s is actually very useful. </p><br><p>  On the other hand, the <code>combineLatest</code> operator <code>combineLatest</code> not wait for a couple of events to be released, but instead uses the latest released events from the slower stream, before applying the glue function and passing it further along the chain. </p><br><p><img src="https://camo.githubusercontent.com/2a1a467dc61743d40f92fd6df1038f4e2a3ded7c/687474703a2f2f692e696d6775722e636f6d2f3670316931447a2e706e67" alt="> Combine latest"></p><br><h3 id="dvizhemsya-k-myshleniyu-na-osnove-push-podhoda">  Moving towards thinking based on the push approach </h3><br><p>  Let's look at a few examples of how <code>Observable</code> s are actually created.  The longest way to create: </p><br><pre> <code class="hljs pgsql"> log("Before create Observable"); Observable&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; someIntStream = Observable .<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ObservableOnSubscribe&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt;() { @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> subscribe(ObservableEmitter&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; emitter) throws <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> { log("Create"); emitter.onNext(<span class="hljs-number"><span class="hljs-number">3</span></span>); emitter.onNext(<span class="hljs-number"><span class="hljs-number">4</span></span>); emitter.onNext(<span class="hljs-number"><span class="hljs-number">5</span></span>); emitter.onComplete(); log("Completed"); } }); log("After create Observable"); log("Subscribing 1st"); someIntStream.subscribe((val) -&gt; LOGGER.<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>("received " + val)); //    // (<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> onError <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> onComplete)     , -  log("Subscribing 2nd"); someIntStream.subscribe((val) -&gt; LOGGER.<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>("received " + val));</code> </pre> <br><p>  <strong>Events are sent to the subscriber as soon as he subscribes</strong> . <br>  Not that we use such a construct, we just passed a new <code>ObservableOnSubscribe</code> object, which demonstrates what to do when someone signs to it. </p><br><p>  Until we subscribe to <code>Observable</code> , there is no output and nothing happens, the data does not move. </p><br><p>  When someone signs up, the <code>call()</code> method is <code>call()</code> and 3 messages are pushed down the chain, followed by a signal that stream has ended. </p><br><p>  Above, we have subscribed twice, the code inside the <code>call(...)</code> method will also be called twice.  So he effectively re-sends the same values ‚Äã‚Äãas soon as someone signs up and then gets the following values ‚Äã‚Äãto the output: </p><br><pre> <code class="hljs pgsql">mainThread: <span class="hljs-keyword"><span class="hljs-keyword">Before</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> Observable mainThread: <span class="hljs-keyword"><span class="hljs-keyword">After</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> Observable mainThread: Subscribing <span class="hljs-number"><span class="hljs-number">1</span></span>st mainThread: <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span> mainThread: received <span class="hljs-number"><span class="hljs-number">3</span></span> mainThread: received <span class="hljs-number"><span class="hljs-number">4</span></span> mainThread: received <span class="hljs-number"><span class="hljs-number">5</span></span> mainThread: Completed mainThread: Subscribing <span class="hljs-number"><span class="hljs-number">2</span></span>nd mainThread: <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span> mainThread: received <span class="hljs-number"><span class="hljs-number">3</span></span> mainThread: received <span class="hljs-number"><span class="hljs-number">4</span></span> mainThread: received <span class="hljs-number"><span class="hljs-number">5</span></span> mainThread: Completed</code> </pre> <br><p>  It is important to note that rx operators do not necessarily mean multithreading.  <strong>RxJava</strong> does not <strong>enforce default contention</strong> between <strong>Observable</strong> and <strong>Subscriber</strong> .  Therefore, all calls occur on the " <strong>main</strong> " thread. </p><br><p>  This type of <code>Observable</code> , which begins to spread when someone is signed, is called <strong><code>cold observables</code></strong> (cold observers).  Another type is <strong><code>hot observables</code></strong> (hot observers), they can release events, even when no one subscribes to them. </p><br><ul><li>  <code>Cold Observables</code> begin to spread events only when someone signs up.  Each subscriber receives the same events.  For example, <strong>as a CD on which they play the same songs</strong> for the one who included the cd in the player to listen. </li><li>  <code>Hot Observables</code> events extend even when nobody has subscribed to them yet.  <strong>As a radio station that loses songs through broadcasting, even when no one turned it on</strong> .  And just like when you turn on the radio, you miss previous events.  <em>Hot observable</em> models events whose distribution you cannot control.  Approximately as in the case of recording events in the log (event log). </li></ul><br><p>  <code>Subjects</code> are such a special kind of <code>Observable</code> , which is also an <code>Observer</code> (like <code>Subscriber</code> - which decides that it can push data (by <code>onNext()</code> ) to them) and make implementing hot <code>Observables</code> easier.  There are also many implementations, like <code>ReplaySubject</code> , that store selected events in the buffer and replay them by subscription (of course, you can specify a buffer size to prevent the <code>OutOfMemory</code> error) while <code>PublishSubject</code> only misses events that occurred after signing. <br>  And of course, there are many static methods for creating <code>Observables</code> and from other sources. </p><br><pre> <code class="hljs cs">Observable.just(<span class="hljs-string"><span class="hljs-string">"This"</span></span>, <span class="hljs-string"><span class="hljs-string">"is"</span></span>, <span class="hljs-string"><span class="hljs-string">"something"</span></span>) Observable.<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(Iterable&lt;T&gt; collection) Observable.<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(Future&lt;T&gt; future) -    ,  `future` </code> </pre> <br><h3 id="dobavlenie-v-nash-elk-stek-rabbitmq-emittera-dannyh-otpravlyaemyh-posredstvom-push">  Adding to our ELK stack a RabbitMQ emitter of data sent via push </h3><br><p>  By tradition, working with the ELK stack, we use ElasticSearch to query the event log data, so we can say that they are in a pull-based polling style. </p><br><p>  Can we instead have push-based, where we are going to inform 'immediately' when an event appears in the log, to further reduce the response time to the event, from the moment it occurred and before we start to process it. </p><br><p>  One of the many possible solutions can be <strong>RabbitMq</strong> , as a solution <strong>experienced</strong> in battles with a very good reputation for its performance, for its ability to process a huge number of messages.  Despite this, <strong>Logstash</strong> already supports the <strong>RabbitMQ</strong> plugin (there is also another FluentD plugin) so that we can easily integrate it into our existing ELK stack and write logs to ElasticSearch and RabbitMQ. </p><br><p>  Perhaps you remember that <strong>Logstash</strong> can behave like a controller, and choose how it works, and where to send / save logged events.  This means that we can filter the events that we want to process or indicate where to send them, for example, to other RabbitMQ queues. </p><br><p>  It is even possible to directly send data to <strong>RabbitMQ</strong> through the Logback Appender, if you want to omit the use of <strong>Logstash</strong> . </p><br><p>  By the way: the so-called <code>AmqpAppender</code> is so <code>AmqpAppender</code> a rather specific implementation of <strong>RabbitMQ AMQP</strong> (with AMQP protocol version 0-9-1, 0-9). </p><br><p>  For example, ActiveMQ (while also supporting AMQP connector) seems to implement the protocol version AMQP 1.0, while the spring-amqp library with protocol versions 0-9-1, 0-9, which are quite different from 1.0), so you may encounter errors on type <code>'org.apache.activemq.transport.amqp.AmqpProtocolException: Connection from client using unsupported AMQP attempted'</code> </p><br><p>  However, our solution was to use <strong>logstash-logback-encoder</strong> and send formatted JSON with an event log to <strong>Logstash</strong> .  We will redirect the logstash output to the RabbitMQ (exchange) exchange point. </p><br><p>  We will use <em>docker-compose</em> to start the <strong><em>logstash-rabbitmq</em></strong> cluster <strong><em>.</em></strong> <br>  You can clone the repository </p><br><p> <code>docker-compose -f docker-compose-rabbitmq.yml up</code> <br>  and then you can use <br> <code>./event-generate.sh</code> <br>  to generate a certain number of random events that will be sent to <strong>logstash</strong> . </p><br><p>  ,  ,   ,  <a href=""></a>  <strong>logstash</strong> .   <a href="https://www.elastic.co/guide/en/logstash/current/plugins-outputs-rabbitmq.html">rabbitmq-output-plugin</a> ,  : </p><br><pre> <code class="hljs perl">output { rabbitm<span class="hljs-string"><span class="hljs-string">q { exchange =&gt; logstash exchange_type =&gt; direct host =&gt; rabbitmq key =&gt; my_app }</span></span> }</code> </pre> <br><p> RabbitMQ    JMS ,     AMQP ,         . </p><br><p><img src="http://blog.springsource.com/wp-content/uploads/2010/06/rabbit-basics.png" alt="amqp"></p><br><p>        (exchange)      . </p><br><p>      'routing-key',       ,      .          ,             ' <strong>logstash.</strong>  ' </p><br><p>     <code>AMQP</code>    <a href="https://spring.io/blog/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/"></a>  <a href="https://www.cloudamqp.com/blog/2015-09-03-part4-rabbitmq-for-beginners-exchanges-routing-keys-bindings.html"></a> .    <code>Spring</code>  c <code>RabbitMq</code> </p><br><pre> <code class="hljs java"> <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-function">ConnectionFactory </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connectionFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CachingConnectionFactory(host, port); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-function">RabbitAdmin </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rabbitAdmin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ RabbitAdmin rabbitAdmin = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RabbitAdmin(connectionFactory()); rabbitAdmin.declareQueue(queue()); rabbitAdmin.declareBinding(bindQueueFromExchange(queue(), exchange())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rabbitAdmin; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-function">SimpleMessageListenerContainer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">container</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ConnectionFactory connectionFactory, MessageListenerAdapter listenerAdapter)</span></span></span><span class="hljs-function"> </span></span>{ SimpleMessageListenerContainer container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleMessageListenerContainer(); container.setConnectionFactory(connectionFactory); container.setQueueNames(queueName); container.setMessageListener(listenerAdapter); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-function">Queue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">queue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue(queueName, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-function"><span class="hljs-function">DirectExchange </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exchange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DirectExchange(<span class="hljs-string"><span class="hljs-string">"logstash"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Binding </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindQueueFromExchange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Queue queue, DirectExchange exchange)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BindingBuilder.bind(queue).to(exchange).with(<span class="hljs-string"><span class="hljs-string">"my_app"</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-function">MessageListenerAdapter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listenerAdapter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Receiver receiver)</span></span></span><span class="hljs-function"> </span></span>{ MessageListenerAdapter messageListenerAdapter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MessageListenerAdapter(receiver, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MessageConverter() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Message </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o, MessageProperties messageProperties)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> MessageConversionException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"Unsupported"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Message message)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> MessageConversionException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(message.getBody(), <span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (UnsupportedEncodingException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"UnsupportedEncodingException"</span></span>); } } }); messageListenerAdapter.setDefaultListenerMethod(<span class="hljs-string"><span class="hljs-string">"receive"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//the method in our Receiver class return messageListenerAdapter; } @Bean Receiver receiver() { return new Receiver(); }</span></span></code> </pre> <br><p>         'logstash',       'my_app'. <strong>MessageListenerAdapter</strong>  ,   'receive'      <code>Receiver</code>  ,      . </p><br><p>        ,      ,      <code>hot observable</code> ,       ,   ,       <strong>PublishSubject</strong> . </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Receiver</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PublishSubject&lt;JsonObject&gt; publishSubject = PublishSubject.create(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Receiver</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-comment"><span class="hljs-comment">/** * Method invoked by Spring whenever a new message arrives * @param message amqp message */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Object message</span></span></span><span class="hljs-function">)</span></span> { log.info(<span class="hljs-string"><span class="hljs-string">"Received remote message {}"</span></span>, message); JsonElement remoteJsonElement = gson.fromJson ((String) message, JsonElement.class); JsonObject jsonObj = remoteJsonElement.getAsJsonObject(); publishSubject.onNext(jsonObj); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> PublishSubject&lt;JsonObject&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPublishSubject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> publishSubject; } }</code> </pre> <br><p>   ,   <strong>SimpleMessageListenerContainer</strong>     ,     (     ).   Observable ,        ( <code>onNext</code> , <code>onComplete</code> , onError   ): </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     Observable.create(s -&gt; { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Thread A <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> { s.onNext(<span class="hljs-string"><span class="hljs-string">"one"</span></span>); s.onNext(<span class="hljs-string"><span class="hljs-string">"two"</span></span>); }).start(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Thread B <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> { s.onNext(<span class="hljs-string"><span class="hljs-string">"three"</span></span>); s.onNext(<span class="hljs-string"><span class="hljs-string">"four"</span></span>); }).start(); }); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  Observable&lt;String&gt; obs1 = Observable.create(s -&gt; { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Thread A <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> { s.onNext(<span class="hljs-string"><span class="hljs-string">"one"</span></span>); s.onNext(<span class="hljs-string"><span class="hljs-string">"two"</span></span>); }).start(); }); Observable&lt;String&gt; obs2 = Observable.create(s -&gt; { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Thread B <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> { s.onNext(<span class="hljs-string"><span class="hljs-string">"three"</span></span>); s.onNext(<span class="hljs-string"><span class="hljs-string">"four"</span></span>); }).start(); }); Observable&lt;String&gt; c = Observable.merge(obs1, obs2);</code> </pre> <br><p>       <code>Observable.serialize()</code>  <code>Subject.toSerialized()</code> ,        1 <code>Thread</code>  <code>ListenerContainer</code> ,    .       ,      <code>Subjects</code>   ,    .  <a href="https://artemzin.com/blog/rxjava-thread-safety-of-operators-and-subjects/"> </a> . </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And now you can look at the code and the </font></font><a href="https://github.com/balamaci/rxjava-rabbitmq"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repository</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as a continuation of this long </font></font><a href="https://balamaci.ro/reactive-log-stream-processing-with-rxjava-part-2/"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Part II</font></font></strong><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> post </font><a href="https://balamaci.ro/reactive-log-stream-processing-with-rxjava-part-2/"><font style="vertical-align: inherit;">(Part 2)</font></a><font style="vertical-align: inherit;"> or go to the </font></font><a href="https://github.com/balamaci/rxjava-playground"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rx Playground</font></font></strong></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> there you will find more examples. </font></font><br> <a href="http://blog.isatimur.xyz/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link to translator's site</font></font></a> </p><p></p><p></p><p></p><p></p><p></p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/329894/">https://habr.com/ru/post/329894/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329884/index.html">Machine intelligence in a Gboard keyboard</a></li>
<li><a href="../329886/index.html">Delegates and Lambda Expressions in C # .Net - Cheat Sheet or Briefly</a></li>
<li><a href="../329888/index.html">ACM ICPC 2017: Final Results</a></li>
<li><a href="../329890/index.html">PHDays VII: Confrontation Chronicles</a></li>
<li><a href="../329892/index.html">What are women talking about? (Text mining of beauty blogs)</a></li>
<li><a href="../329896/index.html">Recipes for Android: Scroll-To-Dismiss Activity</a></li>
<li><a href="../329898/index.html">Must see: videos of MoscowJS 37 mitap</a></li>
<li><a href="../329900/index.html">Initial setup of Puppet is not as simple as it sounds.</a></li>
<li><a href="../329902/index.html">Routers, attack vectors and other adventures of Shurik</a></li>
<li><a href="../329904/index.html">How to use a token to make a Windows domain safer? Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>