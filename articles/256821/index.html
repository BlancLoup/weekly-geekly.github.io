<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How IQueryable and LINQ Data Providers Work</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="LINQ tools allow .Net developers to work consistently with collections of objects in memory as well as with objects stored in a database or other remo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How IQueryable and LINQ Data Providers Work</h1><div class="post__text post__text-html js-mediator-article">  LINQ tools allow .Net developers to work consistently with collections of objects in memory as well as with objects stored in a database or other remote source.  For example, to query ten red apples from the list in memory and from the database using the Entity Framework, we can use absolutely identical code: <br><br><pre><code class="cs hljs">List&lt;Apple&gt; appleList; DbSet&lt;Apple&gt; appleDbSet; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> applesFromList = appleList.Where(apple =&gt; apple.Color == ‚Äúred‚Äù).Take(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> applesFromDb = appleDbSet.Where(apple =&gt; apple.Color == ‚Äúred‚Äù).Take(<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br>  However, these requests are executed differently.  In the first case, when enumerating the result using foreach, the apples will be filtered using the specified predicate, after which the first 10 of them will be taken.  In the second case, the syntax tree with the query expression will be transferred to a special LINQ provider, which translates it into an SQL query to the database and executes, then generates C # objects for the 10 found records and returns them.  This behavior is enabled by the IQueryable &lt;T&gt; interface, which is intended for creating LINQ providers to external data sources.  Below we will try to understand the principles of organization and use of this interface. <br><a name="habracut"></a><br><h2>  Interfaces IEnumerable &lt;T&gt; and IQueryable &lt;T&gt; </h2><br>  At first glance it might seem that LINQ is based on a set of extension methods like Where (), Select (), First (), Count (), etc.  to the IEnumerable &lt;T&gt; interface, which ultimately allows the developer to write queries in a uniform way for both in-memory objects (LINQ to Objects) and databases (for example, LINQ to SQL, LINQ to Entities) and remote services (for example, LINQ to OData Services).  But it is not.  The fact is that within the extension methods of IEnumerable &lt;T&gt;, the corresponding operations with sequences have already been implemented.  For example, the First &lt;TSource&gt; method (Func &lt;TSource, bool&gt; predicate) is implemented in .Net Framework 4.5.2, the source code of which is available to us <a href="http://referencesource.microsoft.com/">here</a> , as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> TSource First&lt;TSource&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IEnumerable&lt;TSource&gt; source, Func&lt;TSource, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; predicate) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> Error.ArgumentNull(<span class="hljs-string"><span class="hljs-string">"source"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (predicate == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> Error.ArgumentNull(<span class="hljs-string"><span class="hljs-string">"predicate"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (TSource element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> source) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (predicate(element)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element; } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> Error.NoMatch(); }</code> </pre><br>  It is clear that in the general case such a method cannot be performed on data located in the database or service.  To execute it, we can only preload the entire data set directly into the application, which for obvious reasons is unacceptable. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To implement LINQ providers to data external to the application, the IQueryable &lt;T&gt; interface (inherited from IEnumerable &lt;T&gt;) is used, along with a set of extension methods that are almost completely identical to those written for IEnumerable &lt;T&gt;.  It is precisely because List &lt;T&gt; implements IEnumerable &lt;T&gt;, and DbSet &lt;T&gt; from the Entity Framework is IQueryable &lt;T&gt;, the queries with apples given at the beginning of the article are executed differently. <br><br>  The peculiarity of extension methods for IQueryable &lt;T&gt; is that they do not contain data processing logic.  Instead, they simply form a syntactic structure with a description of the request, ‚Äúbuilding up‚Äù it with each new method call in the chain.  When calling aggregate methods (Count (), etc.) or enumerating using foreach, the request description is sent to the provider that is encapsulated within a specific IQueryable &lt;T&gt; implementation, and the request is already converted into the language of the data source and performs it.  In the case of the Entity Framework, this language is SQL, in the case of the .Net driver for MongoDb, this is a search json object, etc. <br><br>  Incidentally, some ‚Äúinteresting‚Äù characteristics of LINQ providers stem from this feature: <br><ul><li>  a request that is successfully executed by one provider may not be supported by another;  Moreover, we will find out about this even at the stage of constructing the request, but only at the stage of its execution by the provider; </li><li>  the provider can modify it before performing the request;  for example, a limit on the number of returned objects, additional filters, etc. can be added to all requests. </li></ul><br><h2>  Making LINQ with your own hands: ISimpleQueryable &lt;T&gt; </h2><br>  Before describing the device interface IQueryable &lt;T&gt;, try to write its own simple analogue - the interface ISimpleQueryable &lt;T&gt;, as well as a couple of methods extensions to it in the style of LINQ.  This will allow you to clearly demonstrate the basic principles of working with IQueryable &lt;T&gt;, without going into the nuances of its implementation. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISimpleQueryable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TSource</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IEnumerable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TSource</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> QueryDescription { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-function">ISimpleQueryable&lt;TSource&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateNewQueryable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> queryDescription</span></span></span><span class="hljs-function">)</span></span>; TResult Execute&lt;TResult&gt;(); }</code> </pre><br>  In the interface, we see the QueryDescription property, which contains the description of the query, as well as the Execute &lt;TResult&gt; () method, which should execute this query if necessary.  This is a generic method, since the output can be both an enumeration and a value of an aggregate function, such as Count ().  In addition, the interface has the CreateNewQueryable () method, which allows adding a new instance of ISimpleQueryable &lt;T&gt; when adding a new LINQ method, but with a new description of the query.  Note that the request description is presented here as a string, and in LINQ, expression trees (Expression Trees) are used for this, which you can read about <a href="https://msdn.microsoft.com/ru-ru/library/bb397951.aspx">here</a> or <a href="http://habrahabr.ru/post/83169/">here</a> . <br><br>  We now turn to extension methods: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimpleQueryableExtentions</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ISimpleQueryable&lt;TSource&gt; Where&lt;TSource&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ISimpleQueryable&lt;TSource&gt; queryable, Expression&lt;Func&lt;TSource, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt; predicate) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> newQueryDescription = queryable.QueryDescription + <span class="hljs-string"><span class="hljs-string">".Where("</span></span> + predicate.ToString() + <span class="hljs-string"><span class="hljs-string">")"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> queryable.CreateNewQueryable(newQueryDescription); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count&lt;TSource&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ISimpleQueryable&lt;TSource&gt; queryable) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> newQueryDescription = queryable.QueryDescription + <span class="hljs-string"><span class="hljs-string">".Count()"</span></span>; ISimpleQueryable&lt;TSource&gt; newQueryable = queryable.CreateNewQueryable(newQueryDescription); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newQueryable.Execute&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); } }</code> </pre><br>  As we see, these methods simply add information about themselves to the query description and create a new instance of ISimpleQueryable &lt;T&gt;.  In addition, the Where () method, unlike its counterpart for IEnumerable &lt;T&gt;, does not accept the predicate Func &lt;TSource, bool&gt; itself, but the previously mentioned expression tree with its description Expression &lt;Func &lt;TSource, bool&gt; &gt;.  In this example, this simply gives us the opportunity to get a string with the predicate code, and in the case of a real LINQ, the ability to save all the details of the query as an expression tree. <br><br>  Finally, we will create a simple implementation of our ISimpleQueryable &lt;T&gt;, which will contain everything necessary for writing LINQ queries, except for the method of their execution.  To make it realistic, add a link to the data source (_dataSource), which should be used when executing the query using the Execute () method. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FakeSimpleQueryable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TSource</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">ISimpleQueryable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TSource</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> _dataSource; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> QueryDescription { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FakeSimpleQueryable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> queryDescription, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dataSource</span></span></span><span class="hljs-function">)</span></span> { _dataSource = dataSource; QueryDescription = queryDescription; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ISimpleQueryable&lt;TSource&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateNewQueryable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> queryDescription</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FakeSimpleQueryable&lt;TSource&gt;(queryDescription, _dataSource); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TResult Execute&lt;TResult&gt;() { <span class="hljs-comment"><span class="hljs-comment">//    QueryDescription     dataSource throw new NotImplementedException(); } public IEnumerator&lt;TSource&gt; GetEnumerator() { return Execute&lt;IEnumerator&lt;TSource&gt;&gt;(); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } }</span></span></code> </pre><br>  Now consider a simple query to FakeSimpleQueryable: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> provider = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FakeSimpleQueryable&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = provider.Where(s =&gt; s.Contains(<span class="hljs-string"><span class="hljs-string">"substring"</span></span>)).Where(s =&gt; s != <span class="hljs-string"><span class="hljs-string">"some string"</span></span>).Count();</code> </pre><br>  Let's try to figure out what will happen when executing the above code (see also the figure below): <br><ul><li>  First, the first call to the Where () method will take an empty query description from the FakeSimpleQueryable instance created with the help of the constructor, add ".Where (s =&gt; s.Contains (" substring ")) to it" and form a second instance of FakeSimpleQueryable with a new description; </li><li>  then the second Where () call will take the description of the request from the previously created FakeSimpleQueryable, add ".Where (s =&gt; s! =" some string ")" to it, and then again form a new, third, instance of FakeSimpleQueryable with the description of the request " .Where (s =&gt; s.Contains ("substring")). Where (s =&gt; s! = "Some string") "; </li><li>  Finally, a Count () call will take a description of the request from the FakeSimpleQueryable instance created in the previous step, add the ".Count ()" to it and form the fourth FakeSimpleQueryable instance, then call the Execute &lt;int&gt; method, since it is impossible to build the query further; </li><li>  as a result, inside the Execute () method, we will have a QueryDescription value of ".Where (s =&gt; s.Contains (" substring ")). Where (s =&gt; s! =" some string "). Count ()", which need to be processed further. </li></ul><br><img src="https://habrastorage.org/files/160/2d9/5d9/1602d95d966d458f8cd7b727208cbf0e.png"><br><br><h2>  Real IQueryable &lt;T&gt; ... and IQueryProvider &lt;T&gt; </h2><br>  Consider now what is the IQueryable &lt;T&gt; interface, implemented in .Net: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IQueryable</span></span> : <span class="hljs-title"><span class="hljs-title">IEnumerable</span></span> { Expression Expression { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } Type ElementType { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } IQueryProvider Provider { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IQueryable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">out</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IEnumerable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">IQueryable</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IQueryProvider</span></span> { <span class="hljs-function"><span class="hljs-function">IQueryable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateQuery</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Expression expression</span></span></span><span class="hljs-function">)</span></span>; IQueryable&lt;TElement&gt; CreateQuery&lt;TElement&gt;(Expression expression); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Expression expression</span></span></span><span class="hljs-function">)</span></span>; TResult Execute&lt;TResult&gt;(Expression expression); }</code> </pre><br>  Note that: <br><ul><li>  in .Net there is a generic and regular version of IQueryable; </li><li>  to store the tree with the LINQ query description, the Expression property is used (in our implementation, we used a string QueryDescription); </li><li>  the ElementType property contains information about the type of elements returned by the query and is used in implementations of LINQ providers for checking the type conformity; </li><li>  a pair of methods for creating new instances of IQueryable (CreateQuery () and CreateQuery &lt;TElement&gt; ()), as well as a pair of methods for executing a query (Execute () and Execute &lt;TResult&gt; ()) are moved to a separate interface IQueryProvider &lt;T&gt;;  it can be assumed that such a separation was needed in order to separate the request itself, which is re-created with each new call to the extension method, from the object that actually has access to the data source, does all the basic work and can be quite ‚Äúheavy‚Äù for permanent re-creation; </li><li>  The IQueryable.Provider property points to the associated IQueryProvider instance. </li></ul><br>  Now let's take a look at the work of extension methods for IQueryable &lt;T&gt; using the example of the Where () method: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IQueryable&lt;TSource&gt; Where&lt;TSource&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IQueryable&lt;TSource&gt; source, Expression&lt;Func&lt;TSource, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt; predicate) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> Error.ArgumentNull(<span class="hljs-string"><span class="hljs-string">"source"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (predicate == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> Error.ArgumentNull(<span class="hljs-string"><span class="hljs-string">"predicate"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> source.Provider.CreateQuery&lt;TSource&gt;( Expression.Call( <span class="hljs-literal"><span class="hljs-literal">null</span></span>, ((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TSource)), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Expression[] { source.Expression, Expression.Quote(predicate) } )); }</code> </pre><br>  We see that the method constructs a new IQueryable &lt;TSource&gt; instance by passing an expression to CreateQuery &lt;TSource&gt; (), in which a call to the actual Where () method with the predicate passed as an argument is added to the source expression from source.Expression. <br><br>  Thus, despite some differences between the IQueryable &lt;T&gt; and IQueryProvider &lt;T&gt; interfaces from the ISimpleQueryable &lt;T&gt; we created earlier, the principles of their use in LINQ are the same: each extension method added to the query complements the expression tree with information about itself, then it creates a new IQueryable &lt;T&gt; instance using the CreateQuery &lt;T&gt; () method, and the aggregate methods also initiate the query execution by calling the Execute &lt;T&gt; () method. <br><br><h2>  A couple of words about the development of LINQ providers </h2><br>  Since the LINQ query design mechanism has already been implemented in .Net for us, the development of a LINQ provider is mostly reduced to the implementation of the Execute () and Execute &lt;TResult&gt; () methods.  This is where you need to parse the expression tree that came to be executed, convert it to the data source language, execute the query, wrap the results in C # objects and return them.  Unfortunately, this procedure involves the processing of a considerable number of different nuances.  Moreover, the available information on developing LINQ providers is quite small.  Below are the most informative, in the opinion of the author, articles on this topic: <br><ul><li>  <a href="http://blogs.msdn.com/b/mattwar/archive/2008/11/18/linq-links.aspx">LINQ: Building an IQueryable provider series,</a> </li><li>  <a href="https://msdn.microsoft.com/en-us/library/vstudio/bb546158(v%3Dvs.110).aspx">Walkthrough: Creating an IQueryable LINQ Provider</a> </li></ul><br>  I hope that the material of this article will be useful to anyone who wanted to understand the organization of the work of LINQ-providers to remote data sources or to approach the creation of such a provider, but has not yet decided. </div><p>Source: <a href="https://habr.com/ru/post/256821/">https://habr.com/ru/post/256821/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../256811/index.html">Dino Esposito will perform in St. Petersburg</a></li>
<li><a href="../256813/index.html">Vivaldi TP3 - we do the browser together</a></li>
<li><a href="../256815/index.html">BalanceBall. Self-balancing platform from A to Z</a></li>
<li><a href="../256817/index.html">Native Script. One code for all platforms</a></li>
<li><a href="../256819/index.html">Interesting notes on C # and CLR</a></li>
<li><a href="../256823/index.html">Features of conceptual domain modeling</a></li>
<li><a href="../256825/index.html">What prepares us for C # 7 (Part 1. Tuples)</a></li>
<li><a href="../256827/index.html">Reverse engineering integer division by constant</a></li>
<li><a href="../256829/index.html">Features of the introduction of DLL and installation of hooks in Modern-applications Windows 8/10</a></li>
<li><a href="../256831/index.html">As we thought out the designer for children's robotics. #one</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>