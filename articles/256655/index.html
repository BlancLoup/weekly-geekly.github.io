<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>All about triggers in Oracle</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Traditionally, the article is written thesis. More detailed content can be found in the video attached at the bottom of the article recording a lectur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>All about triggers in Oracle</h1><div class="post__text post__text-html js-mediator-article">  <em>Traditionally, the article is written thesis.</em>  <em>More detailed content can be found in the video attached at the bottom of the article recording a lecture on Oracle triggers.</em> <br><ul><li>  <a href="https://habr.com/ru/post/256655/">Oracle Triggers Overview</a> </li><li>  <a href="https://habr.com/ru/post/256655/">Dml triggers</a> <br><ul><li>  <a href="https://habr.com/ru/post/256655/">Pseudo recordings</a> </li><li>  <a href="https://habr.com/ru/post/256655/">Instead of dml triggers</a> </li><li>  <a href="https://habr.com/ru/post/256655/">Instead of triggers on Nested Table Columns of Views.</a> </li><li>  <a href="https://habr.com/ru/post/256655/">Compound DML triggers (compound DML triggers)</a> <br><ul><li>  <a href="https://habr.com/ru/post/256655/">Composite trigger structure</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/256655/">Basic rules for determining DML triggers</a> </li><li>  <a href="https://habr.com/ru/post/256655/">Limitations of DML Triggers</a> </li><li>  <a href="https://habr.com/ru/post/256655/">Error mutation table ORA-04091</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/256655/">System triggers (System triggers)</a> <br><ul><li>  <a href="https://habr.com/ru/post/256655/">Schema level triggers</a> </li><li>  <a href="https://habr.com/ru/post/256655/">Database Triggers (database triggers)</a> </li><li>  <a href="https://habr.com/ru/post/256655/">Instead of create triggers</a> </li><li>  <a href="https://habr.com/ru/post/256655/">Attributes of system triggers</a> </li><li>  <a href="https://habr.com/ru/post/256655/">System Trigger Events</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/256655/">Compiling triggers</a> </li><li>  <a href="https://habr.com/ru/post/256655/">Trigger Exceptions</a> </li><li>  <a href="https://habr.com/ru/post/256655/">The order of execution of triggers</a> </li><li>  <a href="https://habr.com/ru/post/256655/">Enable / Disable Triggers</a> </li><li>  <a href="https://habr.com/ru/post/256655/">Rights for operations with triggers</a> </li><li>  <a href="https://habr.com/ru/post/256655/">Trigger Data Dictionaries</a> </li></ul><br><a name="habracut"></a><br><a name="One"></a><h1>  <b>Trigger Overview</b> </h1><br>  A trigger is a pl / sql named block that is stored in a database. <br><ul><li>  You cannot trigger a trigger yourself, it always works only on a certain event automatically (if it is enabled) </li><li>  Do not create a recursive trigger.  Ie, for example, the after update trigger, in which the update of the same table is executed.  In this case, the trigger will fire recursively until the memory runs out. </li></ul><br><br>  <b>Trigger classification:</b> <br><ul><li>  DML trigger (per table or view) </li><li>  System trigger (per schema or database) </li><li>  Conditional trigger (those that have a when clause) </li><li>  Instead of trigger (dml view trigger or system trigger create command) </li></ul><br><br>  <b>Why use triggers:</b> <br><ul><li>  For automatic generation of virtual field values </li><li>  For logging </li><li>  To collect statistics </li><li>  To change the data in the tables, if the representation is involved in the dml operation </li><li>  To prevent dml operations at certain times </li><li>  To implement complex data integrity constraints that cannot be implemented through descriptive constraints set when creating tables </li><li>  For the organization of various types of audit </li><li>  For notifying other modules about what to do if the information in the database changes </li><li>  To implement business logic </li><li>  For organizing cascade effects on database tables </li><li>  To respond to system events in the database or schema </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/fe7/b84/164/fe7b84164a5940d4bc6a01860b21a80f.png"><br><br>  where <b>plsql_trigger_source</b> is such a construction: <br><img src="https://habrastorage.org/files/3c1/fe9/176/3c1fe9176c6c425ab816351acc51c77a.png"><br><br>  Constructs <b>simple_dml_trigger, instead_of_dml_trigger, compound_dml_trigger</b> and <b>system_trigger</b> will be given in the relevant sections of the article. <br><br><a name="Two"></a><h1>  <b>Dml triggers</b> </h1><br><ul><li>  DML triggers are created for tables or views, triggered when inserting, updating, or deleting records. </li><li>  A trigger can be created in a different scheme than the one where the tables are defined.  In this case, the current scheme when the trigger is executed is the scheme of the trigger itself. </li><li>  During the MERGE operation, triggers to modify, insert or delete records are triggered, depending on the operation with the string. </li><li>  A trigger is part of a transaction, an error in a trigger rolls back an operation, changes to tables in a trigger become part of a transaction. </li><li>  If a transaction is rolled back, the trigger changes are also rolled back. </li><li>  Triggers do not allow DDL and transaction management statements (exceptions are autonomous transactions). </li></ul><br><br>  The <b>simple_dml_trigger</b> construction <b>:</b> <br><img src="https://habrastorage.org/files/264/a0b/d19/264a0bd19eac4875a2bee996de03917c.png"><br>  Where, <b>dml_event_clause:</b> <br><img src="https://habrastorage.org/files/186/8f1/8ef/1868f18efd8e46eab3a2d6a7449d46f9.png"><br>  <b>referencing_clause:</b> <br><img src="https://habrastorage.org/files/a7a/ab7/988/a7aab7988e7f4992b0a2d49c03d83032.png"><br>  <b>trigger_edition_clause:</b> <br><img src="https://habrastorage.org/files/9ae/521/634/9ae5216349ba4ae7a6d068ac10f3e5f1.png"><br>  <b>trigger_body:</b> <br><img src="https://habrastorage.org/files/813/e81/7c2/813e817c2e494d0a9262d3d9753a9954.png"><br><br>  <b>By anchored object are divided into:</b> <br><ul><li>  On the table </li><li>  On the submission (instead of trigger) </li></ul><br><br>  <b>On launch events:</b> <br><ul><li>  Insert records (insert) </li><li>  Updating records (update) </li><li>  Deleting entries (delete) </li></ul><br><br>  <b>By scope:</b> <br><ul><li>  Statement level triggers </li><li>  Record Level (row level triggers) </li><li>  Compound triggers </li></ul><br><br>  <b>By response time:</b> <br><ul><li>  Before performing the operation (before) </li><li>  After the operation (after) </li></ul><br><br>  <b>Crossedition triggers</b> - used for inter-editing interaction, for example, for transferring and transforming data from fields that are not in the new edition to other fields. <br><br>  Conditional predicates to determine the operation on which the trigger worked: <br><table><tbody><tr><th>  Predicate </th><th>  Description </th></tr><tr><td>  Inserting </td><td>  True if trigger triggered on Insert operation </td></tr><tr><td>  Updating </td><td>  True if trigger triggered on Update operation </td></tr><tr><td>  Updating ('colum') </td><td>  True if the trigger was triggered by an Update operation that affects a specific field. </td></tr><tr><td>  Deleting </td><td>  True if trigger triggered on Delete operation </td></tr></tbody></table><br><br>  These predicates can be used anywhere Boolean expressions can be used. <br><br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">BEFORE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> salary, department_id <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> employees <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> INSERTING <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> DBMS_OUTPUT.PUT_LINE(<span class="hljs-string"><span class="hljs-string">'Inserting'</span></span>); WHEN UPDATING('salary') THEN DBMS_OUTPUT.PUT_LINE('Updating salary'); WHEN UPDATING('department_id') THEN DBMS_OUTPUT.PUT_LINE('Updating department ID'); WHEN DELETING THEN DBMS_OUTPUT.PUT_LINE('Deleting'); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>;</code> </pre> <br></div></div><br><br><a name="Three"></a><h2>  <b>Pseudo recordings</b> </h2><br>  There are pseudo-entries that allow you to refer to the fields of a variable record and get the field values ‚Äã‚Äãbefore the change and the field values ‚Äã‚Äãafter the change.  These are old and new entries.  Using the <b>Referencing</b> construct, you can change their names.  The structure of these entries is tablename% rowtype.  These entries are only for row level triggers or compound triggers (with sections of the recording level). <br><table><tbody><tr><th>  Trigger Operation </th><th>  OLD.column </th><th>  NEW.column </th></tr><tr><td>  Insert </td><td>  Null </td><td>  New value </td></tr><tr><td>  Update </td><td>  Old meaning </td><td>  New value </td></tr><tr><td>  Delete </td><td>  Old meaning </td><td>  Null </td></tr></tbody></table><br><br>  <b>Restrictions:</b> <br><ul><li>  With pseudo-records, operations of the entire record level are prohibited (: new = null;) </li><li>  You cannot change the values ‚Äã‚Äãof the old record fields </li><li>  If the trigger fires on delete, you cannot change the field values ‚Äã‚Äãof new </li><li>  In the after trigger, you cannot change the field values ‚Äã‚Äãof new </li></ul><br><br><a name="Four"></a><h2>  <b>Instead of dml triggers</b> </h2><br><ul><li>  They are created for views (view) and serve to replace DML operations with their functionality. </li><li>  Enables insert / update or delete operations for non-updated views. </li></ul><br><br>  Construction <b>instead_of_dml_trigger:</b> <br><img src="https://habrastorage.org/files/8c1/f9b/8fc/8c1f9b8fcdbe4cbdbc26b8d3131250b1.png"><br><br><ul><li>  This is always the trigger level record (row level) </li><li>  It has access to old and new pseudo-records, but cannot change them. </li><li>  Replaces dml operation with view </li></ul><br><br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> order_info <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> c.customer_id, c.cust_last_name, c.cust_first_name, o.order_id, o.order_date, o.order_status <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> customers c, orders o <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.customer_id = o.customer_id; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> order_info_insert INSTEAD <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> order_info <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> duplicate_info <span class="hljs-keyword"><span class="hljs-keyword">EXCEPTION</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">PRAGMA</span></span> EXCEPTION_INIT (duplicate_info, <span class="hljs-number"><span class="hljs-number">-00001</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> customers (customer_id, cust_last_name, cust_first_name) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> ( :new.customer_id, :new.cust_last_name, :new.cust_first_name); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> orders (order_id, order_date, customer_id) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> ( :new.order_id, :new.order_date, :new.customer_id); EXCEPTION WHEN duplicate_info THEN RAISE_APPLICATION_ERROR ( num=&gt; -20107, msg=&gt; 'Duplicate customer or order ID'); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> order_info_insert;</code> </pre><br></div></div><br><br><a name="Five"></a><h2>  <b>Instead of triggers on Nested Table Columns of Views</b> </h2><br>  You can create a trigger for a nested table view.  In such a trigger, there is also an additional pseudo-record - parent, which refers to the entire record of the view (standard pseudo-records old and new refer only to the records of the nested table) <br><br><div class="spoiler">  <b class="spoiler_title">An example of such a trigger</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">-- Create type of nested table element: CREATE OR REPLACE TYPE nte AUTHID DEFINER IS OBJECT ( emp_id NUMBER(6), lastname VARCHAR2(25), job VARCHAR2(10), sal NUMBER(8,2) ); / -- Created type of nested table: CREATE OR REPLACE TYPE emp_list_ IS TABLE OF nte; / -- Create view: CREATE OR REPLACE VIEW dept_view AS SELECT d.department_id, d.department_name, CAST (MULTISET (SELECT e.employee_id, e.last_name, e.job_id, e.salary FROM employees e WHERE e.department_id = d.department_id ) AS emp_list_ ) emplist FROM departments d; -- Create trigger: CREATE OR REPLACE TRIGGER dept_emplist_tr INSTEAD OF INSERT ON NESTED TABLE emplist OF dept_view REFERENCING NEW AS Employee PARENT AS Department FOR EACH ROW BEGIN -- Insert on nested table translates to insert on base table: INSERT INTO employees ( employee_id, last_name, email, hire_date, job_id, salary, department_id ) VALUES ( :Employee.emp_id, -- employee_id :Employee.lastname, -- last_name :Employee.lastname || '@company.com', -- email SYSDATE, -- hire_date :Employee.job, -- job_id :Employee.sal, -- salary :Department.department_id -- department_id ); END;</span></span></code> </pre><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Triggers a trigger statement insert</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> d.emplist <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dept_view d <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> department_id = <span class="hljs-number"><span class="hljs-number">10</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1001</span></span>, <span class="hljs-string"><span class="hljs-string">'Glenn'</span></span>, <span class="hljs-string"><span class="hljs-string">'AC_MGR'</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>);</code> </pre><br></div></div><br><br><a name="Six"></a><h2>  <b>Compound DML triggers (compound DML triggers)</b> </h2><br>  Appeared in version 11G, these triggers include processing of all kinds of DML triggers in one block. <br>  Construction <b>compound_dml_trigger:</b> <br><img src="https://habrastorage.org/files/8fe/2c9/6a5/8fe2c96a569d4219babc3bba006c6796.png"><br><br>  Where, <b>compound_trigger_block:</b> <br><img src="https://habrastorage.org/files/22d/c45/e45/22dc45e459e74018b41751514042be61.png"><br><br>  <b>timing_point_section:</b> <br><img src="https://habrastorage.org/files/a77/f50/232/a77f502324e8426f881104ba281fff2d.png"><br><br>  <b>timing_point:</b> <br><img src="https://habrastorage.org/files/91f/c31/1fe/91fc311fef80418c8c5433a3d3adc2cc.png"><br><br>  <b>tps_body:</b> <br><img src="https://habrastorage.org/files/fce/819/015/fce819015c75488ba80f378fbdd51347.png"><br><br><ul><li>  Triggers such triggers at different events and at different points in time (at the level of the operator or line, when inserting / updating / deleting, before or after the event). </li><li>  Cannot be offline transactions. </li></ul><br>  Mainly used to: <br><ul><li>  Collect rows for insertion into another table in order to intermittently insert them in batches. </li><li>  Avoid mutating-table error </li></ul><br><br><a name="Seven"></a><h3>  <b>Composite trigger structure</b> </h3><br>  May contain variables that live throughout the execution of the statement that caused the trigger to fire. <br>  This trigger contains the following sections: <br><ul><li>  Before statement </li><li>  After statement </li><li>  Before each row </li><li>  After each row </li></ul><br>  In these triggers there is no initialization section, but for these purposes you can use the section before statement. <br>  If there is neither a section before statement, nor a section after statement in the trigger, and the operator does not affect any records, this trigger does not work. <br><br>  <b>Restrictions:</b> <br><ul><li>  Cannot access old, new or parent pseudo-records in expression level sections (before statement and after statement) </li><li>  You can only change the values ‚Äã‚Äãof the pseudo-record fields in the before each row section. </li><li>  Exceptions generated in one section cannot be processed in another section. </li><li>  If a goto statement is used, it must point to a code in the same section. </li></ul><br><br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span> tr_table_test_compound <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> table_test <span class="hljs-keyword"><span class="hljs-keyword">compound</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span> v_count pls_integer := <span class="hljs-number"><span class="hljs-number">0</span></span>; before statement is <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> dbms_output.put_line ( <span class="hljs-string"><span class="hljs-string">'before statement'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statement</span></span>; before each row is <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> dbms_output.put_line ( <span class="hljs-string"><span class="hljs-string">'before insert'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; after each row is <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> dbms_output.put_line ( <span class="hljs-string"><span class="hljs-string">'after insert'</span></span> ); v_count := v_count + 1; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; after statement is <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> dbms_output.put_line ( <span class="hljs-string"><span class="hljs-string">'after statement'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statement</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> tr_table_test_compound;</code> </pre><br></div></div><br><br><a name="Eight"></a><h2>  <b>Basic rules for determining DML triggers</b> </h2><br><ul><li>  Update of - allows you to specify a list of editable fields for triggering </li><li>  All conditions in the header and When ... are checked without trigger triggering at the stage of SQL execution. </li><li>  You can use only built-in functions in a When statement. </li><li>  You can make several triggers of the same type, the execution order is not defined by default, but it can be specified using the FOLLOWS TRIGGER_FIRST construct </li><li>  Uniqueness constraints are checked when the record is changed, that is, after the execution of the triggers before </li><li>  The variable declaration section is defined by the word DECLARE </li><li>  The main trigger block follows the same rules as regular PL / SQL blocks. </li></ul><br><br><a name="Nine"></a><h2>  <b>Limitations of DML Triggers</b> </h2><br><ul><li>  DDL statements cannot be executed (only in an autonomous transaction) </li><li>  cannot run subroutines with transaction control statements </li><li>  does not have access to SERIALLY_REUSABLE packages </li><li>  size can not exceed 32K </li><li>  variables of type LONG and LONG RAW cannot be declared </li></ul><br><br><a name="Ten"></a><h2>  <b>Error mutation table ORA-04091</b> </h2><br><br>  If you try to get or change data in the target table in a row-level trigger, then Oracle will not allow this and throws an ORA-04091 error. The TABLE_TEST table changes, the trigger / function may not notice it. <br>  To work around this problem, use the following techniques: <br><ul><li>  use operation level triggers </li><li>  autonomous transaction in trigger </li><li>  use third-party structures (package level collections) </li><li>  use COMPOUND TRIGGER </li><li>  change of the algorithm itself with the removal of the functional from the trigger </li></ul><br><br><a name="Eleven"></a><h1>  <b>System triggers (System triggers)</b> </h1><br>  <b>System_trigger</b> construction <b>:</b> <br><img src="https://habrastorage.org/files/ad7/cf1/e32/ad7cf1e32e2d41739a3a9b8d80e2b5a1.png"><br>  Such triggers apply to either the schema or the entire database. <br><br>  There are several options at which point in time the system trigger is triggered: <br><ul><li>  Before the operation is performed (which triggers the trigger) </li><li>  After the operation is performed (which triggers the trigger) </li><li>  Instead of the Create statement </li></ul><br><br><a name="Twelve"></a><h2>  <b>Schema level triggers</b> </h2><br><ul><li>  It is always triggered when the user who owns the schema triggers an event (performs an operation) on which the trigger should fire. </li><li>  In case any other user starts a procedure / function that is called with the creator's rights, and in this procedure / function, the operation for which the system trigger is created is performed - this trigger will trigger. </li></ul><br><br><div class="spoiler">  <b class="spoiler_title">Trigger example</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> drop_trigger <span class="hljs-keyword"><span class="hljs-keyword">BEFORE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> hr.SCHEMA <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> RAISE_APPLICATION_ERROR ( <span class="hljs-keyword"><span class="hljs-keyword">num</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">-20000</span></span>, msg =&gt; <span class="hljs-string"><span class="hljs-string">'Cannot drop object'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>;</code> </pre><br></div></div><br><br><a name="Thirteen"></a><h2>  <b>Database Triggers (database triggers)</b> </h2><br><ul><li>  Such a trigger is triggered when any database user executes the command on which the trigger is created. </li></ul><br><br><div class="spoiler">  <b class="spoiler_title">Trigger example</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> check_user <span class="hljs-keyword"><span class="hljs-keyword">AFTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOGON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DATABASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> check_user; EXCEPTION WHEN OTHERS THEN RAISE_APPLICATION_ERROR (-20000, 'Unexpected error: '|| DBMS_Utility.Format_Error_Stack); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>;</code> </pre><br></div></div><br><br><a name="Fourteen"></a><h2>  <b>Instead of create triggers</b> </h2><br><ul><li>  This is a schema level trigger that responds to the create command and replaces this command with itself (that is, instead of executing the create command, the body of the trigger is executed). </li></ul><br><br><div class="spoiler">  <b class="spoiler_title">Trigger example</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> t INSTEAD <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SCHEMA</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IMMEDIATE</span></span> <span class="hljs-string"><span class="hljs-string">'CREATE TABLE T (n NUMBER, m NUMBER)'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>;</code> </pre><br></div></div><br><br><a name="Fifteen"></a><h2>  <b>Attributes of system triggers</b> </h2><br><table><tbody><tr><th>  Attribute </th><th>  Return value and type </th></tr><tr><td>  ora_client_ip_address </td><td>  Vararch2 <br>  client ip address <br>  <b>Example:</b> <pre> <code class="sql hljs">IF (ora_sysevent = 'LOGON') THEN v_addr := ora_client_ip_address; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>;</code> </pre></td></tr><tr><td>  ora_database_name </td><td>  Varchar2 (50) <br>  database name <br>  <b>Example:</b> <pre> <code class="sql hljs">v_db_name := ora_database_name;</code> </pre> </td></tr><tr><td>  ora_des_encrypted_password </td><td>  Vararch2 <br>  DES-encrypted user password that is created or modified. <br>  <b>Example:</b> <pre> <code class="sql hljs">IF (ora_dict_obj_type = 'USER') THEN <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> event_table <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (ora_des_encrypted_password); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>;</code> </pre></td></tr><tr><td>  ora_dict_obj_name </td><td>  Varchar2 (30) <br>  the name of the object on which the DDL operation is performed <br><br>  <b>Example:</b> <pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> event_table <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'Changed object is '</span></span> || ora_dict_obj_name);</code> </pre></td></tr><tr><td>  ora_dict_obj_name_list ( <br>  name_list OUT ora_name_list_t <br>  ) <br></td><td>  Pls_integer <br>  number of objects changed by the command <br>  Name_list - list of objects changed by the command <br><br>  <b>Example:</b> <pre> <code class="sql hljs">IF (ora_sysevent='ASSOCIATE STATISTICS') THEN number_modified := ora_dict_obj_name_list(name_list); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>;</code> </pre></td></tr><tr><td>  ora_dict_obj_owner </td><td>  Varchar2 (30) <br>  the owner of the object on which the DDL operation is performed <br><br>  <b>Example:</b> <pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> event_table <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'object owner is'</span></span> || ora_dict_obj_owner);</code> </pre></td></tr><tr><td>  ora_dict_obj_owner_list ( <br>  owner_list OUT ora_name_list_t <br>  ) <br></td><td>  Pls_integer <br>  number of owners of objects changed by the team <br>  Owner_list - the list of owners of the objects changed by the command <br><br>  <b>Example:</b> <pre> <code class="sql hljs">IF (ora_sysevent='ASSOCIATE STATISTICS') THEN number_modified := ora_dict_obj_name_list(owner_list); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>;</code> </pre></td></tr><tr><td>  ora_dict_obj_type </td><td>  Varchar2 (20) <br>  the type of the object on which the ddl operation is performed <br><br>  <b>Example:</b> <pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> event_table <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'This object is a '</span></span> || ora_dict_obj_type);</code> </pre></td></tr><tr><td>  ora_grantee ( <br>  user_list OUT ora_name_list_t <br>  ) <br></td><td>  Pls_integer <br>  number of users involved in the grant operation <br>  User_list is a list of these users. <br><br>  <b>Example:</b> <pre> <code class="sql hljs">IF (ora_sysevent = '<span class="hljs-keyword"><span class="hljs-keyword">GRANT</span></span><span class="hljs-string"><span class="hljs-string">') THEN number_of_grantees := ora_grantee(user_list); END IF;</span></span></code> </pre></td></tr><tr><td>  ora_instance_num </td><td>  Number <br>  instance number <br><br>  <b>Example:</b> <pre> <code class="sql hljs">IF (ora_instance_num = 1) THEN <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> event_table <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'1'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>;</code> </pre></td></tr><tr><td>  ora_is_alter_column ( <br>  column_name IN VARCHAR2 <br>  ) <br></td><td>  Boolean <br>  True if the specified field was changed by the alter operation.  Otherwise false <br><br>  <b>Example:</b> <pre> <code class="sql hljs">IF (ora_sysevent = '<span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span><span class="hljs-string"><span class="hljs-string">' AND ora_dict_obj_type = '</span></span><span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span><span class="hljs-string"><span class="hljs-string">') THEN alter_column := ora_is_alter_column('</span></span>C<span class="hljs-string"><span class="hljs-string">'); END IF;</span></span></code> </pre></td></tr><tr><td>  ora_is_creating_nested_table </td><td>  Boolean <br>  true if the current event is the creation of a nested table.  Otherwise false <br><br>  <b>Example:</b> <pre> <code class="sql hljs">IF (ora_sysevent = '<span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span><span class="hljs-string"><span class="hljs-string">' AND ora_dict_obj_type = '</span></span><span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span><span class="hljs-string"><span class="hljs-string">' AND ora_is_creating_nested_table) THEN INSERT INTO event_table VALUES ('</span></span>A <span class="hljs-keyword"><span class="hljs-keyword">nested</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> created<span class="hljs-string"><span class="hljs-string">'); END IF;</span></span></code> </pre></td></tr><tr><td>  ora_is_drop_column ( <br>  column_name IN VARCHAR2 <br>  ) <br></td><td>  Boolean <br>  true if the specified field is deleted.  Otherwise false <br><br>  <b>Example:</b> <pre> <code class="sql hljs">IF (ora_sysevent = '<span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span><span class="hljs-string"><span class="hljs-string">' AND ora_dict_obj_type = '</span></span><span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span><span class="hljs-string"><span class="hljs-string">') THEN drop_column := ora_is_drop_column('</span></span>C<span class="hljs-string"><span class="hljs-string">'); END IF;</span></span></code> </pre></td></tr><tr><td>  ora_is_servererror ( <br>  error_number IN VARCHAR2 <br>  ) <br></td><td>  Boolean <br>  true if an exception has been thrown with error_number number.  Otherwise false <br><br>  <b>Example:</b> <pre> <code class="sql hljs">IF ora_is_servererror(error_number) THEN <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> event_table <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'Server error!!'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>;</code> </pre></td></tr><tr><td>  ora_login_user </td><td>  Varchar2 (30) <br>  current user name <br><br>  <b>Example:</b> <pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ora_login_user <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> DUAL;</code> </pre> </td></tr><tr><td>  ora_partition_pos </td><td>  Pls_integer <br>  in instead of trigger for create table position in the text of the sql command, where the partition construction can be inserted <br><br>  <b>Example:</b> <pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">-- Retrieve ora_sql_txt into sql_text variable v_n := ora_partition_pos; v_new_stmt := SUBSTR(sql_text,1,v_n - 1) || ' ' || my_partition_clause || ' ' || SUBSTR(sql_text, v_n));</span></span></code> </pre></td></tr><tr><td>  ora_privilege_list ( <br>  privilege_list OUT ora_name_list_t <br>  ) <br></td><td>  Pls_integer <br>  the number of privileges involved in a grant or revoke operation <br>  Privilege_list - a list of these privileges <br><br>  <b>Example:</b> <pre> <code class="sql hljs">IF (ora_sysevent = '<span class="hljs-keyword"><span class="hljs-keyword">GRANT</span></span><span class="hljs-string"><span class="hljs-string">' OR ora_sysevent = '</span></span><span class="hljs-keyword"><span class="hljs-keyword">REVOKE</span></span><span class="hljs-string"><span class="hljs-string">') THEN number_of_privileges := ora_privilege_list(privilege_list); END IF;</span></span></code> </pre></td></tr><tr><td>  ora_revokee ( <br>  user_list OUT ora_name_list_t <br>  ) <br></td><td>  Pls_integer <br>  the number of users involved in the revoke operation <br>  User_list is a list of these users. <br><br>  <b>Example:</b> <pre> <code class="sql hljs">IF (ora_sysevent = '<span class="hljs-keyword"><span class="hljs-keyword">REVOKE</span></span><span class="hljs-string"><span class="hljs-string">') THEN number_of_users := ora_revokee(user_list); END IF;</span></span></code> </pre></td></tr><tr><td>  ora_server_error ( <br>  position IN PLS_INTEGER <br>  ) <br></td><td>  Number <br>  error code in the specified position error stack, where 1 is the top of the stack <br><br>  <b>Example:</b> <pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> event_table <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'top stack error '</span></span> || ora_server_error(<span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre></td></tr><tr><td>  ora_server_error_depth </td><td>  Pls_integer <br>  number of error messages in error stack <br><br>  <b>Example:</b> <pre> <code class="sql hljs">n := ora_server_error_depth; <span class="hljs-comment"><span class="hljs-comment">-- Use n with functions such as ora_server_error</span></span></code> </pre></td></tr><tr><td>  ora_server_error_msg ( <br>  position IN PLS_INTEGER <br>  ) <br></td><td>  Vararch2 <br>  error message in the specified place error stack <br><br>  <b>Example:</b> <pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> event_table <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'top stack error message'</span></span> || ora_server_error_msg(<span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre></td></tr><tr><td>  ora_server_error_num_params ( <br>  position IN PLS_INTEGER <br>  ) <br></td><td>  Pls_integer <br>  the number of rows replaced (using the% s format) in the specified position error stack <br><br>  <b>Example:</b> <pre> <code class="sql hljs">n := ora_server_error_num_params(1);</code> </pre> </td></tr><tr><td>  ora_server_error_param ( <br>  position IN PLS_INTEGER, <br>  param IN PLS_INTEGER <br>  ) <br></td><td>  Vararch2 <br>  the replaced text in the error message in the specified position error stack (the param on the account returns the replaced text) <br><br>  <b>Example:</b> <pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">-- Second %s in "Expected %s, found %s": param := ora_server_error_param(1,2);</span></span></code> </pre></td></tr><tr><td>  ora_sql_txt ( <br>  sql_text OUT ora_name_list_t <br>  ) <br></td><td>  Pls_integer <br>  the number of items in the pl / sql collection in the sql_text. <br>  The parameter sql_text itself returns the command text for which the trigger worked. <br><br>  <b>Example:</b> <pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> event_table (<span class="hljs-keyword"><span class="hljs-keyword">col</span></span> VARCHAR2(<span class="hljs-number"><span class="hljs-number">2030</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> sql_text ora_name_list_t; n PLS_INTEGER; v_stmt VARCHAR2(2000); <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> n := ora_sql_txt(sql_text); FOR i IN 1..n LOOP v_stmt := v_stmt || sql_text(i); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> event_table <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'text of triggering statement: '</span></span> || v_stmt); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>;</code> </pre></td></tr><tr><td>  ora_sysevent </td><td>  Varchar2 (20) <br>  the name of the command that triggers <br><br>  <b>Example:</b> <pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> event_table <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (ora_sysevent);</code> </pre></td></tr><tr><td>  ora_with_grant_option </td><td>  Boolean <br>  true if privileges are granted with a grant option.  Otherwise false. <br><br>  <b>Example:</b> <pre> <code class="sql hljs">IF (ora_sysevent = '<span class="hljs-keyword"><span class="hljs-keyword">GRANT</span></span><span class="hljs-string"><span class="hljs-string">' AND ora_with_grant_option = TRUE) THEN INSERT INTO event_table VALUES ('</span></span><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">grant</span></span> <span class="hljs-keyword"><span class="hljs-keyword">option</span></span><span class="hljs-string"><span class="hljs-string">'); END IF;</span></span></code> </pre></td></tr><tr><td>  ora_space_error_info ( <br>  error_number OUT NUMBER <br>  error_type OUT VARCHAR2, <br>  object_owner out VARCHAR2, <br>  table_space_name OUT VARCHAR2, <br>  object_name OUT VARCHAR2, <br>  sub_object_name OUT VARCHAR2 <br>  ) <br></td><td>  Boolean <br>  true if the error occurs due to lack of space.  In the output parameters of the object. <br><br>  <b>Example:</b> <pre> <code class="sql hljs">IF (ora_space_error_info ( eno,typ,owner,ts,obj,subobj) = TRUE) THEN DBMS_OUTPUT.PUT_LINE('The object '|| obj || ' owned by ' || owner || ' has run out of space.'); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>;</code> </pre></td></tr></tbody></table><br><br><a name="Sixteen"></a><h2>  <b>System Trigger Events</b> </h2><br><table><tbody><tr><th>  Event </th><th>  Description </th><th>  Available Attributes </th></tr><tr><td>  AFTER STARTUP </td><td>  When starting the database.  It happens only the database level.  When an error is written to the system log. </td><td>  ora_sysevent <br>  ora_login_user <br>  ora_instance_num <br>  ora_database_name <br></td></tr><tr><td>  BEFORE SHUTDOWN </td><td>  Before the server starts the shutdown process.  It happens only the database level.  When an error is written to the system log. </td><td>  ora_sysevent <br>  ora_login_user <br>  ora_instance_num <br>  ora_database_name <br></td></tr><tr><td>  AFTER DB_ROLE_CHANGE </td><td>  When you start the database for the first time after changing roles from standby to primary or from primary to primary to standby. <br>  it is used only in the Data Guard configuration; there is only a database level. <br></td><td>  ora_sysevent <br>  ora_login_user <br>  ora_instance_num <br>  ora_database_name <br></td></tr><tr><td>  AFTER SERVEREROR </td><td>  If any error occurs (if with a condition, then it only works for the error specified in the condition).  When an error occurs in the body of a trigger, it does not call itself recursively. </td><td>  ora_sysevent <br>  ora_login_user <br>  ora_instance_num <br>  ora_database_name <br>  ora_server_error <br>  ora_is_servererror <br>  ora_space_error_info <br></td></tr><tr><td>  BEFORE ALTER <br><br>  AFTER ALTER <br></td><td>  If the object is changed by the alter command </td><td>  ora_sysevent <br>  ora_login_user <br>  ora_instance_num <br>  ora_database_name <br>  ora_dict_obj_type <br>  ora_dict_obj_name <br>  ora_dict_obj_owner <br>  ora_des_encrypted_password <br>  (for ALTER USER events) <br>  ora_is_alter_column <br>  (for ALTER TABLE events) <br>  ora_is_drop_column <br>  (for ALTER TABLE events) <br></td></tr><tr><td>  BEFORE DROP <br><br>  AFTER DROP <br></td><td>  When deleting an object </td><td>  ora_sysevent <br>  ora_login_user <br>  ora_instance_num <br>  ora_database_name <br>  ora_dict_obj_type <br>  ora_dict_obj_name <br>  ora_dict_obj_owner <br></td></tr><tr><td>  BEFORE ANALYZE <br><br>  AFTER ANALYZE <br></td><td>  When the analyze command is triggered </td><td>  ora_sysevent <br>  ora_login_user <br>  ora_instance_num <br>  ora_database_name <br>  ora_dict_obj_name <br>  ora_dict_obj_type <br>  ora_dict_obj_owner <br></td></tr><tr><td>  BEFORE ASSOCIATE STATISTICS <br><br>  AFTER ASSOCIATE STATISTICS <br></td><td>  When executing associate statistics </td><td>  ora_sysevent <br>  ora_login_user <br>  ora_instance_num <br>  ora_database_name <br>  ora_dict_obj_name <br>  ora_dict_obj_type <br>  ora_dict_obj_owner <br>  ora_dict_obj_name_list <br>  ora_dict_obj_owner_list <br></td></tr><tr><td>  BEFORE AUDIT <br><br>  AFTER AUDIT <br><br>  BEFORE NOAUDIT <br><br>  AFTER NOAUDIT <br></td><td>  When executing an audit or noaudit command </td><td>  ora_sysevent <br>  ora_login_user <br>  ora_instance_num <br>  ora_database_name <br></td></tr><tr><td>  BEFORE COMMENT <br><br>  AFTER COMMENT <br></td><td>  When adding a comment to an object </td><td>  ora_sysevent <br>  ora_login_user <br>  ora_instance_num <br>  ora_database_name <br>  ora_dict_obj_name <br>  ora_dict_obj_type <br>  ora_dict_obj_owner <br></td></tr><tr><td>  BEFORE CREATE <br><br>  AFTER CREATE <br></td><td>  When creating an object </td><td>  ora_sysevent <br>  ora_login_user <br>  ora_instance_num <br>  ora_database_name <br>  ora_dict_obj_type <br>  ora_dict_obj_name <br>  ora_dict_obj_owner <br>  ora_is_creating_nested_table <br>  (for CREATE TABLE events) <br></td></tr><tr><td>  BEFORE DDL <br><br>  AFTER DDL <br></td><td>  It works on most DDL commands, except: alter database, create control file, create database. </td><td>  ora_sysevent <br>  ora_login_user <br>  ora_instance_num <br>  ora_database_name <br>  ora_dict_obj_name <br>  ora_dict_obj_type <br>  ora_dict_obj_owner <br></td></tr><tr><td>  BEFORE DISASSOCIATE STATISTICS <br><br>  AFTER DISASSOCIATE STATISTICS <br></td><td>  When you run the disassociate statistics command </td><td>  ora_sysevent <br>  ora_login_user <br>  ora_instance_num <br>  ora_database_name <br>  ora_dict_obj_name <br>  ora_dict_obj_type <br>  ora_dict_obj_owner <br>  ora_dict_obj_name_list <br>  ora_dict_obj_owner_list <br></td></tr><tr><td>  BEFORE GRANT <br><br>  AFTER GRANT <br></td><td>  When executing the grant command </td><td>  ora_sysevent <br>  ora_login_user <br>  ora_instance_num <br>  ora_database_name <br>  ora_dict_obj_name <br>  ora_dict_obj_type <br>  ora_dict_obj_owner <br>  ora_grantee <br>  ora_with_grant_option <br>  ora_privilege_list <br></td></tr><tr><td>  BEFORE LOGOFF </td><td>  It triggers before disconnecting a user, it can be a schema or database level </td><td>  ora_sysevent <br>  ora_login_user <br>  ora_instance_num <br>  ora_database_name <br></td></tr><tr><td>  AFTER LOGON </td><td>  It works after the user has successfully established a connection to the database.  When an error prohibits the user from entering  Does not affect SYS. </td><td>  ora_sysevent <br>  ora_login_user <br>  ora_instance_num <br>  ora_database_name <br>  ora_client_ip_address <br></td></tr><tr><td>  BEFORE RENAME <br><br>  AFTER RENAME <br></td><td>  When executing the rename command </td><td>  ora_sysevent <br>  ora_login_user <br>  ora_instance_num <br>  ora_database_name <br>  ora_dict_obj_name <br>  ora_dict_obj_owner <br>  ora_dict_obj_type <br></td></tr><tr><td>  BEFORE REVOKE <br><br>  AFTER REVOKE <br></td><td>  With the revoke command </td><td>  ora_sysevent <br>  ora_login_user <br>  ora_instance_num <br>  ora_database_name <br>  ora_dict_obj_name <br>  ora_dict_obj_type <br>  ora_dict_obj_owner <br>  ora_revokee <br>  ora_privilege_list <br></td></tr><tr><td>  AFTER SUSPEND </td><td>  It works if the sql command is suspended due to a server error (out of memory). <br>  In this case, the trigger must change the conditions so that the command execution is resumed) <br></td><td>  ora_sysevent <br>  ora_login_user <br>  ora_instance_num <br>  ora_database_name <br>  ora_server_error <br>  ora_is_servererror <br>  ora_space_error_info <br></td></tr><tr><td>  BEFORE TRUNCATE <br><br>  AFTER TRUNCATE <br></td><td>  When executing the truncate command </td><td>  ora_sysevent <br>  ora_login_user <br>  ora_instance_num <br>  ora_database_name <br>  ora_dict_obj_name <br>  ora_dict_obj_type <br>  ora_dict_obj_owner <br></td></tr></tbody></table><br><br><a name="Seventeen"></a><h1>  <b>Compiling triggers</b> </h1><br>  If an error occurs during the execution of the create trigger command, the trigger will still be created, but will be in an invalid state.  In this case, all attempts to perform an operation (on which the trigger should fire) on the object on which such a trigger hangs, will end with an error.  This does not apply to cases where: <br><ul><li>  The trigger was created in the disabled state (or transferred to this state) </li><li>  Trigger event after startup on database </li><li>  The trigger event after logon on database or after logon on schema and an attempt is made to login under the user System </li></ul><br>  To recompile a trigger, use the alter trigger command. <br><br><a name="Eighteen"></a><h1>  <b>Trigger Exceptions</b> </h1><br>  In the event that an exception occurs in the trigger, the entire operation is rolled back (including any changes made to the inside of the trigger).  Exceptions to this: <br><ul><li>  If the trigger event is after startup on database or before shutdown on database </li><li>  If the event is a trigger after logon on database and the user has the privilege of administer database trigger </li><li>  If the trigger event is after logon on schema and the user either owns the schema or has the privilege of alter any trigger </li></ul><br><br><a name="Nineteen"></a><h1>  <b>The order of execution of triggers</b> </h1><br>  The <b>trigger_ordering_clause</b> construction <b>:</b> <br><img src="https://habrastorage.org/files/cc9/234/2f4/cc92342f4e204651a50e8df878843103.png"><br><br><ol><li>  First, all the statement before the trigger is executed. </li><li>  Then all before each row of the trigger </li><li>  After all after each row of the trigger </li><li>  And at the end all after statement trigger </li></ol><br>  To set explicitly the order of execution of triggers that fire at the same point in time (because such an order is not defined by default), use the following and precedes constructs. <br><br><a name="Twenty"></a><h1>  <b>Enable / Disable Triggers</b> </h1><br>  This may be necessary, for example, to load a large amount of information into a table. <br>  To enable / disable the trigger, use the command: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> [schema.]trigger_name { <span class="hljs-keyword"><span class="hljs-keyword">ENABLE</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">DISABLE</span></span> };</code> </pre><br>  To enable / disable all triggers on the table at once: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> table_name { <span class="hljs-keyword"><span class="hljs-keyword">ENABLE</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">DISABLE</span></span> } ALL <span class="hljs-keyword"><span class="hljs-keyword">TRIGGERS</span></span>;</code> </pre><br><br>  To change a trigger, you can either use the Create or replace trigger command, or delete the drop trigger first, and then create the create trigger again. <br>  The alter trigger operation only allows you to enable / disable a trigger, compile it or rename it. <br>  Trigger compilation: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span> TRIGGER_NAME compile;</code> </pre><br><br><a name="TwentyOne"></a><h1>  <b>Rights for operations with triggers</b> </h1><br><br>  To work with triggers, even in its scheme, the create trigger privilege is necessary, it gives the rights to create, modify and delete. <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">grant</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">USER</span></span>;</code> </pre><br>  To work with triggers in all other schemes, you need the * any trigger privilege.  Please note that the rights are given separately to create, modify and delete. <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">grant</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">USER</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">grant</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">USER</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">grant</span></span> <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">USER</span></span>;</code> </pre><br>  To work with DATABASE level system triggers, ADMINISTER DATABASE TRIGGER privilege is required. <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">grant</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ADMINISTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DATABASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">USER</span></span>;</code> </pre><br><br><a name="TwentyTwo"></a><h1>  <b>Triggers data dictionaries:</b> </h1><br><ul><li>  <b>dba_triggers</b> - information about triggers </li><li>  <b>dba_source</b> - body code of the trigger </li><li>  <b>dba_objects</b> - trigger validity </li></ul><br><br>  A video recording of the lecture, based on which this article was written: <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/FrTNnnux5JI%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhh6nHi9u3Vkso_moU1LKIF_e5yQXg" frameborder="0" allowfullscreen=""></iframe><br><br>  Many other Oracle-related videos can be found on this channel: <a href="http://www.youtube.com/c/MoscowDevelopmentTeam">www.youtube.com/c/MoscowDevelopmentTeam</a> <br><br><h1>  <b>Other Oracle Articles</b> </h1><br>  <a href="http://habrahabr.ru/post/254355/">All about collections in Oracle</a> </div><p>Source: <a href="https://habr.com/ru/post/256655/">https://habr.com/ru/post/256655/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../256643/index.html">Material Design. Dynamic Toolbar on a live example</a></li>
<li><a href="../256647/index.html">Container in linux, linux in egg, egg in python</a></li>
<li><a href="../256649/index.html">PHP Digest number 61 - interesting news, materials and tools (April 13 - 26, 2015)</a></li>
<li><a href="../256651/index.html">93 video lectures on Scala</a></li>
<li><a href="../256653/index.html">Microsoft SQL Server Data Tools</a></li>
<li><a href="../256659/index.html">Anatomy of IPsec. Check the strength of the legendary protocol</a></li>
<li><a href="../256661/index.html">Car Hacking: Are car safety systems safe?</a></li>
<li><a href="../256663/index.html">Attack on the oracle. Detailed Guide for Oracle DB Attack Vectors</a></li>
<li><a href="../256665/index.html">We play with muscles. Methods and tools for hacking MySQL databases</a></li>
<li><a href="../256667/index.html">We check MS SQL for durability. Vectors of attacks on MS SQL Server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>