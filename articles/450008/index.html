<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Find bugs in LLVM 8 using the PVS-Studio analyzer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="More than two years have passed since the last verification of the LLVM project code with the help of our PVS-Studio analyzer. Let's make sure that th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Find bugs in LLVM 8 using the PVS-Studio analyzer</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f2/8d4/5bf/2f28d45bf369270d9330bfbe2ea78f00.png" alt="PVS-Studio and LLVM 8.0.0"></div><br>  More than two years have passed since the last verification of the LLVM project code with the help of our PVS-Studio analyzer.  Let's make sure that the PVS-Studio analyzer is still the leading tool for identifying errors and potential vulnerabilities.  To do this, check and find new bugs in the release of LLVM 8.0.0. <br><a name="habracut"></a><br><h2>  Article to be written </h2><br>  To be honest, I did not want to write this article.  It is not interesting to write about the project, which we have repeatedly checked ( <a href="https://www.viva64.com/ru/b/0108/">1</a> , <a href="https://www.viva64.com/ru/b/0155/">2</a> , <a href="https://www.viva64.com/ru/b/0446/">3</a> ).  It is better to write about something new, but I have no choice. <br><br>  Every time a new version of LLVM comes out or the <a href="https://clang-analyzer.llvm.org/">Clang Static Analyzer is</a> updated, we have the following type of questions in the mail: <br><br>  <i>See, the new version of Clang Static Analyzer has learned to find new errors!</i>  <i>It seems to me that the relevance of using PVS-Studio is decreasing.</i>  <i>Clang finds more errors than before and catches up with the capabilities of PVS-Studio.</i>  <i>What do you think about it?</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To this I always want to answer something in the spirit: <br><br>  <b>We also do not sit idle!</b>  We have significantly improved the capabilities of the PVS-Studio analyzer.  So do not worry, we continue to lead, as before. <br><br>  Unfortunately, this is a bad answer.  There is no proof.  And that is why I am writing this article now.  So, the LLVM project is once again checked and various errors are found in it.  Those that seemed interesting to me, I will now demonstrate.  These errors cannot be found by Clang Static Analyzer (or it is extremely inconvenient to do with it).  And we can.  And I found and wrote out all these errors in one evening. <br><br>  But writing the article was delayed for several weeks.  I could not force myself to put all this in the form of text :). <br><br>  By the way, if you are wondering what technologies are used in the PVS-Studio analyzer to detect errors and potential vulnerabilities, then I suggest <a href="https://www.viva64.com/ru/b/0592/">reading</a> this <a href="https://www.viva64.com/ru/b/0592/">note</a> . <br><br><h2>  New and old diagnostics </h2><br>  As already noted, about two years ago, the LLVM project was once again checked, and the errors found were corrected.  Now this article will present a new portion of errors.  Why were new bugs found?  There are 3 reasons for this: <br><br><ol><li>  The LLVM project develops, the old code changes, and a new one appears.  Naturally in the modified and written code there are new errors.  This clearly demonstrates that static analysis should be applied regularly, and not occasionally.  Our articles show well the capabilities of the PVS-Studio analyzer, but this has nothing to do with improving the quality of the code and reducing the cost of fixing errors.  Use static code analyzer regularly! </li><li>  We are refining and improving existing diagnostics.  Therefore, the analyzer can detect errors that were not noticed during previous checks. </li><li>  New diagnostics have appeared in PVS-Studio, which were absent 2 years ago.  I decided to allocate them in a separate section in order to demonstrate the development of PVS-Studio. </li></ol><br><h2>  Defects identified by diagnostics that existed 2 years ago </h2><br>  <b>Fragment N1: Copy-Paste</b> <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShouldUpgradeX86Intrinsic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function *F, StringRef Name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Name == <span class="hljs-string"><span class="hljs-string">"addcarryx.u32"</span></span> || <span class="hljs-comment"><span class="hljs-comment">// Added in 8.0 .... Name == "avx512.mask.cvtps2pd.128" || // Added in 7.0 Name == "avx512.mask.cvtps2pd.256" || // Added in 7.0 Name == "avx512.cvtusi2sd" || // Added in 7.0 Name.startswith("avx512.mask.permvar.") || // Added in 7.0 // &lt;= Name.startswith("avx512.mask.permvar.") || // Added in 7.0 // &lt;= Name == "sse2.pmulu.dq" || // Added in 7.0 Name == "sse41.pmuldq" || // Added in 7.0 Name == "avx2.pmulu.dq" || // Added in 7.0 .... }</span></span></code> </pre> <br>  PVS-Studio <a href="https://www.viva64.com/ru/w/v501/">warning</a> : <a href="https://www.viva64.com/ru/w/v501/">V501</a> [CWE-570] There are identical sub-expressions' Name.startswith ("avx512.mask.permvar.")  operator.  AutoUpgrade.cpp 73 <br><br>  It is checked twice that the name begins with the substring "avx512.mask.permvar.".  In the second check, we obviously wanted to write something else, but forgot to correct the copied text. <br><br>  <b>Fragment N2: Typo</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CXNameRefFlags { CXNameRange_WantQualifier = <span class="hljs-number"><span class="hljs-number">0x1</span></span>, CXNameRange_WantTemplateArgs = <span class="hljs-number"><span class="hljs-number">0x2</span></span>, CXNameRange_WantSinglePiece = <span class="hljs-number"><span class="hljs-number">0x4</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AnnotateTokensWorker::HandlePostPonedChildCursor( CXCursor Cursor, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> StartTokenIndex) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> flags = CXNameRange_WantQualifier | CXNameRange_WantQualifier; .... }</code> </pre> <br>  PVS-Studio warning: V501 There are identical sub-expressions 'CXNameRange_WantQualifier' to the left and the right of the '|'  operator.  CIndex.cpp 7245 <br><br>  Because of a typo, the same named constant <i>CXNameRange_WantQualifier is used twice</i> . <br><br>  <b>Fragment N3: Confusion with the priorities of operators</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PPCTTIImpl::getVectorInstrCost(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Opcode, Type *Val, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Index) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == ST-&gt;isLittleEndian() ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; .... }</code> </pre> <br>  PVS-Studio <a href="https://www.viva64.com/ru/w/v502/">warning</a> : <a href="https://www.viva64.com/ru/w/v502/">V502</a> [CWE-783] Perhaps the '?:' Operator works in a different way.  The '?:' Operator has a lower limit than the '==' operator.  PPCTargetTransformInfo.cpp 404 <br><br>  In my opinion, this is a very beautiful mistake.  Yes, I know that I have strange ideas about beauty :). <br><br>  Now, according to the <a href="https://www.viva64.com/ru/t/0064/">priorities of the operators</a> , the expression is calculated as follows: <br><br><pre> <code class="cpp hljs">(ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; (Index == ST-&gt;isLittleEndian())) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  From a practical point of view, this condition does not make sense, since it can be reduced to: <br><br><pre> <code class="cpp hljs">(ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == ST-&gt;isLittleEndian())</code> </pre> <br>  This is an obvious mistake.  Most likely, 0/1 would be compared with the <i>Index</i> variable.  To fix the code you need to add brackets around the ternary operator: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == (ST-&gt;isLittleEndian() ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>))</code> </pre> <br>  By the way, the ternary operator is very dangerous and provokes logical errors.  Be very careful with him and do not be greedy to put parentheses.  I covered this topic in more detail <a href="https://www.viva64.com/ru/b/0391/">here</a> , in the chapter ‚ÄúFear the Operator?: And enclose it in parentheses‚Äù. <br><br>  <b>Fragment N4, N5: Null Index</b> <br><br><pre> <code class="cpp hljs">Init *TGParser::ParseValue(Record *CurRec, RecTy *ItemType, IDParseMode Mode) { .... TypedInit *LHS = dyn_cast&lt;TypedInit&gt;(Result); .... LHS = dyn_cast&lt;TypedInit&gt;( UnOpInit::get(UnOpInit::CAST, LHS, StringRecTy::get()) -&gt;Fold(CurRec)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!LHS) { Error(PasteLoc, Twine(<span class="hljs-string"><span class="hljs-string">"can't cast '"</span></span>) + LHS-&gt;getAsString() + <span class="hljs-string"><span class="hljs-string">"' to string"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } .... }</code> </pre> <br>  PVS-Studio <a href="https://www.viva64.com/ru/w/v522/">warning</a> : <a href="https://www.viva64.com/ru/w/v522/">V522</a> [CWE-476] Dereferencing of the null pointer 'LHS' might take place.  TGParser.cpp 2152 <br><br>  If the <i>LHS</i> appears to be zero, a warning should be issued.  However, instead of this, this null pointer itself will be dereferenced: <i>LHS-&gt; getAsString ()</i> . <br><br>  This is a very typical situation when an error is hidden in the error handler, as no one tests them.  Static analyzers check all reachable code, no matter how often it is used.  This is a very good example of how static analysis complements other testing and error protection techniques. <br><br>  A similar <i>RHS</i> pointer processing error was made in the code just below: V522 [CWE-476] Dereferencing of the null pointer 'RHS' might take place.  TGParser.cpp 2186 <br><br>  <b>Fragment N6: Using the pointer after moving</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; ExtractBlocks(....) { .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; ProgClone = CloneModule(BD.getProgram(), VMap); .... BD.setNewProgram(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ProgClone)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= MiscompiledFunctions.clear(); for (unsigned i = 0, e = MisCompFunctions.size(); i != e; ++i) { Function *NewF = ProgClone-&gt;getFunction(MisCompFunctions[i].first); // &lt;= assert(NewF &amp;&amp; "Function not found??"); MiscompiledFunctions.push_back(NewF); } .... }</span></span></code> </pre> <br>  PVS-Studio warning: V522 [CWE-476] Dereferencing of the null pointer 'ProgClone' might take place.  Miscompilation.cpp 601 <br><br>  At the beginning, the smart pointer <i>ProgClone</i> ceases to own the object: <br><br><pre> <code class="cpp hljs">BD.setNewProgram(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ProgClone));</code> </pre> <br>  In fact, now <i>ProgClone</i> is a null pointer.  Therefore, a null pointer dereference should occur just below: <br><br><pre> <code class="cpp hljs">Function *NewF = ProgClone-&gt;getFunction(MisCompFunctions[i].first);</code> </pre> <br>  But, in fact, this will not happen!  Note that the loop is not actually executed. <br><br>  At the beginning, the <i>MiscompiledFunctions</i> container is cleared: <br><br><pre> <code class="cpp hljs">MiscompiledFunctions.clear();</code> </pre> <br>  Further, the size of this container is used in the loop condition: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, e = MisCompFunctions.size(); i != e; ++i) {</code> </pre> <br>  It is easy to see that the cycle does not start.  I think this is also a mistake, and the code should be written in a different way. <br><br>  It seems that we met the very famous parity of errors!  One mistake masks another :). <br><br>  <b>Fragment N7: Using the pointer after moving</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; TestOptimizer(BugDriver &amp;BD, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; Test, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; Safe) { outs() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" Optimizing functions being tested: "</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; Optimized = BD.runPassesOn(Test.get(), BD.getPassesToRun()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Optimized) { errs() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" Error running this sequence of passes"</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">" on the input program!\n"</span></span>; BD.setNewProgram(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(Test)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= BD.EmitProgressBitcode(*Test, "pass-error", false); // &lt;= if (Error E = BD.debugOptimizerCrash()) return std::move(E); return false; } .... }</span></span></code> </pre> <br>  PVS-Studio warning: V522 [CWE-476] Dereferencing of the null pointer 'Test' might take place.  Miscompilation.cpp 709 <br><br>  Again the same situation.  At the beginning, the contents of the object are moved, and then it is used as if nothing had happened.  I increasingly encounter this situation in the program code, after the semantics of displacement appeared in C ++.  That's why I love the C ++ language!  There are more and more new ways to shoot yourself a leg.  PVS-Studio analyzer will always have a job :). <br><br>  <b>Fragment N8: Null Index</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> FunctionDumper::dump(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PDBSymbolTypeFunctionArg &amp;Symbol) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> TypeId = Symbol.getTypeId(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Type = Symbol.getSession().getSymbolById(TypeId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Type) Printer &lt;&lt; <span class="hljs-string"><span class="hljs-string">"&lt;unknown-type&gt;"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Type-&gt;dump(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  PVS-Studio warning: V522 [CWE-476] Dereferencing of the null pointer 'Type' might take place.  PrettyFunctionDumper.cpp 233 <br><br>  In addition to error handlers, debugging printout functions are usually not tested.  Before us is just such a case.  The function waits for the user, who, instead of solving his problems, will be forced to fix it. <br><br>  Right: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Type) Type-&gt;dump(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Printer &lt;&lt; <span class="hljs-string"><span class="hljs-string">"&lt;unknown-type&gt;"</span></span>;</code> </pre> <br>  <b>Fragment N9: Null Index</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SearchableTableEmitter::collectTableEntries( GenericTable &amp;Table, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Record *&gt; &amp;Items) { .... RecTy *Ty = resolveTypes(Field.RecType, TI-&gt;getType()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Ty) <span class="hljs-comment"><span class="hljs-comment">// &lt;= PrintFatalError(Twine("Field '") + Field.Name + "' of table '" + Table.Name + "' has incompatible type: " + Ty-&gt;getAsString() + " vs. " + // &lt;= TI-&gt;getType()-&gt;getAsString()); .... }</span></span></code> </pre> <br>  PVS-Studio warning: V522 [CWE-476] Dereferencing of the null pointer 'Ty' might take place.  SearchableTableEmitter.cpp 614 <br><br>  I think everything is clear and requires no explanation. <br><br>  <b>Fragment N10: Typo</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> FormatTokenLexer::tryMergeCSharpNullConditionals() { .... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;Identifier = *(Tokens.end() - <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;Question = *(Tokens.end() - <span class="hljs-number"><span class="hljs-number">1</span></span>); .... Identifier-&gt;ColumnWidth += Question-&gt;ColumnWidth; Identifier-&gt;Type = Identifier-&gt;Type; <span class="hljs-comment"><span class="hljs-comment">// &lt;= Tokens.erase(Tokens.end() - 1); return true; }</span></span></code> </pre> <br>  PVS-Studio <a href="https://www.viva64.com/ru/w/v570/">warning</a> : <a href="https://www.viva64.com/ru/w/v570/">V570</a> The 'Identifier-&gt; Type' variable is assigned to itself.  FormatTokenLexer.cpp 249 <br><br>  It makes no sense to assign a variable to itself.  Most likely they wanted to write: <br><br><pre> <code class="cpp hljs">Identifier-&gt;Type = Question-&gt;Type;</code> </pre> <br>  <b>Fragment N11: Suspicious break</b> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SystemZOperand::print(raw_ostream &amp;OS) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Kind) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KindToken: OS &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Token:"</span></span> &lt;&lt; getToken(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KindReg: OS &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Reg:"</span></span> &lt;&lt; SystemZInstPrinter::getRegisterName(getReg()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... }</code> </pre> <br>  PVS-Studio <a href="https://www.viva64.com/ru/w/v622/">warning</a> : <a href="https://www.viva64.com/ru/w/v622/">V622</a> [CWE-478] Consider inspecting the 'switch' statement.  It's possible that the operator is missing.  SystemZAsmParser.cpp 652 <br><br>  At the beginning there is a very suspicious <i>break</i> statement.  Have you forgotten to write something else? <br><br>  <b>Fragment N12: Check pointer after dereference</b> <br><br><pre> <code class="cpp hljs">InlineCost AMDGPUInliner::getInlineCost(CallSite CS) { Function *Callee = CS.getCalledFunction(); Function *Caller = CS.getCaller(); TargetTransformInfo &amp;TTI = TTIWP-&gt;getTTI(*Callee); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Callee || Callee-&gt;isDeclaration()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> llvm::InlineCost::getNever(<span class="hljs-string"><span class="hljs-string">"undefined callee"</span></span>); .... }</code> </pre> <br>  PVS-Studio <a href="https://www.viva64.com/ru/w/v595/">warning</a> : <a href="https://www.viva64.com/ru/w/v595/">V595</a> [CWE-476]  Check lines: 172, 174. AMDGPUInline.cpp 172 <br><br>  The <i>Callee</i> pointer is first dereferenced at the time of the <i>getTTI</i> function <i>call</i> . <br><br>  And then it turns out that this pointer should be checked for equality <i>nullptr</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Callee || Callee-&gt;isDeclaration())</code> </pre> <br>  But it's' too late‚Ä¶ <br><br>  <b>Fragment N13 - N ...: Check pointer after dereference</b> <br><br>  The situation described in the previous code snippet is not unique.  She is found here: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Value *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">optimizeDoubleFP</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallInst *CI, IRBuilder&lt;&gt; &amp;B, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isBinary, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isPrecise = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ .... Function *CalleeFn = CI-&gt;getCalledFunction(); StringRef CalleeNm = CalleeFn-&gt;getName(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= AttributeList CalleeAt = CalleeFn-&gt;getAttributes(); if (CalleeFn &amp;&amp; !CalleeFn-&gt;isIntrinsic()) { // &lt;= .... }</span></span></code> </pre> <br>  PVS-Studio warning: V595 [CWE-476]  Check lines: 1079, 1081. SimplifyLibCalls.cpp 1079 <br><br>  And here: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Sema::InstantiateAttrs(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MultiLevelTemplateArgumentList &amp;TemplateArgs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Decl *Tmpl, Decl *New, LateInstantiatedAttrVec *LateAttrs, LocalInstantiationScope *OuterMostScope) { .... NamedDecl *ND = dyn_cast&lt;NamedDecl&gt;(New); CXXRecordDecl *ThisContext = dyn_cast_or_null&lt;CXXRecordDecl&gt;(ND-&gt;getDeclContext()); <span class="hljs-comment"><span class="hljs-comment">// &lt;= CXXThisScopeRAII ThisScope(*this, ThisContext, Qualifiers(), ND &amp;&amp; ND-&gt;isCXXInstanceMember()); // &lt;= .... }</span></span></code> </pre> <br>  PVS-Studio warning: V595 [CWE-476]  Check lines: 532, 534. SemaTemplateInstantiateDecl.cpp 532 <br><br>  And here: <br><br><ul><li>  V595 [CWE-476] The 'U' pointer was used before it was verified against nullptr.  Check lines: 404, 407. DWARFFormValue.cpp 404 </li><li>  V595 [CWE-476] The 'ND' pointer was used against nullptr.  Check lines: 2149, 2151. SemaTemplateInstantiate.cpp 2149 </li></ul><br>  And then I was not interested in studying the warnings with the number V595.  So I do not know if there are any more similar errors besides those listed here.  Most likely there. <br><br>  <b>Fragment N17, N18: Suspicious Shift</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processLogicalImmediate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Imm, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RegSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;Encoding)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Size = RegSize; .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> NImms = ~(Size<span class="hljs-number"><span class="hljs-number">-1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>; .... }</code> </pre> <br>  PVS-Studio <a href="https://www.viva64.com/ru/w/v629/">warning</a> : <a href="https://www.viva64.com/ru/w/v629/">V629</a> [CWE-190] Consider inspecting the '~ (Size - 1) &lt;&lt; 1' expression.  Bit shifting of the 32-bit type.  AArch64AddressingModes.h 260 <br><br>  Perhaps this is not an error, and the code works exactly as intended.  But this is clearly a very suspicious place, and it needs to be checked. <br><br>  Suppose the <i>Size</i> variable is 16, and then the author of the code planned to get the value in the <i>NImms</i> variable: <br><br>  11111111111111111111111111111111111111111111111111111111100000 <br><br>  However, in fact, you get the value: <br><br>  00000000000000000000000000000011111111111111111111111111100000 <br><br>  The point is that all calculations are performed using the 32-bit unsigned type.  And only then, this 32-bit unsigned type will be implicitly extended to <i>uint64_t</i> .  In this case, the high bits will be zero. <br><br>  You can fix the situation like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> NImms = ~<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>&gt;(Size<span class="hljs-number"><span class="hljs-number">-1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Similar situation: V629 [CWE-190] Consider inspecting the 'Immr &lt;&lt; 6' expression.  Bit shifting of the 32-bit type.  AArch64AddressingModes.h 269 <br><br>  <b>Fragment N19: Missing the</b> <b><i>else</i></b> <b>keyword</b> <b>?</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AMDGPUAsmParser::cvtDPP(MCInst &amp;Inst, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OperandVector &amp;Operands) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Op.isReg() &amp;&amp; Op.Reg.RegNo == AMDGPU::VCC) { <span class="hljs-comment"><span class="hljs-comment">// VOP2b (v_add_u32, v_sub_u32 ...) dpp use "vcc" token. // Skip it. continue; } if (isRegOrImmWithInputMods(Desc, Inst.getNumOperands())) { // &lt;= Op.addRegWithFPInputModsOperands(Inst, 2); } else if (Op.isDPPCtrl()) { Op.addImmOperands(Inst, 1); } else if (Op.isImm()) { // Handle optional arguments OptionalIdx[Op.getImmTy()] = I; } else { llvm_unreachable("Invalid operand type"); } .... }</span></span></code> </pre> <br>  PVS-Studio <a href="https://www.viva64.com/ru/w/v646/">warning</a> : <a href="https://www.viva64.com/ru/w/v646/">V646</a> [CWE-670] Consider inspecting the application's logic.  It's possible that 'else' keyword is missing.  AMDGPUAsmParser.cpp 5655 <br><br>  There is no error here.  Since the then-block of the first <i>if</i> ends in <i>continue</i> , it does not matter <i>if the</i> keyword is <i>else</i> or not.  In any case, the code will work the same way.  However, missing <i>else</i> makes the code more obscure and dangerous.  If continue <i>continue</i> disappears, the code will start to work in a completely different way.  In my opinion, it is better to add <i>else</i> . <br><br>  <b>Fragment N20: Four of the same type of typo</b> <br><br><pre> <code class="cpp hljs">LLVM_DUMP_METHOD <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Symbol::dump(raw_ostream &amp;OS) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isUndefined()) Result += <span class="hljs-string"><span class="hljs-string">"(undef) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isWeakDefined()) Result += <span class="hljs-string"><span class="hljs-string">"(weak-def) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isWeakReferenced()) Result += <span class="hljs-string"><span class="hljs-string">"(weak-ref) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isThreadLocalValue()) Result += <span class="hljs-string"><span class="hljs-string">"(tlv) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Kind) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SymbolKind::GlobalSymbol: Result + Name.str(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; case SymbolKind::ObjectiveCClass: Result + "(ObjC Class) " + Name.str(); // &lt;= break; case SymbolKind::ObjectiveCClassEHType: Result + "(ObjC Class EH) " + Name.str(); // &lt;= break; case SymbolKind::ObjectiveCInstanceVariable: Result + "(ObjC IVar) " + Name.str(); // &lt;= break; } OS &lt;&lt; Result; }</span></span></code> </pre> <br>  PVS-Studio warnings: <br><br><ul><li>  V655 [CWE-480] The strings were concatenated but are not utilized.  Consider inspecting the 'Result + Name.str ()' expression.  Symbol.cpp 32 </li><li>  V655 [CWE-480] The strings were concatenated but are not utilized.  Consider inspecting the 'Result + "(ObjC Class)" + Name.str ()' expression.  Symbol.cpp 35 </li><li>  V655 [CWE-480] The strings were concatenated but are not utilized.  Consider inspecting the 'Result + "(ObjC Class EH)" + Name.str ()' expression.  Symbol.cpp 38 </li><li>  V655 [CWE-480] The strings were concatenated but are not utilized.  Consider inspecting the 'Result + "(ObjC IVar)" + Name.str ()' expression.  Symbol.cpp 41 </li></ul><br>  Randomly, instead of the + operator =, the + operator is used.  As a result, constructions are devoid of meaning. <br><br>  <b>Fragment N21: Uncertain behavior</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getReqFeatures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;StringRef, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp;FeaturesMap, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Record *&gt; &amp;ReqFeatures)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;R : ReqFeatures) { StringRef AsmCondString = R-&gt;getValueAsString(<span class="hljs-string"><span class="hljs-string">"AssemblerCondString"</span></span>); SmallVector&lt;StringRef, <span class="hljs-number"><span class="hljs-number">4</span></span>&gt; Ops; SplitString(AsmCondString, Ops, <span class="hljs-string"><span class="hljs-string">","</span></span>); assert(!Ops.empty() &amp;&amp; <span class="hljs-string"><span class="hljs-string">"AssemblerCondString cannot be empty"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;Op : Ops) { assert(!Op.empty() &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Empty operator"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FeaturesMap.find(Op) == FeaturesMap.end()) FeaturesMap[Op] = FeaturesMap.size(); } } }</code> </pre> <br>  Try to find a dangerous code yourself.  And this is a picture to divert attention, so as not to immediately look at the answer: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d5d/183/d4e/d5d183d4e2d3107bc512e52d893fda25.png" alt="Hmmm ..."></div><br><br>  PVS-Studio <a href="https://www.viva64.com/ru/w/v708/">warning</a> : <a href="https://www.viva64.com/ru/w/v708/">V708</a> [CWE-758] Dangerous construction is used: 'FeaturesMap [Op] = FeaturesMap.size ()', where 'FeaturesMap' is of 'map' class.  This may lead to undefined behavior.  RISCVCompressInstEmitter.cpp 490 <br><br>  Problem line: <br><br><pre> <code class="cpp hljs">FeaturesMap[Op] = FeaturesMap.size();</code> </pre> <br>  If the element <i>Op is</i> not found, then a new element is created in the map and the number of elements in this map is recorded there.  It‚Äôs just not known if the <i>size</i> function will be called before or after adding a new element. <br><br>  <b>Fragment N22-N24: Reassignment</b> <br><br><pre> <code class="cpp hljs">Error MachOObjectFile::checkSymbolTable() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MachO::nlist STE = getSymbolTableEntry(SymDRI); NType = STE.n_type; <span class="hljs-comment"><span class="hljs-comment">// &lt;= NType = STE.n_type; // &lt;= NSect = STE.n_sect; NDesc = STE.n_desc; NStrx = STE.n_strx; NValue = STE.n_value; } .... }</span></span></code> </pre> <br>  PVS-Studio <a href="https://www.viva64.com/ru/w/v519/">warning</a> : <a href="https://www.viva64.com/ru/w/v519/">V519</a> [CWE-563] The 'NType' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 1663, 1664. MachOObjectFile.cpp 1664 <br><br>  I think there is no real error here.  Just an extra recurring assignment.  But still a blooper. <br><br>  Similarly: <br><br><ul><li>  V519 [CWE-563] The 'B.NDesc' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 1488, 1489. llvm-nm.cpp 1489 </li><li>  V519 [CWE-563] The variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 59, 61. coff2yaml.cpp 61 </li></ul><br>  <b>Fragment N25-N27: More reassignments</b> <br><br>  Now consider a slightly different reassignment option. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Vectorizer::vectorizeLoadChain( ArrayRef&lt;Instruction *&gt; Chain, SmallPtrSet&lt;Instruction *, <span class="hljs-number"><span class="hljs-number">16</span></span>&gt; *InstructionsProcessed) { .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Alignment = getAlignment(L0); .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> NewAlign = getOrEnforceKnownAlignment(L0-&gt;getPointerOperand(), StackAdjustedAlignment, DL, L0, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, &amp;DT); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NewAlign != <span class="hljs-number"><span class="hljs-number">0</span></span>) Alignment = NewAlign; Alignment = NewAlign; .... }</code> </pre> <br>  PVS-Studio warning: V519 [CWE-563] The 'Alignment' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 1158, 1160. LoadStoreVectorizer.cpp 1160 <br><br>  This is a very strange code, which apparently contains a logical error.  In the beginning, the variable <i>Alignment is</i> assigned a value depending on the condition.  And then assignment occurs again, but now without any verification. <br><br>  Similar situations can be seen here: <br><br><ul><li>  V519 [CWE-563] The 'Effects' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 152, 165. WebAssemblyRegStackify.cpp 165 </li><li>  V519 [CWE-563] The 'ExpectNoDerefChunk' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 4970, 4973. SemaType.cpp 4973 </li></ul><br>  <b>Fragment N28: Always true condition</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readPrefixes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct InternalInstruction* insn)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> byte = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> nextByte; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (byte == <span class="hljs-number"><span class="hljs-number">0xf3</span></span> &amp;&amp; (nextByte == <span class="hljs-number"><span class="hljs-number">0x88</span></span> || nextByte == <span class="hljs-number"><span class="hljs-number">0x89</span></span> || nextByte == <span class="hljs-number"><span class="hljs-number">0xc6</span></span> || nextByte == <span class="hljs-number"><span class="hljs-number">0xc7</span></span>)) { insn-&gt;xAcquireRelease = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextByte != <span class="hljs-number"><span class="hljs-number">0x90</span></span>) <span class="hljs-comment"><span class="hljs-comment">// PAUSE instruction support // &lt;= break; } .... }</span></span></code> </pre> <br>  PVS-Studio <a href="https://www.viva64.com/ru/w/v547/">warning</a> : <a href="https://www.viva64.com/ru/w/v547/">V547</a> [CWE-571] Expression 'nextByte! = 0x90' is always true.  X86DisassemblerDecoder.cpp 379 <br><br>  Check does not make sense.  The variable <i>nextByte is</i> always not equal to the value <i>0x90</i> , which follows from the previous check.  This is some kind of logical error. <br><br>  <b>Fragment N29 - N ...: Always true / false conditions</b> <br><br>  The analyzer generates many warnings that the entire condition ( <a href="https://www.viva64.com/ru/w/v547/">V547</a> ) or part of it ( <a href="https://www.viva64.com/ru/w/v560/">V560</a> ) is always true or false.  Often, these are not real errors, but simply inaccurate code, the result of macro deployment, and the like.  However, it makes sense to look at all these warnings, as from time to time there are true logical errors.  For example, this section of code is suspicious: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> DecodeStatus </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeGPRPairRegisterClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MCInst &amp;Inst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RegNo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *Decoder)</span></span></span><span class="hljs-function"> </span></span>{ DecodeStatus S = MCDisassembler::Success; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RegNo &gt; <span class="hljs-number"><span class="hljs-number">13</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MCDisassembler::Fail; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((RegNo &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) || RegNo == <span class="hljs-number"><span class="hljs-number">0xe</span></span>) S = MCDisassembler::SoftFail; .... }</code> </pre> <br>  PVS-Studio <a href="https://www.viva64.com/ru/w/v560/">warning</a> : <a href="https://www.viva64.com/ru/w/v560/">V560</a> [CWE-570] A part of the conditional expression is always false: RegNo == 0xe.  ARMDisassembler.cpp 939 <br><br>  The constant 0xE is a value of 14 in the decimal system.  Checking <i>RegNo == 0xe</i> does not make sense, since if <i>RegNo is&gt; 13</i> , then the function will complete its execution. <br><br>  There were many other warnings with the identifier V547 and V560, but, as in the case of <a href="https://www.viva64.com/ru/w/v595/">V595</a> , I was not interested in studying these warnings.  It was clear that I had enough material to write an article :).  Therefore, it is not known how many errors of this type can be identified in LLVM with the help of PVS-Studio. <br><br>  I will give an example why it is boring to study these triggers.  The analyzer is absolutely right when issuing a warning to the following code.  But this is not a mistake. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> UnwrappedLineParser::parseBracedList(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ContinueOnSemicolons, tok::TokenKind ClosingBraceKind) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasError = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... HasError = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ContinueOnSemicolons) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !HasError; .... }</code> </pre> <br>  PVS-Studio warning: V547 [CWE-570] Expression '! HasError' is always false.  UnwrappedLineParser.cpp 1635 <br><br>  <b>Fragment N30: ‚Äã‚ÄãSuspicious return</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isImplicitlyDef</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MachineRegisterInfo &amp;MRI, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Reg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (MachineRegisterInfo::def_instr_iterator It = MRI.def_instr_begin(Reg), E = MRI.def_instr_end(); It != E; ++It) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*It).isImplicitDef(); } .... }</code> </pre> <br>  PVS-Studio <a href="https://www.viva64.com/ru/w/v612/">warning</a> : <a href="https://www.viva64.com/ru/w/v612/">V612</a> [CWE-670] An unconditional 'return' within a loop.  R600OptimizeVectorRegisters.cpp 63 <br><br>  This is either an error or a specific technique that is intended to explain something to programmers who read the code.  Such a construction does not explain anything to me and looks very suspicious.  It‚Äôs better not to write like that :). <br><br>  Are you tired?  Then it's time to make tea or coffee. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a2/f86/58f/8a2f8658fdacb0dde918807666d1cd39.png" alt="Coffee"></div><br><br><h2>  Defects revealed by new diagnostics </h2><br>  I think 30 responses of old diagnostics are enough.  Let's now see what is interesting can be found by new diagnostics, which appeared in the analyzer after the <a href="https://www.viva64.com/ru/b/0446/">previous</a> test.  In total, 66 general-purpose diagnostics were added to the C ++ analyzer. <br><br>  <b>Fragment N31: Unreachable Code</b> <br><br><pre> <code class="cpp hljs">Error CtorDtorRunner::run() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> CtorDtorMap = ES.lookup(JITDylibSearchList({{&amp;JD, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}}), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(Names), NoDependenciesToRegister, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Error::success(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CtorDtorMap.takeError(); CtorDtorsByPriority.clear(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Error::success(); }</code> </pre> <br>  PVS-Studio <a href="https://www.viva64.com/ru/w/v779/">warning</a> : <a href="https://www.viva64.com/ru/w/v779/">V779</a> [CWE-561] Unreachable code detected.  It is possible that an error is present.  ExecutionUtils.cpp 146 <br><br>  As you can see, both branches of the <i>if statement</i> end with a call to the <i>return statement</i> .  Accordingly, the <i>CtorDtorsByPriority</i> container <i>will</i> never be <i>emptied</i> . <br><br>  <b>Fragment N32: Unreachable Code</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> LLParser::ParseSummaryEntry() { .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Lex.getKind()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lltok::kw_gv: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseGVEntry(SummaryID); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lltok::kw_module: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseModuleEntry(SummaryID); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lltok::kw_typeid: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseTypeIdEntry(SummaryID); <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; // &lt;= default: return Error(Lex.getLoc(), "unexpected summary kind"); } Lex.setIgnoreColonInIdentifiers(false); // &lt;= return false; }</span></span></code> </pre> <br>  PVS-Studio warning: V779 [CWE-561] Unreachable code detected.  It is possible that an error is present.  LLParser.cpp 835 <br><br>  An interesting situation.  Let's look at this place at the beginning: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseTypeIdEntry(SummaryID); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre> <br>  At first glance it seems that there is no error here.  It seems that the <i>break</i> statement here is superfluous, and you can simply delete it.  However, not all so simple. <br><br>  The analyzer issues a warning on the lines: <br><br><pre> <code class="cpp hljs">Lex.setIgnoreColonInIdentifiers(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  And indeed, this code is unreachable.  All cases in <i>switch</i> end with a call to the <i>return statement</i> .  And now the senseless lonely <i>break</i> does not look so harmless!  Perhaps one of the branches should end in <i>break</i> , not <i>return</i> ? <br><br>  <b>Fragment N33: Random resetting of high bits</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStubAlignment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Arch == Triple::systemz) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } Expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>&gt; RuntimeDyldImpl::emitSection(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ObjectFile &amp;Obj, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SectionRef &amp;Section, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCode) { .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> DataSize = Section.getSize(); .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (StubBufSize &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) DataSize &amp;= ~(getStubAlignment() - <span class="hljs-number"><span class="hljs-number">1</span></span>); .... }</code> </pre> <br>  PVS-Studio <a href="https://www.viva64.com/ru/w/v784/">warning</a> : <a href="https://www.viva64.com/ru/w/v784/">V784</a> The size of the bit mask is less than the size of the first operand.  This will cause the loss of higher bits.  RuntimeDyld.cpp 815 <br><br>  Notice that the <i>getStubAlignment</i> function returns <i>unsigned</i> type.  We calculate the value of the expression, if we assume that the function returns the value 8: <br><br>  ~ (getStubAlignment () - 1) <br><br>  ~ (8u-1) <br><br>  0xFFFFFFF8u <br><br>  Now notice that the <i>DataSize</i> variable is of a 64-bit unsigned type.  It turns out that when the DataSize &amp; 0xFFFFFFF8u operation is performed, all thirty two high bits will be reset.  Most likely, this is not what the programmer wanted.  I suspect that he wanted to calculate: DataSize &amp; 0xFFFFFFFFFFFFFFF8u. <br><br>  To correct the error, you should write this: <br><br><pre> <code class="cpp hljs">DataSize &amp;= ~(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>&gt;(getStubAlignment()) - <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Or so: <br><br><pre> <code class="cpp hljs">DataSize &amp;= ~(getStubAlignment() - <span class="hljs-number"><span class="hljs-number">1U</span></span>LL);</code> </pre> <br>  <b>Fragment N34: Failure of an explicit type conversion</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scaleShuffleMask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Scale, ArrayRef&lt;T&gt; Mask, SmallVectorImpl&lt;T&gt; &amp;ScaledMask)</span></span></span><span class="hljs-function"> </span></span>{ assert(<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; Scale &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Unexpected scaling factor"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NumElts = Mask.size(); ScaledMask.assign(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(NumElts * Scale), <span class="hljs-number"><span class="hljs-number">-1</span></span>); .... }</code> </pre> <br>  PVS-Studio <a href="https://www.viva64.com/ru/w/v1028/">warning</a> : <a href="https://www.viva64.com/ru/w/v1028/">V1028</a> [CWE-190] Possible overflow.  Consider casting operands for the 'NumElts * Scale' operator for the 'size_t' type, not the result.  X86ISelLowering.h 1577 <br><br>  Explicit type casting is used to prevent overflow when multiplying variables of type <i>int</i> .  However, here the explicit type conversion does not protect against overflow.  At the beginning, the variables will be multiplied, and only then the 32-bit result of the multiplication will be expanded to the <a href="https://www.viva64.com/ru/t/0044/"><i>size_t</i></a> type. <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragment N35: Unsuccessful Copy-Paste</font></font></b> <br><br><pre> <code class="cpp hljs">Instruction *InstCombiner::visitFCmpInst(FCmpInst &amp;I) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match(Op0, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op0, &amp;TLI)) { I.setOperand(<span class="hljs-number"><span class="hljs-number">0</span></span>, ConstantFP::getNullValue(Op0-&gt;getType())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;I; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match(Op1, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op1, &amp;TLI)) { I.setOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>, ConstantFP::getNullValue(Op0-&gt;getType())); <span class="hljs-comment"><span class="hljs-comment">// &lt;= return &amp;I; } .... }</span></span></code> </pre> <br> <a href="https://www.viva64.com/ru/w/v778/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V778</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [CWE-682] Two similar code fragments were found. </font><font style="vertical-align: inherit;">Perhaps this is a typo and 'Op1' variable should be used instead of 'Op0'. </font><font style="vertical-align: inherit;">InstCombineCompares.cpp 5507 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This new interesting diagnostics reveals situations when a code fragment was copied, and in it they began to change some names, but did not correct them in one place. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Please note that in the second block </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Op0 was</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> changed </font><font style="vertical-align: inherit;">to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Op1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">But in one place did not correct. </font><font style="vertical-align: inherit;">Most likely, it should have been written like this:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match(Op1, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op1, &amp;TLI)) { I.setOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>, ConstantFP::getNullValue(Op1-&gt;getType())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;I; }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragment N36: Confusion in the variables</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Status</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode; Status() : Mask(<span class="hljs-number"><span class="hljs-number">0</span></span>), Mode(<span class="hljs-number"><span class="hljs-number">0</span></span>){}; Status(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode) : Mask(Mask), Mode(Mode) { Mode &amp;= Mask; }; .... };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio </font></font><a href="https://www.viva64.com/ru/w/v1001/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">warning</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><a href="https://www.viva64.com/ru/w/v1001/"><font style="vertical-align: inherit;">V1001</font></a><font style="vertical-align: inherit;"> [CWE-563] The 'Mode' variable is assigned. </font><font style="vertical-align: inherit;">SIModeRegister.cpp 48 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is very dangerous to give the arguments of functions the same names as members of a class. </font><font style="vertical-align: inherit;">It is very easy to get confused. </font><font style="vertical-align: inherit;">Before us is just such a case. </font><font style="vertical-align: inherit;">This expression does not make sense:</font></font><br><br><pre> <code class="cpp hljs">Mode &amp;= Mask;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The function argument is changing. </font></font> And that's all.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This argument is no longer used. </font><font style="vertical-align: inherit;">Most likely, it was necessary to write this:</font></font><br><br><pre> <code class="cpp hljs">Status(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode) : Mask(Mask), Mode(Mode) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Mode &amp;= Mask; };</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragment N37: Confusion in the variables</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SectionBase</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> Size = <span class="hljs-number"><span class="hljs-number">0</span></span>; .... }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SymbolTableSection</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SectionBase { .... }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SymbolTableSection::addSymbol(Twine Name, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Bind, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Type, SectionBase *DefinedIn, <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> Value, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Visibility, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Shndx, <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> Size) { .... Sym.Value = Value; Sym.Visibility = Visibility; Sym.Size = Size; Sym.Index = Symbols.size(); Symbols.emplace_back(llvm::make_unique&lt;Symbol&gt;(Sym)); Size += <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;EntrySize; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio warning: V1001 [CWE-563] The size of the variable is assigned. </font><font style="vertical-align: inherit;">Object.cpp 424 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The situation is similar to the previous one. </font><font style="vertical-align: inherit;">It should be written:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Size += <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;EntrySize;</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragment N38-N47: We forgot to check the pointer.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Previously, we considered examples of </font></font><a href="https://www.viva64.com/ru/w/v595/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">how the V595</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diagnostics </font><a href="https://www.viva64.com/ru/w/v595/"><font style="vertical-align: inherit;">work</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Its essence is that the pointer at the beginning is dereferenced, and only then it is checked. </font><font style="vertical-align: inherit;">Young diagnostics </font></font><a href="https://www.viva64.com/ru/w/v1004/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V1004</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the opposite of its meaning, but also detects a lot of errors. </font><font style="vertical-align: inherit;">It reveals situations when the pointer was checked at the beginning and then forgot to do it. </font><font style="vertical-align: inherit;">Consider such cases found inside LLVM.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getGEPCost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Type *PointeeType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value *Ptr, ArrayRef&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value *&gt; Operands)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Ptr != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= assert(....); BaseGV = dyn_cast&lt;GlobalValue&gt;(Ptr-&gt;stripPointerCasts()); } bool HasBaseReg = (BaseGV == nullptr); auto PtrSizeBits = DL.getPointerTypeSizeInBits(Ptr-&gt;getType()); // &lt;= .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio warning: V1004 [CWE-476] The 'Ptr' pointer was used unsafely after it was verified against nullptr. </font><font style="vertical-align: inherit;">Check lines: 729, 738. TargetTransformInfoImpl.h 738 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> variable </font><font style="vertical-align: inherit;">can be equal to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nullptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as evidenced by the check:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Ptr != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> However, below this pointer is dereferenced without preliminary check: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PtrSizeBits = DL.getPointerTypeSizeInBits(Ptr-&gt;getType());</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Consider another similar case. </font></font><br><br><pre> <code class="cpp hljs">llvm::DISubprogram *CGDebugInfo::getFunctionFwdDeclOrStub(GlobalDecl GD, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Stub) { .... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> *FD = dyn_cast&lt;FunctionDecl&gt;(GD.getDecl()); SmallVector&lt;QualType, <span class="hljs-number"><span class="hljs-number">16</span></span>&gt; ArgTypes; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FD) <span class="hljs-comment"><span class="hljs-comment">// &lt;= for (const ParmVarDecl *Parm : FD-&gt;parameters()) ArgTypes.push_back(Parm-&gt;getType()); CallingConv CC = FD-&gt;getType()-&gt;castAs&lt;FunctionType&gt;()-&gt;getCallConv(); // &lt;= .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio warning: V1004 [CWE-476] The ‚ÄúFD‚Äù pointer was used unsafely after it was verified against nullptr. </font><font style="vertical-align: inherit;">Check lines: 3228, 3231. CGDebugInfo.cpp 3231 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notice the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FD</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pointer </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">I am sure that the problem is clearly visible and no special explanation is required.</font></font><br><br>  And further: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computePolynomialFromPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value &amp;Ptr, Polynomial &amp;Result, Value *&amp;BasePtr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DataLayout &amp;DL)</span></span></span><span class="hljs-function"> </span></span>{ PointerType *PtrTy = dyn_cast&lt;PointerType&gt;(Ptr.getType()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!PtrTy) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= Result = Polynomial(); BasePtr = nullptr; } unsigned PointerBits = DL.getIndexSizeInBits(PtrTy-&gt;getPointerAddressSpace()); // &lt;= .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio warning: V1004 [CWE-476] The 'PtrTy' pointer was used unsafely after it was verified against nullptr. </font><font style="vertical-align: inherit;">Check lines: 960, 965. InterleavedLoadCombinePass.cpp 965 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to protect against such errors? </font><font style="vertical-align: inherit;">Be attentive to the Code-Review and use the PVS-Studio static analyzer for regular code checking. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is no sense to cite other code fragments with errors of this type. </font><font style="vertical-align: inherit;">I leave in the article only a list of warnings:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V1004 [CWE-476] The 'Expr' pointer was used unsafely after it was verified against nullptr. </font><font style="vertical-align: inherit;">Check lines: 1049, 1078. DebugInfoMetadata.cpp 1078</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V1004 [CWE-476] The 'PI' pointer was used unsafely after it was verified against nullptr. </font><font style="vertical-align: inherit;">Check lines: 733, 753. LegacyPassManager.cpp 753</font></font></li><li> V1004 [CWE-476] The 'StatepointCall' pointer was used unsafely after it was verified against nullptr. Check lines: 4371, 4379. Verifier.cpp 4379 </li><li> V1004 [CWE-476] The 'RV' pointer was used unsafely after it was verified against nullptr. Check lines: 2263, 2268. TGParser.cpp 2268 </li><li> V1004 [CWE-476] The 'CalleeFn' pointer was used unsafely after it was verified against nullptr. Check lines: 1081, 1096. SimplifyLibCalls.cpp 1096 </li><li> V1004 [CWE-476] The 'TC' pointer was used unsafely after it was verified against nullptr. Check lines: 1819, 1824. Driver.cpp 1824 </li></ul><br> <b> N48-N60:  ,   (  )</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;IRMutator&gt; createISelMutator() { .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;IRMutationStrategy&gt;&gt; Strategies; Strategies.emplace_back( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InjectorIRStrategy(InjectorIRStrategy::getDefaultOps())); .... }</code> </pre> <br>  PVS-Studio: <a href="https://www.viva64.com/ru/w/v1023/">V1023</a> [CWE-460] A pointer without owner is added to the 'Strategies' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-isel-fuzzer.cpp 58 <br><br>        <i>std::vector&lt;std::unique_ptr&lt;X&gt;&gt;</i>    <i>xxx.push_back(new X)</i> ,       <i>X*</i>  <i>std::unique_ptr&lt;X&gt;</i> . <br><br>     <i>xxx.emplace_back(new X)</i> ,    :  <i>emplace_back</i>           . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It's not safe. </font><font style="vertical-align: inherit;">If the vector is full, the memory is allotted. </font><font style="vertical-align: inherit;">The memory reassignment operation may fail, with the result that the exception </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: bad_alloc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will be generated </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In this case, the pointer will be lost, and the created object will never be deleted. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The safe solution is to create </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unique_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which will own the pointer before the vector tries to re-allocate memory:</font></font><br><br><pre> <code class="cpp hljs">xxx.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;X&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Starting with C ++ 14, you can use 'std :: make_unique': </font></font><br><br><pre> <code class="cpp hljs">xxx.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;X&gt;())</code> </pre> <br>       LLVM.     ,      . ,     <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BF%25D1%2582%25D0%25B0%25D0%25B9%25D0%25BC"></a> ,      ,     ,      . <br><br> ,         LLVM,            PVS-Studio   . <br><br>    : <br><br><ul><li> V1023 [CWE-460] A pointer without owner is added to the 'Passes' container by the 'emplace_back' method. A memory leak will occur in case of an exception. PassManager.h 546 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'AAs' container by the 'emplace_back' method. A memory leak will occur in case of an exception. AliasAnalysis.h 324 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Entries' container by the 'emplace_back' method. A memory leak will occur in case of an exception. DWARFDebugFrame.cpp 519 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'AllEdges' container by the 'emplace_back' method. A memory leak will occur in case of an exception. CFGMST.h 268 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'VMaps' container by the 'emplace_back' method. A memory leak will occur in case of an exception. SimpleLoopUnswitch.cpp 2012 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Records' container by the 'emplace_back' method. A memory leak will occur in case of an exception. FDRLogBuilder.h 30 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'PendingSubmodules' container by the 'emplace_back' method. A memory leak will occur in case of an exception. ModuleMap.cpp 810 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Objects' container by the 'emplace_back' method. A memory leak will occur in case of an exception. DebugMap.cpp 88 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Strategies' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-isel-fuzzer.cpp 60 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 685 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 686 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 688 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 689 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 690 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 691 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 692 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 693 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 694 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Operands' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 1911 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Stash' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 2100 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Matchers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 2702 </li></ul><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In total, I wrote out 60 warnings, after which I stopped. Are there any other defects that PVS-Studio analyzer detects in LLVM? Yes there is. However, when I wrote out the code snippets for the article, it was late evening, or rather, even night, and I decided it was time to round out. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope you were interested, and you want to try the PVS-Studio analyzer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can download the analyzer and get a trial key on </font></font><a href="https://www.viva64.com/ru/pvs-studio-download/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this page</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most importantly, use static analysis regularly. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One-time checks</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> performed by us to popularize the methodology of static analysis and PVS-Studio are not a normal scenario. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Good luck in improving the quality and reliability of the code!</font></font><br><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/450002/"><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you want to share this article with an English-speaking audience, then please use the link to the translation: Andrey Karpov. </font></font><a href="https://habr.com/en/company/pvs-studio/blog/450002/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finding Bugs in LLVM 8 with PVS-Studio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/450008/">https://habr.com/ru/post/450008/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../450/index.html">Changes in the search interface Webalta</a></li>
<li><a href="../4500/index.html">Mark Kyuban about creating GooTube: this is crazy</a></li>
<li><a href="../450000/index.html">(Left to right (Through the Looking Glass)</a></li>
<li><a href="../450004/index.html">Fast C / C ++ cache, thread safety</a></li>
<li><a href="../450006/index.html">Chiller cooling data center: which coolant to choose?</a></li>
<li><a href="../450010/index.html">Photo storage, backup and cataloging</a></li>
<li><a href="../450016/index.html">Creating a system of formal verification from scratch. Part 1: symbolic virtual machine in PHP and Python</a></li>
<li><a href="../450018/index.html">Mathematical duet mapped an infinite area of ‚Äã‚Äãminimal surfaces</a></li>
<li><a href="../450020/index.html">Silicon Valley came to Kansas students. This led to protests.</a></li>
<li><a href="../450024/index.html">On open-source implementations of the GOST R 34.11-2012 hash function and their impact on the electronic signature GOST R 34.10-2012</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>