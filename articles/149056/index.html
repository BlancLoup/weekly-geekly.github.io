<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Partial application and currying in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings. 

 I don‚Äôt know how it happened, but I was playing at leisure with lambda expressions in C ++ 11 (about which, by the way, I already wrote ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Partial application and currying in C ++</h1><div class="post__text post__text-html js-mediator-article">  Greetings. <br><br>  I don‚Äôt know how it happened, but I was playing at leisure with lambda expressions in C ++ 11 (about which, by the way, I already <a href="http://habrahabr.ru/post/66021/">wrote an article</a> that gained surprisingly good popularity a couple of years ago), and under the <s>influence of narcotic</s> from Haskell language began to deal with such concepts as partial application and currying in the context of C ++.  And for a start, perhaps, it would be nice for us to decide on these terms. <br><br><a name="habracut"></a>  Actually, a partial application of a function is the ability to fix a specific value for one of the function parameters, that is, from a function from N parameters we get a function from N-1 parameters.  If we have a binary function that adds two numbers: <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; }</code> </pre> <br>  then we can fix a certain value behind one of the parameters, for example, 42. Thus, we get a new, unary function that adds the number 42 to its argument. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Strictly speaking, partial application of functions was also in the previous C ++ standard.  This role was performed by two classes <code>std::binder1st</code> and <code>std::binder2nd</code> , as well as the well-known auxiliary functions <code>std::bind1st</code> and <code>std::bind2nd</code> , which simplify the creation of objects of the above classes.  However, there is one problem: these binders do not know how to work with ordinary function pointers, because they need to know the type of parameters.  To solve this and other problems in STL, functors are commonly used.  To be honest, I would prefer to call them functional objects, since  the word "functor" since acquaintance with Haskell is associated with a completely different entity.  However, in C ++ programming circles, this term was fixed precisely for designating objects that can behave like functions;  besides, it is faster to write :) <br><br>  So how is this problem solved?  If someone does not know, I will tell in two words.  The <code>std::binder1st</code> and <code>std::binder2nd</code> , which by the way work only with binary functions, require the presence of several <code>typedef</code> in the functor you define: these are result_type, first_argument_type and second_argument_type.  In order not to have to declare these types in your functor manually each time, you can simply inherit from <code>std::binary_function&lt;T0,T1,R&gt;</code> , where T0 and T1 are the function argument types, and R is the return type, respectively. <br><br>  An example of using this whole thing is something like <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sum</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::binary_function&lt;T, T, T&gt; { <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; a, T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } }; <span class="hljs-comment"><span class="hljs-comment">//   std::for_each(intArray.begin(), intArray.end(), std::bind1st(Sum&lt;int&gt;(), 42));</span></span></code> </pre><br><br>  Those who have been familiar with STL for a long time are not afraid of such constructions (and I, unfortunately, are among them), but believe me, the jumble of all these special characters and wrappers is frightening for beginners who came to C ++ from other languages.  Readability is also better not to remember, because I saw the combination and more abruptly :) Especially since later in the Boost library a more powerful replacement appeared - Boost.Bind, which, however, differed even less (typical C ++ - way) .  By the way, it should be noted that Boost.Bind migrated to the new C ++ 11 standard to replace the old binders, which I described above a little.  However, who will use it when there is ... what?  That's right, lambda!  Well, it‚Äôs quite another thing :) Scribbling is less, readability is better (compared to binders, of course, but not with other languages;)). <br><br>  So, we have the <code>Sum</code> functor, which we defined above.  I may have forgotten to say, but in STL there is already a similar functor - std :: plus &lt;&gt;.  But we will do without him, since we wrote our own one.  In general, we have a binary functor, and we need to get a partially applied unary.  With lambdas, it might look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  for_each, begin  end // ... Sum&lt;int&gt; sum; for_each(begin(intArray)), end(intArray), [sum] (int const &amp; n) { return sum(42, n); });</span></span></code> </pre><br><br>  You may ask why we call <code>sum(42, n)</code> , when we can write <code>return 42 + n;</code> directly in the body of the lambda <code>return 42 + n;</code>  .  The remark, of course, is correct, but we are interested in precisely the partial application of the function, if you have not forgotten.  In addition, the function could be much more complicated than simply summing two numbers. <br><br>  How would we write it in Haskell?  Perhaps, something like this would turn out: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sum</span></span> ab = a + b someFunc intList = map (Œª n ‚Üí sum <span class="hljs-number"><span class="hljs-number">42</span></span> n) intList</code> </pre><br><br>  If you are not familiar with Haskell, do not despair.  This code is similar to the last C ++ example.  Now I will explain in a nutshell: in the first line we declared the function <code>sum</code> , which takes <code>a</code> and <code>b</code> , and returns their sum.  Next, we declared some function that takes a list as a parameter (probably a list of integers, judging by the name of the parameter) and does something with it.  The <code>map</code> function is an analogue of <code>std::for_each</code> , i.e.  it takes a function and calls it for each item in the list.  As a function, we pass a lambda, which calls the function <code>sum</code> , explicitly passing a fixed value as the first parameter, and the argument of the lambda naturally comes as the second parameter.  None of this really matters ... Or rather, it would not matter if the same Haskell code could not be written like this: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sum</span></span> ab = a + b someFunc intList = map (sum <span class="hljs-number"><span class="hljs-number">42</span></span>) intList</code> </pre><br><br>  As we can see, this time, instead of lambda, we used a much shorter construction, namely the call to the <i>binary</i> function <code>sum</code> with <i>one</i> parameter.  How does this work?  Yes, very simple!  :) The call <code>(sum 42)</code> will give us a new function that takes one parameter and then sums it up with the number 42. In essence, this is the same partial application - we just say to the <code>sum</code> function: ‚ÄúHere's your first parameter, remember it!  But we don‚Äôt yet know the second parameter, so you‚Äôll have to deal with it later. ‚Äù  All this works due to the fact that all functions in Haskell are curried (by the way, there was such a mathematician - Haskell Curry;)).  So it's time to figure out what it is. <br><br>  First, currying is an operation.  That is, it‚Äôs not just some kind of property or magical creature in the Haskell universe - it‚Äôs a transformation.  Secondly, this is a transformation performed on a function: it takes a function from N parameters and converts it to a similar function from a single parameter, which returns a function from N-1 parameters.  Let me explain by example.  To do this, let's return to our C ++ function <code>sum</code> , but add one more parameter to it (just in case): <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T2, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T3, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R&gt; <span class="hljs-function"><span class="hljs-function">R </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T1 a, T2 b, T3 c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b + c; }</code> </pre> <br>  Since we are only interested in the types of parameters and return values, we will write down its type as follows: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sum</span></span> :: ((<span class="hljs-type"><span class="hljs-type">T1</span></span> √ó <span class="hljs-type"><span class="hljs-type">T2</span></span> √ó <span class="hljs-type"><span class="hljs-type">T3</span></span>) ‚Üí <span class="hljs-type"><span class="hljs-type">R</span></span>)</code> </pre><br>  This record means that the function takes three arguments of types T1, T2 and T3, respectively, and returns a value of type R. Actually, after currying, by definition, we should get something like this: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sum</span></span> :: (<span class="hljs-type"><span class="hljs-type">T1</span></span> ‚Üí ((<span class="hljs-type"><span class="hljs-type">T2</span></span> √ó <span class="hljs-type"><span class="hljs-type">T3</span></span>) ‚Üí <span class="hljs-type"><span class="hljs-type">R</span></span>))</code> </pre><br>  That is, it is a function that takes one parameter of type T1, and returns another function, which in turn takes two arguments of types T2 and T3, respectively, and returns (as before) a value of type R. In essence, we ‚Äúbite off‚Äù the first parameter of the function and say, they say, "we remember him, do not worry."  And then we return a similar function that takes one less parameter.  Nothing like?  Why, based on this, partial application can be realized! <br><br>  But ... in fact, I was a little tricky.  If everything worked that way, then we would have to curry the resulting function after partially applying each successive function argument.  Judge for yourself: we have a ternary function that we curry and get a unary function.  We transfer this single parameter to this unary function and get another binary function as a result.  Now, if we want to perform a partial application for one more parameter, we will have to perform the currying again, only now for the binary function.  It makes no sense to fool yourself with this each time, so in fact, as a result of the currying, we get the following: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sum</span></span> :: (<span class="hljs-type"><span class="hljs-type">T1</span></span> ‚Üí (<span class="hljs-type"><span class="hljs-type">T2</span></span> ‚Üí (<span class="hljs-type"><span class="hljs-type">T3</span></span> ‚Üí <span class="hljs-type"><span class="hljs-type">R</span></span>)))</code> </pre><br>  In essence, this is the same thing, but instead of returning a binary function, we return it immediately as a curried one.  Thus, we obtained a chain of unary functions from the multi-input function, which, firstly, will allow us to partially apply the arguments in order, and secondly, when applying all the arguments, it will behave equivalently to the original function, that is, it will give the same result at the output . <br><br>  I hope so far everything has been more or less clear.  But, I think, many of you are already pointing a finger at the monitor with an exclamation: ‚ÄúWell, finally show the code of the bljad already!‚Äù It‚Äôs reasonable, I can‚Äôt argue.  Therefore, with the theory finished, go to practice.  The year 2012 is in the courtyard, so we will use the new C ++ 11 standard, although we will try to limit ourselves only to what Microsoft Visual Studio 2010 supports - in terms of supporting the new standard, it is probably the most lagging behind of release compilers. <br><br>  Let's start with the simple.  There is a binary function.  As a result of currying, we need to get a unary function, which returns us another unary function.  Using C ++ 11 makes it easier than a steamed turnip: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstddef&gt; #include &lt;iostream&gt; using namespace std; template &lt;typename R, typename T0, typename T1&gt; function&lt;function&lt;R(T1)&gt;(T0)&gt; curry_(function&lt;R(T0,T1)&gt; f) { return [=] (T0 const &amp; t0) -&gt; function&lt;R(T1)&gt; { return [=] (T1 const &amp; t1) { return f(t0, t1); }; }; } int sum(int a, int b) { return a + b; } int main() { auto curried_sum = curry_&lt;int,int,int&gt;(sum); cout &lt;&lt; sum(42, 10) &lt;&lt; endl; // =&gt; 52 cout &lt;&lt; curried_sum(42)(10) &lt;&lt; endl; // =&gt; 52 return EXIT_SUCCESS; }</span></span></span></span></code> </pre><br><br>  In general, there are such things: our function <code>curry_</code> depends on three template parameters (the types of the function arguments and the type of the return value).  It takes an object of type <code>std::function&lt;&gt;</code> as an argument.  If anyone does not know, this is such a universal container that can store functors, lambdas and even function pointers (Yay! No more smutter :)).  What matters to us is that it is essentially a functional object, that is, it has <code>operator()</code> overloaded.  Next, we simply return the unary lambda (essentially an anonymous functor), which returns another unary lambda.  It is practically one-to-one translation of the definition of the term <i>currying</i> from Russian to C ++. <br><br>  Now came the important point.  Anyone who has read this far should ask their inner voice which option they like more: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind1st(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)&gt;(sum), <span class="hljs-number"><span class="hljs-number">42</span></span>)(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  curry_&lt;int,int,int&gt;(sum)(42)(10);</span></span></code> </pre><br><br>  If the first, you can not continue to read, believe me.  If the second, then I have to admit to you ... I don‚Äôt really like the second one myself, although in my opinion it‚Äôs already much better than the first. <br><br>  Anyway, I am slightly annoyed by the need to explicitly specify the types of arguments and return value.  The compiler cannot automatically print all types on its own, so it has to be prompted.  In addition, if we want to overload the <code>curry_</code> function for a ternary function, we will fail because the compiler cannot distinguish between instances of <code>std::function&lt;&gt;</code> .  As I understand it, the reason for this is that the <code>std::function&lt;&gt;</code> a template constructor defined, which accepts any type, but we will not go into it now, because I‚Äôm not completely sure that I understood the problem correctly.  However, the fact remains.  And with this you need to do something. <br><br>  The question of the need to specify the types of arguments and the return value will try to solve as follows.  The <code>curry_</code> function will <code>curry_</code> left as it is, and for it we will write a template wrapper, which will take any type as a template parameter.  Next, we write something like <code>function_traits</code> (by the way, it‚Äôs strange that there‚Äôs no such thing in the standard, no?), In which we will memorize the types of arguments, etc.  The approach of writing the so-called traits classes is universally used in the STL, so why shouldn't we do that. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function_traits</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//      template &lt;typename R, typename T0, typename T1&gt; struct function_traits&lt;R(*)(T0,T1)&gt; { typedef R result_type; typedef T0 first_argument_type; typedef T1 second_argument_type; }; //   curry_ template &lt;typename Functor&gt; function&lt; function&lt; typename function_traits&lt;Functor&gt;::result_type(typename function_traits&lt;Functor&gt;::second_argument_type) &gt;(typename function_traits&lt;Functor&gt;::first_argument_type) &gt; curry(Functor f) { return curry_ &lt; typename function_traits&lt;Functor&gt;::result_type , typename function_traits&lt;Functor&gt;::first_argument_type , typename function_traits&lt;Functor&gt;::second_argument_type &gt; (f); }</span></span></code> </pre><br><br>  Well, only two dozen lines of not too readable code, and we can already write like this: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; curry(sum)(<span class="hljs-number"><span class="hljs-number">42</span></span>)(<span class="hljs-number"><span class="hljs-number">10</span></span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br><br>  In my opinion, this is a success!  :) It remains to implement <code>curry_</code> for ternary functions, and even so that we do not have to start another function name for these purposes - let everything be solved by overloading functions.  So far, the instinct tells me that this will be problematic.  Look at least at the <code>curry</code> wrapper function: it takes only one parameter (directly the function to be curried), but it should always return objects of different types depending on the arity of the function (that is, it will return a function that returns a function, or a function that returns a function, a return function, or ... mmm, perhaps enough). <br><br>  To solve this problem, you will have to slightly <s>resist with metaprogramming</s> to think and find inspiration.  So, first we need to distinguish between the unary, binary, ternary, ... n-ary functions.  I think for this you can add a static constant to <code>function_traits</code> , which will be initialized with different values ‚Äã‚Äãdepending on the specialization of the template.  Next, we will add an additional <i>dummy</i> argument to our <code>curry</code> wrapper function, which will only participate in resolving the function overload at the compilation stage. <br><br>  We get the following: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function_traits</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//      template &lt;typename R, typename T0&gt; struct function_traits&lt;R(*)(T0)&gt; { typedef R result_type; typedef T0 argument_type; static const int arity = 1; }; //      template &lt;typename R, typename T0, typename T1&gt; struct function_traits&lt;R(*)(T0,T1)&gt; { typedef R result_type; typedef T0 first_argument_type; typedef T1 second_argument_type; static const int arity = 2; }; //     template &lt;typename R, typename T0, typename T1, typename T2&gt; struct function_traits&lt;R(*)(T0,T1,T2)&gt; { typedef R result_type; typedef T0 first_argument_type; typedef T1 second_argument_type; typedef T2 third_argument_type; static const int arity = 3; }; //     template&lt;typename Functor, int NArgs&gt; struct count_args : std::enable_if&lt;function_traits&lt;Functor&gt;::arity == NArgs&gt; { static_assert(NArgs &gt;= 0, "Negative number? WTF?"); }; //  //       ,     template &lt;typename Functor&gt; Functor curry(Functor f, typename count_args&lt;Functor, 1&gt;::type * = 0) { return f; } //   template &lt;typename Functor&gt; std::function&lt; std::function&lt; typename function_traits&lt;Functor&gt;::result_type(typename function_traits&lt;Functor&gt;::second_argument_type) &gt;(typename function_traits&lt;Functor&gt;::first_argument_type) &gt; curry(Functor f, typename count_args&lt;Functor, 2&gt;::type * = 0) { return curry_ &lt; typename function_traits&lt;Functor&gt;::result_type , typename function_traits&lt;Functor&gt;::first_argument_type , typename function_traits&lt;Functor&gt;::second_argument_type &gt; (f); } //   template &lt;typename Functor&gt; std::function&lt; std::function&lt; std::function&lt; typename function_traits&lt;Functor&gt;::result_type(typename function_traits&lt;Functor&gt;::third_argument_type) &gt;(typename function_traits&lt;Functor&gt;::second_argument_type) &gt;(typename function_traits&lt;Functor&gt;::first_argument_type) &gt; curry(Functor f, typename count_args&lt;Functor, 3&gt;::type * = 0) { return curry_ &lt; typename function_traits&lt;Functor&gt;::result_type , typename function_traits&lt;Functor&gt;::first_argument_type , typename function_traits&lt;Functor&gt;::second_argument_type , typename function_traits&lt;Functor&gt;::third_argument_type &gt; (f); }</span></span></code> </pre><br><br>  In general, everything is very clear here.  We implemented function overloading by adding a second dummy parameter.  This parameter uses <code>std::enable_if</code> to ‚Äúturn off‚Äù unsuitable <code>curry</code> options during overload resolution.  We also added the implementation of currying for unary functions, which simply returns the original function.  It remains to write the implementation for the function <code>curry_</code> for ternary functions.  In the theoretical part, I mentioned that during the currying of the ternary function, the result would be a unary, which theoretically could return a function of two arguments, but in fact returns its curried version.  With this knowledge, the implementation for the three arguments is extremely simple: <br><pre> <code class="cpp hljs">&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T0, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T2&gt; function&lt;function&lt;function&lt;R(T2)&gt;(T1)&gt;(T0)&gt; curry_(function&lt;R(T0,T1,T2)&gt; f) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [=] (T0 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; t0) -&gt; function&lt;function&lt;R(T2)&gt;(T1)&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> curry_&lt;R,T1,T2&gt;([=] (T1 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; t1, T2 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; t2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(t0,t1,t2); }); }; }</code> </pre><br>  In general, I wrapped all this (except for examples of use, of course) in the <code>mega</code> namespace and added <code>function_traits</code> for functors to specializations, stuffed it into one header file and uploaded it to <a href="https://github.com/GooRoo/MegaFP">GitHub</a> .  It will be necessary to add README somehow :) Now we can write any nonsense using ternary functions.  Yes, even like this: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> d)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">ostringstream</span></span> str; str &lt;&lt; s &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">" . = "</span></span> &lt;&lt; d &lt;&lt; <span class="hljs-string"><span class="hljs-string">"$"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str.str(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; mega::curry(foo)(<span class="hljs-string"><span class="hljs-string">"-"</span></span>)(<span class="hljs-number"><span class="hljs-number">2</span></span>)(<span class="hljs-number"><span class="hljs-number">9.95</span></span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// =&gt; -: 2 . = 9.95$ return EXIT_SUCCESS; }</span></span></code> </pre><br><br>  The beauty of this approach is that new, more specific functions can be built on the fly from the ‚Äúwider‚Äù ones.  How and where exactly this can be applied, everyone decides for himself. <br><br>  Honestly, I didn‚Äôt check whether something similar had already been implemented, so I don‚Äôt exclude that I wrote another bicycle, because it was interesting to me from an academic point of view.  In addition, from the point of view of optimality, for the time being I did not go into much detail either.  I can immediately say that the C ++ compiler optimizes such things as not so good, so as a result we get a whole bundle of <code>call</code> 's with dragging different information between registers.  But for the convenience you have to pay. <br><br>  Thanks for attention. <br><br>  May the Force be with you. <br><br>  PS I have an early morning, and online, I will most likely appear closer in the evening.  So do not do much holivarte without me :) </div><p>Source: <a href="https://habr.com/ru/post/149056/">https://habr.com/ru/post/149056/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../149050/index.html">Google closes services again: Google Apps For Teams, Google Listen and Google Video For Business</a></li>
<li><a href="../149051/index.html">Zendesk - application history number 24</a></li>
<li><a href="../149052/index.html">Google‚Äôs billing system has received new features</a></li>
<li><a href="../149054/index.html">Cuts Technet Subscriptions</a></li>
<li><a href="../149055/index.html">What kind of power does a ‚Äústrong AI‚Äù need?</a></li>
<li><a href="../149057/index.html">Dark Eclipse Juno?</a></li>
<li><a href="../149059/index.html">Making Your Time Machine for Linux</a></li>
<li><a href="../149060/index.html">AngularJS - a framework for dynamic web applications from Google</a></li>
<li><a href="../149061/index.html">How to stop regularly repairing computers to neighbors and acquaintances of their friends, but do not pass for ignorance</a></li>
<li><a href="../149062/index.html">The idea of ‚Äã‚Äãorganizing a distributed network infrastructure of mixed type for the publication of electronic educational resources</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>