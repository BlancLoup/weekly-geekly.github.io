<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to CDRS, Apache Cassandra driver fully written in Rust</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="CDRS ( Apache C assandra d river written in R s ) is my own open source project that I decided to develop after I discovered that there was a shortage...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to CDRS, Apache Cassandra driver fully written in Rust</h1><div class="post__text post__text-html js-mediator-article"><p>  <a href="http://github.com/AlexPikalov/cdrs"><strong>CDRS</strong></a> ( <a href="http://cassandra.apache.org/">Apache <b>C</b> assandra</a> <b>d</b> river written in <b>R</b> <b>s</b> ) is my own open source project that I decided to develop after I discovered that there was a shortage of drivers for Cassandra in the Rust ecosystem. <a name="habracut"></a></p><br><p>  Of course, I will not say that they are not at all.  They are, but one part is the packages abandoned in their infancy Hello World, and the second part is probably the only <a href="https://crates.io/crates/cassandra">binding to the DataStax driver written in C ++</a> . </p><br><p>  As for CDRS, by means of Rust it fully implements the <a href="">specification of the 4th version of the protocol</a> . </p><br><h2 id="cargotoml">  cargo.toml </h2><br><p>  To include a driver in your project, as usual, you need the following. </p><br><p> First, add the CDRS to the <code>dependencies</code> section of your <code>cargo.toml</code> file: </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">dependencies</span></span>] cdrs = <span class="hljs-string"><span class="hljs-string">"1.0.0-beta.1"</span></span></code> </pre> <br><p>  This will allow you to use a TCP connection without encryption. </p><br><p>  If you intend to create an SSL-encrypted connection to your database, then CDRS must be enabled with the "ssl" feature: </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">dependencies</span></span>] openssl = <span class="hljs-string"><span class="hljs-string">"0.9.6"</span></span> [dependencies.cdrs] version = <span class="hljs-string"><span class="hljs-string">"1.0.0-beta.1"</span></span> features = [<span class="hljs-string"><span class="hljs-string">"ssl"</span></span>]</code> </pre> <br><p>  Second, add it to <code>lib.rs</code> </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> CDRS</code> </pre> <br><h2 id="ustanovka-soedineniya">  Connection setup </h2><br><h4 id="tcp-soedinenie">  TCP connection </h4><br><p>  To install an unencrypted connection, you will need the following modules. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> cdrs::client::CDRS; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> cdrs::authenticators::{NoneAuthenticator, PasswordAuthenticator}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> cdrs::transport::TransportPlain;</code> </pre> <br><p>  If it so happens that your cluster does not require password authorization, then the connection can be established as follows: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> authenticator = NoneAuthenticator; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> addr = <span class="hljs-string"><span class="hljs-string">"127.0.0.1:9042"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tcp_transport = TransportPlain::new(addr).unwrap(); <span class="hljs-comment"><span class="hljs-comment">// pass authenticator and transport into CDRS' constructor let client = CDRS::new(tcp_transport, authenticator); use cdrs::compression; // start session without compression let mut session = try!(client.start(compression::None));</span></span></code> </pre> <br><p>  To establish a connection that requires password authentication, instead of <code>NoneAuthenticator</code> you need to use <code>PasswordAuthenticator</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> authenticator = PasswordAuthenticator::new(<span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-string"><span class="hljs-string">"pass"</span></span>);</code> </pre> <br><h4 id="tls-soedinenie">  TLS connection </h4><br><p>  Establishing a TLS connection is very similar to the process described in the previous step, except that you need a PEM certificate to create an SSL transport. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> cdrs::client::CDRS; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> cdrs::authenticators::PasswordAuthenticator; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> cdrs::transport::TransportTls; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> openssl::ssl::{SslConnectorBuilder, SslMethod}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::path::Path;</code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> authenticator = PasswordAuthenticator::new(<span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-string"><span class="hljs-string">"pass"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> addr = <span class="hljs-string"><span class="hljs-string">"127.0.0.1:9042"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// here needs to be a path of your SSL certificate let path = Path::new("./node0.cer.pem"); let mut ssl_connector_builder = SslConnectorBuilder::new(SslMethod::tls()).unwrap(); ssl_connector_builder.builder_mut().set_ca_file(path).unwrap(); let connector = ssl_connector_builder.build(); let ssl_transport = TransportTls::new(addr, &amp;connector).unwrap(); // pass authenticator and SSL transport into CDRS' constructor let client = CDRS::new(ssl_transport, authenticator);</span></span></code> </pre> <br><h4 id="connection-pool">  Connection pool </h4><br><p>  For easier management of existing connections, CDRS contains a <code>ConnectionManager</code> , which in essence is an adapter for <a href="https://github.com/sfackler/r2d2">r2d2</a> . </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> cdrs::connection_manager::ConnectionManager; <span class="hljs-comment"><span class="hljs-comment">//... let config = r2d2::Config::builder() .pool_size(3) .build(); let transport = TransportPlain::new(ADDR).unwrap(); let authenticator = PasswordAuthenticator::new(USER, PASS); let manager = ConnectionManager::new(transport, authenticator, Compression::None); let pool = r2d2::Pool::new(config, manager).unwrap(); for _ in 0..20 { let pool = pool.clone(); thread::spawn(move || { let conn = pool.get().unwrap(); // use the connection // it will be returned to the pool when it falls out of scope. }); }</span></span></code> </pre> <br><h2 id="szhatie---lz4-i-snappy">  Compression - lz4 and snappy </h2><br><p>  To use <code>lz4</code> and <code>snappy</code> compression, it is enough to transfer the desired decoder to the session constructor: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// session without compression let mut session_res = client.start(compression::None); // session with lz4 compression let mut session_res = client.start(compression::Lz4); // session with snappy compression let mut session_res = client.start(compression::Snappy);</span></span></code> </pre> <br><p>  Further, CDRS will independently inform the cluster that it is ready to receive information in a compressed form with the selected decoder.  Further unpacking will take place automatically and does not require any further action from the developer. </p><br><h2 id="vypolnenie-zaprosov">  Query execution </h2><br><p>  Requests to Cassandra server are carried out exclusively within the existing session, after the choice of authorization methods, compression, and the type of transport. </p><br><p>  To execute a particular query, you must create <a href="https://docs.rs/cdrs/1.0.0-beta.1/cdrs/query/struct.Query.html">a</a> <code>Query</code> <a href="https://docs.rs/cdrs/1.0.0-beta.1/cdrs/query/struct.Query.html">object</a> , which at first glance may seem somewhat redundant for simple queries, since it contains many parameters that are probably not used so often. </p><br><p>  For this reason, a <code>builder</code> was created that simplifies the process of configuring a query.  For example, for simple ' <code>USE my_namespace;</code>  'simple enough </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> create_query: Query = QueryBuilder::new(<span class="hljs-string"><span class="hljs-string">"USE my_namespace;"</span></span>).finalize(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> with_tracing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> with_warnings = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> switched = session.query(create_query, with_tracing, with_warnings).is_ok();</code> </pre> <br><h4 id="sozdanie-novoy-tablicy">  Creating a new table </h4><br><p>  To create a new table in the Cassandra cluster, as before, you must first configure <code>Query</code> and then run the query: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::default::<span class="hljs-built_in"><span class="hljs-built_in">Default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> cdrs::query::{Query, QueryBuilder}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> cdrs::consistency::Consistency; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> create_query: Query = QueryBuilder::new(<span class="hljs-string"><span class="hljs-string">"CREATE TABLE keyspace.authors ( id int, name text, messages list&lt;text&gt;, PRIMARY KEY (id) );"</span></span>) .consistency(Consistency::One) .finalize(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> with_tracing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> with_warnings = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> table_created = session.query(create_query, with_tracing, with_warnings).is_ok();</code> </pre> <br><p>  As for the CQL request for creating a new table, for more complete information it is better to turn to specialized resources, for example <a href="https://docs.datastax.com/en/cql/3.1/cql/cql_reference/create_table_r.html">DataStax</a> . </p><br><h4 id="select-zapros-i-mapping-rezultatov">  SELECT query and result mapping </h4><br><p>  Suppose that in our database there is a table of authors, and each author has a list of his posts.  Let these messages be stored inside the list column.  In Rust terms, the author should have the following form: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Author</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> messages: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; }</code> </pre> <br><p>  The query itself can be executed via the <code>Session::query</code> method, as was done when creating a table.  Naturally, CQL should be in this case something like ' <code>SELECT * FROM keyspace.authors;</code>  '.  If the table contains data about some authors, we can try to display the data in the collection of Rust structures, such as ' <code>Vec&lt;Author&gt;</code> ' </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//... use cdrs::error::{Result as CResult}; let res_body = parsed.get_body(); let rows = res_body.into_rows().unwrap(); let messages: Vec&lt;Author&gt; = rows .iter() .map(|row| { let name: String = row.get_by_name("name").unwrap(); let messages: Vec&lt;String&gt; = row // unwrap Option&lt;CResult&lt;T&gt;&gt;, where T implements AsRust .get_by_name("messages").unwrap().unwrap() .as_rust().unwrap(); return Author { author: name, text: messages }; }) .collect();</span></span></code> </pre> <br><p>  While displaying the results, you should pay attention to the following traits: </p><br><ol><li><p>  <a href="https://docs.rs/cdrs/1.0.0-beta.1/cdrs/types/trait.IntoRustByName.html">IntoRustByName</a> .  In simple terms, this trait is applied to complex Cassandra types such as row (which, strictly speaking, is not a separate type defined in the specification, but in its internal structure can be considered as something close to the User Defined Type) and UDT.  Roughly speaking, <code>get_by_name</code> tries to find a "property" by its name, and if it finds it, it returns the result of converting this property to a Rust type or to CDRS types, such as <code>List</code> , 'Map', <code>UDT</code> .  These types themselves are a display of the corresponding data types defined in the specification. </p><br></li><li>  <a href="https://docs.rs/cdrs/1.0.0-beta.1/cdrs/types/trait.AsRust.html">AsRust</a> .  This trait is intended for the final mapping to the Rust types.  A complete list of implimenters can be found in the link below. </li></ol><br><h4 id="prepare--execute">  Prepare &amp; Execute </h4><br><p>  Sometimes it is convenient to first prepare a complex query once, and then execute it several times with different data at different times.  Prepare &amp; Execute is perfect for this. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// prepare just once let insert_table_cql = " insert into user_keyspace.users (user_name, password, gender, session_token, state) values (?, ?, ?, ?, ?)"; let prepared = session.prepare(insert_table_cql.to_string(), true, true) .unwrap() .get_body() .into_prepared() .unwrap(); // execute later and possible few times with different values let v: Vec&lt;Value&gt; = vec![Value::new_normal(String::from("john").into_bytes()), Value::new_normal(String::from("pwd").into_bytes()), Value::new_normal(String::from("male").into_bytes()), Value::new_normal(String::from("09000").into_bytes()), Value::new_normal(String::from("FL").into_bytes())]; let execution_params = QueryParamsBuilder::new(Consistency::One).values(v).finalize(); // without tracing and warnings let executed = session.execute(prepared.id, execution_params, false, false);</span></span></code> </pre> <br><p>  It also makes sense to combine Prepare &amp; Batch to fulfill several prepared queries at once.  The simplest example of Batch can also be found in the <a href="">examples</a> . </p><br><h2 id="cassandra-events">  Cassandra events </h2><br><p>  In addition to all the above, CDRS provides the ability to subscribe and follow the events published by the server. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> listener, stream) = session.listen_for(<span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[SimpleServerEvent::SchemaChange]).unwrap(); thread::spawn(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> || listener.start(&amp;Compression::<span class="hljs-literal"><span class="hljs-literal">None</span></span>).unwrap()); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> topology_changes = stream <span class="hljs-comment"><span class="hljs-comment">// inspects all events in a stream .inspect(|event| println!("inspect event {:?}", event)) // filter by event's type: topology changes .filter(|event| event == &amp;SimpleServerEvent::TopologyChange) // filter by event's specific information: new node was added .filter(|event| { match event { &amp;ServerEvent::TopologyChange(ref event) =&gt; { event.change_type == TopologyChangeType::NewNode }, _ =&gt; false } }); println!("Start listen for server events"); for change in topology_changes { println!("server event {:?}", change); }</span></span></code> </pre> <br><p>  To find a complete list of events, it is best to refer to the <a href="">specification</a> itself, as well as to the <a href="https://docs.rs/cdrs/1.0.0-beta.1/cdrs/frame/events/enum.ServerEvent.html">driver documentation</a> . </p><br><p>  In the future, there are plans to use events for smart load balancing. </p><br><h2 id="poleznye-ssylki">  useful links </h2><br><ul><li>  CDRS <a href="https://github.com/AlexPikalov/cdrs">repository</a> , <a href="https://github.com/AlexPikalov/cdrs/tree/master/examples">examples</a> , <a href="https://docs.rs/cdrs">documentation</a> </li><li>  <a href="">The specification of the 4th version of the protocol</a> </li><li>  DataStax <a href="https://docs.datastax.com/en/cql/3.1/cql/cql_reference/cqlReferenceTOC.html">CQL</a> , <a href="http://docs.datastax.com/en/cassandra/2.1/cassandra/configuration/configTOC.html">cluster configuration</a> . </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/321594/">https://habr.com/ru/post/321594/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321582/index.html">PVS-Studio and GitHub-community: the beginning of friendship</a></li>
<li><a href="../321584/index.html">Angular 1.x: creeping webpack, hidden grunt</a></li>
<li><a href="../321586/index.html">Artificial Intelligence Attacks You</a></li>
<li><a href="../321590/index.html">Why VIPER is a good choice for your next application.</a></li>
<li><a href="../321592/index.html">CloudFlare + nginx, or save with the help of the "coffee maker" (upd2: fast speakers dynamics!)</a></li>
<li><a href="../321596/index.html">How IT professionals work. Dmitry Tsimoshko, director of information technology at Century 21</a></li>
<li><a href="../321598/index.html">Implementation of the procedure ‚ÄúPlanning Release Release by Product‚Äù by the tools of the Atlassian family</a></li>
<li><a href="../321600/index.html">Kotlin Video Tutorial Series</a></li>
<li><a href="../321602/index.html">Procedural level generation for MERC in Unity</a></li>
<li><a href="../321604/index.html">Seminar "How much does the data center operation cost?", February 21, OST data center</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>