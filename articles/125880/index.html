<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Class fields available by name with setter and getter in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As you know, in C ++ there is no means for describing the fields of a class with controlled access, such as property in C #. On Habrahabr, the article...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Class fields available by name with setter and getter in C ++</h1><div class="post__text post__text-html js-mediator-article">  As you know, in C ++ there is no means for describing the fields of a class with controlled access, such as property in C #.  On Habrahabr, the <a href="http://habrahabr.ru/blogs/cpp/121799/">article</a> has already partially covered this topic, but I absolutely do not like the syntax.  Besides, I really wanted to be able to access the fields from the run-time by name. <br><a name="habracut"></a><br><h4>  If you want to solve a problem, try to find out the answer first. </h4><br>  Let's estimate what you need to get. <br>  For example, an int field with the name "x".  We are quite satisfied with this entry: <br><pre><code class="cpp hljs">field(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,x);</code> </pre> <br>  And further in the code we want to access this field. <br><pre> <code class="cpp hljs">foo.x = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = foo.x; foo.setField(<span class="hljs-string"><span class="hljs-string">"x"</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> p = foo.getField(<span class="hljs-string"><span class="hljs-string">"x"</span></span>);</code> </pre> <br>  Sometimes we also want to control the installation and getting the values ‚Äã‚Äãfrom this field ourselves, so we‚Äôll also have to write getters and setters. <br>  And you also need not forget about the possibility of field initialization. <br><br><h4>  Where to begin </h4><br>  What you need to know in the run-time about the fields?  At least their names and meanings.  And it would not be bad to know the type. <br><br><h5>  Type of </h5><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromNativeType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Type(<span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(T).name(), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T)); } Type(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * name, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size) : size(size), name(name) { } Type(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Type &amp; another) : size(another.size), name(another.name) { } };</code> </pre> <br>  This is far from a complete implementation of the class describing the type.  In fact, it is possible and necessary to add a lot more, but for the problem to be solved this is not the most important, and the name and size is quite enough.  Perhaps I will write a separate article on the type description. <br>  It seems more or less simple, only the static method confuses.  The fact is that the syntax does not allow instantiating the template constructor by passing template arguments in triangular brackets. <br>  Example <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val&gt; Bar() { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> var = val; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, var); } };</code> </pre> <br>  The Bar class itself is not a template, but it has a default template constructor.  So to call this constructor it must be instantiated.  This code suggests itself: <br><pre> <code class="cpp hljs">Bar bar = Bar&lt;<span class="hljs-number"><span class="hljs-number">10</span></span>&gt;();</code> </pre> <br>  But such a record means instantiating a template class, not a template constructor. <br>  Sometimes it is possible to bypass it and further I will show how. <br>  Thus Type :: fromNativeType &lt;&gt; () is, in a sense, also a constructor. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Field storage </h4><br>  Since we want to refer to the fields by their names from the run-time - we have to store them in some way.  I chose the following option: create a base class from which all the others are inherited.  This class contains a repository of field information and methods for accessing it. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Basic</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;FieldDeclaration&gt; fields; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> FieldType&gt; <span class="hljs-function"><span class="hljs-function">FieldType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; name, FieldType </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">default</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; fields.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fields[i].name.compare(name)==<span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt; Field&lt;FieldType&gt;* &gt;(fields[i].pointer)-&gt;getValue(); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> FieldType&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; name, FieldType value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; fields.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fields[i].name.compare(name)==<span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt; Field&lt;FieldType&gt;* &gt;(fields[i].pointer)-&gt;setValue(value); } } } };</code> </pre> <br>  For storage it is better to use probably std :: map, for example, std :: vector is appropriate. <br>  FieldDeclaration is simply a structure containing type information. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldDeclaration</span></span></span><span class="hljs-class"> {</span></span> FieldDeclaration(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp; name, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Type &amp; type, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * pointer = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) : name(name), type(type), pointer(pointer) { } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Type type; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * pointer; };</code> </pre> <br><br><h4>  Magic magic </h4><br>  Of course, this whole system was not written the first time, and the most basic part of it was modified many times in general, due to the fact that some of the ways to solve the problem led to a dead end. <br>  Therefore, I will insert only code snippets that come together in the big picture. <br><br><h5>  Some concepts used </h5><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __CONCAT__(a,b) a##b #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __STRINGIZE__(name) #name #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __CLASS_NAME__(name) __CONCAT__(__field_class__, name) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __GETTER_NAME__(fieldname) __CONCAT__(getterof_, fieldname) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __SETTER_NAME__(fieldname) __CONCAT__(setterof_, fieldname)</span></span></code> </pre><br><br><h5>  Pseudo-keyword </h5><br>  At the beginning of the article we agreed that we would use the syntax of the field description, which takes 2 arguments: the type and the name of the field.  In fact, I made the separation of two types of fields: <br><ul><li>  <strong>smartfield</strong> - supports getter and setter and can be obtained by name from a run-time </li><li>  <strong>field</strong> - does not use getter and setter </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> smartfield(type,name) \ type __stdcall __GETTER_NAME__(name)(); \ void __stdcall __SETTER_NAME__(name)(type value); \ __FIELD_CLASS_DECLARATION_SMART__(type,name) \ __CLASS_NAME__(name) name; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> field(type, name) \ __FIELD_CLASS_DECLARATION__(type,name) \ __CLASS_NAME__(name) name;</span></span></code> </pre><br>  The first two lines of the smartfield macro declare the getter and setter of the corresponding field directly in the class where the field will be located.  Then you must write their implementation.  They will be called getter_ &lt;field name&gt; and setter_ &lt;field name&gt;, respectively. <br>  The __stdcall call agreement modifier allows you to call a class method at a pointer, passing this explicitly as the first parameter (the __thiscall agreement according to the Microsoft specification used by default uses the ECX register to pass this). <br>  __FIELD_CLASS_DECLARATION__ and __FIELD_CLASS_DECLARATION_SMART__ are descriptions of the classes of the corresponding fields (we will return to the ‚Äúclasses of the internal kitchen‚Äù). <br>  __CLASS_NAME __ (name) name;  it is actually a copy of the "classes of domestic cuisine." <br><br><h5>  class Field </h5><br>  It should be noted that the "classes of domestic cuisine" are descendants of a more general class Field <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NO_GETTER (TGetter)0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NO_SETTER (TSetter)0 template </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename FieldType&gt; class Field { protected: typedef FieldType (*TGetter)(void *); typedef void (*TSetter)(void *, FieldType); TGetter getter; TSetter setter; void * that; public: const std::string name; const Type type; FieldType value; template&lt; typename OwnerType &gt; Field(OwnerType * _this, const char * nm) : name( nm ), type( Type::fromNativeType&lt;FieldType&gt;() ), getter(NO_GETTER), setter(NO_SETTER), that(_this) { _this-&gt;fields.push_back(FieldDeclaration(name, type, this)); } template&lt; typename OwnerType &gt; Field(OwnerType * _this, const char * nm, const FieldType &amp; initvalue) : name( nm ), type( Type::fromNativeType&lt;FieldType&gt;() ), value(initvalue), getter(NO_GETTER), setter(NO_SETTER), that(_this) { _this-&gt;fields.push_back(FieldDeclaration(name, type, this)); } FieldType getValue() { if (getter) return getter(that); else return value; } void setValue(FieldType val) { if (setter) setter(that,val); else value = val; } Field&lt;FieldType&gt; &amp; operator = (FieldType val) { setValue(val); return *this; } operator FieldType() { return getValue(); } };</span></span></span></span></code> </pre><br>  So, we have a template Field class, the template of which requires specifying the field type. <br>  Class store in itself: <br><ul><li>  Field name </li><li>  Field Type Information </li><li>  Value </li><li>  Getter </li><li>  Setter </li><li>  Pointer that equal this to the owner class </li></ul><br>  Notice that the TGetter and TSetter types are written in such a way that the functions they describe take the pointer void * as the first parameter.  This is actually a pointer to that.  This works because the getter and setter are clearly marked with the __stdcall modifier. <br><br>  Now the designers.  They are template, the template is parameterized for the owner class types OwnerType, that is, the class in which the field is declared.  The constructor itself takes the pointer this of the class OwnerType and saves it to that.  By the way, as I have already said, it is impossible to explicitly parameterize a constructor, but templates have an interesting feature: if there is an opportunity to deduce the type by which you need to parameterize a template automatically, then this is what happens.  In this case, this is the same situation.  When passing this to the constructor, the compiler itself must substitute the type OwnerType. <br>  The nm argument takes the symbolic name of the field.  It is created by the stringing operator (see above __STRINGIZE__) from higher macros. <br>  By default, we initialize the getter and setter to zero values ‚Äã‚Äãso that we know that they should not be called.  If the getter and setter are present, they will be set separately in the heir classes. <br>  The difference between the second constructor and the first one is that it accepts the default field value, since  It is quite often used. <br><br>  Next come the default getter and setter.  They check for the presence of a getter / setter set by the programmer, and if they are given, call them with an explicit transfer to that first parameter.  Otherwise, they simply return the value / assign the new. <br><br>  The assignment operator and the cast operator are needed simply for syntactically more convenient access to the field value. <br><br><h4>  Classes of domestic cuisine </h4><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __FIELD_CLASS_DECLARATION__(type, name) \ class __CLASS_NAME__(name) : public Field</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;type&gt; \ { \ public: \ __FIELD_CLASS_CONSTRUCTOR_1__(type,name) \ __FIELD_CLASS_CONSTRUCTOR_2__(type,name) \ __CLASS_NAME__(name) &amp; operator = (type val) \ { \ Field&lt;type&gt;::operator=(val); \ return *this; \ } \ }; #define __FIELD_CLASS_DECLARATION_SMART__(type, name) \ class __CLASS_NAME__(name) : public Field&lt;type&gt;\ { \ public: \ __FIELD_CLASS_CONSTRUCTOR_1_SMART__(type,name) \ __FIELD_CLASS_CONSTRUCTOR_2_SMART__(type,name) \ __CLASS_NAME__(name) &amp; operator = (type val) \ { \ Field&lt;type&gt;::operator=(val); \ return *this; \ }\ };</span></span></span></span></code> </pre><br>  These classes will be substituted directly into the owner class.  To unify the name of these classes, use the macro __CLASS_NAME__ (see above).  They are all descendants of the Field class already reviewed. <br>  A good practice is to return the reference to itself by the assignment operator, this allows you to write cascade assignments. <br>  All difference between them in designers. <br><br><h5>  About the constructors of these classes </h5><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __FIELD_CLASS_CONSTRUCTOR_1_SMART__(type,name) \ template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; class OwnerType &gt; \ __CLASS_NAME__(name)(OwnerType * _this) \ : Field&lt;type&gt;(_this, __STRINGIZE__(name)) \ { \ auto get_ptr = &amp;OwnerType::__GETTER_NAME__(name); \ auto set_ptr = &amp;OwnerType::__SETTER_NAME__(name); \ this-&gt;getter = (TGetter)(void*)*(void**)(&amp;get_ptr); \ this-&gt;setter = (TSetter)(void*)*(void**)(&amp;set_ptr); \ } #define __FIELD_CLASS_CONSTRUCTOR_2_SMART__(type,name) \ template&lt; class OwnerType &gt; \ __CLASS_NAME__(name)(OwnerType * _this, type initvalue) \ : Field&lt;type&gt;(_this, __STRINGIZE__(name), initvalue) \ { \ auto get_ptr = &amp;OwnerType::__GETTER_NAME__(name); \ auto set_ptr = &amp;OwnerType::__SETTER_NAME__(name); \ this-&gt;getter = (TGetter)(void*)*(void**)(&amp;get_ptr); \ this-&gt;setter = (TSetter)(void*)*(void**)(&amp;set_ptr); \ } #define __FIELD_CLASS_CONSTRUCTOR_1__(type,name) \ template&lt; class OwnerType &gt; \ __CLASS_NAME__(name)(OwnerType * _this) \ : Field&lt;type&gt;(_this, __STRINGIZE__(name)) \ { \ } #define __FIELD_CLASS_CONSTRUCTOR_2__(type,name) \ template&lt; class OwnerType &gt; \ __CLASS_NAME__(name)(OwnerType * _this, type initvalue) \ : Field&lt;type&gt;(_this, __STRINGIZE__(name), initvalue) \ { \ }</span></span></span></span></code> </pre><br>  Figures 1 and 2 distinguish constructors with initialization of the field value (2) and without (1).  The word SMART indicates the presence of a getter and a setter. <br>  All constructors are also template (the type must be saved and passed to the Field constructor), and they also use the automatic substitution OwnerType.  The corresponding Field constructor is called and it is passed to it except this and initialization values ‚Äã‚Äã(if any) also the field name with the string const char [], obtained by the macro __STRINGIZE__. <br>  Next in the SMART constructors is getting and saving pointers to the getter and setter.  It works very strange.  The fact is that C ++ strictly refers to casting types of pointers to class methods.  This is due to the fact that, given the possibility of inheritance and virtual methods, a pointer to a method may not always be expressed in the same way as a pointer to a function.  However, we know that the pointers to our getter and setter can be expressed, for example, by the type void *. <br>  We create temporary variables that will store pointers to methods as given by the C ++ compiler.  I wrote the type auto, in fact, it was possible to write explicitly, but it‚Äôs more convenient and thanks to C ++ 0x for that. <br>  Next we get pointers to these temporary variables.  These pointers are cast to void ** type.  Then dereference and get void *.  Well, in the end we bring it to TGetter or TSetter types and save. <br><br><h4>  Finishing touch </h4><br>  Since the field needs the this pointer for normal operation, all fields must be initialized.  Therefore, it would be nice to write small macros that allow you to do this conveniently. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> initfieldval(name, value) name(this, value) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> initfield(name) name(this)</span></span></code> </pre><br>  The first for initialization value, the second for simple initialization. <br><br>  That's all! <br><br><h4>  Using </h4><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"basic.h"</span></span></span><span class="hljs-meta"> class Foo : public Basic { public: smartfield(int, i); field(float, f); Foo(); }; Foo::Foo() : initfield(i), initfieldval(f, 3.14) { } int Foo::getterof_i() { printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Getting field i of class Foo\n"</span></span></span><span class="hljs-meta">); return i.value; } void Foo::setterof_i(int value) { printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Setting field i of class Foo\n"</span></span></span><span class="hljs-meta">); i.value = value; } int main() { Foo foo; int j = foo.i; foo.setField(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i"</span></span></span><span class="hljs-meta">, 10); int k = foo.getField(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i"</span></span></span><span class="hljs-meta">, -1); float z = foo.f; return 0; }</span></span></code> </pre><br><br><h4>  Conclusion </h4><br>  So, we got such a tool as class fields with the ability to call by name from a run-time and the ability to specify setters and getters with a fairly simple syntax.  I do not claim that this is the best solution to the task, on the contrary, I have ideas on how this could be improved. <br>  Of the minuses, I note the impossibility of creating static fields (for now) and the need to use two different words to initialize fields with and without the default value. <br><br>  <a href="">Sources</a> <br><br>  PS <br>  Everything written here was born solely for the love of C ++. <br>  Of course, I will never write something like this in my work and I do not advise others, because the code is quite difficult to read. <br><br>  PS2 <br>  I am very reluctant to miss the possibility of overloading macros in the preprocessor, even by the number of arguments, and I believe that nothing prevents this. <br>  If it were possible to overload macros by the number of arguments, the field initialization macros looked even more beautiful. </div><p>Source: <a href="https://habr.com/ru/post/125880/">https://habr.com/ru/post/125880/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../125871/index.html">Admins-per-server ratio - observations from own experience</a></li>
<li><a href="../125872/index.html">Droider Show. Issue # 3 in which the kid counted all</a></li>
<li><a href="../125876/index.html">UniFi 2.0 Hotspot for cafes and hotels. Office Wi-Fi. Overview of the new free controller</a></li>
<li><a href="../125877/index.html">Creating a simple financial model of your startup</a></li>
<li><a href="../125879/index.html">AppFabric Cache Pitfalls</a></li>
<li><a href="../125881/index.html">Instructions for beginner musicians</a></li>
<li><a href="../125882/index.html">Ten of the most sought after specializations according to Indeed.com</a></li>
<li><a href="../125883/index.html">Correct work with the database in Android</a></li>
<li><a href="../125887/index.html">Indian company released Android $ 75 solar-powered tablet</a></li>
<li><a href="../125890/index.html">Funky project management model</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>