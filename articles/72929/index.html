<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Multithreading, general data and mutexes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 When writing multi-threaded applications it is almost always necessary to work with shared data, the simultaneous change of which can l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Multithreading, general data and mutexes</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  When writing multi-threaded applications it is almost always necessary to work with shared data, the simultaneous change of which can lead to very unpleasant consequences. <br><br>  To block shared data from simultaneous access, you must use synchronization objects. <br><br>  In this topic, the method of working with mutexes is considered, which significantly reduces the number of potential errors associated with creation / deletion and capture / release. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Failure of the mutex causes a memory leak, non-capture leads to incorrect data, and non-release blocks all functions working with shared data. <br><br>  Below we consider working with mutexes in Windows and Unix, a similar idea can be used when working with other synchronization objects. <br><br>  This idea is a special case of the ‚ÄúResource Allocation - Is Initialization (RAII)‚Äù method. <br><br><a name="habracut"></a><br><br><h2>  Create, configure and delete mutex </h2><br>  First, let's declare the class CAutoMutex, which creates a mutex in the constructor and deletes it in the destroyer. <br>  Pros: <br>  - it is not necessary to produce for the whole project similar fragments initialization codes, settings and deletion of mutex <br>  - automatic removal of mutex and release of resources occupied by it <br><br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">// -,     (Windows)</font> <br> <font color="#0000ff">class</font> CAutoMutex <br> { <br> <font color="#008000">//   </font> <br> HANDLE m_h_mutex; <br> <br> <font color="#008000">//  </font> <br> CAutoMutex( <font color="#0000ff">const</font> CAutoMutex&amp;); <br> CAutoMutex&amp; <font color="#0000ff">operator</font> =( <font color="#0000ff">const</font> CAutoMutex&amp;); <br> <br> <font color="#0000ff">public</font> : <br> CAutoMutex() <br> { <br> m_h_mutex = CreateMutex(NULL, FALSE, NULL); <br> assert(m_h_mutex); <br> } <br> <br> ~CAutoMutex() { CloseHandle(m_h_mutex); } <br> <br> HANDLE <font color="#0000ff">get</font> () { <font color="#0000ff">return</font> m_h_mutex; } <br> }; <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  On Windows, mutexes are recursive by default, but not on Unix.  If the mutex is not recursive, then an attempt to capture it twice in one thread will result in deadlock. <br>  To create a recursive mutex in Unix, you need to set the appropriate flag during initialization.  The corresponding CAutoMutex class would look like this (checks for return values ‚Äã‚Äãare not shown for compactness): <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">// -,      (Unix)</font> <br> <font color="#0000ff">class</font> CAutoMutex <br> { <br> pthread_mutex_t m_mutex; <br> <br> CAutoMutex( <font color="#0000ff">const</font> CAutoMutex&amp;); <br> CAutoMutex&amp; <font color="#0000ff">operator</font> =( <font color="#0000ff">const</font> CAutoMutex&amp;); <br> <br> <font color="#0000ff">public</font> : <br> CAutoMutex() <br> { <br> pthread_mutexattr_t attr; <br> pthread_mutexattr_init(&amp;attr); <br> pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE); <br> pthread_mutex_init(&amp;m_mutex, &amp;attr); <br> pthread_mutexattr_destroy(&amp;attr); <br> } <br> ~CAutoMutex() <br> { <br> pthread_mutex_destroy(&amp;m_mutex); <br> } <br> pthread_mutex_t&amp; <font color="#0000ff">get</font> () <br> { <br> <font color="#0000ff">return</font> m_mutex; <br> } <br> };</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br><h2>  Capture and release mutex </h2><br>  By analogy with the previous class, we will declare the CMutexLock class, which occupies the mutex in the constructor and frees in the destructor.  The created object of this class will automatically capture the mutex and release it at the end of the scope, regardless of what kind of exit it was: normal exit, premature return, or throwing an exception.  The advantage is also that you can not produce similar fragments of the code for working with mutexes. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">// -,    </font> <br> <font color="#0000ff">class</font> CMutexLock <br> { <br> HANDLE m_mutex; <br> <br> <font color="#008000">//  </font> <br> CMutexLock( <font color="#0000ff">const</font> CMutexLock&amp;); <br> CMutexLock&amp; <font color="#0000ff">operator</font> =( <font color="#0000ff">const</font> CMutexLock&amp;); <br> <font color="#0000ff">public</font> : <br> <font color="#008000">//     </font> <br> CMutexLock(HANDLE mutex): m_mutex(mutex) <br> { <br> <font color="#0000ff">const</font> DWORD res = WaitForSingleObject(m_mutex, INFINITE); <br> assert(res == WAIT_OBJECT_0); <br> } <br> <font color="#008000">//     </font> <br> ~CMutexLock() <br> { <br> <font color="#0000ff">const</font> BOOL res = ReleaseMutex(m_mutex); <br> assert(res); <br> } <br> }; <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  For even more convenience, we will declare the following macro: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">// ,      </font> <br> <font color="#0000ff">#define</font> SCOPE_LOCK_MUTEX(hMutex) CMutexLock _tmp_mtx_capt(hMutex); <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  The macro allows you not to keep in mind the name of the CMutexLock class and its namespace, and also not to puzzle over the name of the object being created (for example, _tmp_mtx_capt). <br><br><h2>  Examples of using </h2><br>  Consider usage examples. <br><br>  To simplify the example, let's declare a mutex and general data in the global scope: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">//     </font> <br> <font color="#0000ff">static</font> CAutoMutex g_mutex; <br> <br> <font color="#008000">//  </font> <br> <font color="#0000ff">static</font> DWORD g_common_cnt = 0; <br> <font color="#0000ff">static</font> DWORD g_common_cnt_ex = 0; <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  An example of a simple function that uses common data and the macro SCOPE_LOCK_MUTEX: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">void</font> do_sth_1( ) <font color="#0000ff">throw</font> () <br> { <br> <font color="#008000">// ...</font> <br> <font color="#008000">//   </font> <br> <font color="#008000">// ...</font> <br> <br> { <br> <font color="#008000">//  </font> <br> SCOPE_LOCK_MUTEX(g_mutex. <font color="#0000ff">get</font> ()); <br> <br> <font color="#008000">//   </font> <br> g_common_cnt_ex = 0; <br> g_common_cnt = 0; <br> <br> <font color="#008000">//   </font> <br> } <br> <br> <font color="#008000">// ...</font> <br> <font color="#008000">//   </font> <br> <font color="#008000">// ...</font> <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  Isn't it true that the do_sth_1 () function looks more elegant than the next one?  do_sth_1_eq: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">void</font> do_sth_1_eq( ) <font color="#0000ff">throw</font> () <br> { <br> <font color="#008000">//  </font> <br> <font color="#0000ff">if</font> (WaitForSingleObject(g_mutex. <font color="#0000ff">get</font> (), INFINITE) == WAIT_OBJECT_0) <br> { <br> <font color="#008000">//   </font> <br> g_common_cnt_ex = 0; <br> g_common_cnt = 0; <br> <br> <font color="#008000">//     </font> <br> ReleaseMutex(g_mutex. <font color="#0000ff">get</font> ()); <br> } <br> <font color="#0000ff">else</font> <br> { <br> assert(0); <br> } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  In the following example, there are three exit points from the function, but there is only one mention of mutex (declaration of the mutex blocking area): <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">// - </font> <br> <font color="#0000ff">struct</font> Ex {}; <br> <br> <font color="#008000">// ,   </font> <br> <font color="#0000ff">int</font> do_sth_2( <font color="#0000ff">const</font> <font color="#0000ff">int</font> data ) <font color="#0000ff">throw</font> (Ex) <br> { <br> <font color="#008000">// ...</font> <br> <font color="#008000">//   </font> <br> <font color="#008000">// ...</font> <br> <br> <font color="#008000">//     </font> <br> SCOPE_LOCK_MUTEX(g_mutex. <font color="#0000ff">get</font> ()); <br> <br> <font color="#0000ff">int</font> rem = data % 3; <br> <br> <font color="#0000ff">if</font> (rem == 1) <br> { <br> g_common_cnt_ex++; <br> <font color="#008000">//      </font> <br> <font color="#0000ff">throw</font> Ex(); <br> } <br> <font color="#0000ff">else</font> <font color="#0000ff">if</font> (rem == 2) <br> { <br> <font color="#008000">//     </font> <br> g_common_cnt++; <br> <font color="#0000ff">return</font> 1; <br> } <br> <br> <font color="#008000">//      </font> <br> <font color="#0000ff">return</font> 0; <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  Note: I am not in favor of using multiple return s in one function, just an example of this. <br>  becomes a little more revealing. <br>  And if the function were longer and the points of exclusion would be a dozen?  Without a macro, it was necessary to put ReleaseMutex (...) in front of each of them, and you can make a mistake here very easily. <br><br><h2>  Conclusion </h2><br>  The examples of classes and macros are simple enough; they do not contain complex checks and expect the release of the mutex for infinite time.  But even this makes life easier in many cases.  And if it makes life easier, why not use it? <br><br>  UPD: The first class of CAutoMutex was not written by mistake, instead it was re-declared the second class of CMutexLock.  Fixed. <br><br>  UPD2: Removed inline words in the declaration of methods inside classes as unnecessary. <br><br>  UPD3: A variant of the CAutoMutex class with a recursive mutex for Unix has been added. <br><br>  UPD4: Moved to C ++ Blog </div><p>Source: <a href="https://habr.com/ru/post/72929/">https://habr.com/ru/post/72929/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../72920/index.html">The script to automatically build qutIM from SVN for Linux</a></li>
<li><a href="../72923/index.html">Writing a basic wave robot in python</a></li>
<li><a href="../72924/index.html">Contests non stop!</a></li>
<li><a href="../72925/index.html">Configuring mysql for ssl replications (Debian, Ubuntu)</a></li>
<li><a href="../72927/index.html">Simplicity in good web design</a></li>
<li><a href="../72930/index.html">Jeff Dean reveals Google secrets</a></li>
<li><a href="../72932/index.html">Fee for free</a></li>
<li><a href="../72933/index.html">Super fast (and neat) robots from ABB</a></li>
<li><a href="../72935/index.html">Nook - Kindle Assassin</a></li>
<li><a href="../72938/index.html">Google Tasks has grown and is now available to everyone.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>