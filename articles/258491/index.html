<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>64-bit code in 2015: what's new in diagnosing possible problems?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="64-bit errors are hard enough to detect, since they are akin to a time bomb: they can be felt far from immediately. The PVS-Studio static analyzer fac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>64-bit code in 2015: what's new in diagnosing possible problems?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/291/468/d36/291468d36a4120d606990d0fe8d22192.png" align="left"><br>  64-bit errors are hard enough to detect, since they are akin to a time bomb: they can be felt far from immediately.  The <a href="http://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> static analyzer facilitates the task of finding and correcting such errors.  However, several more steps were taken in this direction: 64-bit diagnostics were recently reviewed more closely, as a result of which their distribution by importance levels changed.  This article focuses on these changes, as well as how it affected the work with the tool and the search for errors.  Examples of 64-bit errors from real applications are attached. <br><br><h2>  What is the article about? </h2><br>  For a start, I would like to make specifics in content.  The article covers the following topics: <ol><li>  Changes in the PVS-Studio analyzer affecting the search for 64-bit errors; </li><li>  Overview of 64-bit first-level errors found by the PVS-Studio analyzer and brief comments on them; </li><li>  Comparison of efficiency in finding the most important errors by means of PVS-Studio and Microsoft Visual Studio 2013. </li></ol><br>  The first paragraph speaks for itself: it will cover the main changes in PVS-Studio regarding the analysis of 64-bit errors, as well as how they will affect the operation of the tool. <br><br>  The second main section is devoted to found 64-bit errors in real projects.  In addition to the code snippets from the projects, comments on them will also be given, so you may be able to learn something new for yourself. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The third section compares the effectiveness of finding these errors with the PVS-Studio static analyzer and the Microsoft Visual Studio 2013 environment tools. Moreover, in the case of Visual Studio, both the compiler and the static analyzer were used to search for errors. <br><br>  Do not forget that here are written only some errors.  In a real project, they will most likely be much larger and they will be more diverse.  At the end of the article, links are suggested that more fully acquaint you with the world of 64-bit errors. <br><a name="habracut"></a><br><h2>  Changes in PVS-Studio due to 64-bit errors </h2><br>  Not so long ago, we carefully looked at 64-bit diagnostics and more accurately distributed them by severity levels. <br><br>  Now the distribution of 64-bit errors looks like this: <br><br>  <b>Level 1.</b> Critical errors that cause harm in any application.  An example would be storing a pointer in a 32-bit variable of type int.  If you are developing a 64-bit application, you should definitely study and correct the first level warnings. <br><br>  <b>Level 2.</b> Errors, which usually manifest themselves only in applications that process large data arrays.  An example is the use of an 'int' variable for indexing a huge array. <br><br>  <b>Level 3.</b> Everything else.  As a rule, these warnings are not relevant.  However, for some applications, this or that diagnosis can be extremely useful. <br><br>  Thus, by setting the filtering on 64-bit first-level errors, you will receive a list of messages pointing to sections of code that are more likely to be erroneous.  Do not underestimate these warnings, since the consequences of 64-bit errors can be very different, but clearly unpleasant and often unexpected.  It is about them that will be discussed. <br><br>  I think you will understand how hard it would be to find such errors without a tool like PVS-Studio as you read the article. <br><br><h2>  Analysis of 64-bit errors </h2><br>  Care should be taken to ensure that data types are used correctly.  With this, perhaps, let's start. <br><br><pre><code class="cpp hljs">LRESULT CSaveDlg::OnGraphNotify(WPARAM wParam, LPARAM lParam) { LONG evCode, evParam1, evParam2; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (pME &amp;&amp; SUCCEEDED(pME-&gt;GetEvent(&amp;evCode, (LONG_PTR*)&amp;evParam1, (LONG_PTR*)&amp;evParam2, <span class="hljs-number"><span class="hljs-number">0</span></span>))) { .... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Analyzer Warnings: <ul><li>  <a href="http://www.viva64.com/ru/d/0050/">V114</a> Dangerous explicit type pointer conversion: (LONG_PTR *) &amp; evParam1 test.cpp 8 </li><li>  <a href="http://www.viva64.com/ru/d/0050/">V114</a> Dangerous explicit type pointer conversion: (LONG_PTR *) &amp; evParam2 test.cpp 8 </li></ul><br>  In order to understand the nature of the error, you need to look at the variable types 'evParam1', 'evParam2', as well as the declaration of the method 'GetEvent': <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> HRESULT STDMETHODCALLTYPE </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* [out] */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __RPC__out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *lEventCode, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* [out] */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __RPC__out LONG_PTR *lParam1, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* [out] */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __RPC__out LONG_PTR *lParam2, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* [in] */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msTimeout)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  As can be seen from the analyzer message, a dangerous explicit type conversion is performed.  The point is that the type 'LONG_PTR' is a ' <a href="http://www.viva64.com/ru/t/0030/">memsize-type</a> ', having a size of 32 bits per Win32 ( <a href="http://www.viva64.com/ru/t/0018/">ILP32</a> data <a href="http://www.viva64.com/ru/t/0018/">model</a> ) and 64 bits on a Win64 architecture ( <a href="http://www.viva64.com/ru/t/0026/">LLP64</a> data <a href="http://www.viva64.com/ru/t/0026/">model</a> ).  At the same time, the 'LONG' type has a size of 32 bits on both architectures.  Since the 64-bit architecture of the above types have different sizes, it is possible to work incorrectly with the objects referenced by these pointers. <br><br>  Let's continue the topic of dangerous type conversions.  Take a look at the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">BOOL WINAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackPopupMenu</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_ HMENU hMenu, _In_ UINT uFlags, _In_ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, _In_ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, _In_ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nReserved, _In_ HWND hWnd, _In_opt_ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RECT *prcRect )</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JABBER_LIST_ITEM</span></span></span><span class="hljs-class"> {</span></span> .... }; INT_PTR CJabberDlgGcJoin::DlgProc(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res = TrackPopupMenu( hMenu, TPM_RETURNCMD, rc.left, rc.bottom, <span class="hljs-number"><span class="hljs-number">0</span></span>, m_hwnd, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) { JABBER_LIST_ITEM *item = (JABBER_LIST_ITEM *)res; .... } .... }</code> </pre> <br>  Analyzer warning: <a href="http://www.viva64.com/ru/d/0156/">V204</a> Explicit conversion from 32-bit integer type to pointer type: (JABBER_LIST_ITEM *) res test.cpp 57 <br><br>  To begin with, it would be nice to take a look at the 'TrackPopupMenu' function used in this code.  It returns the ID of the user-selected menu item, or a null value in case of an error or if there was no choice.  The type 'BOOL' for these purposes is clearly chosen unsuccessfully, but what to do. <br><br>  The result of executing this function, as can be seen from the code, is entered into the variable 'res'.  In case if any element was selected by the user (res! = 0), then this variable is reduced to the type of the pointer to the structure.  An interesting approach, but since in the article we are talking about 64-bit errors, let's think about how this code will be executed on 32 and 64-bit architectures, and what could be the problem? <br><br>  The catch is that on a 32-bit architecture, such conversions are valid and feasible, since the types of 'pointer' and 'BOOL' are the same size.  But the rake will make itself felt on the 64-bit architecture.  In Win64 applications, the above types have different sizes (64 and 32 bits, respectively).  The potential error is that the high bit values ‚Äã‚Äãin the pointer may be lost. <br><br>  We continue the review.  Code snippet: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hash_void_ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ptr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hash; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; hash = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ptr) * <span class="hljs-number"><span class="hljs-number">8</span></span> / TABLE_BITS; i++) { hash ^= (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)ptr &gt;&gt; i * <span class="hljs-number"><span class="hljs-number">8</span></span>; hash += i * <span class="hljs-number"><span class="hljs-number">17</span></span>; hash &amp;= TABLE_MASK; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; }</code> </pre> <br>  Analyzer warning: <a href="http://www.viva64.com/ru/d/0157/">V205</a> Explicit conversion of pointer type to 32-bit integer type: (unsigned long) ptr test.cpp 76 <br><br>  Let us see what is the problem of casting a variable of type 'void *' to type 'unsigned long' in this function.  As already mentioned, these types have a different size in the LLP64 data model, where the type 'void *' is 64 bits, and 'unsigned long' is 32 bits.  As a result, the high-order bits contained in the 'ptr' variable will be truncated (lost).  The value of the variable 'i' increases as the iterations increase, and as a result, a bitwise shift to the right as the iterations pass will affect more and more bits.  Since the size of the 'ptr' variable was truncated, with some iteration all the bits contained in it will be filled with 0. As a result of the above, on a Win64 application the 'hash' will be incorrectly compiled.  Due to filling in 'hash' with zeros, <a href="http://www.viva64.com/go.php%3Furl%3D1607">collisions</a> can occur, that is, getting the same hashes for different input data (in this case, pointers).  As a result, this can lead to inefficient program operation.  If the conversion to 'memsize-type' were performed, truncation would not occur, and then the shift (and therefore the compilation of the hash) would be carried out correctly. <br><br>  Look at the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CValueList</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CListCtrl { .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SortItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_In_ PFNLVCOMPARE pfnCompare, _In_ DWORD_PTR dwData)</span></span></span></span>; .... }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CLastValuesView::OnListViewColumnClick(....) { .... m_wndListCtrl.SortItems(CompareItems, (DWORD)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); .... }</code> </pre> <br>  Analyzer warning: <a href="http://www.viva64.com/ru/d/0172/">V220</a> Suspicious sequence of types of castings: memsize -&gt; 32-bit integer -&gt; memsize.  The value being cast: 'this'.  test.cpp 87 <br><br>  Diagnostics V220 signals a double dangerous data conversion.  At the beginning, the variable 'memsize-type' turns into a 32-bit value, and then immediately expands back to 'memsize-type'.  In fact, this means that the values ‚Äã‚Äãof the higher bits will be ‚Äúcut off‚Äù.  It is almost always a mistake. <br><br>  Continue to reveal the topic of dangerous transformations: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> YAHOO_LOGINID </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"yahoo_id"</span></span></span><span class="hljs-meta"> DWORD_PTR __cdecl CYahooProto::GetCaps(int type, HANDLE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*hContact*/</span></span></span><span class="hljs-meta">) { int ret = 0; switch (type) { .... case PFLAG_UNIQUEIDSETTING: ret = (DWORD_PTR)YAHOO_LOGINID; break; .... } return ret; }</span></span></code> </pre> <br>  Analyzer warning: <a href="http://www.viva64.com/ru/d/0361/">V221</a> Suspicious sequence of types of castings: pointer -&gt; memsize -&gt; 32-bit integer.  The value being cast: '"yahoo_id"'.  test.cpp 99 <br><br>  Noticed the trend that with each example of transformation becomes more and more.  There are 3 of them. And 2 of them are dangerous, for the same reasons as all described above.  Since 'YAHOO_LOGINID' is a string literal, its type is 'const char *', having the same size in the 64-bit architecture as the type of 'DWORD_PTR', so the explicit conversion is correct.  But then the bad things begin.  The type 'DWORD_PTR' is implicitly converted to an integer 32-bit.  But that's not all.  Since the result returned by the function is of the type 'DWORD_PTR', another implicit conversion will be performed, this time back to the 'memsize-type'.  Obviously, in this case, the use of the returned value is at your own risk. <br><br>  I want to note that the Visual Studio 2013 compiler issued the following warning: <br><br>  warning C4244: '=': conversion from 'DWORD_PTR' to 'int', possible loss of data <br><br>  Here the actual question will be possible: why is the warning issued by Visual Studio 2013 given only in this example?  The question is fair, but have patience, this will be written below. <br><br>  In the meantime, we will continue to consider errors  Consider the following code containing a class hierarchy: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CWnd</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CCmdTarget { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WinHelp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DWORD_PTR dwData, UINT nCmd = HELP_CONTEXT)</span></span></span></span>; .... }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CFrameWnd</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CWnd { .... }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CFrameWndEx</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CFrameWnd { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WinHelp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DWORD dwData, UINT nCmd = HELP_CONTEXT)</span></span></span></span>; .... };</code> </pre> <br>  Analyzer warning: <a href="http://www.viva64.com/ru/d/0080/">V301</a> Unexpected function overloading behavior.  WinHelpA 'in derived class' CFrameWndEx' and base class' CWnd '.  test.cpp 122 <br><br>  The example is interesting because it was taken from the <a href="http://www.viva64.com/ru/b/0163/">report</a> when checking the Visual C ++ 2012 libraries. As you can see, even the Visual C ++ developers make 64-bit errors. <br><br>  Enough detail about this error is written in the <a href="http://www.viva64.com/ru/l/0012/">corresponding article</a> .  Here I wanted to explain the essence briefly.  On the 32-bit architecture, this code will be correctly processed, since the types 'DWORD' and 'DWORD_PTR' have the same size, in the heir class this function will be redefined, and the code will be executed correctly.  But the pitfall has not gone away and will let you know about yourself on the 64-bit architecture.  Since in this case the types 'DWORD' and 'DWORD_PTR' will have different sizes, polymorphism will be destroyed.  We will have on hand 2 different functions, which goes against what was meant. <br><br>  And the last example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CSymEngine::GetMemInfo(CMemInfo&amp; rMemInfo) { MEMORYSTATUS ms; GlobalMemoryStatus(&amp;ms); _ultot_s(ms.dwMemoryLoad, rMemInfo.m_szMemoryLoad, countof(rMemInfo.m_szMemoryLoad), <span class="hljs-number"><span class="hljs-number">10</span></span>); .... }</code> </pre> <br>  Analyzer Warning: <a href="http://www.viva64.com/ru/d/0082/">V303</a> The function 'GlobalMemoryStatus' is deprecated in the Win64 system.  It is a safer to use the 'GlobalMemoryStatusEx' function.  test.cpp 130 <br><br>  In principle, no special explanation is required, everything is clear from the message of the analyzer.  You must use the 'GlobalMemoryStatusEx' function, since the 'GlobalMemoryStatus' function may not work correctly on a 64-bit architecture.  More information about this is written on the MSDN portal in the <a href="http://www.viva64.com/go.php%3Furl%3D1592">description of the corresponding function</a> . <br><br>  <b>Note.</b> <br><br>  Please note that all the above errors can occur in the most ordinary application software.  In order for them to occur, the program does not necessarily have to work with large amounts of memory.  And that is why diagnostics that reveal these errors belong to the first level. <br><br><h2>  What will Visual Studio 2013 tell us? </h2><br><h3>  Compiler warnings </h3><br>  Before telling about the results of testing the static analyzer of Visual Studio 2013, I would like to dwell on the compiler warnings.  Attentive readers probably noticed that only 1 such warning was given in the text.  What is the matter, you ask?  But the fact is that there were simply no other warnings related to 64-bit errors.  And this is at the 3rd level of issuing warnings. <br><br>  But it is worth compiling this example with all included warnings (EnableAllWarnings), as we get ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/512/5f9/20f/5125f920ff574d022adb5a685afd936e.png"></div><br><br>  And, quite unexpectedly, warnings lead to header files (for example, winnt.h).  If you do not be lazy and find in this heap of warnings those that relate to the project, you can still get something interesting, for example: <br><br>  warning C4312: 'type cast': conversion from 'int' to 'JABBER_LIST_ITEM *' of greater size <br><br>  warning C4311: 'type cast': pointer truncation from 'void *' to 'unsigned long' <br><br>  warning C4311: 'type cast': pointer truncation from 'CLastValuesView * const' to 'DWORD' <br><br>  warning C4263: 'void CFrameWndEx :: WinHelpA (DWORD, UINT)': member function <br><br>  In general, the compiler issued 10 warnings in the file with these examples.  Only 3 warnings from this list clearly indicate 64-bit errors (warnings of the C4311 compiler and C4312).  Among these warnings are those that indicate a narrowing type conversion (C4244) or that the virtual function will not be redefined (C4263).  These warnings also indirectly indicate 64-bit errors. <br><br>  As a result, having eliminated one way or another repeating each other warnings, we will receive 5 warnings concerning the 64-bit errors we are considering. <br><br>  As you can see, the Visual Studio compiler could not detect all 64-bit errors.  I remind you that the PVS-Studio analyzer found 9 first-level errors in the same file. <br><br>  ‚ÄúBut what about the static analyzer built into Visual Studio 2013?‚Äù You ask.  Maybe he coped better and found more errors?  Let's get a look. <br><br><h3>  The static analyzer included in Visual Studio 2013 </h3><br>  The result of testing these examples with a static analyzer embedded in Visual Studio 2013 is 3 warnings: <ul><li>  C6255 Unprotected use of alloca <br>  _alloca indicates a stack overflow exception.  Consider using _malloca instead. <br>  64BitsErrors - test.cpp (Line 58); </li><li>  C6384 Pointer size division <br>  Dividing sizeof a pointer by another value. <br>  64BitsErrors - test.cpp (Line 72); </li><li>  C28159 Consider using another function instead <br>  Consider using 'GlobalMemoryStatusEx' instead of 'GlobalMemoryStatus'.  Reason: Deprecated.  See MSDN for details <br>  64BitsErrors - test.cpp (Line 128); </li></ul><br>  But we are looking at 64-bit errors, right?  How many errors from this list are related to 64-bit ones?  Only the latter (using a function that may return incorrect results). <br><br>  It turns out that the static analyzer Visual Studio 2013 found 1 64-bit error against 9 found by the PVS-Studio analyzer.  Impressive, isn't it?  Imagine the difference in large projects. <br><br>  And now once again I want to remind you that in terms of error detection, static code analyzers embedded in the Visual Studio 2013 and Visual Studio 2015 environments are the same (for more information, see the <a href="http://www.viva64.com/ru/b/0319/">corresponding note</a> in more detail). <br><br><h2>  What is the result? </h2><br>  The most striking is to reflect the results of the verification of code examples in the form of a table. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c5/e55/9d5/7c5e559d5214a26874074af11c2fe3bf.png"></div><br><br>  As can be seen from the table, 9 64-bit errors were detected with the help of PVS-Studio, and 6. With the common means of Microsoft Visual Studio 2013 - 6. You may say that it is not such a big difference.  I do not agree.  Let's estimate why: <ul><li>  We talked only about the most critical 64-bit errors.  Even 3 missed mistakes, this is already a lot.  And if we take the rarer errors for which the PVS-Studio analyzer generates warnings of the 2nd and 3rd levels, then it can find much more than Visual Studio.  <a href="http://www.viva64.com/ru/a/0066/">This article</a> may give some insight.  The article is a bit outdated, now the gap will be even greater. </li><li>  Calling for help a compiler with the 4th warning level turned on is not always possible.  But both at the fourth and at the third level of warnings we will receive only 2 warnings (by means of the analyzer and the compiler) related to 64-bit errors.  Not too impressive result. </li><li>  If you set the flag "/ Wall", we get a bunch of warnings that are not related to the project.  In practice, using "/ Wall" will be difficult.  You can separately include some warnings, but there will still be a lot of excess noise. </li></ul><br>  As can be seen from the above, in order to detect 64-bit errors found by means of Microsoft Visual Studio 2013, you need to do a certain amount of work.  Now imagine how much it will increase, be it a real, really big project. <br><br>  What is with PVS-Studio?  We run diagnostics, set up filtering by 64-bit errors and necessary warnings with a few mouse clicks, we get the result. <br><br><h2>  Conclusion </h2><br>  I hope that I managed to show that transferring applications to the 64-bit architecture is associated with a number of difficulties.  Errors similar to those described in this article are easy enough to make, but it is extremely difficult to find.  Add to this the fact that not all such errors are detected by Microsoft Visual Studio 2013, and to find those you need to do a certain amount of work.  At the same time, the <a href="http://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> static analyzer coped with the task, showing a decent result.  At the same time, the process of searching and filtering errors is easier and more convenient.  Agree that in really large projects without such a tool would have been difficult, so in such cases a good static analyzer is simply necessary. <br><br>  Developing a 64-bit application?  <a href="http://www.viva64.com/ru/pvs-studio-download/">Download the</a> PVS-Studio trial, check your project and see how many 64-bit messages of the first level you will have.  If a few still show up - please correct them, and make this world a little better. <br><br><h2>  Additional materials </h2><br>  As promised, I provide a list of additional materials on the topic of 64-bit errors: <ul><li>  Terminology.  <a href="http://www.viva64.com/ru/t/0002/">64-bit error</a> ; </li><li>  Andrey Karpov.  <a href="http://www.viva64.com/ru/a/0065/">A collection of examples of 64-bit errors in real programs</a> . </li><li>  Andrey Karpov.  <a href="http://www.viva64.com/ru/b/0253/">C ++ 11 and 64-bit errors</a> . </li><li>  Andrey Karpov, Evgeny Ryzhkov.  <a href="http://www.viva64.com/ru/l/">Lessons learned from developing 64-bit C / C ++ applications</a> . </li></ul><br><br><h2>  This article is in English. </h2><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Sergey Vasiliev.  <a href="http://www.viva64.com/en/b/0325/">64-Bit Code in 2015: New in the Diagnostics of Possible Issues</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/258491/">https://habr.com/ru/post/258491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../258477/index.html">Accessibility. How we make Yandex accessible to people with disabilities and why we consider it important.</a></li>
<li><a href="../258479/index.html">New features for application developers in Search Console</a></li>
<li><a href="../258483/index.html">Muller's recurrent relation: problems with rounding floating-point numbers</a></li>
<li><a href="../258485/index.html">Registration for the conference on computational linguistics "Dialogue" is open</a></li>
<li><a href="../258489/index.html">OpenEMS modeling basics</a></li>
<li><a href="../258495/index.html">About data transmission via audio jack</a></li>
<li><a href="../258499/index.html">OWASP TOP-10: A Practical View of Web Application Security</a></li>
<li><a href="../258501/index.html">Free functional test webinar from TestCafe</a></li>
<li><a href="../258503/index.html">Useful Wordpress plugins. OptionTree - site settings page</a></li>
<li><a href="../258505/index.html">Branch model and git module management for a large project</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>