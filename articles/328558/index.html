<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The best way to upload files to Ruby is with Shrine. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the first part of a series of posts about Shrine . The purpose of this series of articles is to show the advantages of Shrine over existing fi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The best way to upload files to Ruby is with Shrine. Part 1</h1><div class="post__text post__text-html js-mediator-article">  <i>This is the first part of a series of posts about <a href="https://github.com/janko-m/shrine">Shrine</a> .</i>  <i>The purpose of this series of articles is to show the advantages of Shrine over existing file loaders.</i> <br><hr><br>  More than a year has passed since I started developing Shrine.  During this time, Shrine received a lot of interesting functionality, the ecosystem has grown significantly and enough developers started using Shrine in production. <br><br>  Before delving into the explanation of the benefits, you need to take a step back and consider in detail what motivated the development of Shrine in the first place. <br><br>  In particular, I want to talk about the limitations of existing boot loaders.  I think it‚Äôs important to be aware of these limitations so that you can make the choice that best fits the <a href="https://twin.github.io/evaluating-ruby-libraries">requirements</a> . <br><a name="habracut"></a><br><h1>  Requirements </h1><br><hr><br>  The requirements were as follows: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  Files on Amazon S3 must be uploaded directly. </li><li>  File processing and deletion must be performed in the background. </li><li>  Processing can be performed during the boot process. </li><li>  <a href="https://github.com/jeremyevans/sequel">Sequel</a> Integration </li><li>  Ability to use with frameworks other than Rails </li></ol><br>  In my opinion, the first two points are very important because they allow you to achieve optimal user experience when working with forms.  But the last two points should also not be ignored: <br><br>  1. Using Amazon S3 or analogues, allows you to optimize the process of downloading files. <br>  This definitely has a number of advantages: reduced resource consumption, scaling with storage encapsulation, working with Heroku-type cloud solutions that do not provide the <a href="https://devcenter.heroku.com/articles/dynos">ability to write to the disk</a> and have a limitation on <a href="https://devcenter.heroku.com/articles/request-timeout">the query execution time</a> . <br><br>  2. Processing and deleting files in background tasks allows you to work with files <a href="https://twin.github.io/file-uploads-asynchronous-world">asynchronously</a> , regardless of whether you store files on the local file system or on external storage, such as Amazon S3, this will greatly improve the user interface.  Using background tasks is also necessary to maintain the high bandwidth of your application, because workers will not be bound to slow queries. <br><br>  3. Processing on during the download process works fine with small files, especially when several versions of files are created, for example, different sizes for images.  on the other hand, processing at boot is necessary for large files, such as video.  Therefore, we need a library that can work with any type of file. <br><br>  4. Using with ORM besides ActiveRecord is also very important.  Since more functional and productive ORMs for Ruby have already appeared. <br><br>  5. Finally, decent alternatives to Rails have appeared in the Ruby community.  Need easy integration with any web framework. <br><br>  Now we will go through the existing libraries and consider their main drawbacks with regard to the requirements. <br><br><h2>  Paperclip </h2><br><hr><br><blockquote>  Simple management of file attachments for ActiveRecord </blockquote><br>  We can say stasis - goodbye Paperclip, because there is a strong dependence on ActiveRecord.  Since this is a very common library that is used with ActiveRecord, let's still go over the other requirements. <br><br><h3>  Direct download </h3><br>  Paperclip does not have direct download capability.  It is possible to use <a href="https://github.com/aws/aws-sdk-ruby">aws-sdk</a> to generate links and parameters for direct upload to S3 and then edit the attributes of the model in the same way as when downloading a file through Paperclip. <br><br>  However, Paperclip works with only one repository.  For work, it is necessary that all downloads take place directly to the main S3 repository.  This leads to a security problem, since an attacker can download files without attaching, and as a result, many orphan files can be created.  It would be a lot easier if <a href="http://docs.aws.amazon.com/AmazonS3/latest/UG/lifecycle-configuration-bucket-no-versioning.html">S3 did it for you</a> . <br><br><h3>  Background tasks </h3><br>  For background tasks, use <a href="https://github.com/jrgifford/delayed_paperclip">delayed_papeclip</a> .  However, delayed_paperclip runs tasks only after the file has been completely downloaded.  This means that if you do not want or cannot do direct downloads to S3, your users will have to download the file twice (first to the application, then to the repository) before any background processing takes place.  And it is very slow. <br><br>  In addition, delayed_paperclip does not support deleting files in the background.  This is a big minus because you have to perform an HTTP request for each version of the file (if you have several versions of files stored on S3).  Do not expect to add this functionality, as <a href="https://github.com/thoughtbot/paperclip/issues/2281">Paperclip also checks for the existence of each version before uninstalling</a> .  Of course, you can disable file deletion, but then you have a problem with orphan files. <br><br>  Finally, <a href="https://github.com/jrgifford/delayed_paperclip/pull/178">delayed_paperclip is now tied to ActiveJob</a> , which means that now it‚Äôs not possible to directly use it with libraries for background tasks. <br><br><h3>  False triggering of mime-type spoofing attack </h3><br>  Paperclip has the functionality of detecting whether someone is trying to replace the MIME type of the file.  However, this functionality often works falsely, this leads to the fact that it is likely to cause a validation error, even if the file extension matches the file contents.  This is quite a decisive factor, because in this case, a false positive can be very annoying to users. <br><br>  Of course, you can disable this functionality, but this will make the application vulnerable to <a href="https://www.owasp.org/index.php/Unrestricted_File_Upload">attacks when downloading files</a> . <br><br><h2>  CarrierWave </h2><br><hr><br><blockquote>  Great solution for uploading files for Rails, Sinatra and other web frameworks </blockquote><br>  <a href="https://github.com/carrierwaveuploader/carrierwave">CarrierWave is the</a> answer to Paperclip who stored the configuration directly in the model, encapsulating in classes. <br><br>  CarrierWave is an <a href="https://github.com/carrierwaveuploader/carrierwave-sequel">integration with Sequel</a> . <br><br>  Unfortunately, for the <a href="">carrierwave_backgrounder</a> and <a href="">carrierwave_direct</a> extensions, the ORM CarrierWave integration is not enough.  It takes a lot of additional ActiveRecord-specific code to make it all work. <br><br><h3>  Direct download </h3><br>  As mentioned earlier, the CarrierWave ecosystem has solutions for direct download to S3 - <a href="">carrierwave_direct</a> .  This works in a way that allows you to create a direct upload form on S3, and then assign the S3 key to the uploaded file to your loader. <br><br><pre><code class="hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- Form submits to "https://my-bucket.s3-eu-west-1.amazonaws.com" --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">%=</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">direct_upload_form_for</span></span></span><span class="hljs-tag"> @</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">photo.image</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">do</span></span></span><span class="hljs-tag"> |</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">f</span></span></span><span class="hljs-tag">| %&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">%=</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">f.file_field</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">:image</span></span></span><span class="hljs-tag"> %&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">%=</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">f.submit</span></span></span><span class="hljs-tag"> %&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">%</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">end</span></span></span><span class="hljs-tag"> %&gt;</span></span></code> </pre> <br>  However, what if you need multiple downloads directly to S3?  The README notes that carrierwave_direct is intended for single downloads only.  What about the JSON API?  This is the usual form, all it does is generate URLs and parameters for uploading to S3. So why doesn't carrierwave_direct get this information in JSON format? <br><br>  But what if, instead of re-implementing all the logic for generating a request for S3 using <a href="https://github.com/fog/fog-aws">fog-aws, I</a> simply relied on <a href="https://github.com/aws/aws-sdk-ruby">aws-sdk</a> ? <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># aws-sdk bucket = s3.bucket("my-bucket") object = bucket.object(SecureRandom.hex) presign = object.presigned_post</span></span></code> </pre><br><pre> <code class="hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- HTML version --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">action</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"&lt;%= presign.url %&gt;"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">method</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"post"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">enctype</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"multipart/form-data"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"file"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"file"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">%</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">presign.fields.each</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">do</span></span></span><span class="hljs-tag"> |</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">| %&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"hidden"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"&lt;%= name %&gt;"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"&lt;%= value %&gt;"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">%</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">end</span></span></span><span class="hljs-tag"> %&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"submit"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Upload"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><pre> <code class="hljs pgsql"># <span class="hljs-type"><span class="hljs-type">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> { "url": presign.url, "fields": presign.fields }</code> </pre><br>  This method has the following advantages: It is not tied to Rails, it works with the JSON API, it supports multiple file downloads (the client can simply make a request with this data for each file), and it is more reliable (since now the parameters are generated by the officially supported gem ). <br><br><h3>  Background tasks </h3><br>  First, it is worth noting that carrierwave_direct provides instructions for setting up background processing.  However, setting up background tasks correctly <a href="https://twin.github.io/file-uploads-asynchronous-world">is quite challenging</a> , so it makes sense to rely on a library that does this for you. <br><br>  Which brings us to <a href="">carrierwave_backgrounder</a> .  This library supports the processing of background tasks, but in my experience it was unstable ( <a href="https://github.com/lardawge/carrierwave_backgrounder/pull/169">1</a> , and <a href="https://github.com/lardawge/carrierwave_backgrounder/pull/186">2</a> ).  In addition, it does not support deleting files in the background, which is a decisive factor when deleting multiple files. <br><br>  Even if we overcome all of this, it‚Äôs impossible to integrate carrierwave_backgrounder with carrierwave_direct.  As I mentioned, I want to upload files directly to S3 and process and delete them in background tasks.  But it seems that these two libraries are incompatible with each other, which means that I cannot achieve the desired performance with CarrierWave for my cases. <br><br><h3>  Closing not allowed issue on github </h3><br>  I understand that sometimes people are ungrateful to the maintainers of popular open-source libraries and it is worth being softer and respectful to each other.  <a href="https://github.com/carrierwaveuploader/carrierwave/issues/1064">However</a> , <a href="https://github.com/carrierwaveuploader/carrierwave/issues/1349">I</a> <a href="https://github.com/carrierwaveuploader/carrierwave/issues/1773">cannot</a> <a href="https://github.com/carrierwaveuploader/carrierwave/issues/1756">understand</a> <a href="https://github.com/carrierwaveuploader/carrierwave/issues/1747">why the</a> <a href="https://github.com/carrierwaveuploader/carrierwave/issues/1711">CarrierWave</a> <a href="https://github.com/carrierwaveuploader/carrierwave/issues/1680">developers</a> <a href="https://github.com/carrierwaveuploader/carrierwave/issues/1711">are</a> <a href="https://github.com/carrierwaveuploader/carrierwave/issues/1555">closing</a> <a href="https://github.com/carrierwaveuploader/carrierwave/issues/1543">unresolved</a> <a href="https://github.com/carrierwaveuploader/carrierwave/issues/1320">tasks</a> . <br><br>  <a href="https://github.com/carrierwaveuploader/carrierwave/issues/1320">One</a> such closed task is the unnecessary execution of CarrierWave processing before validation.  This is a serious security hole, since an attacker can transfer any file to an image processor, since validation of file sizes / MIME measurements will be performed only after processing.  This makes your application vulnerable to attacks like <a href="https://imagetragick.com/">ImageTragick</a> , <a href="https://www.bamsoftware.com/hacks/deflate.html">image bombs</a> or simply downloading large images. <br><br><h2>  Refile </h2><br><hr><br><blockquote>  Uploading Files to Ruby, Attempt # 3 </blockquote><br>  <a href="https://github.com/refile/refile">Refile</a> was created by Jonas Niklas, the author of CarrierWave, as the <a href="https://www.varvet.com/blog/refile-fixing-ruby-file-uploads">third attempt to improve file loading in Ruby</a> . Like Dragonfly, Refile was designed to work on the fly.  Having suffered from the complexity of CarrierWave, I found that the simple and modern design of Refile is really promising, so I began to contribute to it, and as a result I was invited to the test. <br><br><pre> <code class="ruby hljs">Refile.attachment_url(@photo, <span class="hljs-symbol"><span class="hljs-symbol">:image</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:fit</span></span>, <span class="hljs-number"><span class="hljs-number">400</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span>) <span class="hljs-comment"><span class="hljs-comment"># resize to 400x500 #=&gt; "/attachments/15058dc712/store/fit/400/500/ed3153b9cb"</span></span></code> </pre><br>  Some of the new Refile ideas include temporary and permanent storage as first-order repositories, clean abstractions for repositories, IO Abstraction, a clean internal design (no GOD objects), and direct loading out of the box.  Thanks to the clean Refile design, creating a Sequel integration was pretty simple. <br><br><h3>  Direct download </h3><br>  Refile is the first file upload library that comes with native support for direct downloads, allowing you to upload an attached file asynchronously while the user selects it.  You can upload a file via Rack or directly to S3 using Refile to generate S3 request parameters.  there is even a javascript library that does everything for you. <br><br><pre> <code class="hljs mel">&lt;%= form.attachment_field :<span class="hljs-keyword"><span class="hljs-keyword">image</span></span>, presigned: true %&gt;</code> </pre><br>  There is also a great performance boost.  When you upload a file directly to S3, you upload it to the bucket directory, which is marked ‚Äútemporary‚Äù.  Then, when validation is completed and the record is saved, the downloaded file is moved to the permanent storage.  If the temporary and permanent storage is on S3, then instead of reloading Refile, it will simply issue an S3 COPY request. <br><br>  No words, my requirements for direct downloads were met. <br><br><h3>  Background tasks </h3><br>  One of the limitations of Refile is the lack of support for background jobs.  You might think that since Refile does the processing during the boot process and has S3 COPY optimization, background tasks are not needed here. <br><br>  However, the S3 COPY request is still an HTTP request and affects the duration of the form submission.  In addition, the S3 COPY request rate depends on the file size, so the larger the file, the slower the S3 COPY request will be. <br><br>  In addition, Amazon S3 is just one of many cloud storages, you can use another service that suits your needs better, but which doesn‚Äôt have this optimization or even supports direct download. <br><br><h3>  Processing during the boot process </h3><br>  I think the processing during the upload process is great for images that are stored locally and quickly processed.  However, if you store originals on S3, then Refile will serve the initial request for the version much slower, since it must first load the original from S3.  In this case, you need to think about adding background tasks that pre-process all versions. <br><br>  If you upload larger files, such as videos, it is usually best to process them after downloading, rather than during the download process.  But Refile currently does not support this. <br><br><h2>  Dragonfly </h2><br><hr><br><blockquote>  Ruby gem for processing during the loading process - suitable for loading images into Rails, Sinatra </blockquote><br>  <a href="https://github.com/markevans/dragonfly">Dragonfly</a> is another processing solution during the download process that was on the stage for much longer than Refile, and in my opinion, has much more advanced and flexible processing options during the download process. <br><br>  Dragonfly does not work with Sequel, as one would expect, I would even be ready to write an adapter, but the <a href="">overall behavior associated with the model</a> seems to be mixed with the behavior <a href="">specific to ActiveRecord models</a> , so it is not clear how to do this. <br><br>  Also there is no support for background tasks or direct downloads.  You can do the latter manually, but this will have the same drawbacks as Paperclip. <br><br>  There is one more important note.  Receiving files through an image server (Dragonfly application for processing during the download process) is a completely separate responsibility.  I mean that you can use another file upload library that comes with everything (direct downloads, background tasks, various ORMs, etc.) to upload files to the repository and still use Dragonfly to serve these files . <br><br><pre> <code class="ruby hljs">map <span class="hljs-string"><span class="hljs-string">"/attachments"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> run Dragonfly.app <span class="hljs-comment"><span class="hljs-comment"># doesn't care how the files were uploaded end</span></span></code> </pre><br><h2>  Attache </h2><br><hr><br><blockquote>  Another approach to uploading files </blockquote><br>  <a href="https://github.com/choonkeat/attache">Attache is a</a> relatively new library that supports processing during loading.  The difference between Dragonfly and Refile is that Attache was designed to run as a separate service, so files are uploaded and distributed through the Attache server. <br><br>  Attache has ActiveRecord integration for linking uploaded files to database records and has direct download support.  But still there is not enough opportunity to create backup copies and delete files in background tasks.  In addition, Attache is not flexible enough. <br><br>  Please note, like Dragonfly, Attache does not need to be integrated with the model - you can use Shrine for this.  This year, I visited RedDotRubyConf in Singapore, where I met the author Attache, and after a very interesting discussion about the problems with file uploads, we came to the decision that it would be useful to use Shrine for file attachment logic, and simply connect Attache to as backend. <br><br>  Thus, Attache can still do what it does best - distribute files, but delegate work with attachments to Shrine. <br><br><h3>  Finally </h3><br>  Support for direct downloads, managing files in the background, processing at boot, and the ability to use with other ORMs is what I really expect from the library.  However, none of the existing libraries supported all of these requirements. <br><br>  Therefore, I decided to create a new <a href="https://github.com/janko-m/shrine">Shrine</a> library based on knowledge from existing libraries. <br><br>  The purpose of Shrine is not to be clumsy, to provide functionality and flexibility that will optimize various tasks when working with files. <br><br>  This is an ambitious goal, but after a year of active development and research, I feel that I have achieved this.  At the very least, there are more features than any other Ruby library.  In the rest of this article series, I will introduce you to all the cool features you can use with Shrine, so stay tuned! <br><hr><br>  <i>Original: <a href="https://twin.github.io/better-file-uploads-with-shrine-motivation">Better File Uploads with Shrine: Motivation</a></i> <i><br></i>  <i>The rest of the articles from the series in the author's blog:</i> <i><br><br></i> <ul><li>  <i><a href="https://twin.github.io/better-file-uploads-with-shrine-uploader/">Better File Uploads with Shrine: Uploader</a></i> </li><li>  <i><a href="https://twin.github.io/better-file-uploads-with-shrine-attachment">Better File Uploads with Shrine: Attachment</a></i> </li><li>  <i><a href="https://twin.github.io/better-file-uploads-with-shrine-processing">Better File Uploads with Shrine: Processing</a></i> </li><li>  <i><a href="https://twin.github.io/better-file-uploads-with-shrine-metadata">Better File Uploads with Shrine: Metadata</a></i> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/328558/">https://habr.com/ru/post/328558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328548/index.html">Get to know WannaCry</a></li>
<li><a href="../328550/index.html">Organizing a large project on the Zend Framework 2/3</a></li>
<li><a href="../328552/index.html">Dirty game tricks</a></li>
<li><a href="../328554/index.html">Dark LinkedIn Patterns or Why You are Spammed by Friends, Encouraging You to Join LinkedIn</a></li>
<li><a href="../328556/index.html">Problems of Modern Data Science</a></li>
<li><a href="../328560/index.html">Corporate telephone directory with a map</a></li>
<li><a href="../328562/index.html">How to design programs (HtDP)</a></li>
<li><a href="../328564/index.html">Unity3d We play with the mesh. Part 2 - Deformation of the mesh with a height map</a></li>
<li><a href="../328566/index.html">MIPS SIMD technology and Baikal-T1 processor</a></li>
<li><a href="../328568/index.html">The evolution of fractal monsters</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>