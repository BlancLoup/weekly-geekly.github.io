<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cones stuffed with 15 years of using actors in C ++. Part I</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is the first part of the text version of the report of the same name from the February C ++ CoreHard Winter 2017 conference. It so happen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cones stuffed with 15 years of using actors in C ++. Part I</h1><div class="post__text post__text-html js-mediator-article"><p>  This article is the first part of the text version of <a href="https://corehard.by/2017/02/16/15-years-of-practical-actors-usage-in-c-underwater-rocks/">the report of the same name</a> from the February <a href="https://corehard.by/category/corehard-conf-winter-2017/">C ++ CoreHard Winter 2017</a> conference.  It so happened that for 15 years now I have been responsible for developing the <a href="https://habrahabr.ru/post/304386/">SObjectizer</a> framework.  This is one of the few still alive and still developing OpenSource frameworks for C ++ that allow the use of the Actor Model.  Accordingly, during this time, it has repeatedly been tried to try the Model Actors in the case, as a result of which some experience has been accumulated.  Basically it was a positive experience, but there are some unobvious points about which it would be good to know in advance.  About what rake it was possible to step on, what cones were stuffed, how to simplify your life and how it affected the development of SObjectizer, and will be discussed further. </p><br><p>  I suspect that much of what I‚Äôm going to talk about is well known in the Erlang community.  But the Erlang community weakly intersects with the C ++ community.  In addition, there is a difference between what is available to the Erlang developer and what is available to the C ++ developer.  Therefore, I hope that this article will be interesting and useful for C ++ nicknames. </p><a name="habracut"></a><br><p>  SObjectizer itself appeared in the spring of 2002 in the company Intervale.  SObjectizer was created exclusively as a working tool.  Therefore, he immediately went "to the business" and was used inside several products both within the company and abroad: </p><br><ul><li>  electronic and mobile commerce; </li><li>  mobile banking; </li><li>  SMS / USSD traffic aggregation; </li><li>  simulation modeling; </li><li>  test benches for checking software of railway transport automated control systems; </li><li>  prototyping of a distributed system for collecting measurement information. </li></ul><br><p>  Some of these products are still in operation. </p><br><h1>  A few words about the relevance of the Model Actors </h1><br><p>  We briefly refresh the main points of the Actors Model: </p><br><ul><li>  an actor is an entity with behavior; </li><li>  actors respond to incoming messages; </li><li>  having received the message, the actor can: <br><ul><li>  send some (finite) number of messages to other actors; </li><li>  create a certain (finite) number of new actors; </li><li>  define for yourself a new behavior for processing subsequent messages. </li></ul></li></ul><br><p>  The Model of Actors implies that applied work in an application is performed by separate entities, actors who interact with each other only by means of asynchronous messages. </p><br><p>  The actor sleeps waiting for an incoming message, then when an incoming message appears, it wakes up and processes the message, then falls asleep again until it receives the next message. </p><br><p>  For historical reasons, we use the term <i>agent</i> in the SObjectizer, not the <i>actor</i> , so later in the text both terms will be used, they will be the same. </p><br><h2>  And a couple of words about the applicability of the Model Actors in C ++ </h2><br><p>  In my personal opinion, using the Actor Model in C ++ gives us a number of bonuses: </p><br><ul><li>  Each actor has its own state, which is accessible only to him.  This greatly simplifies life in multi-threaded programming; </li><li>  transferring information through asynchronous messages is a convenient and natural way to solve some types of tasks.  And the Model of Actors in such tasks reduces the semantic gap between the subject area and the implementation; </li><li>  when using the Actor Model, the connectivity of the components is very weak, which simplifies their composition and testing; </li><li>  interaction mechanism based on asynchronous messages is very good with timers.  Using timers as deferred or periodic messages in the Actor Model is a pleasure; </li><li>  C ++ nicknames are new to multithreaded programming based on the Model Actors surprisingly fast.  Yesterday's students in a short time begin to write reliable multi-threaded code. </li></ul><br><h1>  Rake and stuffed cones </h1><br><p>  We receive the bonuses described above only if the task falls well on the Actor Model.  A good bed is not always.  So you need to be careful: if we take up the Actor Model, for example, in heavy computational problems, we can get more pain than pleasure. </p><br><p>  If the Model of Actors is well suited for some subject area, then by using the right tools, you can greatly simplify your life. </p><br><p>  But in this case, it is highly desirable to have an idea about some things that can be classified as ‚Äúrake‚Äù or ‚Äúpitfalls‚Äù.  Next, I will talk about some of the rakes, which had a chance to trample personally.  I hope this will help someone to fill fewer cones than I could. </p><br><h2>  Agent overload </h2><br><p>  One of the worst pitfalls is the problem of overloading actors. </p><br><p>  Overload occurs when the agent does not have time to process their messages. <br>  For example, someone loads the agent at a rate of 3 messages per second, and the agent can process only 2 messages per second.  It turns out that in the agent's queue on each clock cycle there is another unprocessed message. </p><br><img src="https://habrastorage.org/files/842/edf/4ac/842edf4acd064ef781ffae549e2d5306.png"><br><p>  If the agent is not protected from overloads in any way, the consequences will be sad: the queue of incoming messages will swell, the memory will open, the memory consumption will slow down the speed of work, which will lead to more rapid growth of queues, etc.  As a result, the application degrades to a complete loss of performance. </p><br><h3>  Why is overloading so terrible in Model Actors? </h3><br><p>  With asynchronous interaction based on sending messages, there is no simple way to implement feedback (it is also back pressure).  Those.  the sending agent simply does not know how full the receiving agent's queue is and cannot just pause until the receiving agent clears its turn.  In particular, both the sending agent and the receiving agent can work on the same working thread, therefore if the sending agent ‚Äúfalls asleep‚Äù, it will block the common working thread together with the receiving agent. </p><br><p>  The difficulty in dealing with congestion is that a good overload protection mechanism must be tailored to a specific task.  Somewhere in the event of an overload, you can throw out the most recent messages.  Somewhere you need to throw away the oldest.  Somewhere for old messages you need to choose another processing strategy. </p><br><h3>  Where is the exit? </h3><br><p>  We learned from our experience that the campaign on the basis of two agents, the collector and performer, each of which works on different working threads, proved itself quite well.  Agent-collector collects messages and provides overload protection.  The perfomer agent periodically requests another batch of messages from the collector agent.  When the next portion is processed, the agent-performer again requests the next portion, etc. </p><br><p>  But the bad thing here is that all this needs to be done by the application programmer.  It would be better to have a set of ready-made tools for this purpose.  Therefore, we have built in SObjectizer a special mechanism called " <a href="https://www.slideshare.net/YauheniAkhotnikau/dive-into-sobjectizer-55-seventh-part-message-limits">message limits</a> " that allows the programmer to use several ready-made simple policies to protect their agents from overload. </p><br><p>  It may look like this in the code like this: </p><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">collector</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : collector(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> quick_n_dirty) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>(ctx <span class="hljs-comment"><span class="hljs-comment">//  get_status   . + limit_then_drop&lt;get_status&gt;(1) //      , //    ,  . + limit_then_redirect&lt;request&gt;(50, [quick_n_dirty]{ return quick_n_dirty; } ) //      ,   //    . + limit_then_abort&lt;get_messages&gt;(1)) ... };</span></span></code> </pre> <br><h4>  Small explanation </h4><br><p>  By means of "limits for messages", you can specify, for example, that it is enough to have only one get_status message in the agent's message queue, and other messages of this type can be easily and painlessly thrown out: </p><br><pre> <code class="cpp hljs">limit_then_drop&lt;get_status&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  You can specify that the queue should have no more than 50 messages of the type request, and the remaining messages of this type should be sent to another agent who will perform processing in some other way (for example, if this is a request for resizing a picture, then you can do a resize more roughly but much faster): </p><br><pre> <code class="cpp hljs">limit_then_redirect&lt;request&gt;(<span class="hljs-number"><span class="hljs-number">50</span></span>, [quick_n_dirty]{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> quick_n_dirty; } )</code> </pre> <br><p>  In some cases, exceeding the allowable number of messages in the queue is an indication that everything is very bad and it is better to interrupt the entire application.  For example, if a second message like get_messages appears in the queue, the first one has not yet been processed, <br>  then obviously something goes completely wrong, so you need to call std :: abort, restart and start all over again: </p><br><pre> <code class="cpp hljs">limit_then_abort&lt;get_messages&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  The message limits added to SObjectizer are not a complete overload protection mechanism (since such mechanisms should be sharpened for a specific task), but in simple cases and with rapid prototyping, message limits were quite successful. </p><br><h2>  Message Delivery Unreliable </h2><br><p>  For some, this may be a surprise, but the delivery of the sent message to the recipient is not guaranteed.  Those.  the message may just be lost somewhere along the way.  There are several main reasons why a sent message may not reach the receiving agent: </p><br><ul><li>  the recipient is simply not there.  Those.  it existed at the time of dispatch, but then managed to disappear; </li><li>  the recipient is, the message reached him, but the recipient simply ignored the message in its current state; </li><li>  the message does not reach the recipient, for example, due to the mechanism of "limits for messages". </li></ul><br><p>  In other words, when you asynchronously send a message to someone, you have no confidence that the message will reach the recipient. </p><br><p>  Let's imagine that agent A sends a message <b><i>x</i></b> to agent B and expects to receive a message <b><i>y</i></b> in response.  When message <b><i>y</i></b> reaches Agent A, Agent A is happy and continues his work. </p><br><p>  However, if the message <b><i>x</i></b> to Agent B did not reach, but was lost somewhere along the road, then Agent A will wait in vain for a response message <b><i>y</i></b> . </p><br><img src="https://habrastorage.org/files/e19/24a/3c2/e1924a3c27754a52b8b12c8300f3b4f1.png"><br><p>  If you forget about the unreliability of messages, you can easily find yourself in a situation where the application simply stopped working after losing several messages.  As in this example: Agent A cannot continue to work until it receives message y. </p><br><p>  Accordingly, the question arises: "If the messages are unreliable, then how to live with it?" </p><br><h3>  What to do? </h3><br><p>  You need to design the work of agents so that the loss of messages does not affect the performance.  There are two easy ways to do this: </p><br><ol><li>  Resending message after timeout.  So, if Agent A did not receive message <b><i>y</i></b> from Agent B within 10 seconds, then Agent A can re-send message <b><i>x</i></b> .  But!  Here you need to understand that message forwarding is a direct way to agent overloading.  Therefore, Agent B must be protected from overload by <b><i>x</i></b> . </li><li>  Roll back the operation if its result was not received within a reasonable time.  So, if Agent A does not receive a message from Agent B within 10 seconds, Agent A can cancel previously performed actions on his side.  Well, or set the status ‚Äúresult unknown‚Äù for your current operation and proceed to processing the next operation. </li></ol><br><p>  At first glance, it may seem that if the interaction through asynchronous messages is unreliable, then the application itself, which is developed on the basis of the Actors Model, will also be unreliable.  In practice, it turns out to be more interesting: the reliability of the application just increases (in my opinion, at least).  This is explained by the fact that the developer is immediately forced to put in his agents some mechanisms for overcoming abnormal situations.  And these mechanisms work when abnormal situations do occur. </p><br><h2>  Error codes vs Exceptions </h2><br><p>  We attacked this rake exactly as the developers of SObjectizer.  Although the consequences affect the users.  The fact is that when we made the first version of SObjectizer in 2002, we did not use exceptions to report errors.  Return codes were used instead. </p><br><p>  Over time, it turned out that error codes are not reliable.  Here the rule worked: if something can be forgotten, it will be forgotten.  It is enough to skip error handling somewhere or reduce error handling only to its logging, then this will eventually come out sideways.  For example, the application will stop processing any user requests.  Traces of the problem can then be found somewhere in the log.  But this is post factum, when the problem has already appeared on users. </p><br><p>  Therefore, when in 2010 we started making a new version of SObjectizer, breaking compatibility with the previous one, we switched to using exceptions to report bugs. </p><br><p>  In my opinion, this has a positive effect on the reliability and quality of applications.  Problems are no longer ‚Äúswallowed‚Äù and any deviation from the norm immediately becomes noticeable. </p><br><h3>  Question almost a million </h3><br><p>  Let's imagine a situation where agent B processes a message from agent A. And during the processing of this message, an error occurs, agent B throws an exception from its handler.  What to do with it? </p><br><p>  This problem has two components: </p><br><ol><li>  Agent B runs on a context that is owned by SObjectizer.  And SObjectizer has no idea what to do with the exception that flew out of agent B. Maybe this exception means that everything is completely bad and there is no point in continuing to work further.  Or maybe it's some kind of nonsense that you can ignore. </li><li>  Even if you catch the exception that flew out from Agent B, and try to deliver it to Agent A, you may find that: <br><ul><li>  Agent A is simply not there, he has already ceased to exist. </li><li>  Even if Agent A is, he may simply not be interested in receiving information about the problems of Agent B. </li><li>  Even if agent A is and even if he is interested in receiving information about problems of agent B, then we may simply not deliver this information to agent A for some reason (for example, because of the protection of agent A against overloads). </li></ul></li></ol><br><h3>  What to do with it? </h3><br><p>  In SObjectizer, we made a special flag that determines what to do if an exception is thrown from the agent.  For example, kill the entire application at once, deregister the problem agent, or ignore the exception. </p><br><p>  The fact that the agent is deregistered when an exception is issued outside allows the supervisor mechanisms to be organized, as in Erlang.  That is, if some agent ‚Äúfalls‚Äù due to an exception, then the agent-supervisor will be able to react and restart the ‚Äúfallen‚Äù agent to such a fall. </p><br><h3>  Here you are not Erlang, here the climate is different </h3><br><p>  Only here, our practice shows that in the case of C ++, this is not all that rosy, as in Erlang or some other safe language.  In Erlang, the principle of let it crash is elevated to absolute.  Roughly speaking, it is not customary to pay attention even to division by zero.  Well, try to divide the Erlang process by zero, well, it will fall, the Erlang virtual machine will clear the garbage, the supervisor will create the crashed process again and that's it.  But in C ++, the attempt to divide by zero is likely to kill the entire application, and not just the agent in which the error occurred. </p><br><p>  Another important point: the agent is a C ++ object.  If we decide to withdraw it from the application, we still need to carefully remove it, like any other object, whose lifetime has expired.  Those.  a destructor will be called for the agent object, and this destructor should work fine. </p><br><p>  This means that the agent object must provide at least a basic guarantee of the security of exceptions.  That is, if the agent object has issued an exception, no resource leaks or damage to anything in the program should arise. </p><br><p>  Which automatically leads to the fact that in C ++ the principle of ‚Äúlet it crash‚Äù looks much different than in Erlang.  And if we are already starting to take care that the agent provides any imputed guarantees with respect to the exceptions, then it quickly turns out that we have no reason to shift our concerns about overcoming the consequences of errors on the framework.  This can be done by the agent himself. </p><br><p>  What leads to the fact that agents naturally begin to support nothrow warranty.  Those.  Do not let out any exceptions at all.  Roughly speaking, message handlers in agents, in which something serious is done, contain try-catch blocks inside.  And if, at the same time, an exception from the agent flies out (which means something unexpected in the catch block), then something is wrong with the whole application.  And in this case, you need to kill not one problem agent, but the entire application.  Since we can not guarantee its further correct operation. </p><br><p>  Hence the moral: C ++ is not Erlang and it is not worthwhile in C ++ to migrate error handling approaches suitable for Erlang or some other programming language. </p><br><hr><br><p>  On this for the first part of all, continued <a href="https://habrahabr.ru/post/324978/">here</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/324420/">https://habr.com/ru/post/324420/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324410/index.html">Smarting Cities</a></li>
<li><a href="../324412/index.html">How to choose the best server solution and not make a mistake</a></li>
<li><a href="../324414/index.html">Scapegoat or MVC in iOS</a></li>
<li><a href="../324416/index.html">Targeted attacks on Polish banks: technical analysis</a></li>
<li><a href="../324418/index.html">Code Generation, Selenoid, HtmlElements in the auto-tester</a></li>
<li><a href="../324422/index.html">APS technology: cloud standard</a></li>
<li><a href="../324424/index.html">‚ÄúComplicated architecture is very simple to do‚Äù - an interview with Oleg Anastasiev from Odnoklassniki</a></li>
<li><a href="../324426/index.html">Where do programmers go after 40</a></li>
<li><a href="../324428/index.html">We share information about the work of your site. Service Overview HostTracker Part 5</a></li>
<li><a href="../324430/index.html">How I did a tester optimizer for finding profitable strategies on the Exchange - 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>