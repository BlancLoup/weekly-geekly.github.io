<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Network hard drive using SSHFS and Raspberry Pi</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 

 I want to share with you my experience of creating a network hard drive on the Raspberry Pi. My article is perfect for those who use Linux a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Network hard drive using SSHFS and Raspberry Pi</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/06d/5b9/05d/06d5b905d6884e1c81db67511637c4cf.jpg"><br><br>  Hello! <br><br>  I want to share with you my experience of creating a network hard drive on the Raspberry Pi.  My article is perfect for those who use Linux as the main OS, because  here I am actively using SSHFS. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      All interested in asking under the cat. <br><a name="habracut"></a><br><h3>  Step 0. Preparation </h3><br>  We need: <br><ul><li>  Raspberry Pi any model + SD memory card up to 32 GB; </li><li>  HDD; </li><li>  If the hard drive is without external power, then most likely you will need a hub with the ability to connect external power; </li><li>  The main computer running Linux (in the article I use Linux Mint 17); </li><li>  The Internet; </li><li>  Straight arms. </li></ul><br><br><h3>  Step 1. Installation </h3><br>  First you need to install on Raspberry Pi Raspbian or Arch Linux ARM. <br>  In the article, I will use Raspbian. <br><ol><li>  Go to the Raspberry Pi website in the <a href="http://www.raspberrypi.org/downloads/">download</a> section and download the Raspbian image </li><li>  Unpack the archive </li><li>  Open the terminal and go to the folder with the image </li><li>  We insert the memory card into the computer </li><li>  Enter df -h in the terminal and look at the output.  The output should contain / dev / mmcblk0p1 or / dev / sdd1.  In my case, this is / dev / mmcblk0p1.  p1 (or 1, if your card is displayed as / dev / sdd1) is the partition number, if there are several sections on the card, the output will still be / dev / mmcblk0p2 or / dev / sdd2.  The number of entries in the output depends on how many sections you have. </li><li>  So, having learned how your card is displayed in the system, we proceed to the image recording. <br><ol><li>  In the terminal, run umount / dev / mmcblk0p1 (or umount / dev / sdd1).  If you have multiple partitions, you need to unmount everything. </li><li>  We will record the image on the card using the dcfldd program.  The dcfldd program works in the same way as dd, but periodically reports how much has already been recorded.  Enter the following command in the terminal: <br><br><pre><code class="bash hljs">$ sudo dcfldd bs=4M <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=___.img of=___</code> </pre> <br>  In my case, the command looks like this: <br><br><pre> <code class="bash hljs">$ sudo dcfldd bs=4M <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=2014-12-24-wheezy-raspbian.img of=/dev/mmcblk0</code> </pre><br>  Please note that on the way to your map it is not necessary to specify the section number (even if it is one).  The image is recorded on the entire card. <br>  bs - block size - the size of one block that is written to the card.  If the recording does not work with 4M installed, then 1M must be supplied, but this will increase the recording time. </li><li>  After the image is written, run the command: <br><br><pre> <code class="bash hljs">$ sync</code> </pre> <br>  This will ensure that all data has been written to the card and clear the buffer. </li></ol></li><li>  Everything.  The card can be removed and inserted into the Raspberry Pi. </li></ol><br><br><h3>  Step 2. First start </h3><br><ol><li>  Insert the card into the Raspberry Pi; </li><li>  We connect to the Raspberry Pi internet, monitor and keyboard; </li><li>  Turn on the Raspberry Pi; </li><li>  After the system has booted, you should see the Raspberry Pi Software Configuration Tool window. <br><ol><li>  Select the item Expand Filesystem and press Enter.  This will make sure that the entire volume of the card is available OS </li><li>  Next, go to step 2 - Change User Password and enter a new password; </li><li>  Go to step 3 - Enable Boot to ... and select the Console Text console; </li><li>  Go to step 4 - Internationalization Options and then go to the item Change Locale and look in the list en_RU.UTF-8 UTF-8, mark with a space and press Enter.  Then the system will ask which locale to use by default.  Select Russian and press Enter; </li><li>  Go back to the Internationalization Options and then go to the item Change Timezone.  Choose Europe and look for your city in the list.  Then press Enter; </li><li>  Go to step 7 - Overclock (we will accelerate our baby a little) and select the Medium level; </li><li>  Go to step 8 - Advanced Options and go to step A2 - Hostname.  Enter the name under which we want to see our baby in the local network and press Enter; </li><li>  Go back to Advanced Options and go to A4 - SSH and turn on SSH; </li><li>  That's where our adventures in the Raspberry Pi Software Configuration Tool are over.  Click the right arrow and Finish. </li></ol></li><li>  If you need to get into this program again, you need to enter: <br><br><pre> <code class="bash hljs">$ sudo raspi-config</code> </pre></li><li>  Now you need to restart the system.  In the console, enter the command: <br><br><pre> <code class="bash hljs">$ sudo reboot</code> </pre></li><li>  After the system reboots go to the account.  The username is the password that you entered earlier; </li><li>  Now you need to upgrade your OS.  To do this, enter: <br><pre> <code class="bash hljs">$ sudo rpi-update</code> </pre>  and after that <br><pre> <code class="bash hljs">$ sudo apt-get update</code> </pre>  and <br><pre> <code class="bash hljs">$ sudo apt-get upgrade</code> </pre><br></li></ol><br><br><h3>  Step 3. Configure SSH </h3><br><ol><li>  First of all, it is necessary to generate keys (if they are not yet generated).  To do this on the main OS, run: <br><br><pre> <code class="bash hljs">$ ssh-keygen -t rsa -C <span class="hljs-string"><span class="hljs-string">"your_email@example.com"</span></span></code> </pre></li><li>  Then the keys must be copied to your Raspberry Pi. <br><ol><li>  For this you need to know under what ip your baby is online.  This can be found by going to the router, for example, or using the command: <br><pre> <code class="bash hljs">$ ifconfig</code> </pre><br>  I have an ip 192.168.0.102. </li><li>  Now we execute the command on the main OS: <br><br><pre> <code class="bash hljs">$ ssh-copy-id pi@192.168.0.102</code> </pre><br>  You will be asked to enter consent to continue the connection.  You must enter yes.  Then you will be asked to enter the password from the account on the Raspberry Pi.  We enter and it. </li></ol></li><li>  Now you can try to connect to your Raspberry Pi via ssh.  To do this, on the main machine, type: <br><br><pre> <code class="bash hljs">$ ssh pi@192.168.0.102</code> </pre></li><li>  If you see a greeting message, then, hooray, you are logged in. </li><li>  Now you can disable the monitor and keyboard from the Raspberry Pi.  All further actions we will be through SSH </li></ol><br><br><h3>  Step 4. Brushing Raspberry Pi </h3><br><ol><li>  Firstly, you need to set a password for root.  by default it is absent.  To do this, run: <br><pre> <code class="bash hljs">$ sudo passwd root</code> </pre>  And enter the new password for root </li><li>  Install the vim editor: <br><pre> <code class="bash hljs">$ sudo apt-get install vim</code> </pre>  You can also use the nano editor, which is already installed.  But I prefer vim. </li><li>  Now I want to change my username.  To do this, exit using the exit command.  Login again via ssh, but under the root. <br><pre> <code class="bash hljs">$ ssh root@192.168.0.102</code> </pre>  and execute the command: <br><pre> <code class="bash hljs">$ usermod -l _ -d /home/_ -m pi</code> </pre>  I use inn0kenty as a new name, i.e.  in my case, the command looks like this: <br><pre> <code class="bash hljs">$ usermod -l inn0kenty -d /home/inn0kenty -m pi</code> </pre><br></li></ol><br><br><h3>  Step 5. Static ip </h3><br>  DHCP works for me, so every time the Raspberry Pi connects to the home network, it will receive a new ip address, which of course does not suit me.  In order to make ip static you need to run: <br><ol><li>  Enter in the terminal <br><pre> <code class="bash hljs">$ sudo vim /etc/network/interfaces</code> </pre>  .  In the opened file we change <br><pre> <code class="bash hljs">iface eth0 inet dhcp</code> </pre>  on <br><pre> <code class="bash hljs">iface eth0 inet static address 192.168.0.98 netmask 255.255.255.0 network 192.168.0.0 broadcast 192.168.0.255 gateway 192.168.0.1</code> </pre>  Indicating the parameters of your network.  Netmask and broadcast can be found with the command <br><pre> <code class="bash hljs">$ sudo ifconfig</code> </pre><br>  and gateway using <br><pre> <code class="bash hljs">$ sudo route -nee</code> </pre></li><li>  Then reboot the Raspberry Pi with the sudo reboot command </li><li>  Now in order to connect to the Raspberry Pi by shh you must enter <br><pre> <code class="bash hljs">$ ssh inn0kenty@192.168.0.98</code> </pre><br></li></ol><br><h3>  Step 6. We brush SSH </h3><br>  In this step, I will show how to simplify ssh connection and make it more secure. <br><ol><li>  First of all, open the ssh configuration file with the command: <br><pre> <code class="bash hljs">$ sudo vim /etc/ssh/sshd_config</code> </pre>  And set it to prohibit ssh login as root and disable password authentication: <br><pre> <code class="bash hljs">PasswordAuthentication no PermitRootLogin no</code> </pre>  And also change the port <br><pre> <code class="bash hljs">Port 22226 ()</code> </pre></li><li>  Then restart the Raspberry Pi <br><pre> <code class="bash hljs">$ sudo reboot</code> </pre></li><li>  Now you need to specify port 22226 to connect to the Raspberry Pi <br><pre> <code class="bash hljs">$ ssh -p 22226 inn0kenty@192.168.0.98</code> </pre>  But such a long team can be simplified and minimized.  To do this, on your primary OS, edit the config file.  In your home directory, run: <br><pre> <code class="bash hljs">$ vim .ssh/config</code> </pre>  and paste the following lines there: <br><pre> <code class="bash hljs">Host 192.168.0.98 Hostname 192.168.0.98 User inn0kenty Port 22226</code> </pre><br>  After that, to connect to your Raspberry Pi you only need to dial <br><pre> <code class="bash hljs">$ ssh 192.168.0.98</code> </pre><br></li></ol><br><br><h3>  Step 7. Connect to the Raspberry Pi from the outside. </h3><br>  In this section, I want to tell how to connect via ssh to the Raspberry Pi, not only from the local network, but also from the outside. <br>  If you have an external ip static, then, cheers, you can not particularly bathe.  It is enough to make redirection from external ip to internal. <br>  But if you, like me, have an external ip dynamic, then dynamic dns comes to the rescue. <br>  Personally, I use noip.com.  it is free, although it requires periodically to go to the site and confirm that you still use the address they gave you. <br>  So, register there and go to Add a Host. <br><ol><li>  In the hostname, enter the address you want to use to connect from the outside and click on the Add Host button without changing anything else </li><li>  Now it is necessary that noip know when your ip changes.  There are two ways.  First, if your router supports the Dynamic Domain Name System (DDNS) function, it is enough to enter account data and domain name in the router settings.  After that, the router will inform noip about changing the ip address.  Second, you need to put the program on your main computer.  In noip, this is the Dynamic DNS Update Client.  You can take it <a href="https://www.noip.com/download%3Fpage%3Dlinux">from here.</a> </li><li>  Next step: it is necessary to redirect from the external ip to your local one. <br>  To do this, in my router, you need to go to Redirect -&gt; Virtual Servers and add the following entry there: <br>  Service port: 22226 <br>  Inner port: 22226 <br>  IP Address: 192.168.0.98 <br>  Protocol: all <br></li><li>  Now you need to add data from the outside to the ssh configuration file on your main OS. <br>  Open the config file <br><pre> <code class="bash hljs">$ vim .ssh/config</code> </pre>  And add there <br><pre> <code class="bash hljs">Host _ Hostname _ User inn0kenty Port 22226</code> </pre>  We save. <br></li><li>  Everything.  Now you can connect to the Raspberry Pi not only from home </li></ol><br><br><h3>  Step 8. Connecting HDD </h3><br><ol><li>  First you need to create a folder on your Raspberry Pi where your HDD will be mounted <br><pre> <code class="bash hljs">$ mkdir hdd</code> </pre></li><li>  Now connect the hard drive to the Raspberry Pi and enter the command <br><pre> <code class="bash hljs">$ sudo blkid</code> </pre>  The output should be something like this: <br><pre> <code class="bash hljs">/dev/mmcblk0p1: SEC_TYPE=<span class="hljs-string"><span class="hljs-string">"msdos"</span></span> LABEL=<span class="hljs-string"><span class="hljs-string">"boot"</span></span> UUID=<span class="hljs-string"><span class="hljs-string">"936C-7154"</span></span> TYPE=<span class="hljs-string"><span class="hljs-string">"vfat"</span></span> /dev/mmcblk0p2: UUID=<span class="hljs-string"><span class="hljs-string">"c1398422-7a7c-4863-8a8f-45a1db26b4f2"</span></span> TYPE=<span class="hljs-string"><span class="hljs-string">"ext4"</span></span> /dev/sda1: LABEL=<span class="hljs-string"><span class="hljs-string">"Seagate Expansion Drive"</span></span> UUID=<span class="hljs-string"><span class="hljs-string">"7CD8E7DCD8E792A6"</span></span> TYPE=<span class="hljs-string"><span class="hljs-string">"ntfs"</span></span></code> </pre>  The last line is just what we need.  Remember UUID. </li><li>  Now you need to install file system support <br><pre> <code class="bash hljs">$ sudo apt-get install ntfs-3g</code> </pre></li><li>  Open the fstab file <br><pre> <code class="bash hljs">$ sudo vim /etc/fstab</code> </pre></li><li>  Add this line there: <br><pre> <code class="bash hljs">UUID=<span class="hljs-string"><span class="hljs-string">"*"</span></span> ** ntfs-3g rw,force,<span class="hljs-built_in"><span class="hljs-built_in">exec</span></span>,users 0 0  * -   UUID (  7CD8E7DCD8E792A6)  ** -       (  /home/inn0kenty/hdd)</code> </pre></li><li>  Save and reboot the Raspberry Pi </li><li>  After rebooting, all files and folders from the hard disk should appear in the hdd folder. </li></ol><br><br><h3>  Step 9. SSHFS </h3><br><ol><li>  Install sshfs on your main OS <br><pre> <code class="bash hljs">$ sudo apt-get install sshfs</code> </pre></li><li>  Create a folder in your home directory where Raspberry Pi will be mounted. <br><pre> <code class="bash hljs">$ mkdir pi</code> </pre></li><li>  Mount the Raspberry Pi in this folder: <br><pre> <code class="bash hljs">$ sshfs 192.168.0.98:/home/inn0kenty/hdd pi</code> </pre>  Everything.  All our files from the hard disk were in the pi folder on your main machine. </li><li>  In order to unmount the Raspberry Pi, enter the command <br><pre> <code class="bash hljs">$ sudo umount pi</code> </pre>  or <br><pre> <code class="bash hljs">$ fusermount -u pi</code> </pre></li><li>  In order to do the same from the outside it is enough to change the command a little. <br><pre> <code class="bash hljs">$ sshfs _:/home/inn0kenty/hdd pi</code> </pre></li><li>  These commands can be written in fstab on your main machine, so that the mount is performed every time you turn on the computer, but for me this is not a suitable option.  The main computer I have is a laptop and the Internet when turned on is not always there.  Therefore, I suggest using a small script that will easily mount your Raspberry Pi with one short command. <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash ABSOLUTE_FILENAME=`readlink -e "$0"` #  #      DIRECTORY=`dirname "$ABSOLUTE_FILENAME"` if [ "x$1" = "x-nh" ] || [ "x$1" = "x-nothome" ] ; then sshfs -o nonempty _:/home/inn0kenty/hdd $DIRECTORY # -o nonempty  sshfs       #    else sshfs -o nonempty 192.168.0.98:/home/inn0kenty/hdd $DIRECTORY fi</span></span></code> </pre><ol><li>  Save this script in the file mount.sh and make it executable <br><pre> <code class="bash hljs">$ chmod +x mount.sh</code> </pre></li><li>  And put it in the pi folder <br><pre> <code class="bash hljs">$ mv mount.sh pi/</code> </pre></li><li>  Then add an alias to run the script with one command.  Open bashrc (if not, create one). <br><pre> <code class="bash hljs">$ vim .bashrc</code> </pre>  And add the line there <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> pimount=<span class="hljs-string"><span class="hljs-string">'/home/inn0kenty/pi/mount.sh'</span></span></code> </pre>  Of course substituting your data. <br>  Save and restart bash. <br>  Now you can mount your Raspberry Pi with one command <br><pre> <code class="bash hljs">$ pimount</code> </pre>  And if you specify the -nh or -nothome key, then your Raspberry Pi will be mounted via the domain name i.e.  You can use your Raspberry Pi to the full even without being in the same local network with it. <br><pre> <code class="bash hljs">$ pimount -nh</code> </pre>  or <br><pre> <code class="bash hljs">$ pimount -nothome</code> </pre></li></ol></li></ol><br><br><h3>  Step 10. Deluge </h3><br>  The last step - installing torrent rocking.  I prefer the deluge. <br><ol><li>  Enter in turn the commands: <br><pre> <code class="bash hljs">$ sudo apt-get install deluged deluge-webui</code> </pre></li><li>  Then we perform <br><pre> <code class="bash hljs">$ sudo vim /etc/default/deluge-daemon</code> </pre>  and enter there the following: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Configuration for /etc/init.d/deluge-daemon # The init.d script will only run if this variable non-empty. DELUGED_USER="__" # !!!CHANGE THIS!!!! # Should we run at startup? RUN_AT_STARTUP="YES"</span></span></code> </pre>  Then save and close </li><li>  And we perform: <br><pre> <code class="bash hljs">$ sudo vim /etc/init.d/deluge-daemon</code> </pre>  and enter there the following: <br><div class="spoiler">  <b class="spoiler_title">Big script</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh ### BEGIN INIT INFO # Provides: deluge-daemon # Required-Start: $local_fs $remote_fs # Required-Stop: $local_fs $remote_fs # Should-Start: $network # Should-Stop: $network # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # Short-Description: Daemonized version of deluge and webui. # Description: Starts the deluge daemon with the user specified in # /etc/default/deluge-daemon. ### END INIT INFO # Author: Adolfo R. Brandes # Updated by: Jean-Philippe "Orax" Roemer PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin DESC="Deluge Daemon" NAME1="deluged" NAME2="deluge" DAEMON1=/usr/bin/deluged DAEMON1_ARGS="-d" # Consult `man deluged` for more options DAEMON2=/usr/bin/deluge-web DAEMON2_ARGS="" # Consult `man deluge-web` for more options PIDFILE1=/var/run/$NAME1.pid PIDFILE2=/var/run/$NAME2.pid UMASK=022 # Change this to 0 if running deluged as its own user PKGNAME=deluge-daemon SCRIPTNAME=/etc/init.d/$PKGNAME # Exit if the package is not installed [ -x "$DAEMON1" -a -x "$DAEMON2" ] || exit 0 # Read configuration variable file if it is present [ -r /etc/default/$PKGNAME ] &amp;&amp; . /etc/default/$PKGNAME # Load the VERBOSE setting and other rcS variables [ -f /etc/default/rcS ] &amp;&amp; . /etc/default/rcS # Define LSB log_* functions. # Depend on lsb-base (&gt;= 3.0-6) to ensure that this file is present. . /lib/lsb/init-functions if [ -z "$RUN_AT_STARTUP" -o "$RUN_AT_STARTUP" != "YES" ] then log_warning_msg "Not starting $PKGNAME, edit /etc/default/$PKGNAME to start it." exit 0 fi if [ -z "$DELUGED_USER" ] then log_warning_msg "Not starting $PKGNAME, DELUGED_USER not set in /etc/default/$PKGNAME." exit 0 fi # # Function to verify if a pid is alive # is_alive() { pid=`cat $1` &gt; /dev/null 2&gt;&amp;1 kill -0 $pid &gt; /dev/null 2&gt;&amp;1 return $? } # # Function that starts the daemon/service # do_start() { # Return # 0 if daemon has been started # 1 if daemon was already running # 2 if daemon could not be started is_alive $PIDFILE1 RETVAL1="$?" if [ $RETVAL1 != 0 ]; then rm -f $PIDFILE1 start-stop-daemon --start --background --quiet --pidfile $PIDFILE1 --make-pidfile \ --exec $DAEMON1 --chuid $DELUGED_USER --user $DELUGED_USER --umask $UMASK -- $DAEMON1_ARGS RETVAL1="$?" else is_alive $PIDFILE2 RETVAL2="$?" [ "$RETVAL2" = "0" -a "$RETVAL1" = "0" ] &amp;&amp; return 1 fi is_alive $PIDFILE2 RETVAL2="$?" if [ $RETVAL2 != 0 ]; then sleep 2 rm -f $PIDFILE2 start-stop-daemon --start --background --quiet --pidfile $PIDFILE2 --make-pidfile \ --exec $DAEMON2 --chuid $DELUGED_USER --user $DELUGED_USER --umask $UMASK -- $DAEMON2_ARGS RETVAL2="$?" fi [ "$RETVAL1" = "0" -a "$RETVAL2" = "0" ] || return 2 } # # Function that stops the daemon/service # do_stop() { # Return # 0 if daemon has been stopped # 1 if daemon was already stopped # 2 if daemon could not be stopped # other if a failure occurred start-stop-daemon --stop --quiet --retry=TERM/30/KILL/5 --user $DELUGED_USER --pidfile $PIDFILE2 RETVAL2="$?" start-stop-daemon --stop --quiet --retry=TERM/30/KILL/5 --user $DELUGED_USER --pidfile $PIDFILE1 RETVAL1="$?" [ "$RETVAL1" = "2" -o "$RETVAL2" = "2" ] &amp;&amp; return 2 rm -f $PIDFILE1 $PIDFILE2 [ "$RETVAL1" = "0" -a "$RETVAL2" = "0" ] &amp;&amp; return 0 || return 1 } case "$1" in start) [ "$VERBOSE" != no ] &amp;&amp; log_daemon_msg "Starting $DESC" "$NAME1" do_start case "$?" in 0|1) [ "$VERBOSE" != no ] &amp;&amp; log_end_msg 0 ;; 2) [ "$VERBOSE" != no ] &amp;&amp; log_end_msg 1 ;; esac ;; stop) [ "$VERBOSE" != no ] &amp;&amp; log_daemon_msg "Stopping $DESC" "$NAME1" do_stop case "$?" in 0|1) [ "$VERBOSE" != no ] &amp;&amp; log_end_msg 0 ;; 2) [ "$VERBOSE" != no ] &amp;&amp; log_end_msg 1 ;; esac ;; restart|force-reload) log_daemon_msg "Restarting $DESC" "$NAME1" do_stop case "$?" in 0|1) do_start case "$?" in 0) log_end_msg 0 ;; 1) log_end_msg 1 ;; # Old process is still running *) log_end_msg 1 ;; # Failed to start esac ;; *) # Failed to stop log_end_msg 1 ;; esac ;; *) echo "Usage: $SCRIPTNAME {start|stop|restart|force-reload}" &gt;&amp;2 exit 3 ;; esac :</span></span></code> </pre><br></div></div></li><li>  We grant the right to execute this script: <br><pre> <code class="bash hljs">$ sudo chmod 755 /etc/init.d/deluge-daemon</code> </pre></li><li>  Add it to autoload: <br><pre> <code class="bash hljs">$ sudo update-rc.d deluge-daemon defaults</code> </pre></li><li>  And run: <br><pre> <code class="bash hljs">$ sudo invoke-rc.d deluge-daemon start</code> </pre></li><li>  Then we reboot. <br>  Now if you go to 192.168.0.98:8112, then you can get into the web ui torrent rocking. </li><li>  Open access from the outside for our web ui.  To do this, go back to our router in the Forwarding -&gt; Virtual Servers and add another entry: <br>  Service port: 80 <br>  Inner port: 8112 <br>  IP Address: 192.168.0.98 <br>  Protocol: all <br><br>  After saving, it will be possible to access the web ui by simply typing your domain name in the address bar of the browser. <br></li></ol><br><br><h3>  Conclusion </h3><br>  I hope that my article at least someone will be useful.  Thank you for your time and attention. </div><p>Source: <a href="https://habr.com/ru/post/247783/">https://habr.com/ru/post/247783/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../247771/index.html">How to get a lot of street wifi? Experience in building OpenDoor networks with high subscriber density</a></li>
<li><a href="../247773/index.html">Bovanenkovo ‚Äã‚Äã- the organization of communication in the gas field No. 3 in Russia from the BS on permafrost</a></li>
<li><a href="../247775/index.html">Subject-oriented design in PHP</a></li>
<li><a href="../247779/index.html">How I stopped worrying and loved Hyper-V replication</a></li>
<li><a href="../247781/index.html">Mikrotik - Open and check cooling</a></li>
<li><a href="../247785/index.html">Stunning collection of free fonts for 2014</a></li>
<li><a href="../247787/index.html">Quantum mechanics. Theoretical minimum</a></li>
<li><a href="../247789/index.html">How I loved vim, emacs and keyboard</a></li>
<li><a href="../247791/index.html">Experiment: 10 things that I learned, using only water for a month</a></li>
<li><a href="../247793/index.html">Monitoring from Brazil - continue to conquer Latin America</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>