<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Convenient work in the console, or paint STDERR red</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Work in the console 
 Many of us use the console every day, and, probably, everyone asked themselves the question: how can I do my work in the console...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Convenient work in the console, or paint STDERR red</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/90e/bfe/8c7/90ebfe8c7452f3f2fb47260720ca78b6.png" align="right"><h4>  Work in the console </h4><br>  Many of us use the console every day, and, probably, everyone asked themselves the question: how can I do my work in the console more efficiently?  What can I do to spend less time on routine tasks?  In this article I would like to briefly talk about a few simple but useful things when working with bash, which you might not know about. <br><a name="habracut"></a><br><h4>  Reduce the number of letters typed </h4><br><h5>  Aliases </h5><br>  One of the most useful things that all modern shells support is aliases.  Aliases allow you to write fewer letters when typing commands.  For example: <br><br><pre><code class="hljs pgsql">$ git status # <span class="hljs-keyword"><span class="hljs-keyword">On</span></span> branch master <span class="hljs-keyword"><span class="hljs-keyword">nothing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>, working directory clean $ <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> st=<span class="hljs-string"><span class="hljs-string">'git status'</span></span> $ st # <span class="hljs-keyword"><span class="hljs-keyword">On</span></span> branch master <span class="hljs-keyword"><span class="hljs-keyword">nothing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>, working directory clean</code> </pre> <br>  As you can see, the syntax for declaring aliases is very simple, so almost everyone uses aliases anyway.  One of the drawbacks of using aliases is that the auto-complement for commands often stops working. <br><br>  Example: (&lt;TAB&gt; is pressing Tab): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="hljs xml">$ git checkout <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TAB</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TAB</span></span></span><span class="hljs-tag">&gt;</span></span> HEAD master origin/HEAD origin/master</code> </pre> <br>  If we declare an alias co = 'git checkout', then pressing Tab stops working the way we expect and starts simply substituting file names (at least for bash): <br><br><pre> <code class="hljs ruby">$ <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> co=<span class="hljs-string"><span class="hljs-string">'git checkout'</span></span> $ co &lt;TAB&gt;&lt;TAB&gt; Display all <span class="hljs-number"><span class="hljs-number">124</span></span> possibilities? (y <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> n) .git/ MANIFEST.doc array.c bashline.c ...</code> </pre> <br><br>  Thus, if you want to write fewer letters, then you have to abandon the auto-add-on ... Or not?  Let's google a little bit and find this interesting function: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> make-completion-<span class="hljs-keyword"><span class="hljs-keyword">wrapper</span></span> () { <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> function_name="$2" <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> arg_count=$(($#<span class="hljs-number"><span class="hljs-number">-3</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> comp_function_name="$1" shift <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>=" function $function_name { ((COMP_CWORD+=$arg_count)) COMP_WORDS=( "$@" \${COMP_WORDS[@]:1} ) "$comp_function_name" return 0 }" eval "$function" }</code> </pre> <br><br>  This interesting feature allows us to revert autocompletion for ‚Äúcomplex‚Äù commands (that is, when we make an alias consisting of a command and additional arguments, as is the case with git checkout).  It allows us to create a function that, in turn, can be used to wrap auto-add-in functions so that the auto-add-on for aliases continues to work.  Sounds hard ..?  The way it is :).  Let's take a look at the usage example: <br><br><pre> <code class="hljs pgsql">$ make-completion-<span class="hljs-keyword"><span class="hljs-keyword">wrapper</span></span> _git _co git checkout $ complete -o bashdefault -o <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> -o nospace -F _co co $ co &lt;TAB&gt;&lt;TAB&gt; HEAD master origin/HEAD origin/master</code> </pre> <br>  Let's analyze a little more: <br><br>  1) make-completion-wrapper: Auto-completion functions for commands usually begin with an underline, and for example for the git command, this function is called "_git".  With our great make-completion-wrapper function, we will create a new function called "_co" (for the co command), which is an alias for "git checkout" <br>  2) complete: Register our new function "_co" as a handler for auto-add for the "co" command <br>  3) Works! <br><br>  To prevent aliases and auto-add-in commands from being lost, we will save these commands in ".bashrc" (or ".bash_profile" or ".profile") in your home directory, and we will be happy :). <br><br><h5>  Functions </h5><br>  The bash alias capabilities are limited, so sometimes it is useful to write functions (as in the previous example).  Functions in bash work as if they were a separate command, but the functions are executed in the same context as the current shell.  That is, the arguments to the functions are passed as "$ 1", "$ 2", etc., as if you were writing a shell script.  The abbreviation "$ @" (in quotes) also works, which substitutes all its arguments "as is" in the right place.  On serverfault <a href="http://serverfault.com/questions/59262/bash-print-stderr-in-red-color">you can find an example of such a function</a> that colors stderr with a given command in red: <br><br><pre> <code class="hljs pgsql">$ color()(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> -o pipefail;"$@" <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;&amp;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;&amp;<span class="hljs-number"><span class="hljs-number">3</span></span>|sed $<span class="hljs-string"><span class="hljs-string">'s,.*,\e[31m&amp;\e[m,'</span></span>&gt;&amp;<span class="hljs-number"><span class="hljs-number">2</span></span>)<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;&amp;<span class="hljs-number"><span class="hljs-number">1</span></span> $ color ls nonexistent ls: nonexistent: <span class="hljs-keyword"><span class="hljs-keyword">No</span></span> such file <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> directory #   </code> </pre> <br>  Even if you do not write commands such as the one above, it is convenient to use functions, if you need to, say, always add the necessary arguments to the end of a command: <br><br><pre> <code class="hljs php">$ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">echoworld</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"$@"</span></span> world; } $ echoworld Hello Hello world</code> </pre><br>  Or if you need to do some simple operations on the arguments: <br><br><pre> <code class="hljs lua">$ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gmo</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { git merge <span class="hljs-string"><span class="hljs-string">"origin/$1"</span></span>; } $ gmo master # git merge <span class="hljs-string"><span class="hljs-string">"origin/master"</span></span> Already up-to-<span class="hljs-built_in"><span class="hljs-built_in">date</span></span>.</code> </pre><br><h4>  Getting rid of SSH input lags with mosh </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/767/a6a/0e8/767a6a0e8a0ab4b6b72bfddd110c5b8b.png" align="left">  If you often have to work on SSH with heavily remote servers (for example, the Amazon cloud in America), or you work on SSH via the mobile Internet, you know the problem of input delay.  That is, you enter some character, and it appears on the remote side only after the round-trip interval, which can easily be 200 ms or more.  In the case of the mobile Internet, input delays are felt much more strongly and it becomes uncomfortable to work. <br><br>  Probably, the authors of the utility called mosh ( <a href="http://mosh.mit.edu/">http://mosh.mit.edu</a> ) are so fed up with the problem that they decided to write their own SSH replacement running on UDP and solving many SSH problems, for example, noticeable input delays and no feedback connections (write failed: broken pipe, which only appears when you try to enter something). <br><br>  This utility also has one major drawback - there is currently no support for viewing history.  That is, if you make cat from a large file or ls from a large directory, then most likely you will only get the last lines of the output, and the beginning will be ‚Äúlost‚Äù.  The authors themselves currently recommend using screen on the remote side to solve this problem, and in version 1.3 they promise to build similar functionality directly into the server (and client). <br><br><h3>  Bash patch to stderr red </h3><br>  In fact, patching bash to get a red stderr is not at all necessary, but it's interesting!  There are already ready-made solutions that are easy to use, such as this: <a href="https://github.com/sickill/stderred">github.com/sickill/stderred</a> .  The project is a shared library that intercepts calls to write (2, ...) and fprintf from libc, and adds a wrapper around the necessary esc sequences to get the red color around. <br><br>  So, we understood that other solutions exist, and they even suit everyone, so let's write our own anyway :)!  I want to immediately say a separate thank you <a href="http://habrahabr.ru/users/ezh/" class="user_link">ezh</a> for the assistance in the implementation of the patch. <br><br>  1. Downloading the bash source ( <a href="http://ftp.gnu.org/gnu/bash/">ftp.gnu.org/gnu/bash</a> ) <br>  2. Add them to git (git init &amp;&amp; git add -A &amp;&amp; git commit -m 'Initial commit') <br>  3. Build bash (./configure &amp;&amp; make) <br>  4. Run bash and make sure everything works (./bash -l) <br>  5. We start to understand the source code: <br><br>  Find the <b>shell.c</b> file and see where bash initialization begins: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined (NO_MAIN_ENV_ARG) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* systems without third argument to main() */</span></span></span><span class="hljs-meta"> int main (argc, argv) int argc; char **argv; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* !NO_MAIN_ENV_ARG */</span></span></span><span class="hljs-meta"> int main (argc, argv, env) int argc; char **argv, **env; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* !NO_MAIN_ENV_ARG */</span></span></span><span class="hljs-meta"> {</span></span></code> </pre><br><br>  After about 400 lines, while still in the main () function, at the very end we find the reader_loop () call: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !defined (ONESHOT) read_and_execute: #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* !ONESHOT */</span></span></span><span class="hljs-meta"> shell_initialized = 1; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Read commands until exit condition. */</span></span></span><span class="hljs-meta"> reader_loop (); exit_shell (last_command_exit_value); }</span></span></code> </pre><br><br>  It would be logical to wedge right before bash starts reading user input and somehow intercepts descriptor number 2 (stderr) if the necessary environment variable is set: <br><br><pre> <code class="cpp hljs"> shell_initialized = <span class="hljs-number"><span class="hljs-number">1</span></span>; color_stderr = get_string_value(<span class="hljs-string"><span class="hljs-string">"COLOR_STDERR"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (color_stderr &amp;&amp; color_stderr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) { init_color_stderr(); } <span class="hljs-comment"><span class="hljs-comment">/* Read commands until exit condition. */</span></span> reader_loop ();</code> </pre><br><br>  How to intercept descriptor number 2?  The obvious solution is to create a pipe, and replace the handle with the number 2 with our pipe, and in another thread read from there, and add the necessary esc sequences: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">colorize_stderr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *void_thread_args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stderr_thread_data</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stderr_thread_data</span></span></span><span class="hljs-class">*)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void_thread_args</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STDERR_PREFIX </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\033[31m"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STDERR_SUFFIX </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\033[m"</span></span></span><span class="hljs-meta"> for (;;) { n = read(data-&gt;pipe, buf, sizeof(buf)); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (n </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;= 0) { if (errno == EINTR) continue; pthread_exit(NULL); } write(data-&gt;err, STDERR_PREFIX, sizeof(STDERR_PREFIX) - 1); write(data-&gt;err, buf, (size_t) n); write(data-&gt;err, STDERR_SUFFIX, sizeof(STDERR_SUFFIX) - 1); } } static void init_color_stderr () { pthread_t thr; int pipes[2]; static struct stderr_thread_data data; pipe(pipes); data.err = dup(2); dup2(pipes[1], 2); data.pipe = pipes[0]; pthread_create(&amp;thr, NULL, colorize_stderr, (void*) &amp;data); }</span></span></span></span></code> </pre><br><br>  However, the entire user input also becomes red: (Apparently, the readline library displays our input on the screen just in stderr ... After digging into the readline library, we insert into the file lib / readline / display.c in the rl_redisplay function (the function, by the way, is only 1300 lines) the following: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Basic redisplay algorithm. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rl_redisplay</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ...   ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_rl_echoing_p == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; _rl_output_some_chars(<span class="hljs-string"><span class="hljs-string">"\033[m"</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*  -:  ,      ,    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Block keyboard interrupts because this function manipulates global data structures. */</span></span> _rl_block_sigint (); RL_SETSTATE (RL_STATE_REDISPLAYING);</code> </pre><br><br>  If everything is done correctly and the necessary headers and method signatures are added (these actions were omitted for brevity), then when we write the line ‚Äúexport COLOR_STDERR = 1‚Äù in .bashrc and run the new compiled bash, the entire stderr will turn red, as in the screenshot at the beginning articles. <br><br>  Since replacing the system bash is a bad idea, you can put a new, compiled bash, say, in ~ / bash and add the following to .bashrc: <br><br><pre> <code class="hljs bash"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ ! -z <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$PS1</span></span></span><span class="hljs-string">"</span></span> ] &amp;&amp; [ -z <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$MY_BASH</span></span></span><span class="hljs-string">"</span></span> ] &amp;&amp; [ -x ~/bash ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> MY_BASH=1 <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> ~/bash -l <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$@</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> COLOR_STDERR=1</code> </pre><br><br>  Upon login, it will be checked if "~ / bash" exists and is executable, and if so, it will replace the current process with "~ / bash -l" (that is, the login shell).  The option COLOR_STDERR = 1 will color us stderr bash red. <br><br>  The patched version of bash is posted on github: <a href="https://github.com/YuriyNasretdinov/bash">github.com/YuriyNasretdinov/bash</a> <br><br>  Since the edits are designed as a ‚Äúcrutch‚Äù to bash, it is unlikely that this patch will be accepted into the main branch, but the implementation itself seems to me rather amusing: to work, in fact, you need to set only one environment variable (you can easily cut it from the code, and then this mode will be enabled by default), and everything else will work without changes. <br><br>  I hope, dear reader, you could learn something useful from this article :).  Happy New Year! </div><p>Source: <a href="https://habr.com/ru/post/207768/">https://habr.com/ru/post/207768/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../207756/index.html">Elections OS</a></li>
<li><a href="../207758/index.html">NSA does not cope with traffic volumes</a></li>
<li><a href="../207760/index.html">How freshman Cauchy's definition has reduced</a></li>
<li><a href="../207762/index.html">January 2, 2014 the Blender project will be 20 years old</a></li>
<li><a href="../207764/index.html">Melange - DSL for Network Protocols</a></li>
<li><a href="../207774/index.html">Hacked openssl.org</a></li>
<li><a href="../207776/index.html">Best PHP frameworks 2013</a></li>
<li><a href="../207778/index.html">Asynchronous JavaScript (book)</a></li>
<li><a href="../207780/index.html">The Mail.Ru Cloud License Agreement changed</a></li>
<li><a href="../207784/index.html">Merge sort and AS3. Overtaking the native Vector.sort (Array.NUMERIC)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>