<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Practical Go: tips on writing supported programs in the real world</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article is devoted to the best practices of writing Go code. It is made in the style of the presentation, but without the usual slides. We will tr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Practical Go: tips on writing supported programs in the real world</h1><div class="post__text post__text-html js-mediator-article">  The article is devoted to the best practices of writing Go code.  It is made in the style of the presentation, but without the usual slides.  We will try to briefly and clearly walk through each item. <br><br>  First you need to agree on what the <i>best</i> practices for a programming language mean.  Here you can recall the words of Russ Cox, Go technical manager: <br><br><blockquote>  Software engineering is what happens with programming if you add the time factor to other programmers. </blockquote><br>  Thus, Russ distinguishes between the concepts of <i>programming</i> and <i>software engineering</i> .  In the first case, you write a program for yourself; in the second, you create a product, over which other programmers will work over time.  Engineers come and go.  Teams grow or shrink.  New features are added and bugs are fixed.  That is the nature of software development. <br><a name="habracut"></a><br><a name="0"></a><h1>  Content </h1><br><ul><li>  <a href="https://habr.com/ru/post/441842/">Content</a> </li><li>  <a href="https://habr.com/ru/post/441842/">1. Fundamental principles</a> <br><ul><li>  <a href="https://habr.com/ru/post/441842/">1.1.</a>  <a href="https://habr.com/ru/post/441842/">Simplicity</a> </li><li>  <a href="https://habr.com/ru/post/441842/">1.2.</a>  <a href="https://habr.com/ru/post/441842/">Readability</a> </li><li>  <a href="https://habr.com/ru/post/441842/">1.3.</a>  <a href="https://habr.com/ru/post/441842/">Productivity</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/441842/">2. Identifiers</a> <br><ul><li>  <a href="https://habr.com/ru/post/441842/">2.1.</a>  <a href="https://habr.com/ru/post/441842/">Name identifiers for clarity, not brevity.</a> </li><li>  <a href="https://habr.com/ru/post/441842/">2.2.</a>  <a href="https://habr.com/ru/post/441842/">Id length</a> </li><li>  <a href="https://habr.com/ru/post/441842/">2.3.</a>  <a href="https://habr.com/ru/post/441842/">Do not name variables by their types.</a> </li><li>  <a href="https://habr.com/ru/post/441842/">2.4.</a>  <a href="https://habr.com/ru/post/441842/">Use a single naming style.</a> </li><li>  <a href="https://habr.com/ru/post/441842/">2.5.</a>  <a href="https://habr.com/ru/post/441842/">Use a single declaration style.</a> </li><li>  <a href="https://habr.com/ru/post/441842/">2.6.</a>  <a href="https://habr.com/ru/post/441842/">Work for a team</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/441842/">3. Comments</a> <br><ul><li>  <a href="https://habr.com/ru/post/441842/">3.1.</a>  <a href="https://habr.com/ru/post/441842/">Comments in variables and constants should describe their contents, not their purpose.</a> </li><li>  <a href="https://habr.com/ru/post/441842/">3.2.</a>  <a href="https://habr.com/ru/post/441842/">Always document public symbols.</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/441842/">4. Package structure</a> <br><ul><li>  <a href="https://habr.com/ru/post/441842/">4.1.</a>  <a href="https://habr.com/ru/post/441842/">A good package starts with a good name.</a> </li><li>  <a href="https://habr.com/ru/post/441842/">4.2.</a>  <a href="https://habr.com/ru/post/441842/">Avoid names like base, common or util</a> </li><li>  <a href="https://habr.com/ru/post/441842/">4.3.</a>  <a href="https://habr.com/ru/post/441842/">Come back quickly, without diving</a> </li><li>  <a href="https://habr.com/ru/post/441842/">4.4.</a>  <a href="https://habr.com/ru/post/441842/">Make a value of zero useful</a> </li><li>  <a href="https://habr.com/ru/post/441842/">4.5.</a>  <a href="https://habr.com/ru/post/441842/">Avoid Package Level Status</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/441842/">5. Project structure</a> <br><ul><li>  <a href="https://habr.com/ru/post/441842/">5.1.</a>  <a href="https://habr.com/ru/post/441842/">Smaller packages, but larger</a> </li><li>  <a href="https://habr.com/ru/post/441842/">5.2.</a>  <a href="https://habr.com/ru/post/441842/">Main package minimum size</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/441842/">6. API structure</a> <br><ul><li>  <a href="https://habr.com/ru/post/441842/">6.1.</a>  <a href="https://habr.com/ru/post/441842/">Design APIs that are hard to abuse by design.</a> </li><li>  <a href="https://habr.com/ru/post/441842/">6.2.</a>  <a href="https://habr.com/ru/post/441842/">Design an API for the main use case.</a> </li><li>  <a href="https://habr.com/ru/post/441842/">6.3.</a>  <a href="https://habr.com/ru/post/441842/">Let functions define the desired behavior.</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/441842/">7. Error handling</a> <br><ul><li>  <a href="https://habr.com/ru/post/441842/">7.1.</a>  <a href="https://habr.com/ru/post/441842/">Eliminate the need for error handling by removing the errors themselves</a> </li><li>  <a href="https://habr.com/ru/post/441842/">7.2.</a>  <a href="https://habr.com/ru/post/441842/">Handle the error only once.</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/441842/">8. Parallelism</a> <br><ul><li>  <a href="https://habr.com/ru/post/441842/">8.1.</a>  <a href="https://habr.com/ru/post/441842/">Constantly do some work.</a> </li><li>  <a href="https://habr.com/ru/post/441842/">8.2.</a>  <a href="https://habr.com/ru/post/441842/">Leave concurrency to caller</a> </li><li>  <a href="https://habr.com/ru/post/441842/">8.3.</a>  <a href="https://habr.com/ru/post/441842/">Never start a go-routine without knowing when it will stop.</a> </li></ul></li></ul><br><a name="1"></a><h1>  1. Fundamental principles </h1><br>  Perhaps among you I am one of the first Go users, but this is not my personal opinion.  These basic principles underpin Go itself: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  Simplicity </li><li>  Readability </li><li>  Productivity </li></ol><br>  <i>Note.</i>  <i>Note that I did not mention "performance" or "parallelism".</i>  <i>There are languages ‚Äã‚Äãfaster Go, but definitely they can not be compared in simplicity.</i>  <i>There are languages ‚Äã‚Äãthat make concurrency a top priority, but they do not equal either in readability or in programming productivity.</i> <i><br><br></i>  <i>Performance and concurrency are important attributes, but not as important as simplicity, readability and productivity.</i> <br><br><a name="1_1"></a><h2>  Simplicity </h2><br><blockquote>  <i>‚ÄúSimplicity is a prerequisite for readability‚Äù</i> - Edsger Dijkstra </blockquote><br>  Why strive for simplicity?  Why is it important that Go programs are simple? <br><br>  Each of us came across an incomprehensible code, right?  When you are afraid to make an edit, because it will break another part of the program that you do not quite understand and do not know how to fix it.  This is the complexity. <br><br><blockquote>  <i>‚ÄúThere are two ways to design software: the first is to make it so simple that there are no obvious flaws, and the second is to make it so complicated that there are no obvious flaws.</i>  <i>The first is much more difficult. ‚Äù</i> - C. E. R. Hoar </blockquote><br>  The complexity turns reliable software into unreliable.  The complexity is what kills software projects.  Therefore, simplicity is the ultimate goal of Go.  Whatever programs we write, they should be simple. <br><br><a name="1_2"></a><h2>  1.2.  Readability </h2><br><blockquote>  <i>‚ÄúReadability is an integral part of maintainability‚Äù</i> - Mark Reinhold, JVM conference, 2018 </blockquote><br>  Why is it important that the code is readable?  Why should we strive for readability? <br><br><blockquote>  <i>‚ÄúPrograms should be written for people, and machines only execute them‚Äù</i> - Hal Abelson and Gerald Sassman, ‚ÄúStructure and Interpretation of Computer Programs‚Äù </blockquote><br>  Not only Go programs, but in general all software is written by people for people.  The fact that machines also process the code is secondary. <br><br>  Once written, the code will be repeatedly read by people: hundreds or even thousands of times. <br><br><blockquote>  <i>‚ÄúThe most important skill for a programmer is the ability to effectively convey ideas‚Äù</i> - <a href="https://gaston.life/books/effective-programming/">Gaston Horker</a> </blockquote><br>  Readability is the key to understanding what the program does.  If you can not understand the code, how to support it?  If the software cannot be maintained, it will be rewritten;  and this may be the last time your company uses Go. <br><br>  If you are writing a program for yourself, do what works for you.  But if this is part of a joint project or program will be used long enough to change the requirements, functions, or environment in which it works, then your goal is to make the program maintainable. <br><br>  The first step to writing supported software is to make sure the code is clear. <br><br><a name="1_3"></a><h2>  1.3.  Productivity </h2><br><blockquote>  <i>‚ÄúDesign is the art of organizing code so that it works today, but always supports change.‚Äù</i> - Sandy Mets </blockquote><br>  As the last basic principle I want to name the developer productivity.  This is a big topic, but it comes down to the ratio: how much time you spend on useful work, and how much - on waiting for a response from tools or hopeless wandering in an incomprehensible code base.  Go programmers need to feel that they can handle a lot of work. <br><br>  There is a joke that the Go language was developed while the C ++ program was compiled.  Quick compilation is a key feature of Go and a key factor in attracting new developers.  Although compilers are improving, in general, minute compilations in other languages ‚Äã‚Äãtake place in a few seconds on Go.  So Go developers feel as productive as programmers in dynamic languages, but without problems with the reliability of those languages. <br><br>  If it is fundamental to talk about developer productivity, then Go programmers understand that reading the code is essentially more important than writing it.  In this logic, Go even goes so far as using the tools to format all the code in a particular style.  This eliminates the slightest difficulty in learning a specific dialect of a particular project and helps to identify errors, because they just <i>look</i> wrong compared to ordinary code. <br><br>  Go programmers do not spend days debugging strange compilation errors, complex build scripts, or deploying code in a production environment.  And most importantly, they do not waste time trying to understand what a colleague wrote. <br><br>  When the Go developers talk about the <i>scalability of a</i> language, they mean exactly productivity. <br><br><a name="2"></a><h1>  2. Identifiers </h1><br>  The first topic we‚Äôll discuss is <i>identifiers</i> , which is a synonym for <i>names</i> : the names of variables, functions, methods, types, packages, and so on. <br><br><blockquote>  <i>‚ÄúA bad name is a symptom of bad design‚Äù</i> - <a href="https://twitter.com/davecheney/status/997150760344305665">Dave Cheney</a> </blockquote><br>  Given the limited syntax of Go, object names have a huge impact on the readability of programs.  Readability is a key factor in good code, so choosing good names is crucial. <br><br><a name="2_1"></a><h2>  2.1.  Name identifiers for clarity, not brevity. </h2><br><blockquote>  <i>‚ÄúIt is important that the code is obvious.</i>  <i>What can be done in one line, you must do in three "</i> - <a href="https://twitter.com/UkiahSmith/status/1044931395112644608">Ukiya Smith</a> </blockquote><br>  Go is not optimized for tricky one-liners or the minimum number of lines in the program.  We do not optimize the size of the source code on the disk, nor the time required to set the program in the editor. <br><br><blockquote>  <i>‚ÄúA good name is like a good joke.</i>  <i>If you need to explain it, it's not funny anymore. ‚Äù</i> - <a href="https://twitter.com/davecheney/status/997155238929842176">Dave Cheney</a> </blockquote><br>  The key to maximum clarity is the names we choose to identify programs.  What are the qualities of a good name? <br><br><ul><li>  <b>A good name is concise</b> .  It does not have to be the shortest, but does not contain excess.  He has a high signal-to-noise ratio. </li><li>  <b>A good name is descriptive</b> .  It describes the use of a variable or a constant, <i>not the</i> content.  A good name describes the result of the function or the behavior of the method, <i>not the</i> implementation.  The purpose of the package, <i>not</i> its contents.  The more precisely the name describes the thing that identifies, the better. </li><li>  <b>A good name is predictable</b> .  By one name, you must understand how the object will be used.  Names should be descriptive, but it is also important to follow the tradition.  This is what Go programmers mean when they say <i>idiomatic</i> . </li></ul><br>  Let's take a closer look at each of these properties. <br><br><a name="2_2"></a><h2>  2.2.  Id length </h2><br>  Sometimes Go style is criticized for short variable names.  As Rob Pike <a href="https://www.lysator.liu.se/c/pikestyle.html">said</a> , ‚ÄúGo programmers want identifiers of the <i>correct</i> length.‚Äù <br><br>  Andrew Gerrand suggests using long identifiers to indicate importance. <br><br><blockquote> <i>‚ÄúThe greater the distance between the announcement of the name and the use of the object, the longer the name must be‚Äù</i> - <a href="https://talks.golang.org/2014/names.slide">Andrew Gerrand</a> </blockquote><br>  Thus, you can make some recommendations: <br><br><ul><li>  Short variable names are good if the distance between the announcement and the <i>last</i> use is small. <br></li><li>  Long variable names must justify themselves;  the longer they are, the greater the value must be.  Verbose names contain little signal relative to their weight on the page. <br></li><li>  Do not include the type name in the variable name. <br></li><li>  Constant names must describe the internal value, not how this value is used. <br></li><li>  Prefer single-letter variables for loops and branches, separate words for parameters and return values, a few words for functions and declarations at the package level. <br></li><li>  Prefer single words for methods, interfaces, and packages. <br></li><li>  Remember that the package name is part of the name that the caller uses for the link. </li></ul><br>  Consider an example. <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Person <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Age <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-comment"><span class="hljs-comment">// AverageAge returns the average age of people. func AverageAge(people []Person) int { if len(people) == 0 { return 0 } var count, sum int for _, p := range people { sum += p.Age count += 1 } return sum / count }</span></span></code> </pre> <br>  The tenth line declares the variable of the range <code>p</code> , and it is called only once from the next line.  That is, the variable lives on the page for a very short time.  If the reader is interested in the role of <code>p</code> in the program, it is enough to read only two lines. <br><br>  For comparison, <code>people</code> declared in the parameters of the function and live seven lines.  The same applies to <code>sum</code> and <code>count</code> , so they justify their longer names.  The reader needs to scan more code to find them: this justifies more distinctive names. <br><br>  You can choose <code>s</code> for <code>sum</code> and <code>c</code> (or <code>n</code> ) for <code>count</code> , but this will reduce the importance of all variables in the program to the same level.  You can replace <code>people</code> with <code>p</code> , but there will be a problem, how to call the iteration variable <code>for ... range</code> .  A single <code>person</code> will look weird, because a short-lived iteration variable produces a longer name than several values ‚Äã‚Äãfrom which it is derived. <br><br><blockquote>  <b>Council</b>  Separate the function flow with empty lines, as empty lines between paragraphs break the flow of text.  In <code>AverageAge</code> we have three consecutive operations.  First, check the division by zero, then the total age and the number of people, and the last is the calculation of the average age. </blockquote><br><h3>  2.2.1.  The main thing is the context </h3><br>  It is important to understand that most naming tips are context sensitive.  I like to say that this is a principle, not a rule. <br><br>  What is the difference between <code>i</code> and <code>index</code> ids?  For example, it is impossible to say for sure that such code <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> index := <span class="hljs-number"><span class="hljs-number">0</span></span>; index &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s); index++ { <span class="hljs-comment"><span class="hljs-comment">// }</span></span></code> </pre> <br>  fundamentally more readable than <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s); i++ { <span class="hljs-comment"><span class="hljs-comment">// }</span></span></code> </pre> <br>  I believe that the second option is not worse, because in this case the area <code>i</code> or <code>index</code> limited to the body of the <code>for</code> loop, and the additional verbosity adds little to the understanding of the program. <br><br>  But which of these functions is more readable? <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *SNMP)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oid []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, index </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span></code> </pre> <br>  or <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *SNMP)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(o []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span></code> </pre> <br>  In this example, <code>oid</code> is an abbreviation of SNMP Object ID, and an additional abbreviation to <code>o</code> causes the code to go from documented notation to shorter notation in code.  Similarly, the reduction of <code>index</code> to <code>i</code> makes it difficult to understand the essence, since in SNMP messages, the sub value of each OID is called an index. <br><br><blockquote>  <b>Council</b>  Do not combine long and short formal parameters in one ad. </blockquote><br><a name="2_3"></a><h2>  2.3.  Do not name variables by their types. </h2><br>  You will not call your pets "dog" and "cat", right?  For the same reason, do not include the type name in the variable name.  It should describe the content, not its type.  Consider an example: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> usersMap <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*User</code> </pre> <br>  What good is this ad?  We see that this is a map, and it has something to do with the type <code>*User</code> : this is probably good.  But <code>usersMap</code> is <i>really a</i> map, and Go, as a statically typed language, will not accidentally use such a name where a scalar variable is required, therefore the <code>Map</code> suffix is ‚Äã‚Äãredundant. <br><br>  Consider the situation when other variables are added: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( companiesMap <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*Company productsMap <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*Products )</code> </pre> <br>  Now we have three variables of type map: <code>usersMap</code> , <code>companiesMap</code> and <code>productsMap</code> , and all strings are matched with different types.  We know that these are maps, and we also know that the compiler will give an error if we try to use <code>companiesMap</code> where the code expects <code>map[string]*User</code> .  In this situation, it is clear that the <code>Map</code> suffix does not improve the clarity of the code, it‚Äôs just extra characters. <br><br>  I suggest avoiding any suffixes that resemble the type of a variable. <br><br><blockquote>  <b>Council</b>  If the title <code>users</code> insufficiently clearly describes the essence, then <code>usersMap</code> too. </blockquote><br>  This tip also applies to function parameters.  For example: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Config <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">// } func WriteConfig(w io.Writer, config *Config)</span></span></code> </pre> <br>  The <code>config</code> name for the <code>*Config</code> parameter is redundant.  We already know that this is <code>*Config</code> , right there next written. <br><br>  In this case, consider <code>conf</code> or <code>c</code> if the lifetime of the variable is short enough. <br><br>  If at some point in our area more than one <code>*Config</code> , then the names <code>conf1</code> and <code>conf2</code> less meaningful than the <code>original</code> and <code>updated</code> , since the latter are more difficult to confuse. <br><br><blockquote>  <b>Note</b>  Don't let package names steal good variable names. <br><br>  The name of the identifier being imported contains the name of the package.  For example, the <code>Context</code> type in the <code>context</code> package will be called <code>context.Context</code> .  This makes it impossible to use a variable or type <code>context</code> in your package. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context context.Context, message </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> <br>  This will not compile.  That is why the local declaration of <code>context.Context</code> types, for example, traditionally uses names like <code>ctx</code> . <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, message </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> </blockquote><br><a name="2_4"></a><h2>  2.4.  Use a single naming style. </h2><br>  Another property of a good name - it must be predictable.  The reader should immediately understand him.  If this is a <i>common</i> name, then the reader has the right to assume that it has not changed the meaning from the previous time. <br><br>  For example, if the code goes around a database handle, each time the parameter is displayed, it must have the same name.  Instead of all combinations of types <code>d *sql.DB</code> , <code>dbase *sql.DB</code> , <code>DB *sql.DB</code> and <code>database *sql.DB</code> it is better to use one thing: <br><br><pre> <code class="go hljs">db *sql.DB</code> </pre> <br>  It's easier to understand the code.  If you see a <code>db</code> , you know that it is <code>*sql.DB</code> and it is declared locally or provided by the caller. <br><br>  Similar advice regarding method recipients;  use the same recipient name for each method of this type.  So it will be easier for the reader to grasp the use of the recipient among various methods of this type. <br><br><blockquote>  <b>Note</b>  The agreement on short names of recipients in Go contradicts the previously voiced recommendations.  This is one of those cases where the choice made at an early stage becomes a standard style, like using <code>CamelCase</code> instead of <code>snake_case</code> . </blockquote><br><blockquote>  <b>Council</b>  The Go style indicates single letter names or abbreviations for recipients, derived from their type.  It may turn out that the receiver's name sometimes conflicts with the name of the parameter in the method.  In this case, it is recommended to make the parameter name a little longer and not to forget to use it consistently. </blockquote><br>  Finally, some single-letter variables are traditionally associated with cycles and counting.  For example, <code>i</code> , <code>j</code> and <code>k</code> are usually inductive variables in <code>for</code> cycles, <code>n</code> usually associated with a counter or accumulator, <code>v</code> is a typical value reduction in the coding function, <code>k</code> usually used for a card key, and <code>s</code> often used as an abbreviation for <code>string</code> parameters . <br><br>  As in the <code>db</code> example above, programmers <i>expect</i> <code>i</code> be an inductive variable.  If they see it in code, then they expect to see a loop soon. <br><br><blockquote>  <b>Council</b>  If you have so many nested loops that you have exhausted the supply of variables <code>i</code> , <code>j</code> and <code>k</code> , then you should split the function into smaller units. </blockquote><br><a name="2_5"></a><h2>  2.5.  Use a single declaration style. </h2><br>  Go has at least six different ways to declare a variable. <br><br><ul><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>; x = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> </li><li><pre> <code class="go hljs">x := <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li></ul><br>  Sure, I have not remembered everything.  Go developers, probably, consider this a mistake, but it is already too late to change something.  With this choice, how to ensure a uniform style? <br><br>  I want to offer a style of variable declaration, which I myself try to use wherever possible. <br><br><ul><li>  <b>When declaring a variable without initialization, use <code>var</code></b> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-comment"><span class="hljs-comment">// 0 var things []Thing // an empty slice of Things var thing Thing // empty Thing struct json.Unmarshall(reader, &amp;thing)</span></span></code> </pre> <br>  <code>var</code> acts as a hint that this variable is <i>intentionally</i> declared as a null value of the specified type.  This is consistent with the requirement to declare variables at the package level using <code>var</code> in contrast to the syntax of a short declaration, although I will later argue that package-level variables should not be used at all. </li><li>  <b>When declaring with initialization, use <code>:=</code></b> .  This makes it clear to the reader that the variable to the left of <code>:=</code> intentionally initialized. <br><br>  To explain why, let's look at the previous example, but this time we specifically initialize each variable: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things []Thing = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing *Thing = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing) json.Unmarshall(reader, thing)</code> </pre> </li></ul><br>  Since there are no automatic conversions from one type to another in Go, in the first and third examples, the type on the left side of the assignment operator must be identical to the type on the right side.  The compiler can deduce the type of the declared variable from the type on the right, so that an example can be written more concisely: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things []Thing = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing) json.Unmarshall(reader, thing)</code> </pre> <br>  Here, the <code>players</code> explicitly initialized to <code>0</code> , which is redundant, because the initial value of the <code>players</code> is zero anyway.  Therefore, it is better to make it clear that we want to use a zero value: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players <span class="hljs-keyword"><span class="hljs-keyword">int</span></span></code> </pre> <br>  What about the second operator?  We cannot determine the type and write <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things = <span class="hljs-literal"><span class="hljs-literal">nil</span></span></code> </pre> <br>  Because <code>nil</code> <a href="https://speakerdeck.com/campoy/understanding-nil">no type</a> .  Instead, we have a choice: or we use the zero value for the slice ... <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things []Thing</code> </pre> <br>  ... or create a slice with zero elements? <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Thing, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  In the second case, the value for the slice is <i>not</i> zero, and we let the reader understand this using a short form of the announcement: <br><br><pre> <code class="go hljs">things := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Thing, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  This tells the reader that we decided to explicitly initialize <code>things</code> . <br><br>  So we come to the third declaration: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing)</code> </pre> <br>  Here, both the explicit initialization of the variable and the introduction of the "unique" keyword <code>new</code> , which some Go programmers do not like, are simultaneously.  If we apply the recommended short syntax, we get <br><br><pre> <code class="go hljs">thing := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing)</code> </pre> <br>  This makes it clear that <code>thing</code> explicitly initialized to the result of <code>new(Thing)</code> , but still leaves an atypical <code>new</code> .  The problem could be solved with the help of a literal: <br><br><pre> <code class="go hljs">thing := &amp;Thing{}</code> </pre> <br>  That is similar to <code>new(Thing)</code> , and such duplication grieves some Go programmers.  However, this means that we explicitly initialize a <code>thing</code> with a pointer to <code>Thing{}</code> and a zero value of <code>Thing</code> . <br><br>  But it is better to take into account the fact that the <code>thing</code> declared with a zero value, and use the operator‚Äôs address to transfer the address of the <code>thing</code> to <code>json.Unmarshall</code> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing Thing json.Unmarshall(reader, &amp;thing)</code> </pre> <br><blockquote>  <b>Note</b>  Of course, there are exceptions to any rule.  For example, sometimes two variables are closely related, so it would be strange to write <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> max := <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre> <br>  More readable declaration: <br><br><pre> <code class="go hljs">min, max := <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre> </blockquote><br>  Summarize: <br><br><ul><li>  When declaring a variable without initialization, use the <code>var</code> syntax. <br></li><li>  When declaring and explicitly initializing a variable, use <code>:=</code> . </li></ul><br><blockquote>  <b>Council</b>  Explicitly point out complex things. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> = <span class="hljs-number"><span class="hljs-number">0x80</span></span></code> </pre> <br>  Here, <code>length</code> can be used with a library, which requires a specific numeric type, and this option more explicitly indicates that the type of length is specifically chosen as uint32 than in the short declaration: <br><br><pre> <code class="go hljs">length := <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span>(<span class="hljs-number"><span class="hljs-number">0x80</span></span>)</code> </pre> <br>  In the first example, I intentionally break my rule by using the var declaration with explicit initialization.  A departure from the standard makes the reader understand that something unusual is happening. </blockquote><br><a name="2_6"></a><h2>  2.6.  Work for a team </h2><br>  I have already said that the essence of software development is the creation of readable, supported code.  Probably most of your career will be working on joint projects.  My advice in this situation: follow the style adopted in the team. <br><br>  Changing styles in the middle of a file is annoying.  It is important uniformity, albeit to the detriment of personal preferences.  My rule of thumb is: if the code comes up through <code>gofmt</code> , then usually the problem is not worth discussing. <br><br><blockquote>  <b>Council</b>  If you want to rename the entire code base, do not mix it with other changes.  If someone uses git bisect, he will not like to wade through thousands of renames to find another altered code. </blockquote><br><h1>  3. Comments </h1><br>  Before we move on to more important points, I want to give a couple of minutes to the comments. <br><br><blockquote>  <i>‚ÄúA good code has a lot of comments, and a bad code requires a lot of comments‚Äù</i> - Dave Thomas and Andrew Hunt, ‚ÄúPragmatic Programmer‚Äù </blockquote><br>  Comments are very important for the readability of the program.  Each comment should make one - and only one - of three things: <br><br><ol><li>  Explain <i>what the</i> code does. </li><li>  Explain <i>how</i> he does it. </li><li>  Explain <i>why</i> . </li></ol><br>  The first form is ideal for comments on public symbols: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Open     . //           .</span></span></code> </pre> <br>  The second is ideal for comments inside the method: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//     var results []chan error for _, dep := range a.Deps { results = append(results, execute(seen, dep)) }</span></span></code> </pre> <br>  The third form (‚Äúwhy‚Äù) is unique in that it does not displace and does not replace the first two.  Such comments explain the external factors that led to the writing of the code in its current form.  Often, without this context, it is difficult to understand why the code is written this way. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;v2.Cluster_CommonLbConfig{ <span class="hljs-comment"><span class="hljs-comment">//  HealthyPanicThreshold HealthyPanicThreshold: &amp;envoy_type.Percent{ Value: 0, }, }</span></span></code> </pre> <br>  In this example, it may not immediately be clear what happens when the HealthyPanicThreshold setting is zero percent.  The comment is intended to clarify that a value of 0 disables the panic threshold. <br><br><a name="3_1"></a><h2>  3.1.  Comments in variables and constants should describe their contents, not their purpose. </h2><br>  Earlier, I said that the name of a variable or constant should describe its purpose.  But a comment to a variable or constant must describe the <i>content</i> , not the <i>purpose</i> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randomNumber = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-comment"><span class="hljs-comment">//    </span></span></code> </pre> <br>  In this example, the comment describes <i>why</i> <code>randomNumber</code> assigned the value 6 and where it came from.  The comment does not describe where <code>randomNumber</code> will be used.  Here are some more examples: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( StatusContinue = <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-comment"><span class="hljs-comment">// RFC 7231, 6.2.1 StatusSwitchingProtocols = 101 // RFC 7231, 6.2.2 StatusProcessing = 102 // RFC 2518, 10.1 StatusOK = 200 // RFC 7231, 6.3.1</span></span></code> </pre> <br>  <i>In the context of HTTP, the</i> number <code>100</code> known as <code>StatusContinue</code> , which is defined in RFC 7231, section 6.2.1. <br><br><blockquote>  <b>Council</b>  For variables without an initial value, the comment should describe who is responsible for initializing this variable. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// sizeCalculationDisabled ,   //     . . dowidth. var sizeCalculationDisabled bool</span></span></code> </pre> <br>  Here the comment informs the reader that the <code>dowidth</code> function <code>dowidth</code> responsible for maintaining the state of <code>sizeCalculationDisabled</code> . </blockquote><br><blockquote>  <b>Council</b>  Hide in sight.  This is <a href="https://www.youtube.com/watch%3Fv%3DIc2y6w8lMPA">advice from Kate Gregory</a> .  Sometimes the best name for a variable is hidden in the comments. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   SQL var registry = make(map[string]*sql.Driver)</span></span></code> </pre> <br>  The comment was added by the author, because the name <code>registry</code> does not sufficiently explain its purpose - this is the registry, but what is the registry? <br><br>  If you rename a variable in sqlDrivers, it becomes clear that it contains SQL drivers. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sqlDrivers = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*sql.Driver)</code> </pre> <br>  Now the comment has become redundant and can be deleted. </blockquote><br><a name="3_2"></a><h2>  3.2.  Always document public symbols. </h2><br>  Your package documentation is generated by godoc, so you should add a comment to each public symbol declared in the package: variable, constant, function, and method. <br><br>  Here are two rules from the Google Style Guide: <br><br><ul><li>  Any public function that is not both obvious and concise should be commented. <br></li><li>  Any function in the library should be commented regardless of length or complexity. </li></ul><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ioutil <span class="hljs-comment"><span class="hljs-comment">// ReadAll   r      (EOF)   // ..    err == nil, not err == EOF. //  ReadAll     ,     //  . func ReadAll(r io.Reader) ([]byte, error)</span></span></code> </pre> <br>  There is one exception to this rule: no need to document methods that implement the interface.  Do not do this specifically: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Read   io.Reader func (r *FileReader) Read(buf []byte) (int, error)</span></span></code> </pre> <br>  This comment says nothing.  He does not say what the method does: worse, it sends somewhere to search for documentation.  In this situation, I propose to completely delete the comment. <br><br>  Here is an example from the <code>io</code> package. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// LimitReader  Reader,    r, //    EOF  n . //   *LimitedReader. func LimitReader(r Reader, n int64) Reader { return &amp;LimitedReader{r, n} } // LimitedReader   R,     //   N .   Read  N  //    . // Read  EOF,  N &lt;= 0    R  EOF. type LimitedReader struct { R Reader // underlying reader N int64 // max bytes remaining } func (l *LimitedReader) Read(p []byte) (n int, err error) { if lN &lt;= 0 { return 0, EOF } if int64(len(p)) &gt; lN { p = p[0:lN] } n, err = lRRead(p) lN -= int64(n) return }</span></span></code> </pre> <br>  Please note that the <code>LimitedReader</code> declaration is immediately preceded by the function that uses it, and the <code>LimitedReader.Read</code> declaration follows the <code>LimitedReader.Read</code> declaration itself.  Although <code>LimitedReader.Read</code> itself is not documented, but it can be understood that this is an implementation of <code>io.Reader</code> . <br><br><blockquote>  <b>Council</b>  Before writing a function, write a comment describing it.  If you find it difficult to write a comment, then this is a sign that the code you are going to write will be difficult to understand. </blockquote><br><h3>  3.2.1.  Don't comment bad code, rewrite it </h3><br><blockquote>  <i>‚ÄúDo not comment on the bad code - rewrite it‚Äù</i> - Brian Kernigan </blockquote><br>  It is not enough to indicate in the comments the difficulty of the code fragment.  If you are faced with one of these comments, you should start a ticket with a reminder of refactoring.  You can live with technical debt as long as its amount is known. <br><br>  In the standard library, it is customary to leave comments in the TODO style with the name of the user who noticed the problem. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// TODO(dfc)  O(N^2),     .</span></span></code> </pre> <br>  This is not an obligation to fix the problem, but the specified user may be the best person to contact with the question.  Other projects accompany TODO with date or ticket number. <br><br><h3>  3.2.2.  Instead of commenting the code, refactor it. </h3><br><blockquote>  <i>‚ÄúGood code is the best documentation.</i>  <i>When you are going to add a comment, ask yourself: ‚ÄúHow to improve the code so that this comment is not needed?‚Äù Refactor and leave the commentary to make it clearer. ‚Äù</i> - Steve McConnell </blockquote><br>  Functions should perform only one task.  If you want to write a comment, because some fragment is not connected with the rest of the function, then consider the possibility of extracting it into a separate function. <br><br>  Smaller functions are not only clearer, but they are easier to check separately from each other.  When you isolated the code into a separate function, its name can replace the comment. <br><br><a name="4"></a><h1>  4. Package structure </h1><br><blockquote>  <i>‚ÄúWrite modest code: modules that do not show anything extra to other modules and that do not rely on the implementations of other modules‚Äù</i> - <a href="https://twitter.com/codewisdom/status/1045305561317888000%3Fs%3D12">Dave Thomas</a> </blockquote><br>  Each package is essentially a separate, small Go program.  As the implementation of a function or method does not matter for the caller, the implementation of the functions, methods, and types that make up the public API of your package also does not matter. <br><br>  A good Go package tends to have minimal connectivity with other packages at the source code level so that as the project grows, changes in one package do not cascade across the entire code base.  Such situations greatly inhibit programmers working on this code base. <br><br>  In this section we will talk about package design, including its name and tips on writing methods and functions. <br><br><a name="4_1"></a><h2>  4.1.  A good package starts with a good name. </h2><br>   Go    .     ,    . <br><br> ,      ,    .         ,   : ¬´    ?¬ª     ¬´    X¬ª,  ¬´     HTTP¬ª. <br><br><blockquote>  <b>Council</b>      ,   . </blockquote><br><h3>  4.1.1.       </h3><br>       .    ,         .  ,      ,  : <br><br><ol><li>     . </li><li>       .       ,     . </li></ol><br><a name="4_2"></a><h2>  4.2.    <code>base</code> , <code>common</code>  <code>util</code> </h2><br>     ‚Äî   <i> </i> ,         .      .     ,       ,   <i></i> : . <br><br>   <code>utils</code>  <code>helpers</code>     ,      ,     .   -    ,  .         ,       -   . <br><br>     ,    <code>utils</code> <code>helpers</code> , ,  ,      .        ,  ,       . <br><br><blockquote> <i>¬´[]    ,   ¬ª</i> ‚Äî   </blockquote><br>       ,           ,       . <br><br><blockquote>  <b>Council</b>      . , <code>strings</code>    . </blockquote><br>     <code>base</code>  <code>common</code>  ,                   .  ,        ,   ,         ,   . <br><br> ,  <code>net/http</code>     <code>client</code>  <code>server</code> ,      <code>client.go</code>  <code>server.go</code>    ,   <code>transport.go</code>   . <br><br><blockquote>  <b>Council</b>  ,      . <br><br><ul><li>  <code>Get</code>   <code>net/http</code>  <code>http.Get</code>     . <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The type </font></font><code>Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of the package </font></font><code>strings</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when converted to other packages is converted to </font></font><code>strings.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The interface </font></font><code>Error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the package is </font></font><code>net</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clearly related to network errors.</font></font></li></ul></blockquote><br><a name="4_3"></a><h2>  4.3.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Come back quickly, without diving </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since Go does not use exceptions in the control flow, there is no need to dig deep into the code to provide a top-level structure for </font></font><code>try</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font><font style="vertical-align: inherit;">blocks </font></font><code>catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Instead of a multi-level hierarchy, the Go code goes down the screen as the function advances. </font><font style="vertical-align: inherit;">My friend Mat Ryer calls this practice a </font></font><a href="https://medium.com/%40matryer/line-of-sight-in-code-186dd7cdea88"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äúline of sight</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><a href="https://medium.com/%40matryer/line-of-sight-in-code-186dd7cdea88"><font style="vertical-align: inherit;">‚Äù </font></a></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is achieved with the help of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">boundary operators</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : conditional blocks with a precondition at the input to the function. </font><font style="vertical-align: inherit;">Here is an example from the package </font></font><code>bytes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *Buffer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnreadRune</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.lastRead &lt;= opInvalid { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(<span class="hljs-string"><span class="hljs-string">"bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.off &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) { b.off -= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) } b.lastRead = opInvalid <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Upon entering the function </font></font><code>UnreadRune</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the status is checked </font></font><code>b.lastRead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and if the previous operation was not </font></font><code>ReadRune</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, an error is immediately returned. The rest of the function works on the assumption that </font></font><code>b.lastRead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">more than </font></font><code>opInvalid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compare with the same function, but without the boundary operator:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *Buffer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnreadRune</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.lastRead &gt; opInvalid { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.off &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) { b.off -= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) } b.lastRead = opInvalid <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(<span class="hljs-string"><span class="hljs-string">"bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune"</span></span>) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The body of a more likely successful branch is embedded in the first condition </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and the condition for a successful exit </font></font><code>return nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">should be detected by carefully matching the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">closing</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> brackets. </font><font style="vertical-align: inherit;">The last line of the function now returns an error, and you need to track the execution of the function to the corresponding </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opening</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bracket to find out how to get to this point. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This option is harder to read, which degrades the quality of programming and code support, so Go prefers to use boundary operators and return errors at an early stage.</font></font><br><br><a name="4_4"></a><h2>  4.4.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Make a value of zero useful </font></font></h2><br>   ,    ,    ,    ,   <i></i> .      :    ‚Äî ,    ‚Äî nil,     ,   . <br><br>                    Go   .  ,      Go,  : ¬´    ¬ª. <br><br>   <code>sync.Mutex</code> ,     ,    .          <code>sync.Mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The code takes into account this fact, so that the type is suitable for use without explicit initialization.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { mu sync.Mutex val <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i MyInt <span class="hljs-comment"><span class="hljs-comment">// i.mu is usable without explicit initialisation. i.mu.Lock() i.val++ i.mu.Unlock() }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another example of a type with a useful zero value is </font></font><code>bytes.Buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">You can declare and start writing to it without explicit initialization.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b bytes.Buffer b.WriteString(<span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span>) io.Copy(os.Stdout, &amp;b) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The zero value of this structure means that </font></font><code>len</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">both </font></font><code>cap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are equal </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and y </font></font><code>array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a pointer to memory with the contents of the backup array of the slice, value </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This means that you do not need to explicitly make a cut, you can simply declare it.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// s := make([]string, 0) // s := []string{} var s []string s = append(s, "Hello") s = append(s, "world") fmt.Println(strings.Join(s, " ")) }</span></span></code> </pre> <br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><code>var s []string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">similar to the two commented lines above, but not identical to them. </font><font style="vertical-align: inherit;">There is a difference between the value of the slice, equal to nil, and the value of the slice, which has a zero length. </font><font style="vertical-align: inherit;">The following code will print false.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1 = []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2 []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> fmt.Println(reflect.DeepEqual(s1, s2)) }</code> </pre> </blockquote><br> ,        ‚Äî  nil ‚Äî      ,   nil.         . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Config <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { path <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"/usr/home"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.path } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c1 *Config <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c2 = &amp;Config{ path: <span class="hljs-string"><span class="hljs-string">"/export"</span></span>, } fmt.Println(c1.Path(), c2.Path()) }</code> </pre> <br><a name="4_5"></a><h2> 4.5.     </h2><br>           ‚Äî           ,      . <br><br>    ,      Go: <br><br><ol><li>     ,    . <br></li><li>   . </li></ol><br>  Go         ,     .   ,     ,         :   <i>  </i>      . <br><br>          ,            !  ,     ,        .  ,     ,   ,       . <br><br>   ,    : <br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Move the corresponding variables as fields to the structures that need them. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Use interfaces to reduce the relationship between behavior and the implementation of this behavior. </font></font></li></ol><br><a name="5"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5. Project structure </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's talk about how packages are combined into a project. </font><font style="vertical-align: inherit;">This is usually a single git repository. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Like a package, every project should have a clear goal. </font><font style="vertical-align: inherit;">If it is a library, it should do one thing, for example, parsing XML or logging. </font><font style="vertical-align: inherit;">You should not combine several goals in one project, it will help to avoid a terrible library </font></font><code>common</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><blockquote>  <b>Council</b>   ,  <code>common</code>        ,         (back-port fixes)    <code>common</code> ,      ,      ,     API. </blockquote><br>     (-,  Kubernetes  . .),         . ,    Kubernetes   <code>cmd/contour</code> ,    ,    Kubernetes,     . <br><br><a name="5_1"></a><h2>  5.1.  ,    </h2><br>  -       ,    Go   :    . <br><br> Go     :     ,   Java ( <code>public</code> , <code>protected</code> , <code>private</code>   <code>default</code> ).       ++. <br><br>  Go      :     ,      (/).   ,      ,        Go. <br><br><blockquote> <b></b> .     ¬´¬ª  ¬´ ¬ª   public  private. </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Given the limited access control options, which methods to use to avoid overly complex package hierarchies? </font></font><br><br><blockquote>  <b>Council</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In each package except </font></font><code>cmd/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">must contain the source code.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I have repeatedly repeated that it is better to prefer a smaller number of packets of a larger size. </font><font style="vertical-align: inherit;">Your default position should be to not create a new package. </font><font style="vertical-align: inherit;">This leads to the fact that too many types become publicly available, creating a wide and small area of ‚Äã‚Äãthe available API. </font><font style="vertical-align: inherit;">Below is discussed in more detail this thesis.</font></font><br><br><blockquote>  <b>Council</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Come with Java? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you come from the world of Java or C #, then remember the unspoken rule: a Java package is equivalent to one source file </font></font><code>.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The Go package is equivalent to the whole Maven module or .NET assembly.</font></font></blockquote><br><h3>  5.1.1.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Organize code by files using import instructions </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you order packages by services, should you do the same for the files in the package? </font><font style="vertical-align: inherit;">How to find out when to split one file </font></font><code>.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">into several? </font><font style="vertical-align: inherit;">How do I know that you have gone too far and need to think about merging files? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here are the recommendations that I use:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start each package with one file </font></font><code>.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Give this file the same name as the directory. </font><font style="vertical-align: inherit;">For example, the package </font></font><code>http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">should be in a file </font></font><code>http.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in a directory </font></font><code>http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As the package grows, you can divide various functions into several files. </font><font style="vertical-align: inherit;">For example, the file </font></font><code>messages.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will contain types </font></font><code>Request</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>Response</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, file </font></font><code>client.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- type </font></font><code>Client</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, file </font></font><code>server.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- type of server.</font></font><br></li><li>       ,    .  ,       . <br></li><li>        . , <code>messages.go</code>     HTTP-       , <code>http.go</code>      , <code>client.go</code>  <code>server.go</code> ‚Äî    HTTP     . </li></ul><br><blockquote>  <b>Council</b>      . </blockquote><br><blockquote> <b></b> .  Go    .      <i></i> ( ‚Äî      Go).           . </blockquote><br><h3>  5.1.2.     </h3><br>  <code>go</code>   <code>testing</code>   .     <code>http2</code> ,     <code>http2_test.go</code>     <code>http2</code> .    <code>http2_test.go</code> , <i> </i>    <code>http2</code> .       . <br><br>  <code>go</code>     ,    <i>test</i> ,   <code>http_test</code> . <i>         ,     ,       ,     .     ,      .    .</i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I recommend using internal tests for unit tests of a package. This allows you to test each function or method directly, avoiding the bureaucracy of external testing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">be sure</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to put into the external test file examples of test functions ( </font></font><code>Example</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). This ensures that when viewed in godoc, the examples will receive the appropriate package prefix and can be easily copied.</font></font><br><br><blockquote>  <b>Council</b>    ,     . <br><br>   ,    ,   Go      <code>go</code> . ,  <code>net/http</code>       <code>net</code> . <br><br>           <code>.go</code> , ,    . </blockquote><br><h3>  5.1.3.   ,     API </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If there are multiple packages in your project, you may find exported functions that are intended for use by other packages, but not for the public API. </font><font style="vertical-align: inherit;">In such a situation, the tool </font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recognizes a special folder name </font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that can be used to place code that is open to your project but closed to others. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To create such a package, place it in a directory with the name </font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or in its subdirectory. </font><font style="vertical-align: inherit;">When the team </font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sees the import package with the path </font></font><code>internal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it checks the location of the caller in the directory or subdirectory </font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, a package </font></font><code>.../a/b/c/internal/d/e/f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can import only a package from a directory tree </font></font><code>.../a/b/c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but not </font></font><code>.../a/b/g</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">any other repository (see</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><a name="5_2"></a><h2>  5.2.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Main package minimum size </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and package </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">should have minimal functionality, because it </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acts as a singleton: there can be only one function in the program </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, including tests. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since it </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is a singleton, there are many restrictions on the called objects: they are called only during </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>main.init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and only </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">once</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This makes it difficult to write tests for code </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Thus, one should strive to derive as much logic as possible from the main function and, ideally, from the main package.</font></font><br><br><blockquote>  <b>Council</b> <code>func main()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> must analyze the flags, open connections with databases, loggers, etc., and then transfer the execution to a high-level object. </font></font></blockquote><br><a name="6"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. API structure </font></font></h1><br>         . <br><br>   ,  ,   .       .        -. <br><br>   API,      ,      ,    :   ,    . <br><br>      API,       ,        . <br><br><a name="6_1"></a><h2>  6.1.  API,      </h2><br><blockquote> <i>¬´API          ¬ª</i> ‚Äî <a href="https://www.infoq.com/articles/API-Design-Joshua-Bloch"> </a> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Josh Bloch's advice is perhaps the most valuable in this article. </font><font style="vertical-align: inherit;">If the API is difficult to use for simple things, then each API call is more complicated than necessary. </font><font style="vertical-align: inherit;">When an API call is complex and non-obvious, it is likely to be overlooked.</font></font><br><br><h3>  6.1.1.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Be careful with functions that accept multiple parameters of the same type. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A good example of a simple at first glance, but difficult to use API, is when it requires two or more parameters of the same type. </font><font style="vertical-align: inherit;">Compare two function signatures:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to, from </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is the difference between these two functions? </font><font style="vertical-align: inherit;">Obviously, one returns a maximum of two numbers, and the other copies the file. </font><font style="vertical-align: inherit;">But this is not the main thing.</font></font><br><br><pre> <code class="go hljs">Max(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 10 Max(10, 8) // 10</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Max is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commutative</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : the order of the parameters does not matter. </font><font style="vertical-align: inherit;">A maximum of eight and ten is ten, regardless of whether eight is compared to ten or ten or eight. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But in the case of CopyFile it is not.</font></font><br><br><pre> <code class="go hljs">CopyFile(<span class="hljs-string"><span class="hljs-string">"/tmp/backup"</span></span>, <span class="hljs-string"><span class="hljs-string">"presentation.md"</span></span>) CopyFile(<span class="hljs-string"><span class="hljs-string">"presentation.md"</span></span>, <span class="hljs-string"><span class="hljs-string">"/tmp/backup"</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Which of these operators will back up your presentation, and which one will overwrite it with the version of last week? </font><font style="vertical-align: inherit;">You cannot tell until you check the documentation. </font><font style="vertical-align: inherit;">In the course of code review, it is not clear whether the order of the arguments is correct or not. </font><font style="vertical-align: inherit;">Again, you need to look in the documentation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One possible solution is the introduction of an auxiliary type responsible for the correct call </font></font><code>CopyFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Source <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src Source)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dest </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CopyFile(dest, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(src)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> from Source = <span class="hljs-string"><span class="hljs-string">"presentation.md"</span></span> from.CopyTo(<span class="hljs-string"><span class="hljs-string">"/tmp/backup"</span></span>) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is </font></font><code>CopyFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">always called correctly here - this can be asserted using a unit test - and can be made private, which further reduces the likelihood of incorrect use.</font></font><br><br><blockquote>  <b>Council</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> An API with several parameters of the same type is difficult to use correctly. </font></font></blockquote><br><a name="6_2"></a><h2>  6.2.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Design an API for the main use case. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A few years ago, I gave a </font></font><a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">talk</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on the use of </font></font><a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">functional options</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to make the API easier by default. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The essence of the presentation was that an API should be developed for the main use case. </font><font style="vertical-align: inherit;">In other words, the API should not require the user to provide extra parameters that do not interest him.</font></font><br><br><h3>  6.2.1.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It is not recommended to use nil as a parameter. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I began by saying that you should not force the user to provide API parameters that do not interest him. </font><font style="vertical-align: inherit;">This means </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">designing APIs for the main use case</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (the default). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is an example from the net / http package.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> http <span class="hljs-comment"><span class="hljs-comment">// ListenAndServe listens on the TCP network address addr and then calls // Serve with handler to handle requests on incoming connections. // Accepted connections are configured to enable TCP keep-alives. // // The handler is typically nil, in which case the DefaultServeMux is used. // // ListenAndServe always returns a non-nil error. func ListenAndServe(addr string, handler Handler) error {</span></span></code> </pre> <br> <code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It takes two parameters: a TCP address to listen for incoming connections and </font></font><code>http.Handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to process an incoming HTTP request. </font></font><code>Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allows the second parameter to be </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The comments indicate that usually the caller </font><font style="vertical-align: inherit;">will </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">actually</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pass </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which indicates a desire to use </font></font><code>http.DefaultServeMux</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as an implicit parameter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now the caller </font></font><code>Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">has two ways to do the same.</font></font><br><br><pre> <code class="go hljs">http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, http.DefaultServeMux)</code> </pre> <br>       . <br><br>   <code>nil</code>   .   <code>http</code>    <code>http.Serve</code> ,        <code>ListenAndServe</code> : <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListenAndServe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, handler Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { l, err := net.Listen(<span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, addr) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> l.Close() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Serve(l, handler) }</code> </pre> <br>  <code>ListenAndServe</code>    <code>nil</code>   , <code>http.Serve</code>    .   ,   <code>http.Serve</code>   ¬´   <code>nil</code> ,  <code>DefaultServeMux</code> ¬ª.  <code>nil</code>        ,    <code>nil</code>   .   <code>Serve</code> <br><br><pre> <code class="go hljs">http.Serve(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br>    . <br><br><blockquote>  <b>Council</b>        <code>nil</code>   <code>nil</code> . </blockquote><br>  <code>http.ListenAndServe</code>     API   ,   . <br><br>   <code>nil</code>           <code>DefaultServeMux</code> . <br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> root = http.Dir(<span class="hljs-string"><span class="hljs-string">"/htdocs"</span></span>) http.Handle(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, http.FileServer(root)) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br>    <br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> root = http.Dir(<span class="hljs-string"><span class="hljs-string">"/htdocs"</span></span>) http.Handle(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, http.FileServer(root)) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, http.DefaultServeMux)</code> </pre> <br>         ? <br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> root = http.Dir(<span class="hljs-string"><span class="hljs-string">"/htdocs"</span></span>) mux := http.NewServeMux() mux.Handle(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, http.FileServer(root)) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux)</code> </pre> <br><blockquote>  <b>Council</b>  ,      .  ,  . </blockquote><br><blockquote>  <b>Council</b>   API-  ,     .     ,    ,  ,      . </blockquote><br><h3>  6.2.2.       []T </h3><br>        . <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShutdownVMs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ids []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span></code> </pre> <br>    ,     .   ,    ,         .   ,       ,    ¬´¬ª  ,     . <br><br>  ,   <code>ids</code>  ,        ,    .     ,      . <br><br>      API,     ,      ,       .    : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> svc.MaxConnections &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || svc.MaxPendingRequests &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || svc.MaxRequests &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || svc.MaxRetries &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-comment"><span class="hljs-comment">// apply the non zero parameters }</span></span></code> </pre> <br>   <code>if</code>   ,        .    : <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// anyPostive indicates if any value is greater than zero. func anyPositive(values ...int) bool { for _, v := range values { if v &gt; 0 { return true } } return false }</span></span></code> </pre> <br>     ,      : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> anyPositive(svc.MaxConnections, svc.MaxPendingRequests, svc.MaxRequests, svc.MaxRetries) { <span class="hljs-comment"><span class="hljs-comment">// apply the non zero parameters }</span></span></code> </pre> <br>     <code>anyPositive</code> , -     : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> anyPositive() { ... }</code> </pre> <br>    <code>anyPositive</code>  <code>false</code> .     . ,   <code>anyPositive</code>  <code>true</code>   . <br><br>   ,       anyPositive,        .              (varargs): <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// anyPostive indicates if any value is greater than zero. func anyPositive(first int, rest ...int) bool { if first &gt; 0 { return true } for _, v := range rest { if v &gt; 0 { return true } } return false }</span></span></code> </pre> <br>  <code>anyPositive</code>       . <br><br><a name="6_3"></a><h2>  6.3.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let functions define the desired behavior. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose I was given the task to write a function that preserves the structure </font></font><code>Document</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on disk.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      f. func Save(f *os.File, doc *Document) error</span></span></code> </pre> <br>      <code>Save</code> ,   <code>Document</code>   <code>*os.File</code> .    . <br><br>  <code>Save</code>      .      ,    ,      . <br><br> <code>Save</code>   ,         .  ,    ,       . <br><br>    ,  <code>f</code>       . <br><br> <code>*os.File</code>    ,      <code>Save</code> , ,    ,     . ,    <code>Save</code>     <code>*os.File</code> . <br><br>  What can be done? <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      // ReadWriterCloser. func Save(rwc io.ReadWriteCloser, doc *Document) error</span></span></code> </pre> <br>   <code>io.ReadWriteCloser</code>      ‚Äî   <code>Save</code>  ,      . <br><br>     ,    <code>io.ReadWriteCloser</code> ,     <code>*os.File</code> . <br><br>       <code>Save</code> ,    ,    <code>*os.File</code>     . <br><br>   <code>Save</code>         <code>*os.File</code> ,      <code>io.ReadWriteCloser</code> . <br><br>         . <br><br> -,  <code>Save</code>    ,      ,    ,     ‚Äî     . <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      // WriteCloser. func Save(wc io.WriteCloser, doc *Document) error</span></span></code> </pre> <br>       <code>Save</code>    . <br><br> -,     <code>Save</code>    ,     .  ,    <code>wc</code>  . <br><br>   <code>Save</code>  <code>Close</code> ,     . <br><br>      ,            . <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      // Writer. func Save(w io.Writer, doc *Document) error</span></span></code> </pre> <br>   ‚Äî  Save     <code>io.Writer</code> ,      ,     . <br><br>                (   ,   ),       ,      <code>Save</code>     ,   <code>io.Writer</code> . <br><br><a name="7"></a><h1> 7.   </h1><br>   <a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully"> </a>  <a href="https://dave.cheney.net/2014/12/24/inspecting-errors"></a> <a href="https://dave.cheney.net/2016/04/07/constant-errors"></a>     ,    . <br><br>        ,    . <br><br><a name="7_1"></a><h2>  7.1.    ,    </h2><br>         ,     ‚Äî    . <br><br><blockquote> <b></b> .    ¬´  ¬ª.    ,      . </blockquote><br>           <a href="https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201">¬´   ¬ª</a> .     ¬´   ¬ª.    . <br><br><h3> 7.1.1.   </h3><br>        . <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountLines</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( br = bufio.NewReader(r) lines <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err error ) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { _, err = br.ReadString(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) lines++ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != io.EOF { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lines, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>       , <code>CountLines</code>  <code>io.Reader</code> ,   <code>*os.File</code> ;       <code>io.Reader</code> ,     . <br><br>   <code>bufio.Reader</code> ,       <code>ReadString</code> ,  ,      ,     . <br><br>   ,     ,     . ,    : <br><br><pre> <code class="go hljs"> _, err = br.ReadString(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) lines++ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> }</code> </pre> <br>     <i></i>   ‚Äî   . <br><br> ,        ,  ,  <code>ReadString</code>  ,     ,    .   ,       . <br><br>    ,    ,   ,     . <br><br><blockquote> <b></b> .      ,   ? </blockquote><br>       . <code>ReadString</code>  <code>io.EOF</code> ,    .   ,    <code>ReadString</code>   -   ¬´,   ¬ª. ,       <code>CountLine</code> ,  ,      <code>io.EOF</code> ,     ,      <code>nil</code>  ,   . <br><br> ,        ,       .    . <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountLines</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { sc := bufio.NewScanner(r) lines := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sc.Scan() { lines++ } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lines, sc.Err() }</code> </pre> <br>     <code>bufio.Scanner</code>  <code>bufio.Reader</code> . <br><br>   <code>bufio.Scanner</code>  <code>bufio.Reader</code> ,     ,     . <br><br><blockquote> <b></b> . <code>bufio.Scanner</code>    ,      . </blockquote><br>  <code>sc.Scan()</code>   <code>true</code> ,        .  ,   <code>for</code>         .  ,   <code>CountLines</code>   ,        . <br><br> -,  <code>sc.Scan</code>  <code>false</code>   ,  <code>for</code>        .  <code>bufio.Scanner</code>   ,   ,     <code>sc.Err()</code>     ,     . <br><br> , <code>sc.Err()</code>    <code>io.EOF</code>     <code>nil</code> ,      . <br><br><blockquote>  <b>Council</b>      ,       . </blockquote><br><h3> 7.1.2. WriteResponse </h3><br>      <a href="https://blog.golang.org/errors-are-values">¬´ ‚Äî  ¬ª</a> . <br><br>    ,   ,   .   ,     ,      ,   <code>ioutil.ReadFile</code>  <code>ioutil.WriteFile</code> .                -.        .    HTTP-,   HTTP-. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Header <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Key, Value <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Status <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Code <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Reason <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, st Status, headers []Header, body io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := fmt.Fprintf(w, <span class="hljs-string"><span class="hljs-string">"HTTP/1.1 %d %s\r\n"</span></span>, st.Code, st.Reason) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, h := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> headers { _, err := fmt.Fprintf(w, <span class="hljs-string"><span class="hljs-string">"%s: %s\r\n"</span></span>, h.Key, h.Value) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _, err := fmt.Fprint(w, <span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } _, err = io.Copy(w, body) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br>       <code>fmt.Fprintf</code>   .         ,    . ,     <code>\r\n</code> ,       . ,        <code>io.Copy</code> ,         ,   <code>WriteResponse</code> . <br><br>    .     ,     <code>errWriter</code> . <br><br> <code>errWriter</code>   <code>io.Writer</code> ,      . <code>errWriter</code>       .          . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> errWriter <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { io.Writer err error } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *errWriter)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e.err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, e.err } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, e.err = e.Writer.Write(buf) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, st Status, headers []Header, body io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { ew := &amp;errWriter{Writer: w} fmt.Fprintf(ew, <span class="hljs-string"><span class="hljs-string">"HTTP/1.1 %d %s\r\n"</span></span>, st.Code, st.Reason) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, h := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> headers { fmt.Fprintf(ew, <span class="hljs-string"><span class="hljs-string">"%s: %s\r\n"</span></span>, h.Key, h.Value) } fmt.Fprint(ew, <span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>) io.Copy(ew, body) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ew.err }</code> </pre> <br>   <code>errWriter</code>  <code>WriteResponse</code> ,     .         .           <code>ew.err</code> ,       io.Copy. <br><br><a name="7_2"></a><h2>  7.2.     </h2><br> ,   ,       .        <i></i> . <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// WriteAll writes the contents of buf to the supplied writer. func WriteAll(w io.Writer, buf []byte) { w.Write(buf) }</span></span></code> </pre> <br>      ,   .    ,   <code>w.WriteAll</code> . <br><br>   <i> </i>        .  ,     . <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := w.Write(buf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Println(<span class="hljs-string"><span class="hljs-string">"unable to write:"</span></span>, err) <span class="hljs-comment"><span class="hljs-comment">// annotated error goes to log file return err // unannotated error returned to caller } return nil }</span></span></code> </pre> <br>   ,      <code>w.Write</code> ,     ,     , , ,        ,     . <br><br>  ,      : <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, conf *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf, err := json.Marshal(conf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"could not marshal config: %v"</span></span>, err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := WriteAll(w, buf); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Println(<span class="hljs-string"><span class="hljs-string">"could not write config: %v"</span></span>, err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  ,      . <br><br><pre> <code class="go hljs">unable to write: io.EOF could not write config: io.EOF</code> </pre> <br>           - . <br><br><pre> <code class="go hljs">err := WriteConfig(f, &amp;conf) fmt.Println(err) <span class="hljs-comment"><span class="hljs-comment">// io.EOF</span></span></code> </pre> <br>      ,                . <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, conf *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf, err := json.Marshal(conf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"could not marshal config: %v"</span></span>, err) <span class="hljs-comment"><span class="hljs-comment">// oops, forgot to return } if err := WriteAll(w, buf); err != nil { log.Println("could not write config: %v", err) return err } return nil }</span></span></code> </pre> <br>     ,      .     ,  Go     ,          . <br><br>      ,  ,  <i></i> . -    . <br><br>      Go ,             .   JSON  ,  <code>buf</code> : ,    ,  ,        JSON. <br><br>         ,     <code>WriteAll</code> . ,   ,       .    ,    ,    ‚Äî   ,     JSON,     . <br><br><h3> 7.2.1.     </h3><br>  ,          .    ,     . <br><br>          <code>fmt.Errorf</code> . <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, conf *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf, err := json.Marshal(conf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"could not marshal config: %v"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := WriteAll(w, buf); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"could not write config: %v"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := w.Write(buf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"write failed: %v"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>         ,        . <br><br>       -,  <code>Error()</code>  - : <br><br><pre> <code class="go hljs">could not write config: write failed: input/output error</code> </pre> <br><h3> 7.2.2.    github.com/pkg/errors </h3><br>  <code>fmt.Errorf</code>     <i></i>  ,  <i></i>     .  ,         <i> </i> ,        ,        : <br><br><ol><li> ,     . <br></li><li>        . </li></ol><br>  ,     .       -    <code>errors</code> : <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { f, err := os.Open(path) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"open failed"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> f.Close() buf, err := ioutil.ReadAll(f) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"read failed"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buf, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { home := os.Getenv(<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>) config, err := ReadFile(filepath.Join(home, <span class="hljs-string"><span class="hljs-string">".settings.xml"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> config, errors.WithMessage(err, <span class="hljs-string"><span class="hljs-string">"could not read config"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { _, err := ReadConfig() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } }</code> </pre> <br>        K&amp;D: <br><br><pre> <code class="go hljs">could not read config: open failed: open /Users/dfc/.settings.xml: no such file or directory</code> </pre> <br>        . <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { _, err := ReadConfig() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"original error: %T %v\n"</span></span>, errors.Cause(err), errors.Cause(err)) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"stack trace:\n%+v\n"</span></span>, err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } }</code> </pre> <br>  ,        : <br><br><pre> <code class="plaintext hljs">original error: *os.PathError open /Users/dfc/.settings.xml: no such file or directory stack trace: open /Users/dfc/.settings.xml: no such file or directory open failed main.ReadFile /Users/dfc/devel/practical-go/src/errors/readfile2.go:16 main.ReadConfig /Users/dfc/devel/practical-go/src/errors/readfile2.go:29 main.main /Users/dfc/devel/practical-go/src/errors/readfile2.go:35 runtime.main /Users/dfc/go/src/runtime/proc.go:201 runtime.goexit /Users/dfc/go/src/runtime/asm_amd64.s:1333 could not read config</code> </pre> <br>  <code>errors</code>            ,   .     ,     Go      . <br><br><a name="8"></a><h1> 8.  </h1><br>  Go   -   .   ,     (    )  ,    Go      ,     ,  .       ,        Go. <br><br>     Go  ,    <code>select</code>  <code>go</code> .     Go     ,   ,          .     :       ,   -    ,     Go. <br><br>    ,    Go ‚Äî  ,   .  ,          .   ,         ,           ,          . <br><br>            Go. <br><br><a name="8_1"></a><h2>  8.1.   -  </h2><br>      ? <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { } }</code> </pre> <br>   ,   :   -.           ,   <code>for{}</code>    <code>main</code>  - main,     -,   ,      -   . <br><br>    Go   ,                 (live-lock). <br><br>   ?   . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"runtime"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { runtime.Gosched() } }</code> </pre> <br>    ,    ,      .     . <br><br>       Go,   -  . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }() <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> {} }</code> </pre> <br>   <code>select</code>  .  ,            <code>runtime.GoSched()</code> .     ,   . <br><br>      , , ,     .  ,   <code>http.ListenAndServe</code>  -,   - main,   <code>http.ListenAndServe</code>   -. <br><br><blockquote>  <b>Council</b>     <code>main.main</code> ,   Go     ,    -,     . </blockquote><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }</code> </pre> <br>      :  -    ,      ,      ,    . <br><br>         ,       -   . <br><br><blockquote>  <b>Council</b>   Go  -,  .      ,     . </blockquote><br><a name="8_2"></a><h2>  8.2.     </h2><br>       API? <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// ListDirectory returns the contents of dir. func ListDirectory(dir string) ([]string, error)</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// ListDirectory returns a channel over which // directory entries will be published. When the list // of entries is exhausted, the channel will be closed. func ListDirectory(dir string) chan string</span></span></code> </pre> <br>   :      ,       ,  -   .   ,   <code>ListDirectory</code> ,      .    ,   ,         . <br><br>   .        Go,  <code>ListDirectory</code>  ,      .   ,   ,     .       <code>ListDirectory</code> ,     -   . <br><br><blockquote> <b></b> .       -:   ,        ,  , ,      .   ,                    . </blockquote><br>   <code>ListDirectory</code>      : <br><br><ul><li>      ,      , <code>ListDirectory</code>          - .            .   , ,    . <br></li><li>      ,   ,      ,  -    .      <code>ListDirectory</code> :       ,      . ,             ,    ,      . </li></ul><br>          : ,          . <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListDirectory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, fn </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br>    <code>filepath.WalkDir</code>   . <br><br><blockquote>  <b>Council</b>     -,         .          . </blockquote><br><a name="8_3"></a><h2>  8.3.    -,  ,    </h2><br>    -   .      Go ‚Äî   . ,       ,     -. <br><br>     http-    :  8080      8001      <code>/debug/pprof</code> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> _ <span class="hljs-string"><span class="hljs-string">"net/http/pprof"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux) <span class="hljs-comment"><span class="hljs-comment">// debug http.ListenAndServe("0.0.0.0:8080", mux) // app traffic }</span></span></code> </pre> <br>   ,    . <br><br>         ,      ,       . <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveDebug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> serveDebug() serveApp() }</code> </pre> <br>   <code>serveApp</code>  <code>serveDebug</code>   ,     <code>main.main</code> .       ,  <code>serveApp</code>  <code>serveDebug</code>       . <br><br>        .     <code>serveApp</code> ,    <code>main.main</code> ,         . <br><br><blockquote>  <b>Council</b>    Go    ,              ,   .         :      . </blockquote><br>  <code>serveDebug</code>    -,      - ,        .    ,     ,    <code>/debug</code>   . <br><br>      ,   <i></i> -,  . <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveDebug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> serveDebug() <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> serveApp() <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> {} }</code> </pre> <br>  <code>serverApp</code>  <code>serveDebug</code>    <code>ListenAndServe</code>      <code>log.Fatal</code> .      -,      <code>select{}</code> . <br><br>     : <br><br><ol><li>  <code>ListenAndServe</code>    <code>nil</code> ,     <code>log.Fatal</code> ,   HTTP        . <br></li><li> <code>log.Fatal</code>  <code>os.Exit</code> ,     ;    ,  -      ,   .       . </li></ol><br><blockquote>  <b>Council</b>   <code>log.Fatal</code>   <code>main.main</code>  <code>init</code> . </blockquote><br>           -,    ,   ,    . <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveDebug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { done := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> error, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { done &lt;- serveDebug() }() <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { done &lt;- serveApp() }() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>(done); i++ { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := &lt;-done; err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"error: %v"</span></span>, err) } } }</code> </pre> <br>   -    .     -,    ,      <code>done</code>   ,      -   . <br><br>   <code>done</code>    ,         <code>for range</code> ,     -.         -,    . <br><br>          -    ,    .          -  . <br><br>      <code>http.Server</code>   ,        .  <code>serve</code>    <code>http.Handler</code> ,  <code>http.ListenAndServe</code> ,    <code>stop</code> ,       <code>Shutdown</code> . <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, handler http.Handler, stop &lt;-</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { s := http.Server{ Addr: addr, Handler: handler, } <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { &lt;-stop <span class="hljs-comment"><span class="hljs-comment">// wait for stop signal s.Shutdown(context.Background()) }() return s.ListenAndServe() } func serveApp(stop &lt;-chan struct{}) error { mux := http.NewServeMux() mux.HandleFunc("/", func(resp http.ResponseWriter, req *http.Request) { fmt.Fprintln(resp, "Hello, QCon!") }) return serve("0.0.0.0:8080", mux, stop) } func serveDebug(stop &lt;-chan struct{}) error { return serve("127.0.0.1:8001", http.DefaultServeMux, stop) } func main() { done := make(chan error, 2) stop := make(chan struct{}) go func() { done &lt;- serveDebug(stop) }() go func() { done &lt;- serveApp(stop) }() var stopped bool for i := 0; i &lt; cap(done); i++ { if err := &lt;-done; err != nil { fmt.Println("error: %v", err) } if !stopped { stopped = true close(stop) } } }</span></span></code> </pre> <br>       <code>done</code>    <code>stop</code> ,    -      <code>http.Server</code> .   ,        - <code>ListenAndServe</code> .    - , <code>main.main</code>     . <br><br><blockquote>  <b>Council</b>     ‚Äî      .   -  <a href="https://github.com/heptio/workgroup"> </a> ,     √≥  . </blockquote></div><p>Source: <a href="https://habr.com/ru/post/441842/">https://habr.com/ru/post/441842/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441828/index.html">Cashing cryptocurrency in the Russian Federation fell under the Criminal Code</a></li>
<li><a href="../441830/index.html">Kibana User Guide. Visualization. Part 4</a></li>
<li><a href="../441832/index.html">Who is the project manager according to the business owner and how to deal with it</a></li>
<li><a href="../441834/index.html">Do not hire. And what if it is you?</a></li>
<li><a href="../441840/index.html">Because of software bugs, Lime scooters sometimes block the front wheel at maximum speed.</a></li>
<li><a href="../441844/index.html">iRobot Scooba: experience of using and solving common problems of a washing robot vacuum cleaner</a></li>
<li><a href="../441850/index.html">Guessing on neural networks: whether the author himself noted in the comments to the post</a></li>
<li><a href="../441854/index.html">REST? Take a dumb JSON-RPC</a></li>
<li><a href="../441866/index.html">Everything (Well, almost) about video cards. Part 1</a></li>
<li><a href="../441868/index.html">Why the brain needs to be given a "break"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>