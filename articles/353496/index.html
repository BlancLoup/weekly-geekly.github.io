<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introducing reactive threads - for Java developers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 Today we will return to one of the topics covered in our wonderful book " Reactive Design Patterns ". We will talk about Akka Streams and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introducing reactive threads - for Java developers</h1><div class="post__text post__text-html js-mediator-article"> Hi, Habr! <br><br>  Today we will return to one of the topics covered in our wonderful book " <a href="https://www.piter.com/product_by_id/95693187">Reactive Design Patterns</a> ".  We will talk about Akka Streams and streaming data in general - in the book of Roland Kuhn, chapters 10 and 15-17 are devoted to these issues. <br><a name="habracut"></a><br>  <a href="http://www.reactive-streams.org/">Reactive streams</a> are a standard way to asynchronously process data in streaming style.  They were <a href="https://www.lightbend.com/blog/update-release-reactive-streams-1-0-1-and-jdk9">included in Java 9</a> as <code>java.util.concurrent.Flow</code> interfaces, and are now becoming a real lifesaver for creating streaming components in various applications ‚Äî and this arrangement will continue over the coming years.  It should be noted that reactive streams are ‚Äújust‚Äù standard, and by themselves they are not suitable for anything.  In practice, one or another specific implementation of this standard is used, and today we will talk about Akka Streams - one of the leading implementations of reactive flows since their inception. <br><br>  <b>Context</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A typical stream processing pipeline consists of several steps, each of which carries information to the next step (that is, in descending order).  So, if you take two adjacent steps and consider the upstream supplier, and the next one - the data consumer, it turns out that the supplier can work either slower or faster than the consumer.  When the supplier is slower, everything is fine, but the situation is complicated if the consumer does not keep up with the supplier.  In this case, the consumer may overflow with the data that he has to (moderately force) carefully process. <br><br>  The simplest way to handle excess data is to pick up and drop everything that cannot be processed.  This is exactly what they do, for example, when working with network equipment.  But what if we don‚Äôt want to discard anything at all?  Then we can use back pressure (backpressure) <br><br>  The idea of ‚Äã‚Äãback pressure is very important in the context of Reactive Streams and boils down to the fact that we limit the amount of data transmitted between adjacent links of the conveyor, so no link is full.  Since the most important aspect of the reactive approach is to avoid blocking unless absolutely necessary, the implementation of back pressure in the reactive flow must also be non-blocking. <br><br>  <b>How it's done</b> <br><br>  The Reactive Streams standard defines a number of interfaces, but not an implementation as such.  This means that by simply adding a dependency to org.reactivestreams: reactive-streams, we are just marking time ‚Äî we still need a concrete implementation.  There are many implementations of Reactive Streams, and in this article we will use <a href="https://doc.akka.io/docs/akka/current/stream/index.html%3Flanguage%3Djava">Akka Streams and the corresponding Java-based DSL</a> .  Other implementations include <a href="https://github.com/ReactiveX/RxJava">RxJava 2.x</a> or <a href="https://projectreactor.io/">Reactor</a> and others. <br><br>  <b>Usage example</b> <br><br>  Suppose we have a directory in which we want to track new CSV files, then each file is streamlined, some aggregation is performed on the fly, and the results collected in this way are sent to a web socket (in real time).  In addition, we want to set a certain threshold for the accumulation of aggregated data, upon reaching which an email notification will be initiated. <br><br>  In our example, the CSV lines will have pairs ( <code>id</code> , <code>value</code> ), and the <code>id</code> will change every two lines, for example: <br><br> <code>370582,0.17870700247256666 <br> 370582,0.5262255382633264 <br> 441876,0.30998025265909457 <br> 441876,0.3141591265785087 <br> 722246,0.7334219632071504 <br> 722246,0.5310146239777006</code> <br> <br>  We want to calculate the average value for two strings with a common id and send it to a web socket only if it exceeds 0.9.  Moreover, we want to send an email notification after every fifth value that arrives on a web socket.  Finally, we want to read and display data obtained from a web socket, and this will be done through a trivial frontend written in JavaScript. <br><br>  <b>Architecture</b> <br><br>  We are going to use a number of tools from the Akka ecosystem (see Figure 1).  Naturally, Akka Streams will be in the center of the entire system, which allows you to process data in real time on a streaming basis.  We will use <a href="https://developer.lightbend.com/docs/alpakka/current/">Alpakka</a> to read CSV files, this is a set of connectors for integrating Akka Streams with various technologies, protocols or libraries.  Interestingly, since Akka Streams are jet streams, the entire Alpakka ecosystem is also available for any other RS ‚Äã‚Äãimplementations ‚Äî it is this interoperability gain that RS interfaces are designed to achieve.  Finally, we will use Akka HTTP, which will provide the end point of the web socket.  The most pleasant thing in this case is that Akka HTTP seamlessly integrates with Akka Streams (which, in fact, uses it under the hood), so it‚Äôs easy to provide a stream as a web socket. <br><br><img src="https://habrastorage.org/webt/uk/kn/1i/ukkn1igjwv9jhhaegqy0ik-kyiw.png"><br><br>  <i>Fig.</i>  <i>1. Architecture Overview</i> <br><br>  If we compare this scheme with the classical architecture of Java EE, it is probably noticeable that everything here is much simpler.  No containers and bins, but only a simple standalone application.  Moreover, the Java EE stack does not support the stream approach at all. <br><br>  <b>Basics of Akka Streams</b> <br><br>  In Akka Streams, the processing pipeline (graph) consists of elements of three types <code>Source</code> (source), <code>Sink</code> (catcher) and Flows (processing steps). <br><br>  Based on these components, we define our graph, which, in essence, is just a recipe for data processing.  No calculations are made there.  In order for the pipeline to work, we need to materialize the graph, that is, to bring it into a launchable form.  To do this, you will need a so-called materializer that optimizes the definition of the graph and, ultimately, launches it.  However, the built-in ActorMaterializer is virtually uncontested, so you are unlikely to use any other implementation. <br>  If you look closely at the parameters of the component types, it is noticeable that each component (except for the corresponding types of I / O) is of the mysterious type Mat.  It refers to the so-called ‚Äúmaterialized value‚Äù - this value is accessible from the outside of the graph (as opposed to input / output types, available only for internal communication between the steps of the graph - see Fig. 2).  If you prefer to ignore the materialized value (and this often happens if we are only interested in data transfer between the steps of the graph), then to indicate this option there is a special parameter of the type: <code>NotUsed</code> .  It can be compared to <code>Void</code> from Java, however, semantically it is a little more loaded: in the sense of meaning, ‚Äúwe do not use this meaning‚Äù is more informative than <code>Void</code> .  Also note that some APIs use a similar type of Done, signaling that a task has been completed.  Perhaps the other Java libraries in both of these cases would use <code>Void</code> , but in Akka Streams all types try to fill up the maximum with useful semantics. <br><br><img src="https://habrastorage.org/webt/kk/c1/7e/kkc17egtgiyydi_-arpaagm2fu0.png"><br><br>  <i>Fig.</i>  <i>2. Description of Flow Type Parameters</i> <br><br>  <b>application</b> <br><br>  Now let's move on to a specific implementation of a CSV handler.  First, we define the Akka Streams graph, and then, using the Akka HTTP protocol, we will connect the stream to a web socket. <br><br>  <b>Components of a stream conveyor</b> <br><br>  At the input point of our streaming pipeline, we want to track whether new CSV files have appeared in the directory of interest to us.  I would like to use <code>java.nio.file.WatchService</code> for this, but since we have a streaming application, you need to get an event source ( <code>Source</code> ) and work with it, and not organize everything through callbacks.  Fortunately, such a Source is already available in Alpakka in the form of one of the <code>DirectoryChangesSource</code> connectors, part of the <code>alpakka-file</code> , where <code>WatchService</code> used "under the hood": <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Source&lt;Pair&lt;Path, DirectoryChange&gt;, NotUsed&gt; newFiles = DirectoryChangesSource.create(DATA_DIR, DATA_DIR_POLL_INTERVAL, <span class="hljs-number"><span class="hljs-number">128</span></span>);</code> </pre> <br>  So we get the source, giving us the type of the <code>Pair&lt;Path, DirectoryChange&gt;</code> .  We are going to filter them so that we only select new CSV files and then transfer them down.  For such data conversion, as well as for all subsequent ones, we will use small elements called Flow, from which then a complete processing pipeline will be formed: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Flow&lt;Pair&lt;Path, DirectoryChange&gt;, Path, NotUsed&gt; csvPaths = Flow.&lt;Pair&lt;Path, DirectoryChange&gt;&gt;create() .filter(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::isCsvFileCreationEvent) .map(Pair::first); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isCsvFileCreationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pair&lt;Path, DirectoryChange&gt; p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.first().toString().endsWith(<span class="hljs-string"><span class="hljs-string">".csv"</span></span>) &amp;&amp; p.second().equals(DirectoryChange.Creation); }</code> </pre> <br>  You can create <code>Flow</code> , for example, using the generic <code>create()</code> method ‚Äî it is useful when the input type itself is generic.  Here, the resulting stream will generate (in the form of <code>Path</code> ) each new CSV file appearing in <code>DATA_DIR</code> . <br><br>  Now we are going to convert Paths to strings chosen from each file.  To turn a source into another source, you can use one of the <code>flatMap*</code> methods.  In both cases, we create a <code>Source</code> from each incoming element and in some way combine several resulting sources into a new one-piece one, linking or merging the original sources.  In this case, we will focus on <code>flatMapConcat</code> , since we want to preserve the order of the rows, so that the rows with the same <code>id</code> remain next to each other.  To convert the <code>Path</code> to a stream of bytes, use the built-in <code>FileIO</code> utility: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Flow&lt;Path, ByteString, NotUsed&gt; fileBytes = Flow.of(Path.class).flatMapConcat(FileIO::fromPath);</code> </pre> <br>  This time we will use the <code>of()</code> method to create a new stream ‚Äî it is convenient when the input type is not generic. <br><br>  The above <code>ByteString</code> is a byte sequence representation accepted in Akka Streams.  In this case, we want to parse the byte stream as a CSV file - and for this we use again one of the Alpakka modules, this time <code>alpakka-csv</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Flow&lt;ByteString, Collection&lt;ByteString&gt;, NotUsed&gt; csvFields = Flow.of(ByteString.class).via(CsvParsing.lineScanner());</code> </pre> <br>  Pay attention to the <code>via</code> combinator used here, which allows you to attach an arbitrary <code>Flow</code> to the output obtained in another step of the graph ( <code>Source</code> or another <code>Flow</code> ).  The result is a stream of elements, each of which corresponds to a field in a single line of the CSV file.  Then they can be transformed into a model of our subject area: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reading</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> value; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id = id; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> String.format(<span class="hljs-string"><span class="hljs-string">"Reading(%d, %f)"</span></span>, id, value); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Reading </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;ByteString&gt; fields)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;String&gt; fieldList = fields.stream().map(ByteString::utf8String).collect(toList()); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = Integer.parseInt(fieldList.get(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> value = Double.parseDouble(fieldList.get(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Reading(id, value); } }</code> </pre> <br>  For transformation as such, we use the <code>map</code> method and pass the reference to the <code>Reading.create</code> method: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Flow&lt;Collection&lt;ByteString&gt;, Reading, NotUsed&gt; readings = Flow.&lt;Collection&lt;ByteString&gt;&gt;create().map(Reading::create);</code> </pre><br>  At the next stage, we have to add the readings in pairs, calculate the average value for each group and transmit the information further only when a certain threshold is reached.  Since we want the average to be calculated asynchronously, we will use the <code>mapAsyncUnordered</code> method, which performs an asynchronous operation with a given level of parallelism: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Flow&lt;Reading, Double, NotUsed&gt; averageReadings = Flow.of(Reading.class) .grouped(<span class="hljs-number"><span class="hljs-number">2</span></span>) .mapAsyncUnordered(<span class="hljs-number"><span class="hljs-number">10</span></span>, readings -&gt; CompletableFuture.supplyAsync(() -&gt; readings.stream() .map(Reading::getValue) .collect(averagingDouble(v -&gt; v))) ) .filter(v -&gt; v &gt; AVERAGE_THRESHOLD);</code> </pre> <br>  Having identified the above components, we are ready to fold one of them into an integral conveyor (with the help of the already known combinator <code>via</code> ).  It is absolutely not difficult: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Source&lt;Double, NotUsed&gt; liveReadings = newFiles .via(csvPaths) .via(fileBytes) .via(csvFields) .via(readings) .via(averageReadings);</code> </pre> <br>  <b>Note</b> <br><br>  When combining components as shown above, the compiler protects us by not accidentally connecting two blocks containing incompatible data types. <br><br>  <b>Stream as a web socket</b> <br><br>  Now we use Akka HTTP to create a simple web server that will play such roles: <br><br><ul><li>  Provide a source of readings as a web socket, </li><li>  Produce a trivial web page that connects to a web socket and displays the data received. </li></ul><br>  It costs nothing to create a web server using Akka HTTP: you just need to inherit <code>HttpApp</code> and provide the required mappings on the DSL route: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Server</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpApp</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Source&lt;Double, NotUsed&gt; readings; Server(Source&lt;Double, NotUsed&gt; readings) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.readings = readings; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> Route </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">routes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> route( path(<span class="hljs-string"><span class="hljs-string">"data"</span></span>, () -&gt; { Source&lt;Message, NotUsed&gt; messages = readings.map(String::valueOf).map(TextMessage::create); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> handleWebSocketMessages(Flow.fromSinkAndSourceCoupled(Sink.ignore(), messages)); } ), get(() -&gt; pathSingleSlash(() -&gt; getFromResource(<span class="hljs-string"><span class="hljs-string">"index.html"</span></span>) ) ) ); } }</code> </pre> <br>  Two routes are defined here: <code>/data</code> , that is, the end point of the web socket, and <code>/</code> along which a trivial frontend is issued.  It is already clear how easy it is to provide <code>Source</code> from Akka Streams as the end point of a web socket: we take <code>handleWebSocketMessages</code> , the task of which is to improve the HTTP connection before connecting to the web socket and organize a stream in which incoming and outgoing data will be processed. <br><br>  <code>WebSocket</code> modeled as a stream, that is, outgoing and incoming messages are sent to the client.  In this case, we want to ignore the incoming data and create such a stream, the ‚Äúincoming‚Äù side of which is entered into <code>Sink.ignore()</code> .  The ‚Äúoutgoing‚Äù side of the web socket handler thread is simply connected to our source from which the average values ‚Äã‚Äãcome.  All that has to be done with <code>double</code> numbers, in the form of which are presented are averages - convert each of them to <code>TextMessage</code> , this is a wrapper used in Akka for web socket data.  Everything is simply done using the <code>map</code> method already familiar to us. <br><br>  To start the server, you just need to run the <code>startServer</code> method, specifying the host name and port: <br><br><pre> <code class="java hljs">Server server = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Server(csvProcessor.liveReadings); server.startServer(config.getString(<span class="hljs-string"><span class="hljs-string">"server.host"</span></span>), config.getInt(<span class="hljs-string"><span class="hljs-string">"server.port"</span></span>));</code> </pre> <br>  <b>Frontend</b> <br><br>  To retrieve data from a web socket and display it, we use absolutely simple JavaScript code that simply attaches the values ‚Äã‚Äãto the textarea.  This code uses the ES6 syntax, which should normally run in any modern browser. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ws = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebSocket(<span class="hljs-string"><span class="hljs-string">"ws://localhost:8080/data"</span></span>); ws.onopen = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> log(<span class="hljs-string"><span class="hljs-string">"WS connection opened"</span></span>); ws.onclose = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> log(<span class="hljs-string"><span class="hljs-string">"WS connection closed with code: "</span></span> + event.code); ws.onmessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> log(<span class="hljs-string"><span class="hljs-string">"WS received: "</span></span> + event.data);</code> </pre> <br>  The <code>log</code> method attaches a message to the textarea, and also puts a timestamp. <br><br>  <b>Launch</b> <br><br>  To run and test the application, you need: <br><br><ul><li>  start the server ( <code>sbt run</code> ), </li><li>  go to <a href="http://localhost/">localhost</a> : 8080 in the browser (or to the selected host / port, if you change the defaults), </li><li>  copy one or several files from <code>src/main/resources/sample-data</code> to the <code>data</code> directory in the project root (if you did not change <code>csv-processor.data-dir</code> in the configuration), </li><li>  Watch how the data is displayed in the server logs and in the browser. </li></ul><br>  <b>Add a mail trigger</b> <br><br>  The final touch in our application is a side channel in which we will simulate email alerts sent after every fifth element is received on a web socket.  It should work "sideways" in order not to disturb the transfer of basic elements. <br><br>  To implement this behavior, we use the more advanced feature of Akka Streams - the Graph DSL language - in which we write our own graph step, in which the stream splits into two parts.  The first simply submits the values ‚Äã‚Äãto the web socket, and the second controls when the next 5 seconds will expire, and sends an email notification ‚Äî see fig.  3 <br><br><img src="https://habrastorage.org/webt/gy/u4/qs/gyu4qsjfzpybbq2jgtxoaqcvhbi.png"><br><br>  <i>Fig.</i>  <i>3. Our own graph pitch for emailing</i> <br><br>  We will use the built-in step <code>Broadcast</code> , in which our input is sent to a set of announced conclusions.  Also we will write our own catcher - <code>Mailer</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Graph&lt;FlowShape&lt;Double, Double&gt;, NotUsed&gt; notifier = GraphDSL.create(builder -&gt; { Sink&lt;Double, NotUsed&gt; mailerSink = Flow.of(Double.class) .grouped(EMAIL_THRESHOLD) .to(Sink.foreach(ds -&gt; logger.info(<span class="hljs-string"><span class="hljs-string">"Sending e-mail"</span></span>) )); UniformFanOutShape&lt;Double, Double&gt; broadcast = builder.add(Broadcast.create(<span class="hljs-number"><span class="hljs-number">2</span></span>)); SinkShape&lt;Double&gt; mailer = builder.add(mailerSink); builder.from(broadcast.out(<span class="hljs-number"><span class="hljs-number">1</span></span>)).toInlet(mailer.in()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FlowShape.of(broadcast.in(), broadcast.out(<span class="hljs-number"><span class="hljs-number">0</span></span>)); });</code> </pre> <br>  We begin to create our own graph step from the <code>GraphDSL.create()</code> method, where a copy of the graph <code>Builder</code> is provided, <code>Builder</code> - it is used for manipulating the graph structure. <br><br>  Next, we define our own catcher, where <code>grouped</code> is used to combine incoming elements into groups of arbitrary size (default 5), after which these groups are sent down.  For each such group, we will simulate a side effect: an e-mail notification. <br><br>  Having defined our own catcher, we can use the <code>builder</code> instance to add it to the graph.  We also add a <code>Broadcast</code> step with two outputs. <br><br>  Next, you need to specify the connection between the elements of the graph - we want to connect one of the outputs of the <code>Broadcast</code> step to the email trap, and the other to make an output for the step of the graph written by us.  Entering the step we wrote will be directly connected to the output of the <code>Broadcast</code> step. <br><br>  <b>Note 1</b> <br>  The compiler cannot determine if all parts of the graph are correctly connected.  However, this moment is checked by the materializer at runtime, so there will be no hanging elements at the input or at the output. <br><br>  <b>Note 2</b> <br>  In this case, you can see that all the steps we have written are of the form Graph &lt;S, M&gt;, where S is the form that determines the number and types of inputs and outputs, and M is the materialized value (if any).  Here we deal with the Flow form, that is, we have one input and one output. <br><br>  At the last stage, we connect notifier as an additional step of the <code>liveReadings</code> pipeline, which will now take the following form: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Source&lt;Double, NotUsed&gt; liveReadings = newFiles .via(csvPaths) .via(fileBytes) .via(csvFields) .via(readings) .via(averageReadings) .via(notifier);</code> </pre> <br>  When you run the updated code, you will see mail notification entries appear in the log.  The notification is sent whenever five more values ‚Äã‚Äãhave passed through the web socket. <br><br>  <b>Total</b> <br><br>  In this article, we studied the general concepts of stream data processing, learned how to build a lightweight data processing pipeline using Akka Streams.  This is an alternative to the traditional approach used in Java EE. <br><br>  We looked at how to use some of the processing steps built into Akka Streams, how to write your own step in Graph DSL.  It also showed how to use Alpakka to stream data from the file system and the Akka HTTP protocol, which allows you to create a simple web server with a web socket on the endpoint that is seamlessly integrated with Akka Streams. <br><br>  A full working example with the code from this article is <a href="https://github.com/softwaremill/reactive-streams-for-java-developers">on GitHub</a> .  There are several additional <code>log</code> steps placed at different points.  They help to more accurately imagine what is happening inside the pipeline.  In the article I specifically lowered them to make it shorter. </div><p>Source: <a href="https://habr.com/ru/post/353496/">https://habr.com/ru/post/353496/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353486/index.html">Why game servers and chat must exist separately</a></li>
<li><a href="../353488/index.html">Issue # 18: IT training - current issues and challenges from leading companies</a></li>
<li><a href="../353490/index.html">And again about translating PHP documentation</a></li>
<li><a href="../353492/index.html">GeekBrains starts training performance marketing specialists</a></li>
<li><a href="../353494/index.html">IntelliJ IDEA 2018.1 - Improved code analysis, support for Git partial commits, Android Studio 3.0, and more.</a></li>
<li><a href="../353498/index.html">How many mathematics do you need to sign a polygon in the Yandex.Maps JS API</a></li>
<li><a href="../353500/index.html">Implementing domain-specific design in PHP</a></li>
<li><a href="../353502/index.html">Associative rules, or beer with diapers</a></li>
<li><a href="../353504/index.html">Root access through TeamCity</a></li>
<li><a href="../353506/index.html">Drupalgeddon2: SA-CORE-2018-002 operation began</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>