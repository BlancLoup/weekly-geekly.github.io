<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Homemade garbage collector for OpenJDK</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is a translation of the article ‚ÄúDo It Yourself (OpenJDK) Garbage Collector‚Äù by Alexey Shipilyov, published with the consent of the author. Repor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Homemade garbage collector for OpenJDK</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  This is a translation of the article <a href="https://shipilev.net/jvm/diy-gc/">‚ÄúDo It Yourself (OpenJDK) Garbage Collector‚Äù by</a> Alexey Shipilyov, published with the consent of the author.  Report any typos and other bugs in PM - we'll fix them. </blockquote><p>  The process of creating something in a runtime of a language is a fun exercise.  At least the creation of the first version!  It is a very, very difficult task to build a reliable, high-performance, fault-tolerant subsystem of runtime, the behavior of which can be conveniently monitored and debugged. </p><br><p>  It is deceptively simple to make a simple garbage collector, and here you want to do this in this article.  Roman Kennke on FOSDEM 2019 gave a talk and a demo called <a href="">‚ÄúWriting GC in 20 minutes‚Äù</a> using an earlier version of this patch.  Despite the fact that the code implemented there demonstrates a lot and is abundantly commented, there is a need for a good high-level description of what is happening - this is how the article appeared. </p><br><p>  A basic understanding of the work of garbage collectors will greatly help in understanding what is written here.  The article will use specificity and ideas in a specific implementation of HotSpot, but there will not be an introductory course on GC design.  Take the <a href="http://gchandbook.org/">GC Handbook</a> and read the first chapters about the very basics of GC, and even more quickly allow you to start <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection">an article on Wikipedia</a> . </p><br><p><img src="https://habrastorage.org/webt/4v/1i/4y/4v1i4yrxpcef-vvvkknzfuhmt-w.jpeg"></p><a name="habracut"></a><br><h1 id="soderzhanie">  Content </h1><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><ul><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">1. What does GC consist of?</a> <br><ul><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">1.1.</a>  <a href="https://habr.com/ru/company/jugru/blog/443250/">Epsilon GC</a> <br><ul><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">1.1.1.</a>  <a href="https://habr.com/ru/company/jugru/blog/443250/">Memory allocation</a> </li><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">1.1.2.</a>  <a href="https://habr.com/ru/company/jugru/blog/443250/">Barriers</a> </li><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">1.1.3.</a>  <a href="https://habr.com/ru/company/jugru/blog/443250/">Connection to monitoring</a> </li></ul></li><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">1.2.</a>  <a href="https://habr.com/ru/company/jugru/blog/443250/">Rantaym and GC</a> <br><ul><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">1.2.1.</a>  <a href="https://habr.com/ru/company/jugru/blog/443250/">Root elements</a> </li><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">1.2.2.</a>  <a href="https://habr.com/ru/company/jugru/blog/443250/">Object Traversal</a> </li><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">1.2.3.</a>  <a href="https://habr.com/ru/company/jugru/blog/443250/">Moves</a> </li><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">1.2.4.</a>  <a href="https://habr.com/ru/company/jugru/blog/443250/">Marker data</a> </li></ul></li></ul></li><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">2. General plan</a> </li><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">3. Implementing the GC core</a> <br><ul><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">3.1.</a>  <a href="https://habr.com/ru/company/jugru/blog/443250/">Prologue</a> </li><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">3.2.</a>  <a href="https://habr.com/ru/company/jugru/blog/443250/">Marking</a> </li><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">3.3.</a>  <a href="https://habr.com/ru/company/jugru/blog/443250/">We calculate new addresses</a> </li><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">3.4.</a>  <a href="https://habr.com/ru/company/jugru/blog/443250/">Fix pointers</a> </li><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">3.5.</a>  <a href="https://habr.com/ru/company/jugru/blog/443250/">Moving objects</a> </li><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">3.6.</a>  <a href="https://habr.com/ru/company/jugru/blog/443250/">Epilogue</a> </li></ul></li><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">4. Connect GC to VM</a> <br><ul><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">4.1.</a>  <a href="https://habr.com/ru/company/jugru/blog/443250/">Root Bypass</a> </li><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">4.2.</a>  <a href="https://habr.com/ru/company/jugru/blog/443250/">Safepoints and stop the world</a> </li><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">4.3.</a>  <a href="https://habr.com/ru/company/jugru/blog/443250/">Memory allocation errors</a> </li></ul></li><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">5. Build</a> </li><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">6. Testing</a> </li><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">7. Performance</a> </li><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">8. What's next?</a> </li><li>  <a href="https://habr.com/ru/company/jugru/blog/443250/">9. Conclusions</a> </li></ul></div></div><br><a name="1"></a><br><h1 id="1-iz-chego-sostoit-gc">  1. What does GC consist of? </h1><br><p>  Now, when many different GCs are written, it‚Äôs pretty simple to make your own - many elements already written can be (re) used to shift some of the worries about implementation details to proven and tested code. </p><br><a name="11"></a><br><h2 id="11-epsilon-gc">  1.1.  Epsilon GC </h2><br><p>  OpenJDK 11 has a new JEP 318: <a href="https://openjdk.java.net/jeps/318">"Epsilon: A No-Op Garbage Collector (Experimental)"</a> .  Its task is to provide a minimal implementation for the case when freeing memory is unnecessary or even prohibited.  The JEP discusses in more detail why it might be useful. </p><br><p>  From the point of view of implementation, ‚Äúgarbage collector‚Äù is a bad name; it would be better to use the term <a href="https://en.wikipedia.org/wiki/Category:Automatic_memory_management">‚Äúautomatic memory manager‚Äù</a> , which is responsible for both allocating and freeing memory.  Epsilon GC implements only the ‚Äúselection‚Äù, and the ‚Äúrelease‚Äù is not engaged at all.  Therefore, we can take Epsilon GC and start implementing the ‚Äúrelease‚Äù algorithms from scratch. </p><br><a name="111"></a><br><h3 id="111-vydelenie-pamyati">  1.1.1.  Memory allocation </h3><br><p>  The most developed part of Epsilon GC <a href="">is responsible for memory allocation</a> .  It serves external requests for allocating memory of arbitrary size and creating a <a href="https://shipilev.net/jvm/anatomy-quarks/4-tlab-allocation/">Thread-Local Allocation Buffer (TLAB) of the</a> desired size.  The implementation itself tries not to extend TLAB too much, since there will be no memory freeing and no one will return the lost bytes. </p><br><a name="112"></a><br><h3 id="112-barery">  1.1.2.  Barriers </h3><br><p>  Some garbage collectors require interaction with the application to maintain GC invariants, forcing the runtime and the application to do so-called <em>barriers</em> when trying to access the heap.  This is true for all multithreaded collectors, and for <a href="https://shipilev.net/jvm/anatomy-quarks/13-intergenerational-barriers/">many collectors with generations</a> and stopping the world. </p><br><p>  Epsilon does not require barriers, but the runtime and compiler still want to <em>know</em> that barriers do nothing.  Handling it every time can be tedious everywhere.  Fortunately, starting with OpenJDK 11, there is a new <a href="https://openjdk.java.net/jeps/304">JEP-304: ‚ÄúGarbage Collection Interface‚Äù</a> , thanks to which it has become much, much easier to insert barriers.  In particular, the <a href="">barrier set in Epsilon is empty</a> , and all the trivial work - save, load, CAS, arraycopy - can be delegated to implementations of trivial barriers from an already existing superclass.  If you are doing a GC, which also does not need barriers, you can simply reuse the code from Epsilon. </p><br><a name="113"></a><br><h3 id="113-podklyuchenie-k-monitoringu">  1.1.3.  Connection to monitoring </h3><br><p>  The last tedious part of the GC implementation is hooks to a bunch of monitoring mechanisms inside the JVM: MX-bins, diagnostic commands, etc. should work.  Epsilon <a href="">has already done</a> all this for you. </p><br><a name="12"></a><br><h2 id="12-rantaym-i-gc">  1.2.  Rantaym and GC </h2><br><a name="121"></a><br><h3 id="121-kornevye-elementy">  1.2.1.  Root elements </h3><br><p>  The garbage collector, in general, needs to know that it is in the Java runtime that has links to the heap.  These root elements, called <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection">GC Roots</a> , can be slots on stream stacks and local variables (including those that are in JIT-compiled code!), Native classes and classloaders, links in JNI, and so on.  Attempts to identify these elements can be very difficult and tedious.  But in Hotspot, they are all tracked using the appropriate VM subsystems, so you can simply examine how the existing GC implementations work with them.  Further in the text we will see it. </p><br><a name="122"></a><br><h3 id="122-obhod-obektov">  1.2.2.  Object Traversal </h3><br><p> The garbage collector should bypass outbound links in Java objects.  This operation is found everywhere, so the common parts of the runtime provide ready-made workaround tools; you don‚Äôt have to write anything yourself.  Below, there will be a section with a specific implementation, and there you can find, for example, calls <code>obj‚Üíoop_iterate</code> . </p><br><a name="123"></a><br><h3 id="123-peremescheniya">  1.2.3.  Moves </h3><br><p>  The moving garbage collector needs to write down new addresses of the objects being moved somewhere.  There are several places where you can write this data about the movements ( <em>forwarding data</em> ). </p><br><ol><li>  You can reuse the <a href="">‚Äúmarker word‚Äù (‚Äúmark word‚Äù) in the object itself</a> (Serial, Parallel, etc.).  After the world stops, all access to the object is controlled, and it is guaranteed that not a single Java stream will be able to see the temporary data that we decided to write to the marker word.  You can reuse it to store forwarding data. </li><li>  You can maintain a separate native motion table ( <a href="http://openjdk.java.net/jeps/333">ZGC</a> , C4, and others).  This completely isolates the GC from runtime and the rest of the application, since only the GC knows about the existence of such a table.  Competitive collectors usually use just such a scheme - they do not want to suffer with a bunch of unnecessary problems. </li><li>  You can add one more word to the object ( <a href="http://openjdk.java.net/jeps/189">Shenandoah</a> and others).  This combination of the two previous approaches not only gives runtime and the application to work with existing headers without problems, but also saves forwarding data. </li></ol><br><a name="124"></a><br><h3 id="124-markernye-dannye">  1.2.4.  Marker data </h3><br><p>  The garbage collector needs to write <em>marking data</em> somewhere.  And again, there are several ways to save them: </p><br><ol><li>  You can reuse the marker word in the object itself (Serial, Parallel, etc.).  Again, in world stop mode, you can use the bits in the marker word to encode the fact that there is a label.  Further, if it is necessary to bypass all living objects, we go along the heap, object after object - this is possible due to the fact that the <a href="https://shipilev.net/jvm/anatomy-quarks/5-tlabs-and-heap-parsability/">heap is parsable</a> . </li><li>  You can maintain a separate structure for storing marking data (G1, Shenandoah, etc.).  This is usually done using a <a href="">separate bitmap</a> that maps every N bytes of the heap to 1 bit of the card.  Usually, Java objects <a href="https://shipilev.net/jvm/anatomy-quarks/24-object-alignment/">are 8 byte aligned</a> , so the map displays every 64 bits from the heap to 1 bit of the card, taking up 1/64 of the heap size in native memory.  These overheads pay off well when scanning a heap for the presence of living objects, especially sparse ones: bypassing the map is often much faster than bypassing the heap to be disassembled object by object. </li><li>  Encode tags in the links themselves (ZGC, C4 and others).  This requires coordination with the application, then you need to cut out all these tags from the links or perform some other tricks to maintain correctness.  In other words, we need either barriers or some additional work on the part of the GC. </li></ol><br><a name="2"></a><br><h1 id="2-obschiy-plan">  2. General plan </h1><br><p>  Most likely, the easiest to implement on top of Epsilon is Mark-Compact, in the style of LISP2.  The main idea of ‚Äã‚Äãthis GC is described both <a href="https://en.wikipedia.org/wiki/Mark-compact_algorithm">in Wikipedia</a> and <a href="http://gchandbook.org/">in the GC Handbook</a> (chapter 3.2).  The algorithm will be sketched in the implementation section below, but I strongly recommend reading a little of Wikipedia or the GC Handbook to understand what we are going to do. </p><br><p>  The algorithm in question is a <em>shifting</em> GC: moving objects move in an crowd at the very beginning of the heap.  It has its pros and cons: </p><br><ul><li>  It maintains the order of memory allocations.  This is very good for controlling the layout in memory if this is important to you (control freaks, your hour has come!).  The downside is that you will not get <a href="https://shipilev.net/jvm/anatomy-quarks/11-moving-gc-locality/">automatic locality of links</a> . </li><li>  Its complexity is O (N) on the number of objects.  However, linearity has its price: GC is required to bypass the heap 4 times for each build cycle. </li><li>  It does not require free memory in a heap!  There is no need to reserve memory in the heap to evacuate living objects, so you can even work with a heap that is overflowed by 99. (9)%.  If we take on other ideas of simple collectors, for example, a semi-heap scavenger (semi-space scavenger), we‚Äôll have to slightly rewrite the heap view and reserve some space for evacuation, but this is beyond the scope of this exercise. </li><li>  If you work a little on the issue, you can achieve zero memory consumption and time during periods when the GC is not active.  It runs on a memory in an arbitrary state, and stops, significantly compacting it.  This fits very well with how Epsilon works: it just continues to allocate immediately after the last object.  This is also a minus: a few dead objects at the beginning of the heap lead to a large number of movements. </li><li>  It simply does not require new barriers; you can reuse <code>EpsilonBarrierSet</code> as is. </li></ul><br><p>  For simplicity, the GC implementation will use a full stop of the world (stop-the-world, STW), there will be no generations and multithreading in it.  For this case, it makes sense to use a bitmap to store marks and reuse the marker word to store movement data. </p><br><a name="3"></a><br><h1 id="3-realizaciya-yadra-gc">  3. Implementing the GC core </h1><br><p>  Reading and understanding the <a href="https://shipilev.net/jvm/diy-gc/webrev/">whole implementation</a> may be too complicated for an ignorant person.  In this section we will look at it step by step. </p><br><a name="31"></a><br><h2 id="31-prolog">  3.1.  Prologue </h2><br><p>  The garbage collector usually needs to do a couple of things to prepare for the build.  Read the comments, they should speak for themselves: </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 0: Prologue"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      .      //   :   ,   ,  // ¬´¬ª   ,      //   ,     . if (!os::commit_memory((char*)_bitmap_region.start(), _bitmap_region.byte_size(), false)) { log_warning(gc)("Could not commit native memory for marking bitmap, GC failed"); return; } //        ,  , //       TLAB-. ensure_parsability(true); //      ,    GC. CodeCache::gc_prologue(); BiasedLocking::preserve_marks(); //        . //       . DerivedPointerTable::clear(); }</span></span></code> </pre> <br><p>  Since we use a bitmap to track objects reachability, we need to clean it up before using it.  Or in our case, since we are aiming to never request resources before running the GC cycle, we have to <a href="https://www.codeproject.com/Articles/1255908/Allocating-Memory-on-Linux-and-Windows">commit the bitmap to memory in</a> advance.  This offers several interesting advantages, at least on Linux, where most of the bitmap will point to zero page, especially for sparse heaps. </p><br><p>  The threads should release their TLABs and ask the GC for new ones after the build is complete. </p><br><blockquote>  Do not confuse TLAB and <code>java.lang.ThreadLocal</code> .  From the point of view of the GC, ThreadLocals are ordinary objects, and they will not be compiled by the GC unless specifically required in the Java code. </blockquote><p>  Some parts of the runtime, especially holding links to the java heap, will break down during garbage collection, so you need to specifically warn them that the GC will start working soon.  This will allow the relevant subsystems to get ready and save some of their state before the GC makes its move. </p><br><a name="32"></a><br><h2 id="32-markirovka">  3.2.  Marking </h2><br><p>  Marking in the stop mode of the world becomes quite simple when almost everything has already been done for us.  Marking is pretty standard, and most likely, in many GC implementations is the first step. </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 1: Mark"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    ,     .  //   ,  ,    //      . EpsilonMarkStack stack; EpsilonScanOopClosure cl(&amp;stack, &amp;_bitmap); //      . process_roots(&amp;cl); stat_reachable_roots = stack.size(); //    ,    . //    ,   , //      . while (!stack.is_empty()) { oop obj = stack.pop(); obj-&gt;oop_iterate(&amp;cl); stat_reachable_heap++; } //       . DerivedPointerTable::set_active(false); }</span></span></code> </pre> <br><p>  This works in exactly the same way as for any other graph: you start a detour from the initial set of reachable vertices, go along the outgoing edges and record all the visited vertices.  The detour continues until all unvisited vertices end.  In GC, ‚Äúvertices‚Äù are objects, and ‚Äúedges‚Äù are links between them. </p><br><p>  Technically, we could just recursively walk through the object graph, but this is a bad idea for arbitrary graphs that can have very large diameters.  Imagine a linked list of a billion peaks!  Therefore, to limit the depth of recursion, we use a labeling stack that records the detected objects. </p><br><p>  The initial set of reachable objects is GC roots.  Now you should not dwell on the fact that such a <code>process_roots</code> , this will be later.  For now, let's just say that it bypasses all the accessible references from the VM side. </p><br><p>  The bitmap with marks serves both as a tool for recording the <em>marking front</em> (a set of objects already visited), and at the end - as a repository of the desired result, a set of all achievable objects.  The real work takes place in <code>EpsilonScanOopClosure</code> , it is applied to all interesting objects and is iterated over all links of the selected object. </p><br><blockquote>  Look, Java knew how to <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25BC%25D1%258B%25D0%25BA%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">closure</a> before it became fashionable! </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonScanOopClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BasicOopIterateClosure { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: EpsilonMarkStack* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _stack; MarkBitMap* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _bitmap; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do_oop_work</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-comment"><span class="hljs-comment">// p -     ,   oop,   //      ,  : T o = RawAccess&lt;&gt;::oop_load(p); if (!CompressedOops::is_null(o)) { oop obj = CompressedOops::decode_not_null(o); //  . ,   .  , //        . //    +, //       . if (!_bitmap-&gt;is_marked(obj)) { _bitmap-&gt;mark((HeapWord*)obj); _stack-&gt;push(obj); } } } };</span></span></code> </pre> <br><p>  After completing this step, <code>_bitmap</code> contains bits indicating the location of live objects.  Thanks to this, it is possible to bypass all living objects, for example: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//           . //   ,    ( )  ,  //       1/64  . void EpsilonHeap::walk_bitmap(ObjectClosure* cl) { HeapWord* limit = _space-&gt;top(); HeapWord* addr = _bitmap.get_next_marked_addr(_space-&gt;bottom(), limit); while (addr &lt; limit) { oop obj = oop(addr); assert(_bitmap.is_marked(obj), "sanity"); cl-&gt;do_object(obj); addr += 1; if (addr &lt; limit) { addr = _bitmap.get_next_marked_addr(addr, limit); } } }</span></span></code> </pre> <br><a name="33"></a><br><h2 id="33-vychislyaem-novye-adresa">  3.3.  We calculate new addresses </h2><br><p>  This is also a fairly simple step, and it implements exactly what the algorithm says. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ab3/406/5e6/ab34065e6397d39413057358b45247a3.jpg"></p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    forwarding data (,    ) //   .        . //          . PreservedMarks preserved_marks; //     GC. HeapWord* new_top; { GCTraceTime(Info, gc) time("Step 2: Calculate new locations", NULL); //    ,        //    . ,  - . EpsilonCalcNewLocationObjectClosure cl(_space-&gt;bottom(), &amp;preserved_marks); walk_bitmap(&amp;cl); //         . //       ,    //      ,      "" //  . new_top = cl.compact_point(); stat_preserved_marks = preserved_marks.size(); }</span></span></code> </pre> <br><p>  The only thing that catches your eye here is that we decided to store new addresses in the marking word of java objects, and this word may already be occupied by something important, for example, under information about locks.  Fortunately, such non-trivial marking words are quite rare, and we can simply store them separately, if it is needed at all: this is what <code>PreservedMarks</code> uses. </p><br><p>  <code>EpsilonCalcNewLocationObjectClosure</code> makes real algorithmic work: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonCalcNewLocationObjectClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ObjectClosure { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: HeapWord* _compact_point; PreservedMarks* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _preserved_marks; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: EpsilonCalcNewLocationObjectClosure(HeapWord* start, PreservedMarks* pm) : _compact_point(start), _preserved_marks(pm) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oop obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    :    . //        (      , //    ),      , //     . if ((HeapWord*)obj != _compact_point) { markOop mark = obj-&gt;mark_raw(); if (mark-&gt;must_be_preserved(obj)) { _preserved_marks-&gt;push(obj, mark); } obj-&gt;forward_to(oop(_compact_point)); } _compact_point += obj-&gt;size(); } HeapWord* compact_point() { return _compact_point; } };</span></span></code> </pre> <br><p>  <code>forward_to</code> is the most important part, since it stores the ‚Äúmove address‚Äù in the marker word of the object.  This will be needed in the following steps. </p><br><a name="34"></a><br><h2 id="34-ispravlyaem-ukazateli">  3.4.  Fix pointers </h2><br><p>  Now you need to go through the heap again and rewrite all the links with their new addresses according to the following algorithm: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/25f/c82/1dc/25fc821dc95d2f9d50fe40653eb845ff.jpg"></p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 3: Adjust pointers"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     _   _,     // ¬´ ¬ª.      forwarding data, //    .      . EpsilonAdjustPointersObjectClosure cl; walk_bitmap(&amp;cl); //     ,      VM,  //     :      . EpsilonAdjustPointersOopClosure cli; process_roots(&amp;cli); //   ,      , //     . preserved_marks.adjust_during_full_gc(); }</span></span></code> </pre> <br><p>  There are two types of links to the shifted objects: outgoing either from the objects on the heap itself, or from GC roots.  Update need both classes of links.  Some saved tags also store links to objects, so you need to ask them to update.  <code>PreservedMarks</code> knows how to do this, because it expects "forwarding data" in the same place where we saved it, in the marking word of the object. </p><br><p>  Closures are divided into two types: some accept objects and bypass their contents, others update these addresses.  Here you can make a small optimization of performance: if the object does not move, you can save a couple of records in a heap: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonAdjustPointersOopClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BasicOopIterateClosure { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do_oop_work</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-comment"><span class="hljs-comment">// p -     ,   oop. //        ,  : T o = RawAccess&lt;&gt;::oop_load(p); if (!CompressedOops::is_null(o)) { oop obj = CompressedOops::decode_not_null(o); //         . //  ,    . if (obj-&gt;is_forwarded()) { oop fwd = obj-&gt;forwardee(); assert(fwd != NULL, "just checking"); RawAccess&lt;&gt;::oop_store(p, fwd); } } } }; class EpsilonAdjustPointersObjectClosure : public ObjectClosure { private: EpsilonAdjustPointersOopClosure _cl; public: void do_object(oop obj) { //    ,    : obj-&gt;oop_iterate(&amp;_cl); } };</span></span></code> </pre> <br><p>  After completing this step, we essentially broke the heap: the links point to the ‚Äúwrong‚Äù addresses where the objects are not yet located.  Let's fix it! </p><br><a name="35"></a><br><h2 id="35-dvigaem-obekty">  3.5.  Moving objects </h2><br><p>  Time to move objects to new addresses, in accordance with the algorithm: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/01c/5b8/db8/01c5b8db85781c82b89bbed730c8aecc.jpg"></p><br><p>  <code>EpsilonMoveObjectsObjectClosure</code> around the heaps again and apply <code>EpsilonMoveObjectsObjectClosure</code> closure to all living objects: </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 4: Move objects"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//       . //          . EpsilonMoveObjectsObjectClosure cl; walk_bitmap(&amp;cl); stat_moved = cl.moved(); //         ,   // ¬´¬ª      . _space-&gt;set_top(new_top); }</span></span></code> </pre> <br><p>  Immediately after that, you can drag the heap point of the compression point, making it possible to allocate memory right from this place, as soon as the garbage collection cycle ends. </p><br><p>  Notice that in the shifting assembly we can overwrite the contents of existing objects, but since the scan goes in the same direction, the overwritten objects are already copied to the right place. </p><br><blockquote>  The old and the new location of the same object may intersect.  For example, if you move a 100-byte object to 8 bytes.  The copying procedure should work itself out, and the intersecting content should be copied correctly, pay attention to <code>Copy::aligned_*conjoint*_words</code> . </blockquote><p>  The closure itself will simply move the objects being moved to the new addresses: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonMoveObjectsObjectClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ObjectClosure { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oop obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     ,  .   - , //   -  mark word, //      forwarding data. if (obj-&gt;is_forwarded()) { oop fwd = obj-&gt;forwardee(); assert(fwd != NULL, "just checking"); Copy::aligned_conjoint_words((HeapWord*)obj, (HeapWord*)fwd, obj-&gt;size()); fwd-&gt;init_mark_raw(); } } };</span></span></code> </pre> <br><a name="36"></a><br><h2 id="36-epilog">  3.6.  Epilogue </h2><br><p>  The garbage collection is over, the heap is almost consistent again, the last finishing touches are left: </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 5: Epilogue"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    . preserved_marks.restore(); //   ,    . DerivedPointerTable::update_pointers(); BiasedLocking::restore_marks(); CodeCache::gc_epilogue(); JvmtiExport::gc_epilogue(); //     . if (!os::uncommit_memory((char*)_bitmap_region.start(), _bitmap_region.byte_size())) { log_warning(gc)("Could not uncommit native memory for marking bitmap"); } //    ,  . //        . if (EpsilonUncommit) { _virtual_space.shrink_by((_space-&gt;end() - new_top) * HeapWordSize); _space-&gt;set_end((HeapWord*)_virtual_space.high()); } }</span></span></code> </pre> <br><p>  We notify the rest of the runtime that they should run the post-assembly procedures.  We restore the special marker words that we saved earlier.  Farewell kiss of our marker map - it is no longer needed. </p><br><p>  And if you really want to, you can reduce the memory for allocations to the new size, thereby returning the memory to the operating system! </p><br><a name="4"></a><br><h1 id="4-podklyuchaem-gc-k-vm">  4. Connect GC to VM </h1><br><a name="41"></a><br><h2 id="41-obhod-kornevyh-elementov">  4.1.  Root Bypass </h2><br><p>  Remember, you need to bypass the special, reachable links from the VM?  You can ask each VM subsystem to bypass the links hidden from other Java objects.  An exhaustive list of such root elements in the current Hotspot looks something like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> EpsilonHeap::do_roots(OopClosure* cl) { <span class="hljs-comment"><span class="hljs-comment">//   ,        1 . StrongRootsScope scope(1); //         . CLDToOopClosure clds(cl, ClassLoaderData::_claim_none); MarkingCodeBlobClosure blobs(cl, CodeBlobToOopClosure::FixRelocations); //      . //        . { MutexLockerEx lock(CodeCache_lock, Mutex::_no_safepoint_check_flag); CodeCache::blobs_do(&amp;blobs); } { MutexLockerEx lock(ClassLoaderDataGraph_lock); ClassLoaderDataGraph::cld_do(&amp;clds); } Universe::oops_do(cl); Management::oops_do(cl); JvmtiExport::oops_do(cl); JNIHandles::oops_do(cl); WeakProcessor::oops_do(cl); ObjectSynchronizer::oops_do(cl); SystemDictionary::oops_do(cl); Threads::possibly_parallel_oops_do(false, cl, &amp;blobs); }</span></span></code> </pre> <br><p>  ,        .    GC    . </p><br><a name="42"></a><br><h2 id="42-seyfpointy-i-ostanovka-mira">  4.2.     </h2><br><p>   GC     ,   VM      .  Hotspot     <code>VM_Operation</code> ,     GC    VM-  : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// VM_operation,      class VM_EpsilonCollect: public VM_Operation { private: const GCCause::Cause _cause; EpsilonHeap* const _heap; static size_t _last_used; public: VM_EpsilonCollect(GCCause::Cause cause) : VM_Operation(), _cause(cause), _heap(EpsilonHeap::heap()) {}; VM_Operation::VMOp_Type type() const { return VMOp_EpsilonCollect; } const char* name() const { return "Epsilon Collection"; } virtual bool doit_prologue() { //     ,     . //         GC, //          . //   ,         //  .     , //       1%, ,  , //     . Heap_lock-&gt;lock(); size_t used = _heap-&gt;used(); size_t capacity = _heap-&gt;capacity(); size_t allocated = used &gt; _last_used ? used - _last_used : 0; if (_cause != GCCause::_allocation_failure || allocated &gt; capacity / 100) { return true; } else { Heap_lock-&gt;unlock(); return false; } } virtual void doit() { _heap-&gt;entry_collect(_cause); } virtual void doit_epilogue() { _last_used = _heap-&gt;used(); Heap_lock-&gt;unlock(); } }; size_t VM_EpsilonCollect::_last_used = 0; void EpsilonHeap::vmentry_collect(GCCause::Cause cause) { VM_EpsilonCollect vmop(cause); VMThread::execute(&amp;vmop); }</span></span></code> </pre> <br><p>       ,       GC ‚Äî    ,     . </p><br><a name="43"></a><br><h2 id="43-oshibki-vydeleniya-pamyati">  4.3.    </h2><br><p> ,     GC  ,   ,  GC    ,     .   ,      <code>allocate_work</code>     ,   GC     : </p><br><pre> <code class="cpp hljs">HeapWord* EpsilonHeap::allocate_or_collect_work(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size) { HeapWord* res = allocate_work(size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> &amp;&amp; EpsilonSlidingGC) { vmentry_collect(GCCause::_allocation_failure); res = allocate_work(size); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br><p>  That's all! </p><br><a name="5"></a><br><h1 id="5-sborka"> 5.  </h1><br><p> <a href="https://shipilev.net/jvm/diy-gc/webrev/"> </a>        OpenJDK. </p><br><pre> <code class="bash hljs">$ hg <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://hg.openjdk.java.net/jdk/jdk/ jdk-jdk $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> jdk-jdk $ curl https://shipilev.net/jvm/diy-gc/webrev/jdk-jdk-epsilon.changeset | patch -p1</code> </pre> <br><p>     OpenJDK  : </p><br><pre> <code class="bash hljs">$ ./configure --with-debug-level=fastdebug $ make images</code> </pre> <br><p>    : </p><br><pre> <code class="bash hljs">$ build/linux-x86_64-server-fastdebug/images/jdk/bin/java -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -XX:+EpsilonSlidingGC -version openjdk version <span class="hljs-string"><span class="hljs-string">"13-internal"</span></span> 2019-09-17 OpenJDK Runtime Environment (build 13-internal+0-adhoc.shade.jdk-jdk-epsilon) OpenJDK 64-Bit Server VM (build 13-internal+0-adhoc.shade.jdk-jdk-epsilon, mixed mode, sharing</code> </pre> <br><a name="6"></a><br><h1 id="6-testirovanie"> 6.  </h1><br><p>  ,    GC  ?    : </p><br><ol><li> .  .   Hotspot    ,   JVM   <em>fastdebug</em>        ,        GC. </li><li>  .        ,          . ,        ( )   ,          . </li><li> .    ,  ,   ,   .     -   ,        . </li></ol><br><p> ,    ,       : </p><br><pre> <code class="plaintext hljs">$ CONF=linux-x86_64-server-fastdebug make images run-test TEST=gc/epsilon/ Building targets 'images run-test' in configuration 'linux-x86_64-server-fastdebug' Test selection 'gc/epsilon/', will run: * jtreg:test/hotspot/jtreg/gc/epsilon Running test 'jtreg:test/hotspot/jtreg/gc/epsilon' Passed: gc/epsilon/TestAlwaysPretouch.java Passed: gc/epsilon/TestAlignment.java Passed: gc/epsilon/TestElasticTLAB.java Passed: gc/epsilon/TestEpsilonEnabled.java Passed: gc/epsilon/TestHelloWorld.java Passed: gc/epsilon/TestLogTrace.java Passed: gc/epsilon/TestDieDefault.java Passed: gc/epsilon/TestDieWithOnError.java Passed: gc/epsilon/TestMemoryPools.java Passed: gc/epsilon/TestMaxTLAB.java Passed: gc/epsilon/TestPrintHeapSteps.java Passed: gc/epsilon/TestArraycopyCheckcast.java Passed: gc/epsilon/TestClasses.java Passed: gc/epsilon/TestUpdateCountersSteps.java Passed: gc/epsilon/TestDieWithHeapDump.java Passed: gc/epsilon/TestByteArrays.java Passed: gc/epsilon/TestManyThreads.java Passed: gc/epsilon/TestRefArrays.java Passed: gc/epsilon/TestObjects.java Passed: gc/epsilon/TestElasticTLABDecay.java Passed: gc/epsilon/TestSlidingGC.java Test results: passed: 21 TEST SUCCESS</code> </pre> <br><p> ?       <em>fastdebug</em>    .  ?    - . </p><br><a name="7"></a><br><h1 id="7-proizvoditelnost"> 7.  </h1><br><p> -  <a href="https://github.com/spring-projects/spring-petclinic">spring-petclinic</a> ,  Apache Bench     GC!        ,  ,     GC . </p><br><p>    : <code>-Xlog:gc -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -XX:+EpsilonSlidingGC</code> : </p><br><p> : </p><br><pre> <code class="plaintext hljs">Heap: 20480M reserved, 20480M (100.00%) committed, 19497M (95.20%) used GC(2) Step 0: Prologue 2.085ms GC(2) Step 1: Mark 51.005ms GC(2) Step 2: Calculate new locations 71.207ms GC(2) Step 3: Adjust pointers 49.671ms GC(2) Step 4: Move objects 22.839ms GC(2) Step 5: Epilogue 1.008ms GC(2) GC Stats: 70561 (8.63%) reachable from roots, 746676 (91.37%) reachable from heap, 91055 (11.14%) moved, 2237 (0.27%) markwords preserved GC(2) Heap: 20480M reserved, 20480M (100.00%) committed, 37056K (0.18%) used GC(2) Lisp2-style Mark-Compact (Allocation Failure) 20479M-&gt;36M(20480M) 197.940ms</code> </pre> <br><p> 200 ?        GC!   ,         .   ,          ,   :         (      ‚Äî  ,    ).       - (                ). </p><br><p>  , GC          . ,   <code>-Xlog:gc -XX:+UseSerialGC</code> ‚Äî  ,  ,  : </p><br><pre> <code class="plaintext hljs">GC(46) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.603ms GC(47) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.606ms GC(48) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.747ms GC(49) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.578ms</code> </pre> <br><p> , 2 .  ,        ,   GC   .      <code>-Xlog:gc -XX:+UseSerialGC</code> ,       ,      : </p><br><pre> <code class="plaintext hljs">GC(3) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 1969.694ms GC(4) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 2261.405ms GC(5) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 2327.577ms GC(6) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 2328.976ms</code> </pre> <br><p>     ,    .    . </p><br><a name="8"></a><br><h1 id="8-chto-dalshe"> 8.  ? </h1><br><p>     .       ,    GC  OpenJDK ‚Äî  ,    ,          . </p><br><p>   : </p><br><ol><li><p>    .     ,   // .      .     ,       ,    ¬´ ¬ª       ,        ,   . <br></p><blockquote>    GC, <code>java.lang.ref.Reference.referent</code> ‚Äî     Java-,  ,   ,     -  .       <code>FinalReference</code> ,    . </blockquote>         <code>ReferenceProcessor</code>     /  /     . <br></li><li><p>        VM.              VM,   ,   ,       .       <em></em>  <em></em>  .  ,    <em></em>  ,  ,     -  <em></em>   ,    . </p><br></li><li><p>  .      ‚Äî    ,    GC,          .  ,    ,      ,       . <br></p><blockquote>    mark-compact GC   Full GC fallbacks  Shenandoah (  OpenJDK 8)  G1 (  OpenJDK 10,    <a href="https://openjdk.java.net/jeps/307">JEP 307: ¬´Parallel Full GC for G1¬ª</a> ). </blockquote><br></li><li><p>  <a href="https://shipilev.net/jvm/diy-gc/epsilon-dense-prefix.patch">  </a> .  ,        ¬´¬ª     ,     , ,  -     .           .   ,          . </p><br></li><li><p>        .     ,  ,     ,           .   ,     ¬´¬ª ‚Äî    ¬´¬ª        ¬´¬ª ,      . </p><br></li><li><p>  -   GC Handbook     . </p><br></li></ol><br><a name="9"></a><br><h1 id="9-vyvody"> 9.  </h1><br><p>       ?   GC ‚Äî  , ,  ,        GC. </p><br><p>         ,    -  GC   . ,     ,            GC (, Serial GC  Parallel GC),         . </p><br><blockquote>  .  , 5-6  2019,  JPoint ‚Äî    Java-.           ‚Äî OpenJDK, GraalVM, Kotlin  .        <a href="https://jpoint.ru/%3Futm_source%3Dhabr%26utm_medium%3D443250">  </a> . </blockquote></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/443250/">https://habr.com/ru/post/443250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443240/index.html">Understanding Q-learning, the problem of "walking on a rock"</a></li>
<li><a href="../443242/index.html">Quarkus - supersonic subatomic Java. Framework Overview</a></li>
<li><a href="../443244/index.html">Analysis of tasks. Binpoisk_1</a></li>
<li><a href="../443246/index.html">How we reinvented the IP PBX Askozia, after the project was sold and closed by the developer</a></li>
<li><a href="../443248/index.html">PRP and HSR seamless redundancy protocols</a></li>
<li><a href="../443252/index.html">Modular bot ants with memory</a></li>
<li><a href="../443256/index.html">PowerShell, dump my experience</a></li>
<li><a href="../443258/index.html">Gotify - open source project for delivering notifications and sending messages to the server</a></li>
<li><a href="../443260/index.html">Migrate to Zimbra without risking your business using a common domain</a></li>
<li><a href="../443262/index.html">Bad advice: how to write technical documentation? Part Three and Last</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>