<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Multithread Observer in C ++ (practice)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are many variations on this pattern, but most examples are not suitable for multi-threaded applications. 
 In this article, I want to share the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Multithread Observer in C ++ (practice)</h1><div class="post__text post__text-html js-mediator-article">  There are many variations on this pattern, but most examples are not suitable for multi-threaded applications. <br>  In this article, I want to share the experience of using a pattern in multi-threaded applications and describe the main problems that I had to face. <br>  The purpose of this article is to draw the attention of developers to the problems that can be encountered when creating multi-threaded applications.  Identify pitfalls in the implementation of communication between components in a multi-threaded application. <br>  If you need a ready-made solution, pay attention to the Signals2 library, which has been included in boost since <a href="http://www.boost.org/users/history/version_1_39_0">May 2009</a> . <br>  I'm not trying to provide a solution that could be used in a finished form.  But nevertheless, having familiarized with the material, you can do without the use of third-party libraries, in those projects in which they are not available or undesirable for some reason (drivers, low-level applications, etc.). <br><a name="habracut"></a><br><h4>  Subject area </h4><br><h5>  Characters </h5><br>  NotificationSender - an object that sends messages. <br>  Typically, this is a workflow that notifies you of a change in its state that needs to be displayed on the user interface. <br>  NotificationListener - an object that implements the processing of notifications. <br>  Typically, this is an object that controls the display of the part of the user interface associated with the background task. <br>  There can be many such objects, and they can be connected / disconnected dynamically (for example, opening a remote window where task execution details are shown) <br>  NotificationDispatcher - an object that controls subscribers and sending messages. <br><br><h5>  Interaction between objects </h5><br>  Sending messages to all subscribers. <br>  The subscription / withdrawal process. <br>  The lifetime of objects. <br>  This article describes the method of synchronous messaging.  This means that the call to the SendMessage function will be synchronous, and the thread calling this method will wait for all subscribers to process the messages.  In some cases, this approach is more convenient asynchronous mailing, but it also has difficulty with the termination of the subscription. <br><br><h4>  The simplest implementation for a single-threaded environment </h4><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> __int64 SubscriberId; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CSubscriber</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~CSubscriber(){} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pContext)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-function">SubscriberId </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSubscriberId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (SubscriberId)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CDispatcher</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;CSubscriber*&gt; CSubscriberList; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-function">SubscriberId </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CSubscriber* pNewSubscriber)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_SubscriberList.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_SubscriberList[i]-&gt;GetSubscriberId() == pNewSubscriber-&gt;GetSubscriberId()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } m_SubscriberList.push_back(pNewSubscriber); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pNewSubscriber-&gt;GetSubscriberId(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unsubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SubscriberId id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_SubscriberList.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_SubscriberList[i]-&gt;GetSubscriberId() == id) { m_SubscriberList.erase(m_SubscriberList.begin() + i); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pContext)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_SubscriberList.size(); ++i) { m_SubscriberList[i]-&gt;MessageHandler(pContext); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: CSubscriberList m_SubscriberList; };</code> </pre> <br>  Here the unique identifier of the subscriber is the address of the object of the subscriber, the function GetSubscriberId always returns the same value for one object of the subscriber regardless of the type conversion. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Usage example </h5><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CListener</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CSubscriber { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pContext)</span></span></span><span class="hljs-function"> </span></span>{ wprintf(<span class="hljs-string"><span class="hljs-string">L"%d\n"</span></span>, *((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)pContext)); } }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _tmain(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argc, _TCHAR* argv[]) { CDispatcher Dispatcher; CListener Listener1; CListener Listener2; Dispatcher.Subscribe(&amp;Listener1); Dispatcher.Subscribe(&amp;Listener2); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; ++i) { Dispatcher.SendMessage(&amp;i); } Dispatcher.Unsubscribe(Listener2.GetSubscriberId()); Dispatcher.Unsubscribe(Listener1.GetSubscriberId()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><h4>  Disable the subscriber inside the message handler </h4><br>  In the example there is a problem that is not related to multithreading.  This problem occurs when we try to unsubscribe inside a MessageHandler handler.  This problem will be solved by copying the list of subscribers before calling the MessageHandler. <br><br><h4>  Go to a multithreaded environment. </h4><br>  With one thread, such code will work quite stably. <br>  Let's see what happens when multiple threads are running. <br><pre> <code class="cpp hljs">CDispatcher g_Dispatcher; <span class="hljs-function"><span class="hljs-function">DWORD WINAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WorkingThread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PVOID pParam)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>;;++i) { g_Dispatcher.SendMessage(&amp;i); } }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _tmain(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argc, _TCHAR* argv[]) { ::CreateThread(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, WorkingThread, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); CListener Listener1; CListener Listener2; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { g_Dispatcher.Subscribe(&amp;Listener1); g_Dispatcher.Subscribe(&amp;Listener2); g_Dispatcher.Unsubscribe(Listener1.GetSubscriberId()); g_Dispatcher.Unsubscribe(Listener2.GetSubscriberId()); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Sooner or later, a crash will occur. <br>  The problem is to add / remove subscribers and simultaneously send notifications (multi-threaded access to CDispatcher :: m_SubscriberList in our example). <br>  Here you need to synchronize access to the list of subscribers. <br><br><h4>  Synchronize access to the list of subscribers </h4><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CDispatcher</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;CSubscriber*&gt; CSubscriberList; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-function">SubscriberId </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CSubscriber* pNewSubscriber)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">CScopeLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScopeLocker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m_Lock)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_SubscriberList.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_SubscriberList[i]-&gt;GetSubscriberId() == pNewSubscriber-&gt;GetSubscriberId()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } m_SubscriberList.push_back(pNewSubscriber); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pNewSubscriber-&gt;GetSubscriberId(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unsubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SubscriberId id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">CScopeLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScopeLocker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m_Lock)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_SubscriberList.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_SubscriberList[i]-&gt;GetSubscriberId() == id) { m_SubscriberList.erase(m_SubscriberList.begin() + i); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pContext)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">CScopeLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScopeLocker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m_Lock)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_SubscriberList.size(); ++i) { m_SubscriberList[i]-&gt;MessageHandler(pContext); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: CSubscriberList m_SubscriberList; CLock m_Lock; };</code> </pre><br>  Access synchronization was implemented using synchronization objects (Critical section or Mutex). <br>  For greater portability and in order not to be distracted from the essence of what is happening, we abstract away from direct calls to platform-dependent functions, such as EnterCriticalSection.  For this is the class CLock. <br>  For robust c ++ exceptions, it is convenient to use the RAII technology, namely the CScopeLocker class, which captures the synchronization object in the constructor and frees it in the destructor. <br>  With this implementation, the program will not fall, but another unpleasant situation awaits us. <br><br><h4>  Combating deadlock </h4><br>  Suppose we have a thread that performs some kind of background task and there is a window that displays the progress of the task. <br>  As a rule, a thread sends a notification to a window class, which in turn calls the system function SendMessage, which initiates some actions in the context of a window procedure. <br>  The system function SendMessage is blocking, it sends a message to the window stream and waits for it to process it. <br>  If the connection / disconnection of the object-listener will also occur in the context of a window procedure (in the window stream), a mutual blocking of threads, the so-called deadlock, is possible. <br>  Such a deadlock can be rarely reproduced (at the time of calling Subscribe / Unsubscribe and simultaneously calling MessageHandler in a separate thread) <br>  The following code emulates a situation with a blocking call to the SendMessage system function. <br><br><pre> <code class="cpp hljs">CDispatcher g_Dispatcher; CLock g_Lock; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CListener</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CSubscriber { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pContext)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   SendMessage g_Lock.Lock(); wprintf(L"%d\n", *((int*)pContext)); g_Lock.Unlock(); } }; DWORD WINAPI WorkingThread(PVOID pParam) { for(int i = 0;;++i) { g_Dispatcher.SendMessage(&amp;i); } }; int _tmain(int argc, _TCHAR* argv[]) { ::CreateThread(NULL, 0, WorkingThread, NULL, 0, NULL); CListener Listener1; CListener Listener2; for(;;) { //    (  ) g_Lock.Lock(); g_Dispatcher.Subscribe(&amp;Listener1); g_Dispatcher.Subscribe(&amp;Listener2); g_Lock.Unlock(); Sleep(0); g_Lock.Lock(); g_Dispatcher.Unsubscribe(Listener1.GetSubscriberId()); g_Dispatcher.Unsubscribe(Listener2.GetSubscriberId()); g_Lock.Unlock(); } return 0; }</span></span></code> </pre><br>  The problem is that the main thread captures the global synchronization object g_Lock (similar to a window procedure, it runs in the context of a window stream), and then calls the Subscribe / Unsubscribe method, which inside tries to capture the second synchronization object CDispatcher :: m_Lock. <br>  At this point, the worker thread sends a notification, capturing CDispatcher :: m_Lock in the CDispatcher :: SendMessage function, and then tries to capture the global synchronization object g_Lock (in the same way as the window, it calls the SendMessage system function). <br><br><pre> Window Flow A -&gt; B
 Workflow B -&gt; A
</pre><br>  This can be called the classic deadlock. <br>  The problem lies in the CDispatcher :: SendMessage () function. <br>  Here the rule should be followed - you cannot call a callback function while capturing any synchronization object. <br>  So, remove the lock when sending notifications. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pContext)</span></span></span><span class="hljs-function"> </span></span>{ CSubscriberList SubscriberList; { <span class="hljs-function"><span class="hljs-function">CScopeLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScopeLocker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m_Lock)</span></span></span></span>; SubscriberList = m_SubscriberList; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; SubscriberList.size(); ++i) { SubscriberList[i]-&gt;MessageHandler(pContext); } }</code> </pre><br><h4>  Monitoring subscriber lifetime </h4><br>  After we removed the deadlock, another problem appeared - the lifetime of the subscriber objects. <br>  We no longer have a guarantee that the MessageHandler method will not be called after calling Unsubscribe, and therefore we cannot delete the subscriber object immediately after calling Unsubscribe. <br>  In this situation, it is easiest to control the lifetime of the subscriber objects using the reference count. <br>  To do this, you can use COM technology - inherit the CSubscriber interface from IUnknown and use ATL CComPtr for the list of subscriber objects, that is, replace std :: vector &lt;CSubscriber *&gt; with std :: vector &lt;CComPtr&gt;. <br>  But such an implementation is fraught with additional costs for implementing subscriber classes, since in each of them the AddRef / Release methods and the unnecessary QueryInterface should be implemented, although if the project actively uses COM, then this approach can be beneficial. <br>  Smart pointers are well suited to control the lifetime of subscriber objects using a link counter. <br><br><h4>  Simple implementation for multithreaded environment </h4><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> __int64 SubscriberId; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CSubscriber</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~CSubscriber(){} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pContext)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-function">SubscriberId </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSubscriberId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (SubscriberId)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;} }; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;CSubscriber&gt; CSubscriberPtr; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CDispatcher</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;CSubscriberPtr&gt; CSubscriberList; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-function">SubscriberId </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CSubscriberPtr pNewSubscriber)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">CScopeLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScopeLocker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m_Lock)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_SubscriberList.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_SubscriberList[i]-&gt;GetSubscriberId() == pNewSubscriber-&gt;GetSubscriberId()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } m_SubscriberList.push_back(pNewSubscriber); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pNewSubscriber-&gt;GetSubscriberId(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unsubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SubscriberId id)</span></span></span><span class="hljs-function"> </span></span>{ CSubscriberPtr toRelease; <span class="hljs-function"><span class="hljs-function">CScopeLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScopeLocker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m_Lock)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_SubscriberList.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_SubscriberList[i]-&gt;GetSubscriberId() == id) { toRelease = m_SubscriberList[i]; m_SubscriberList.erase(m_SubscriberList.begin() + i); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pContext)</span></span></span><span class="hljs-function"> </span></span>{ CSubscriberList SubscriberList; { <span class="hljs-function"><span class="hljs-function">CScopeLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScopeLocker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m_Lock)</span></span></span></span>; SubscriberList = m_SubscriberList; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; SubscriberList.size(); ++i) { SubscriberList[i]-&gt;MessageHandler(pContext); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: CSubscriberList m_SubscriberList; CLock m_Lock; };</code> </pre><br>  In this implementation, I replaced the ‚Äúbare‚Äù CSubscriber * pointer with a ‚Äúsmart‚Äù pointer with a reference counter, which turned out to be in the boost library. <br>  Also, I added the toRelease variable to the Unsubscribe function in order to call the subscriber's destructor after the Unlock call (you cannot call the callback function, including the destructor of the subscriber object, capturing any synchronization object). <br>  It is worth paying attention to the fact that the SendMessage function copies the list of smart pointers (after copying, all pointers increase their reference counters, and when they exit the function, they decrease, which controls the lifetime of the subscriber objects) <br><br><h4>  We are testing </h4><br><pre> <code class="cpp hljs">CDispatcher g_Dispatcher; CLock g_Lock; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CListener</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CSubscriber { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pContext)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   SendMessage g_Lock.Lock(); wprintf(L"%d\n", *((int*)pContext)); g_Lock.Unlock(); } }; DWORD WINAPI WorkingThread(PVOID pParam) { for(int i = 0;;++i) { g_Dispatcher.SendMessage(&amp;i); } }; int _tmain(int argc, _TCHAR* argv[]) { ::CreateThread(NULL, 0, WorkingThread, NULL, 0, NULL); for(;;) { boost::shared_ptr&lt;CListener&gt; pListener1(new CListener); boost::shared_ptr&lt;CListener&gt; pListener2(new CListener); //    (  ) g_Lock.Lock(); g_Dispatcher.Subscribe(pListener1); g_Dispatcher.Subscribe(pListener2); g_Lock.Unlock(); Sleep(0); g_Lock.Lock(); g_Dispatcher.Unsubscribe(pListener1-&gt;GetSubscriberId()); g_Dispatcher.Unsubscribe(pListener2-&gt;GetSubscriberId()); g_Lock.Unlock(); } return 0; }</span></span></code> </pre><br><h4>  Optimized implementation for multithreaded environment </h4><br>  As a rule, the SendMessage function call will occur much more frequently than Subscribe / Unsubscribe.  With a large number of subscribers, the bottleneck may be copying the list of subscribers within SendMessage. <br>  Copying the list of subscribers can be transferred in the function Subscribe / Unsubscribe.  It will be similar to the methodology of the lock-free algorithms. <br>  The CDispatcher object will not keep the list of subscribers directly, but with a smart pointer.  Inside the SendMessage function, we will receive a pointer to the current list of subscribers and work with it.  In the Subscribe / Unsubscribe functions, we will create a new list of subscribers each time and redirect the pointer inside the CDispatcher object to a new list of subscribers.  Thus, while the pointer to the list of subscribers in the CDispatcher object will already point to a new list of subscribers, the SendMessage function will still work with the old list.  Since no one changes the old list of subscribers, everything will work stably in a multithreaded environment. <br>  In principle, you can slightly modify the functions of Subscribe / Unsubscribe and implement a completely lock-free algorithm, but this is another topic. <br>  Medot Unsubscribe is asynchronous and does not guarantee after its completion a complete termination of the mailing, half the solution - the subscriber receives a notice of termination of the subscription using the function UnsubscribeHandler.  To implement this behavior, an intermediate class CSubscriberItem was added, which in its destructor invokes the UnsubscribeHandler function. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Observer { <span class="hljs-comment"><span class="hljs-comment">////////////////////////// // Subscriber ////////////////////////// typedef unsigned __int64 SubscriberId; class CSubscriber { public: virtual ~CSubscriber(){} virtual void MessageHandler(void* pContext) = 0; virtual void UnsubscribeHandler() = 0; SubscriberId GetSubscriberId() {return (SubscriberId)this;} }; typedef boost::shared_ptr&lt;CSubscriber&gt; CSubscriberPtr; ////////////////////////////////////////////////////////////////////// // Dispatcher /////////////////////////////////// class CDispatcher { private: class CSubscriberItem { public: CSubscriberItem(CSubscriberPtr pSubscriber) :m_pSubscriber(pSubscriber) { } ~CSubscriberItem() { m_pSubscriber-&gt;UnsubscribeHandler(); }; CSubscriberPtr Subscriber()const {return m_pSubscriber;} private: CSubscriberPtr m_pSubscriber; }; typedef boost::shared_ptr&lt;CSubscriberItem&gt; CSubscriberItemPtr; typedef std::vector&lt;CSubscriberItemPtr&gt; CSubscriberList; typedef boost::shared_ptr&lt;CSubscriberList&gt; CSubscriberListPtr; public: CDispatcher() { } private: CDispatcher(const CDispatcher&amp;){} CDispatcher&amp; operator=(const CDispatcher&amp;){return *this;} public: SubscriberId Subscribe(CSubscriberPtr pNewSubscriber) { //Declaration of the next shared pointer before ScopeLocker //prevents release of subscribers from under lock CSubscriberListPtr pNewSubscriberList(new CSubscriberList()); //Enter to locked section CScopeLocker ScopeLocker(m_Lock); if(m_pSubscriberList) { //Copy existing subscribers pNewSubscriberList-&gt;assign(m_pSubscriberList-&gt;begin(), m_pSubscriberList-&gt;end()); } for(size_t i = 0; i &lt; pNewSubscriberList-&gt;size(); ++i) { CSubscriberItemPtr pSubscriberItem = (*pNewSubscriberList)[i]; if(pSubscriberItem-&gt;Subscriber()-&gt;GetSubscriberId() == pNewSubscriber-&gt;GetSubscriberId()) { return 0; } } //Add new subscriber to new subscriber list pNewSubscriberList-&gt;push_back(CSubscriberItemPtr(new CSubscriberItem(pNewSubscriber))); //Exchange subscriber lists m_pSubscriberList = pNewSubscriberList; return pNewSubscriber-&gt;GetSubscriberId(); } bool Unsubscribe(SubscriberId id) { //Declaration of the next shared pointers before ScopeLocker //prevents release of subscribers from under lock CSubscriberItemPtr pSubscriberItemToRelease; CSubscriberListPtr pNewSubscriberList; //Enter to locked section CScopeLocker ScopeLocker(m_Lock); if(!m_pSubscriberList) { //No subscribers return false; } pNewSubscriberList = CSubscriberListPtr(new CSubscriberList()); for(size_t i = 0; i &lt; m_pSubscriberList-&gt;size(); ++i) { CSubscriberItemPtr pSubscriberItem = (*m_pSubscriberList)[i]; if(pSubscriberItem-&gt;Subscriber()-&gt;GetSubscriberId() == id) { pSubscriberItemToRelease = pSubscriberItem; } else { pNewSubscriberList-&gt;push_back(pSubscriberItem); } } //Exchange subscriber lists m_pSubscriberList = pNewSubscriberList; if(!pSubscriberItemToRelease.get()) { return false; } return true; } void SendMessage(void* pContext) { CSubscriberListPtr pSubscriberList; { CScopeLocker ScopeLocker(m_Lock); if(!m_pSubscriberList) { //No subscribers return; } //Get shared pointer to an existing list of subscribers pSubscriberList = m_pSubscriberList; } //pSubscriberList pointer to copy of subscribers' list for(size_t i = 0; i &lt; pSubscriberList-&gt;size(); ++i) { (*pSubscriberList)[i]-&gt;Subscriber()-&gt;MessageHandler(pContext); } } private: CSubscriberListPtr m_pSubscriberList; CLock m_Lock; }; }; //namespace Observer</span></span></code> </pre><br><h4>  Links </h4><br>  Library boost :: signals2 <a href="">article</a> <br>  Smart pointers <a href="http://www.ozon.ru/context/detail/id/88891/">Jeff Alger</a> <br>  Resource Acquisition Is Initialization (RAII) <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">Wikipedia</a> <br>  Comments on the first version of this article can be found <a href="http://rsdn.ru/forum/cpp/4053177.flat.aspx">here.</a> </div><p>Source: <a href="https://habr.com/ru/post/108857/">https://habr.com/ru/post/108857/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../10885/index.html">antiminusovschina</a></li>
<li><a href="../108850/index.html">Draft Mozilla Drumbeat is gaining momentum</a></li>
<li><a href="../108854/index.html">Glavstartom on TechCrunch</a></li>
<li><a href="../108855/index.html">How to get loose designer. Tips from personal experience</a></li>
<li><a href="../108856/index.html">The default amount of Instances on Amazon EC2 is 20 pieces.</a></li>
<li><a href="../108858/index.html">900 terabytes per g bacteria</a></li>
<li><a href="../108859/index.html">The full program of the conference MageConf & ZFConf Ukraine is available.</a></li>
<li><a href="../10886/index.html">Profession Third Floor Reporter</a></li>
<li><a href="../108860/index.html">Is there an alternative to the giants of the database market?</a></li>
<li><a href="../108861/index.html">Advertising in social networks: whether to wait for sales?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>