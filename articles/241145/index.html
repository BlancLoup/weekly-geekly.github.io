<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rushim Captcha SilkRoad</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Silk Road, the famous black market, was closed about a year ago. Until recently, I thought he was dead. This would make writing an article easier, but...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rushim Captcha SilkRoad</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/5ff/316/0af/5ff3160afa964a19b572ee245ef01ecb.png"><br><br>  Silk Road, the famous black market, was closed about a year ago.  Until recently, I thought he was dead.  This would make writing an article easier, but not so well.  I just read about his return to the network. <br><br>  Now I want to delve into the code that I wrote a few years ago to disassemble the captcha mechanism of the ‚Äúold‚Äù version of the site. <br><a name="habracut"></a><br><h4>  Motivation </h4><br>  I first heard about The Silk Road in <a href="http://www.gwern.net/Silk%2520Road">articles gwern'a</a> .  After connecting Tor, I got the opportunity to see this site. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      My first thought is this: there is a lot of interesting real-time market data that is difficult to access programmatically. <br><br>  Is it really <a href="http://en.wikipedia.org/wiki/Drugwars">Drug Wars</a> with a real price upgrade? <br><br>  Indices that show <code>MJ ‚ñ≤0.21</code> , <code>COKE ‚ñº3.53</code> ? <br><br>  After a while, I could collect a price history for all these products. <br><br>  I have already begun to imagine graphs, schemes and cases of <code>Sr::Listing</code> .  First we need to automate the authorization process. <br><br>  All the code in this article will be presented in Ruby, but I will not publish the API for two reasons: <br><br><ol><li>  Most likely, it just does not work anymore; </li><li>  It has never been neatly decorated. </li></ol><br><h4>  Tor </h4><br>  Silk Road has been converted to a hidden service TOR.  So our API should call Tor. <br><br>  <a href="">Vidalia</a> opens locally SOCKS5 proxy on startup.  You must configure the client for correct HTTP requests.  Fortunately, <a href="https://github.com/astro/socksify-ruby">socksify gem</a> allows us to do this.  This trick will allow us to convert SOCKS requests in our <code>auto_configure</code> application. <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'socksify'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'socksify/http'</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TorError</span></span></span><span class="hljs-class"> &lt; RuntimeError;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tor</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment"># Loads the torproject test page and tests for the success message. # Just to be sure. def self.test_tor? uri = 'https://check.torproject.org/?lang=en-US' begin page = Net::HTTP.get(URI.parse(uri)) return true if page.match(/browser is configured to use Tor/i) rescue ; end false end # Our use case has the Tor SOCKS5 proxy running locally. On unix, we use # `lsof` to see the ports `tor` is listening on. def self.find_tor_ports p = `lsof -i tcp | grep "^tor" | grep "\(LISTEN\)"` p.each_line.map do |l| m = l.match(/localhost:([0-9]+) /) m[1].to_i end end # Configures future connections to use the Tor proxy, or raises TorError def self.auto_configure! return true if </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@configured</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> TCPSocket::socks_server = 'localhost' ports = find_tor_ports ports.each do |p| TCPSocket::socks_port = p if test_tor? </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@configured</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> = true return true end end TCPSocket::socks_server = nil TCPSocket::socks_port = nil fail TorError, "SOCKS5 connection failed; ports: #{ports}" end end end</span></span></span></span></code> </pre><br>  All is ready.  We have created a fairly simple process. <br><br><h4>  Captcha </h4><br>  Now we come to the topic of the article: SilkRoad captcha bypass. <br><br>  I've never done this before, so it should be interesting.  All the above code is the result of six hours of work. <br><br>  I decided to call the project successful if the application recognizes text with an accuracy of one third of all codes. <br><br>  In the end, it turned out to do something more than planned. <br><br>  Due to the fact that the authors of Silk Road had to develop paranoia in themselves, they could not use services like reCAPTCHA.  I‚Äôm not sure that their decision was samopisny in the end, but let's look at a few examples: <br><br><img src="//habrastorage.org/files/8dc/896/893/8dc896893c7247b6a275174b6fee7774.jpg"><br><img src="//habrastorage.org/files/319/d58/411/319d5841113c47e0a9b914077d1979e7.jpg"><br><img src="//habrastorage.org/files/8d8/0d1/73a/8d80d173a3d94988b5c8551405c3ee60.jpg"><br><img src="//habrastorage.org/files/274/b59/3d6/274b593d6e954c76adcd82304e116422.jpg"><br><img src="http://1450829327612039001694"><br><br>  There are several obvious features of this captcha: <br><br><ol><li>  Standard format: a dictionary word cropped to five characters, along with a number from 0 to 999; </li><li>  The font never changes; </li><li>  Any symbol can be at any position along the X axis; </li><li>  Any symbol can be rotated, but only a few degrees; </li><li>  In the background, there is something like a spiral that does not painfully contrast with the text; </li><li>  They are all horrible and pink, which gives us one channel of color information. </li></ol><br>  I wrote <a href="http://docs.seattlerb.org/mechanize/">Mechanize</a> , which downloaded 2,000 captcha examples from the site at two-second intervals.  After I decided them by hand, calling in the format (text) <code>.jpg</code> .  It was very sad, believe me. <br><br>  But there are pluses: I received many test samples in my new application. <br><br><h4>  We remove the background </h4><br>  The most, in my opinion, the right step to start.  At this stage, I wanted to get images in shades of gray, containing only characters (preferably), as well as screening out all the "noise" of the image. <br><br>  Using Gimp, I played with several effects and several sequences.  I had mistakes, but ultimately I got this: <br><br>  Original: <br><br><img src="http://1450829327612039001694"><br><br>  Corrected: <br><br><img src="//habrastorage.org/files/d4a/359/f1a/d4a359f1a4024fbf95cbb7b180d5c1f2.png"><br><br>  Shades of gray, 0.09: <br><img src="//habrastorage.org/files/a1b/704/a26/a1b704a2623e44ffb2a8bd599f6aaf66.png"><br><br>  The result was obtained with the following code for <a href="http://www.imagemagick.org/RMagick/doc/">RMagick</a> : <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># Basic image processing gets us to a black and white image # with most background removed def remove_background(im) im = im.equalize im = im.threshold(Magick::MaxRGB * 0.09) # the above processing leaves a black border. Remove it. im = im.trim '#000' im end</span></span></code> </pre><br><br>  This freed our image from unnecessary details, but still there was ‚Äúgarbage‚Äù - small black dots between the letters.  Let's get rid of them: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># Consider a pixel "black enough"? In a grayscale sense. def black?(p) return p.intensity == 0 || (Magick::MaxRGB.to_f / p.intensity) &lt; 0.5 end # True iff [x,y] is a valid pixel coordinate in the image def in_bounds?(im, x, y) return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; im.columns &amp;&amp; y &lt; im.rows end # Returns new image with single-pixel "islands" removed, # see: Conway's game of life. def despeckle(im) xydeltas = [[-1, -1], [0, -1], [+1, -1], [-1, 0], [+1, 0], [-1, +1], [0, +1], [+1, +1]] j = im.dup j.each_pixel do |p, x, y| if black?(p) island = true xydeltas.each do |dx2, dy2| if in_bounds?(j, x + dx2, y + dy2) &amp;&amp; black?(j.pixel_color(x + dx2, y + dy2)) island = false break end end im = im.color_point(x, y, '#fff') if island end end im end</span></span></code> </pre><br><br>  So we got something like this: <br><img src="//habrastorage.org/files/864/152/842/8641528420ca48cb9cca55ebff09fd77.png"><br><br>  Wonderful. <br><br><h4>  Segmentation </h4><br>  Now I want to cut our captcha into bitmaps so that each contains one character.  We move around the image from left to right, looking for white indents. <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># returns true if column "x" is blank (non-black) def blank_column?(im, x) (0 ... im.rows).each do |y| return false if black?(im.pixel_color(x, y)) end true end # finds columns of white, and splits the image into characters, yielding each def each_segmented_character(im) return enum_for(__method__, im) unless block_given? st = 0 x = 0 while x &lt; im.columns # Zoom over to the first non-blank column x += 1 while x &lt; im.columns &amp;&amp; blank_column?(im, x) # That's now our starting point. st = x # Zoom over to the next blank column, or end of the image. x += 1 while x &lt; im.columns &amp;&amp; (!blank_column?(im, x) || (x - st &lt; 2)) # slivers smaller than this can't possibly work: it's noise. if x - st &gt;= 4 # The crop/trim here also removes vertical whitespace, which puts the # resulting bitmap into its minimal bounding box. yield im.crop(st, 0, x - st, im.rows).trim('#fff') end end end</span></span></code> </pre><br><br>  This cuts off our captcha on the same pieces: <br><img src="//habrastorage.org/files/c54/cbb/deb/c54cbbdeb7de4966be386b5d82af59fd.png"><br><br>  Then each piece turns into a separate box with a letter, thus separating from the others. <br><br>  I executed this code for many of the previously prepared caps, and this is what happened in some cases: <br><br><img src="//habrastorage.org/files/4d5/93f/0e8/4d593f0e81094171828aa5e839e3bfe1.png"><br><br>  Think of it as a histogram.  Dark areas are places where the algorithm cut the image.  You can see offsets ... <br><br>  We also see how the rotation of symbols affects the clarity of the result.  If the characters rotated at a large angle, then our task would be significantly more complicated. <br><br>  So, every character is quite possible to read.  Since the letters are taken from an English dictionary, the more frequently used symbols are more clearly visible.  We will review this question later. <br><br>  But did not know that J is used so rarely! <br><br><h4>  Neural networks for character recognition </h4><br>  There is a cool Ruby gem called <a href="http://www.ai4r.org/">AI4R</a> .  Since <code>Ai4r::Positronic</code> not always available, I decided to use a neural network. <br><br>  You start with an empty array of bits.  You teach him drawings of famous solutions: <br><br><ul><li>  "Such a model is A." </li><li>  "And this model is also in A." </li><li>  "This model is found in V." </li></ul><br>  After checking for a variety of examples, several suitable candidate symbols appear, and the network will tell you the correct option using its base. <br><br>  But there are difficulties.  The more characters you have and the more parameters for recognition you specify, the longer it will take to train the algorithm. <br><br>  I took each character into squares, made it 20x20 in size and applied a monochrome effect, and began training. <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'ai4r'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'RMagick'</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Brain</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initialize</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">keys</span></span></span><span class="hljs-class"> = *(('</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">'..'</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">z</span></span></span><span class="hljs-class">').</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">to_a</span></span></span><span class="hljs-class"> + ('0'..'9').</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">to_a</span></span></span><span class="hljs-class">) @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ai</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ai4r::NeuralNetwork::Backpropagation</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class">([</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GRID_SIZE</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GRID_SIZE</span></span></span><span class="hljs-class">, @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">keys</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size</span></span></span><span class="hljs-class">]) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment"># Returns a flat array of 0 or 1 from the image data, suitable for # feeding into the neural network def to_data(image) # New image of our actual grid size, then paste it over padded = Magick::Image.new(GRID_SIZE, GRID_SIZE) padded = padded.composite(image, Magick::NorthWestGravity, Magick::MultiplyCompositeOp) padded.get_pixels(0, 0, padded.columns, padded.rows).map do |p| ImageProcessor.black?(p) ? 1 : 0 end end # Feed this a positive example, eg, train('a', image) def train(char, image) outputs = [0] * </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@keys</span></span></span></span><span class="hljs-class"><span class="hljs-comment">.length outputs[ </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@keys</span></span></span></span><span class="hljs-class"><span class="hljs-comment">.index(char) ] = 1.0 </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@ai</span></span></span></span><span class="hljs-class"><span class="hljs-comment">.train(to_data(image), outputs) end # Return all guesses, eg, {'a' =&gt; 0.01, 'b' =&gt; '0.2', ...} def classify_all(image) results = </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@ai</span></span></span></span><span class="hljs-class"><span class="hljs-comment">.eval(to_data(image)) r = {} </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@keys</span></span></span></span><span class="hljs-class"><span class="hljs-comment">.each.with_index do |v, i| r[v] = results[i] end r end # Returns best guess def classify(image) res = </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@ai</span></span></span></span><span class="hljs-class"><span class="hljs-comment">.eval(to_data(image)) </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@keys</span></span></span></span><span class="hljs-class"><span class="hljs-comment">[res.index(res.max)] end end end</span></span></span></span></code> </pre><br><br>  I changed my mechanize tool to load new captchas.  This time, the captcha solved the algorithm, and then performed authorization in the system. <br><br>  Correctly guessed codes are automatically broken down into characters by character and added to the base of examples to improve the application knowledge. <br><br>  When the authorization attempt failed, the captcha sent a separate folder so that I could solve it myself.  As soon as I changed the name of the captcha to her answer, the algorithm took the image, divided it into squares and replenished its base.  From time to time I had to solve a couple of dozen examples. <br><br>  After several hours of training, the percentage of successfully solved problems was 90%. <br><br>  Unfortunately, the captcha length was usually equal to eight characters, therefore, the probability of a successful solution was 0.90 ** 8, or 43%.  My initial goal was achieved, but I wanted more. <br><br><h4>  Use of the dictionary and frequency of use of letters </h4><br>  At times, our network gave strange candidate solutions that did not correspond to reality.  Something weird that didn't fit the format.  She recognized characters independently and combined the result without further context. <br><br>  But the ‚Äúverbal‚Äù part of the captcha was not random letters, but rather parts of real words.  Cut off words from a special list.  If I had a sheet, then it would be possible to build a logical chain of reasoning to improve the result of character recognition.  This is how I generated my word list: <br><br><pre> <code class="ruby hljs">cat /usr/share/dict/words *.txt <span class="hljs-params"><span class="hljs-params">| tr AZ az |</span></span> grep -v <span class="hljs-string"><span class="hljs-string">'[^az]'</span></span> \ <span class="hljs-params"><span class="hljs-params">| cut -c1-5 |</span></span> grep <span class="hljs-string"><span class="hljs-string">'...'</span></span> <span class="hljs-params"><span class="hljs-params">| sort |</span></span> uniq &gt; dict5.txt</code> </pre><br><br>  Afterwards, I could assume that <code>dict5.txt</code> contained all the possible options that the captcha could contain. <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># Returns the "word" and "number" part of a captcha separately. # "word" takes the longest possible match def split_word(s) s.match(/(.+?)?(\d+)?\z/.to_a.last(2) rescue [nil, nil] end def weird_word?(s) w, d = split_word(s) # nothing matched? return true if w.nil? || d.nil? # Digit in word part?, Too long? return true if w.match /\d/ || w.size &gt; 5 # Too many digits? return true if d.size &gt; 3 # Yay return false end def in_dict?(w) return dict.bsearch { |p| p &gt;= w } == w end</span></span></code> </pre><br><br>  But how to fix strange words that are not in the dictionary? <br><br>  My first thought was to look at the list of candidates of the system, but the matter was different.  The script performed poor-quality segmentation, alas <br><br>  Let's take a look at this interesting table: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># az English text letter frequency, according to Wikipedia LETTER_FREQ = { a: 0.08167, b: 0.01492, c: 0.02782, d: 0.04253, e: 0.12702, f: 0.02228, g: 0.02015, h: 0.06094, i: 0.06966, j: 0.00153, k: 0.00772, l: 0.04025, m: 0.02406, n: 0.06749, o: 0.07507, p: 0.01929, q: 0.00095, r: 0.05987, s: 0.06327, t: 0.09056, u: 0.02758, v: 0.00978, w: 0.02360, x: 0.00150, y: 0.01974, z: 0.00074 }</span></span></code> </pre><br><br>  Noticed our poor and rarely used J again? <br><br>  Peter Norvig wrote an interesting article <a href="http://norvig.com/spell-correct.html">How to write a pronunciation corrector</a> .  We have a dictionary and, presumably, a word with a typo.  Let's fix this: <br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># This finds every dictionary entry that is a single replacement away from # word. It returns in a clever priority: it tries to replace digits first, # then the alphabet, in z..e (frequency) order. As we're just focusing on the # "word" part, "9" is most definitely a mistake, and "z" is more likely a # mistake than "e". def edit1(word) # Inverse frequency, "zq...e" letter_freq = LETTER_FREQ.sort_by { |k, v| v }.map(&amp;:first).join # Total replacement priority: 0..9zq..e replacement_priority = ('0'..'9').to_a.join + letter_freq # Generate splits, tagged with the priority, then sort them so # the splits on least-frequent english characters get processed first splits = word.each_char.with_index.map do |c, i| # Replace what we're looking for with a space w = word.dup; w[i] = ' ' [replacement_priority.index(c), w] end splits.sort_by!{|k,v| k}.map!(&amp;:last) # Keep up with results so we don't end up with duplicates yielded = [] splits.each do |w| letter_freq.each_char do |c| candidate = w.sub(' ', c) next if yielded.include?(candidate) if in_dict?(candidate) yielded.push(candidate) yield candidate end end end end</span></span></code> </pre><br><br>  The big trick is to replace.  Using the table of frequency of use of symbols and a list of possible words that differ only by one symbol from the options proposed by the network, we simply replace the symbol with the one needed to correct the "typo". <br><br>  This step increased the success rate from 43% to 56%.  It made me realize that the goal is really achieved. <br><br>  <i>An article about breaking a new (second) Captcha SilkRoad will be published soon.</i>  <i>Do not miss!</i> <br><br>  Thanks for the idea of ‚Äã‚Äãthe article <a href="https://habrahabr.ru/users/ilusha_sergeevich/" class="user_link">ilusha_sergeevich</a> </div><p>Source: <a href="https://habr.com/ru/post/241145/">https://habr.com/ru/post/241145/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../241135/index.html">Introduction to HTML Import</a></li>
<li><a href="../241137/index.html">How Anakin Skywalker became Darth Vader. Android virus in picture .png</a></li>
<li><a href="../241139/index.html">I / O Schedule 2014: a bad example for learning</a></li>
<li><a href="../241141/index.html">Why is a stock exchange an IT company?</a></li>
<li><a href="../241143/index.html">What accelerates forced overtime</a></li>
<li><a href="../241149/index.html">SPB Frontend: October meeting</a></li>
<li><a href="../241151/index.html">Dnipropetrovsk Ciklum Speakers' Corner "Google Guava: make your code easier and faster", October 23</a></li>
<li><a href="../241153/index.html">Portal to search for like-minded people when creating projects</a></li>
<li><a href="../241155/index.html">Expressive JavaScript: Higher Order Functions</a></li>
<li><a href="../241157/index.html">About the VeeamON First-Hand Conference - Not Everything That Was in Vegas Remains in Vegas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>