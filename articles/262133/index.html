<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>STM32, C ++ and FreeRTOS. Development from scratch. Part 4 (Interrupts, UART and UnHART)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Conducting 
 Once on vacation in the city on the Neva and visiting many beautiful places, I still, in the evenings over a cup of beer, dealt with the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>STM32, C ++ and FreeRTOS. Development from scratch. Part 4 (Interrupts, UART and UnHART)</h1><div class="post__text post__text-html js-mediator-article"><h4>  Conducting </h4><br>  Once on vacation in the city on the Neva and visiting many beautiful places, I still, in the evenings over a cup of beer, dealt with the UART.  Moreover, I bought good Fisher FA011 headphones, which I had to buy USB SOUND BLASTER X-FI HD and wanted to listen to music. <br>  Previous articles first moved to Geektime, then I overtook them back, I don‚Äôt even know where to put them now :) <br>  But just in case they are here: <br>  <a href="http://habrahabr.ru/post/261807//">STM32, C ++ and FreeRTOS.</a>  <a href="http://habrahabr.ru/post/261807//">Development from scratch.</a>  <a href="http://habrahabr.ru/post/261807//">Part 1</a> <br>  <a href="http://habrahabr.ru/post/261823/">STM32, C ++ and FreeRTOS.</a>  <a href="http://habrahabr.ru/post/261823/">Development from scratch.</a>  <a href="http://habrahabr.ru/post/261823/">Part 2</a> and <br>  <a href="http://habrahabr.ru/post/261837/">STM32, C ++ and FreeRTOS.</a>  <a href="http://habrahabr.ru/post/261837/">Development from scratch.</a>  <a href="http://habrahabr.ru/post/261837/">Part 3 (LCD and Screens)</a> <br><a name="habracut"></a><br><h4>  UART </h4><br>  After a detailed study of the microcontroller, it seemed to me that everything is simple.  Setup and test sending of a byte to the port went without a hitch, everything worked like a clock, and then I decided to use interrupts.  It was necessary to make the interrupt handler be a static class method.  And IAR in the compiler manual, and wrote: <br><blockquote>  Special function types can be used for static member functions.  For example, in the <br>  The following example is the interrupt function: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Device</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> __<span class="hljs-function"><span class="hljs-function">irq </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; };</code> </pre> </blockquote><br>  But bad luck, for Cortex M this method does not fit and <br><blockquote>  On the ARM Cortex-M, an interrupt service line <br>  normal function, which means no special keywords are required.  <b>Thus, the keywords</b> <b><br></b>  <b>__irq, __fiq, and __nested are not available when you compile for ARM Cortex-M.</b> <br>  These exception function names are defined in cstartup_M.c and cstartup_M.s. <br>  Vector code: <br>  NMI_Handler <br>  HardFault_Handler <br>  MemManage_Handler <br>  BusFault_Handler <br>  ... <br>  The vector table is implemented as an array.  It should always have the name <br>  __vector_table <br></blockquote><br>  Or simply, your interrupt handler must have the same name as it has in the vector table defined in the startup file.  This is done using a special keyword - the weak link __weak (in the PUBWEAK assembler), which means that this definition will be used until it is found that at least one matching letter is written without the keyword __week.  Well, that is, if you define a function with the exact same name without this directive, then the compiler will use this definition, and if you do not define, then it is marked with __weak. <br>  It is clear that I can‚Äôt insert C in the <b>startup_stm32l1xx_md.s</b> or <b>startup_stm32l1xx_md.c</b> file <b>.</b> C ++ name of the static method of the type <i>cUart :: USART2_IRQHandler ()</i> , the assembler simply won‚Äôt understand it. <br>  And just <i>‚ÄúUSART2_IRQHandler‚Äù</i> does not match the definition of <i>‚ÄúcUart :: USART2_IRQHandler ()‚Äù</i> . <br>  You can use <i>extern "C" {void USART2_IRQHandler (void) {...}}</i> , but this means that I will insert C from here, which I do not need at all, and in general access from such a function to the attributes of my class, for example the buffer will not, and it will be necessary to fence a bunch of ugly code :). <br>  Therefore, I decided to go the other way and create the <b>startup_stm32l1xx_md.cpp</b> file.  An Internet search found that some people had the exact same problem. <a href="http://community.arm.com/message/6214">For example,</a> <br>  In general, the idea is as follows: In <b>startup_stm32l1xx_md.cpp, we define</b> classes with static methods (which will be interrupt handlers), create a table __vector_table, where each interrupt vector has a pointer to these static methods.  Further we do __weak definition of each method <br>  And now when in the code the compiler sees the implementation of <i>void cUart1 :: handler ()</i> , it takes it without a second thought.  Of course, your classes and methods should be named exactly as defined in <b>startup_stm32l1xx_md.cpp</b> . <br>  It is necessary not to forget about the functions of FreeRtos: <i>vPortSVCHandler</i> , <i>xPortPendSVHandler</i> , <i>xPortSysTickHandler</i> and put them on the right interrupt and voila - everything works: <br><div class="spoiler">  <b class="spoiler_title">startup_stm32l1xx_md.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> language = extended #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> segment = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CSTACK"</span></span></span><span class="hljs-meta"> extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> void __iar_program_start( void ); extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> void vPortSVCHandler(void); extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> void xPortPendSVHandler(void); extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> void xPortSysTickHandler(void); class cNMI { public: static void handler(void); }; class cHardFault { public: static void handler(void); }; class cMemManage { public: static void handler(void); }; class cBusFault { public: static void handler(void); }; class cUsageFault { public: static void handler(void); }; class cDebugMon { public: static void handler(void); }; class cWindowWatchdog { public: static void handler(void); }; class cPvd { public: static void handler(void); }; class cTamperTimeStamp { public: static void handler(void); }; class cRtcWakeup { public: static void handler(void); }; class cFlash { public: static void handler(void); }; class cRcc { public: static void handler(void); }; class cExti { public: static void line0Handler(void); static void line1Handler(void); static void line2Handler(void); static void line3Handler(void); static void line4Handler(void); static void line9Handler(void); static void line15_10Handler(void); }; class cDma { public: static void channellHandler(void); static void channel2Handler(void); static void channel3Handler(void); static void channel4Handler(void); static void channel5Handler(void); static void channel6Handler(void); static void channel7Handler(void); }; class cAdc { public: static void handler(void); }; class cDac { public: static void handler(void); }; class cUsb { public: static void highPriorityHandler(void); static void lowPriorityHandler(void); static void fsWakeupHandler(void); }; class cComp { public: static void handler(void); }; class cLcdDriver { public: static void handler(void); }; class cTim9 { public: static void handler(void); }; class cTim2 { public: static void handler(void); }; class cTim3 { public: static void handler(void); }; class cTim4 { public: static void handler(void); }; class cTim10 { public: static void handler(void); }; class cTim6 { public: static void handler(void); }; class cTim7 { public: static void handler(void); }; class cTim11 { public: static void handler(void); }; class cI2C1 { public: static void eventHandler(void); static void errorHandler(void); }; class cI2C2 { public: static void eventHandler(void); static void errorHandler(void); }; class cSpi1 { public: static void handler(void); }; class cSpi2 { public: static void handler(void); }; class cUart1 { public: static void handler(void); }; class cUart2 { public: static void handler(void); }; class cUart3 { public: static void handler(void); }; class cRtcAlarm { public: static void handler(void); }; typedef void( *intfunc )( void ); typedef union { intfunc __fun; void * __ptr; } intvec_elem; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// The vector table is normally located at address 0. // When debugging in RAM, it can be located in RAM, aligned to at least 2^6. // If you need to define interrupt service routines, // make a copy of this file and include it in your project. // The name "__vector_table" has special meaning for C-SPY: // it is where the SP start value is found, and the NVIC vector // table register (VTOR) is initialized to this address if != 0. #pragma location = ".intvec" extern "C" const intvec_elem __vector_table[] = { { .__ptr = __sfe( "CSTACK" ) }, __iar_program_start, cNMI::handler, cHardFault::handler, cMemManage::handler, cBusFault::handler, cUsageFault::handler, 0, 0, 0, 0, vPortSVCHandler, // freeRTOS  ! cDebugMon::handler, 0, xPortPendSVHandler, // freeRTOS  ! xPortSysTickHandler, // freeRTOS  ! //External Interrupts cWindowWatchdog::handler, //Window Watchdog cPvd::handler, //PVD through EXTI Line detect cTamperTimeStamp::handler, //Tamper and Time Stamp cRtcWakeup::handler, //RTC Wakeup cFlash::handler, //FLASH cRcc::handler, //RCC cExti::line0Handler, //EXTI Line 0 cExti::line1Handler, //EXTI Line 1 cExti::line2Handler, //EXTI Line 2 cExti::line3Handler, //EXTI Line 3 cExti::line4Handler, //EXTI Line 4 cDma::channellHandler, //DMA1 Channel 1 cDma::channel2Handler, //DMA1 Channel 2 cDma::channel3Handler, //DMA1 Channel 3 cDma::channel4Handler, //DMA1 Channel 4 cDma::channel5Handler, //DMA1 Channel 5 cDma::channel6Handler, //DMA1 Channel 6 cDma::channel7Handler, //DMA1 Channel 7 cAdc::handler, //ADC1 cUsb::highPriorityHandler, //USB High Priority cUsb::lowPriorityHandler, //USB Low Priority cDac::handler, //DAC cComp::handler, //COMP through EXTI Line cExti::line9Handler, //EXTI Line 9..5 cLcdDriver::handler, //LCD cTim9::handler, //TIM9 cTim10::handler, //TIM10 cTim11::handler, //TIM11 cTim2::handler, //TIM2 cTim3::handler, //TIM3 cTim4::handler, //TIM4 cI2C1::eventHandler, //I2C1 Event cI2C1::errorHandler, //I2C1 Error cI2C2::eventHandler, //I2C2 Event cI2C2::errorHandler, //I2C2 Error cSpi1::handler, //SPI1 cSpi2::handler, //SPI2 cUart1::handler, //USART1 cUart2::handler, //USART2 cUart3::handler, //USART3 cExti::line15_10Handler, //EXTI Line 15..10 cRtcAlarm::handler, //RTC Alarm through EXTI Line cUsb::fsWakeupHandler, //USB FS Wakeup from suspend cTim6::handler, //TIM6 cTim7::handler //TIM7 }; __weak void cNMI::handler() { while (1) {} } __weak void cHardFault::handler() { while (1) {} } __weak void cMemManage::handler() { while (1) {} } __weak void cBusFault::handler() { while (1) {} } __weak void cUsageFault::handler() { while (1) {} } __weak void cDebugMon::handler() { while (1) {} } __weak void cWindowWatchdog::handler() { while (1) {} } __weak void cPvd::handler() { while (1) {} } __weak void cTamperTimeStamp::handler() { while (1) {} } __weak void cRtcWakeup::handler() { while (1) {} } __weak void cFlash::handler() { while (1) {} } __weak void cRcc::handler() { while (1) {} } __weak void cExti::line0Handler() { while (1) {} } __weak void cExti::line1Handler() { while (1) {} } __weak void cExti::line2Handler() { while (1) {} } __weak void cExti::line3Handler() { while (1) {} } __weak void cExti::line4Handler() { while (1) {} } __weak void cExti::line9Handler() { while (1) {} } __weak void cExti::line15_10Handler() { while (1) {} } __weak void cDma::channellHandler() { while (1) {} } __weak void cDma::channel2Handler() { while (1) {} } __weak void cDma::channel3Handler() { while (1) {} } __weak void cDma::channel4Handler() { while (1) {} } __weak void cDma::channel5Handler() { while (1) {} } __weak void cDma::channel6Handler() { while (1) {} } __weak void cDma::channel7Handler() { while (1) {} } __weak void cAdc::handler() { while (1) {} } __weak void cUsb::fsWakeupHandler() { while (1) {} } __weak void cUsb::highPriorityHandler() { while (1) {} } __weak void cUsb::lowPriorityHandler() { while (1) {} } __weak void cDac::handler() { while (1) {} } __weak void cComp::handler() { while (1) {} } __weak void cLcdDriver::handler() { while (1) {} } __weak void cTim2::handler() { while (1) {} } __weak void cTim3::handler() { while (1) {} } __weak void cTim4::handler() { while (1) {} } __weak void cTim6::handler() { while (1) {} } __weak void cTim7::handler() { while (1) {} } __weak void cTim9::handler() { while (1) {} } __weak void cTim10::handler() { while (1) {} } __weak void cTim11::handler() { while (1) {} } __weak void cI2C1::errorHandler() { while (1) {} } __weak void cI2C1::eventHandler() { while (1) {} } __weak void cI2C2::errorHandler() { while (1) {} } __weak void cI2C2::eventHandler() { while (1) {} } __weak void cSpi1::handler() { while (1) {} } __weak void cSpi2::handler() { while (1) {} } __weak void cUart1::handler() { while (1) {} } __weak void cUart2::handler() { while (1) {} } __weak void cUart3::handler() { while (1) {} } __weak void cRtcAlarm::handler() { while (1) {} } extern "C" void __cmain( void ); extern "C" __weak void __iar_init_core( void ); extern "C" __weak void __iar_init_vfp( void ); #pragma required=__vector_table void __iar_program_start( void ) { __iar_init_core(); __iar_init_vfp(); __cmain(); }</span></span></span></span></code> </pre><br></div></div><br><br><cut></cut><br><br><h4>  DWART.  Receive message transfer </h4><br>  So, with the interrupts figured out, now you can take up the implementation of a thread of a simple protocol.  Modbus was dropped immediately - not very difficult :).  HART, an industrial protocol for devices such as pressure sensors, temperature sensors and flowmeters ‚Äî will work just fine. <br>  And the task that I set for myself will be communicating using this protocol with the program setting up the devices, say <b>Pactware</b> , or the <b>Elemental</b> <a href="http://www.elemer.ru/po/hart_config.php">HARTConfig</a> , <b>having</b> <a href="http://www.elemer.ru/po/hart_config.php">faked</a> some popular sensor, say the pressure sensor - Yokogawa EJA, so that this program does not detect a catch.  I must say that everything turned out :) <br><img src="https://habrastorage.org/files/c0b/6bb/118/c0b6bb11812a4019ae5b1259db13da75.png" alt="image"><br>  And even managed to remove the trend in air temperature, measured by the internal temperature sensor of the microcontroller: <br><img src="https://habrastorage.org/files/20a/8de/226/20a8de226020413fb04a83fe55cbe3cd.png" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This is how my Pactware device is seen :) <br><img src="https://habrastorage.org/files/ff7/db5/a14/ff7db5a146c14330bf1469aa0397218a.png" alt="image"><br><br>  HART documentation is available only to a member of the fund.  But I managed to find fragmentary descriptions that would be fine for my demo project.  Here is an example of one of these resources: <a href="http://hart2dde.narod.ru/hartdesc.html">Description of the HART protocol</a> or here is the <a href="http://cyberleninka.ru/article/n/realizatsiya-hart-protokola-na-osnove-modeli-iso-osi">OSI HART Model Protocol</a> <br>  In short - on the line there is a master (main) and slave (slave) device.  The main thing sends requests, the slave responds at a speed of 1200 bits per second - everything is simple. <br>  There may be two main devices on the line, but I will simply communicate with ONE RS232 master. <br>  For the same reason, I don‚Äôt need to particularly follow the bus arbitration and determine when it‚Äôs difficult to have a token, and when not, and the whole arbitration in my case is only that - I have the token, after 2 symbols of silence on the line.  At a speed of 1200 bits per second it is approximately 19 ms.  Those.  if within 19 ms, I have no interruption in reception - the parcel is considered accepted, and the token is with me, I can answer and should start responding within about 250 ms, otherwise the token will go to the master again. <br>  In general, I called this protocol <b>Dwart</b> , a symbiosis between Dwarf - dwarf, gnome and HART. <br>  First you need to select the entity that will operate: <br><br><ul><li>  Link level ( <b>LinkLayer</b> ) - will be responsible just for sending and transmitting messages, as well as for determining the end of receiving a request from the master </li><li>  The transmission end determination timer ( <b>LinkLayerTimer</b> ) is a 19 ms timer, after which it will be considered that the request from the master has been accepted.  The timer should start after each received byte. </li><li>  Frame ( <b>Frame</b> ) - is responsible for parsing and framing HART parcels. </li><li>  Commands ( <b>Command</b> ) - is responsible for the implementation of a separate command. </li><li>  The main class itself ( <b>Dwart</b> ) - he will manage all this business </li></ul><br>  In order to observe the principle of puff pie - the classes of the lower layer will not know about the classes of the layer located above, i.e.  For example, Command will work only with Frame, and Frame with LinkLayer, while LinkLayer will not know anything about Command and Frame, and Frame about Command. <br>  So what is the idea - to accept bytes until the silence timer has been activated, then to notify Dwart, which will call the parsing method of the received message and, depending on the request, execute the necessary command. <br>  In general, ideally, say when requesting command 1 from the master, I want the answer to it to look something like this: <br><pre> <code class="cpp hljs">Command1.Response.PrimaryVariable = <span class="hljs-number"><span class="hljs-number">3.54</span></span> Command1.Send();</code> </pre><br>  First, let's estimate the channel level, this figure shows only public methods, so as not to litter the picture. <br><img src="https://habrastorage.org/files/792/bdc/a96/792bdca962244370aa6fc3deca463561.png" alt="image"><br><br>  I will clarify the picture a bit, the methods of the interrupt handler are static, and in order to access the methods and fields of the class instance in these static methods, it is necessary that either the fields and methods are also static, or they can be addressed directly to the class instance.  I went to the second - the right way, referring to a specific instance of the class, which I initialize in the constructor with the <b>this</b> pointer. <br>  LinkLayer will receive bytes from the UART port and add them to the receive buffer. <br>  But since HART has 0xFF synchronization bytes, called preambles, and their number can reach 20, (and we don‚Äôt need them at all, because they don‚Äôt carry any information, and all we need is to determine the beginning of the frame by sequence ( 0xFF 0xFF &lt;start byte&gt;)), it will waste 20 preambles to the buffer, so I‚Äôll just watch them right in the interrupt and as soon as they run out, I‚Äôll start to add bytes to the buffer. <br>  After receiving each byte, I will restart the timer for 19 ms, if it works, the package is considered to be accepted. <br>  Another task is to notify the linklayer from the linklayertimer class as soon as the timer interrupt is triggered, indicating the end of receiving the request from the master.  For this, I used the Designer Observer template, as a result LinkLayer simply subscribes to events from LinkLayerTimer. It looks like this: <br><div class="spoiler">  <b class="spoiler_title">linklayertimer.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"susutypes.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"observable.h"</span></span></span><span class="hljs-meta"> class cLinkLayerTimer : public iObservable { public: explicit cLinkLayerTimer(tU16 timeout); void start(void) const; private: static void irqHandler(void); static cLinkLayerTimer* instance; };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">linklayertimer.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"linklayertimer.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"susuassert.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; cLinkLayerTimer* cLinkLayerTimer::instance = NULL; /******************************************************************************* * Function: constructor * Description:    TIM2 ******************************************************************************/ cLinkLayerTimer::cLinkLayerTimer(tU16 timeout) { ASSERT(instance != NULL); this-&gt;instance = this; TIM2-&gt;ARR = (uint16_t)timeout; } /******************************************************************************* * Function: start * Description:  .     ******************************************************************************/ void cLinkLayerTimer::start(void) const { TIM2-&gt;CNT = (uint16_t)0; TIM2-&gt;CR1 |= TIM_CR1_CEN; } /******************************************************************************* * Function: irqHandler * Description:     . *     ,   ******************************************************************************/ void cLinkLayerTimer::irqHandler(void) { ASSERT(instance != NULL); instance-&gt;notifyObservers(); TIM2-&gt;CR1 &amp;=~ TIM_CR1_CEN; TIM2-&gt;SR &amp;= ~TIM_SR_UIF; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">linklayer.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"susutypes.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"linklayertimer.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"observer.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PREAMBUL_SYMBOL (uint16_t) 0xFF typedef enum { LLS_none = 0, LLS_write = 1, LLS_writeComplete = 2, LLS_readComplete = 3, LLS_error = 4 } tLinkLayerStatus; class cLinkLayer : private iObserver, public iObservable { public: explicit cLinkLayer(tU8 *pRxBuf, const tU8 rxBufSize,tU8 *pTxBuf, const tU8 preambulCount); void writeData(tU8 dataSize); tLinkLayerStatus getStatus() const { return eStatus; }; virtual void eventHandle(const iObservable* pObservable); tU8* pTxBuffer; tU8* pRxBuffer; private: static void irqHandler(void); static cLinkLayer* instance; void endMessageHandler(void); void enableReceive(void) const { USART2-&gt;CR1 |= USART_CR1_RXNEIE;}; void disableReceive(void){USART2-&gt;CR1 &amp;=~ USART_CR1_RXNEIE;}; void enableTransmit(void) const { USART2-&gt;CR1 |= USART_CR1_TCIE; }; void disableTransmit(void) const { USART2-&gt;CR1 &amp;=~ USART_CR1_TCIE; }; tLinkLayerStatus eStatus; cLinkLayerTimer* pEndTransmitTimer; tU8 rxBufferSize; tU8 rxBufferIndex; tU8 txBufferIndex; tU8 txBufferSize; tU8 preambulsCount; tU8 preambulIndex; tBoolean readPreambuls; };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">linllayer.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stm32l1xx.h&gt; #include "linklayer.h" #include "susuassert.h" #include &lt;stdio.h&gt; #define END_MESSAGE_TIMEOUT (tU16) 19 #define GOOD_COUNT_RX_PREAMBULS (tU8) 2 cLinkLayer* cLinkLayer::instance = NULL; /******************************************************************************* * Function: constructor * Description:       ******************************************************************************/ cLinkLayer::cLinkLayer(tU8 *pRxBuf, const tU8 rxBufSize,tU8 *pTxBuf, const tU8 preambulCount) { ASSERT (rxBuffer != NULL); ASSERT (txBuffer != NULL); //     3 ASSERT(preambulCount &gt; (tU8)2); this-&gt;preambulsCount = preambulCount; this-&gt;preambulIndex = (tU8)0; this-&gt;readPreambuls = TRUE; this-&gt;pRxBuffer = pRxBuf; this-&gt;rxBufferSize = rxBufSize; this-&gt;rxBufferIndex = (tU8)0; this-&gt;pTxBuffer = pTxBuf; this-&gt;txBufferSize = (tU8)0; this-&gt;txBufferIndex = (tU8)0; this-&gt;eStatus = LLS_none; this-&gt;instance = this; this-&gt;pEndTransmitTimer = new cLinkLayerTimer(END_MESSAGE_TIMEOUT); //    this-&gt;pEndTransmitTimer-&gt;addObserver(this); this-&gt;disableTransmit(); this-&gt;enableReceive(); } /******************************************************************************* * Function: writeData * Description:  ,     ******************************************************************************/ void cLinkLayer::writeData(tU8 dataSize) { //    ,     ,    // if (this-&gt;eStatus != LLS_write) { this-&gt;disableReceive(); this-&gt;txBufferSize = dataSize; this-&gt;eStatus = LLS_write; USART2-&gt;DR = PREAMBUL_SYMBOL; this-&gt;preambulIndex ++; this-&gt;enableTransmit(); } } /******************************************************************************* * Function: handler * Description:   ******************************************************************************/ void cLinkLayer::irqHandler(void) { ASSERT(instance != NULL); // if (USART2-&gt;SR &amp; USART_SR_TC) { //    ,   3   if (instance-&gt;preambulIndex != instance-&gt;preambulsCount) { USART2-&gt;DR = PREAMBUL_SYMBOL; instance-&gt;preambulIndex ++; } else { //  -    if(instance-&gt;txBufferIndex &lt; instance-&gt;txBufferSize) { USART2-&gt;DR = (uint16_t)instance-&gt;pTxBuffer[instance-&gt;txBufferIndex++]; } else { instance-&gt;txBufferIndex = (tU8)0; instance-&gt;txBufferSize = (tU8)0; instance-&gt;disableTransmit(); instance-&gt;eStatus = LLS_writeComplete; instance-&gt;preambulIndex = (tU8)0; instance-&gt;readPreambuls = TRUE; instance-&gt;enableReceive(); } } USART2-&gt;SR &amp;=~ USART_SR_TC; }; // if (USART2-&gt;SR &amp; USART_SR_RXNE) { instance-&gt;pRxBuffer[instance-&gt;rxBufferIndex] = (tU8)USART2-&gt;DR; instance-&gt;pEndTransmitTimer-&gt;start(); //    if (instance-&gt;readPreambuls) { if (instance-&gt;pRxBuffer[instance-&gt;rxBufferIndex] == (tU8)PREAMBUL_SYMBOL) { instance-&gt;preambulIndex++; } else { instance-&gt;readPreambuls = FALSE; instance-&gt;rxBufferIndex++; } } else { //      2 if ((instance-&gt;rxBufferIndex &lt;= instance-&gt;rxBufferSize) &amp;&amp; (instance-&gt;preambulIndex &gt;= GOOD_COUNT_RX_PREAMBULS)) { instance-&gt;rxBufferIndex++; } else { instance-&gt;eStatus = LLS_error; instance-&gt;preambulIndex = (tU8)0; } } } } /******************************************************************************* * Function: endMessageHandler * Description:    ******************************************************************************/ void cLinkLayer::endMessageHandler(void) { this-&gt;eStatus = LLS_readComplete; this-&gt;rxBufferIndex = (tU8) 0; this-&gt;readPreambuls = TRUE; instance-&gt;preambulIndex = (tU8)0; } /******************************************************************************* * Function: eventHandle * Description:     ******************************************************************************/ void cLinkLayer::eventHandle(const iObservable* pObservable) { this-&gt;endMessageHandler(); this-&gt;notifyObservers(); }</span></span></span></span></code> </pre><br></div></div><br>  LinkLayer itself also notifies the end of the acceptance of the request from the master of its subscribers - we need it later <br><br><h4>  DWART.  Team building </h4><br>  Now the most interesting thing is that the teams, as I have already said, would like to make everything look beautiful, and it was possible to refer to the commands conveniently - like this <pre> <code class="cpp hljs"> Command0.Response.PrimaryVariable = <span class="hljs-number"><span class="hljs-number">3.54</span></span></code> </pre> <br>  It is clear that if for each command I keep the whole Response request structure, and there can be 254 commands, then I don‚Äôt have enough memory, so I will only store a pointer to the Response request structure, and each time assign this pointer to a pointer to the data in the transfer buffer, which I will receive using the buildFrameBeforeData class method withFrame. <br>  For all the teams I will do the basic interface iBaseDwartCommand with common methods, and since I have requests and responses from each command of different lengths and different types, I will create a template class derived from iDwartCommand.  It looks like this: <br><img src="https://habrastorage.org/files/043/332/ce9/043332ce9f194ae1a7c3065fd08ee131.png" alt="image"><br>  Command 0 - returns just information about the device. <br>  Commands 1 - returns the value of the primary variable, in my case it is with Trimmer, access to which is provided by the cVariables class, so I have to pass it on to the constructor. <br>  As a result, filling in the data of command 1 looks like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> cCommand1::setNewData(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//          this-&gt;pResponse = (tCommand1Response*) this-&gt;pFrame-&gt;buildFrameBeforeData(COMMAND1, (tU8)sizeof(tCommand1Response)); this-&gt;pResponse-&gt;status1 = (tU8)0; this-&gt;pResponse-&gt;status2 = (tU8)0; this-&gt;pResponse-&gt;PrimaryVariableUnits = (tU8) pVariables-&gt;pTrimmer-&gt;getUnits(); this-&gt;pResponse-&gt;PrimaryVariableValue = std::swap&lt;tF32&gt;(pVariables-&gt;pTrimmer-&gt;getValue()); this-&gt;pFrame-&gt;setCheckSumm(); }</span></span></code> </pre><br>  Here, the cConversion class swap method is used to swap bytes in places, since HART uses the Big Endian view, and my microcontroller is Little Endian.  Well, almost got what I wanted :) <br>  Completely the whole implementation looks like this: <br><div class="spoiler">  <b class="spoiler_title">basedwartcommand.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iBaseDwartCommand</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setNewData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">dwartcommand.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"frame.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"basecommand.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"susuassert.h"</span></span></span><span class="hljs-meta"> template </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class req, class resp&gt; class iDwartCommand : public iBaseDwartCommand { public: explicit iDwartCommand(cFrame *pDwratFrame); req *pRequest; resp *pResponse; void send(void); protected: cFrame *pFrame; }; /******************************************************************************* * Function: constructor * Description: ******************************************************************************/ template &lt;class req, class resp&gt; iDwartCommand&lt;req, resp&gt;::iDwartCommand(cFrame *pDwartFrame) { ASSERT (pFrame != NULL); this-&gt;pFrame = pDwartFrame; } /******************************************************************************* * Function: send * Description:   ******************************************************************************/ template &lt;class req, class resp&gt; void iDwartCommand&lt;req, resp&gt;::send(void) { this-&gt;pFrame-&gt;send(); }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">command0.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"command.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> COMMAND0 (tU8)0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> pack(push, 1) typedef struct { tU8 status1; tU8 status2; tU8 expansion; tU8 manufacturer; tU8 deviceType; tU8 numberOfpreambuls; tU8 universalCommandRevision; tU8 deviceSpecificCommandRevision; tU8 softwareRevision; tU8 hardwareRevision; tU8 deviceFlags; tU8 deviceID[3]; } tCommand0Response; typedef struct { } tCommand0Request; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> pack(pop) class cCommand0: public iDwartCommand</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;tCommand0Request, tCommand0Response&gt; { public: explicit cCommand0(cFrame *pDwartFrame); virtual void setNewData(void); };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">command0.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs">include <span class="hljs-string"><span class="hljs-string">"susuassert.h"</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"command0.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"frame.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/******************************************************************************* * Function: constructor * Description: ******************************************************************************/</span></span></span><span class="hljs-meta"> cCommand0::cCommand0(cFrame *pDwartFrame): iDwartCommand(pDwartFrame) { } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/******************************************************************************* * Function: setNewData * Description:     ******************************************************************************/</span></span></span><span class="hljs-meta"> void cCommand0::setNewData(void) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//          this-&gt;pResponse = (tCommand0Response*) this-&gt;pFrame-&gt;buildFrameBeforeData(COMMAND0, (tU8)sizeof(tCommand0Response)); this-&gt;pResponse-&gt;status1 = (tU8)0; this-&gt;pResponse-&gt;status2 = (tU8)0; this-&gt;pResponse-&gt;manufacturer = (tU8)0x37; this-&gt;pResponse-&gt;deviceType = (tU8)0x04; this-&gt;pResponse-&gt;expansion = (tU8)0; this-&gt;pResponse-&gt;deviceSpecificCommandRevision = (tU8)5; this-&gt;pResponse-&gt;universalCommandRevision = (tU8)5; this-&gt;pResponse-&gt;hardwareRevision = (tU8)1; this-&gt;pResponse-&gt;softwareRevision = (tU8)201; this-&gt;pResponse-&gt;numberOfpreambuls = (tU8)5; this-&gt;pResponse-&gt;deviceID[0] = (tU8)0; this-&gt;pResponse-&gt;deviceID[1] = (tU8)0; this-&gt;pResponse-&gt;deviceID[2] = (tU8)1; this-&gt;pResponse-&gt;deviceFlags = (tU8)0; this-&gt;pFrame-&gt;setCheckSumm(); }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">command1.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"command.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"vars.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> COMMAND1 (tU8)1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> pack(push, 1) typedef struct { tU8 status1; tU8 status2; tU8 PrimaryVariableUnits; tF32 PrimaryVariableValue; } tCommand1Response; typedef struct { } tCommand1Request; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> pack(pop) class cCommand1: public iDwartCommand</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;tCommand1Request, tCommand1Response&gt; { public: explicit cCommand1(cFrame *pDwartFrame,Variablesr *Vars); virtual void setNewData(void); private: Variables *pVariables; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">command1.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"susuassert.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"command1.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"frame.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/******************************************************************************* * Function: constructor * Description: ******************************************************************************/</span></span></span><span class="hljs-meta"> cCommand1::cCommand1(cFrame *pDwartFrame, Variables *pVars): iDwartCommand(pDwartFrame) { ASSERT(pVars != NULL); this-&gt;pVariables = pVars; } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/******************************************************************************* * Function: setNewData * Description:     ******************************************************************************/</span></span></span><span class="hljs-meta"> void cCommand1::setNewData(void) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//          this-&gt;pResponse = (tCommand1Response*) this-&gt;pFrame-&gt;buildFrameBeforeData(COMMAND1, (tU8)sizeof(tCommand1Response)); this-&gt;pResponse-&gt;status1 = (tU8)0; this-&gt;pResponse-&gt;status2 = (tU8)0; this-&gt;pResponse-&gt;PrimaryVariableUnits = (tU8) pVariables-&gt;pTrimmer-&gt;getUnits(); this-&gt;pResponse-&gt;PrimaryVariableValue = std::swap&lt;tF32&gt;(pVariables-&gt;pTrimmer-&gt;getValue()); this-&gt;pFrame-&gt;setCheckSumm(); }</span></span></span></span></code> </pre><br></div></div><br>        .     ,  ,      ,      254    ,       .      cCommandSet: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"command.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"variables.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> COMMANDS_COUNT 254 class cCommandSet { public: cCommandSet(cFrame *pFrame, Variables *pVariables); iBaseDwartCommand *pCommands[COMMANDS_COUNT]; };</span></span></code> </pre><br><br>  ,    Pactware  HartConfig    Yokogawa,      ,     . <br> commandset.cpp  : <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"susuassert.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"commandset.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"command0.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"command1.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"command2.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"command3.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"command12.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"command13.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"command14.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"command15.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"command157.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"command159.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"command160.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"command180.h"</span></span></span><span class="hljs-meta"> cCommandSet::cCommandSet(cFrame *pFrame, cVariables *pVariables) { this-&gt;pCommands[COMMAND0] = new cCommand0(pFrame); this-&gt;pCommands[COMMAND1] = new cCommand1(pFrame, pVariables); this-&gt;pCommands[COMMAND2] = new cCommand2(pFrame, pVariables); this-&gt;pCommands[COMMAND3] = new cCommand3(pFrame, pVariables); this-&gt;pCommands[COMMAND13] = new cCommand13(pFrame); this-&gt;pCommands[COMMAND12] = new cCommand12(pFrame); this-&gt;pCommands[COMMAND14] = new cCommand14(pFrame); this-&gt;pCommands[COMMAND15] = new cCommand15(pFrame, pVariables); this-&gt;pCommands[COMMAND160] = new cCommand160(pFrame); this-&gt;pCommands[COMMAND157] = new cCommand157(pFrame); this-&gt;pCommands[COMMAND159] = new cCommand159(pFrame); this-&gt;pCommands[COMMAND180] = new cCommand180(pFrame); }</span></span></code> </pre><br>    ,       ,       :)   ,   . <br>    ,    157, 159  160, ( ,   -  ,      , ,    (   ,        ,     ,      )),      - ,    . <br> - ,     ,        ‚Äî   <br><pre> <code class="cpp hljs">pCommandSet-&gt;pCommands[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;pFrame-&gt;getCurrentCommand()]-&gt;setNewData(); pCommandSet-&gt;pCommands[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;pFrame-&gt;getCurrentCommand()]-&gt;send();</code> </pre><br>       swith case,    ¬´ ¬ª :) <br><br><h4> DWART.  Completion </h4><br> ,           . <br>     ,         LinkLayer, <br>       ,       -   ,            ,        ,   ,    cFrame,          ,       . <br>      cFrame, cLinkLayer  CommandSet   cLinkLayer      .         -,          ,    . <br><img src="https://habrastorage.org/files/5c6/168/4d1/5c61684d197c409693d6363c1d290015.png" alt="image"><br><div class="spoiler"> <b class="spoiler_title">dwart.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"susutypes.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"frame.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"observer.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"linklayer.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"variables.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"commandset.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"frtosWrapper.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_BUFFER_SIZE (tU8)255 class cDwart: private iObserver, public iActiveObject { public: cDwart(Variables *pVariables); virtual void eventHandle(const iObservable* pObservable); virtual void run(void); private: cCommandSet *pCommandSet; cLinkLayer *pLinkLayer; cFrame *pFrame; tU8 buffer[MAX_BUFFER_SIZE]; tBoolean isToken; static const tU8 deviceID[5]; };</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">dwart.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"susuassert.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"frame.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stddef.h&gt; #include "dwart.h" #define SHORT_ADDR (tU8)0 #define PREAMBULS_COUNT (tU8)7 #define DWART_WAITING (tU32) (50/portTICK_PERIOD_MS) const tU8 cDwart::deviceID[5] = {(tU8)0x37,(tU8)0x04,(tU8)0x00,(tU8)0x00,(tU8)0x01}; /******************************************************************************* * Function: constructor * Description:    cLinkLayer, cFrame cCommandSet  *         ******************************************************************************/ cDwart::cDwart(Variables *pVariables) { this-&gt;pLinkLayer = new cLinkLayer(this-&gt;buffer,MAX_BUFFER_SIZE, this-&gt;buffer, PREAMBULS_COUNT); this-&gt;pFrame = new cFrame((tU8*)deviceID, SHORT_ADDR,this-&gt;pLinkLayer); this-&gt;pCommandSet = new cCommandSet(this-&gt;pFrame, pVariables); this-&gt;pLinkLayer-&gt;addObserver(this); this-&gt;isToken = FALSE; } /******************************************************************************* * Function: eventHandle * Description:    .       ******************************************************************************/ void cDwart::eventHandle(const iObservable* pObservable) { ASSERT(pObservable != NULL); this-&gt;isToken = TRUE; } /******************************************************************************* * Function: run * Description:      ******************************************************************************/ void cDwart::run(void) { for(;;) { if (this-&gt;isToken) { this-&gt;isToken = FALSE; if (this-&gt;pFrame-&gt;decode() == FE_good) { pCommandSet-&gt;pCommands[this-&gt;pFrame-&gt;getCurrentCommand()]-&gt;setNewData(); pCommandSet-&gt;pCommands[this-&gt;pFrame-&gt;getCurrentCommand()]-&gt;send(); } } oRTOS.taskDelay(DWART_WAITING); } }</span></span></span></span></code> </pre><br></div></div><br>      cDwart  main.cpp     <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cAdcDirector* pAdcDirector = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cAdcDirector(); pAdcDirector-&gt;startConversion(); cVariables *pVariables = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cVariables(pAdcDirector); oRTOS.taskCreate(pVariablesDirector, VARIABLESDIRECTOR_STACK_SIZE, VARIABLESDIRECTOR_PRIORITY, <span class="hljs-string"><span class="hljs-string">"Var"</span></span>); cDwart *pDwart = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cDwart(pVariablesDirector); oRTOS.taskCreate(pDwart, DWART_STACK_SIZE, DWART_PRIORITY, <span class="hljs-string"><span class="hljs-string">"Dwart"</span></span>); ... oRTOS.startScheduler(); }</code> </pre><br>       Pactware    . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/S0qeAysH2Jk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>        . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/hR5AvBr2c-k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br> ,      ,    255   ,   ,       switch case,     placeholder   ,              ,   . <br>        ,     . </div><p>Source: <a href="https://habr.com/ru/post/262133/">https://habr.com/ru/post/262133/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../262123/index.html">Network Security, Part 2. Next-Generation Firewall</a></li>
<li><a href="../262125/index.html">Will Microsoft Azure be able to find an index that your DBA couldn't find?</a></li>
<li><a href="../262127/index.html">Command line art</a></li>
<li><a href="../262129/index.html">The magic of tensor algebra: Part 6 - Kinematics of a free solid. Nature of angular velocity</a></li>
<li><a href="../262131/index.html">How to pay for training with VMware PSO credits</a></li>
<li><a href="../262137/index.html">Setting the syntax check "on the fly" HTML, CSS, JS, PHP in Sublime Text 3 on Windows 7</a></li>
<li><a href="../262139/index.html">Stream API: universal intermediate operation</a></li>
<li><a href="../262141/index.html">Watson went to Wimbledon</a></li>
<li><a href="../262143/index.html">DevDay - open meetings for sociable IT people</a></li>
<li><a href="../262145/index.html">The rapid development of mobile advertising, Fallout Shelter for Android, CSR2 - and other news of the week for a mobile developer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>