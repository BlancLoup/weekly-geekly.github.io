<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Modified Geometry Buffer Anti-Aliasing Algorithm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aliasing represents one of the fundamental problems of computer graphics, and many different anti-aliasing algorithms have been invented to deal with ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Modified Geometry Buffer Anti-Aliasing Algorithm</h1><div class="post__text post__text-html js-mediator-article">  Aliasing represents one of the fundamental problems of computer graphics, and many different anti-aliasing algorithms have been invented to deal with it.  The emergence of <a href="https://habrahabr.ru/post/124913">MLAA has</a> attracted interest in algorithms that work at the post-processing stage.  One of these algorithms (with a small reservation) is <i>Geometry Buffer Anti-Aliasing</i> (GBAA).  This material describes an attempt to modify the original algorithm to improve the quality of anti-aliasing in some cases. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/896/ffd/a06/896ffda0608daacc04b99f41243ef623.png" alt="image"></div><a name="habracut"></a><br><br><h4>  Geometric Post-process Anti-Aliasing (GPAA) </h4><br>  <a href="http://humus.name/index.php%3Fpage%3D3D%26ID%3D87">GBAA</a> is an enhanced version of the <a href="http://humus.name/index.php%3Fpage%3D3D%26ID%3D86">Geometric Post-process Anti-Aliasing Algorithm (GPAA)</a> .  The underlying idea is that instead of searching for sharp boundaries in the original image to estimate the location of geometric edges (as MLAA does) you can use the information about the edges in a ‚Äúpure form‚Äù by receiving it from the renderer.  The algorithm is pretty simple: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  Render the scene (main pass); </li><li>  Make a copy of the backbuffer; </li><li>  Render geometric edges in an extra pass, blending the colors of adjacent pixels to get smoothed edges. </li></ol><br>  The blending of pixel colors (blending) is as follows: <br><br><ol><li>  For each pixel, the direction (vertical or horizontal) and the distance to the nearest edge are determined; </li><li>  Using direction and distance, the pixel coverage of the adjacent triangle is calculated; </li><li>  The direction is used to select the adjacent pixel, and the coating is used to calculate blending ratios. </li></ol><br><br>  This picture illustrates the logic of the algorithm: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d8f/958/134/d8f95813476916dc94de0b447214e1c5.png" alt="GPAA illustration"></div><br><br>  The bold line indicates a geometric edge.  The arrows show the selection of the adjacent pixel.  Dotted lines indicate offsets relative to the center of the pixel, which are used to calculate blending ratios.  Blending is done with a single texture sample: an offset is added to the texture coordinates of the current pixel, and a linear filter does the rest of the work. <br><br>  In the vertex shader, the coordinates of the geometric edge are projected onto the screen plane and are used to obtain the equation of a straight line on which the edge lies.  An equation in the form of a four-dimensional vector falls into a pixel shader, where the coverage and color of a pixel are calculated. <br><br><div class="spoiler">  <b class="spoiler_title">Shader Code (HLSL)</b> <div class="spoiler_text"><pre><code class="hljs pgsql">struct VsIn { float3 Position0 : Position0; float3 Position1 : Position1; }; struct PsIn { <span class="hljs-type"><span class="hljs-type">float4</span></span> Position : SV_Position; // The parameters are <span class="hljs-keyword"><span class="hljs-keyword">constant</span></span> across the <span class="hljs-type"><span class="hljs-type">line</span></span> so use the nointerpolation <span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span>. // This <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> necessarily required, but <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> this we can make the vertex shader slightly shorter. nointerpolation <span class="hljs-type"><span class="hljs-type">float4</span></span> KMF : KMF; }; float4x4 ViewProj; <span class="hljs-type"><span class="hljs-type">float4</span></span> ScaleBias; PsIn main(VsIn <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>) { PsIn <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> pos0 = mul(ViewProj, <span class="hljs-type"><span class="hljs-type">float4</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.Position0, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-type"><span class="hljs-type">float4</span></span> pos1 = mul(ViewProj, <span class="hljs-type"><span class="hljs-type">float4</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.Position1, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.Position = pos0; // Compute screen-space position <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> direction <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">line</span></span> float2 pos = (pos0.xy / pos0.w) * ScaleBias.xy + ScaleBias.zw; float2 dir = (pos1.xy / pos1.w) * ScaleBias.xy + ScaleBias.zw - pos; // <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> mostly horizontal <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> vertical <span class="hljs-type"><span class="hljs-type">bool</span></span> x_gt_y = abs(dir.x) &gt; abs(dir.y); // Pass down the screen-space <span class="hljs-type"><span class="hljs-type">line</span></span> equation <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x_gt_y) { <span class="hljs-type"><span class="hljs-type">float</span></span> k = dir.y / dir.x; <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.KMF.xy = float2(k, <span class="hljs-number"><span class="hljs-number">-1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-type"><span class="hljs-type">float</span></span> k = dir.x / dir.y; <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.KMF.xy = float2(<span class="hljs-number"><span class="hljs-number">-1</span></span>, k); } <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.KMF.z = -dot(pos.xy, <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.KMF.xy); <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.KMF.w = asfloat(x_gt_y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>; } Texture2D BackBuffer; SamplerState <span class="hljs-keyword"><span class="hljs-keyword">Filter</span></span>; float2 PixelSize; <span class="hljs-type"><span class="hljs-type">float4</span></span> main(PsIn <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>) : SV_Target { // Compute the difference <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> geometric <span class="hljs-type"><span class="hljs-type">line</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> sample position <span class="hljs-type"><span class="hljs-type">float</span></span> diff = dot(<span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.KMF.xy, <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.Position.xy) + <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.KMF.z; // Compute the coverage <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the neighboring surface <span class="hljs-type"><span class="hljs-type">float</span></span> coverage = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f - abs(diff); float2 <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (coverage &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { // <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> direction <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> sample a neighbor pixel <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span> = diff &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (asuint(<span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.KMF.w)) <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.y = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.x = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; } // Blend pixel <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> neighbor pixel <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> texture filtering <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> shifting the coordinate appropriately. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BackBuffer.Sample(<span class="hljs-keyword"><span class="hljs-keyword">Filter</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.Position.xy + coverage * <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.xy) * PixelSize); }</code> </pre> <br></div></div><br>  The main advantages of this algorithm are quality and performance.  The quality of antialiasing does not depend on the angle of inclination of the edge, which is a traditional problem for post-processing techniques.  The first picture shows the results of FXAA with different quality presets, the second shows the results of GPAA. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6cd/82c/38a/6cd82c38a8bd1d680d47ab4d37ec651b.png" alt="FXAA horizontal edges"></div><br>  <i>FXAA 3, FXAA 5</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d7/79d/979/5d779d979de8538d2d6661d01dff8549.png" alt="GPAA horizontal edges"></div><br>  <i>GPAA</i> <br><br>  The most expensive operation is copying the screen buffer: rendering one frame (in the original implementation) on the HD 5870 video card at 1280x720 resolution is performed in 0.93 ms, of which copying the screen buffer takes 0.08 ms, and the smoothing of the edges is 0.01 ms.  The disadvantage is obviously the need to pre-process the geometry to extract edges and additional memory for storing them.  In addition, consumer-grade GPUs perform rasterization of lines relatively slowly.  Together, these problems adversely affect the scalability of GPAA with the increasing geometric complexity of the scene. <br><br><h4>  Geometry Buffer Anti-Aliasing (GBAA) </h4><br>  So the GBAA is an advanced version of GPAA.  Actually, the improvement is that the directions and distances to the borders of triangles are calculated in a geometric shader, which eliminates the need for preliminary processing of geometry and rasterization of lines, reduces the amount of memory used and, most importantly, eliminates the dependence of performance on the geometric complexity of the scene. <br><br>  The picture below illustrates the definition of the distance to the borders: for each edge, the geometric shader first calculates the height <i>d</i> , and then the axially aligned distance <i>d <sub>x</sub></i> .  The results are stored in the vertex attributes, interpolated by the rasterizer and used to calculate blending coefficients in the pixel shader. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/098/75e/03a/09875e03ad8246adcec106f2d1caa9b4.png" alt="GBAA distance calculation"></div><br><br>  An additional advantage over GPAA is the ability to perform anti-aliasing of not only geometric edges, but also other boundaries, the distance to which can be estimated: for example, boundaries in alpha-transparent textures: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f33/dd5/054/f33dd5054a78b520f319916eed8c2d5e.png" alt="GBAA alpha-transparency"></div><br><br>  The pixel shader uses the results of the geometry shader calculations to search for edges intersecting a pixel.  In case the minimum offset to the edge is less than half a pixel, the next pixel is selected, the blending coefficients are calculated and blending is performed.  Otherwise, the pixel remains unchanged.  Information about the displacement of silhouette edges is available only for pixels that are on the inside of the silhouette, so these pixels require additional processing: <br><br><ul><li>  Offsets are selected from 4 neighboring pixels; </li><li>  Depending on the offset, one of 4 neighbors is selected (the one whose offset corresponds to the direction towards the current pixel): <br>  - left: 0.5 &lt;= offset.x &lt;= 1.0 <br>  - right: -1.0 &lt;= offset.x &lt;= -0.5 <br>  - upper: 0.5 &lt;= offset.y &lt;= 1.0 <br>  - lower: -1.0 &lt;= offset.y &lt;= -0.5 <br></li><li>  From the selected offset, a corrected offset is obtained for the current pixel, then all that remains is to calculate the coefficients and perform blending. </li></ul><br><br><div class="spoiler">  <b class="spoiler_title">Shader Code (HLSL)</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">struct PsIn { <span class="hljs-type"><span class="hljs-type">float4</span></span> Position : SV_Position; float2 TexCoord : TexCoord; }; [Vertex shader] PsIn main(uint VertexID : SV_VertexID) { // Produce a fullscreen triangle PsIn <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.Position.x = (VertexID == <span class="hljs-number"><span class="hljs-number">0</span></span>)? <span class="hljs-number"><span class="hljs-number">3.0</span></span>f : <span class="hljs-number"><span class="hljs-number">-1.0</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.Position.y = (VertexID == <span class="hljs-number"><span class="hljs-number">2</span></span>)? <span class="hljs-number"><span class="hljs-number">3.0</span></span>f : <span class="hljs-number"><span class="hljs-number">-1.0</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.Position.zw = <span class="hljs-number"><span class="hljs-number">1.0</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.TexCoord = <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.Position.xy * float2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">-0.5</span></span>f) + <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>; } [Fragment shader] Texture2D BackBuffer; Texture2D &lt;float2&gt; GeometryBuffer; SamplerState Linear; SamplerState <span class="hljs-type"><span class="hljs-type">Point</span></span>; float2 PixelSize; <span class="hljs-type"><span class="hljs-type">float4</span></span> main(PsIn <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>) : SV_Target { float2 <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = GeometryBuffer.Sample(<span class="hljs-type"><span class="hljs-type">Point</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.TexCoord); // <span class="hljs-keyword"><span class="hljs-keyword">Check</span></span> geometry buffer <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> an edge cutting through the pixel. [flatten] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (min(abs(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.x), abs(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.y)) &gt;= <span class="hljs-number"><span class="hljs-number">0.5</span></span>f) { // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> edge was <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> we look <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> neighboring pixels<span class="hljs-string"><span class="hljs-string">' geometry information. This is necessary because // relevant geometry information may only be available on one side of an edge, such as on silhouette edges, // where a background pixel adjacent to the edge will have the background'</span></span>s geometry information, <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> // the foreground<span class="hljs-string"><span class="hljs-string">'s geometric edge that we need to antialias against. Doing this step covers up gaps in the // geometry information. offset = 0.5f; // We only need to check the component on neighbor samples that point towards us float offset_x0 = GeometryBuffer.Sample(Point, In.TexCoord, int2(-1, 0)).x; float offset_x1 = GeometryBuffer.Sample(Point, In.TexCoord, int2( 1, 0)).x; float offset_y0 = GeometryBuffer.Sample(Point, In.TexCoord, int2( 0, -1)).y; float offset_y1 = GeometryBuffer.Sample(Point, In.TexCoord, int2( 0, 1)).y; // Check range of neighbor pixels'</span></span> distance <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> use <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> edge cuts this pixel. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abs(offset_x0 - <span class="hljs-number"><span class="hljs-number">0.75</span></span>f) &lt; <span class="hljs-number"><span class="hljs-number">0.25</span></span>f) <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = float2(offset_x0 - <span class="hljs-number"><span class="hljs-number">1.0</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f); // Left x-<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> [ <span class="hljs-number"><span class="hljs-number">0.5</span></span> .. <span class="hljs-number"><span class="hljs-number">1.0</span></span>] cuts this pixel <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abs(offset_x1 + <span class="hljs-number"><span class="hljs-number">0.75</span></span>f) &lt; <span class="hljs-number"><span class="hljs-number">0.25</span></span>f) <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = float2(offset_x1 + <span class="hljs-number"><span class="hljs-number">1.0</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f); // Right x-<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> [<span class="hljs-number"><span class="hljs-number">-1.0</span></span> .. <span class="hljs-number"><span class="hljs-number">-0.5</span></span>] cuts this pixel <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abs(offset_y0 - <span class="hljs-number"><span class="hljs-number">0.75</span></span>f) &lt; <span class="hljs-number"><span class="hljs-number">0.25</span></span>f) <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = float2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, offset_y0 - <span class="hljs-number"><span class="hljs-number">1.0</span></span>f); // Up y-<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> [ <span class="hljs-number"><span class="hljs-number">0.5</span></span> .. <span class="hljs-number"><span class="hljs-number">1.0</span></span>] cuts this pixel <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abs(offset_y1 + <span class="hljs-number"><span class="hljs-number">0.75</span></span>f) &lt; <span class="hljs-number"><span class="hljs-number">0.25</span></span>f) <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = float2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, offset_y1 + <span class="hljs-number"><span class="hljs-number">1.0</span></span>f); // Down y-<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> [<span class="hljs-number"><span class="hljs-number">-1.0</span></span> .. <span class="hljs-number"><span class="hljs-number">-0.5</span></span>] cuts this pixel } // Convert distance <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> texture coordinate shift float2 <span class="hljs-keyword"><span class="hljs-keyword">off</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> &gt;= float2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>))? float2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f) : float2(<span class="hljs-number"><span class="hljs-number">-0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">-0.5</span></span>f); <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>; // Blend pixel <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> neighbor pixel <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> texture filtering <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> shifting the coordinate appropriately. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BackBuffer.Sample(Linear, <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.TexCoord + <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> * PixelSize); }</code> </pre><br></div></div><br><br><h4>  Modification </h4><br>  The GBAA has an unpleasant feature, expressed in artifacts near the converging ribs: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/680/ac4/bc8/680ac4bc88b430c40d29dd1029a27fd9.png" alt="GBAA artifacts"></div><br><br>  Thin sub-pixel triangles are a source of problems for all post-filtering algorithms that work with the image in screen resolution, and, unfortunately, GBAA is no exception.  I tried to understand the mechanism of the occurrence of these artifacts and modify the original algorithm in order to improve the quality of anti-aliasing in problem cases.  Consider the first case: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ba/b0a/71e/7bab0a71edaeab5f83cc4cab86fd7e4c.png" alt="GBAA artifact 1"></div><br><br>  Here, the sampling point of the current pixel in the center falls inside a thin triangle, and the sampling points of the left and right pixels fall into large triangles adjacent to a thin one.  If the right edge of a thin triangle is closer to the center of the middle pixel, as shown in the picture, then GBAA will determine the coverage of the right triangle with the middle pixel based on the offset of the right edge relative to its center, and then produce a linearly interpolated color between the middle and right pixels.  However, the middle pixel covers fragments of three triangles at once, and if the color of at least one pixel differs from the others, the resulting color will be determined incorrectly.  Let <i>a</i> , <i>b</i> , <i>c</i> be the original colors of three pixels, and <i>Œ±</i> , <i>Œ≤</i> , <i>Œ≥</i> be the ratio of the areas of the triangle fragments covered with the average pixel to the area of ‚Äã‚Äãthe pixel.  The corrected color of the average pixel in this case can be determined by the formula <br><br>  <i>b <sub>out</sub> = Œ±a + Œ≤b + Œ≥c</i> , <br><br>  while the original algorithm will calculate it using the formula <br><br>  <i>b <sub>out</sub> = (Œ± + Œ≤) b + Œ≥c</i> <br><br>  If, for example, the left pixel turns out to be white, and the middle and right pixels turn black, then in the described situation the original algorithm will always produce black for the middle pixel, leaving a fragment of the original image unchanged. <br><br>  The second case occurs when a thin triangle is located between the centers of two pixels: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f21/2e3/771/f212e37710c624f8825906ad1f6dbc07.png" alt="GBAA artifact 2 - example 1"></div><br><br>  Here, in contrast to the first case, part of the information necessary for calculating the correct color is lost: there is no sample point that would fall inside a thin triangle.  To understand how such a case can affect the final image, consider a larger fragment: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e14/5a9/d93/e145a9d937d8017cbd2e2e82abfb628b.png" alt="GBAA artifact 2 - example 2"></div><br><br>  Since, when shifting to the right, the darker triangles are shifted upwards, occupying an ever smaller area, the brightness of the pixels in the upper row should increase.  This happens until the queue reaches the last column.  The case that arises during its processing was considered earlier.  Here the main source of the problem is the first two columns: the upper pixels should get their original color, but instead the original algorithm mixes them with the colors of the lower pixels.  On the left is a fragment of the triangle border, obtained using the wrong blending coefficients, on the right - the correct result: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e87/882/558/e87882558166d23e4392c9fc96174f38.png" alt="GBAA artifact 2 results"></div><br><br>  The behavior of the original algorithm in this case can be improved by retaining the original colors of the pixels, between which there is a thin triangle. <br><br>  To handle these two cases, you can make several changes to the original algorithm. <br><br><ol><li>  The correct calculation of the pixel color in the case of the first case requires the presence of information about the second offset, while the original algorithm stores only one.  This will require additional space in the geometric buffer.  If there is a second offset along the same axis as the first, but opposite to it, then this offset must also be stored in a geometric buffer.  At the post-processing stage, in order to determine the triple coverage case, it is necessary to check whether the pixel intersects with two edges from different sides, and if it intersects, calculate the corrected color. <br><br></li><li>  The processing of the second case has a minimal effect on the structure of the algorithm, requiring additional checks to be made during the post-processing stage.  A pixel should receive its original color if there is a neighboring pixel in the direction of the corresponding offset, which corresponds to the opposite offset direction in the same axis. <br></li></ol><br><br><div class="spoiler">  <b class="spoiler_title">Shader Code (HLSL)</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">struct PsIn { <span class="hljs-type"><span class="hljs-type">float4</span></span> Position : SV_Position; float2 TexCoord : TexCoord; }; [Vertex shader] PsIn main(uint VertexID : SV_VertexID) { // Produce a fullscreen triangle PsIn <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.Position.x = (VertexID == <span class="hljs-number"><span class="hljs-number">0</span></span>)? <span class="hljs-number"><span class="hljs-number">3.0</span></span>f : <span class="hljs-number"><span class="hljs-number">-1.0</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.Position.y = (VertexID == <span class="hljs-number"><span class="hljs-number">2</span></span>)? <span class="hljs-number"><span class="hljs-number">3.0</span></span>f : <span class="hljs-number"><span class="hljs-number">-1.0</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.Position.zw = <span class="hljs-number"><span class="hljs-number">1.0</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.TexCoord = <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>.Position.xy * float2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">-0.5</span></span>f) + <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Out</span></span>; } [Fragment shader] Texture2D BackBuffer; Texture2D &lt;float2&gt; GeometryBuffer; Texture2D &lt;<span class="hljs-type"><span class="hljs-type">float</span></span>&gt; InvGeometryBuffer; SamplerState Linear; SamplerState <span class="hljs-type"><span class="hljs-type">Point</span></span>; float2 PixelSize; <span class="hljs-type"><span class="hljs-type">int</span></span> Tweak; <span class="hljs-type"><span class="hljs-type">int</span></span> ShowEdges; <span class="hljs-type"><span class="hljs-type">void</span></span> check_opposite_neighbor(float2 tex_coord, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> float2 <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>) { // <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> major <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> float2 <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; <span class="hljs-type"><span class="hljs-type">bool</span></span> x_major = abs(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.x) &lt; abs(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x_major) <span class="hljs-keyword"><span class="hljs-keyword">off</span></span> = float2(sign(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.x), <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span> = float2(<span class="hljs-number"><span class="hljs-number">0</span></span>, sign(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.y)); // <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> neighbor<span class="hljs-string"><span class="hljs-string">'s offset float2 opp_offset = GeometryBuffer.Sample(Point, tex_coord + off*PixelSize); // Make sure it is valid bool apply_offset = true; if (min(abs(opp_offset.x), abs(opp_offset.y)) &lt; 0.5f) { // Make sure it points towards current sample // if so - don'</span></span>t apply texture coordinate <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x_major) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sign(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.x)!=sign(opp_offset.x) &amp;&amp; abs(opp_offset.x) &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>f) <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sign(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.y)!=sign(opp_offset.y) &amp;&amp; abs(opp_offset.y) &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>f) <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; } } } <span class="hljs-type"><span class="hljs-type">float4</span></span> main(PsIn <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>) : SV_Target { float2 <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = GeometryBuffer.Sample(<span class="hljs-type"><span class="hljs-type">Point</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.TexCoord); <span class="hljs-type"><span class="hljs-type">bool</span></span> edge_found = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-type"><span class="hljs-type">bool</span></span> triple_coverage = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> result; // <span class="hljs-keyword"><span class="hljs-keyword">Check</span></span> geometry buffer <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> an edge cutting through the pixel. [flatten] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (min(abs(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.x), abs(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.y)) &gt;= <span class="hljs-number"><span class="hljs-number">0.5</span></span>f) { // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> edge was <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> we look <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> neighboring pixels<span class="hljs-string"><span class="hljs-string">' geometry information. This is necessary because // relevant geometry information may only be available on one side of an edge, such as on silhouette edges, // where a background pixel adjacent to the edge will have the background'</span></span>s geometry information, <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> // the foreground<span class="hljs-string"><span class="hljs-string">'s geometric edge that we need to antialias against. Doing this step covers up gaps in the // geometry information. offset = 0.5f; // We only need to check the component on neighbor samples that point towards us float offset_x0 = GeometryBuffer.Sample(Point, In.TexCoord, int2(-1, 0)).x; float offset_x1 = GeometryBuffer.Sample(Point, In.TexCoord, int2( 1, 0)).x; float offset_y0 = GeometryBuffer.Sample(Point, In.TexCoord, int2( 0, -1)).y; float offset_y1 = GeometryBuffer.Sample(Point, In.TexCoord, int2( 0, 1)).y; // Check range of neighbor pixels'</span></span> distance <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> use <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> edge cuts this pixel. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abs(offset_x0 - <span class="hljs-number"><span class="hljs-number">0.75</span></span>f) &lt; <span class="hljs-number"><span class="hljs-number">0.25</span></span>f) { edge_found = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = float2(offset_x0 - <span class="hljs-number"><span class="hljs-number">1.0</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f); // Left x-<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> [ <span class="hljs-number"><span class="hljs-number">0.5</span></span> .. <span class="hljs-number"><span class="hljs-number">1.0</span></span>] cuts this pixel } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abs(offset_x1 + <span class="hljs-number"><span class="hljs-number">0.75</span></span>f) &lt; <span class="hljs-number"><span class="hljs-number">0.25</span></span>f) { edge_found = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = float2(offset_x1 + <span class="hljs-number"><span class="hljs-number">1.0</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f); // Right x-<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> [<span class="hljs-number"><span class="hljs-number">-1.0</span></span> .. <span class="hljs-number"><span class="hljs-number">-0.5</span></span>] cuts this pixel } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abs(offset_y0 - <span class="hljs-number"><span class="hljs-number">0.75</span></span>f) &lt; <span class="hljs-number"><span class="hljs-number">0.25</span></span>f) { edge_found = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = float2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, offset_y0 - <span class="hljs-number"><span class="hljs-number">1.0</span></span>f); // Up y-<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> [ <span class="hljs-number"><span class="hljs-number">0.5</span></span> .. <span class="hljs-number"><span class="hljs-number">1.0</span></span>] cuts this pixel } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abs(offset_y1 + <span class="hljs-number"><span class="hljs-number">0.75</span></span>f) &lt; <span class="hljs-number"><span class="hljs-number">0.25</span></span>f) { edge_found = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = float2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, offset_y1 + <span class="hljs-number"><span class="hljs-number">1.0</span></span>f); // Down y-<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> [<span class="hljs-number"><span class="hljs-number">-1.0</span></span> .. <span class="hljs-number"><span class="hljs-number">-0.5</span></span>] cuts this pixel } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { edge_found = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Tweak) { <span class="hljs-type"><span class="hljs-type">float</span></span> inv_offset = InvGeometryBuffer.Sample(<span class="hljs-type"><span class="hljs-type">Point</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.TexCoord); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inv_offset != <span class="hljs-number"><span class="hljs-number">0.0</span></span>f) { triple_coverage = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; // Sample two neighbors <span class="hljs-type"><span class="hljs-type">float</span></span> maj_offset; float2 <span class="hljs-keyword"><span class="hljs-keyword">off</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abs(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.x) &lt; abs(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.y)) { <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>.x = -sign(inv_offset); maj_offset = <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.x; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>.y = -sign(inv_offset); maj_offset = <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>.y; } <span class="hljs-type"><span class="hljs-type">float4</span></span> n1 = BackBuffer.Sample(<span class="hljs-type"><span class="hljs-type">Point</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.TexCoord + <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>*PixelSize); <span class="hljs-type"><span class="hljs-type">float4</span></span> n2 = BackBuffer.Sample(<span class="hljs-type"><span class="hljs-type">Point</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.TexCoord - <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>*PixelSize); // Calculate coverage <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> this sample (b) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> two neighbors (a, c) <span class="hljs-type"><span class="hljs-type">float</span></span> alpha = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f-abs(maj_offset); // a (n1) <span class="hljs-type"><span class="hljs-type">float</span></span> gamma = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f-abs(inv_offset); // c (n2) <span class="hljs-type"><span class="hljs-type">float</span></span> beta = <span class="hljs-number"><span class="hljs-number">1</span></span>-alpha-gamma; // b (this) // Blend final color result = alpha*n1 + beta*BackBuffer.Sample(<span class="hljs-type"><span class="hljs-type">Point</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.TexCoord) + gamma*n2; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> check_opposite_neighbor(<span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.TexCoord, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ShowEdges &amp;&amp; edge_found) result = <span class="hljs-type"><span class="hljs-type">float4</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!triple_coverage) { // Convert distance <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> texture coordinate shift float2 <span class="hljs-keyword"><span class="hljs-keyword">off</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> &gt;= float2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>))? float2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f) : float2(<span class="hljs-number"><span class="hljs-number">-0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">-0.5</span></span>f); <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>; // Blend pixel <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> neighbor pixel <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> texture filtering <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> shifting the coordinate appropriately. result = BackBuffer.Sample(Linear, <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>.TexCoord + <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> * PixelSize); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br></div></div><br><h4>  Tests </h4><br>  To compare the quality of antialiasing, fragments of the scene were selected, in which the original GBAA produced noticeable artifacts.  Then, for each fragment, the camera position was fixed and 4 screenshots were saved: the original image, the original image with highlighted edges, the result of the GBAA and the result of the modified GBAA. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/951/27b/b45/95127bb45a1f908d2266c1418fb9c0f9.png" alt="Results - 1"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2db/9b9/8ed/2db9b98ed46c7d87dd0ad1e51e01fc33.png" alt="Results - 2"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca0/fbe/014/ca0fbe014d76782a3517019697693362.png" alt="Results - 3"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/445/45f/fe8/44545ffe85f6a746e653a9b10e8cb879.png" alt="Results - 4"></div><br><br>  Although the quality of the fragments with converging edges still cannot be called ideal, the artifacts on them became much less noticeable.  Scenes with complex textures mask residual effects well.  The achieved improvement in quality is obtained at the price of some drop in productivity.  If the post-processing stage of the original GBAA took 0.14 ms at a resolution of 1920x1080, then the modified algorithm requires 0.22 ms, which is 57% more.  However, even this level of performance continues to be more than satisfactory, leaving behind MLAA and its modifications. <br><br><h4>  Conclusion </h4><br>  It should be noted that I did not make much effort to optimize the branching in the pixel shader - this could give an increase in performance.  New GPU architectures, such as <abbr title="Graphics Core Next">GCN</abbr> , <a href="https://michaldrobot.com/2014/05/12/low-level-optimizations-for-gcn-digital-dragons-2014-slides/">provide the ability to read vertex attributes in a pixel shader</a> , which allows you to implement an algorithm (both original and modified) without using a geometric shader, eliminating the associated overhead. <br><br>  Compiled binaries and sources are available on <a href="https://github.com/nitrocaster/gbaa-plus">GitHub</a> . </div><p>Source: <a href="https://habr.com/ru/post/307366/">https://habr.com/ru/post/307366/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../307356/index.html">Network Evolution to SDN & NFV</a></li>
<li><a href="../307358/index.html">We raise micromonitoring on icinga2 with minimal costs</a></li>
<li><a href="../307360/index.html">Asynchronous programming in 1C via .Net Native VK</a></li>
<li><a href="../307362/index.html">Model of watercraft interaction in video games</a></li>
<li><a href="../307364/index.html">The book "The secrets of CSS. Perfect solutions to daily tasks. ‚Äù</a></li>
<li><a href="../307368/index.html">AI monsters and finding the way with heatmaps</a></li>
<li><a href="../307372/index.html">Cremes is a new advanced cyber spyware malware.</a></li>
<li><a href="../307374/index.html">Alternative to .clearfix</a></li>
<li><a href="../307378/index.html">A little about unconventional mapping</a></li>
<li><a href="../307380/index.html">How important it is to write code that people can read</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>