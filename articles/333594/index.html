<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The system of rewinding time in the style of Prince of Persia</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this tutorial, we will create a simple game in which the player can rewind actions. We will do it in Unity, but it is possible to adapt the system ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The system of rewinding time in the style of Prince of Persia</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/310/e36/309/310e36309ceb7f88414943b6bbc43ffd.jpg" alt="image"><br><br>  In this tutorial, we will create a simple game in which the player can <em>rewind</em> actions.  We will do it in Unity, but it is possible to adapt the system to other engines.  In the first part we will look at the basics of this function, and in the second we will write its backbone and make it more universal. <br><br>  First, let's look at the games that use such a system.  We will explore the various uses of this technique, and then create a little game with the rewind function. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/aae/bb5/f73/aaebb5f73c30ad7ed75bf2759b1e4587.gif"><br>  <i>Demonstration of key features</i> <br><br>  You will need the latest version of <a href="https://unity3d.com/" rel="external">Unity</a> and experience with the engine.  The source code will be made publicly available so you can compare your results with it. <br><br>  Ready?  Go! <br><a name="habracut"></a><br><h2>  How is this system used in other games? </h2><br>  <em>Prince of Persia: The Sands of Time</em> was one of the first games with time rewinding mechanics built into the gameplay.  When a player dies, he can not only restart the game, but also rewind it a few seconds back, at the time when the character is still alive, and immediately try again. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/43b/219/01f/43b21901f875b5fc7f513c7a653a9307.jpg"><br>  <em>Prince of Persia: The Forgotten Sands.</em>  <em>The <em>Sands Of Time</em> trilogy has perfectly integrated time rewind into its gameplay.</em>  <em>Due to this, the player is not interrupted for fast loading and remains immersed in the game.</em> <br><br>  This mechanic is integrated not only into the gameplay, but also into the narrative and the very universe of the game, and is mentioned throughout the plot. <br><br>  A similar system is used in games such as <em>Braid</em> , in which the gameplay is also closely related to time rewind.  The heroine of the game <em>Overwatch</em> Tracer has the ability, which returns her to the place where she was a few seconds ago, that is, <em>rewinds</em> her time, even in a multiplayer game.  In the <em>GRID</em> racing game series, there is also a snapshot mechanic: during the race, the player has a small supply of rewinds, which can be used when the car gets into a serious accident.  This saves players from the annoyance that occurs during accidents at the end of the race. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e80/197/82f/e8019782fcae182714ba8b1110f1ebd3.jpg"><br>  <i>In a serious collision in GRID, you have the opportunity to rewind the game at the time before the accident.</i> <br><br><h2>  Other examples of use </h2><br>  But this system can be used not only as a substitute for quick save.  Another use is to implement ghosts in racing games and asynchronous multiplayer mode. <br><br><h3>  Replays </h3><br>  This is another interesting way to use the function.  It is used in games like <em>SUPERHOT</em> , in the <em>Worms</em> series, and in most sports games. <br><br>  Sports replays work almost the same way as shown on television: the process of the game is shown repeatedly, sometimes from a different angle.  To do this, the games are recorded not in the video, but in the user's actions, thanks to which you can play replays from different angles and angles.  In the Worms games, replays are served with humor: instant replays of very funny or effective kills are shown. <br><br>  SUPERHOT also records movement.  After passing the level, a replay of the entire gameplay is shown, which fits in just a few seconds. <br><br>  Funny replays in Super Meat Boy.  After passing the level, the player sees all previous attempts superimposed on each other. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8a6/445/106/8a64451063bd8364eb007c9529403388.jpg"><br>  <i>Replay at the end of the <em>Super Meat Boy</em> level.</i>  <i>All previous attempts are recorded and then played at the same time.</i> <br><br><h3>  Ghost Racing </h3><br>  <em>A ghost race</em> is a technique in which a player drives an empty track, trying to show the best time.  But at the same time, he competes with a <em>ghost</em> - a translucent machine, exactly the same path as the best previous player attempt.  It is impossible to face it, that is, the player can concentrate on achieving the best time. <br><br>  In order not to ride alone, you can <em>compete</em> with yourself, which makes the time trial more interesting.  This feature is used in most racing games, from the <em>Need for Speed</em> series to <em>Diddy Kong Racing</em> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/878/362/aca/878362aca450e0f14ee724a3428e39bd.jpg"><br>  <em>Race with a ghost in Trackmania Nations.</em>  <em>This is a "silver" complexity, it means that the player will receive a silver medal if he overtakes the ghost.</em>  <em>Notice that the models of cars intersect, that is, the ghost is not material and can be passed through.</em> <br><br><h3>  Ghosts in multiplayer modes </h3><br>  Another way to use the function is ghosts in multiuser asynchronous mode.  In this rarely used feature, multiplayer matches are performed by recording data from one player, which is sent to another player, who then <em>competes</em> with the first.  The data is applied in the same way as in races with a ghost, only the competition takes place with another player. <br><br>  This type of competition is used in <em>Trackmania</em> games, where you can drive on various difficulties.  Such recorded riders become opponents who must be defeated in order to receive a reward. <br><br><h3>  Montage of shooting </h3><br>  In some games, rewinding can be just a fun tool.  <em>Team Fortress 2</em> has a built-in replay editor in which you can create your own videos. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc8/dab/66d/bc8dab66d728a2645526f48283b5f7d8.jpg"><br>  <i><em>Team Fortress 2</em> replay editor.</i>  <i>The recorded battle can be viewed from any point of view, and not just from the eyes of the player.</i> <br><br>  After enabling the function, you can record and view previous matches.  It is very important that <em>everything is</em> recorded, and not just what the player sees.  This means that you can navigate through the recorded game world, see where everyone is <em>and</em> manage time. <br><br><h2>  How to implement it </h2><br>  To test this system, we need a simple game.  Let's create it! <br><br><h3>  Player </h3><br>  Create a cube in the scene, it will be a player character.  Then create a new C # script called <code>Player.cs</code> and add the following to the <code>Update()</code> function: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.Translate (Vector3.forward * <span class="hljs-number"><span class="hljs-number">3.0f</span></span> * Time.deltaTime * Input.GetAxis (<span class="hljs-string"><span class="hljs-string">"Vertical"</span></span>)); transform.Rotate (Vector3.up * <span class="hljs-number"><span class="hljs-number">200.0f</span></span> * Time.deltaTime * Input.GetAxis (<span class="hljs-string"><span class="hljs-string">"Horizontal"</span></span>)); }</code> </pre> <br>  So we can control the character with the arrows.  Attach the script to the cube.  Now, after clicking on Play, you can move around.  Change the angle of the camera so that it looks at the cube from above.  Finally, create a <em>floor</em> plane and assign each object its own material so that we do not move in the void.  You should have something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/552/d19/f3d/552d19f3df5dbea500a3cc316bb95343.jpg"><br><br>  Try to control the cube with WSAD and the arrow keys <br><br><h3>  Timecontroller </h3><br>  Now create a new C # <code>TimeController.cs</code> and add it to the new empty GameObject.  He will manage the recording and rewind of the game. <br><br>  For this to work, we will record the movement of the player‚Äôs character.  After clicking the rewind button, we will change the coordinates of the character.  First, create a variable that stores the character: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject player;</code> </pre> <br>  Assign a player object to the resulting TimeController slot so that it can have access to the player and his data. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d01/1a3/3ea/d011a33ea252025b5dc30eec214f86e2.jpg"><br><br>  Then you need to create an array to store player data: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArrayList playerPositions; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { playerPositions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); }</code> </pre> <br>  Now we need to continuously record the position of the player.  We will have the saved position of the player in the last frame, the position in which the player was 6 frames back and the position where the player was 8 seconds ago (or any recording time you specified).  When we press the play key, we will go back through the array of positions and assign them frame by frame, resulting in a time rewind function. <br><br>  First, let's save the data: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixedUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { playerPositions.Add (player.transform.position); }</code> </pre> <br>  In the <code>FixedUpdate()</code> function, we write data.  <code>FixedUpdate()</code> is used because it runs at a constant frequency of 50 cycles per second (or any selected value), which allows us to write data at a fixed interval.  The <code>Update()</code> function is performed with the frequency that the processor provides, which would complicate our work. <br><br>  This code will save each frame in the array position of the player.  Now we need to apply it! <br><br>  We will add a check for pressing the rewind button.  To do this, we need a boolean variable: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isReversing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  And check in the <code>Update()</code> function: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Input.GetKey(KeyCode.Space)) { isReversing = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { isReversing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  To play the game <em>in the opposite direction</em> , we need to apply the data instead of recording.  The new code for recording and applying the player‚Äôs position should look like this: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixedUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!isReversing) { playerPositions.Add (player.transform.position); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { player.transform.position = (Vector3) playerPositions[playerPositions.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; playerPositions.RemoveAt(playerPositions.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre> <br>  And the whole <code>TimeController</code> script will look like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TimeController</span></span>: <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject player; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArrayList playerPositions; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isReversing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { playerPositions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Input.GetKey(KeyCode.Space)) { isReversing = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { isReversing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixedUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!isReversing) { playerPositions.Add (player.transform.position); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { player.transform.position = (Vector3) playerPositions[playerPositions.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; playerPositions.RemoveAt(playerPositions.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); } } }</code> </pre> <br>  Also, do not forget to add to the <code>player</code> class a check on whether the <code>TimeController</code> rewinding in order to perform a motion only if it is not playing.  Otherwise, the behavior may become strange: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Player</span></span>: <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TimeController timeController; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { timeController = FindObjectOfType(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TimeController)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TimeController; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!timeController.isReversing) { transform.Translate (Vector3.forward * <span class="hljs-number"><span class="hljs-number">3.0f</span></span> * Time.deltaTime * Input.GetAxis (<span class="hljs-string"><span class="hljs-string">"Vertical"</span></span>)); transform.Rotate (Vector3.up * <span class="hljs-number"><span class="hljs-number">200.0f</span></span> * Time.deltaTime * Input.GetAxis (<span class="hljs-string"><span class="hljs-string">"Horizontal"</span></span>)); } } }</code> </pre><br>  These new lines will automatically find a <code>TimeController</code> object in the scene at startup and check it during execution.  We can control the character only when rewinding is not performed. <br><br>  Now we can move around the world and rewind backward movement with the space bar.  You can download the package at the link at the end of the article and open <strong>TimeRewindingFunctionality01</strong> to check the work! <br><br>  But wait, why does our simple cube player continue to look in the last direction in which we left it?  Because we did not guess to record the rotation of the object! <br><br>  To do this, we need another array created at the beginning to save and use data. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TimeController</span></span>: <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject player; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArrayList playerPositions; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArrayList playerRotations; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isReversing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { playerPositions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); playerRotations = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Input.GetKey(KeyCode.Space)) { isReversing = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { isReversing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixedUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!isReversing) { playerPositions.Add (player.transform.position); playerRotations.Add (player.transform.localEulerAngles); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { player.transform.position = (Vector3) playerPositions[playerPositions.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; playerPositions.RemoveAt(playerPositions.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); player.transform.localEulerAngles = (Vector3) playerRotations[playerRotations.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; playerRotations.RemoveAt(playerRotations.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); } } }</code> </pre> <br>  Try running!  <strong>TimeRewindingFunctionality02</strong> is an enhanced version.  Now our cube player can move back in time and will look exactly as it looked at the appropriate moment. <br><br><h2>  Conclusion </h2><br>  We have created a simple prototype of the game with an already fully working time rewind system, but it is still far from perfect.  Next, we will make it much more stable and versatile, as well as add interesting effects. <br><br>  Here is what we still have to do: <br><br><ul><li>  Record only every 12th frame and interpolate states between recorded frames so that the data volume is not too huge. <br></li><li>  Record only the last 75 positions and turns of the player so that the array does not become too bulky and the game does not crash. </li></ul><br>  In addition, we will consider how to expand this system so that it acts not only for the player: <br><br><ul><li>  How to record not only one player </li><li>  Add an effect that tells you to rewind (such as blurring a VHS signal) </li><li>  Use to store the position and rotation of the player's own class, rather than arrays </li></ul><br>  <a href="">Unity project archive</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/531/a1d/d4d/531a1dd4d4cb3c0a1aa6fac0b9bcf96e.jpg"><br><br>  So, we have created a simple game in which you can rewind time to the previous point.  Now we can improve this function and make its use much more interesting. <br><br><h2>  Write less data and interpolate </h2><br>  At the moment we are recording the positions and turns of the player <strong>50</strong> times per second.  This amount of data will quickly become overwhelming, and this will be especially noticeable in more complex games, as well as on weak mobile devices. <br><br>  Instead, we can write only 4 times per second and interpolate the position and rotation between these keyframes.  This way we will save 92% of performance, and the results will be seemingly indistinguishable from records with 50 frames per second, because they are reproduced in a fraction of a second. <br><br>  Let's start by recording key frames every x frames.  To do this, we first need new variables: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> keyframe = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> frameCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  The <code>keyframe</code> variable is a frame in the <code>FixedUpdate</code> method in which we will write player data.  Currently, it is assigned the value <strong>5</strong> , that is, the data will be recorded on every fifth cycle of the execution of the <code>FixedUpdate</code> method.  Since <code>FixedUpdate</code> is executed 50 times per second, 10 frames will be recorded per second.  The <code>frameCounter</code> variable will be used as a frame counter to the next keyframe. <br><br>  Now we will change the record block in the <code>FixedUpdate</code> function to make it look like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!isReversing) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(frameCounter &lt; keyframe) { frameCounter += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { frameCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; playerPositions.Add (player.transform.position); playerRotations.Add (player.transform.localEulerAngles); } }</code> </pre> <br>  If you try to start the game now, you will see that now rewinding takes much less time.  It happened so because we write less data, but we reproduce it at normal speed.  Need to fix it. <br><br>  First, we need another <code>frameCounter</code> variable in order not to write data, but to reproduce it. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> reverseCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Correct the code that restores the position of the player to use it in the same way as we write data.  The <code>FixedUpdate</code> function should look like this: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixedUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!isReversing) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(frameCounter &lt; keyframe) { frameCounter += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { frameCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; playerPositions.Add (player.transform.position); playerRotations.Add (player.transform.localEulerAngles); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(reverseCounter &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { reverseCounter -= <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { player.transform.position = (Vector3) playerPositions[playerPositions.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; playerPositions.RemoveAt(playerPositions.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); player.transform.localEulerAngles = (Vector3) playerRotations[playerRotations.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; playerRotations.RemoveAt(playerRotations.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); reverseCounter = keyframe; } } }</code> </pre> <br>  Now when rewinding the player will jump to previous positions in real time! <br><br>  But we didn‚Äôt really want this  We need to interpolate the positions between these keyframes, which will be a bit more difficult.  First, we need four variables: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 currentPosition; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 previousPosition; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 currentRotation; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 previousRotation;</code> </pre> <br>  They will store the current player data and one keyframe recorded to the current data so that we can interpolate between them. <br><br>  Then we need this function: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RestorePositions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = keyframes.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> secondToLastIndex = keyframes.Count - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(secondToLastIndex &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { currentPosition = (Vector3) playerPositions[lastIndex]; previousPosition = (Vector3) playerPositions[secondToLastIndex]; playerPositions.RemoveAt(lastIndex); currentRotation = (Vector3) playerRotations[lastIndex]; previousRotation = (Vector3) playerRotations[secondToLastIndex]; playerRotations.RemoveAt(lastIndex); } }</code> </pre> <br>  It assigns the appropriate information to position and rotation variables, between which we will perform interpolation.  We will do this in a separate function, because we call it for two different points. <br><br>  The data recovery unit will look like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(reverseCounter &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { reverseCounter -= <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reverseCounter = keyframe; RestorePositions(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(firstRun) { firstRun = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; RestorePositions(); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> interpolation = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) reverseCounter / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) keyframe; player.transform.position = Vector3.Lerp(previousPosition, currentPosition, interpolation); player.transform.localEulerAngles = Vector3.Lerp(previousRotation, currentRotation, interpolation);</code> </pre> <br>  We call the function to retrieve the last and the penultimate data set from the arrays at a given interval of key frames (in our case it is <strong>5</strong> ), but we also need to call it in the first cycle when the restoration is performed.  Therefore, we need this block: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(firstRun) { firstRun = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; RestorePositions(); }</code> </pre> <br>  To make it work, we also need the variable <code>firstRun</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> firstRun = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br>  And to reset when you release the spacebar: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Input.GetKey(KeyCode.Space)) { isReversing = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { isReversing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; firstRun = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Here's how interpolation works: instead of just using the last saved keyframe, this system gets the last and the last but one frames, then interpolates the data between them.  The amount of interpolation depends on the current distance between frames. <br><br>  Interpolation is performed by the Lerp function, by which we transfer the current and previous position (or rotation).  Then the interpolation coefficient is calculated, which can have values ‚Äã‚Äãfrom <strong>0</strong> to <strong>1</strong> .  Then the player is placed between two saved points, for example, 40% on the way to the last keyframe. <br><br>  If you slow down and reproduce it frame by frame, then you can actually see how the character moves between these keyframes, but this is imperceptible during the game. <br><br>  Thus, we have significantly reduced the complexity of the time rewind scheme and made it much more stable. <br><br><h2>  Record only a fixed number of frames </h2><br>  By drastically reducing the number of frames saved, we can now ensure that the system does not save too much data. <br><br>  Now it's just a bunch of data written to the array, not designed for long-term use.  As the array grows, it becomes more cumbersome and access takes more time, and the whole system becomes unstable. <br><br>  To fix this, we can add code that checks to see if the array has grown larger than a certain size.  If we know how many frames per second we save, we can determine how many seconds of rewinding time need to be stored so that it does not interfere with the game and does not increase its complexity.  In the rather complex <em>Prince of Persia</em> , the rewind time is limited to about 15 seconds, and in the more technically simple <em>Braid</em> game, the rewind can be endless. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(playerPositions.Count &gt; <span class="hljs-number"><span class="hljs-number">128</span></span>) { playerPositions.RemoveAt(<span class="hljs-number"><span class="hljs-number">0</span></span>); playerRotations.RemoveAt(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  When the array exceeds a certain size, we will delete its first element.  Therefore, it will always store as much data as a player can rewind, and will not interfere with efficiency.  Paste this code into the <code>FixedUpdate</code> function after the record and play code. <br><br><h2>  Using your own class to store player data </h2><br>  While we are recording the position and rotation of the player in two separate arrays.  Although this works, we need to constantly remember that we write and read data from two places at the same time, which can lead to problems in the future.  However, we can create a separate class for storing all this data, and in the future - for others (if necessary for the project). <br><br>  The code of our own class, which will be used as a container for data, is as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Keyframe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 rotation; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Keyframe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position, Vector3 rotation</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rotation = rotation; } }</code> </pre> <br>  You can add it to the TimeController.cs file before you start declaring classes.  He creates a container to save the position and rotation of the player.  The designer allows you to create it directly with all the necessary information. <br><br>  The rest of the algorithm must be adapted to work with the new system.  In the Start method, you must initialize the array: <br><br><pre> <code class="cs hljs">keyframes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList();</code> </pre> <br>  And instead of: <br><br><pre> <code class="cs hljs">playerPositions.Add (player.transform.position); playerRotations.Add (player.transform.localEulerAngles);</code> </pre> <br>  we can save directly to the Keyframe object: <br><br><pre> <code class="cs hljs">keyframes.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Keyframe(player.transform.position, player.transform.localEulerAngles));</code> </pre> <br>  Here we add the position and rotation of the player into one object, which is then added to a single array, which significantly reduces the complexity of the algorithm. <br><br><h2>  Adding a blur effect to indicate rewind </h2><br>  We really need some sign that says that time is rewinding.  So far, only <em>we</em> know about this, and this behavior can be confusing for the player.  In such situations, it is not bad to add different signals informing the player about the rewinding performed, both visual (for example, a slight blurring of the screen) and sound (slowing down and playing music in reverse order). <br><br>  Let's do something in the style of <em>Prince of Persia by</em> adding a little blur. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8a8/b3f/71b/8a8b3f71b546bf99ec08392c5e3b14c8.jpg"><br>  <i>Rewind time in Prince of Persia: The Forgotten Sands</i> <br><br>  Unity allows you to layered one on another several camera effects, and experimenting, you can choose the perfect fit for your project. <br><br>  To use basic effects, you must first import them.  To do this, go to <strong>Assets&gt; Import Package&gt; Effects</strong> and import everything that we are offered. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/264/0ba/ce2/2640bace24abc93b9c83334060074d57.jpg"><br><br>  Visual effects can be applied directly to the camera.  Go to <strong>Components&gt; Image Effects</strong> and add <strong>Blur</strong> and <strong>Bloom</strong> effects.  Their combination creates a good effect, to which we aspire. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b75/155/973/b75155973b6e35f0dc9405c40f3f366e.jpg"><br><br>  These are the basic settings.  You can customize them according to your project. <br><br>  If you try to start the game now, it will use the effect constantly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed7/eff/3af/ed7eff3af91e55b725588b11896b2817.jpg"><br><br>  Now we need to learn how to enable and disable it.  To do this, you need to import <code>TimeController</code> effects into <code>TimeController</code> .  Add them to the very beginning: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityStandardAssets.ImageEffects;</code> </pre> <br>  To access the camera from <code>TimeController</code> , add this variable: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Camera camera;</code> </pre> <br>  And assign it a value in the <code>Start</code> function: <br><br><pre> <code class="cs hljs">camera = Camera.main;</code> </pre> <br>  Then add this code to turn on effects when rewinding time: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Input.GetKey(KeyCode.Space)) { isReversing = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; camera.GetComponent&lt;Blur&gt;().enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; camera.GetComponent&lt;Bloom&gt;().enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { isReversing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; firstRun = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; camera.GetComponent&lt;Blur&gt;().enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; camera.GetComponent&lt;Bloom&gt;().enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  When you press the spacebar, now you will not only rewind time in the scene, but also activate the camera rewind effect, informing the player about what is happening. <br><br>  All <code>TimeController</code> code should look like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityStandardAssets.ImageEffects; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Keyframe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 rotation; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Keyframe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position, Vector3 rotation</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rotation = rotation; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TimeController</span></span>: <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject player; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArrayList keyframes; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isReversing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> keyframe = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> frameCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> reverseCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 currentPosition; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 previousPosition; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 currentRotation; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 previousRotation; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Camera camera; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> firstRun = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { keyframes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); camera = Camera.main; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Input.GetKey(KeyCode.Space)) { isReversing = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; camera.GetComponent&lt;Blur&gt;().enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; camera.GetComponent&lt;Bloom&gt;().enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { isReversing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; firstRun = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; camera.GetComponent&lt;Blur&gt;().enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; camera.GetComponent&lt;Bloom&gt;().enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixedUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!isReversing) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(frameCounter &lt; keyframe) { frameCounter += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { frameCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; keyframes.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Keyframe(player.transform.position, player.transform.localEulerAngles)); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(reverseCounter &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { reverseCounter -= <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reverseCounter = keyframe; RestorePositions(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(firstRun) { firstRun = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; RestorePositions(); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> interpolation = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) reverseCounter / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) keyframe; player.transform.position = Vector3.Lerp(previousPosition, currentPosition, interpolation); player.transform.localEulerAngles = Vector3.Lerp(previousRotation, currentRotation, interpolation); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(keyframes.Count &gt; <span class="hljs-number"><span class="hljs-number">128</span></span>) { keyframes.RemoveAt(<span class="hljs-number"><span class="hljs-number">0</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RestorePositions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = keyframes.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> secondToLastIndex = keyframes.Count - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(secondToLastIndex &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { currentPosition = (keyframes[lastIndex] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Keyframe).position; previousPosition = (keyframes[secondToLastIndex] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Keyframe).position; currentRotation = (keyframes[lastIndex] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Keyframe).rotation; previousRotation = (keyframes[secondToLastIndex] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Keyframe).rotation; keyframes.RemoveAt(lastIndex); } } }</code> </pre> <br>  Download the <a href="">package with the project</a> and try to experiment with it. <br><br><h2>  Summarize </h2><br>  Our time rewinding game has become much better.  The algorithm is significantly improved, consumes 90% less computing power and is much more stable.  We have added an interesting effect telling the player that time is rewinding. <br><br>  It is time to make a real game on its basis! </div><p>Source: <a href="https://habr.com/ru/post/333594/">https://habr.com/ru/post/333594/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../333584/index.html">A collection of developer tools</a></li>
<li><a href="../333586/index.html">Bot for Telegram for 48 hours on Perl or how to buy cat food without leaving the chat</a></li>
<li><a href="../333588/index.html">Debugging the Android application using a browser</a></li>
<li><a href="../333590/index.html">Configuring the Apache CloudStack Failover Management Server using MariaDB Galera Replication</a></li>
<li><a href="../333592/index.html">Application of the principle of poka-yoke in programming using the example of PHP</a></li>
<li><a href="../333596/index.html">I am the cause of the emergence of the Hungarian notation in Android</a></li>
<li><a href="../333598/index.html">Cold calls for web studio. Lead for 159 rubles a reality or fantasy?</a></li>
<li><a href="../333600/index.html">Competitive Intelligence at PHDays: Spying on the Internet of Things</a></li>
<li><a href="../333602/index.html">Time of miracles, or Brakes for the end of the world</a></li>
<li><a href="../333604/index.html">What's new in ECMAScript 2017 (ES8)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>