<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Beautiful Chromium and gnarled memset</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We bring to your attention a series of articles devoted to recommendations for writing high-quality code using the example of errors found in the Chro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Beautiful Chromium and gnarled memset</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/756/67a/79d/75667a79d306e3d8ed926c30041f43d4.png" alt="malloc" align="left">  We bring to your attention a series of articles devoted to recommendations for writing high-quality code using the example of errors found in the Chromium project.  This is the first part to be devoted to the memset function. <br><br>  Gentlemen, programmers, with the <i>memset</i> function, you need to do something in C ++ programs!  Rather, even immediately it is clear what to do - it must stop using.  At one time I wrote an article " <a href="https://www.viva64.com/ru/b/0360/">The most dangerous function in the world of C / C ++</a> ."  I think it is easy to guess that the article is about <i>memset</i> . <br><a name="habracut"></a><br>  However, I will not be unfounded, and again with examples I will demonstrate the danger of this function.  The code of the Chromium project and the libraries used in it is of very high quality.  Google developers pay a lot of attention to tests and the use of various tools for detecting defects.  For example, Google has developed <a href="https://github.com/google/sanitizers">tools</a> such as AddressSanitizer, ThreadSanitizer, and MemorySanitizer. <br><br>  As a result, there are very few errors related to the <i>memset</i> functions, but it‚Äôs sad that they do exist.  Very high quality project, but still they are! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's see what I noticed in the process of parsing the report issued by PVS-Studio.  As I wrote in the <a href="https://habrahabr.ru/company/pvs-studio/blog/347536/">introductory article</a> , I looked at the report rather briefly, so there may be other errors that I did not notice.  However, the defects found will be enough for us to discuss the <i>malloc</i> function. <br><br><h2>  Incorrect buffer size calculated </h2><br>  The first type of error is associated with an incorrect calculation of the buffer size.  Or, in other words, the problem is that there is confusion between the size of the array in bytes and the number of elements in the array.  Such errors can be classified as <a href="https://cwe.mitre.org/data/definitions/682.html">CWE-682</a> : Incorrect Calculation. <br><br>  The first error example is taken directly from the Chromium project code.  Note that the <i>text</i> and <i>unmodified_text arrays</i> consist of Unicode characters. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(WIN32) typedef wchar_t WebUChar; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> typedef unsigned short WebUChar; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> static const size_t kTextLengthCap = 4; class WebKeyboardEvent : public WebInputEvent { .... WebUChar text[kTextLengthCap]; WebUChar unmodified_text[kTextLengthCap]; .... };</span></span></code> </pre> <br>  As a result, only half of the elements in these arrays are filled with zeros: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">WebKeyboardEvent* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildCharEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> InputEventData&amp; event)</span></span></span><span class="hljs-function"> </span></span>{ WebKeyboardEvent* key_event = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebKeyboardEvent(....); .... <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(key_event-&gt;text, <span class="hljs-number"><span class="hljs-number">0</span></span>, text_length_cap); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(key_event-&gt;unmodified_text, <span class="hljs-number"><span class="hljs-number">0</span></span>, text_length_cap); .... }</code> </pre> <br>  PVS-Studio warnings: <br><br><ul><li>  <a href="https://www.viva64.com/ru/w/v512/">V512</a> CWE-682 A call of the 'memset' function will be the key_event-&gt; text '.  event_conversion.cc 435 </li><li>  V512 CWE-682 Alert for the 'memset' function will be the key_event-&gt; unmodified_text '.  event_conversion.cc 436 </li></ul><br>  The second error example is taken from the WebRTC library used in Chromium.  The error is similar to the previous one: it is not taken into account that the array elements are of type <i>int64_t</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VCMRttFilter</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { kMaxDriftJumpCount = <span class="hljs-number"><span class="hljs-number">5</span></span> }; .... <span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> _jumpBuf[kMaxDriftJumpCount]; <span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> _driftBuf[kMaxDriftJumpCount]; .... }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> VCMRttFilter::Reset() { _gotNonZeroUpdate = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _avgRtt = <span class="hljs-number"><span class="hljs-number">0</span></span>; _varRtt = <span class="hljs-number"><span class="hljs-number">0</span></span>; _maxRtt = <span class="hljs-number"><span class="hljs-number">0</span></span>; _filtFactCount = <span class="hljs-number"><span class="hljs-number">1</span></span>; _jumpCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; _driftCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(_jumpBuf, <span class="hljs-number"><span class="hljs-number">0</span></span>, kMaxDriftJumpCount); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(_driftBuf, <span class="hljs-number"><span class="hljs-number">0</span></span>, kMaxDriftJumpCount); }</code> </pre> <br>  Here, only the first element of the array and one byte in the second element are reset to zero. <br><br>  PVS-Studio warning: V512 CWE-682A call of the 'memset' function will make it. _JumpBuf.  rtt_filter.cc 52 <br><br>  <b>Recommendation</b> <br><br>  The way to avoid such errors is to not use more <i>memset</i> .  You can be very careful, but sooner or later errors will still leak into your project.  This is a good picture in the Chromium project.  In other projects - this is a very common problem ( <a href="https://www.viva64.com/ru/examples/v512/">proof</a> ). <br><br>  Yes, it is impossible to refuse <i>memset</i> in C code.  However, if we are talking about C ++, then let's forget about this function.  Do not use the <i>memset</i> function in C ++ code.  Do not use and point. <br><br>  What to replace the <i>memset</i> call? <br><br>  First, you can use the <a href="http://en.cppreference.com/w/cpp/algorithm/fill">std :: fill</a> function.  In this case, the array filling will look like this: <br><br><pre> <code class="cpp hljs">fill(begin(key_event-&gt;text), end(key_event-&gt;text), <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Secondly, it is often not necessary to use the call of special functions at all.  As a rule, the <i>memset</i> function is used to initialize local arrays and structures.  Classic: <br><br><pre> <code class="cpp hljs">HDHITTESTINFO hhti; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;hhti, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(hhti));</code> </pre> <br>  But you can write much easier and more reliable: <br><br><pre> <code class="cpp hljs">HDHITTESTINFO hhti = {};</code> </pre> <br>  If we are talking about the constructor: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> A[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: C() { <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(A, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(A)); } };</code> </pre> <br>  That can be written: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> A[<span class="hljs-number"><span class="hljs-number">100</span></span>] = {}; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: C() { } };</code> </pre> <br><h2>  Wrong expectations from memset </h2><br>  Sometimes they forget that the second argument sets the value of a single byte, which is used to fill the buffer.  It is confusing for the fact that the second argument of the <i>memset</i> function is of type <i>int</i> .  As a result, errors that can be classified as <a href="https://cwe.mitre.org/data/definitions/628.html">CWE-628</a> occur: Function Call with Incorrectly Specified Arguments. <br><br>  Consider an example of a similar error that I noticed in the V8 engine used in the Chromium project. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> i::V8::FatalProcessOutOfMemory( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* location, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_heap_oom) { .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> last_few_messages[Heap::kTraceRingBufferSize + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> js_stacktrace[Heap::kStacktraceBufferSize + <span class="hljs-number"><span class="hljs-number">1</span></span>]; i::HeapStats heap_stats; .... <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(last_few_messages, <span class="hljs-number"><span class="hljs-number">0x0BADC0DE</span></span>, Heap::kTraceRingBufferSize + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(js_stacktrace, <span class="hljs-number"><span class="hljs-number">0x0BADC0DE</span></span>, Heap::kStacktraceBufferSize + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;heap_stats, <span class="hljs-number"><span class="hljs-number">0xBADC0DE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(heap_stats)); .... }</code> </pre> <br>  PVS-Studio warnings: <br><br><ul><li>  <a href="https://www.viva64.com/ru/w/v575/">V575</a> CWE-628 The 'memset' function processes value '195936478'.  Inspect the second argument.  api.cc 327 </li><li>  V575 CWE-628 The 'memset' function processes value '195936478'.  Inspect the second argument.  api.cc 328 </li><li>  V575 CWE-628 The 'memset' function processes value '195936478'.  Inspect the second argument.  api.cc 329 </li></ul><br>  The programmer decided to fill the memory blocks with the value <i>0x0BADC0DE</i> so that when debugging it was easier to understand what was happening.  However, the memory areas will be filled with a byte with the value <i>0xDE</i> . <br><br>  What the programmer does in code is a low-level operation, and here it is more difficult to manage without <i>memset</i> than in the situations described earlier.  The size of the buffers is not a multiple of 4 bytes, so it‚Äôs impossible to use <i>std :: fill</i> as before.  You have to write and use your own function. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fill_0x0BADC0DE</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> badcode[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-number"><span class="hljs-number">0xDE</span></span>, <span class="hljs-number"><span class="hljs-number">0xC0</span></span>, <span class="hljs-number"><span class="hljs-number">0xAD</span></span>, <span class="hljs-number"><span class="hljs-number">0x0B</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span>; generate_n(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *&gt;(buf), size, [&amp;] { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">4</span></span>) n = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> badcode[n++]; }); }</code> </pre> <br>  <b>Recommendation</b> <br><br>  There is no special recommendation here.  But we were again convinced that the <i>memset</i> function is not really needed here, since it does not solve the task set for the programmer. <br><br><h2>  Error overwriting private data </h2><br>  The <i>memset</i> function is used to wipe private data after it is no longer needed.  It is not right.  If the buffer with private data is not used after the function call, the compiler has the right to remove the call to this function.  This defect is classified as <a href="https://cwe.mitre.org/data/definitions/14.html">CWE-14</a> : Compiler Removal of Code to Clear Buffers. <br><br>  I already foresee the objections that the compiler cannot be removed from the <i>memset</i> call.  Can.  And he does it for the purpose of optimization.  To understand the topic, I suggest that you carefully study the following article " <a href="https://www.viva64.com/ru/b/0388/">Safely clearing private data</a> ." <br><br>  Let's see how such errors look in practice.  We start with the WebRTC library used by Chromium. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AsyncSocksProxySocket::SendAuth() { .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * sensitive = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[len]; pass_.CopyTo(sensitive, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); request.WriteString(sensitive); <span class="hljs-comment"><span class="hljs-comment">// Password memset(sensitive, 0, len); delete [] sensitive; DirectSend(request.Data(), request.Length()); state_ = SS_AUTH; }</span></span></code> </pre> <br>  PVS-Studio <a href="https://www.viva64.com/ru/w/v597/">warning</a> : <a href="https://www.viva64.com/ru/w/v597/">V597</a> CWE-14 The compiler could delete the memset function call, which is used to flush the 'sensitive' object.  The RtlSecureZeroMemory () function should be used to erase the private data.  socketadapters.cc 677 <br><br>  The <i>memset</i> function with a probability close to 100% will be deleted by the compiler in the Release version. <br><br>  Ayayay!  The password will remain hanging somewhere in the memory and, theoretically, it may be sent somewhere.  I seriously, it really <a href="https://www.viva64.com/ru/k/0041/">happens</a> . <br><br>  In the same library I met 3 more similar errors.  I will not describe them, since they are of the same type.  I will give only the corresponding messages of the analyzer: <br><br><ul><li>  V597 CWE-14 The compiler could delete the memset function call, which is used to flush the sensitive object.  The RtlSecureZeroMemory () function should be used to erase the private data.  httpcommon.cc 721 </li><li>  V597 CWE-14 The compiler could delete the memset function call, which is used to flush the sensitive object.  The RtlSecureZeroMemory () function should be used to erase the private data.  httpcommon.cc 766 </li><li>  V597 CWE-14 The compiler could delete the memset function call, which is used to flush the sensitive object.  The RtlSecureZeroMemory () function should be used to erase the private data.  httpcommon.cc 917 </li></ul><br>  <b>Recommendation</b> <br><br>  Never use the <i>memset</i> function to overwrite private data! <br><br>  You should use specialized memory cleaning functions that cannot be deleted by the compiler during code optimization. <br><br>  Note.  This applies not only to C ++ programmers, but C programmers too. <br><br>  In Visual Studio, for example, you can use <a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff562768%2528v%3Dvs.85%2529.aspx"><i>RtlSecureZeroMemory</i></a> .  Starting from C11, there is a <a href="http://en.cppreference.com/w/c/string/byte/memset"><i>memset_s</i></a> function.  If necessary, you can create your own safe function.  There are many examples on the Internet how to do it.  Here are some of the options. <br><br>  Option <a href="https://www.securecoding.cert.org/confluence/display/c/MSC06-C.%2BBeware%2Bof%2Bcompiler%2Boptimizations">N1</a> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">errno_t</span></span> memset_s(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *v, <span class="hljs-keyword"><span class="hljs-keyword">rsize_t</span></span> smax, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c, <span class="hljs-keyword"><span class="hljs-keyword">rsize_t</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EINVAL; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smax &gt; RSIZE_MAX) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EINVAL; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &gt; smax) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EINVAL; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = v; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (smax-- &amp;&amp; n--) { *p++ = c; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Option <a href="http://stackoverflow.com/a/13299459/965097">N2</a> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">secure_zero</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = s; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n--) *p++ = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  In the case of the Chromium project, it is probably rational to use the <i>OPENSSL_cleanse</i> function. <br><br><h2>  Conclusion </h2><br>  If you are writing a program in C ++ and you want to write a call to the <i>memset</i> function, then stop.  Most likely, you will do well without this dangerous function. <br><br><div style="text-align:center;"> <a href="https://www.viva64.com/en/b/0553/"><img src="https://habrastorage.org/files/8d2/41b/5bf/8d241b5bf34747169141ed7c1997143b.png"></a> </div><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Andrey Karpov.  <a href="https://www.viva64.com/en/b/0553/">Nice Chromium and clumsy memset</a> . </div><p>Source: <a href="https://habr.com/ru/post/347594/">https://habr.com/ru/post/347594/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347584/index.html">Disable triggers in ZABBIX on schedule</a></li>
<li><a href="../347586/index.html">How I made AI to identify fake news with an accuracy of 95% and almost went crazy</a></li>
<li><a href="../347588/index.html">Tough and flexible IT skills: everything is more and less serious than I would like to think</a></li>
<li><a href="../347590/index.html">Open science school hackathon DeepHack.Babel</a></li>
<li><a href="../347592/index.html">Telegram bot for complex quests</a></li>
<li><a href="../347596/index.html">The evolution of x86 architecture system calls</a></li>
<li><a href="../347598/index.html">Legal aspects of domain space</a></li>
<li><a href="../347600/index.html">Friday format: ‚Äúlanguage development‚Äù - research that combines IT and linguistics</a></li>
<li><a href="../347604/index.html">File system steganography</a></li>
<li><a href="../347606/index.html">Dynamic email :: practical use</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>