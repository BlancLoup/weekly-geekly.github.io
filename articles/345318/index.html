<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>AI teaches the language: why do you need a hackathon on machine translation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On December 18, a qualifying round for participation in the hackathon DeepHack.Babel from the Laboratory of Neural Systems and Deep Learning of MIPT s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>AI teaches the language: why do you need a hackathon on machine translation</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/xd/mw/4q/xdmw4qrefn8op8adkzcstljsm1g.png" alt="image"><br><br>  On December 18, a qualifying round for participation in the hackathon <a href="http://babel.tilda.ws/">DeepHack.Babel</a> from the Laboratory of Neural Systems and Deep Learning of MIPT started.  The focus will be on neural network machine translation, which is gaining popularity in the research community and is already being used in commercial products.  Moreover, it will be necessary to train a machine translation system, in contrast to common practice, on non-parallel data ‚Äî that is, in terms of machine learning, without the involvement of a teacher.  If you are still thinking about registration, tell us why. <br><a name="habracut"></a><br><h4>  What was before </h4><br>  Until recently (before neural networks became popular), machine translation systems were essentially tables of translation options: for each word or phrase in the source language, a number of possible translations were made into the target language.  These translations were distinguished from a large number of parallel texts (texts in two languages ‚Äã‚Äãthat are exact translations of each other) by analyzing the frequency of the joint occurrence of words and expressions.  To translate a string, you had to combine translations for individual words and phrases into sentences and choose the most plausible option: <br><br><img src="https://habrastorage.org/webt/yh/cy/cu/yhcycuei5s1qorh-6pcblsd66ga.png" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Options for the translation of individual words and phrases of the sentence ‚Äúer geht ja nicht nach hause‚Äù (‚Äúhe does not go home‚Äù) into English.  The quality of variants is determined by the weighted sum of the values ‚Äã‚Äãof the attributes, such as, for example, the probabilities p ( <i>e</i> | <i>f</i> ) and p ( <i>f</i> | <i>e</i> ), where <i>e</i> and <i>f</i> are the source and target phrases.  In addition to suitable translations, you must also select the order of phrases.  The illustration is taken from <a href="http://www.statmt.org/book/slides/06-decoding.pdf">the</a> Philipp Koehn <a href="http://www.statmt.org/book/slides/06-decoding.pdf">presentation</a> . <br><br>  Here the second component of the machine translation system, the probabilistic model of language, came into play.  Its classic version - <a href="https://web.stanford.edu/class/cs124/lec/languagemodeling.pdf">a language model on <i>n-</i> grams</a> - as well as a translation table, is based on the joint occurrence of words, but this time it is about the probability of meeting a word after a certain prefix ( <i>n</i> previous words).  The more such a probability for each of the words of the generated sentence (that is, the less we ‚Äúsurprise‚Äù the language model with a choice of words), the more natural it sounds and the more likely it is the correct translation.  Such a technique, despite its seemingly limited, allowed achieving a very high quality of translation - not least because the probabilistic model of the language is trained only in a monolingual (and not in a parallel) package, so it can be taught on a very large amount of data and she will be well informed about how you can talk, and how not. <br><br><h4>  What has changed with the advent of neural networks </h4><br>  Neural networks have changed the approach to machine translation.  Now translation is made by ‚Äúcoding‚Äù the entire sentence into a vector representation (containing the general meaning of this sentence in a form independent of the language) and then ‚Äúdecoding‚Äù this representation into words in the target language.  These transformations are often performed using recurrent neural networks, which are designed specifically for processing sequences of objects (in our case, sequences of words). <br><br><img src="https://habrastorage.org/webt/gb/-d/2n/gb-d2nmmbjhmjlizrajgg4vjxlo.png" alt="image"><br><br>  The scheme of the three-layer model encoder-decoder.  The encoder (red part) generates a sentence representation: at each step, combines a new input word with a representation for the words read earlier.  The blue part is the presentation of the entire sentence.  The decoder (green part) outputs the word in the target language based on the representation of the original sentence and the previous generated word.  The illustration is taken from the <a href="https://sites.google.com/site/acl16nmt/home">tutorial on neural network machine translation</a> for ACL-2016. <br><br>  At each step, such a neural network combines a new input word (more precisely, its vector representation) with information about the previous words.  The parameters of the neural network determine how much you need to ‚Äúforget‚Äù, and how much you need to ‚Äúremember‚Äù at each step, so the presentation of the entire sentence contains the most important information from it.  The architecture of encoder-decoder has already become classical, you can read its description, for example, in [1]. <br><br>  In fact, the standard version of this system does not work exactly as expected, therefore additional tricks are needed for good translation quality.  For example, a recurrent network with normal cells is subject to exploding or decaying gradients (i.e., the gradients converge to zero or very large values ‚Äã‚Äãand do not change anymore, which makes network training impossible) ‚Äîthe neurons of a different structure ‚Äî LSTM [2] and GRU [ 3], at each step deciding what information you need to "forget" and which one to pass on.  When reading long sentences, the system forgets how they started - in this case, the use of bidirectional networks helps to read the sentence from the beginning and the end at the same time, as was done in [4].  In addition, it turned out to be useful, by analogy with statistical systems, to clearly make correspondences between individual words in the original sentence and its translation ‚Äî the attention mechanism already used in other tasks was used for this purpose (application of attention to machine translation is described, for example, in [4] and [5], a short and simple description of attention - in <a href="http://www.wildml.com/2016/01/attention-and-memory-in-deep-learning-and-nlp/">this post</a> ).  It consists in the fact that when decoding (generating a translation) the system receives information about which word of the original sentence it should translate at this step. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sd/dw/qn/sddwqnr-dujerkcmsrdiyhhhluy.png" alt="image"></div><br>  The attention mechanism in the encoder-decoder architecture.  The current state of the decoder (B) is multiplied with each of the encoder states (A) - this is how we determine which of the input words is most relevant for the decoder at the moment (instead of multiplication, another operation can be used to determine the similarity).  The result of this multiplication is then converted to a probability distribution by the softmax function ‚Äî it returns the weight of each input word to the decoder.  Combinations of the weighted states of the encoder are fed to the decoder.  The illustration is taken from the <a href="https://distill.pub/2016/augmented-rnns/">post by</a> Chris Olah. <br><br>  Using all these additional techniques, machine translation on neural networks is confidently won by statistical systems: for example, at the last <a href="http://statmt.org/wmt17/index.html">competition of machine translation systems,</a> neural network models were the first in almost all pairs of languages.  However, in the past statistical models there is a feature that has not yet been able to be transferred to neural networks - this is the ability to use a large amount of non-parallel data (that is, those for which there is no translation into another language). <br><br><h4>  Why use non-parallel data </h4><br>  One may ask, why use non-parallel data if neural network systems are good enough without them?  The fact is that good quality requires a very large amount of data, which is not always available.  It is known that neural networks are demanding on the amount of training data.  It is easy to check that any classical method (for example, Support Vector Machines) will bypass a neural network on a very small data set.  In machine translation for some of the most sought-after pairs of languages ‚Äã‚Äã(English ‚áî main European languages, English Chinese, English ‚áî Russian) there is enough data, and neural network architectures for such pairs of languages ‚Äã‚Äãshow very good results.  But where parallel data is less than a few million sentences, neural networks are useless.  There are very few such richly parallel pairs of languages, but monolingual texts are available for very many languages, and in huge numbers: news, blogs, social networks, government works - new content is constantly generated.  All these texts could be used to improve the quality of neural network machine translation just as they helped to improve statistical systems - but, unfortunately, such techniques have not yet been developed. <br><br>  More precisely, there are several examples of teaching a neural network translation system on monolingual texts: in [6] the combination of the encoder-decoder architecture with a probabilistic language model is described, in [7] the missing translation for a monolingual corpus is generated by the model itself.  All these methods improve the quality of translation, but the use of monolingual corpuses in neural network machine translation systems has not yet become common practice: it is not yet clear how to use non-parallel texts when learning, it is not clear which approach is better, or if there are differences in its use for different pairs of languages, different architectures, etc. And these are exactly the questions that we will try to solve on our DeepHack.Babel hackathon. <br><br><h4>  Non-parallel data and DeepHack.Babel </h4><br>  We will try to conduct controlled experiments: the participants will be given a very small set of parallel data, they will be asked to train a neural network machine translator on it, and then improve its quality using monolingual data.  All participants will be on an equal footing: the same data, the same restrictions on the size and training time of the models - so we can find out which of the methods implemented by the participants work better and come closer to understanding how to improve the quality of translation for non-common pairs of languages.  We will conduct experiments on several pairs of languages ‚Äã‚Äãof different degrees of complexity in order to check how versatile different solutions are. <br><br>  In addition, we will come close to an even more ambitious task that seemed impracticable by means of statistical translation: translation without parallel data.  The technology of teaching translation in parallel texts is already known and perfected, although many issues related to it are not yet resolved.  Comparable corpuses (pairs of texts with a common theme and similar content) are also actively used in machine translation [8] - this makes it possible to use such resources as Wikipedia (the corresponding articles in different languages ‚Äã‚Äãdo not match there literally, but describe the same objects) .  But what if there is no information at all about whether the texts match each other or not?  For example, when analyzing two corpuses of news for a certain year in different languages, we can be sure that the same events were discussed - this means that for most of the words of one corpus there will be a translation in the other corpus - but establish correspondences between sentences or at least between texts without additional information can not. <br><br>  Is it possible to use such data?  Although this seems fiction, there are already several examples in the scientific literature that this is possible - for example, a recent publication [9] describes such a system built on denoising autoencoders.  Participants of the hackathon will be able to reproduce these methods and try to bypass systems trained in parallel texts. <br><br><img src="https://habrastorage.org/webt/ov/0s/sb/ov0ssbusxtoccrl0xgvoo_qwv84.png" alt="image"><br><br>  The principle of operation of the machine translation system without parallel data.  Autoencoder (left): the model learns to restore the sentence from the distorted version.  x is a sentence, C (x) is its distorted version, xÃÇ is a reconstruction.  Translator (right): the model is learning to translate the sentence into another language.  The input to it is a distorted translation generated by the version of the model from the previous iteration.  The first version of the model is a lexicon (dictionary), also trained without the use of parallel data.  The combination of the two models achieves translation quality comparable to systems trained on parallel data.  The illustration is taken from the article [9]. <br><br><h4>  How to participate </h4><br>  Applications for the qualifying round of the hackathon will be accepted until January 8.  The task of the qualifying round is to train the machine translation system from English to German.  There are no restrictions on data and methods yet: participants can use any buildings and pre-trained models and choose the system architecture to their own taste.  However, it should be remembered that the system will be tested on a set of proposals on IT topics - this involves the use of data from relevant sources.  And, although there are no restrictions on the architecture, it is assumed that when performing a qualifying task, participants will become familiar with neural network translation models in order to better cope with the main task of the hackathon. <br><br>  50 people whose systems will show the best translation quality (which will be measured by the BLEU metric [10]) will be able to participate in the hackathon.  Those who do not pass the selection should not be upset - they can visit the hackathon as listeners: every day there will be lectures by specialists in machine translation, machine learning and word processing, open to everyone. <br><br><div class="spoiler">  <b class="spoiler_title">Bibliography</b> <div class="spoiler_text"><ol><li>  <a href="">Sequence to Sequence Learning with Neural Networks</a> .  I.Sutskever, O.Vinyals, QVLe. </li><li>  <a href="http://arxiv.org/abs/1503.04069">LSTM: A Search Space Odyssey</a> .  K.Greff, RKSrivastava, J.Koutn√≠k, BRSteunebrink, J.Schmidhuber. </li><li>  <a href="http://arxiv.org/abs/1406.1078v3">Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation</a> .  K.Cho, BvMerrienboer, C.Gulcehre, D.Bahdanau, F.Bougares, H.Schwenk, Y.Bengio. </li><li>  <a href="">Neural Machine Translation by Jointly Learning to Align and Translate</a> .  D.Bahdanau, K.Cho, Y.Bengio. </li><li>  <a href="http://nlp.stanford.edu/~lmthang/data/papers/emnlp15_attn.pdf">Effective Approaches to Attention-based Neural Machine Translation</a> .  M.-T.Luong, H.Pham, CDManning. </li><li>  <a href="http://arxiv.org/abs/1503.03535">On Using Monolingual Corpora in Neural Machine Translation</a> .  C.Gulcehre, O.Firat, K.Xu, K.Cho, L.Barrault, H.-C.Lin, F.Bougares, H.Schwenk, Y.Bengio. </li><li>  <a href="http://arxiv.org/abs/1511.06709">Improving Neural Machine Translation Models with Monolingual Data</a> .  R.Sennrich, B.Haddow, A..Birch. </li><li>  <a href="http://aclweb.org/anthology/C16-1300.pdf">Earth Mobility Distance Regularization</a> .  M.Zhang, Y.Liu, H.Luan, Y.Liu, M.Sun. </li><li>  <a href="http://arxiv.org/abs/1711.00043">Unsupervised Machine Translation Using Monolingual Corpora Only</a> .  G.Lample, L.Denoyer, M.Ranzato. </li><li>  <a href="https://dl.acm.org/citation.cfm%3Fid%3D1073135">BLEU: a method for automatic evaluation of machine translation</a> .  K.Papineni, S.Roukos, T.Ward, W.-J.Zhu. </li></ol></div></div></div><p>Source: <a href="https://habr.com/ru/post/345318/">https://habr.com/ru/post/345318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345306/index.html">Working with the in-memory database using Intel Optane</a></li>
<li><a href="../345310/index.html">Predict outflow using neural network</a></li>
<li><a href="../345312/index.html">New Year's post good</a></li>
<li><a href="../345314/index.html">I want to program, let them teach me! Avito educational projects</a></li>
<li><a href="../345316/index.html">Pay attention to people, not technology.</a></li>
<li><a href="../345320/index.html">Visual programming in DRAGON</a></li>
<li><a href="../345322/index.html">Karmic incompatibility and other vicissitudes of service engineer</a></li>
<li><a href="../345324/index.html">Pygest # 20. Releases, articles, interesting projects, packages and libraries from the world of Python [December 6, 2017 - December 23, 2017]</a></li>
<li><a href="../345326/index.html">Is there life without standards in javascript?</a></li>
<li><a href="../345328/index.html">Simulation of the simplest statements</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>