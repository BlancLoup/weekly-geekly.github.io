<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Let the Holy War begin: Java vs C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On the eve of Joker 2016 we dashed a post about Java Performance , which caused a storm of emotions among readers. In order to throw fuel into the fan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Let the Holy War begin: Java vs C ++</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/06d/55a/f28/06d55af2819b4959a8d520b5648c0e3c.jpg"><br><br>  On the eve of Joker 2016 we dashed a <a href="https://habrahabr.ru/company/jugru/blog/307178/"><b>post about Java Performance</b></a> , which caused a storm of emotions among readers.  In order to throw fuel into the fan and still try to come to some kind of a single solution, we decided to attract experts from different ‚Äúcamps‚Äù: <br><br><ul><li>  <strong>Dmitry Nesteruk</strong> .  Expert on .NET, C ++ and development tools, author of courses on technology and mathematics, <a href="https://geektimes.ru/company/itinvest/blog/270474/">quantum</a> . </li><li>  <strong>Andrey Pangin</strong> .  Lead programmer at Odnoklassniki, specializing in high-load backends.  He knows the JVM like the back of his hand, as he had previously developed the HotSpot virtual machine in Sun Microsystems and Oracle for several years.  Likes assembly language and low-level system programming. </li><li>  <strong>Vladimir Sitnikov</strong> .  For ten years, NetCracker OSS has been working on the performance and scalability of the software used by telecom operators to automate network management processes and network equipment.  He is interested in Java and Oracle Database performance issues. </li><li>  <strong>Oleg Krasnov</strong> .  SEMrush CTO and ANSI C adept. </li></ul><br><a name="habracut"></a><br><h2>  Andrey Pangin </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/7b1/71e/971/7b171e9711561e59bfd3d0bc4c804710.jpg" align="left" width="250">  <b>- Java and C ++, what do you think is the most popular language now?</b>  <b>Both of them are already adults, but who is more mature and honed?</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      - First of all, I do not consider that there is any competition between these languages.  Each of them has its own niche, and they perfectly coexist together.  Traditionally, the popularity of Java is somewhat higher.  The Java platform attracts with its powerful tools for debugging and maintaining applications.  However, the significance of C ++ is difficult to overestimate.  Despite the fact that it is a language with a great history, it continues to grow rapidly: only developers managed to get used to C ++ 11, as C ++ 14 came out with many new interesting features. <br><cut><br>  <b>- What can languages ‚Äã‚Äãgive in the world of high-loaded servers?</b>  <b>Does it make sense to develop individual system modules in different languages, honing them for specific tasks?</b>  <b>If they could (they wanted to, or simply would have had the opportunity), would they use C ++ for solving problems, or would they do everything only in one language?</b> <br><br>  - Everyone understands something of their own as high-loaded servers.  For some, there are thousands of network requests per second, for others, parallel computing over large amounts of data.  Different tools are better suited for different tasks.  We (Odnoklassniki) have modules written in C ++, in particular, related to image and video processing - they need SIMD computing and the most efficient use of the processor.  However, for most of our systems, Java performance is enough.  Moreover, the code fragments, previously developed in C and called via JNI, were gradually rewritten in Java, as a result, we even won in performance because we got rid of unnecessary copying and JNI overhead. <br><br>  <b>- Using Unsafe in Java, justified or not?</b>  <b>Why not use C ++?</b> <br><br>  - I have a <a href="http://2015.jokerconf.com/talks/pangin/">whole report</a> on why we use Unsafe.  There are a number of scenarios where one cannot do without Unsafe, in particular, for working with off-heap and interacting with native code. <br>  If we wanted to write an application entirely in C ++, we would have to re-implement all our common frameworks and protocols: for collecting statistics, for monitoring, for communication between servers, etc. And so - we have only a small part of the code with Unsafe which is responsible for low-level operations, but we conduct the rest of the development in familiar Java, adhering to the best patterns of writing simple and understandable code.  It is much more convenient when the entire ecosystem is developed on a single platform. <br><br>  <b>- What are the most frequent performance problems in the development of Enterprise-systems and possible solutions?</b> <br><br>  - Rarely, when we run into the performance of the Java platform itself.  Usually, problems can be solved either by replacing the algorithm or by scaling, that is, building up iron.  The most common bottleneck is network bandwidth or disk I / O.  But if we talk about JVM, then the main or even the only performance problem is sometimes delivered to us by the garbage collector, because the pauses longer than 500ms are often critical in our cases.  Therefore, we try not to make the Heap too large: a maximum of 50 gigabytes, but more often even less: from 4 to 8 gigabytes per application.  We try to <a href="https://github.com/odnoklassniki/one-nio">move</a> large volumes outside the hip: we even made a framework for creating <a href="https://github.com/odnoklassniki/one-nio">large high-loaded caches</a> .  An additional advantage of such a cache in comparison with hip is the persistence, that is, the ability to restart the application without losing data.  This is achieved through the use of shared memory: immediately after starting the application displays the shared memory object in the address space of the process, and the cache with all the data becomes instantly accessible. <br><br>  <b>- What can you say about the imminent release of JDK 9 and its main feature - modularity?</b> <br><br>  - There was a lot of talk about modularity, the release date was even transferred several times to finally finish this modularity.  But at the same time among my friends I don‚Äôt know a single Java developer who would really need this feature.  I think it would be better if we released JDK 9 earlier - the developers would be only grateful.  For example, modularity hurts us rather than helps: one of the side effects is that Unsafe will now be hidden deep inside, and is unavailable without special keys.  But in JDK 9 much more pleasant innovations are expected, for the sake of which the new version should at least try: improvements in G1, Compact Strings, VarHandles, etc. <br><br>  <b>- If you look at it very roughly, the difference between C ++ and Java is in the runtime layer, which, among other things, performs all sorts of optimizations.</b>  <b>Which is preferable: use the architectural features of the machine manually (C ++), or is it better to rely on dynamic JVM optimizations?</b>  <b>Speaking about specific things, is it better to do automatic garbage collection or manual control?</b> <br><br>  - Adaptive compilation and automatic memory management are just the strengths of Java.  In this, the virtual machine has succeeded and surpassed static compilers.  But the main thing is not even that.  We choose JVM for the security guarantees that it gives us.  In the first place - protection against fatal errors due to incorrect memory handling.  It is an order of magnitude more difficult to look for problems related to pointers or going beyond the array boundaries in unmanaged code.  And the cost of correcting such errors more than covers the benefit of the small speed advantage, which gives direct memory access.  As mentioned above, we sometimes use Unsafe, and in these cases we automatically expose ourselves to the same risks as in C ++.  Yes, we sometimes have to understand the crash dumps of the JVM, and this activity is not pleasant.  That is why we still prefer pure Java, and use unmanaged code only in cases of extreme necessity. <br><br>  I will also have a report on Joker on the topic: ‚ÄúMyths and Facts about Java Performance‚Äù. <br><br><h2>  Dmitry Nesteruk </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/8d8/035/904/8d8035904e43012c22101a54b7711139.png" align="left" width="250">  <b>- Java and C ++, in your opinion, what is the most popular language now?</b>  <b>Both of them are already adults, but who is more mature and honed?</b> <br><br>  - If we talk about demand, then everything is obvious: Java, of course, is more in demand than other languages.  C ++ occupies its own niche in the three main disciplines (game dev, finance and embedded), well, plus is the main language for HPC and scientific computing.  Therefore, if you stick to selfish interests, then Java is certainly safer as a skill, unless you are going purposefully to one of these areas. <br><br>  As for maturity, everything is difficult and you must first break into language features, compiler abilities and features of standard libraries. <br><br>  Let's start with the first - with languages.  And there and there are problems.  With Java, the problem is that the language does not develop as rapidly as its closest competitor, as a result of which features come very slowly and not in the way you want.  It is noteworthy that C # is younger, but lambdas first appeared in it, LINQ technology (Language Integrated Query is such convenient mechanisms for traversing and sampling data sets), and the original solutions based on C # (that is, supporting properties and delegates) were also performed correctly and successfully. <br><br>  As for C ++, the main problem here is 100% C ++ compatibility with the C language, which automatically means a huge baggage of useless language features.  On the other hand, the stagnation of C ++ in the 2000s also did not add to the popularity of the language, since  developers need to be constantly fed with new features.  Now the situation is better - in C ++ there are lambdas (by the way, more expressive than in C # / Java), type inference for variables and even values ‚Äã‚Äãreturned from a function, in general, the language somehow evolves. <br><br>  This is what concerns languages.  Now about compilers.  Here, first, the comparison is not entirely correct, because  JVM is a JIT, that is, the idea that you can take bytecode and turn it into the perfect representation for the current processor, with all the optimizations that apply.  That sounds good in theory - I don‚Äôt know how it is in Java, but in the .NET world this approach, compared to the C ++ compiler optimizations, of course, it does almost nothing.  If you do the math or, I say this: if you, say, buy a mathematical .NET library on the web, then it will be just a wrapper around C ++. <br><br>  Yes, and regarding the C ++ compiler: I use Intel C ++ for computational tasks, that is, the compiler that is supplied by the processor manufacturer itself.  There are a huge number of disadvantages in this: there are fewer language features than in MSVC, a bunch of awkward errors for which you have to contact support, but we eat this cactus for one simple reason: optimization.  Intel'ovsky compiler generates the most effective code.  Of course, not a single code: here we have all the power of Intel Parallel Studio is used, this is also the Threading Building Blocks for parallelization (by the way, an analogue of Microsoft Parallel Patterns Library), and Intel Math Kernel Library, which even if you don‚Äôt use directly, You use it indirectly through MATLAB and others.  Here we need to clarify that a library like MKL is already optimized by guys from Intel: here both vectorization and parallelization, and even cluster parallelization via MPI (for example for FFT) is made out of the box - that is, take it and use it.  And of course it is worth mentioning the means of profiling, which are also part of the IPS.  This is a very powerful toolkit, in essence, it sets itself the goal of helping the developer optimize the code in terms of performance, well, correctness too - there is also memory profiling, so there are easy leaks and everything like that. <br><br>  And finally, about ‚Äúlib‚Äù - everything is simple, Java wins, in C ++ everything is bad.  I will not even talk about the fact that the C ++ Standard Library interface itself is a little bit insane, but the problem seems to me not only that everything is "legacy", but that there are just very few features!  We have just appeared such things as file system support and some kind of thread support.  And then, here I have a string, I want to break it into substrings by a space - this is not in the standard library, that is, I have to take a third-party library (well, there is such a thing as Boost, there are many useful things).  But the development really slows down.  Many companies, such as Electronic Arts, they write their implementations of STL because they are not satisfied with the standard.  Well, on the sidelines, many admit that we essentially need a new, from scratch, library, some STL2, although it would be more correct, of course, to call it Standard Library 2 or something like that. <br><br>  There are still a lot of problems, for example, the absence of the main package manager, and also, even if it were, how is the library fumbling?  In Java or .NET, you can simply distribute binaries, while in C ++ you need to fumble around.  Nobody has really solved this problem yet, and this also slows down the development.  sometimes you take someone else's liba, and then you spend half an hour just to make it work for you. <br><br>  <b>- How do languages ‚Äã‚Äãgenerally feel in Enterprise, for example, in the banking sector?</b>  <b>For example, in the HFT (High-Frequency-Trading) world there are heavy loads and high demands on reliability.</b>  <b>Also, the financial industry is quite conservative.</b>  <b>How does this affect the choice of a particular technology?</b> <br><br>  - Enterprise is one such large comb, under which any corporate development is currently underway.  Globally - this, of course, C # and Java, and other languages ‚Äã‚Äãsomewhere on the periphery.  As for banking, everything is somewhat more interesting, and it is especially interesting that C ++ appears in some places, well, there are some offices like Bloomberg, which are entirely in C ++, but it seems to me an anomaly.  In general, if you now receive MFE, that is, Master of Financial Engineering, then there is mainly C ++ used, although now popular languages ‚Äã‚Äãsuch as Python and R, well, MATLAB also remains relevant. <br><br>  As for the HFT, this is also a controversial topic, but yes, it basically tends to C ++, and even to C, the use of any FPGA, where the system C is present, or people write HDL languages.  When speed, performance is important, then the native code is somehow closer, although the argument that de ‚ÄúJava slows down‚Äù seems to me irrelevant.  It's just that manual memory management is sometimes necessary for people, everyone is afraid of a big malicious GC, which will come and stop all flows at the very moment when you need to make some kind of deal. <br><br>  In quantitative terms, the ‚Äúpluses‚Äù remained rather from some conservative considerations, because the financial system, in contrast to the usual software development, he considers programming as a skill akin to knowing English, and not as something systemic.  Accordingly, people simply learn C ++ and do not suffer, although now for analysis Python and R are somehow even more popular.  But the "advantages" in investment banks car. <br><br>  <b>- For software development for embedded devices, which language is better suited, in your opinion?</b>  <b>How do these languages ‚Äã‚Äãallow us to write portable code?</b> <br><br>  - In general, the theme embedded is too wide.  For many, embedded are any Rasperry Pi or Arduino, for me it is FPGA, for someone else something.  But if to generalize, then embedded it is finite basically C or C ++, if we talk about the application layer.  Of course, for FPGA development, I use either VHDL directly or write MATLAB, which after conversion VHDL throws out - the essence remains the same. <br><br>  Specifically, about FPGA, since this is the only topic in which I understand at least something, I can say that languages, and the development approach itself is a good illustration of how all technology can get stuck much worse than C ++ somewhere in older models, languages ‚Äã‚Äãand in general.  It is very difficult to work with this technology and you essentially start using any kind of generator like MATLAB or write something of your own.  That is, for people who work purely at the system level, shifting the bits to manual is normal, but I, as a person who wants, for example, to model a set of business rules in hardware, do not like this approach at all, and the language not enough to explain at a high level what I need. <br><br>  And I‚Äôm just not qualified to talk about Java and embedded. <br><br>  <b>- If you look at it very roughly, the difference between C ++ and Java is in the runtime layer, which, among other things, performs all sorts of optimizations.</b>  <b>Which is preferable: use the architectural features of the machine manually (C ++), or is it better to rely on dynamic JVM optimizations?</b> <br><br>  - Well, I, it seems, has already raised this question, but everything is an amateur.  Here to take me, I practically use all levels of parallelization, I mean SIMD, OpenMP, MPI and not to mention any specifics like hardware accelerators.  There are some SIMD optimizations in Java, and now .NET is slowly pulling up, but in fact C ++ still rules in terms of automatic optimizations, and let's not forget that in C ++ you can manually assemble assembly blocks.  I understand that now nobody knows the assembler, and many have never seen C ++, but the point is that when it comes to pure computation, that is, mathematics, and I want to quickly, then why not? <br><br>  I don‚Äôt really believe in dynamic optimizations. That's why: if you have a simple loop, let's say the array is summed up - yes, that can be recognized, parallelized there.  The problem is, if you, for example, dragged some kind of dependency from the outside into a cycle, what then?  In OpenMP, we have the appropriate markup, but the dynamic optimizer cannot solve such problems, never.  Therefore, someone, for example, will look at CUDA and say that this model is absolutely unreal, why should I rewrite all algorithms, and even learn something?  And as for me, it is inevitable, because  optimizers work very well on understandable, simple things, do all sorts of inlinings, but all that performance-critical can be written with your hands, write in the native code and not suffer. <br><br>  <b>- How dynamic is the Java and C ++ ecosystem?</b>  <b>How often do updates, releases, standards come out?</b>  <b>How lively are languages ‚Äã‚Äã(how many language features appear)?</b> <br><br>  - Well, I think we can say that the ‚Äúpluses‚Äù are immortal, unlike Java as a language, where many new languages ‚Äã‚Äãhave appeared with interesting features - these are Scala and Kotlin, and others.  Another thing is that language and platform are different things.  Java as a language does not suit many people; in fact, therefore, new languages.  But as a platform - everything is fine there, apparently, again, there are advantages even in comparison with the closest competitor (for example, in terms of GC).  But as a language, there are plenty of grounds for complaints. <br><br>  About C ++, I must speak here, I guess.  Of course, after the community that way 13 years did nothing at all, new standards and new library features are, of course, good, fine, I would even say, compared with total apathy.  In C ++ 11, many, many real useful moves have occurred, I am now writing a completely different C ++ than before.  In C ++, 14 is still a bit better, but in C ++ 17, the whole world has again disappointed - that is, the features that have been waiting for everyone will not be there.  The main feature that everyone wanted and wants in general is modules.  Just now C ++ compiles very slowly, more precisely the primary compilation, since  The incrementality of it, judging by MSVC, is simply super, but building it for example from scratch is a pleasure below average.  Well, modules should solve this problem, but no one knows when. <br><br>  Again, in C ++ there is such a problem that the most basic things are not in the standard library.  And this newcomer, who needs to translate a string, say, to lower case or beat them by tokens, will simply lead to a stupor.  Of course, there are many third-party libraries, but the very usability of libraries is also a question.  Languages ‚Äã‚Äãthat have metadata - you see a function there and you know how to use it, even the documentation will appear as an extra.  And in C ++, you can have a template argument of the Func type, that is, a function, and you can not understand the function signature, even if you climb into the sorts.  And it is not clear what to do with this, actually. <br><br>  In general, if to summarize, I would say that both languages ‚Äã‚Äãare as if alive, and everything depends on what you actually need.  In general, you can write productively on and on that.  Regarding lib, here the pros lose, it‚Äôs clear to everyone, and surprisingly, because  the language seems to be older, much, and the libraries, well, they even if there is, are from the world C and are not particularly usable, or they simply do not exist and need to be searched somewhere outside, download, compile, and only then use. <br><br><h2>  Oleg Krasnov </h2><br><img src="https://habrastorage.org/files/a3a/913/ba1/a3a913ba1a3347e2a68c1dea95caaa10.jpg" align="left" width="250">  <b>- Why C?</b> <br><br>  - When I came to SEMrush, there were no significant developments in server logic in other languages.  At that time, I mostly programmed in C and decided to develop the product in this language.  I believed in my strength.  =) <br>  For me, C is a simple and convenient language.  With sufficient skill and knowledge of libraries, it is perfect for prototyping development at the level of a scripting language. <br>  In SEMrush, the distribution of server-side programming languages ‚Äã‚Äãis approximately the following: 1/3 is C and C ++, 1/3 is scripted, 1/3 is Java. <br><br>  <b>- Java and C, what do you think is the most popular language now?</b>  <b>Both of them are already adults, but who is more mature and honed?</b> <br><br>  - My experience suggests that the C language is to develop things that are related to productive tasks.  For example, this is work with sockets, data multiplexing, high-loaded multi-threaded applications, where you can and should maximally manage computer resources. <br>  SEMrush does not have an explicit division of programming languages ‚Äã‚Äãinto zones of their use.  If you need to start a new product, the choice of a particular language depends on the professionalism of the person who starts developing the architecture and programming.  And also on how communicative and able he is to convey to his colleagues the ideas he wants to translate. <br>  Quite frequent tasks for us are data collection and processing.  Among the reasons why, for example, we do not use Java in all products, is that we have no wild inheritance in terms of entities.  Due to the nature of our work, its depth in the vertical plane is less than in the horizontal one.  That is, a large amount of data will be transferred between independent entities rather than between parents and descendants. <br><br>  <b>- Does it make sense to develop individual modules of the system in different languages, sharpening them for specific tasks?</b> <br><br>  - I believe it has.  In this regard, we have everything very well.  The development is carried out by small groups of 5-6 people, each of whom works on their product, and the interaction between them is carried out through the API.  Both the user interface and services must interact ‚Äúwell‚Äù with each other.  This is done, for example, using data formats such as JSON and Binary-JSON.  So yes, you can use different languages ‚Äã‚Äãto write the whole system. <br><br>  We have our own database, written in C, and there were no major problems with its work.  When I was engaged in the development of the architecture of this base, there were no ready-made adequate tools that would fit.  This database works on ordinary files and, with this in mind, is quite reliable.  If we exclude from consideration all measures to ensure its uninterrupted operation (redundancy, clustering), then even a ‚Äúfallen off‚Äù disk (hardware malfunction or unforeseen technical reasons) will not cause much harm, no more than 8.5% of data will be lost.  That is, the probability that users will suffer, is further reduced at the level of business logic.  But in general, the system is built in such a way that data is not lost.  Everything is very reliable. <br>  We once carried out tests for maximum utilization of the performance of "iron" with 12 disks.  If RAID5 was used, then the read / write speed was about 2.5x the speed of one hard drive.  But our system uses 12 disks separately at the level of business logic, this allows us to achieve an 11-fold increase in speed due to the fact that each thread works with its own disk. <br><br>  <b>- How do languages ‚Äã‚Äãgenerally feel in Enterprise?</b> <br><br>  - We have large products.  For example, one of them bypasses the Internet and creates a database of site pages that link to each other.  The kernel is written in C, which allows you to dispose of "iron", almost 100%.  More than 150 servers are involved in this product, but this approach allows us to be sure that we do not overpay for the server park, and we, as you understand, are concerned with financial efficiency.  Separately, I note that thanks to the agile development process, we have time both to deliver new features to the user, and to hone the performance of each product. <br><br>  <b>- What are the most frequent performance problems in the development of Enterprise-systems and possible solutions?</b> <br><br>  - To be honest, I can‚Äôt even remember any particular problems.  If suddenly there is not enough power, then the use of the assembler, special libraries and the efforts of highly skilled programmers allows you to quickly solve the problem.  But in 99% of cases we have no problems with productive solutions. <br>  I have no prejudice about Java, but it is more demanding on resources.  Yes, with its help it is very convenient to solve problems with complex multi-level business logic, to build interconnected systems.  However, such tasks as networking, multi-threaded programming, or large binary data, in my opinion, are more suitable for C. In Java, this can also be done, but I would choose C. <br><br>  <b>- What do you think should be the "ideal" database?</b>  <b>Is it worth bothering with application performance if all the power of the system is leveled by transactions to the database and how can this be fixed?</b> <br><br>  - The ideal database is not universal.           -. ,        ,     ¬´¬ª  . <br><br> <b>‚Äî       ,     ,    ‚Äî Java  ++?</b> <br><br> ‚Äî   ‚Äî     ,      -.  -  ,   - ‚Äî .            .          . <br><br> <b>‚Äî    Java  C++?    , , ?    (    )?</b> <br><br> ‚Äî     99,      ,     .     ,   .    ++ ‚Äî ++14  ++17 (draft)     ,   ,       .  ,     .       .            . <br>     ++              ++.  It is irrational.  .    ++,          . <br><br><h2>   </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/c07/716/384/c07716384696150e94d875b6adb0313a.jpg" align="left" width="250"> <b>‚Äî        ?          ,     ?    (     ),    ++           ?</b> <br><br> ‚Äî         .   ‚Äî   .     10   ,  , 10  ,     .  ,     ,  ,    ,        .              .    ‚Äî   . ,  java         ,       ,   ..   C++     .  ,    java       ,        . <br><br> <b>‚Äî  Unsafe  Java,   ?      ++?</b> <br><br> ‚Äî  ,  Unsafe  Java  ()  ,         .    unsafe java    . ,  OpenJDK java.util.HashMap   Map.Entry ,     ,        .         ,    , ..          ,   .    ,    javac  JIT-      . <br><br>     C++,   -    entry .     ,      . ++     . <br><br>    java ?     Unsafe, off-heap    ?   ,   ,    ,       .   java       HashMap  . <br><br>   ¬´   ¬ª,     (Unsafe, VarHandlers, memory mapped files,  ..).      ,      JEP 169: Value Objects ‚Äî     ,       Java       . <br><br> <b>‚Äî         Enterprise-    ?</b> <br><br> ‚Äî         ,        . ,   SQL-.  Those.    .     ,      ,    . ¬´¬ª          .        ,          .     API          1000         ,      . <br><br> <b>‚Äî         JDK 9     ‚Äî ?     ,      Java?</b> <br><br> ‚Äî   Java        . ,        30   ,       . <br><br>   Java-         ?          ?  .class     JVM         .   JDK9,   ,    ,     ,       java-. Java-       ,    ,         . <br><br>      ‚Äì    java-.          JVM    ,        . <br><br> <b>‚Äî    ,    C++  Java ‚Äî   runtime, ,  ,   ?</b> <br><br> ‚Äî     Java ‚Äî          . , java-     Iterator. ,        ¬´¬ª  (invokeinterface).       ,          Iterator     . JIT- ,     ,         ¬´       hasNext¬ª.        ,        -  ,  ¬´ ¬ª. <br><br>     C++, ,        ,  ,        . <br><br>  ,       ‚Äî   .    C++  ¬´¬ª   ,  C++     (clang LLVM,          ..). <br><br><hr><br> <strong>   ?</strong> </cut></div><p>Source: <a href="https://habr.com/ru/post/307180/">https://habr.com/ru/post/307180/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../307168/index.html">Goodbye object-oriented programming</a></li>
<li><a href="../307170/index.html">Making our game designer at Unity easier and more enjoyable</a></li>
<li><a href="../307172/index.html">The first programs are published for the IBM quantum computer.</a></li>
<li><a href="../307176/index.html">Samsung SM961 512GB and 256GB SSD Review</a></li>
<li><a href="../307178/index.html">Java performance: present and future</a></li>
<li><a href="../307184/index.html">Who is behind the Pokemon Go PR campaign?</a></li>
<li><a href="../307186/index.html">Choose a long way (or goodbye MAX_PATH)</a></li>
<li><a href="../307188/index.html">Cross-platform use of .Net classes in 1C through Native VK. Or replacing COM with Linux II</a></li>
<li><a href="../307192/index.html">Lead from the fields: who and how applied qualitative methods in UX Research to develop IT products. Part 2 of 6</a></li>
<li><a href="../307196/index.html">Who is Caviar? School of creative thinking for the digital world</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>