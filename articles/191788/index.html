<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Frontend caching: Flask, Nginx + Memcached + SSI</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For a long time, the following articles on this subject caught my eye: 


- nginx, memcached and SSI 
- Nginx + Memcached + SSI - caching pages and bl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Frontend caching: Flask, Nginx + Memcached + SSI</h1><div class="post__text post__text-html js-mediator-article">  For a long time, the following articles on this subject caught my eye: <br><ul><li>  <a href="http://habrahabr.ru/post/30662/">nginx, memcached and SSI</a> </li><li>  <a href="http://highload.com.ua/index.php/2010/04/06/nginx-memcached-ssi-%25D0%25BA%25D0%25B5%25D1%2588%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5-%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B8%25D1%2586-%25D0%25B8-%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25B2-partials/">Nginx + Memcached + SSI - caching pages and blocks (partials)</a> </li><li>  <a href="http://highload.com.ua/index.php/2010/01/22/%25D0%25BA%25D0%25B5%25D1%2588%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5-%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B8%25D1%2586-%25D1%2583%25D1%2581%25D0%25BA%25D0%25BE%25D1%2580%25D1%258F%25D0%25B5%25D0%25BC-%25D1%2581%25D0%25B0%25D0%25B9%25D1%2582-%25D0%25B2-100/">Page caching - we speed up the site by 100 times (Varnish + ESI)</a> </li></ul><br>  I'm friends with PHP, so I tried the examples and made sure that it works.  But all this had ‚Äúfatal flaws‚Äù :) - PHP, and I am a Python fan and am mainly involved in backend work.  Seriously speaking, it was not possible to put it into practice. <br><br>  However, at the beginning of the year, a proposal was made to participate in one ambitious project, initially implying HiLoad and other buns from this opera.  While business plans were being compiled, investors and other similar cases were looking for, I decided to study issues that in my opinion would be useful in this work, including caching issues. <br><br>  First of all, a draft solution was implemented for my favorite framework, <a href="http://flask.pocoo.org/docs/">Flask, which</a> uses the <b>Varnish + ESI</b> stack for caching.  It worked and even showed good results.  Later it came to the realization that Varnish is probably an ‚Äúextra player‚Äù and that‚Äôs all, and you can even get more flexible on the <b>Nginx + Memcached + SSI</b> bundle.  This option was made, there was no noticeable difference in performance, but the latter seemed more flexible and manageable. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      That project did not even taxi to the runway, or taxi but without me.  Thinking, I decided to ‚Äúcomb the code‚Äù and put it in the OpenSource and in the public court. <br><a name="habracut"></a><br>  I will not describe in detail the principle of caching fragments of pages.  In the above articles, it is described well enough, and Google with Yandex will help to find even more information.  I will try to focus more on a specific implementation.  In my case, this is <b>Nginx + Memcached + SSI</b> and <b>Flask</b> using the extension written by me. <br><br>  In short, the principle is described in several sentences.  The result of the function that generates a webcast fragment is placed in memcached with the key usually represented as a URI uniquely corresponding to this fragment, and the page itself displays a line of the form <b>&lt;! - # include virtual = "&lt;URI&gt;" -&gt;</b> , where &lt;URI&gt; - the key value for which the real content is put in the cache.  Further, ‚Äúspecially trained‚Äù Nginx having encountered this instruction when proxying replaces it with real content received directly from the memcached server. <br><br>  Consider the example of a typical site, where each page has a block, in which a greeting to the user and the number of posts and comments made by him are displayed.  Counting the number of user messages is quite a costly operation, and if we also print a graph of friends there, then only this fragment will significantly decrease the database and, consequently, the overall page loading speed.  But there is a solution!  You can cache the content of this block as described above and queries to the database will not be made every time a user opens a new photo in an album.  Nginx will give this block "without straining" bakand.  The application remains to update the content in the cache, if the user created a new post or wrote a comment. <br><br>  This approach is different from the typical one when the application itself selects data from the cache and displays it on the page in that Nginx is now responsible for this, and Nginx is the thing!  Which is incomparable in the speed of content delivery with none of the frameworks known to me. <br><br><h4>  Practical part </h4><br>  The extension code is not particularly sophisticated by me called <b>Flask-Fragment</b> and <a href="https://github.com/AleshGood/Flask-Fragment">published on GitHub under the MIT license</a> .  There are no tests, there is no documentation, but there is a fairly functional demo application representing the ‚Äúlite‚Äù version of the blog.  If it will be interesting to someone else besides me, I plan to make some expansion of the API, support for the Varnish + ESI variant and of course the tests and documentation. <br><br><h5>  Enable caching </h5><br>  To select a fragment and its subsequent caching, you need to create a function that generates only the required part of the page.  Mark it as responsible for fragment generation by the fragment decorator.  For its functionality meets the extension Flask-Fragment, one must be connected.  Such functions, I will continue to call them <b>fragment view</b> , can take the parameters they need, and the output should give the content suitable for insertion into the web page. <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Flask <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask.ext.fragment <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Fragment app = Flask(__name__) fragment = Fragment(app) @fragment(app, cache=<span class="hljs-number"><span class="hljs-number">300</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">posts_list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(page)</span></span></span><span class="hljs-function">:</span></span> page = int(page) page_size = POSTS_ON_PAGE pagination = Post.query.filter_by().paginate(page, page_size) posts = Post.query.filter_by().offset((page<span class="hljs-number"><span class="hljs-number">-1</span></span>)*page_size).limit(page_size).all() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> render_template(<span class="hljs-string"><span class="hljs-string">'fragments/posts_list.html'</span></span>, pagination=pagination, posts=posts)</code> </pre><br>  In the template of the main page the fragment call is made in the following form: <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"content"</span></span></span><span class="hljs-tag">&gt;</span></span> {% block content %} {{ fragment('posts_list', page) }} {% endblock %} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Now, when you first call the fragment with the <code>page=2</code> parameter, the result of the <code>posts_list</code> function will be placed in the memcached cache with the <b><code>fragment:/_inc/posts_list/2</code></b> , and the instruction for Nginx will be inserted into the page.  It will look like this: <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"content"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--# include virtual="/_inc/posts_list/2" --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  In addition, the <b><code>fragment:fresh:/_inc/posts_list/2</code></b> key with a value of 1 will also be placed in memcached. An extension intercepting a call to the <code>posts_list</code> function will not launch it to generate content while this key is in the cache and has a value&gt; 0. <br><br>  The TTL for the <code>fragment:/_inc/posts_list/2</code> key <code>fragment:/_inc/posts_list/2</code> will be set to 300 (we defined it in the <code>fragment</code> decorator‚Äôs <code>cache</code> parameter) + FRAGMENT_LOCK_TIMEOUT value set in the configuration, by default 180. And the <code>fragment:fresh:/_inc/posts_list/2</code> TTL <code>fragment:fresh:/_inc/posts_list/2</code> only on the specified value is 300. After this, Nginx, having encountered the instruction in the code, <code>&lt;!--# include virtual="/_inc/posts_list/2" ‚Äì&gt;</code> will take the content of this fragment from the memcached cache without accessing the application for 480 seconds.  In principle, Nginx will not wait for a TTL expiration situation, the application will update the content after 300 seconds, when the <code>fragment:fresh:/_inc/posts_list/2</code> key no longer exists. <br><br><h5>  Cache reset </h5><br>  So the fragment is cached.  By the way, the example above is taken from the demo application that comes with the Flask-Fragment package, it generates a list of posts with the number of comments to each of them.  Accordingly, when a user adds a post or comment, the content of the list in the cache will be irrelevant.  It needs to be updated.  Below is an example of flask view which is called when a post is added. <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@app.route('/new/post', methods=['GET', 'POST']) @login_required def new_post(): form = PostForm() if form.validate_on_submit(): form.post.author_id = current_user.id db.session.add(form.post) db.session.commit() fragment.reset(posts_list) fragment.reset(user_info, current_user.id) flash('Your post has saved successfully.', 'info') return redirect(url_for('index')) return render_template('newpost.html', form=form)</span></span></code> </pre><br>  There are two calls to the <b><code>fragment.reset</code></b> method.  The first <code>fragment.reset(posts_list)</code> resets the cache for the fragment view <code>posts_list</code> , the second <code>fragment.reset(user_info, current_user.id)</code> resets the cache for that block with the user greeting, which I gave as an example at the beginning of the article, as it displays the total number of posts and user comments.  This fragment is uniquely addressed by the URI / _inc / user_info / 21, where the last digit is the user's <code>userid</code> .  The extension organizes the reset of the key itself, forming it based on the parameters passed to <code>fragment.reset</code> . <br><br>  The situation is worse in the first case, it uses pagination and there will be as many keys reset as there are currently generated pages for the list of posts.  For example <code>fragment:fresh:/_inc/posts_list/2</code> , this is only the key to reset the second page.  It cannot do without the intervention of a higher mind.  Below is a function code that performs a specific cache reset fragment <code>view posts_list</code> . <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@fragment.resethandler(posts_list) def reset_posts_list(): page_size = POSTS_ON_PAGE pagination = Post.query.filter_by().paginate(1, page_size) for N in range(pagination.pages): fragment.reset_url(url_for('posts_list', page=N+1))</span></span></code> </pre><br>  Here, the <b><code>fragment.resethandler</code></b> decorator is used to determine the ‚Äúcustom‚Äù handler, in which the cache is reset for each page of the list of posts using the <b><code>fragment.reset_url</code></b> method. <br><br>  In conclusion, I will present another block of code, these are the methods of the flask extension itself, which illustrate the key part of the functionality associated with the formation and writing of the contents of fragments in the cache. <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, url, timeout, deferred_view)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.memcache <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> timeout: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self._cache_valid(url): self._cache_prepare(url, timeout, deferred_view) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jinja2.Markup(<span class="hljs-string"><span class="hljs-string">'&lt;!--# include virtual="{0}" --&gt;'</span></span>.format(url)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jinja2.Markup(deferred_view()) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_cache_valid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, url)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bool(self.memcache.get(self.fresh_prefix+url) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_cache_prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, url, timeout, deferred_view)</span></span></span><span class="hljs-function">:</span></span> successed_lock = self.memcache.add(self.lock_prefix+url, <span class="hljs-number"><span class="hljs-number">1</span></span>, self.lock_timeout) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> successed_lock: result = Compressor.unless_prefix+(deferred_view()).encode(<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>) self.memcache.set(self.body_prefix+url, result, timeout+self.lock_timeout) self.memcache.set(self.fresh_prefix+url, <span class="hljs-number"><span class="hljs-number">1</span></span>, timeout) self.memcache.delete(self.lock_prefix+url)</code> </pre><br>  As you can see, an attempt is made to create a lock key.  This prevents race condition.  Information in the cache is only updated by one thread that has managed to set the lock, the rest execute the default silence script and while the old data is returned to the client. <br><br><h5>  Conclusion </h5><br>  What did we get?  And we got a serious unloading of the frontend and the database, which is clearly seen when running the demo application in the DebugToolbar panel.  Later, I plan to put in the repository a load test, made on the assumption that the blog user generates only 5% of requests to add posts or comments, the rest is viewing.  However, if you fill two or three dozen posts with two or three dozen comments to each, then on a weak virtual machine the difference is already noticeable. <br><br>  Caching can be turned off by setting the value of the <code>FRAGMENT_CACHING</code> parameter in the config to <code>False</code> .  In this case, the application can work without proxying through Nginx, the extension will insert the real content of the fragments independently. <br><br>  Thank you for your attention, I hope the article was interesting not only for web programmers who are interested in Python, but also for anyone interested in improving the performance of web applications.  I also hope that I contributed to the popularization of the wonderful framework <a href="http://flask.pocoo.org/docs/">Flask</a> . </div><p>Source: <a href="https://habr.com/ru/post/191788/">https://habr.com/ru/post/191788/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../191762/index.html">Various methods for loading associations in Ruby on Rails</a></li>
<li><a href="../191764/index.html">Installing and using Archipel for managing virtual machines</a></li>
<li><a href="../191766/index.html">MiniJava programming language compiler</a></li>
<li><a href="../191772/index.html">The funniest comments in the source code</a></li>
<li><a href="../191786/index.html">Error handling panic / defer style in Python</a></li>
<li><a href="../191790/index.html">The successful experience of the organization of the neurocomputer interface between people</a></li>
<li><a href="../191794/index.html">Crime prediction systems</a></li>
<li><a href="../191796/index.html">Skype is 10 years old</a></li>
<li><a href="../191798/index.html">Curiosity is offline</a></li>
<li><a href="../191800/index.html">Derby.js - a new look at web development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>