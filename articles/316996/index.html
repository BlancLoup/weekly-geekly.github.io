<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a blog engine with Phoenix and Elixir / Part 5. Connecting ExMachina</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: ‚Äú Elixir and Phoenix are a great example of where modern web development is heading. Already, these tools provide high-quality ac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a blog engine with Phoenix and Elixir / Part 5. Connecting ExMachina</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/68b/cfd/be8/68bcfdbe8cb3469eb7dc1975df64cae4.png"><br><br>  From the translator: ‚Äú <i>Elixir and Phoenix are a great example of where modern web development is heading.</i>  <i>Already, these tools provide high-quality access to real-time technologies for web applications.</i>  <i>Sites with increased interactivity, multiplayer browser games, microservices - those areas in which these technologies will serve a good service.</i>  <i>The following is a translation of a series of 11 articles that describe in detail the aspects of development on the Phoenix framework that would seem such a trivial thing as a blog engine.</i>  <i>But do not hurry to sulk, it will be really interesting, especially if the articles encourage you to pay attention to the Elixir or become its followers.</i> <i><br><br></i>  <i>In this part, we will include the ExMachina library to improve the testing process.</i>  <i>Now you don‚Äôt need to copy identical code to create test models, factories will do it for us!</i> <br><a name="habracut"></a><br>  At the moment, our application is based on: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <b>Elixir</b> : v1.3.1 </li><li>  <b>Phoenix</b> : v1.2.0 </li><li>  <b>Ecto</b> : v2.0.2 </li><li>  <b>Comeonin</b> : v2.5.2 </li></ul><br><h2>  Introduction </h2><br>  As you noticed, in the process of writing this engine, we use only a few libraries.  Now add another one called ExMachina.  She is an analogue of Factory Girl from Ruby. <br><br><h2>  What is this? </h2><br>  As just mentioned, ExMachina is designed in the image of Factory Girl - the implementation of the Ruby <i>Factory</i> pattern (also from great guys from Thoughtbot).  We proceed from the fact that it would be great to add various models with links to tests, without rewriting the code from time to time to create them.  You can accomplish the same thing yourself with the help of auxiliary modules that include simple functions for generating models.  But then everything will be reduced to the constant creation of such modules for each necessary data set, for each connection, and so on.  It certainly will have time to get bored. <br><br><h2>  Getting started </h2><br>  Let's start by opening the <code>mix.exs</code> file to add ExMachina to the <code>deps</code> and <code>application</code> lists.  To do this, simply insert another entry for ExMachina into the list of dependencies immediately after ComeOnIn: <br><br><pre> <code class="hljs ruby">defp deps <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> [{<span class="hljs-symbol"><span class="hljs-symbol">:phoenix</span></span>, <span class="hljs-string"><span class="hljs-string">"~&gt; 1.2.0"</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:phoenix_pubsub</span></span>, <span class="hljs-string"><span class="hljs-string">"~&gt; 1.0"</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:phoenix_ecto</span></span>, <span class="hljs-string"><span class="hljs-string">"~&gt; 3.0"</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:postgrex</span></span>, <span class="hljs-string"><span class="hljs-string">"&gt;= 0.0.0"</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:phoenix_html</span></span>, <span class="hljs-string"><span class="hljs-string">"~&gt; 2.6"</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:phoenix_live_reload</span></span>, <span class="hljs-string"><span class="hljs-string">"~&gt; 1.0"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">only:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:dev</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:gettext</span></span>, <span class="hljs-string"><span class="hljs-string">"~&gt; 0.11"</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:cowboy</span></span>, <span class="hljs-string"><span class="hljs-string">"~&gt; 1.0"</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:comeonin</span></span>, <span class="hljs-string"><span class="hljs-string">"~&gt; 2.5.2"</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:ex_machina</span></span>, <span class="hljs-string"><span class="hljs-string">"~&gt; 1.0"</span></span>}] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  And then add <code>:ex_machina</code> to the list of used applications: <br><br><pre> <code class="hljs sql">def application <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">mod</span></span>: {Pxblog, []}, applications: [:phoenix, :phoenix_pubsub, :phoenix_html, :cowboy, :logger, :gettext, :phoenix_ecto, :postgrex, :comeonin, :ex_machina]] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Run the following command to ensure that the application components are ready and configured correctly: <br><br><pre> <code class="bash hljs">$ mix <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> deps.get, compile</code> </pre> <br>  If everything goes well, then you should see a message on the output about installing ExMachina and successfully compiling the project!  Before we change the code, you need to run the <code>mix test</code> and make sure that all tests are green. <br><br><h2>  Add the first role factory. </h2><br>  We need to create a factory module and make it available for all tests.  I prefer to do this without inflating the tests.  To do this, simply throw the module file with the factories into the <code>test/support</code> directory and then write its import in the tests we need. <br><br>  So let's start by creating the <code>test/support/factory.ex</code> file: <br><br><pre> <code class="hljs pgsql">defmodule Pxblog.Factory <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use ExMachina.Ecto, repo: Pxblog.Repo <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.<span class="hljs-keyword"><span class="hljs-keyword">Role</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.Post def role_factory <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> %<span class="hljs-keyword"><span class="hljs-keyword">Role</span></span>{ <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">sequence</span></span>(:<span class="hljs-type"><span class="hljs-type">name</span></span>, &amp;"Test Role #{&amp;1}"), <span class="hljs-keyword"><span class="hljs-keyword">admin</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  We called it <code>Factory</code> because such a name reflects the essence of this module.  Then we will use special factory functions.  They compare with the sample an atom supplied to the input, which determines which type of factory <i>to assemble</i> / <i>create</i> .  Since this library is pretty close to Factory Girl, it also brings with it some naming conventions that are important to know.  The first such name will be <code>build</code> .  The <code>build</code> function means that the model ( <i>not the revision</i> ) will be <i>built</i> without saving to the database.  The second agreement will be the name of the <code>insert</code> function, which vice versa saves the model in the database, thereby <i>creating</i> it. <br><br>  We also need to specify <code>use ExMachina.Ecto</code> so that ExMachina uses Ecto as the Repo layer and behaves accordingly when creating models, associations, etc.  We also need to add pseudonyms to all the models for which we will write factories. <br><br>  The <code>role_factory</code> function should simply return a <code>Role</code> structure that defines default properties.  This feature only supports arity 1. <br><br>  The piece with the <code>sequence</code> function is pretty curious.  We need to generate a unique name for each role.  Therefore, we will make it sequentially generated.  To do this, we take the function <code>sequence</code> , in which we pass two arguments: the first is the name of the field for which we want to generate a sequence, the second is an anonymous function, which returns a string and interpolates the value inside it.  Let's take a look at this feature: <br><br><pre> <code class="hljs cmake">&amp;‚Äù<span class="hljs-keyword"><span class="hljs-keyword">Test</span></span> Role <span class="hljs-comment"><span class="hljs-comment">#{&amp;1}‚Äù</span></span></code> </pre> <br>  If you are familiar with Elixir, you may have learned an alternative way to write anonymous functions.  It roughly translates as: <br><br><pre> <code class="hljs ruby">fn x -&gt; <span class="hljs-string"><span class="hljs-string">"Test Role </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{x}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  So the <code>sequence</code> function can be explained this way: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">sequence</span></span>(:<span class="hljs-type"><span class="hljs-type">name</span></span>, fn x -&gt; "Test Role #{x}" <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)</code> </pre> <br>  Finally, set the admin flag to <code>false</code> , because  we use this value as the default condition.  We can create the administrative role by specifying this explicitly.  Other more advanced features of ExMachina let's discuss a little later.  Now we will spend some time combining our new factory <code>Role</code> with controller tests. <br><br><h2>  Add Role factory to controller tests </h2><br>  First open the <code>test/controllers/user_controller_test.exs</code> .  At the top, in the <code>setup</code> block, add the use of our new function <code>TestHelper.create_role</code> : <br><br><pre> <code class="hljs kotlin"># ... <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Pxblog.Factory <span class="hljs-meta"><span class="hljs-meta">@valid_create_attrs</span></span> %{email: <span class="hljs-string"><span class="hljs-string">"test@test.com"</span></span>, username: <span class="hljs-string"><span class="hljs-string">"test"</span></span>, password: <span class="hljs-string"><span class="hljs-string">"test"</span></span>, password_confirmation: <span class="hljs-string"><span class="hljs-string">"test"</span></span>} <span class="hljs-meta"><span class="hljs-meta">@valid_attrs</span></span> %{email: <span class="hljs-string"><span class="hljs-string">"test@test.com"</span></span>, username: <span class="hljs-string"><span class="hljs-string">"test"</span></span>} <span class="hljs-meta"><span class="hljs-meta">@invalid_attrs</span></span> %{} setup <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> user_role = insert(:role) {:ok, nonadmin_user} = TestHelper.create_user(user_role, %{email: <span class="hljs-string"><span class="hljs-string">"nonadmin@test.com"</span></span>, username: <span class="hljs-string"><span class="hljs-string">"nonadmin"</span></span>, password: <span class="hljs-string"><span class="hljs-string">"test"</span></span>, password_confirmation: <span class="hljs-string"><span class="hljs-string">"test"</span></span>}) admin_role = insert(:role, admin: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) {:ok, admin_user} = TestHelper.create_user(admin_role, %{email: <span class="hljs-string"><span class="hljs-string">"admin@test.com"</span></span>, username: <span class="hljs-string"><span class="hljs-string">"admin"</span></span>, password: <span class="hljs-string"><span class="hljs-string">"test"</span></span>, password_confirmation: <span class="hljs-string"><span class="hljs-string">"test"</span></span>}) {:ok, conn: build_conn(), admin_role: admin_role, user_role: user_role, nonadmin_user: nonadmin_user, admin_user: admin_user} end # ...</code> </pre> <br>  But before that, we import the factory module itself.  In <i>line 10,</i> we simply add the role using the <code>:role</code> factory.  In <i>line 13,</i> we do the same, but override the admin flag to <code>true</code> . <br><br>  Save the file and restart the tests.  All of them must still pass!  Now let's write a factory for users, which also creates connections. <br><br><h2>  Add a factory for users </h2><br>  Take a look at the factory for users. <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">def</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">user_factory</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">do</span></span> %<span class="hljs-selector-tag"><span class="hljs-selector-tag">User</span></span>{ <span class="hljs-attribute"><span class="hljs-attribute">username</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">sequence</span></span>(:username, &amp;<span class="hljs-string"><span class="hljs-string">"User #{&amp;1}"</span></span>), email: <span class="hljs-string"><span class="hljs-string">"test@test.com"</span></span>, password: <span class="hljs-string"><span class="hljs-string">"test1234"</span></span>, password_confirmation: <span class="hljs-string"><span class="hljs-string">"test1234"</span></span>, password_digest: Comeonin.Bcrypt.<span class="hljs-built_in"><span class="hljs-built_in">hashpwsalt</span></span>(<span class="hljs-string"><span class="hljs-string">"test1234"</span></span>), role: <span class="hljs-built_in"><span class="hljs-built_in">build</span></span>(:role) } <span class="hljs-selector-tag"><span class="hljs-selector-tag">end</span></span></code> </pre> <br>  Basically, this factory is the same as what we wrote earlier for creating roles.  But there are a couple of pitfalls with which we have to deal.  Above, on <i>line 7</i> , you can see that we set the <code>password_digest</code> value to the password <code>password</code> hash value (as we simulate user login, we need to add this as well).  We simply call the Bcrypt module from Comeonin and use the <code>hashpwsalt</code> function, passing the same value to it as in the <code>password</code> / <code>password_confirmation</code> fields.  On the next line, we also set <code>role</code> as an association.  We use the <code>build</code> function and pass in it the name of the association we want to build, in the form of an atom. <br><br>  After modifying the user factory, let's go back to the file <code>test/controllers/user_controller_test.exs</code> . <br><br><pre> <code class="hljs sql">setup <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> user_role = <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(:<span class="hljs-keyword"><span class="hljs-keyword">role</span></span>) nonadmin_user = <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(:<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">role</span></span>: user_role) admin_role = <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(:<span class="hljs-keyword"><span class="hljs-keyword">role</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">admin</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) admin_user = <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(:<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">role</span></span>: admin_role) {:ok, <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>: build_conn(), admin_role: admin_role, user_role: user_role, nonadmin_user: nonadmin_user, admin_user: admin_user} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Now we will finally replace all calls to <code>TestHelper</code> calls to the factory.  We take the role and transfer it to the factory to create a user with the right role.  Then, do the same with the administrator, but we don‚Äôt need to change our tests! <br><br>  Run them and make sure they are still green.  We can continue. <br><br><h2>  Add factory for posts </h2><br>  I think we have already filled our hands in adding new factories, so work on the latter should not cause any difficulties. <br><br>  There is nothing new here, so let's just change the file <code>test/controllers/post_controller_test.exs</code> : <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">def</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">post_factory</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">do</span></span> %<span class="hljs-selector-tag"><span class="hljs-selector-tag">Post</span></span>{ <span class="hljs-attribute"><span class="hljs-attribute">title</span></span>: <span class="hljs-string"><span class="hljs-string">"Some Post"</span></span>, body: <span class="hljs-string"><span class="hljs-string">"And the body of some post"</span></span>, user: <span class="hljs-built_in"><span class="hljs-built_in">build</span></span>(:user) } <span class="hljs-selector-tag"><span class="hljs-selector-tag">end</span></span></code> </pre> <br>  Once again, we <code>import</code> the <code>Pxblog.Factory</code> module <code>Pxblog.Factory</code> that our tests know where the factory is to which we send calls.  Then we replace all the steps to create a post in the <code>setup</code> block with a factory call.  Using the <code>insert</code> function, a <code>role</code> structure is created, which is then used to create a user through the factory, which is finally used to create the post associated with it ... Just something! <br><br>  Run the tests.  They turned green again! <br><br>  From this place, everything else is just extra work.  Let's go back and replace all calls to <code>TestHelper</code> with <code>Factory</code> calls.  This is not particularly new or exciting, so I will not pay undue attention to explaining the details. <br><br><h2>  Other ways to connect factories </h2><br>  I choose the path of explicitly connecting my factories to each of the tests, but if you don‚Äôt want to do the same, you can use one of the following methods. <br><br>  Add an alias to the <code>using</code> block in the <code>test/support/model_case.ex</code> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">quote</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.Repo <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Ecto <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Ecto.Changeset <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Ecto.Query <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Pxblog.ModelCase <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Pxblog.Factory <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  And the <code>test/support/conn_case.ex</code> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">quote</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> # <span class="hljs-keyword"><span class="hljs-keyword">Import</span></span> conveniences <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> testing <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> connections use Phoenix.ConnTest <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Pxblog.Repo <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Ecto <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Ecto.Changeset <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Ecto.Query <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Pxblog.Router.Helpers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Pxblog.Factory # The <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> endpoint <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> testing @endpoint Pxblog.Endpoint <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><h2>  Other ExMachina features </h2><br>  For the purposes of a small blogging engine, we do not need any other features provided by ExMachina.  For example, besides <code>build</code> and <code>create</code> there is support for some other functions for the sake of convenience (I use <code>build</code> as an example, but it also works with <code>create</code> ): <br><br><pre> <code class="hljs lisp">build_pair(<span class="hljs-symbol"><span class="hljs-symbol">:factory</span></span>, attrs) &lt;- Builds <span class="hljs-number"><span class="hljs-number">2</span></span> models build_list(<span class="hljs-name"><span class="hljs-name">n</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:factory</span></span>, attrs) &lt;- Builds N models</code> </pre> <br>  You can also save the model you built using the <code>build</code> method by calling <code>create</code> on it: <br><br><pre> <code class="hljs pgsql">build(:<span class="hljs-keyword"><span class="hljs-keyword">role</span></span>) |&gt; <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span></code> </pre> <br><h2>  Other resources </h2><br>  For more information on using ExMachina, visit the <a href="https://github.com/thoughtbot/ex_machina">Github page</a> .  You can also visit the Thoughbot technical blog, where the creators posted a <a href="https://robots.thoughtbot.com/announcing-ex-machina">wonderful ExMachina announcement</a> and some other ways to use it. <br><br><h2>  Let's sum up </h2><br>  At first, I must say, I was a little wary, remembering how I had previously implemented some things with the help of Factory Girl.  I was afraid that here everything would go the same way.  But Elixir protects us from ourselves, which helps to find a balance when testing.  The syntax is clear and clean.  The amount of code required has decreased significantly.  Many thanks to the glorious guys from Thoughtbot for another extremely useful library. <br><br><h2>  Conclusion from the Wuns </h2><br>  Today is a very short conclusion - just subscribe to our <a href="https://wunsh.ru/%3Futm_source%3Dhabrahabr%26utm_medium%3Dcontent%26utm_campaign%3Dblog-phoenix-5">Elixir community</a> and get interesting articles in Russian every week. <br><br><h2>  Other series articles </h2><br><ol><li>  <a href="https://habrahabr.ru/post/311088/">Introduction</a> </li><li>  <a href="https://habrahabr.ru/post/313482/">Authorization</a> </li><li>  <a href="https://habrahabr.ru/post/315252/">Adding Roles</a> </li><li>  <a href="https://habrahabr.ru/post/316368/">Process roles in controllers</a> </li><li>  We connect ExMachina </li><li>  <a href="https://habrahabr.ru/post/317550/">Markdown support</a> </li><li>  <a href="https://habrahabr.ru/post/318790/">Add comments</a> </li><li>  <a href="https://habrahabr.ru/post/323462/">We finish with comments</a> </li><li>  <a href="https://habrahabr.ru/post/332094/">Channels</a> </li><li>  <a href="https://habrahabr.ru/post/333020/">Channel testing</a> </li><li>  <a href="https://habrahabr.ru/post/335048/">Conclusion</a> </li></ol><br><br>  Good luck in learning, stay with us! </div><p>Source: <a href="https://habr.com/ru/post/316996/">https://habr.com/ru/post/316996/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../316980/index.html">Formula of trust</a></li>
<li><a href="../316986/index.html">Tuning Swift compiler. Part 1</a></li>
<li><a href="../316988/index.html">Nonlinear regression in Apache Spark. We develop with our own hands</a></li>
<li><a href="../316990/index.html">STM32: FreeRTOS and Piezo Ceramic Emitter</a></li>
<li><a href="../316994/index.html">Bad advice or how to become a terrible leader.</a></li>
<li><a href="../317002/index.html">We write real Pointer Analysis for LLVM. Part 1: Introducing or first meeting with the world of program analysis</a></li>
<li><a href="../317004/index.html">RubyMine 2016.3: Debugging in attach mode, updated support for Puppet, SDK synchronization via rsync</a></li>
<li><a href="../317008/index.html">Productivity is my ecommerce site evaluation method</a></li>
<li><a href="../317010/index.html">History of programming languages: Algol - a victim of a conflict of interest</a></li>
<li><a href="../317012/index.html">Choosing a hosting: speed and reliability</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>