<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Kotlin DSL: Theory and Practice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sql, RegExp, Gradle - what unites them? These are all examples of using problem-oriented languages ‚Äã‚Äãor domain-specific language. Each such language s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Kotlin DSL: Theory and Practice</h1><div class="post__text post__text-html js-mediator-article"><p>  Sql, RegExp, Gradle - what unites them?  These are all examples of using problem-oriented languages ‚Äã‚Äãor domain-specific language.  Each such language solves its own narrowly focused task, for example, requesting data from a database, searching for matches in the text, or a description of the application building process.  The Kotlin language provides a large number of opportunities to create your own problem-oriented language.  In the course of the article, we will figure out what tools are in the programmer‚Äôs arsenal, and implement DSL for the proposed subject area. </p><br><p>  I will explain the entire syntax presented in the article as simply as possible, however, the material is intended for practicing engineers who view Kotlin as a language for building problem-oriented languages.  At the end of the article will be given the shortcomings that need to be prepared.  The code used in the article is relevant for Kotlin version 1.1.4-3 and is available on GitHub. </p><br><p><img src="https://habrastorage.org/webt/lq/hh/et/lqhhetd_sjpnqtbrv5cdvow7pzo.png"></p><a name="habracut"></a><br><h2 id="chto-takoe-dsl">  What is DSL? </h2><br><p>  Programming languages ‚Äã‚Äãcan be divided into 2 types: universal languages ‚Äã‚Äã(general-purpose programming language) and domain-specific language.  Popular DSL examples are SQL, regular expressions, build.gradle.  A language reduces the amount of functionality provided, but at the same time it is able to effectively solve a specific problem.  This is a way to describe the program not in an imperative style (how to get the result), but in a declarative or close to declarative (describe the current problem), in which case the solution to the problem will be obtained on the basis of the specified information. </p><br><p>  Suppose you have a standard execution process, which can sometimes change, be refined, but in general you want to use it with different data and format of the result.  Creating a DSL, you make a flexible tool for solving various problems from one subject area, and the end user of your DSL does not think about how the solution will be obtained.  This is some API, masterfully using which you can greatly simplify your life and long-term system support. </p><br><p>  In the article I reviewed the construction of the "internal" DSL in the Kotlin language.  This kind of problem-oriented languages ‚Äã‚Äãis implemented on the basis of the universal language syntax.  You can read more about this <a href="https://en.wikipedia.org/wiki/Domain-specific_language">here</a> . </p><br><h2 id="oblast-primeneniya">  Application area </h2><br><p>  One of the best ways to apply and demonstrate Kotlin DSL, in my opinion, is tests. </p><br><p>  Suppose you come from the world of Java.  How often did you have to describe standard instances of entities for a rather large data model again and again?  Is it possible that for this you used some builders or, even worse, special utility classes that filled the default values ‚Äã‚Äãunder the hood?  How many overloaded methods do you have?  How often do you need ‚Äúquite a bit‚Äù to deviate from the default values ‚Äã‚Äãand how much work does it have to do now?  If nothing but a negative, you do not cause these questions, then you are reading the correct article. </p><br><p>  For a long time on our project devoted to the educational sphere, we, in the same way, with the help of builders and utility classes, covered with tests one of the most important modules of the system - a module for building a training schedule.  This approach was replaced by the Kotlin and DSL language for the formation of various options for the use of a planning and verification system.  Below you will see examples of how we took advantage of the possibilities of the language and turned the development of tests on the planning subsystem from torture to pleasure. </p><br><p>  In the course of this article, we will look into the DSL design for testing a small demonstration system of class planning between a student and a teacher. </p><br><h2 id="osnovnye-vozmozhnosti">  Main features </h2><br><p>  Let's list the main advantages of Kotlin, which allow you to write clean enough in this language and are available for building your own DSL.  Below is a table with the main language syntax enhancements you should use.  Review this list carefully.  If most of the designs are not familiar to you, then it is advisable to read sequentially.  However, if you are not familiar with one or two points, you can go directly to them.  If everything is familiar to you here, then you can go on to review the shortcomings of using DSL at the end of the article.  If you want to add to this list, then please write your options in the comments. </p><br><table><thead><tr><th>  Functionality name </th><th>  DSL syntax </th><th>  Common syntax </th></tr></thead><tbody><tr><td>  Operator Overriding </td><td><code>collection += element</code> </td> <td> <code>collection.add(element)</code> </td> </tr><tr><td>  Type aliases </td><td> <code>typealias Point = Pair&lt;Int, Int&gt;</code> </td> <td>  Creating empty heir classes and other crutches </td></tr><tr><td>  Convention for get / set methods </td><td> <code>map["key"] = "value"</code> </td> <td> <code>map.put("key", "value")</code> </td> </tr><tr><td>  Multi-declaration </td><td> <code>val (x, y) = Point(0, 0)</code> </td> <td> <code>val p = Point(0, 0); val x = p.first; val y = p.second</code> </td> </tr><tr><td>  Lambda brackets </td><td> <code>list.forEach { ... }</code> </td> <td> <code>list.forEach({...})</code> </td> </tr><tr><td>  Extention function </td><td> <code>mylist.first(); //  first()     mylist</code> </td> <td>  Utilities </td></tr><tr><td>  Infix functions </td><td> <code>1 to "one"</code> </td> <td> <code>1.to("one")</code> </td> </tr><tr><td>  Lambda with handler </td><td> <code>Person().apply { name = ¬´John¬ª }</code> </td> <td>  Not </td></tr><tr><td>  Context control </td><td> <code>@DslMarker</code> </td> <td>  Not </td></tr></tbody></table><br><p>  Found something new for yourself?  Then we continue. </p><br><p>  In the table, delegated properties are intentionally omitted, since, in my opinion, they are useless for building DSL in the form that we will consider.  Thanks to these features, you can write code cleaner, get rid of a lot of ‚Äúnoisy‚Äù syntax and at the same time make development even more enjoyable (‚Äúwhere is more pleasant?‚Äù, You ask).  I liked the comparison from the book Kotlin in Action, in natural languages, for example, in English, sentences are built from words and grammatical rules govern how to combine words with each other.  Similarly in DSL, a single operation can be made up of several method calls, and type checking will ensure that the design makes sense.  Naturally, the order of calls may not always be obvious, but this remains on the conscience of the designer DSL. </p><br><p>  It is important to understand that in this article we will consider the ‚Äúinternal DSL‚Äù, i.e.  Problem-oriented language is based on the universal language - Kotlin. </p><br><h2 id="primer-finalnogo-rezultata">  Example of the final result </h2><br><p>  Before we begin to build our problem-oriented language, I want to demonstrate the result of what you can build after reading the article.  You can find all the code on the GitHub repository by <a href="https://github.com/ivan-osipov/kotlin-dsl-example">reference</a> .  Below is a DSL for testing teacher search for students in their subjects of interest.  In this example, there is a fixed time grid, and we check that the classes are placed in the teacher‚Äôs and student‚Äôs plans at the same time. </p><br><pre> <code class="hljs erlang-repl">schedule { data { startFrom(<span class="hljs-string"><span class="hljs-string">"08:00"</span></span>) subjects(<span class="hljs-string"><span class="hljs-string">"Russian"</span></span>, <span class="hljs-string"><span class="hljs-string">"Literature"</span></span>, <span class="hljs-string"><span class="hljs-string">"Algebra"</span></span>, <span class="hljs-string"><span class="hljs-string">"Geometry"</span></span>) student { name = <span class="hljs-string"><span class="hljs-string">"Ivanov"</span></span> subjectIndexes(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) } student { name = <span class="hljs-string"><span class="hljs-string">"Petrov"</span></span> subjectIndexes(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) } teacher { subjectIndexes(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) availability { monday(<span class="hljs-string"><span class="hljs-string">"08:00"</span></span>) wednesday(<span class="hljs-string"><span class="hljs-string">"09:00"</span></span>, <span class="hljs-string"><span class="hljs-string">"16:00"</span></span>) } } teacher { subjectIndexes(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) availability { thursday(<span class="hljs-string"><span class="hljs-string">"08:00"</span></span>) + sameDay(<span class="hljs-string"><span class="hljs-string">"11:00"</span></span>) + sameDay(<span class="hljs-string"><span class="hljs-string">"14:00"</span></span>) } } // data { } doesn't be compiled here because there is scope control with // @DataContextMarker } assertions { for ((day, lesson, student, teacher) in scheduledEvents) { val teacherSchedule: Schedule = teacher.schedule teacherSchedule[day, lesson] shouldNotEqual null teacherSchedule[day, lesson]!!.student shouldEqual student val studentSchedule = student.schedule studentSchedule[day, lesson] shouldNotEqual null studentSchedule[day, lesson]!!.teacher shouldEqual teacher } } }</code> </pre> <br><h2 id="instrumenty">  Instruments </h2><br><p>  A complete list of tools for building DSL, was given above.  Each of them was used in the example and, by examining the code by <a href="https://github.com/ivan-osipov/kotlin-dsl-example">reference</a> , you can study the construction of such constructions.  We will often return to this example to demonstrate various tools.  It is important to note that the decisions to build DSL are demonstrative, although you can repeat what you see in your own project, this does not mean that the presented option is the only correct one.  Below we take a detailed look at each tool. </p><br><p>  Some features of the language are especially good in combination with others and the first tool in this list is lambda outside the brackets. </p><br><h3 id="lyambda-vne-skobok">  Lambda outside brackets </h3><br><p>  <a href="https://kotlinlang.org/docs/reference/lambdas.html">Documentation</a> </p><br><p>  Lambda expressions or lambdas are blocks of code that can be passed to functions, saved, or called.  In the Kotlin language, the lambda type is denoted as follows <code>(  ) -&gt;  </code> .  Following this rule, the most primitive type of lambda is <code>() -&gt; Unit</code> , where Unit is an analogue of Void with one exception.  At the end of the lambda or function, we do not <br>  must write the "return ..." construct.  Due to this, we always have a return type, just in Kotlin this happens implicitly. </p><br><p>  Below is the simplest example of how you can save lambda to a variable: </p><br><pre> <code class="hljs coffeescript">val helloPrint: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String)</span></span></span><span class="hljs-function"> -&gt;</span></span> Unit = { println(it) }</code> </pre> <br><p>  For lambda without parameters, the compiler is able to independently derive the type from the already known ones.  However, in our case there is one parameter.  Calling such a lambda looks like this: </p><br><pre> <code class="hljs lisp">helloPrint(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>)</code> </pre> <br><p>  In the example above, lambda takes one parameter.  Inside the lambda, this parameter defaults to the name "it", but if there are several parameters, you must explicitly list their names, or use the underscore "_" to ignore it.  The example below demonstrates this behavior. </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> helloPrint: (String, <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> = { _, _ -&gt; println(<span class="hljs-string"><span class="hljs-string">"Do nothing"</span></span>) } helloPrint(<span class="hljs-string"><span class="hljs-string">"Does not matter"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>) <span class="hljs-comment"><span class="hljs-comment">//output: Do nothing</span></span></code> </pre> <br><p>  The basic tool that you might have already encountered, for example, in Groovy, is lambda outside the brackets.  Pay attention to the example at the very beginning of the article; almost every use of curly brackets, with the exception of standard constructions, is the use of lambda.  There are at least two ways to make a construction of the form <code>x { ‚Ä¶ }</code> : </p><br><ul><li>  the object x and its unary operator invoke (we will discuss this method later); </li><li>  x function to which lambda is passed. </li></ul><br><p>  Regardless of the option, we use lambda.  Suppose there is a function <code>x()</code> .  In the Kotlin language, the following rule applies: if lambda is the <strong>last</strong> argument of a function, then it can be taken out of the brackets, if the lambda is a <strong>single</strong> parameter, then you can leave out the brackets.  As a result, the <code>x({‚Ä¶})</code> construct can be converted to <code>x() {}</code> , and then, removing the brackets, we get <code>x {}</code> .  The declaration of such a function is as follows: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( lambda: ()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> ) { lambda() }</code> </pre> <br><p>  or in abbreviated form for single-line functions, you can write this: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( lambda: ()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> ) = lambda()</code> </pre> <br><p>  But what if x is an instance of a class, an object, not a function?  There is another interesting solution, which is based on one of the fundamental concepts used in the construction of problem-oriented languages, redefinition of operators.  Let's look at this tool. </p><br><h3 id="pereopredelenie-operatorov">  Operator Overriding </h3><br><p>  <a href="https://kotlinlang.org/docs/reference/operator-overloading.html">Documentation</a> </p><br><p>  Kotlin provides a wide but limited range of operators.  The operator modifier allows you to define functions by convention that will be called under certain conditions.  An obvious example is the plus function, which will be executed when using the "+" operator between two objects.  A complete list of operators can be found at the link above in the documentation. </p><br><p>  Consider a slightly less trivial operator "invoke".  The main example of this article begins with the schedule {} construct.  The purpose of the construction is to isolate the block of code that is responsible for planning testing.  To construct such a construction, a method slightly different from that discussed above is used: the invoke + operator ‚Äúlambda outside parentheses‚Äù.  After the definition of the invoke operator, the schedule (...) construction becomes available to us, while schedule is an object.  In fact, the call to schedule (...) is interpreted by the compiler as schedule.invoke (...).  Let's look at the schedule declaration. </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> schedule { <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">init</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SchedulingContext</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { SchedulingContext().<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() } }</code> </pre> <br><p>  It is necessary to understand that the schedule identifier refers us to a single instance of the schedule class (singleton), which is marked with the special keyword object (for more details on such objects, please read <a href="https://kotlinlang.org/docs/reference/object-declarations.html">here</a> ).  Thus, we call the invoke method on the schedule instance and, with the only parameter of the method, we determine the lambda, which we put out of the brackets.  As a result, the schedule {...} construction is equivalent to the following: </p><br><pre> <code class="hljs">schedule.invoke( {    } )</code> </pre> <br><p>  However, if you look closely at the invoke method, you will see not the usual lambda, but the lambda with a handler or the lambda with the context, the type of which is written as follows: <code>SchedulingContext.() -&gt; Unit</code> <br>  It's time to figure out what it is. </p><br><h3 id="lyambda-s-obrabotchikom">  Lambda with handler </h3><br><p>  <a href="https://kotlinlang.org/docs/reference/lambdas.html">Documentation</a> </p><br><p>  Kotlin gives us the opportunity to set the context for lambda expressions.  Context is a regular object.  The context type is defined along with the lambda expression type.  Such a lambda acquires the properties of a non-static method in a context class, but with access only to the public API of this class. <br>  While the type of a conventional lambda is defined as: <code>() -&gt; Unit</code> , the type of lambda with a context of type X is defined as: <code>X.()-&gt; Unit</code> and, if the first type of lambda can be run in the usual way: </p><br><pre> <code class="hljs coffeescript">val x : <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Unit = {} x()</code> </pre> <br><p>  then for lambda with context context is needed: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyContext</span></span></span><span class="hljs-class"> val x : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyContext</span></span></span><span class="hljs-class">.() -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Unit</span></span></span><span class="hljs-class"> = {} //x() // , ..    val c = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyContext</span></span></span><span class="hljs-class">() //  cx() //  x(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">c</span></span></span><span class="hljs-class">) //  </span></span></code> </pre> <br><p>  Let me remind you that in the schedule object we have an invoke operator defined (see the previous paragraph), which allows us to use the construction: </p><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">schedule</span></span> { }</code> </pre> <br><p>  The lambda we use has a context like SchedulingContext.  In this class, the data method is defined.  As a result, we get the following construction: </p><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">schedule</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> { //... } }</span></span></code> </pre><br><p>  As you probably guessed, the data method takes the lambda with context, however, the context is different.  Thus, we get nested structures within which several contexts are available simultaneously. </p><br><p>  To understand in detail how this example works, let's remove all syntactic sugar: </p><br><pre> <code class="hljs kotlin">schedule.invoke({ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>({ }) })</code> </pre> <br><p>  As you can see, everything is extremely simple. <br>  Let's take a look at the implementation of the invoke operator. </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">init</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SchedulingContext</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { SchedulingContext().<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() }</code> </pre> <br><p>  We call the constructor for the context: <code>SchedulingContext()</code> , and then on the created object (context) we call the lambda with the identifier init, which we passed as a parameter.  This is very similar to calling a regular function.  As a result, in one line <code>SchedulingContext().init()</code> we create a context and call the lambda passed to the operator.  If you are interested in other examples, then pay attention to the apply and with methods from the standard Kotlin library. </p><br><p>  In the last examples, we looked at the invoke operator and its interaction with other tools.  Next, we focus on another tool that is formally an operator and makes our code cleaner, namely the convention for get / set methods. </p><br><h3 id="soglashenie-dlya-getset-metodov">  Convention for get / set methods </h3><br><p>  <a href="https://kotlinlang.org/docs/reference/operator-overloading.html">Documentation</a> </p><br><p>  When developing DSL, we can implement the syntax of access to an associative array using one or more keys.  Take a look at the example below: </p><br><pre> <code class="hljs swift">availabilityTable[<span class="hljs-type"><span class="hljs-type">DayOfWeek</span></span>.<span class="hljs-type"><span class="hljs-type">MONDAY</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(availabilityTable[<span class="hljs-type"><span class="hljs-type">DayOfWeek</span></span>.<span class="hljs-type"><span class="hljs-type">MONDAY</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-comment"><span class="hljs-comment">//output: true</span></span></code> </pre> <br><p>  To use square brackets, you must implement the get or set methods depending on what you need (read or write) with the operator modifier.  An example of the implementation of this tool can be found in the Matrix class on GitHub by <a href="https://github.com/ivan-osipov/kotlin-dsl-example">reference</a> .  This is the simplest implementation of a wrapper for working with matrices.  Below is the part of the code that interests us. </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Matrix</span></span></span></span>(...) { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> content: List&lt;MutableList&lt;T&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, j: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = content[i][j] <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, j: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, value: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { content[i][j] = value } }</code> </pre> <br><p>  The types of parameters for the get and set functions are limited only by your imagination.  You can use one or several parameters for get / set functions and provide a comfortable syntax for accessing data.  Operators in Kotlin bring many interesting features that you can find <a href="https://kotlinlang.org/docs/reference/operator-overloading.html">in the documentation</a> . </p><br><p>  Surprisingly, the Kotlin standard library has a Pair class, but why?  Most of the community believes that the Pair class is bad, the meaning of the connection of two objects disappears with it and it becomes not obvious why they are paired.  The following two tools demonstrate how to preserve the meaningfulness of a couple, and not to create extra classes. </p><br><h3 id="psevdonimy-tipa">  Type aliases </h3><br><p>  <a href="https://kotlinlang.org/docs/reference/type-aliases.html">Documentation</a> </p><br><p>  Imagine that we need a wrapper class for a point on a plane with integer coordinates.  In principle, the <code>Pair&lt;Int, Int&gt;</code> class is suitable for us, but in a variable of this type at one moment we may lose understanding of why we connect values ‚Äã‚Äãin a pair.  Obvious fixes are either writing your own class or something worse.  In Kotlin, the developer‚Äôs arsenal is replenished with type aliases, which are written as follows: </p><br><pre> <code class="hljs pgsql">typealias <span class="hljs-type"><span class="hljs-type">Point</span></span> = Pair&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>,<span class="hljs-type"><span class="hljs-type">Int</span></span>&gt;</code> </pre> <br><p>  In fact, this is the usual renaming of the structure.  Thanks to this approach, we do not need to create a class Point, which in this case would simply duplicate the pair.  Now, we can create points like this: </p><br><pre> <code class="hljs pgsql">val <span class="hljs-type"><span class="hljs-type">point</span></span> = <span class="hljs-type"><span class="hljs-type">Point</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br><p>  However, the Pair class has two properties, first and second, and how can we rename these properties to erase any differences between the desired class Point and Pair?  The properties themselves cannot be renamed, but there is a great opportunity in our toolkit, which craftsmen have identified as multi-declarations. </p><br><h3 id="multi-deklaracii-destructuring-declaration">  Multi-declaration (destructuring declaration) </h3><br><p>  <a href="https://kotlinlang.org/docs/reference/multi-declarations.html">Documentation</a> </p><br><p>  For ease of understanding the example, consider the situation: we have an object of type Point, as we know from the example above, this is just the renamed type <code>Pair&lt;Int, Int&gt;</code> .  As can be seen from the implementation of the Pair class of the standard library, it is marked with the data modifier, which means that, among other things, in this class we get the generated componentN methods.  Let's talk about them. </p><br><p>  For any class, we can define the componentN operator, which will provide access to one of the object properties.  This means that calling the point.component1 method is equivalent to calling point.first.  Now let's see why this duplication is needed. </p><br><p>  What is a multi-declaration?  This is a way to "decompose" an object into variables.  Thanks to this functionality, we can write the following construction: </p><br><pre> <code class="hljs lisp">val (<span class="hljs-name"><span class="hljs-name">x</span></span>, y) = Point(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br><p>  We have the opportunity to declare several variables at once, but what will be as values?  For this we need the generated methods <code>componentN</code> , in accordance with the sequence number, instead of N, starting from 1, we can decompose an object into a set of its properties.  So, for example, a record above is equivalent to the following: </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pair = <span class="hljs-type"><span class="hljs-type">Point</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = pair.component1() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y = pair.component2()</code> </pre> <br><p>  which in turn is equivalent to: </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pair = <span class="hljs-type"><span class="hljs-type">Point</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = pair.first <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y = pair.second</code> </pre> <br><p>  where first and second are properties of the Point object. </p><br><p>  The for construction in Kotlin has the following form, where x sequentially takes the values ‚Äã‚Äã1, 2 and 3: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-function"><span class="hljs-function">x </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listOf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span></span><span class="hljs-function">))</span></span> { ‚Ä¶ }</code> </pre> <br><p>  Note the <code>assertions</code> block in DSL from the main example.  For convenience, I will provide part of it below: </p><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ((<span class="hljs-built_in"><span class="hljs-built_in">day</span></span>, lesson, student, teacher) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> scheduledEvents) { ‚Ä¶ }</code> </pre> <br><p>  Now everything should be obvious.  We iterate through the scheduledEvents collection, each element of which is decomposed into 4 properties describing the current object. </p><br><h3 id="extension-funkcii">  Extension function </h3><br><p>  <a href="https://kotlinlang.org/docs/reference/extensions.html">Documentation</a> </p><br><p>  Adding custom methods to objects from third-party libraries or adding methods to the Java Collection Framework is a long-time dream of many developers.  And now we all have that opportunity.  The declaration of expanding functions is as follows: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> AvailabilityTable.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">monday</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, to: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">? = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> <br><p>  Unlike the usual method, we add the class name before the method name to indicate which class we are expanding.  In the example, <code>AvailabilityTable</code> is an alias for the Matrix type and, since the aliases in Kotlin are just renaming, as a result such a declaration is equivalent to the one shown in the example below, which is not always convenient: <br></p><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Matrix</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;Boolean&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">monday</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, to: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">? = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> <br><p>  But, unfortunately, nothing can be done about it, except for not using the tool or adding methods only to a specific context class.  Then magic appears only where it is needed.  Moreover, you can extend even these interfaces with these functions.  A good example would be the first method, which extends any Iterable object as follows: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Iterable</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">first</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: T</code> </pre> <br><p>  As a result, any collection based on the Iterable interface, regardless of the type of the element, receives the first method.  The interesting thing is that we can put the extension method in the context class and thus have access to the extension method only in a specific context (see the lambda with the context above).  Moreover, we can also create extension functions for Nullable types (the explanation of Nullable types is beyond the scope of the article, but you can read it <a href="https://kotlinlang.org/docs/reference/null-safety.html">here</a> if you like).  For example, the isNullOrEmpty function from the Kotlin standard library, which extends the CharSequence? Type, can be used as follows: </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> s: <span class="hljs-type"><span class="hljs-type">String</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> s.isNullOrEmpty() <span class="hljs-comment"><span class="hljs-comment">//true</span></span></code> </pre> <br><p>  The signature of this function is shown below: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> CharSequence?.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isNullOrEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span></code> </pre> <br><p>  When working from Java with such Kotlin functions, extension functions are available as static. </p><br><h3 id="infix-funkcii">  Infix functions </h3><br><p>  <a href="https://kotlinlang.org/docs/reference/functions.html">Documentation</a> </p><br><p>  Another way to add a syntax is to use infix functions.  Simply put, thanks to this tool, we were able to get rid of unnecessary code noise in simple situations. <br>  The <code>assertions</code> block from the main sample article demonstrates the use of this tool: </p><br><pre> <code class="hljs vbscript">teacherSchedule[<span class="hljs-built_in"><span class="hljs-built_in">day</span></span>, lesson] shouldNotEqual <span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre> <br><p>  Such a construction is equivalent to the following: </p><br><pre> <code class="hljs vbscript">teacherSchedule[<span class="hljs-built_in"><span class="hljs-built_in">day</span></span>, lesson].shouldNotEqual(<span class="hljs-literal"><span class="hljs-literal">null</span></span>)</code> </pre> <br><p>  There are situations when brackets and points are unnecessary.  In this case, we need the infix modifier for functions. <br>  In the code above, the <code>teacherSchedule[day, lesson]</code> construct returns a schedule element, and the function <code>shouldNotEqual</code> checks that the element is not null. </p><br><p>  To declare such a function is necessary: </p><br><ul><li>  specify the infix modifier; </li><li>  define exactly one parameter. </li></ul><br><p>  You can combine the last two tools, as in the code below: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T : Any?&gt;</span></span></span><span class="hljs-function"> T.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldNotEqual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(expected: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> <br><p>  Please note that the generic type is the default Any inheritor (non-Nullable type hierarchy), however, in such cases, we cannot use null, so you need to explicitly specify the Any? Type. </p><br><h3 id="kontrol-konteksta">  Context control </h3><br><p>  <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-dsl-marker/index.html">Documentation</a> </p><br><p>  When we use a lot of nested contexts, an explosive mixture is produced at the lowest level, so, for example, without any control, the following construction can be obtained which does not make sense: </p><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">schedule</span></span> { // <span class="hljs-type"><span class="hljs-type">SchedulingContext</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> { // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataContext</span></span></span><span class="hljs-class"> +   </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SchedulingContext</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class"> { } // -    } }</span></span></code> </pre> <br><p>  Prior to Kotlin 1.1, there was already a way to avoid this.  Create your own data method in the nested DataContext context, and then mark it with the Deprecated annotation with the ERROR level. </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataContext</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Deprecated(level = DeprecationLevel.ERROR, message = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Incorrect context"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">init</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">DataContext</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) {} }</code> </pre> <br><p>  Thanks to this approach, we could exclude the possibility of inadmissible building DSL.  However, with a large number of methods in the SchedulingContext, we received a certain amount of routine work, discouraging all the desire to control the context. </p><br><p>  In Kotlin 1.1 a new tool for control appeared - the @DslMarker annotation.  It is applied to your own annotations, which, in turn, are needed to label your contexts.  Let's create our own annotation, which we will mark with the help of a new tool in our arsenal: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@DslMarker</span></span> <span class="hljs-keyword"><span class="hljs-keyword">annotation</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomDslMarker</span></span></span></span></code> </pre> <br><p>  Then you need to mark contexts.  In our main example, these are SchedulingContext and DataContext.  Due to the fact that we mark each of the classes with a single DSL marker, the following happens: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@MyCustomDslMarker</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SchedulingContext</span></span></span><span class="hljs-class"> </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">@MyCustomDslMarker</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataContext</span></span></span><span class="hljs-class"> </span></span>{ ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">demo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { schedule { <span class="hljs-comment"><span class="hljs-comment">// SchedulingContext data { // DataContext +     SchedulingContext // data { } // , ..    DSL  } } }</span></span></code> </pre> <br><p>  Despite all the delight of this approach, which reduces a lot of time and effort, one problem remains.  If you pay attention to our main example, you will see the following code: </p><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">schedule</span></span> { <span class="hljs-section"><span class="hljs-section">data</span></span> { <span class="hljs-section"><span class="hljs-section">student</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">name</span></span> = <span class="hljs-string"><span class="hljs-string">"Petrov"</span></span> } ... } }</code> </pre> <br><p>                Student, ,  ,  ,  ,       @MyCustomDslMarker    , ,   ,  . </p><br><p>   Student  <code>data {}</code>    , ..  DataContext   ,     : </p><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">schedule</span></span> { <span class="hljs-section"><span class="hljs-section">data</span></span> { <span class="hljs-section"><span class="hljs-section">student</span></span> { <span class="hljs-section"><span class="hljs-section">student</span></span> { } } } }</code> </pre> <br><p>       ,         ,        .   : </p><br><ol><li>      , , StudentContext.         @DslMarker. </li><li>     , , IStudent (   ),  -,   ,     ,     . <br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@MyCustomDslMarker</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StudentContext</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> owner: Student = Student()): IStudent <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> owner</code> </pre> </li><li>   @Deprecated,    .   , ,   ,   . <br>   deprecated extension    Identifiable . </li></ol><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Deprecated(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Incorrect context"</span></span></span><span class="hljs-meta">, level = DeprecationLevel.ERROR)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Identifiable.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">student</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">init</span></span></span></span><span class="hljs-function"><span class="hljs-params">: ()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) {}</code> </pre> <br><p>  ,   ,    DSL    . </p><br><h2 id="minusy-ispolzovaniya-dsl">   DSL </h2><br><p>       DSL  Kotlin  ,      DSL   . </p><br><h3 id="pereispolzovanie-chasti-dsl">   DSL </h3><br><p> ,       DSL,           .              DSL  extension ,       . </p><br><p> ,    ,        :  " callback'",   DSL,   .   ,         ,      . ,          DSL    ,    . </p><br><h3 id="this-it"> This, it!? </h3><br><p>      this  it      DSL.   -  it,     ,  ,        ,    .    ,    . </p><br><p>       ,      .       "  "             DSL. ,         , , <code>val mainContext = this</code> </p><br><h3 id="vlozhennost">  Nesting </h3><br><p>          .             .   ,     ,    ,    " ",   . ,     DSL,    ,   ,  DSL     ,   - .     DSL (,      ),   , ..    . </p><br><h3 id="gde-doki-zin">  , ? </h3><br><p>   -    DSL,      : " ?".        .    DSL,      ,      .     ,      .    , ..  -    : "   ,   ?" ,   ,          . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>     ,        - .         ,   . </p><br><p> ,  -  , ,         .  ,  DSL  .     ,     ,    . </p><br><p>  " ",     ,  DSL  ,  ,   ,    ,    . <br>     - ! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/341402/">https://habr.com/ru/post/341402/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../341390/index.html">Bid optimization: the relationship between the cost per click and the set rate</a></li>
<li><a href="../341392/index.html">HEIF - a new standard format for storing images in iOS and MacOS</a></li>
<li><a href="../341394/index.html">Announcement of Moscow Spark # 3</a></li>
<li><a href="../341398/index.html">Money monoid</a></li>
<li><a href="../341400/index.html">Cryptopolicy: law enforcement agencies on blockchain technology</a></li>
<li><a href="../341404/index.html">On the development of a single desktop application in Python</a></li>
<li><a href="../341406/index.html">Dataset: associations to the words and expressions of the Russian language</a></li>
<li><a href="../341408/index.html">Pediatric Bone Age Challenge. Deep learning and many, many bones</a></li>
<li><a href="../341410/index.html">B2BX: the economy of ICO and the main areas of expenditure of investors' money B2BX</a></li>
<li><a href="../341426/index.html">Reactive brain waves: a story about Muse, JS and browsers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>