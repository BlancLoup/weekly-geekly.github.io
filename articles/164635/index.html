<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Minicomputer from a router with OpenWRT: we write the framebuffer driver</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good afternoon, dear habrovchane. Here we come to the most interesting and important part of my series of articles about turning a small router into a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Minicomputer from a router with OpenWRT: we write the framebuffer driver</h1><div class="post__text post__text-html js-mediator-article">  Good afternoon, dear habrovchane.  Here we come to the most interesting and important part of my series of articles about turning a small router into a minicomputer - now we are going to develop a real framebuffer driver that will allow you to run different graphical applications on the router.  So that the enthusiasm did not fade away, here is a video of one of these applications - I think most people will recognize this magnificent old quest: <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/ipdXKPUVOVE%3Ffeature%3Doembed&amp;xid=25657,15700022,15700186,15700190,15700253,15700258&amp;usg=ALkJrhho-v8ATTsgL5SHthSqa824UzORNw" frameborder="0" allowfullscreen=""></iframe><br>  In case you missed the previous parts, here are the links: <br>  <a href="http://habrahabr.ru/post/163689/">1 - Minicomputer from a router with OpenWRT: we are developing a USB video card</a> <br>  <a href="http://habrahabr.ru/post/163861/">2 - Minicomputer from router with OpenWRT: write USB class-driver for Linux</a> <br>  So, get down to work. <br><a name="habracut"></a><br><h4>  Introduction </h4><br>  Iron has not changed again (although we will definitely change something in the firmware in the next article), so we will start with an overview of what we have to do. <br>  Despite the fact that our driver from the previous article already knows how to display graphics, it is very difficult to fully use it (for example, to display the console or launch a graphical application).  The fact is that such applications require a well-defined, standardized interface, the so-called framebuffer.  When registering a framebuffer in the system, we will need to fill in several specialized structures-descriptors, this time much more specific than the abstract ‚Äúfile operations‚Äù that we filled out last time.  Operations will also be there, but there will be special callbacks, such as <b>fb_imageblit</b> (called when someone wants to transfer a block of bits with an image to a specific place on the screen), <b>fb_copyarea</b> (similar transfer, but a block of bits is taken not from the external buffer but from video memory), etc.  In addition, there will be structures with a description of the screen resolution, the color bitness and how the color components are located in this ‚Äúbit depth‚Äù. <br><br>  The first thing to realize is that we have a somewhat unusual situation when compared with PC video cards (although it‚Äôs quite usual for embedded devices) - our device doesn‚Äôt have any video memory as such, which we could access - more precisely, it has memory the same GRAM, hidden in the depths of the display, but we only have access to it through the ‚Äúwindow‚Äù of 16 bits wide.  The memory on board is also not enough to store the entire frame buffer there. <br>  Fortunately, Linux has a special approach for this - functions with the prefix " <b>sys_</b> " are already written for us, for example, " <b>sys_imageblit</b> ", which implement the functionality required by the framebuffer, working with the system memory as a frame buffer. <br>  That is, if the frame buffer is located in the video card and we have hardware support for such operations, we simply kick our piece of hardware in the callbacks, giving the command ‚Äúexecute block bit transfer‚Äù or ‚Äúcopy the video memory area‚Äù. <br>  If we don‚Äôt have this, we allocate memory in the kernel that is equal to our frame buffer, and in callbacks we call these same functions with the prefix " <b>sys_</b> " that perform the necessary operations in RAM. <br>  Thus, you can get a fully working framebuffer, which will not interact with iron at all - such a driver already exists and it is called vfb, virtual framebuffer.  Its source code is in <a href="">drivers / video / vfb.c.</a> <br>  If we add a periodic data transfer to a real device to such a driver, we will get a real framebuffer driver.  But before we do this, let's build a little of our system and practice on the virtual driver, <b>vfb</b> . <br><br><h4>  Enable graphics support in the kernel. </h4><br>  I was busy with this part for a long time, mainly because I first wrote my driver and then tried to understand why I only have a black screen - I sinned on my own errors in the code.  Then I guessed to install the VFB driver instead, having read the contents of the memory of which I saw the same black screen.  Then I finally realized that the matter is not in the driver, but in the fact that the kernel itself refuses to display information on it, after which the problem was resolved rather quickly.  But first things first. <br><ol><li>  In order for us to see the console output in the framebuffer's memory (well, on the screen if it is real and not virtual) <b>two</b> drivers are needed - this is, in fact, the driver of the framebuffer itself, which will create the <b>/ dev / fb [x]</b> device and the console driver running on top of it is the <b>fbcon</b> driver </li><li>  In the core, respectively, <b>support for framebuffers</b> , <b>support for virtual terminals</b> (an abstraction combining an output device + input device, a display and a keyboard), <b>support for displaying the system console</b> on such terminals (yes, this can also be disabled, then the system console output only to physically existing character devices like com-ports), the <b>fbcon driver itself</b> , as well <b>as some of the available fonts available to it</b> . </li><li>  The very point that I missed at the beginning when I couldn‚Äôt understand why nothing is output - you need to tell the kernel that you need to output the contents of the system console to that <b>/ dev / tty [x]</b> that fbcon <b>captured</b> ! <br>  The fact is that the <b>fbcon</b> driver tries to capture the first available <b>/ dev / tty [x]</b> , for example, <b>tty0</b> .  But the kernel does not bring anything there, it is an abstraction that is not tied to anything, because  neither the application allowing to log in to the system, nor the output of the system console are running on it. <br>  In order to solve this problem, we must first tell the kernel that we want to see the system console on <b>/ dev / tty0</b> (however, this is optional, if suddenly someone does not want to see the boot process and system output, then this item can be omitted ), and secondly, inform Inita that there you need to run the software for the login </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now we will do all three points regarding the virtual framebuffer driver, and when we get the picture in memory, we will proceed to write our own.  <b>fbcon</b> and the framebuffer driver can be either statically biased, or both as plug-ins, or one static one, the other dynamically - this will not cause problems, <b>fbcon will</b> catch the framebuffer as soon as it sees it. <br>  However, when working with vfb, there is one subtlety - in order to activate it, you need to transfer the <b>vfb_enable = 1</b> parameter to the module, or start the kernel with the " <b>video = vfb</b> " parameter.  It will be easier to work with the module, so we will limit ourselves to it.  <b>fbcon</b> is built into the core. <br><br><ol><li>  <b>Run make kernel_menuconfig</b> and go to the item Device Drivers </li><li>  We turn on <b>Graphics Support - Support for frame buffer devices</b> , after which we get a list of the drivers themselves, in which we select the <b>Virtual framebuffer</b> . </li><li>  Go back up, go to <b>Character devices</b> and turn it on <br><br>  <b>Virtual terminal</b> <b><br></b>  <b>Enable character translations in console</b> <b><br></b>  <b>Support for console on virtual terminal</b> <b><br></b>  <b>Support for binding and unbinding console drivers</b> <br><br>  Thanks to the last two options, we will be able to bring the system console to a virtual terminal, and then, if you wish, unpin it from the framebuffer driver, which will allow it to be unloaded from memory. </li><li>  Go back to <b>Graphics Support</b> , go to the <b>Console display driver support</b> menu that has become available and enable <b>Framebuffer Console support</b> , then activate the <b>Select compiled-in fonts</b> item and select a font there - say, <b>VGA 8x8 font</b> </li><li>  We exit to the main menu and pay attention to the <b>Kernel Hacking</b> item - if you go in there, you can find, near the end of the list, the item containing the kernel boot options.  In general, they are transferred to the kernel by a boot-loder, but you can add a parameter string using this item, or redefine it altogether.  We will not redefine, but we will add - we will add, because  The bootloader sends the <b>console = ttyATH0</b> parameter to it, which means outputting the system console to the serial port.  Unfortunately, we cannot do this right here - this parameter will be overridden when applying platform-specific patches, so we‚Äôll go there.  Do not touch anything here, save the config and exit. </li><li> Go to where, as we remember, are stored platform-specific files and patches - <b>target / linux / ar71xx /</b> .  Go to <b>generic</b> and open the file <b>config-default</b> .  In it, we see a single line, the same parameter that was seen in the kernel configuration: <br>  <i>CONFIG_CMDLINE = "rootfstype = squashfs, jffs2 noinitrd"</i> <br>  append to the end <b>console = tty0</b> and <b>fbcon = font: &lt;font name&gt;</b> , setting the font name to one of those selected in the kernel configuration.  We get something like <br>  <i>CONFIG_CMDLINE = "rootfstype = squashfs, jffs2 noinitrd console = tty0 fbcon = font: ProFont6x11"</i> <br></li></ol><br><br>  The last thing we need to do before rebuilding is to go to <b>make menuconfig</b> and include the fbset utility in the capabilities provided by <b>busybox</b> , which will allow us to set the parameters of our framebuffer.  It is located in the menu <b>Base System - Busybox - Linux SyStem Utilities</b> <br><br>  Now you can rebuild the kernel.  In <b>build_dir / target-mips_r2_uClibc-0.9.33.2 / linux-ar71xx_generic / linux-3.6.9 / dri</b> <b><br></b>  <b>vers / video /</b> <b><br></b>  we take away that with the <b>.ko</b> extension <br>  Contrary to expectations, it will not be there alone; turning on a driver that uses functions with the prefix " <b>sys_</b> " activates the assembly of several modules in which these same functions lie.  Interestingly, in principle, nothing prevents them from being statically added to the kernel, leaving the driver as a plug-in, but I could not do this from the menu, I had to write the corresponding patch to the Kconfig file.  But we will do this later, but for now just rewrite the router with a new firmware and transfer all modules to it. <br><br>  After we go through SSH to the router and go <b>/ etc.</b>  Open the inittab file and see there is something like this: <br><br><pre><code class="bash hljs">::sysinit:/etc/init.d/rcS S boot ::shutdown:/etc/init.d/rcS K shutdown ttyATH0::askfirst:/bin/ash --login</code> </pre> <br>  The last line just says that you need to run the software for the login (in this case, like all system binaries - part of the busybox) on ttyATH0, the serial port.  It is indicated (askfirst) that to activate this console, you will first need to press enter. <br>  Add one more line: <br><br><pre> <code class="bash hljs">tty0::respawn:/bin/ash --login</code> </pre><br>  Let's see if the kernel parameters are correctly specified through <br><br><pre> <code class="bash hljs">cat /proc/cmdline</code> </pre><br>  and reboot the router. <br>  Now let's take turns insmodim everything except the vfb driver, and at the very end we write <br><br><pre> <code class="bash hljs">insmod vfb.ko vfb_enable=1</code> </pre><br><br>  After that, we should see words like these in the dmesg: <i>Console: switching to color frame buffer device 53x21</i> <br>  Console sizes will vary depending on the font selected.  Set the framebuffer options, more similar to the parameters of our display: <br><br><pre> <code class="bash hljs">fbset -g 320 240 320 240 16</code> </pre><br>  This will set the visible and virtual resolution to 320x240 (most often they are the same, but in principle, you can set the virtual resolution to more visible, getting the frame buffer to more output and use this for double buffering), and the color depth to 16 bits. <br>  <b>fbcon</b> should respond to this by changing its permission and sending a message to dmesg, but if this didn‚Äôt happen, disconnect the console from the framebuffer and reconnect: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"0"</span></span> &gt; /sys/class/vtconsole/vtcon1/<span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"1"</span></span> &gt; /sys/class/vtconsole/vtcon1/<span class="hljs-built_in"><span class="hljs-built_in">bind</span></span></code> </pre><br>  This is a useful pair of commands that will come in handy for us many times - without this, do not unload the framebuffer driver,  he will be busy with the console. <br>  It doesn‚Äôt hurt to connect a keyboard to the router - you can blindly enter the <b>clear</b> and <b>dmesg</b> commands to make sure that there is something on the virtual display. <br>  After we get a "screenshot" with the command <br><br><pre> <code class="bash hljs">cat /dev/fb0 &gt; scrn.raw</code> </pre><br>  And download it to the desktop.  There we open via GIMP or any other software that can load raw graphic data in the RGB565 format - set the image size to 320x240, don't forget about the bit depth, and get a picture like this (the message about opening and closing <b>/ dev / fb0</b> gives my driver, t. I didn‚Äôt take a screenshot from a virtual framebuffer. A virtual one is silent about such cases): <br><img src="https://habrastorage.org/storage2/6cd/597/28d/6cd59728d74b170209ca32a595beb6c5.jpg"><br>  Notice the beautiful, ‚Äúhacker‚Äù green color of the console?  In fact, this tells us about an error, more precisely, about one particular feature to be reckoned with.  But we'll talk about that later.  Before moving on to the main step ‚Äî writing your own framebuffer driver ‚Äî let's compare the available console fonts.  For this, I prepared six photos, three for the console and for Midnight Commander with 4x4, 6x11 and 8x8 fonts.  In my opinion, the most convenient is 6x11: <br><br><img src="https://habrastorage.org/storage2/4c4/688/68b/4c468868bff45459f3883809e40826d1.jpg"><br>  <i>4x4</i> <br><br><img src="https://habrastorage.org/storage2/fdb/2e0/8dd/fdb2e08dd9e3d5d4ab0e51c20467d361.jpg"><br>  <i>6x11</i> <br><br><img src="https://habrastorage.org/storage2/a53/10a/e78/a5310ae78bc2c5397113536f99af2cea.jpg"><br>  <i>8x8</i> <br><br><img src="https://habrastorage.org/storage2/daf/76c/a30/daf76ca30392b36b5a4e16fcf18e0c10.jpg"><br>  <i>4x4</i> <br><br><img src="https://habrastorage.org/storage2/a42/f32/62f/a42f3262f26c6ff17b9500327c35d3fb.jpg"><br>  <i>6x11</i> <br><br><img src="https://habrastorage.org/storage2/96c/063/615/96c063615626efc3613a03e9364ca852.jpg"><br>  <i>8x8</i> <br><br><h4>  We write the framebuffer driver </h4><br>  For a start - about the approach.  An obvious and not very good solution would be to periodically update the entire screen - one could start a timer that would throw the entire contents of the framebuffer via USB with the commands already familiar to us from the previous article.  However, there is a far more correct solution, the so-called deferred io. <br>  Its essence is simple: we only need to specify the callback function, set the time interval and register this deferred io for our framebuffer.  When registering, virtual memory will be configured so that accessing the frame buffer memory will cause an exception that puts our callback in the queue for processing at the interval we set.  In this case, the write to memory will not be interrupted!  And when the callback is called, a list of pages that have been changed will be transferred to it.  Isn't it very convenient?  Yuzerspeys can safely write to the video memory without thinking about anything and without interrupting, while our callback will periodically twitch with a list of memory pages that have been changed - we will only need to throw on the device, not the entire buffer. <br><br>  Since the release of the framebuffer is not as simple as it seems at first glance (the USB device may already be absent, but the clients themselves will not let go of the framebuffer yet and it‚Äôs impossible to clean the memory at this moment) <b><i>Todo</i></b> and vow to promise to implement the correct cleaning and disabling the device a little bit later, but for now let's write everything else to finally see the fruit of our actions.  Normal cleaning, along with finishing the video card firmware (which will raise the FPS at least twice), we will definitely consider in the next article. <br><br>  Let's start with a simple one - since we will receive a list of pages to which we have been recorded, the easiest way is to save in advance the coordinates on the screen corresponding to the top of the page, as well as a pointer to the corresponding memory area.  Therefore, we will create a structure with these fields, without forgetting to add an atomic flag indicating whether this page needs an update.  This is necessary because  internal framebuffer operations that are performed through functions with the " <b>sys_</b> " prefix do not call our handler <b>deferred io</b> , so we will need to manually calculate which pages were accessed and mark them as updateable. <br><br><div class="spoiler">  <b class="spoiler_title">Memory page structure</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">videopage</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *mem; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> length; <span class="hljs-keyword"><span class="hljs-keyword">atomic_t</span></span> toUpdate; };</code> </pre><br></div></div><br>  Here everything is transparent, the only thing that - keep the length, because  The last page may be incomplete - we don‚Äôt need to send extra data to the display. <br>  Let's declare several defines related to the size of the display - the number of pixels per page, the number of pages in the framebuffer, etc. <br>  <b>PAGE_SIZE is</b> defined for us in the kernel source. <br><br><div class="spoiler">  <b class="spoiler_title">Auxiliary Defines</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIDTH 320 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HEIGHT 240 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BYTE_DEPTH 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FB_SIZE WIDTH*HEIGHT*BYTE_DEPTH #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FP_PAGE_COUNT PAGE_ALIGN(FB_SIZE)/PAGE_SIZE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIXELS_IN_PAGE PAGE_SIZE/BYTE_DEPTH</span></span></code> </pre><br></div></div><br>  We declare the required callbacks of framebuffer operations and the callback handler of our <b>deferred io</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Kolbeki</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">display_fillrect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct fb_info *p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct fb_fillrect *rect)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">display_imageblit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct fb_info *p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct fb_image *image)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">display_copyarea</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct fb_info *p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct fb_copyarea *area)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ssize_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">display_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct fb_info *p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">loff_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ppos)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">display_setcolreg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> regno, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> red, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> green, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> blue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> transp, struct fb_info *info)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//--------------- static void display_update(struct fb_info *info, struct list_head *pagelist);</span></span></code> </pre><br></div></div><br>  Next comes a structure with unchangeable display information. <br><br><div class="spoiler">  <b class="spoiler_title">Fb_fix_screeninfo structure</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fb_fix_screeninfo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fixed_info</span></span></span><span class="hljs-class"> = {</span></span> .id = <span class="hljs-string"><span class="hljs-string">"STM32LCD"</span></span>, .type = FB_TYPE_PACKED_PIXELS, .visual = FB_VISUAL_TRUECOLOR, .accel = FB_ACCEL_NONE, .line_length = WIDTH * BYTE_DEPTH, };</code> </pre><br></div></div><br>  Everything is also simple - we set the string ID of our display, the type of pixels - others do not interest us, we have the most common bitmap, the color is truecolor, at least close to it and certainly not monochrome or direct color. <br>  Next comes a more interesting structure with (potentially) variable information.  But since we will not implement the possibility of changing the resolution, for us it will be as constant as in the previous structure. <br><br><div class="spoiler">  <b class="spoiler_title">Fb_var_screeninfo structure</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fb_var_screeninfo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var_info</span></span></span><span class="hljs-class"> = {</span></span> .xres = WIDTH, .yres = HEIGHT, .xres_virtual = WIDTH, .yres_virtual = HEIGHT, .width = WIDTH, .height = HEIGHT, .bits_per_pixel = <span class="hljs-number"><span class="hljs-number">16</span></span>, .red = {<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, .green = {<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, .blue = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, .activate = FB_ACTIVATE_NOW, .vmode = FB_VMODE_NONINTERLACED, };</code> </pre><br></div></div><br>  Here we see the visible and virtual resolutions already familiar to <b>fbset</b> , the physical dimensions of the display in millimeters (you can set, in principle, any, I set the same as its resolution), the image bit depth, and - important structures - descriptors of how color components are in bytes.  In them, the first value is the offset, the second is the length in bits and the third is the flag, the "significant bit to the right." <br>  The last to declare is the deferred I / O structure, <b>deferred io</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Fb_deferred_io structure</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fb_deferred_io</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">display_defio</span></span></span><span class="hljs-class"> = {</span></span> .delay = HZ/<span class="hljs-number"><span class="hljs-number">6</span></span>, .deferred_io = &amp;display_update, };</code> </pre><br></div></div><br>  The choice of the period value, the <b>.delay</b> field, the task, for the most part, is empirical - if you choose too small a value, the update will occur less frequently than the hardware allows, if you choose too large - the queue of pending jobs will be clogged.  Our display is currently more than slow, and this is determined entirely by USB, and not by output to the screen.  In the implementation of the first article, full screen redrawing is possible with a frequency of no higher than 3.6 FPS.  But do not despair - firstly, we will not always redraw the entire screen, and secondly, in the next article, I will show how to squeeze the most out of the hardware we have, so the FPS will jump to ~ 8 - taking into account the incomplete redrawing we get a completely usable device, as in the video at the beginning of the article.  These 9 FPS, by the way, are the physical limit that we can get on Full Speed ‚Äã‚ÄãUSB when transferring raw video data (without compression).  This becomes obvious if we recall the FS USB transfer rate limit - 12 Mbit / s.  Our frame occupies 320 * 240 * 16 = 1 228 800 bits.  Thus, the ideal spherical frame rate in vacuum will be no higher than 9.8 FPS.  From here we will throw away our headers, losses in our driver, losses in the driver of the host controller, losses in the driver on STM, and we will get a real limit of 8-9 FPS, which is quite good to achieve.  But we will do this in the next article, and now we remember that our frequency is about 3.5 FPS, and, according to my measurements, the period is approximately twice as long, that is, 6-7 Hz, turned out to be optimal.  This is what we ask, using the predefined definition in the <b>HZ</b> kernel source.  By the way, you should pay attention - despite the name, this macro does not determine the frequency of 1 Hz, but the corresponding period (in nuclear quanta), therefore, to obtain a frequency of 6 Hz, it should not be multiplied, but divided by six. <br>  Finally, fill the structure with callbacks of the framebuffer operations. <br><br><div class="spoiler">  <b class="spoiler_title">Fb_ops structure</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fb_ops</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">display_fbops</span></span></span><span class="hljs-class"> = {</span></span> .owner = THIS_MODULE, .fb_read = fb_sys_read, .fb_write = display_write, .fb_fillrect = display_fillrect, .fb_copyarea = display_copyarea, .fb_imageblit = display_imageblit, .fb_setcolreg = display_setcolreg, };</code> </pre><br></div></div><br>  We'll immediately write a callback from those that are " <b>sys_</b> " for <b>reading</b> , we have nothing to do there.  In all the rest we will need to still mark the corresponding pages for the update, so we indicate our own. <br>  The structure-descriptor of our device has not changed much since the time of the previous article, we will describe it. <br><br><div class="spoiler">  <b class="spoiler_title">Usblcd handle structure</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usblcd</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usb_device</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">udev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usb_interface</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">device</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gdev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fb_info</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">info</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usb_endpoint_descriptor</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bulk_out_ep</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bulk_out_packet_size; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">videopage</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">videopages</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FP_PAGE_COUNT</span></span></span><span class="hljs-class">];</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> pseudo_palette[<span class="hljs-number"><span class="hljs-number">17</span></span>]; };</code> </pre><br></div></div><br>  An array of our video memory page handles has been added to it.  Generally, it is not recommended to statically place large amounts of data in the kernel, but the structure itself is small, and by the number there are only 38, therefore, in order not to fool around with extra pointers, we leave this array static, 760 bytes or so the core will master it. <br>  The last field, <b>pseudo_palette,</b> is the space for the pseudo-palette that <b>fbcon</b> requires.  It is filled in .fb_setcolreg <b>callback</b> , without which <b>fbcon</b> refuses to work.  In all the firewood that I have seen, this callback looks like copy-paste from the example frame file from the kernel sources, so we will not reinvent the wheel either, especially since nobody seems to be <b>using</b> this <b>fbcon</b> .  Let's start with it. <br><br><div class="spoiler">  <b class="spoiler_title">Callback display_setcolreg</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNVT_TOHW(val,width) ((((val)</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt;(width))+0x7FFF-(val))&gt;&gt;16) static int display_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, struct fb_info *info) { int ret = 1; if (info-&gt;var.grayscale) red = green = blue = (19595 * red + 38470 * green + 7471 * blue) &gt;&gt; 16; switch (info-&gt;fix.visual) { case FB_VISUAL_TRUECOLOR: if (regno &lt; 16) { u32 *pal = info-&gt;pseudo_palette; u32 value; red = CNVT_TOHW(red, info-&gt;var.red.length); green = CNVT_TOHW(green, info-&gt;var.green.length); blue = CNVT_TOHW(blue, info-&gt;var.blue.length); transp = CNVT_TOHW(transp, info-&gt;var.transp.length); value = (red &lt;&lt; info-&gt;var.red.offset) | (green &lt;&lt; info-&gt;var.green.offset) | (blue &lt;&lt; info-&gt;var.blue.offset) | (transp &lt;&lt; info-&gt;var.transp.offset); pal[regno] = value; ret = 0; } break; case FB_VISUAL_STATIC_PSEUDOCOLOR: case FB_VISUAL_PSEUDOCOLOR: break; } return ret; }</span></span></span></span></code> </pre><br></div></div><br>  This, as I said, is the standard code for such a callback, including the macro CNVT_TOHW, which is used to get the values ‚Äã‚Äãof the color components.  It is also dragged from the driver to the driver - it is not entirely clear why it will not be included in the main header file <b>fb.h in the end</b> . <br>  The task of this callback is to fill in a 16-color pseudo-palette, to which the already mentioned console driver will apply. <br>  Now we will declare a small function, to which we will transfer, in essence, a rectangle, in the region of which the video memory was affected.  The function will calculate which pages of video memory are affected by this rectangle, will give them the ‚Äúrequired update‚Äù flag and will schedule the execution of the same callback, which is called in the case of <b>deferred io</b> .  After that, all callback operations will be reduced to calling the " <b>sys_</b> " functions and the function we wrote, which we call touch, by analogy with the Linux command. <br><br><div class="spoiler">  <b class="spoiler_title">Display_touch function</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">display_touch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct fb_info *info, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> w, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> h)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> firstPage; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastPage; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usblcd</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class">=</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">info</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">par</span></span></span><span class="hljs-class">;</span></span> firstPage=((y*WIDTH)+x)*BYTE_DEPTH/PAGE_SIZE<span class="hljs-number"><span class="hljs-number">-1</span></span>; lastPage=(((y+h)*WIDTH)+x+w)*BYTE_DEPTH/PAGE_SIZE+<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(firstPage&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>) firstPage=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(lastPage&gt;FP_PAGE_COUNT) lastPage=FP_PAGE_COUNT; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=firstPage;i&lt;lastPage;i++) atomic_dec(&amp;dev-&gt;videopages[i].toUpdate); schedule_delayed_work(&amp;info-&gt;deferred_work, info-&gt;fbdefio-&gt;delay); }</code> </pre><br></div></div><br>  The code, I think, is quite understandable - we simply calculate which pages we touched on the basis of the resolution, we always round upwards, or rather, we just take with a margin, one page at both ends. <br>  Now we will describe all the other callbacks - they become very simple: <br><br><div class="spoiler">  <b class="spoiler_title">All callback operations</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">display_fillrect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct fb_info *p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct fb_fillrect *rect)</span></span></span><span class="hljs-function"> </span></span>{ sys_fillrect(p, rect); display_touch(p, rect-&gt;dx, rect-&gt;dy, rect-&gt;width, rect-&gt;height); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">display_imageblit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct fb_info *p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct fb_image *image)</span></span></span><span class="hljs-function"> </span></span>{ sys_imageblit(p, image); display_touch(p, image-&gt;dx, image-&gt;dy, image-&gt;width, image-&gt;height); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">display_copyarea</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct fb_info *p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct fb_copyarea *area)</span></span></span><span class="hljs-function"> </span></span>{ sys_copyarea(p, area); display_touch(p, area-&gt;dx, area-&gt;dy, area-&gt;width, area-&gt;height); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ssize_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">display_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct fb_info *p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">loff_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ppos)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> retval; retval=fb_sys_write(p, buf, count, ppos); display_touch(p, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, p-&gt;var.xres, p-&gt;var.yres); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retval; }</code> </pre><br></div></div><br>  Now we finally describe our callback from <b>deferred io</b> , which will send information to the display.  It will largely coincide with the .write <b>callback</b> from the previous article.  We will write to the display through the pages, not forgetting to attribute, as in the previous article, the required heading to them.  Thanks to our <b>videopage</b> structure, the x, y coordinates and lengths are already calculated, so all you need to do is just stuff it into the buffer and drop it over USB. <br><br><div class="spoiler">  <b class="spoiler_title">Callback delayed I / O</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> videobuffer[PAGE_SIZE+<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">display_update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct fb_info *info, struct list_head *pagelist)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usblcd</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">info</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">par</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> retval; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">page</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">page</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> usbSent=<span class="hljs-number"><span class="hljs-number">0</span></span>; list_for_each_entry(page, pagelist, lru) { atomic_dec(&amp;dev-&gt;videopages[page-&gt;index].toUpdate); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;FP_PAGE_COUNT; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(atomic_inc_and_test(&amp;dev-&gt;videopages[i].toUpdate)) atomic_dec(&amp;dev-&gt;videopages[i].toUpdate); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { *(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>*)(videobuffer)=cpu_to_le16(dev-&gt;videopages[i].x); *(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>*)(videobuffer+<span class="hljs-number"><span class="hljs-number">2</span></span>)=cpu_to_le16(dev-&gt;videopages[i].y); *(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*)(videobuffer+<span class="hljs-number"><span class="hljs-number">4</span></span>)=cpu_to_le32(dev-&gt;videopages[i].length&gt;&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(videobuffer+<span class="hljs-number"><span class="hljs-number">8</span></span>,dev-&gt;videopages[i].mem,dev-&gt;videopages[i].length); retval = usb_bulk_msg(dev-&gt;udev, usb_sndbulkpipe(dev-&gt;udev, <span class="hljs-number"><span class="hljs-number">1</span></span>),videobuffer, dev-&gt;videopages[i].length+<span class="hljs-number"><span class="hljs-number">8</span></span>, &amp;usbSent, HZ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retval) printk(KERN_INFO <span class="hljs-string"><span class="hljs-string">"usblcd: sending error!\n"</span></span>); } } }</code> </pre><br></div></div><br>  Since we can get into this callback honestly (via <b>deferrd io</b> ), but we can get it on our own initiative (by planning to perform it in one of the callback operations, calling display_touch), we will simply run through all the pages transmitted to us, if any. mark them up for update. <br>  If we got here not through delayed I / O, the list will simply be empty. <br>  After that, we simply go through all the pages, atomically checking the need for an update and performing this update by synchronous sending via USB.  In the next article, when we finish the driver to a normal state, we will replace the synchronous parcel with a more correct mechanism, called USB Request Block, or URB.  It will allow the USB host to send a request to send data and immediately return to further processing.  And the fact that the URB flew (or did not fly) to the recipient will tell us in the interrupt.  This will allow us to squeeze a little more FPS from our system (without, however, exceeding the theoretical limit, which I mentioned above). <br>  We have just a little bit left - since we decided to do badly and not clean up after ourselves, all that remains is to initialize everything in the Probe callback. <br><br><div class="spoiler">  <b class="spoiler_title">Callback Probe</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LCDProbe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct usb_interface *interface, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct usb_device_id *id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usblcd</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usb_host_interface</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iface_desc</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usb_endpoint_descriptor</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">endpoint</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *videomemory; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> retval = -ENODEV; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; dev_info(&amp;interface-&gt;dev, <span class="hljs-string"><span class="hljs-string">"USB STM32-based LCD module connected"</span></span>); dev = kzalloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*dev), GFP_KERNEL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dev) { dev_err(&amp;interface-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Can not allocate memory for device descriptor\n"</span></span>); retval = -ENOMEM; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>; } dev-&gt;udev=interface_to_usbdev(interface); dev-&gt;interface = interface; iface_desc = interface-&gt;cur_altsetting; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; iface_desc-&gt;desc.bNumEndpoints; ++i) { endpoint = &amp;iface_desc-&gt;endpoint[i].desc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(usb_endpoint_is_bulk_out(endpoint)) { dev-&gt;bulk_out_ep=endpoint; dev-&gt;bulk_out_packet_size = le16_to_cpu(endpoint-&gt;wMaxPacketSize); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!dev-&gt;bulk_out_ep) { dev_err(&amp;interface-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Can not find bulk-out endpoint!\n"</span></span>); retval = -EIO; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error_dev; } dev-&gt;gdev = &amp;dev-&gt;udev-&gt;dev; dev-&gt;info = framebuffer_alloc(<span class="hljs-number"><span class="hljs-number">0</span></span>, dev-&gt;gdev); dev-&gt;info-&gt;par = dev; dev-&gt;info-&gt;dev = dev-&gt;gdev; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dev-&gt;info) { dev_err(&amp;interface-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Can not allocate memory for fb_info structure\n"</span></span>); retval = -ENOMEM; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error_dev; } dev-&gt;info-&gt;fix = fixed_info; dev-&gt;info-&gt;var = var_info; dev-&gt;info-&gt;fix.smem_len=FP_PAGE_COUNT*PAGE_SIZE; dev_info(&amp;interface-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Allocating framebuffer: %d bytes [%lu pages]\n"</span></span>,dev-&gt;info-&gt;fix.smem_len,FP_PAGE_COUNT); videomemory=vmalloc(dev-&gt;info-&gt;fix.smem_len); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!videomemory) { dev_err(&amp;interface-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Can not allocate memory for framebuffer\n"</span></span>); retval = -ENOMEM; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error_dev; } dev-&gt;info-&gt;fix.smem_start =(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)(videomemory); dev-&gt;info-&gt;fbops = &amp;display_fbops; dev-&gt;info-&gt;flags = FBINFO_FLAG_DEFAULT|FBINFO_VIRTFB; dev-&gt;info-&gt;screen_base = videomemory; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)dev-&gt;info-&gt;fix.smem_start, <span class="hljs-number"><span class="hljs-number">0</span></span>, dev-&gt;info-&gt;fix.smem_len); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;FP_PAGE_COUNT;i++) { dev-&gt;videopages[i].mem=(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)(dev-&gt;info-&gt;fix.smem_start+PAGE_SIZE*i); dev-&gt;videopages[i].length=PAGE_SIZE; atomic_set(&amp;dev-&gt;videopages[i].toUpdate,<span class="hljs-number"><span class="hljs-number">-1</span></span>); dev-&gt;videopages[i].y=(((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)(PAGE_SIZE*i)&gt;&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>)/WIDTH); dev-&gt;videopages[i].x=((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)(PAGE_SIZE*i)&gt;&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>)-dev-&gt;videopages[i].y*WIDTH; } dev-&gt;videopages[FP_PAGE_COUNT<span class="hljs-number"><span class="hljs-number">-1</span></span>].length=FB_SIZE-(FP_PAGE_COUNT<span class="hljs-number"><span class="hljs-number">-1</span></span>)*PAGE_SIZE; dev-&gt;info-&gt;pseudo_palette = &amp;dev-&gt;pseudo_palette; dev-&gt;info-&gt;fbdefio=&amp;display_defio; fb_deferred_io_init(dev-&gt;info); dev_info(&amp;interface-&gt;dev, <span class="hljs-string"><span class="hljs-string">"info.fix.smem_start=%lu\ninfo.fix.smem_len=%d\ninfo.screen_size=%lu\n"</span></span>,dev-&gt;info-&gt;fix.smem_start,dev-&gt;info-&gt;fix.smem_len,dev-&gt;info-&gt;screen_size); usb_set_intfdata(interface, dev); retval = register_framebuffer(dev-&gt;info); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retval &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { dev_err(dev-&gt;gdev,<span class="hljs-string"><span class="hljs-string">"Unable to register_frambuffer\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error_buff; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; error_buff: vfree(videomemory); error_dev: kfree(dev); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retval; }</code> </pre><br></div></div><br>  Here, we first allocate memory for our device descriptor, then <i>for the structure of the</i> framebuffer descriptor, and only then - for the framebuffer itself.  Please note - <b>select</b> through <b>vmalloc</b> .  The difference from <b>kmalloc</b> is that <b>vmalloc</b> can reconfigure the virtual memory page tables, and ‚Äúcollect in pieces‚Äù the buffer we requested.  That is, for us it will look like a single block of memory, but physically it may consist of pages that are not even close together.  <b>kmalloc</b> returns memory, which physically is a single unit.  Since we are requesting a sufficiently large chunk, <b>vmalloc</b> will be a good practice. <br>  Everything, we compile, insmodim, and if everything is done correctly we see the console on the display! <br><br><h4>  Conclusion </h4><br>  In this article, we finally took this important step - from a custom device driver that was not used by the system, we went into the framework's embrace, which allowed us to tell all applications and drivers that we have a real display.  Yes, we did a little badly, not clearing the resources and not disconnecting the device, so pulling out the USB and reinstalling it on a working device is not recommended yet. <br>  But we will definitely fix it in the next article.  What do we have to do? <br><ul><li>      ,   FPS   . </li><li>   , -    (   -  ,     . , -     ?) </li><li>    ,         </li><li>      URB'    Bulk-,      </li><li>    ,     -. , ,  ,       Gobliins,  , , . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Below is another video with an old quest (no less loved by me than Gobliins), a few photos of a small graphical shell that you can easily run on your device and the console browser Elinks. </font></font><br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/9A8V1dniLlQ%3Ffeature%3Doembed&amp;xid=25657,15700022,15700186,15700190,15700253,15700258&amp;usg=ALkJrhhB0IL8lR1J02auyPDqL8Bk2pcU0A" frameborder="0" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first Kyrandia </font></font></i> <br><br><img src="https://habrastorage.org/storage2/ee3/8ce/de8/ee38cede8953ecc27444af5dbbff327a.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habr in the console browser (font VGA8x8) </font></font></i> <br><br><img src="https://habrastorage.org/storage2/1bb/43a/902/1bb43a90295b9d3d501b6e892a61070c.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The shell Gmenu2X </font></font></i> <br><br><img src="https://habrastorage.org/storage2/cab/970/d9d/cab970d9ddff072a06830daa7afe79a1.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Built-in file browser</font></font></i> <br><br><img src="https://habrastorage.org/storage2/5e6/c81/a83/5e6c81a837edca72f1ca48407f47b92b.jpg"><br>  <i>Settings</i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On this I have everything. </font><font style="vertical-align: inherit;">Successful implementation and until the next article!</font></font></div><p>Source: <a href="https://habr.com/ru/post/164635/">https://habr.com/ru/post/164635/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../164611/index.html">Unconventional use of Microsoft Reporting Services</a></li>
<li><a href="../164617/index.html">OS X - my experience</a></li>
<li><a href="../164623/index.html">Procrastination Symbolic reward system. Part 1</a></li>
<li><a href="../164625/index.html">Ways of moving computer characters (part 3)</a></li>
<li><a href="../164633/index.html">Using IronPython from Transact SQL</a></li>
<li><a href="../164639/index.html">What do they want in different countries? Google Interactive</a></li>
<li><a href="../164641/index.html">State e-mail launched in Russia</a></li>
<li><a href="../164647/index.html">What to do when IDDQD does not work?</a></li>
<li><a href="../164649/index.html">AWS Insight: Spot Instances</a></li>
<li><a href="../164655/index.html">Toshiba Satellite T2400CT - life under Windows 3.11</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>