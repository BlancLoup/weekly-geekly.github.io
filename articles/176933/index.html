<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Android NDK: OpenSL ES</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, dear habrazhiteli! 
 Recently, reading Habr, I saw an article on the Android NDK and OpenAL. And in the comments a question was asked about Ope...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Android NDK: OpenSL ES</h1><div class="post__text post__text-html js-mediator-article">  Hello, dear habrazhiteli! <br>  Recently, reading Habr, I saw <a href="http://habrahabr.ru/post/176559/">an article</a> on the Android NDK and OpenAL.  And in the comments a question was asked about OpenSL ES.  Then I had the idea to write an article about this library.  I dealt with this topic when I needed to add sounds and music to the game for Android, written in C ++, under the NDK.  The article does not claim to be complete, there will be only the basics. <br><br>  <b>Content:</b> <br><ol><li>  A brief description of the structures of OpenSL ES </li><li>  Initializing the library mechanism and creating an object to work with speakers </li><li>  PCM playback (wav) </li><li>  MP3 playback, OGG </li><li>  Conclusion </li></ol><br><a name="habracut"></a><br><h4>  1. Brief description of structures </h4><br>  Working with OpenSL ES is based on pseudo-object-oriented structures of the C language.  They are used when the project is written in C, but I want object-oriented.  In general, pseudo-object-oriented structures are the usual C structures, containing pointers to functions that, with the first argument, get pointers to the structure itself, like this in C ++, but explicitly. <br>  In OpenSL ES, there are two main types of structures described above: <br><ul><li>  <b>An object</b> (SLObjectItf) is an abstraction of a set of resources designed to perform a specific set of tasks and to store information about these resources.  When creating an object, its type is defined, which determines the range of tasks that can be solved with its help.  An object resembling an Object of the Java language can be considered a similarity of a class in C ++. </li><li>  <b>Interface</b> (SLEngineItf, SLPlayItf, SLSeekItf, etc.) is an abstraction of a set of interrelated functionality provided by a specific object.  The interface includes a variety of methods used to perform actions on an object.  The interface has a type that defines the exact list of methods supported by this interface.  An interface is defined by its identifier, which can be used in the code to refer to an interface type. </li></ul><br><br>  Simply put, objects are needed to allocate resources and get interfaces, and interfaces provide access to the capabilities of objects.  A single object can have multiple interfaces.  Depending on the device, some interfaces may not be available.  However, I did not come across this. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  2. Initializing the library mechanism and creating an object for working with speakers </h4><br>  To connect OpenSL ES to the Android NDK, simply add the lOpenSLES flag to the LOCAL_LDLIBS section of the Android.mk file: <br><pre><code class="cmake hljs">LOCAL_LDLIBS := /*...*/ -lOpenSLES</code> </pre> <br>  Headers used: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;SLES/OpenSLES.h&gt; #include &lt;SLES/OpenSLES_Android.h&gt;</span></span></span></span></code> </pre><br>  To start working with OpenSL ES, you must initialize an object of the OpenSL ES mechanism (SLObjectItf) by calling slCreateEngine, specifying that you will use the SL_IID_ENGINE interface to work with it.  This is necessary in order to be able to create other objects.  The object obtained by such a call becomes the central object for accessing the OpenSL ES API.  Next, the object must be implemented using the Realize pseudo method, which is analogous to the constructor in C ++.  The first parameter of Realize is the object itself (an analogue of this), and the second is the async flag indicating whether the object will be asynchronous. <br>  The current implementation of the Android NDK makes it possible to create only one library mechanism and up to 32 objects in general.  However, any object creation operation may fail (for example, due to a lack of system resources). <br><div class="spoiler">  <b class="spoiler_title">Initialization of the library mechanism</b> <div class="spoiler_text"><pre> <code class="hljs php">SLObjectItf engineObj; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SLInterfaceID pIDs[<span class="hljs-number"><span class="hljs-number">1</span></span>] = {SL_IID_ENGINE}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SLboolean pIDsRequired[<span class="hljs-number"><span class="hljs-number">1</span></span>] = {SL_TRUE}; SLresult result = slCreateEngine( &amp;engineObj, <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*  , NULL,     */</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* ,      */</span></span> pIDs, <span class="hljs-comment"><span class="hljs-comment">/* ID */</span></span> pIDsRequired <span class="hljs-comment"><span class="hljs-comment">/* , ,    .   SL_TRUE,    ,   ,    SL_RESULT_FEATURE_UNSUPPORTED*/</span></span> ); <span class="hljs-comment"><span class="hljs-comment">/* .   slCreateEngine   ‚Äì   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(result != SL_RESULT_SUCCESS){ LOGE(<span class="hljs-string"><span class="hljs-string">"Error after slCreateEngine"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* .      this*/</span></span> result = (*engineObj)-&gt;Realize(engineObj, SL_BOOLEAN_FALSE); <span class="hljs-comment"><span class="hljs-comment">//     /*      ,    */ if(result != SL_RESULT_SUCCESS){ LOGE("Error after Realize engineObj"); return; }</span></span></code> </pre><br></div></div><br>  Next, you need to get the interface SL_IID_ENGINE, through which we will have access to the speakers, playing music, sounds, and so on. <br><div class="spoiler">  <b class="spoiler_title">Getting the interface SL_IID_ENGINE</b> <div class="spoiler_text"><pre> <code class="cpp hljs">SLEngineItf engine; result = (*engineObj)-&gt;GetInterface( engineObj, <span class="hljs-comment"><span class="hljs-comment">/*this*/</span></span> SL_IID_ENGINE, <span class="hljs-comment"><span class="hljs-comment">/*ID */</span></span> &amp;engine <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> );</code> </pre></div></div><br>  Let us dwell on the general scheme of working with objects: <br><ul><li>  Get object by specifying desired interfaces. </li><li>  Implement it by calling <code>(*obj)-&gt;Realize(obj, async);</code> </li><li>  Get the required interfaces by calling <code>(*obj)-&gt; GetInterface (obj, ID, &amp;itf);</code> </li><li>  Work with interfaces </li><li>  Delete an object by calling <code>(*obj)-&gt;Destroy(obj);</code> </li></ul><br>  To work with speakers, create an outputMixObj object using the CreateOutputMix pseudo method of the engineObj engine interface (This just sounds scary so that the reader learns to distinguish between objects and interfaces).  We will need this object later for sound output. <br><div class="spoiler">  <b class="spoiler_title">Creating an object to work with speakers</b> <div class="spoiler_text"><pre> <code class="cpp hljs">SLObjectItf outputMixObj; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SLInterfaceID pOutputMixIDs[] = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SLboolean pOutputMixRequired[] = {}; <span class="hljs-comment"><span class="hljs-comment">/* slCreateEngine()*/</span></span> result = (*engine)-&gt;CreateOutputMix(engine, &amp;outputMixObj, <span class="hljs-number"><span class="hljs-number">0</span></span>, pOutputMixIDs, pOutputMixRequired); result = (*outputMixObj)-&gt;Realize(outputMixObj, SL_BOOLEAN_FALSE);</code> </pre></div></div><br>  SLOutputMixItf is an object representing a sound output device (speaker, headphone).  The OpenSL ES specification provides for the possibility of obtaining a list of available I / O devices, but the Android NDK implementation is not complete enough and does not support either getting the list of devices or choosing what you want (the SLAudioIODeviceCapabilitiesItf interface is officially intended for this). <br><br><h4>  3. Playing PCM (wav) </h4><br>  At once I will make a reservation that for simplification I do not use the data from the WAV header.  If desired, add support for this is fairly easy.  Here, the header is needed only to correctly determine the size of the data. <br><div class="spoiler">  <b class="spoiler_title">Work with PCM buffer</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WAVHeader</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> RIFF[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ChunkSize; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> WAVE[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> fmt[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> Subchunk1Size; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> AudioFormat; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> NumOfChan; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> SamplesPerSec; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> bytesPerSec; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> blockAlign; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> bitsPerSample; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Subchunk2ID[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> Subchunk2Size; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SoundBuffer</span></span></span><span class="hljs-class">{</span></span> WAVHeader* header; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* buffer; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length; }; <span class="hljs-comment"><span class="hljs-comment">/*   PCM    AAssetManager:*/</span></span> <span class="hljs-function"><span class="hljs-function">SoundBuffer* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadSoundFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* filename)</span></span></span></span>{ SoundBuffer* result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SoundBuffer(); AAsset* asset = AAssetManager_open(assetManager, filename, AASSET_MODE_UNKNOWN); <span class="hljs-keyword"><span class="hljs-keyword">off_t</span></span> length = AAsset_getLength(asset); result-&gt;length = length - <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(WAVHeader); result-&gt;header = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WAVHeader(); result-&gt;buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[result-&gt;length]; AAsset_read(asset, result-&gt;header, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(WAVHeader)); AAsset_read(asset, result-&gt;buffer, result-&gt;length); AAsset_close(asset); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre></div></div><br>  Now let's set up a quick buffer sound output.  To do this, use the specialized extension SLDataLocator_AndroidSimpleBufferQueue.  Also, to play music, you must fill in two structures: SLDataSource and SLDataSink, which describe the input and output of the audio channel, respectively. <br><div class="spoiler">  <b class="spoiler_title">Configure Buffered Audio Output</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*,     CreateAudioPlayer()     */</span></span> SLDataLocator_AndroidSimpleBufferQueue locatorBufferQueue = {SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE, <span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*,      wav*/</span></span> SLDataFormat_PCM formatPCM = { SL_DATAFORMAT_PCM, <span class="hljs-number"><span class="hljs-number">1</span></span>, SL_SAMPLINGRATE_44_1, SL_PCMSAMPLEFORMAT_FIXED_16, SL_PCMSAMPLEFORMAT_FIXED_16, SL_SPEAKER_FRONT_CENTER, SL_BYTEORDER_LITTLEENDIAN }; SLDataSource audioSrc = {&amp;locatorBufferQueue, &amp;formatPCM}; SLDataLocator_OutputMix locatorOutMix = {SL_DATALOCATOR_OUTPUTMIX, outputMixObj}; SLDataSink audioSnk = {&amp;locatorOutMix, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SLInterfaceID pIDs[<span class="hljs-number"><span class="hljs-number">1</span></span>] = {SL_IID_BUFFERQUEUE}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SLboolean pIDsRequired[<span class="hljs-number"><span class="hljs-number">1</span></span>] = {SL_BOOLEAN_TRUE }; <span class="hljs-comment"><span class="hljs-comment">/* */</span></span> result = (*engine)-&gt;CreateAudioPlayer(engine, &amp;playerObj, &amp;audioSrc, &amp;audioSnk, <span class="hljs-number"><span class="hljs-number">1</span></span>, pIDs, pIDsRequired); result = (*playerObj)-&gt;Realize(playerObj, SL_BOOLEAN_FALSE);</code> </pre><br>  The implementation of OpenSL ES in the Android NDK is not strict.  If any interfaces are not specified, this does not mean that they cannot be obtained.  <b>But it is better not to do so</b> .  Independently specify the SL_IID_PLAY interface above. <br><pre> <code class="cpp hljs">SLPlayItf player; result = (*playerObj)-&gt;GetInterface(playerObj, SL_IID_PLAY, &amp;player); SLBufferQueueItf bufferQueue; result = (*playerObj)-&gt;GetInterface(playerObj, SL_IID_BUFFERQUEUE, &amp;bufferQueue); result = (*player)-&gt;SetPlayState(player, SL_PLAYSTATE_PLAYING);</code> </pre></div></div><br>  In addition to SL_IID_PLAY and SL_IID_BUFFERQUEUE, you can request other interfaces, for example: <br><ul><li>  SL_IID_VOLUME for volume control </li><li>  SL_IID_MUTESOLO for managing channels (for multichannel audio only, this is indicated in the numChannels field of the SLDataFormat_PCM structure). </li><li>  SL_IID_EFFECTSEND for applying effects (by specification - only reverb effect) </li></ul><br>  etc. <br>  Call <code>(*player)-&gt;SetPlayState(player, SL_PLAYSTATE_PLAYING);</code>  we turn on the newly created player.  While the queue is empty, so you can only hear silence.  Let's put some sound in the queue. <br><div class="spoiler">  <b class="spoiler_title">Adding sound to the queue</b> <div class="spoiler_text"><pre> <code class="cpp hljs">SoundBuffer* sound = loadSoundFile(<span class="hljs-string"><span class="hljs-string">"mySound.wav"</span></span>); (*soundsBufferQueue)-&gt;Clear(bufferQueue); <span class="hljs-comment"><span class="hljs-comment">/*   ,   - .  ,  ,     */</span></span> (*soundsBufferQueue)-&gt;Enqueue(bufferQueue, sound-&gt;buffer, sound-&gt;length); <span class="hljs-comment"><span class="hljs-comment">/*     SoundBuffer,     */</span></span></code> </pre></div></div><br>  That's it, the simplest wav player is ready. <br>  It should be noted that in peak specification, the Android NDK does not support buffered output of music in formats other than PCM. <br><br><h4>  4. Playing MP3, OGG </h4><br>  The scheme described above is not suitable for playing long music files.  First of all, due to the fact that a long wav file will weigh very, very much.  It is better to use MP3 or OGG.  OpenSL ES supports streaming files out of the box.  The difference from the buffered output is also in the fact that for each music file you need to create a separate player object.  It is impossible to change the file during playback for this player. <br>  Prepare to play music: <br><div class="spoiler">  <b class="spoiler_title">Work with file decryptor</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResourseDescriptor</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> decriptor; <span class="hljs-keyword"><span class="hljs-keyword">off_t</span></span> start; <span class="hljs-keyword"><span class="hljs-keyword">off_t</span></span> length; }; <span class="hljs-comment"><span class="hljs-comment">/*  AAssetManager*/</span></span> <span class="hljs-function"><span class="hljs-function">ResourseDescriptor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadResourceDescriptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* path)</span></span></span></span>{ AAsset* asset = AAssetManager_open(assetManager, path, AASSET_MODE_UNKNOWN); ResourseDescriptor resourceDescriptor; resourceDescriptor.decriptor = AAsset_openFileDescriptor(asset, &amp;resourceDescriptor.start, &amp;resourceDescriptor.length); AAsset_close(asset); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resourceDescriptor; }</code> </pre></div></div><br><br>  Next, re-fill the SLDataSource and SLDataSink.  And create an audio player. <br><div class="spoiler">  <b class="spoiler_title">Create player</b> <div class="spoiler_text"><pre> <code class="cpp hljs">ResourseDescriptor resourceDescriptor = loadResourceDescriptor(<span class="hljs-string"><span class="hljs-string">"myMusic.mp3"</span></span>); SLDataLocator_AndroidFD locatorIn = { SL_DATALOCATOR_ANDROIDFD, resourseDescriptor.decriptor, resourseDescriptor.start, resourseDescriptor.length } SLDataFormat_MIME dataFormat = { SL_DATAFORMAT_MIME, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, SL_CONTAINERTYPE_UNSPECIFIED }; SLDataSource audioSrc = {&amp;locatorIn, &amp;dataFormat}; SLDataLocator_OutputMix dataLocatorOut = { SL_DATALOCATOR_OUTPUTMIX, outputMixObj }; SLDataSink audioSnk = {&amp;dataLocatorOut, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SLInterfaceID pIDs[<span class="hljs-number"><span class="hljs-number">2</span></span>] = {SL_IID_PLAY, SL_IID_SEEK}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SLboolean pIDsRequired[<span class="hljs-number"><span class="hljs-number">2</span></span>] = {SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE}; SLObjectItf playerObj; SLresult result = (*engine)-&gt;CreateAudioPlayer(engine, &amp;playerObj, &amp;audioSrc, &amp;audioSnk, <span class="hljs-number"><span class="hljs-number">2</span></span>, pIDs, pIDsRequired); result = (*playerObj)-&gt;Realize(playerObj, SL_BOOLEAN_FALSE);</code> </pre></div></div><br>  To describe the source data we use the MIME type, it provides automatic detection of the file type. <br>  Next we get the interfaces SL_IID_PLAY and SL_IID_SEEK.  The latter is needed to change the playback position in the file and looping.  It can be used regardless of the playback status and speed. <br><div class="spoiler">  <b class="spoiler_title">Getting Interfaces</b> <div class="spoiler_text"><pre> <code class="cpp hljs">SLPlayItf player; result = (*playerObj)-&gt;GetInterface(playerObj, SL_IID_PLAY, &amp;player); SLSeekItf seek; result = (*playerObj)-&gt;GetInterface(playerObj, SL_IID_SEEK, &amp;seek); (*seek)-&gt;SetLoop( seek, SL_BOOLEAN_TRUE, <span class="hljs-comment"><span class="hljs-comment">/* */</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*   (0 )*/</span></span> SL_TIME_UNKNOWN <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> ); (*player)-&gt;SetPlayState(player, SL_PLAYSTATE_PLAYING);</code> </pre></div></div><br>  In theory, the looping mechanism should be convenient for setting background music in the game.  In practice, between the end of the composition and its beginning 0.5-1.0 seconds passes (time for hearing, floats on different devices).  I overcame this by making some smooth fading in the middle and end in the background music.  So  the gap is not noticeable. <br>  According to the specification, various callbacks can be attached to the SLPlayItf interface.  The Android NDK feature is not supported (the method returns SL_RESULT_SUCCESS, but callbacks do not work). <br>  To stop or pause the player, you can use the SetPlayState method of the SLPlayItf interface with the SL_PLAYSTATE_STOPPED or SL_PLAYSTATE_PAUSED values, respectively.  GetPlayState method, which returns the same values, allows you to find out the status of the player. <br><br><h4>  5. Conclusion </h4><br>  The OpenSL ES API is quite rich, and besides sound reproduction, it allows recording it.  Here I will not touch the sound recording, I will only say that it exists and works quite well.  To get the data, a queue of buffers is used.  Data comes in PCM format. <br>  The library is difficult to use in cross-platform development, because  Many features are implemented using Android-specific methods.  Nevertheless, it seemed to me quite comfortable. <br>  The cons seems to be a free implementation; many things from the specification are not supported.  In addition, this API is not faster than the API available in the Android SDK. <br><br><h5>  Literature </h5><br><ol><li>  <b>Sylvain Retabouil.</b>  <b>Android NDK.</b>  <b>Development of applications for Android on C / C ++.</b> </li><li>  <b>The Khronos Group Inc.</b>  <b><a href="http://www.khronos.org/registry/sles/specs/OpenSL_ES_Specification_1.1.pdf">OpenSL ES Specification</a> .</b> </li></ol><br>  Good and more complete code samples can be found in the standard Android NDK (NativeAudio project). <br>  Anticipating questions about the need to use the Android NDK in general and OpenSL ES in particular, I will answer immediately.  Android NDK was needed on the condition of the test task from a well-known game development company (there were contests for Habr√©).  Later it turned into a challenge to me: can I finish the job well.  Smog.  OpenSL ES chose on a whim, because  I had no experience with him or with OpenAL, but for this I considered calls to Java to be an ugly solution. </div><p>Source: <a href="https://habr.com/ru/post/176933/">https://habr.com/ru/post/176933/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../176913/index.html">Highlights for upcoming US immigration reform</a></li>
<li><a href="../176915/index.html">Lexicon and pirates</a></li>
<li><a href="../176919/index.html">Creating a custom component from scratch. Part 2</a></li>
<li><a href="../176927/index.html">Best Practices for Backup Policy</a></li>
<li><a href="../176931/index.html">Speed ‚Äã‚ÄãFirefox</a></li>
<li><a href="../176935/index.html">Tunnel modeling v0.1 - pseudocode</a></li>
<li><a href="../176937/index.html">The second life of payphones</a></li>
<li><a href="../176941/index.html">New Tracks Flow</a></li>
<li><a href="../176943/index.html">The company UDOO launched a campaign on Kickstarter.com. Killer Raspberry Pi</a></li>
<li><a href="../176947/index.html">Foreman - process manager for your web applications.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>