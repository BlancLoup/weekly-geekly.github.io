<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Perspective matrices in graphic API or the devil hides in details</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At a certain point, any developer in the field of computer graphics raises the question: how do these advanced matrices work? Sometimes the answer is ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Perspective matrices in graphic API or the devil hides in details</h1><div class="post__text post__text-html js-mediator-article">  At a certain point, any developer in the field of computer graphics raises the question: how do these advanced matrices work?  Sometimes the answer is very difficult to find and, as is usually the case, the majority of developers throw this activity halfway through. <br><br>  This is not a solution!  Let's figure it out together! <br><a name="habracut"></a><br>  Let's be realistic with a practical bias and take as an experimental OpenGL version 3.3.  Starting with this version, each developer is obliged to independently implement the module of matrix operations.  Great, this is what we need.  Let's decompose ours with you a difficult task and highlight the main points.  Some facts from the OpenGL specification: <br><br><ul><li>  Matrices are stored in columns (column-major); </li><li>  Homogeneous coordinates; </li><li>  The canonical volume of clipping (CVV) in the left-side coordinate system. </li></ul><br>  There are two ways to store matrices: cool-major and row-major.  In lectures on linear algebra, the row-major scheme is used.  By and large, the representation of matrices in memory does not matter, because the matrix can always be translated into one type of representation into another by simple transposition.  And if there is no difference, then for all subsequent calculations we will use the classic row-major matrices.  When programming OpenGL, there is a small trick that allows you to abandon the transposition of matrices while maintaining the classic row-major calculations.  In the shader program, the matrix needs to be transferred as it is, and in the shader it is necessary to multiply not the vector by the matrix, but the matrix by the vector. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Homogeneous coordinates is not a very tricky system with a number of simple rules for translating the usual Cartesian coordinates into homogeneous coordinates and back.  The uniform coordinate is a [1x4] dimension row matrix.  In order to translate the Cartesian coordinate into a homogeneous coordinate, <i>x</i> , <i>y</i> and <i>z</i> must be multiplied by any real number <i>w</i> (except 0).  Next, you need to write the result in the first three components, and the last component will be equal to the factor <i>w</i> .  In other words: <br><img src="https://habrastorage.org/files/799/f3d/f08/799f3df08ff6468fb99401dbd63e5dcc.PNG" width="80">  - Cartesian coordinates <br>  <i>w</i> is a real number not equal to 0 <br><img src="https://habrastorage.org/files/dc9/9a9/8ca/dc99a98ca07143b5903b43c480ead64b.PNG" width="140">  - homogeneous coordinates <br><br>  A little trick: If <i>w</i> is equal to one, then all that is needed for translation is to transfer the components <i>x</i> , <i>y</i> and <i>z</i> and assign the unit to the last component.  That is, get the matrix row: <br><img src="https://habrastorage.org/files/adf/007/94b/adf00794bc774213a6b576030c9e4d3c.PNG" width="110"><br><br>  A few words about zero as <i>w</i> .  From the point of view of homogeneous coordinates, this is quite permissible.  Homogeneous coordinates allow you to distinguish points and vectors.  In the Cartesian coordinate system, such a separation is impossible. <br><img src="https://habrastorage.org/files/adf/007/94b/adf00794bc774213a6b576030c9e4d3c.PNG" width="110">  - point where ( <i>x, y, z</i> ) - Cartesian coordinates <br><img src="https://habrastorage.org/files/3a6/171/3ba/3a61713ba8eb447882dc8f6a059f06da.PNG" width="110">  Is a vector, where ( <i>x, y, z</i> ) is a radius vector <br><br>  The reverse translation of a vertex from homogeneous coordinates to Cartesian coordinates is carried out as follows.  All components of the matrix-row must be divided into the last component.  In other words: <br><img src="https://habrastorage.org/files/e2e/2dd/341/e2e2dd34154b47dbb596712b927febf3.PNG" width="160">  - homogeneous coordinates <br><img src="https://habrastorage.org/files/742/923/7e9/7429237e9e554348b7ea9f22ed441a15.PNG" width="160">  - Cartesian coordinates <br><br>  The main thing that you need to know is that all OpenGL algorithms for clipping and rasterization work in Cartesian coordinates, but before that, all the transformations are performed in homogeneous coordinates.  The transition from homogeneous coordinates to Cartesian coordinates is carried out by hardware. <br><br>  The canonical clipping volume or Canonic view volume (CVV) is one of the less documented parts of OpenGL.  As can be seen from fig.  1 CVV is a cube aligned along the axes with the center at the origin and the edge length equal to two.  Anything that enters the CVV area is subject to rasterization; anything outside the CVV is ignored.  Anything that partially goes beyond CVV boundaries is subject to clipping algorithms.  The most important thing to know is the CVV coordinate system is left-sided! <br><br><img src="https://habrastorage.org/files/f60/d89/9d1/f60d899d1355411da177b52504aad2f2.PNG" width="350"><br>  Fig.  1. OpenGL canonical clipping volume (CVV) <br><br>  Left side coordinate system?  How so, because in the OpenGL 1.0 specification it is clearly written that the coordinate system used is right-handed?  Let's figure it out. <br><br><img src="https://habrastorage.org/files/fd4/ebf/18c/fd4ebf18c61e47cb90e0879ab7b6a55c.PNG" width="600"><br>  Fig.  2. Coordinate systems <br><br>  As can be seen from fig.  2 coordinate systems differ only in the direction of the <i>Z</i> axis.  OpenGL 1.0 actually uses the right-hand user coordinate system.  But the CVV coordinate system and the user coordinate system are two completely different things.  Moreover, since version 3.3, there is no longer such a thing as the standard OpenGL coordinate system.  As mentioned earlier, the programmer himself implements the matrix operations module.  The formation of rotation matrices, the formation of projection matrices, the search for the inverse matrix, the multiplication of matrices is the minimum set of operations included in the module of matrix operations.  There are two logical questions.  If the volume of visibility is a cube with an edge length equal to two, then why is a scene of several thousand conventional units visible on the screen?  At what point is the translation of the user coordinate system into the CVV coordinate system.  Projection matrices - this is the essence that deals with the solution of these issues. <br><br>  The main idea of ‚Äã‚Äãthe foregoing is that the developer himself is free to choose the type of user coordinate system and must correctly describe the projection matrices.  This completes the facts about OpenGL and it was time to bring it all together. <br><br>  One of the most common and difficult to comprehend matrices is the perspective transformation matrix.  So how is it related to CVV and user coordinate system?  Why do objects become smaller with increasing distance to the observer?  In order to understand why objects decrease with increasing distance, let's look at the matrix transformations of the three-dimensional model step by step.  It is no secret that any three-dimensional model consists of a finite list of vertices that undergo matrix transformations completely independently of each other.  In order to determine the coordinate of a three-dimensional vertex on a two-dimensional monitor screen it is necessary: <br><br><ol><li>  Translate Cartesian coordinate to homogeneous coordinate; </li><li>  Multiply the uniform coordinate by the model matrix; </li><li> The result is multiplied by the species matrix; </li><li>  The result is multiplied by the projection matrix; </li><li>  Result translate from homogeneous coordinates to Cartesian coordinates. </li></ol><br>  The translation of the Cartesian coordinates into a uniform coordinate was discussed earlier.  The geometric meaning of the model matrix is ‚Äã‚Äãto translate the model from the local coordinate system into the global coordinate system.  Or, as they say, to bring the top of the model space in the world space.  Let's just say, a three-dimensional object loaded from a file is in a model space, where the coordinates are counted relative to the object itself.  Next, using the model matrix, the model is positioned, scaled, and rotated.  As a result, all the vertices of the three-dimensional model receive the actual homogeneous coordinates in the three-dimensional scene.  Model space relative to world space is local.  From the model space, the coordinates are moved to world space (from local to global).  For this, a model matrix is ‚Äã‚Äãused. <br><br>  Now go to step three.  Here begins the species space.  In this space, coordinates are counted relative to the position and orientation of the observer as if he were the center of the world.  The species space is local relative to the world space, so the coordinates should be entered into it (and not carried out, as in the previous case).  The direct matrix transformation takes the coordinates out of some space.  To reverse them in it, it is necessary to invert the matrix transformation, therefore the species transformation is described by the inverse matrix.  How to get this inverse matrix?  First we get a direct matrix of the observer.  What is characterized by an observer?  The observer is described by the coordinate in which he is located, and the vectors of the direction of view.  The observer is always looking in the direction of his local <i>Z</i> axis.  The observer can move around the scene and make turns.  In many ways, this is reminiscent of the meaning of the model matrix.  By and large, the way it is.  However, for an observer the scaling operation is meaningless, therefore, an equal sign cannot be put between the model matrix of the observer and the model matrix of a three-dimensional object.  The model matrix of the observer is the desired direct matrix.  Inverting this matrix, we get the view matrix.  In practice, this means that all vertices in global homogeneous coordinates will receive new homogeneous coordinates relative to the observer.  Accordingly, if the observer saw a certain vertex, then the value of the homogeneous <i>z</i> coordinate of the given vertex in the species space will be exactly a positive number.  If the vertex was located behind the observer, then the value of its homogeneous coordinate <i>z</i> in the species space will be exactly a negative number. <br><br>  Step four is the most interesting step.  The previous steps were considered so deliberately in detail that the reader had a complete picture of all the operands of the fourth step.  In the fourth step, homogeneous coordinates are removed from the species space into the CVV space.  Once again, the fact is underlined that all potentially visible vertices will have a positive value of a uniform <i>z</i> coordinate. <br><br>  Consider a matrix of the form: <br><br><img src="https://habrastorage.org/files/3f8/a17/83e/3f8a1783eb454b6b9953e87a6cbb9bf2.PNG" width="450"><br><br>  And a point in the homogeneous space of the observer: <br><br><img src="https://habrastorage.org/files/a1d/6ba/e13/a1d6bae139c8456791324c153eac56e5.PNG" width="140"><br><br>  We multiply the homogeneous coordinate by the matrix under consideration: <br><br><img src="https://habrastorage.org/files/0d7/cd5/923/0d7cd5923535475497783b083105deb7.PNG" width="420"><br><br>  We translate the resulting homogeneous coordinates into Cartesian coordinates: <br><br><img src="https://habrastorage.org/files/3e8/c3e/31a/3e8c3e31af33454599fee5af4ca7029d.PNG" width="280"><br><br>  Suppose there are two points in the species space with the same <i>x</i> and <i>y</i> coordinates, but different <i>z</i> coordinates.  In other words, one of the points is behind the other.  Due to perspective distortion, the observer should see both points.  Indeed, it is clear from the formula that, due to division by the <i>z</i> coordinate, compression occurs to the origin point.  The greater the value of <i>z</i> (the farther the point is from the observer), the stronger the compression.  Here is an explanation of the effect of perspective. <br><br>  The OpenGL specification says that cutting and rasterization operations are performed in Cartesian coordinates, and the process of converting homogeneous coordinates to Cartesian coordinates is performed automatically. <br><br>  The matrix (1) is the template for the matrix perspective of the projection.  As mentioned earlier, the task of the projection matrix consists of two points: setting the user coordinate system (left or right), transferring the observer's visibility to the CVV.  We derive the perspective matrix for the left-side user coordinate system. <br><br>  The projection matrix can be described using four parameters (Fig. 3): <br><ul><li>  Viewing angle in radians ( <i>fovy</i> ); </li><li>  Aspect ratio ( <i>aspect</i> ); </li><li>  Distance to the near cut-off plane ( <i>n</i> ); </li><li>  Distance to the far clipping plane ( <i>f</i> ). </li></ul><br><img src="https://habrastorage.org/files/2f3/4f8/3ad/2f34f83ad8c14c31aefb4f7c0032e9a4.PNG" width="650"><br>  Fig.  3. Perspective visibility <br><br>  Consider the projection of a point in the observer‚Äôs space onto the front cut-off face of the perspective visibility volume.  For greater clarity in Fig.  4 shows a side view.  It should also be noted that the user coordinate system coincides with the CVV coordinate system, that is, the left-side coordinate system is used everywhere. <br><br><img src="https://habrastorage.org/files/77d/db9/a21/77ddb9a211fd40669a0c2301877cccb9.PNG" width="500"><br>  Fig.  4. Projecting an arbitrary point <br><br>  Based on the properties of such triangles, the following equations are true: <br><br><img src="https://habrastorage.org/files/67a/0d3/002/67a0d300284f43e2ae7358a4acdea0d1.PNG" width="250"><br><br>  Express yÍûå and xÍûå: <br><br><img src="https://habrastorage.org/files/738/6cb/1d1/7386cb1d13f745ad8950d8cacdd26dfc.PNG" width="600"><br><br>  In principle, expressions (2) are sufficient to obtain the coordinates of the points of the projection.  However, for correct shielding of three-dimensional objects, it is necessary to know the depth of each fragment.  In other words, it is necessary to store the value of the <i>z</i> component.  This value is used in OpenGL depth tests.  In fig.  3, it can be seen that the value of <i>zÍûå is</i> not suitable as a fragment depth, because all the projections of points can have the same value of <i>zÍûå</i> .  The way out of this situation is the use of the so-called pseudo-depth. <br><br>  Pseudo Depth Properties: <br><ol><li>  The pseudo depth is calculated based on the value of <i>z</i> ; </li><li>  The closer the point is to the observer, the smaller the pseudo depth is; </li><li>  For all points lying on the front plane of the scope, the pseudo depth is -1; </li><li>  For all points lying in the far plane of the cut-off of the scope of visibility, the pseudo depth value is 1; </li><li>  All fragments that lie within the scope of visibility have a pseudo-depth value in the range [-1 1]. </li></ol><br>  Let's derive the formula by which the pseudo depth will be calculated.  As a basis, take the following expression: <br><br><img src="https://habrastorage.org/files/c1b/70b/e31/c1b70be31e8f4e4f9fb2e0f8331a6c65.PNG" width="500"><br><br>  The coefficients <i>a</i> and <i>b</i> must be calculated.  To do this, we use the properties of pseudo-depths 3 and 4. We obtain a system of two equations with two unknowns: <br><br><img src="https://habrastorage.org/files/906/4de/29d/9064de29d85147a2b0198016ed90b93f.PNG" width="500"><br><br>  Make an addition of both parts of the system and multiply the result by the product <i>fn</i> , while <i>f</i> and <i>n</i> cannot equal zero.  We get: <br><br><img src="https://habrastorage.org/files/5a8/39d/092/5a839d09245c4fcea0cacdf26657b814.PNG" width="200"><br><br>  Open the brackets and rearrange the terms so that only the part with a remains on the left and only with <i>b</i> on the right: <br><br><img src="https://habrastorage.org/files/6c0/70e/4fa/6c070e4fa1844c11b2589d384bbb3654.PNG" width="500"><br><br>  Substitute (6) into (5).  We convert the expression to a simple fraction: <br><br><img src="https://habrastorage.org/files/a57/0a2/599/a570a2599b094f558de20bb89d6cb71a.PNG" width="150"><br><br>  Multiply both sides by <i>-2fn</i> , while <i>f</i> and <i>n</i> cannot equal zero.  We give similar, regroup the terms and express <i>b</i> : <br><br><img src="https://habrastorage.org/files/0fb/831/ecf/0fb831ecfbd145cdb4f627006cd41398.PNG" width="500"><br><br>  Substitute (7) into (6) and express <i>a</i> : <br><br><img src="https://habrastorage.org/files/7f0/f8e/94a/7f0f8e94a7554d0aa84fbdca990a30f5.PNG" width="150"><br><br>  Accordingly, the components <i>a</i> and <i>b</i> are equal to: <br><br><img src="https://habrastorage.org/files/f07/881/51d/f0788151d6c94b6a811c9f5eeb9db258.PNG" width="80"><br><br>  Now we substitute the obtained coefficients into the matrix blank (1) and see what happens with the <i>z</i> coordinate for an arbitrary point in a homogeneous observer space.  The substitution is performed as follows: <br><br><img src="https://habrastorage.org/files/3a8/08c/8f5/3a808c8f561a4a859ee48d2172b4ada3.PNG" width="500"><br><br>  Let the distance to the front cut-off plane <i>n</i> be 2, and the distance to the far cut-off plane <i>f</i> be 10. Consider five points in the homogeneous observer space: <br><table border="1"><caption>  Mutual arrangement of a point and volume of visibility </caption><tbody><tr><th width="60">  Point </th><th width="110">  Value <img src="https://habrastorage.org/files/5a9/1e0/8ba/5a91e08ba299443988ede8e9663af18c.PNG" width="20"></th><th>  Description </th></tr><tr><td>  one </td><td>  one </td><td>  The point is in front of the front cut-off visibility plane.  Does not pass rasterization. </td></tr><tr><td>  2 </td><td>  2 </td><td>  The point is located on the front edge of the cut-off volume of visibility.  Pass rasterization. </td></tr><tr><td>  3 </td><td>  five </td><td>  The point is located between the front edge of the cut-off and the far edge of the cut-off volume of visibility.  Pass rasterization. </td></tr><tr><td>  four </td><td>  ten </td><td>  The point is on the far edge of the cut-off volume of visibility.  Pass rasterization. </td></tr><tr><td>  five </td><td>  20 </td><td>  The point is beyond the far edge of the cut-off visibility.  Does not pass rasterization. </td></tr></tbody></table><br><br>  Multiply all points by the matrix (8), and then translate the resulting homogeneous coordinates into Cartesian coordinates <img src="https://habrastorage.org/files/2ec/450/9c5/2ec4509c5ee8443dbd12231565cfe23c.PNG" width="20">  .  To do this, we need to calculate the values ‚Äã‚Äãof the new homogeneous components. <img src="https://habrastorage.org/files/433/8cc/413/4338cc413ea64bcb8f578321fb551652.PNG" width="20">  and <img src="https://habrastorage.org/files/1de/b0b/61b/1deb0b61bcb24058b2cc27fd82456b52.PNG" width="24">  . <br><br>  Point 1: <br><br><img src="https://habrastorage.org/files/772/b30/bcd/772b30bcdad44e5bb0703bdd845b7076.PNG" width="550"><br><br>  Point 2: <br><br><img src="https://habrastorage.org/files/1e8/bf3/28c/1e8bf328cc2242829dbf3f65951633c6.PNG" width="550"><br><br>  Point 3: <br><br><img src="https://habrastorage.org/files/bdc/474/433/bdc47443310941cc8acc7962ee378174.PNG" width="550"><br><br>  Point 4: <br><br><img src="https://habrastorage.org/files/4b8/f64/8b4/4b8f648b468745d4a116892d4fed7fc7.PNG" width="550"><br><br>  Point 5: <br><br><img src="https://habrastorage.org/files/1c8/de9/4e1/1c8de94e10fa4b3aa424b8a1907fc300.PNG" width="550"><br><br>  Note that the uniform coordinate <img src="https://habrastorage.org/files/5a9/1e0/8ba/5a91e08ba299443988ede8e9663af18c.PNG" width="20">  absolutely true positioned in the CVV, and most importantly, that now the work of the OpenGL depth test is possible, because the pseudo depth fully satisfies the requirements of the tests. <br><br>  With the <i>z</i> coordinate figured out, move on to the coordinates <i>x</i> and <i>y</i> .  As mentioned earlier, the entire prospective visibility volume should fit into the CVV.  The CVV edge length is two.  Accordingly, the height and width of the perspective visibility volume must be compressed to two conventional units. <br><br><img src="https://habrastorage.org/files/aa1/dc7/be7/aa1dc7be7f73418a8a1205ba0c563604.PNG" width="200"><br><br>  We have the <i>fovy</i> angle and the <i>aspect</i> value.  Let's express the height and width using these values. <br><br><img src="https://habrastorage.org/files/8b2/8ad/07a/8b28ad07a9bb463ba43bd0368a912156.PNG" width="400"><br>  Fig.  5. Scope of visibility <br><br>  From fig.  5 shows that: <br><br><img src="https://habrastorage.org/files/99c/9a7/429/99c9a74290bb4dcd946d61701591245d.PNG" width="350"><br><br>  Now you can get the final view of the perspective projection matrix for the user left-side coordinate system working with CVV OpenGL: <br><br><img src="https://habrastorage.org/files/41e/032/082/41e032082b374f319b00a880772a3395.PNG" width="250"><br><br>  On this output matrix is ‚Äã‚Äãcomplete. <br><br>  A few words about DirectX - the main competitor of OpenGL.  DirectX differs from OpenGL only in CVV dimensions and its positioning.  In DirectX, CVV is a rectangular parallelepiped with lengths along the <i>x</i> and <i>y</i> axes equal to two, and along the <i>z</i> axis, the length is equal to one.  The range of <i>x</i> and <i>y</i> is [-1 1], and the range of <i>z</i> is [0 1].  As for the CVV coordinate system, in DirectX, as in OpenGL, the left-sided coordinate system is used. <br><br>  To display perspective matrices for a user-defined right-side coordinate system, it is necessary to redraw Fig.  2, Fig. 3 and Fig. 4, taking into account the new direction of the <i>Z</i> axis.  Further, the calculations are completely analogous, up to a sign.  For DirectX matrices, the pseudo-depth properties 3 and 4 are modified to the range [0 1]. <br><br>  On this topic of perspective matrices can be considered closed. <br><br><h4>  Useful literature </h4><br>  1. <a href="http://www.cs.dartmouth.edu/~cs77/slides/12_pipeline.pdf">Graphics pipeline</a> <br>  2. <a href="http://en.wikipedia.org/wiki/Homogeneous_coordinates">Homogeneous coordinates</a> <br>  3. <a href="http://users.ece.gatech.edu/~lanterma/mpg11/mpglecture04f11_3dto2dproj_4up.pdf">Lanterman A. Multicore and GPU programming for videogames</a> <br>  4. <a href="http://web.cs.wpi.edu/~gogo/courses/cs543/slides/cs543_15_Projection.pdf">Lindeman RW CS 543 - Computer Graphics: Projection</a> <br>  5. <a href="https://www.opengl.org/registry/doc/glspec33.core.20100311.withchanges.pdf">Segal M., Akeley K. The OpenGL Graphics System: A Specification (Version 3.3 (Core Profile) - March 11, 2010)</a> <br>  6. <a href="http://www.songho.ca/opengl/gl_projectionmatrix.html">Song HA OpenGL Projection Matrix</a> <br>  7. <a href="https://www.opengl.org/registry/doc/GLSLangSpec.3.30.6.pdf">The OpenGL Shading Language Version 3.30</a> <br>  8. <a href="http://ogldev.atspace.co.uk/www/tutorial12/tutorial12.html">Tutorial 12 - Perspective Projection</a> <br>  9. <a href="http://cgm.computergraphics.ru/content/view/51">Ignatenko A. Homogeneous coordinates</a> <br>  10. <a href="http://sernam.ru/book_mm3d.php%3Fid%3D66">Perspective transformations</a> </div><p>Source: <a href="https://habr.com/ru/post/252771/">https://habr.com/ru/post/252771/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../252759/index.html">Creating a Windows Runtime component in Visual C ++</a></li>
<li><a href="../252761/index.html">Optimizing the ToArray and ToList methods by providing the number of elements</a></li>
<li><a href="../252763/index.html">Virtual Link Trunking (VLT) Technology for Dell Network Factories</a></li>
<li><a href="../252767/index.html">We program in a cloud: the review popular IDE</a></li>
<li><a href="../252769/index.html">Align the modal window in the center</a></li>
<li><a href="../252773/index.html">Material Design: to the moon and back</a></li>
<li><a href="../252779/index.html">e-Ticket misunderstanding</a></li>
<li><a href="../252783/index.html">Rewrite Require.js using Promise. Part 1</a></li>
<li><a href="../252785/index.html">IBM Containers now in Bluemix: we put everything on the shelves</a></li>
<li><a href="../252787/index.html">Increase page conversion in the App Store and Google Play with A / B tests</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>