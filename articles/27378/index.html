<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Automatic detection of free text language on PHP - library PHPLangautodetect</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="You know, working with a startup that is trying to create something new and unique on the market is very exciting. And not only the opening opportunit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Automatic detection of free text language on PHP - library PHPLangautodetect</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/olpictures/6c3/a4a/9db/6c3a4a9db171c8f153228e09a71669bb.png" width="150" height="150" hspace="10" vspace="10" align="left">  You know, working with a startup that is trying to create something new and unique on the market is very exciting.  And not only the opening opportunities, but also often non-trivial tasks and questions that are posed to the creators and which no one has solved before.  One of such questions just appeared before me yesterday: an arbitrary line of text is given to us, it is known that it can be two, and in some cases trilingual, that is, there is a mixed text from several languages.  It is necessary to determine for the user the language in which the text is written. <br><br>  In fact, the task is not so rare - similar functionality exists in text editors, in the PuntoSwitcher keyboard switch, and in the machine translation systems such functionality is in demand, not to mention information retrieval systems.  By the way, it was in the context of creating a specialized search engine and text classifier that such a problem appeared.  It was necessary to get such an opportunity in my own program on the PHP platform and not to use third-party services - a similar feature in the form of a web service is present in the Google Language API ( <a href="http://abrdev.com/%3Fp%3D286">in my blog I have already investigated this service</a> ), but it runs remotely and has some significant for us, the restrictions, in particular, the procedure of language identification is performed with a significant delay and is asynchronous in nature.  In addition, I really wanted to have full control over the process and be able to configure it flexibly, which, alas, is not in third-party services.  Therefore, I had to think and try to implement it on our own, but we present the result to your attention. <br><a name="habracut"></a><br><br>  First, a little theory.  Immediately it should be said that the process of automatic language detection is inaccurate and fundamentally probabilistic.  That is, the result is always given with any probability, especially for languages ‚Äã‚Äãthat have a very similar or even identical alphabet (in writing), but they are different.  At the same time, we also depend on the length of the line of the text under study - the less material we have for research, the more difficult or even impossible such a definition is.  Indeed, for statistics it is necessary to have more field for calculating parameters, and in the short line we cannot get enough material for identification, especially when analyzing languages ‚Äã‚Äãthat have basically the same alphabet.  In such a text it is banal that unique letters may simply not appear and it will be defined as a word of another language.  Therefore, the first limitation of the analysis method of the used alphabet is the length of the text - the longer it is, the more accurate the analysis.  Let me give you an example: the word " <strong>rappel</strong> ".  What language is it in?  In English?  It means "go down on the rope."  But the same word is in German!  And there it means "(sudden) insanity, an attack of rabies." 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This method has two varieties.  The variant of using the ‚Äúpercentage of use of the alphabet‚Äù uses the calculation of the number of unique symbols used in the alphabet in the text and the calculation of% of the total volume.  The second changes the number of characters from the text, which coincides with the alphabet, while some characters can fall into different alphabets and be counted in both languages. <br><br>  The second method is based on the use of pre-formed rules that establish the identity of the text using unique or grammatical language sequences of letters (for example, articles in English, letters "" and "" in Russian or "—î" in Ukrainian).  Such rules for n-grams can be developed by linguists and make it possible to more quickly and more accurately determine the language of the text, but also do not give a guaranteed result.  First you need to create them, which means you need to master the language at a sufficient level, and not so many unique characteristic sequences in different languages.  Although, if you know in advance which languages ‚Äã‚Äãyou need to define, there may be more unique combinations between them than if you use all languages.  If you only have Russian and English, then there are obviously more such letter combinations than in a pair of German-English. <br><br>  We should also dwell on the case when the words of different alphabets are mixed in the text.  For example, the names or names of companies and products may be written in the original language, most often English, but the whole sentence is formulated in Russian.  Here only the option of calculating the total number of characters that belong to the alphabet and on the basis of whose characters are more, to make decisions will help.  In the future version, the library will be able to recognize such variants and produce an array of languages ‚Äã‚Äãthat are found in the string; now it will show only the main language, the one with the most characters in the string. <br><br>  In my library, I decided to use both approaches and all possible options, allowing the flexibility to configure the algorithm to use either approach or a combination of them.  Technically, the library is very simple - one class, several methods and properties that set the parameters of the work.  Line by line it is commented in the source code, so here I will not give the whole description of the implementation, I‚Äôll dwell only on the features. <br><br>  The library works with texts in UTF-8 encoding; therefore, it requires the mb_strings module and first of all leads the resulting string to a standard form, trying to recode it, then deletes the extra characters and checks the length.  The minimum amount of text is 50 characters, the maximum is 1680, which is approximately equal to one standard A4 page. <br><br>  You can specify various detection options.  The library can use the analysis of alphabets, while looking at either the total amount of text, or the percentage of letters used in each alphabet.  The decision threshold is also adjustable, by default it is 75% (depending on the calculation, it is either 75% of the letters of the alphabet or in the text the total number of characters of this language is more than 75%).  It is also possible to use the heuristic rules to clarify the result, while you can adjust the priority - if the rule does not confirm the result of the analysis according to statistics, then it is more correct to consider the result of the rules or you should trust the statistics.  For faster work, especially on large amounts of text or a large number of languages, only rules can be used, they are usually much smaller than alphabetic characters.  By the way, the use of rules is also set up - to get the result, you can use it as a match with one of the rules, or require matching with all the rules of one language, however this applies only for long texts and there will always be an error probability. <br><br>  Returns the library after detection or false, which means that it is impossible to determine or that the language being used is not in the database.  If successful, we get an array with two letter code of the language (for example: ‚Äúen‚Äù, ‚Äúru‚Äù or ‚Äúua‚Äù), as well as additional information - the full name of the language and, as a bonus, a link to the article about the language in Wikipedia. org (of course, in the same language). <br><br>  So far, the first version of the library is able to work only with three languages ‚Äã‚Äã- English, Russian and Ukrainian, although nothing prevents to add additional alphabets and rules for working with any languages. <br><br>  Finally, one note about speed.  The fastest option will be to use only the rules, since there are always fewer of them than letters and we will use shorter cycles inside the library.  In particular, the longer the text and the more languages ‚Äã‚Äãwe have identified in the database for the search, the faster will be the option only with the rules.  Therefore, for optimization, it is best for you to limit the set of languages ‚Äã‚Äãin advance to the most probable and remove those that you do not need - this will reduce a significant number of cycles and the algorithm will run faster.  You can also remove the check and decode strings, if you are sure that your system will only have UTF-8 strings converted to the UTF-8 encoding to the algorithm input. <br><br>  <strong>Official project site</strong> : <a href="http://code.google.com/p/phplangautodetect/">http://code.google.com/p/phplangautodetect/</a> <br>  <strong>License</strong> : <a rel="nofollow" href="http://www.gnu.org/licenses/gpl.html">GNU General Public License v3</a> <br>  <strong>Author</strong> : Alexander Lozovyuk (aleks_raiden, aleks.raiden@gmail.com) <br>  <strong>Language / platform</strong> : PHP 5 (requires mb_strings module) <br>  The distribution kit includes the simplest experiment script, the <a href="http://abrdev.com/phplangdetect/">latest version online here</a> . <br><br>  Below is the source code with comments and comments on the implementation of the algorithms described above. <br><br><ol><li>  <font color="#0000ff">class</font> Lang_Auto_Detect </li><li>  { </li><li>  <font color="#008000">// main variables</font> </li><li>  <font color="#008000">// list of supported languages</font> </li><li>  <font color="#0000ff">public</font> $ lang = Array ( <font color="#A31515">'en'</font> =&gt; array ( <font color="#A31515">'English'</font> , <font color="#A31515">'http://en.wikipedia.org/wiki/English_language'</font> ), </li><li>  <font color="#A31515">'en'</font> =&gt; array ( <font color="#A31515">'Russian'</font> , <font color="#A31515">'http://ru.wikipedia.org/wiki/%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0 % B9_% D1% 8F% D0% B7% D1% 8B% D0% BA '</font> ), </li><li>  <font color="#A31515">'ua'</font> =&gt; array ( <font color="#A31515">'Ukraine'</font> , <font color="#A31515">'http://uk.wikipedia.org/wiki/%D0%A3%D0%BA%D1%80%</font> <font color="#A31515">D0%B0%D1% 97% D0% B0%</font> <font color="#A31515">D1 % 81% D1% 8C% D0% BA% D0% B0_% D0% BC% D0% BE% D0% B2% D0% B0 '</font> ) </li><li>  ); </li><li>  <font color="#008000">// threshold of sensitivity, how many% of the language symbols should be in order for it to be defined</font> </li><li>  <font color="#0000ff">public</font> $ detect_range = 75; </li><li>  <font color="#008000">// Whether to handle multilingual documents and return an array of used languages</font> </li><li>  <font color="#0000ff">public</font> $ detect_multi_lang = <font color="#0000ff">false</font> ;  <font color="#008000">// not yet implemented</font> </li><li>  <font color="#008000">// return all results and probabilities</font> </li><li>  <font color="#0000ff">public</font> $ return_all_results = <font color="#0000ff">false</font> ;  <font color="#008000">// in real use it is better to disable</font> </li><li>  <font color="#008000">// use additionally a system of rules and exceptions</font> </li><li>  <font color="#0000ff">public</font> $ use_rules = <font color="#0000ff">false</font> ; </li><li>  <font color="#008000">// apply only the rules (much faster, but the result is less likely, the more text, the more reliable)</font> </li><li>  <font color="#0000ff">public</font> $ use_rules_only = <font color="#0000ff">false</font> ; </li><li>  <font color="#008000">// priority of rules over statistics -</font> </li><li>  <font color="#0000ff">public</font> $ use_rules_priory = <font color="#0000ff">true</font> ;  <font color="#008000">// true - rules take precedence over statistics, false - statistics before rules</font> </li><li>  <font color="#008000">// search only the first rule or maximum matches?</font> </li><li>  <font color="#0000ff">public</font> $ match_all_rules = <font color="#0000ff">false</font> ;  <font color="#008000">// just one thing = all</font> </li><li>  <font color="#008000">// use% of the alphabet or the total number of characters of each alphabet</font> </li><li> <font color="#0000ff">public</font> $ use_str_len_per_lang = <font color="#0000ff">true</font> ;  <font color="#008000">// true - use the total length of the text is more priority than% of the characters of the alphabet, false - vice versa</font> </li><li></li><li>  <font color="#008000">// minimum string length for detection</font> </li><li>  <font color="#0000ff">public</font> $ min_str_len_detect = 50; </li><li>  <font color="#008000">// for normal performance, set the maximum length in characters to compare</font> </li><li>  <font color="#0000ff">public</font> $ max_str_len_detect = 1680;  <font color="#008000">//</font> </li><li></li><li></li><li>  <font color="#008000">// internal non-variable - a table of alphabets used in the definition</font> </li><li>  <font color="#0000ff">private</font> $ _langs = array ( </li><li>  <font color="#A31515">'en'</font> =&gt; array ( <font color="#A31515">'a'</font> , <font color="#A31515">'b'</font> , <font color="#A31515">'c'</font> , <font color="#A31515">'d'</font> , <font color="#A31515">'e'</font> , <font color="#A31515">'f'</font> , <font color="#A31515">'g'</font> , <font color="#A31515">'h'</font> , <font color="#A31515">'i'</font> , <font color="#A31515">'j'</font> , <font color="#A31515">'k'</font> , <font color="#A31515">'l'</font> , <font color="#A31515">'m'</font> , <font color="#A31515">'n'</font> , <font color="#A31515">'o'</font> , <font color="#A31515">'p'</font> , <font color="#A31515">'q'</font> , <font color="#A31515">'r'</font> , <font color="#A31515">'s'</font> , <font color="#A31515">' t '</font> , <font color="#A31515">' u '</font> , <font color="#A31515">' v '</font> , <font color="#A31515">' w '</font> , <font color="#A31515">' x '</font> , <font color="#A31515">' y '</font> , <font color="#A31515">' z '</font> ), </li><li>  <font color="#A31515">'ru'</font> =&gt; array ( <font color="#A31515">'a'</font> , <font color="#A31515">'b'</font> , <font color="#A31515">'c'</font> , <font color="#A31515">'d'</font> , <font color="#A31515">'d'</font> , <font color="#A31515">'e'</font> , <font color="#A31515">'e'</font> , <font color="#A31515">'f'</font> , <font color="#A31515">'s'</font> , <font color="#A31515">'u'</font> , <font color="#A31515">'d'</font> , <font color="#A31515">"k"</font> , <font color="#A31515">"l"</font> , <font color="#A31515">"m"</font> , <font color="#A31515">"n"</font> , <font color="#A31515">"o"</font> , <font color="#A31515">"n"</font> , <font color="#A31515">"p"</font> , <font color="#A31515">"c"</font> , <font color="#A31515">"t"</font> , <font color="#A31515">"y"</font> , <font color="#A31515">"f"</font> , <font color="#A31515">"x"</font> , <font color="#A31515">"</font> , <font color="#A31515">" "</font> , <font color="#A31515">" "</font> , <font color="#A31515">" "</font> , <font color="#A31515">" "</font> , <font color="#A31515">" s "</font> , <font color="#A31515">" "</font> , <font color="#A31515">" er "</font> , <font color="#A31515">" u "</font> , <font color="#A31515">" I "</font> ), </li><li>  <font color="#A31515">'ua'</font> =&gt; array ( <font color="#A31515">'a'</font> , <font color="#A31515">'b'</font> , <font color="#A31515">'c'</font> , <font color="#A31515">'d'</font> , <font color="#A31515">'“ë'</font> , <font color="#A31515">'d'</font> , <font color="#A31515">'e'</font> , <font color="#A31515">'—î'</font> , <font color="#A31515">'w'</font> , <font color="#A31515">'s'</font> , <font color="#A31515">'and'</font> , <font color="#A31515">'—ñ'</font> , <font color="#A31515">'—ó'</font> , <font color="#A31515">'y'</font> , <font color="#A31515">'k'</font> , <font color="#A31515">'l'</font> , <font color="#A31515">'m'</font> , <font color="#A31515">'n'</font> , <font color="#A31515">'o'</font> , <font color="#A31515">'p'</font> , <font color="#A31515">'p'</font> , <font color="#A31515">'s'</font> , <font color="#A31515">' t '</font> , <font color="#A31515">' y '</font> , <font color="#A31515">' f '</font> , <font color="#A31515">' x '</font> , <font color="#A31515">' c '</font> , <font color="#A31515">' h '</font> , <font color="#A31515">' sh '</font> , <font color="#A31515">' u '</font> , <font color="#A31515">' √ú '</font> , <font color="#A31515">' yu '</font> , <font color="#A31515">' I '</font> ) </li><li>  ); </li><li></li><li>  <font color="#008000">// stores the rules</font> </li><li>  <font color="#008000">// rules are characters or strings, the presence of which (any or all) automatically leads to the identification of the text</font> </li><li>  <font color="#0000ff">private</font> $ _lang_rules = array ( </li><li>  <font color="#A31515">'en'</font> =&gt; array ( <font color="#A31515">'th'</font> , <font color="#A31515">'ir'</font> ), </li><li>  <font color="#A31515">'ru'</font> =&gt; array ( <font color="#A31515">''</font> , <font color="#A31515">''</font> ), </li><li>  <font color="#A31515">'ua'</font> =&gt; array ( <font color="#A31515">'—ó'</font> , <font color="#A31515">'—î'</font> ) </li><li>  ); </li><li></li><li></li><li>  <font color="#008000">// class constructor</font> </li><li>  <font color="#0000ff">public</font> <font color="#0000ff">function</font> __construct () </li><li>  { </li><li>  <font color="#0000ff">return</font> <font color="#0000ff">true</font> ; </li><li>  } </li><li></li><li></li><li>  <font color="#008000">// preparation of the entered string for survival</font> </li><li>  <font color="#0000ff">private</font> <font color="#0000ff">function</font> _prepare_str ($ tmp_str = <font color="#0000ff">null</font> ) </li><li>  { </li><li>  <font color="#0000ff">if</font> ($ tmp_str == <font color="#0000ff">null</font> ) <font color="#0000ff">return</font> <font color="#0000ff">false</font> ;  <font color="#008000">// if nothing is passed, exit</font> </li><li></li><li>  $ tmp_str = trim ($ tmp_str); </li><li>  $ tmp_encoding = mb_detect_encoding ($ tmp_str); </li><li></li><li>  <font color="#0000ff">if</font> (mb_strlen ($ tmp_str, $ tmp_encoding)&gt; $ <font color="#0000ff">this</font> -&gt; max_str_len_detect) </li><li>  { </li><li>  <font color="#008000">// cut the length of the text, for productivity</font> </li><li>  $ tmp_str = mb_substr ($ tmp_str, 0, $ <font color="#0000ff">this</font> -&gt; max_str_len_detect, $ tmp_encoding); </li><li>  } </li><li>  <font color="#0000ff">else</font> </li><li>  <font color="#0000ff">if</font> (mb_strlen ($ tmp_str, $ tmp_encoding) &lt;= $ <font color="#0000ff">this</font> -&gt; min_str_len_detect) <font color="#0000ff">return</font> <font color="#0000ff">false</font> ; </li><li></li><li>  <font color="#008000">// convert encodings</font> </li><li>  $ tmp_str = mb_convert_encoding ($ tmp_str, <font color="#A31515">'UTF-8'</font> , $ tmp_encoding); </li><li></li><li>  <font color="#008000">// reduce everything to lower case</font> </li><li>  $ tmp_str = mb_strtolower ($ tmp_str, <font color="#A31515">'UTF-8'</font> ); </li><li></li><li>  <font color="#0000ff">return</font> $ tmp_str; </li><li>  } </li><li></li><li>  <font color="#008000">// function of determining the language according to the rules</font> </li><li>  <font color="#008000">// the rules unambiguously determine the language, but they can be :)</font> </li><li>  <font color="#0000ff">private</font> <font color="#0000ff">function</font> _detect_from_rules ($ tmp_str = <font color="#0000ff">null</font> ) </li><li>  { </li><li>  <font color="#0000ff">if</font> ($ tmp_str == <font color="#0000ff">null</font> ) <font color="#0000ff">return</font> <font color="#0000ff">false</font> ;  <font color="#008000">// if nothing is passed, exit</font> </li><li>  <font color="#0000ff">if</font> (! is_array ($ <font color="#0000ff">this</font> -&gt; _ lang_rules)) <font color="#0000ff">return</font> <font color="#0000ff">false</font> ; </li><li></li><li>  <font color="#008000">// enumerate all rules</font> </li><li>  <font color="#0000ff">foreach</font> ($ <font color="#0000ff">this</font> -&gt; _ lang_rules <font color="#0000ff">as</font> $ lang_code =&gt; $ lang_rules) </li><li>  { </li><li>  $ tmp_freq = 0; </li><li></li><li>  <font color="#0000ff">foreach</font> ($ lang_rules <font color="#0000ff">as</font> $ rule) </li><li>  { </li><li>  $ tmp_term = mb_substr_count ($ tmp_str, $ rule); </li><li></li><li>  <font color="#0000ff">if</font> ($ tmp_term&gt; 1) <font color="#008000">// i.e. a character in order 1 or more times</font> </li><li>  { </li><li>  $ tmp_freq ++;  <font color="#008000">// increase the count of the characters of the language in this line</font> </li><li>  } </li><li></li><li>  <font color="#008000">// now check</font> </li><li>  <font color="#0000ff">if</font> ($ <font color="#0000ff">this</font> -&gt; match_all_rules === <font color="#0000ff">true</font> ) </li><li>  { </li><li>  <font color="#008000">// need to match all the rules</font> </li><li>  <font color="#0000ff">if</font> ($ tmp_freq == count ($ lang_rules)) <font color="#0000ff">return</font> $ lang_code; </li><li>  } </li><li>  <font color="#0000ff">else</font> </li><li>  { </li><li>  <font color="#008000">// one is enough</font> </li><li>  <font color="#0000ff">if</font> ($ tmp_freq&gt; 0) <font color="#0000ff">return</font> $ lang_code; </li><li>  } </li><li>  } </li><li>  } </li><li></li><li>  <font color="#0000ff">return</font> <font color="#0000ff">false</font> ; </li><li>  } </li><li></li><li>  <font color="#008000">// function of determining the language on the table</font> </li><li>  <font color="#0000ff">private</font> <font color="#0000ff">function</font> _detect_from_tables ($ tmp_str = <font color="#0000ff">null</font> ) </li><li>  { </li><li>  <font color="#0000ff">if</font> ($ tmp_str == <font color="#0000ff">null</font> ) <font color="#0000ff">return</font> <font color="#0000ff">false</font> ;  <font color="#008000">// if nothing is passed, exit</font> </li><li></li><li>  <font color="#008000">// we already have to process the string for comparison before</font> </li><li>  <font color="#008000">// go through all the languages ‚Äã‚Äãand determine the probability for each</font> </li><li>  $ lang_res = array (); </li><li></li><li>  <font color="#0000ff">foreach</font> ($ <font color="#0000ff">this</font> -&gt; lang <font color="#0000ff">as</font> $ lang_code =&gt; $ lang_name) </li><li>  { </li><li>  $ lang_res [$ lang_code] = 0;  <font color="#008000">// default is 0, that is, not this language</font> </li><li></li><li>  $ tmp_freq = 0;  <font color="#008000">// character frequency of the current language</font> </li><li>  $ full_lang_symbols = 0;  <font color="#008000">// full number of characters of this language</font> </li><li></li><li>  <font color="#008000">// since the length of the string can be arbitrary, and the alphabet is the same, then loop over the alphabets</font> </li><li>  $ cur_lang = $ <font color="#0000ff">this</font> -&gt; _ langs [$ lang_code]; </li><li></li><li>  <font color="#0000ff">foreach</font> ($ cur_lang <font color="#0000ff">as</font> $ l_item) </li><li>  { </li><li>  <font color="#008000">// now see the number of occurrences of a character in a string</font> </li><li>  $ tmp_term = mb_substr_count ($ tmp_str, $ l_item); </li><li></li><li>  <font color="#0000ff">if</font> ($ tmp_term&gt; 1) <font color="#008000">// i.e. a character in order 1 or more times</font> </li><li>  { </li><li>  $ tmp_freq ++;  <font color="#008000">// increase the count of the characters of the language in this line</font> </li><li>  $ full_lang_symbols + = $ tmp_term; </li><li>  } </li><li>  } </li><li></li><li>  <font color="#0000ff">if</font> ($ <font color="#0000ff">this</font> -&gt; use_str_len_per_lang === <font color="#0000ff">true</font> ) </li><li>  { </li><li>  <font color="#008000">// use total characters</font> </li><li>  $ lang_res [$ lang_code] = $ full_lang_symbols; </li><li>  } </li><li>  <font color="#0000ff">else</font> </li><li>  <font color="#008000">// Calculate the percentage of all characters in the alphabet</font> </li><li>  $ lang_res [$ lang_code] = ceil ((100 / count ($ cur_lang)) * $ tmp_freq); </li><li></li><li>  } </li><li></li><li>  <font color="#008000">// so, now let's see what happened</font> </li><li>  arsort ($ lang_res, SORT_NUMERIC);  <font color="#008000">// sort the array first element language with greater probability</font> </li><li></li><li>  <font color="#0000ff">if</font> ($ <font color="#0000ff">this</font> -&gt; return_all_results == <font color="#0000ff">true</font> ) </li><li>  { </li><li>  <font color="#0000ff">return</font> $ lang_res;  <font color="#008000">// if all results are returned, we return, otherwise select the best one</font> </li><li>  } </li><li>  <font color="#0000ff">else</font> </li><li>  { </li><li>  <font color="#008000">// if more than the specified threshold, return the language code, otherwise - null (that is, we can not determine the language code)</font> </li><li>  $ key = key ($ lang_res); </li><li></li><li>  <font color="#0000ff">if</font> ($ lang_res [$ key]&gt; = $ <font color="#0000ff">this</font> -&gt; detect_range) </li><li>  <font color="#0000ff">return</font> $ key; </li><li>  <font color="#0000ff">else</font> </li><li>  <font color="#0000ff">return</font> <font color="#0000ff">false</font> ; </li><li>  } </li><li></li><li>  } </li><li></li><li></li><li>  <font color="#008000">// common function to determine the language</font> </li><li>  <font color="#0000ff">public</font> <font color="#0000ff">function</font> lang_detect ($ tmp_str = <font color="#0000ff">null</font> ) </li><li>  { </li><li>  <font color="#0000ff">if</font> ($ tmp_str == <font color="#0000ff">null</font> ) <font color="#0000ff">return</font> <font color="#0000ff">false</font> ;  <font color="#008000">// if nothing is passed, exit</font> </li><li></li><li>  $ tmp_str = $ <font color="#0000ff">this</font> -&gt; _ prepare_str ($ tmp_str); </li><li></li><li>  <font color="#0000ff">if</font> ($ tmp_str === <font color="#0000ff">false</font> ) <font color="#0000ff">return</font> <font color="#0000ff">false</font> ; </li><li></li><li>  <font color="#008000">// if the rules apply to the table</font> </li><li>  <font color="#0000ff">if</font> ($ <font color="#0000ff">this</font> -&gt; use_rules_only === <font color="#0000ff">true</font> ) </li><li>  { </li><li>  $ res = $ <font color="#0000ff">this</font> -&gt; _ detect_from_rules ($ tmp_str); </li><li></li><li>  <font color="#0000ff">return</font> array ($ res, $ <font color="#0000ff">this</font> -&gt; lang [$ res]); </li><li>  } </li><li>  <font color="#0000ff">else</font> </li><li>  { </li><li>  <font color="#008000">// when using tables, we can not get a full layout of the results, because disable</font> </li><li>  $ <font color="#0000ff">this</font> -&gt; return_all_results = <font color="#0000ff">false</font> ; </li><li></li><li>  $ res = $ <font color="#0000ff">this</font> -&gt; _ detect_from_tables ($ tmp_str); </li><li></li><li>  <font color="#0000ff">if</font> ($ tmp_str === <font color="#0000ff">false</font> ) <font color="#0000ff">return</font> <font color="#0000ff">false</font> ; </li><li></li><li>  <font color="#0000ff">if</font> ($ <font color="#0000ff">this</font> -&gt; use_rules === <font color="#0000ff">true</font> ) </li><li>  { </li><li>  $ res_rules = $ <font color="#0000ff">this</font> -&gt; _ detect_from_rules ($ tmp_str); </li><li></li><li>  <font color="#008000">// proceed from the priority settings of rules and statistics</font> </li><li>  <font color="#0000ff">if</font> ($ <font color="#0000ff">this</font> -&gt; use_rules_priory === <font color="#0000ff">true</font> ) </li><li>  { </li><li>  <font color="#008000">// rules are more powerful than statistics</font> </li><li>  <font color="#0000ff">return</font> array ($ res_rules, $ <font color="#0000ff">this</font> -&gt; lang [$ res_rules]); </li><li>  } </li><li>  <font color="#0000ff">else</font> </li><li>  { </li><li>  <font color="#0000ff">return</font> array ($ res, $ <font color="#0000ff">this</font> -&gt; lang [$ res]); </li><li>  } </li><li>  } </li><li>  <font color="#0000ff">else</font> </li><li>  <font color="#0000ff">return</font> array ($ res, $ <font color="#0000ff">this</font> -&gt; lang [$ res]); </li><li>  } </li><li>  } </li><li>  } </li></ol>  <font color="gray">* This source code was highlighted with <a href="http://poison.qsh.ru/"><font color="gray">Source Code Highlighter</font></a> .</font> <br><br>  <strong>PS</strong> Of course, the code does not claim perfection, and, perhaps, the network already has implementations of this functionality, which I did not find.  If you know known implementations - please let me know in the comments.  The original article <a href="http://abrdev.com/%3Fp%3D346">is posted on my blog</a> . </div><p>Source: <a href="https://habr.com/ru/post/27378/">https://habr.com/ru/post/27378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273771/index.html">Parallel calculations on CPU and GPU</a></li>
<li><a href="../273773/index.html">3D-lab for people from MIEM, sling their heads inside the prototype trace of printed circuit boards</a></li>
<li><a href="../273775/index.html">The design decision is made by the designer.</a></li>
<li><a href="../273777/index.html">How to run your own torrent search engine based on RuTracker?</a></li>
<li><a href="../273779/index.html">CLI for MarionetteJS</a></li>
<li><a href="../273783/index.html">Non-standard city for non-standard people: a guide to the architecture of Innopolis</a></li>
<li><a href="../273785/index.html">RHCSA certification: preparation and delivery experience</a></li>
<li><a href="../27379/index.html">Ru 2.0 pre-seed</a></li>
<li><a href="../273791/index.html">Embedded Hyper-V Virtualization - First Step</a></li>
<li><a href="../273793/index.html">SID change during cloning and mass deployment</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>