<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parallel fast sorting on Haskell and how hard it turned out to write</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Note Perev .: This is a translation of the story of how difficult it was to write a parallel quick sort (quicksort) on Haskell. The original article w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parallel fast sorting on Haskell and how hard it turned out to write</h1><div class="post__text post__text-html js-mediator-article">  <i>Note</i>  <i>Perev .: This is a translation of the <a href="http://flyingfrogblog.blogspot.de/2010/08/parallel-generic-quicksort-in-haskell.html">story</a> of how difficult it was to write a parallel quick sort (quicksort) on Haskell.</i>  <i>The original article was written in 2010, but it seems to me that it is still instructive and in many ways relevant.</i> <br><br>  There are many examples of how Haskel makes simple problems difficult.  Probably the most famous of them is the sieve of Eratosthenes, which is easy to write in any imperative language, but it is so difficult to write on Haskell that almost all the decisions that have been taught at universities and used in research over the past 18 years have been wrong.  Melissa O'Neill drew attention to their inconsistency in her important scientific work The <a href="http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf">Real Sieve of Eratosthenes</a> .  It provides an excellent description of what is wrong with the old approaches, and how to correct them.  Melissa‚Äôs decision was to use the priority queue to implement the sieve.  The correct solution turned out to be 10 times longer than a <a href="http://fsharpnews.blogspot.com/2010/02/sieve-of-eratosthenes.html">much simpler solution on F #</a> and as much as 100 times longer than the original disfigured Haskell algorithm. <br><a name="habracut"></a><br>  Today, quick sorting is a new sieve of Eratosthenes.  And the programmers on Haskell again bypassed the inability of the language to express this algorithm by <a href="http://www.haskell.org/haskellwiki/Introduction">disfiguring the latter</a> .  The new version is slower by orders of magnitude, but it can easily be written on Haskell. <br><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">qsort</span></span> [] = [] qsort (x:xs) = qsort (filter (&lt; x) xs) ++ [x] ++ qsort (filter (&gt;= x) xs)</code> </pre> <br>  This code is completely at odds with the essence of the present quick sort algorithm, which makes it so efficient (see <a href="http://comjnl.oxfordjournals.org/cgi/content/short/5/1/10">Tony Hoare's original</a> quick sorting <a href="http://comjnl.oxfordjournals.org/cgi/content/short/5/1/10">article in 1962</a> ).  Namely, rearranging the array without additional memory allocation [in-place partitioning using swaps]. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Faced with the challenge of writing a general purpose parallel sorting on Haskell, Jim Apple (who writes Haskell's Ph.D. at the University of California, Davis, UC Davis) launched the case by <a href="http://www.reddit.com/r/coding/comments/codqo/engineering_large_projects_in_a_functional/c0ur3li">writing the</a> following code: <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.HashTable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> H <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Array.IO <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Parallel.Strategies <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> System exch air = do tmpi &lt;- readArray ai tmpr &lt;- readArray ar writeArray ai tmpr writeArray ai tmpi bool abc = if c then a else b quicksort arr lr = if r &lt;= l then return () else do i &lt;- loop (<span class="hljs-title"><span class="hljs-title">l</span></span>-1) r =&lt;&lt; readArray arr r exch arr ir withStrategy rpar $ quicksort arr l (<span class="hljs-title"><span class="hljs-title">i</span></span>-1) quicksort arr (<span class="hljs-title"><span class="hljs-title">i</span></span>+1) r where loop ijv = do (<span class="hljs-title"><span class="hljs-title">i'</span></span>, <span class="hljs-title"><span class="hljs-title">j'</span></span>) &lt;- liftM2 (,) (<span class="hljs-title"><span class="hljs-title">find</span></span> (&gt;=<span class="hljs-title"><span class="hljs-title">v</span></span>) (+1) (<span class="hljs-title"><span class="hljs-title">i</span></span>+1)) (<span class="hljs-title"><span class="hljs-title">find</span></span> (&lt;=<span class="hljs-title"><span class="hljs-title">v</span></span>) (<span class="hljs-title"><span class="hljs-title">subtract</span></span> 1) (<span class="hljs-title"><span class="hljs-title">j</span></span>-1)) if (<span class="hljs-title"><span class="hljs-title">i'</span></span> &lt; <span class="hljs-title"><span class="hljs-title">j'</span></span>) then exch arr i' j' &gt;&gt; loop i' j' v else return i' find pfi = if i == l then return i else bool (<span class="hljs-title"><span class="hljs-title">return</span></span> <span class="hljs-title"><span class="hljs-title">i</span></span>) (<span class="hljs-title"><span class="hljs-title">find</span></span> <span class="hljs-title"><span class="hljs-title">pf</span></span> (<span class="hljs-title"><span class="hljs-title">fi</span></span>)) . p =&lt;&lt; readArray arr i main = do [testSize] &lt;- fmap (<span class="hljs-title"><span class="hljs-title">fmap</span></span> <span class="hljs-title"><span class="hljs-title">read</span></span>) getArgs arr &lt;- testPar testSize ans &lt;- readArray arr (<span class="hljs-title"><span class="hljs-title">testSize</span></span> `<span class="hljs-title"><span class="hljs-title">div</span></span>` 2) print ans testPar testSize = do x &lt;- testArray testSize quicksort x 0 (<span class="hljs-title"><span class="hljs-title">testSize</span></span> - 1) return x testArray :: Int -&gt; IO (<span class="hljs-type"><span class="hljs-type">IOArray</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-type"><span class="hljs-type">Double</span></span>) testArray testSize = do ans &lt;- newListArray (0,<span class="hljs-title"><span class="hljs-title">testSize</span></span>-1) [fromIntegral $ H.hashString $ show i | i &lt;- [1..testSize]] return ans</code> </pre><br>  This algorithm uses parallel Haskell " <a href="http://hackage.haskell.org/packages/archive/parallel/2.2.0.1/doc/html/Control-Parallel-Strategies.html">strategies</a> ".  This concept was designed to give programmers on Haskell more control over parallelization, but it turned out that <a href="http://www.haskell.org/~simonmar/papers/multicore-ghc.pdf">in the only available implementation memory flows</a> and nobody managed to get it to work in this code: Jim's solution contains a multithreading error [concurrency], due to which returns incorrect results in almost every call. <br><br>  Then Peaker proposed <a href="http://www.reddit.com/r/coding/comments/codqo/engineering_large_projects_in_a_functional/c0ur6yx">his solution</a> on Haskell: <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Array.IO <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Concurrent bool t _f True = t bool _t f False = f swap arr ij = do (<span class="hljs-title"><span class="hljs-title">iv</span></span>, <span class="hljs-title"><span class="hljs-title">jv</span></span>) &lt;- liftM2 (,) (<span class="hljs-title"><span class="hljs-title">readArray</span></span> <span class="hljs-title"><span class="hljs-title">arr</span></span> <span class="hljs-title"><span class="hljs-title">i</span></span>) (<span class="hljs-title"><span class="hljs-title">readArray</span></span> <span class="hljs-title"><span class="hljs-title">arr</span></span> <span class="hljs-title"><span class="hljs-title">j</span></span>) writeArray arr i jv writeArray arr j iv parallel fg bg = do m &lt;- newEmptyMVar forkIO (<span class="hljs-title"><span class="hljs-title">bg</span></span> &gt;&gt; <span class="hljs-title"><span class="hljs-title">putMVar</span></span> <span class="hljs-title"><span class="hljs-title">m</span></span> ()) fg &gt;&gt; takeMVar m sort arr left right = when (<span class="hljs-title"><span class="hljs-title">left</span></span> &lt; <span class="hljs-title"><span class="hljs-title">right</span></span>) $ do pivot &lt;- read right loop pivot left (<span class="hljs-title"><span class="hljs-title">right</span></span> - 1) (<span class="hljs-title"><span class="hljs-title">left</span></span> - 1) right where read = readArray arr sw = swap arr find n pred i = bool (<span class="hljs-title"><span class="hljs-title">find</span></span> <span class="hljs-title"><span class="hljs-title">n</span></span> <span class="hljs-title"><span class="hljs-title">pred</span></span> (<span class="hljs-title"><span class="hljs-title">ni</span></span>)) (<span class="hljs-title"><span class="hljs-title">return</span></span> <span class="hljs-title"><span class="hljs-title">i</span></span>) . pred i =&lt;&lt; read i move op di pivot = bool (<span class="hljs-title"><span class="hljs-title">return</span></span> <span class="hljs-title"><span class="hljs-title">op</span></span>) (<span class="hljs-title"><span class="hljs-title">sw</span></span> (<span class="hljs-title"><span class="hljs-title">d</span></span> <span class="hljs-title"><span class="hljs-title">op</span></span>) i &gt;&gt; return (<span class="hljs-title"><span class="hljs-title">d</span></span> <span class="hljs-title"><span class="hljs-title">op</span></span>)) =&lt;&lt; liftM (/=<span class="hljs-title"><span class="hljs-title">pivot</span></span>) (<span class="hljs-title"><span class="hljs-title">read</span></span> <span class="hljs-title"><span class="hljs-title">i</span></span>) loop pivot oi oj op oq = do i &lt;- find (+1) (<span class="hljs-title"><span class="hljs-title">const</span></span> (&lt;<span class="hljs-title"><span class="hljs-title">pivot</span></span>)) oi j &lt;- find (<span class="hljs-title"><span class="hljs-title">subtract</span></span> 1) (\<span class="hljs-title"><span class="hljs-title">idx</span></span> <span class="hljs-title"><span class="hljs-title">cell</span></span> -&gt; <span class="hljs-title"><span class="hljs-title">cell</span></span>&gt;<span class="hljs-title"><span class="hljs-title">pivot</span></span> &amp;&amp; <span class="hljs-title"><span class="hljs-title">idx</span></span>/=<span class="hljs-title"><span class="hljs-title">left</span></span>) oj if i &lt; j then do sw ij p &lt;- move op (+1) i pivot q &lt;- move oq (<span class="hljs-title"><span class="hljs-title">subtract</span></span> 1) j pivot loop pivot (<span class="hljs-title"><span class="hljs-title">i</span></span> + 1) (<span class="hljs-title"><span class="hljs-title">j</span></span> - 1) pq else do sw i right forM_ (<span class="hljs-title"><span class="hljs-title">zip</span></span> [<span class="hljs-title"><span class="hljs-title">left</span></span>..<span class="hljs-title"><span class="hljs-title">op</span></span>-1] [<span class="hljs-title"><span class="hljs-title">i</span></span>-1,<span class="hljs-title"><span class="hljs-title">i</span></span>-2..]) $ uncurry sw forM_ (<span class="hljs-title"><span class="hljs-title">zip</span></span> [<span class="hljs-title"><span class="hljs-title">right</span></span>-1,<span class="hljs-title"><span class="hljs-title">right</span></span>-2..<span class="hljs-title"><span class="hljs-title">oq</span></span>+1] [<span class="hljs-title"><span class="hljs-title">i</span></span>+1..]) $ uncurry sw let ni = if left &gt;= op then i + 1 else right + i - oq nj = if right-1 &lt;= oq then i - 1 else left + i - op let thresh = 1024 strat = if nj - left &lt; thresh || right - ni &lt; thresh then (&gt;&gt;) else parallel sort arr left nj `strat` sort arr ni right main = do arr &lt;- newListArray (0, 5) [3,1,7,2,4,8] getElems arr &gt;&gt;= print sort (<span class="hljs-title"><span class="hljs-title">arr</span></span> :: <span class="hljs-type"><span class="hljs-type">IOArray</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span>) 0 5 getElems arr &gt;&gt;= print</code> </pre><br>  This solution also turned out to be bugs.  First, it contains a more subtle bug of multithreading [concurrency], which leads to incorrect results only occasionally.  Picker <a href="http://www.reddit.com/r/coding/comments/codqo/engineering_large_projects_in_a_functional/c0v1bw5">fixed this bug</a> in the following code: <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> System.Time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> System.Random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Array.IO <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Concurrent <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Exception <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.List <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> L bool t _ True = t bool _ f False = f swap arr ij = do (<span class="hljs-title"><span class="hljs-title">iv</span></span>, <span class="hljs-title"><span class="hljs-title">jv</span></span>) &lt;- liftM2 (,) (<span class="hljs-title"><span class="hljs-title">readArray</span></span> <span class="hljs-title"><span class="hljs-title">arr</span></span> <span class="hljs-title"><span class="hljs-title">i</span></span>) (<span class="hljs-title"><span class="hljs-title">readArray</span></span> <span class="hljs-title"><span class="hljs-title">arr</span></span> <span class="hljs-title"><span class="hljs-title">j</span></span>) writeArray arr i jv writeArray arr j iv background task = do m &lt;- newEmptyMVar forkIO (<span class="hljs-title"><span class="hljs-title">task</span></span> &gt;&gt;= <span class="hljs-title"><span class="hljs-title">putMVar</span></span> <span class="hljs-title"><span class="hljs-title">m</span></span>) return $ takeMVar m parallel fg bg = do wait &lt;- background bg fg &gt;&gt; wait sort arr left right = when (<span class="hljs-title"><span class="hljs-title">left</span></span> &lt; <span class="hljs-title"><span class="hljs-title">right</span></span>) $ do pivot &lt;- read right loop pivot left (<span class="hljs-title"><span class="hljs-title">right</span></span> - 1) (<span class="hljs-title"><span class="hljs-title">left</span></span> - 1) right where read = readArray arr sw = swap arr find n pred i = bool (<span class="hljs-title"><span class="hljs-title">find</span></span> <span class="hljs-title"><span class="hljs-title">n</span></span> <span class="hljs-title"><span class="hljs-title">pred</span></span> (<span class="hljs-title"><span class="hljs-title">ni</span></span>)) (<span class="hljs-title"><span class="hljs-title">return</span></span> <span class="hljs-title"><span class="hljs-title">i</span></span>) . pred i =&lt;&lt; read i move op di pivot = bool (<span class="hljs-title"><span class="hljs-title">return</span></span> <span class="hljs-title"><span class="hljs-title">op</span></span>) (<span class="hljs-title"><span class="hljs-title">sw</span></span> (<span class="hljs-title"><span class="hljs-title">d</span></span> <span class="hljs-title"><span class="hljs-title">op</span></span>) i &gt;&gt; return (<span class="hljs-title"><span class="hljs-title">d</span></span> <span class="hljs-title"><span class="hljs-title">op</span></span>)) =&lt;&lt; liftM (/=<span class="hljs-title"><span class="hljs-title">pivot</span></span>) (<span class="hljs-title"><span class="hljs-title">read</span></span> <span class="hljs-title"><span class="hljs-title">i</span></span>) swapRange px x nx y ny = if px x then sw xy &gt;&gt; swapRange px (<span class="hljs-title"><span class="hljs-title">nx</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span>) nx (<span class="hljs-title"><span class="hljs-title">ny</span></span> <span class="hljs-title"><span class="hljs-title">y</span></span>) ny else return y loop pivot oi oj op oq = do i &lt;- find (+1) (<span class="hljs-title"><span class="hljs-title">const</span></span> (&lt;<span class="hljs-title"><span class="hljs-title">pivot</span></span>)) oi j &lt;- find (<span class="hljs-title"><span class="hljs-title">subtract</span></span> 1) (\<span class="hljs-title"><span class="hljs-title">idx</span></span> <span class="hljs-title"><span class="hljs-title">cell</span></span> -&gt; <span class="hljs-title"><span class="hljs-title">cell</span></span>&gt;<span class="hljs-title"><span class="hljs-title">pivot</span></span> &amp;&amp; <span class="hljs-title"><span class="hljs-title">idx</span></span>/=<span class="hljs-title"><span class="hljs-title">left</span></span>) oj if i &lt; j then do sw ij p &lt;- move op (+1) i pivot q &lt;- move oq (<span class="hljs-title"><span class="hljs-title">subtract</span></span> 1) j pivot loop pivot (<span class="hljs-title"><span class="hljs-title">i</span></span> + 1) (<span class="hljs-title"><span class="hljs-title">j</span></span> - 1) pq else do sw i right nj &lt;- swapRange (&lt;<span class="hljs-title"><span class="hljs-title">op</span></span>) left (+1) (<span class="hljs-title"><span class="hljs-title">i</span></span>-1) (<span class="hljs-title"><span class="hljs-title">subtract</span></span> 1) ni &lt;- swapRange (&gt;<span class="hljs-title"><span class="hljs-title">oq</span></span>) (<span class="hljs-title"><span class="hljs-title">right</span></span>-1) (<span class="hljs-title"><span class="hljs-title">subtract</span></span> 1) (<span class="hljs-title"><span class="hljs-title">i</span></span>+1) (+1) let thresh = 1024000 strat = if nj - left &lt; thresh || right - ni &lt; thresh then (&gt;&gt;) else parallel sort arr left nj `strat` sort arr ni right timed act = do TOD beforeSec beforeUSec &lt;- getClockTime x &lt;- act TOD afterSec afterUSec &lt;- getClockTime return (<span class="hljs-title"><span class="hljs-title">fromIntegral</span></span> (<span class="hljs-title"><span class="hljs-title">afterSec</span></span> - <span class="hljs-title"><span class="hljs-title">beforeSec</span></span>) + fromIntegral (<span class="hljs-title"><span class="hljs-title">afterUSec</span></span> - <span class="hljs-title"><span class="hljs-title">beforeUSec</span></span>) / 1000000000000, x) main = do let n = 1000000 putStrLn "Making rands" arr &lt;- newListArray (0, <span class="hljs-title"><span class="hljs-title">n</span></span>-1) =&lt;&lt; replicateM n (<span class="hljs-title"><span class="hljs-title">randomRIO</span></span> (0, 1000000) &gt;&gt;= evaluate) elems &lt;- getElems arr putStrLn "Now starting sort" (<span class="hljs-title"><span class="hljs-title">timing</span></span>, <span class="hljs-title"><span class="hljs-title">_</span></span>) &lt;- timed $ sort (<span class="hljs-title"><span class="hljs-title">arr</span></span> :: <span class="hljs-type"><span class="hljs-type">IOArray</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span>) 0 (<span class="hljs-title"><span class="hljs-title">n</span></span>-1) print . (<span class="hljs-type"><span class="hljs-type">L</span></span>.<span class="hljs-title"><span class="hljs-title">sort</span></span> <span class="hljs-title"><span class="hljs-title">elems</span></span> ==) =&lt;&lt; getElems arr putStrLn $ "Sort took " ++ show timing ++ " seconds"</code> </pre><br>  This solution really works on small input arrays, but increasing the size of the array to 1,000,000 elements leads to stack overflow.  Two attempts were made to analyze this bug, <a href="http://www.reddit.com/r/coding/comments/codqo/engineering_large_projects_in_a_functional/c0v182l">here</a> and <a href="http://www.reddit.com/r/programming/comments/bnnoh/fast_automatically_parallel_arrays_for_haskell/c0vm0w7">here</a> , but both turned out to be wrong.  In fact, this is a <a href="http://www.reddit.com/r/programming/comments/bnnoh/fast_automatically_parallel_arrays_for_haskell/c0vpw9b">bug</a> in the <a href="http://haskell.org/ghc/docs/6.12.1/html/libraries/array-0.3.0.0/Data-Array-MArray.html">getElems</a> function of the standard Haskell library, which overflows the stack on large arrays. <br><br>  Oddly enough, fixing a few more bugs, apparently, led to the implementation of the world's first parallel general sorting, written in Haskell.  Moreover, the final solution on Haskell is only about 55% slower than the equivalent solution on F #.  Be careful, this solution requires the latest version of GHC, which was released a few weeks ago ( <i>comment re: article 2010, so the reader has nothing to worry about</i> ). <br><br><h4>  First comments on the original article. </h4><br>  Ganesh Sittampalam: <br><blockquote>  Congratulations on learning how to do fork and synchronize in Haskell! </blockquote><br>  Jon Harrop (original author): <br><blockquote>  Congratulations on checking your theory that it will be "trivial" ... </blockquote></div><p>Source: <a href="https://habr.com/ru/post/317348/">https://habr.com/ru/post/317348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../317336/index.html">Scrapbook with M * CTF</a></li>
<li><a href="../317338/index.html">Set up Swashbuckle (Swagger) for WebAPI</a></li>
<li><a href="../317340/index.html">How I chose the GTD system for IT using the Wunderlist example</a></li>
<li><a href="../317344/index.html">Adizes PAEI Management Styles and Scrum Roles</a></li>
<li><a href="../317346/index.html">VulnHub 64Base Simple Solution: Boot2Root</a></li>
<li><a href="../317350/index.html">Presentations and video presentations from the VR-Today virtual reality meeting</a></li>
<li><a href="../317354/index.html">OpenWRT + OpenVPN: point bypass blocking</a></li>
<li><a href="../317356/index.html">Automatic backup of virtual machines in XenServer</a></li>
<li><a href="../317360/index.html">$ mol_atom: theory and practice of reactivity</a></li>
<li><a href="../317362/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ240 (December 5 - 11, 2016)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>