<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SQL Index Manager is a free tool for defragmenting and maintaining indexes.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For many years, working as a SQL Server DBA and doing server administration and performance optimization. In general, I wanted in my free time to do s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SQL Index Manager is a free tool for defragmenting and maintaining indexes.</h1><div class="post__text post__text-html js-mediator-article">  For many years, working as a SQL Server DBA and doing server administration and performance optimization.  In general, I wanted in my free time to do something useful for the Universe and colleagues in the workshop.  So the result was a small <a href="https://github.com/sergeysyrovatchenko/SQLIndexManager">open source</a> index maintenance for SQL Server and Azure. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/546/8b0/98e/5468b098eea90eb287427b56021c6962.png" alt="SQL Index Manager"><br><br><a name="habracut"></a><h3>  Idea </h3><br>  Sometimes people when working on their priorities may resemble a finger-type battery - a motivational charge lasts only one flash, and then everything.  And until recently, I was no exception to this life observation.  Often I was visited by ideas to create something of my own, but priorities changed and nothing came to the end. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      My work in Devart, a Kharkov company that created software for developing and administering SQL Server, MySQL and Oracle databases, had a strong influence on my motivation and professional development. <br><br>  Before coming to them, I had little idea about the specifics of creating my own product, but already in the process I gained a lot of knowledge about the internal structure of SQL Server.  For more than a year, having been engaged in optimizing requests for metadata in their product lines, I gradually began to understand which functionality is more in demand in the market. <br><br>  At a certain stage, the idea arose of making a new niche product, but due to circumstances, this idea did not take off.  At that time, for a new project, there simply wasn‚Äôt enough free resources inside the company without affecting the core business. <br><br>  Already when I was working at a new place and trying to do a project on my own, I had to constantly make some compromises.  The original idea to make a large and stuffed with features product quickly came to naught and gradually transformed into a different direction - to break the planned functionality into separate mini-tools and implement them independently from each other. <br><br>  As a result, <a href="https://github.com/sergeysyrovatchenko/SQLIndexManager"><b>SQL Index Manager was</b></a> born, a free index maintenance tool for SQL Server and Azure.  The main idea was to base commercial alternatives from RedGate and Devart companies and try to improve their functionality.  Provide both beginners and advanced users the ability to conveniently analyze and maintain indexes. <br><br><h3>  Implementation </h3><br>  In words, everything always sounds simple ... this one looked looked at a couple of motivating vidosikov, got up in the small stands and started making a cool product.  But in practice, not everything is so rosy, since there are many pitfalls when working with the sys.dm_db_index_physical_stats system table function and in combination the only place where you can get up-to-date information about index fragmentation. <br><br>  From the first days of development, there was a great opportunity to pave one's dreary way among the standard schemes and copy the already debugged logic of the competing applications, while adding a little ad-libbing.  But after analyzing the requests for metadata, I wanted to do something more optimized, which, due to the bureaucracy of large companies, would never have appeared in their products. <br><br>  When analyzing the RedGate SQL Index Manager (1.1.9.1378 - $ 155), you can see that the application uses a very simple approach: with one query, we get a list of user tables and views, and after the second query, we return a list of all indexes within the selected database. <br><br><pre><code class="1c hljs">SELECT objects.name AS tableOrViewName , objects.object_id AS tableOrViewId , schemas.name AS schemaName , CAST(ISNULL(lobs.NumLobs, <span class="hljs-number"><span class="hljs-number">0</span></span>) AS BIT) AS ContainsLobs , o.is_memory_optimized FROM sys.objects AS objects JOIN sys.schemas AS schemas ON schemas.schema_id = objects.schema_id LEFT JOIN ( SELECT object_id , COUNT(*) AS NumLobs FROM sys.columns WITH (NOLOCK) WHERE system_type_id IN (<span class="hljs-number"><span class="hljs-number">34</span></span>, <span class="hljs-number"><span class="hljs-number">35</span></span>, <span class="hljs-number"><span class="hljs-number">99</span></span>) OR max_length = -<span class="hljs-number"><span class="hljs-number">1</span></span> GROUP BY object_id ) AS lobs ON objects.object_id = lobs.object_id LEFT JOIN sys.tables AS o ON o.object_id = objects.object_id WHERE objects.type = 'U' OR objects.type = 'V' SELECT i.object_id AS tableOrViewId , i.name AS indexName , i.index_id AS indexId , i.allow_page_locks AS allowPageLocks , p.partition_number AS partitionNumber , CAST((c.numPartitions - <span class="hljs-number"><span class="hljs-number">1</span></span>) AS BIT) AS belongsToPartitionedIndex FROM sys.indexes AS i JOIN sys.partitions AS p ON p.index_id = i.index_id AND p.object_id = i.object_id JOIN ( SELECT COUNT(*) AS numPartitions , object_id , index_id FROM sys.partitions GROUP BY object_id , index_id ) AS c ON c.index_id = i.index_id AND c.object_id = i.object_id WHERE i.index_id &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> -- ignore heaps AND i.is_disabled = <span class="hljs-number"><span class="hljs-number">0</span></span> AND i.is_hypothetical = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Next, in the loop for each section of the index, a request is sent to determine its size and level of fragmentation.  At the end of the scan, indexes that weigh less than the entry threshold are dropped on the client. <br><br><pre> <code class="1c hljs">EXEC sp_executesql N' SELECT index_id, avg_fragmentation_in_percent, page_count FROM sys.dm_db_index_physical_stats(@databaseId, @objectId, @indexId, @partitionNr, NULL)' , N'@databaseId int,@objectId int,@indexId int,@partitionNr int' , @databaseId = <span class="hljs-number"><span class="hljs-number">7</span></span>, @objectId = <span class="hljs-number"><span class="hljs-number">2133582639</span></span>, @indexId = <span class="hljs-number"><span class="hljs-number">1</span></span>, @partitionNr = <span class="hljs-number"><span class="hljs-number">1</span></span> EXEC sp_executesql N' SELECT index_id, avg_fragmentation_in_percent, page_count FROM sys.dm_db_index_physical_stats(@databaseId, @objectId, @indexId, @partitionNr, NULL)' , N'@databaseId int,@objectId int,@indexId int,@partitionNr int' , @databaseId = <span class="hljs-number"><span class="hljs-number">7</span></span>, @objectId = <span class="hljs-number"><span class="hljs-number">2133582639</span></span>, @indexId = <span class="hljs-number"><span class="hljs-number">2</span></span>, @partitionNr = <span class="hljs-number"><span class="hljs-number">1</span></span> EXEC sp_executesql N' SELECT index_id, avg_fragmentation_in_percent, page_count FROM sys.dm_db_index_physical_stats(@databaseId, @objectId, @indexId, @partitionNr, NULL)' , N'@databaseId int,@objectId int,@indexId int,@partitionNr int' , @databaseId = <span class="hljs-number"><span class="hljs-number">7</span></span>, @objectId = <span class="hljs-number"><span class="hljs-number">2133582639</span></span>, @indexId = <span class="hljs-number"><span class="hljs-number">3</span></span>, @partitionNr = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  When analyzing the logic of this application, you can find many shortcomings.  For example, if you find fault with trifles, before sending a request, no checks are made on whether the current section contains lines to exclude empty sections from scanning. <br><br>  But the most acute problem is manifested in another aspect: the number of requests to the server will be approximately equal to the total number of rows from sys.partitions.  Given the fact that real databases can contain tens of thousands of sections, this nuance can lead to a huge number of similar requests to the server.  In a situation if the database is remote, then the scan time will be even longer due to the increased network delays in the execution of each, even the simplest query. <br><br>  Unlike RedGate, a similar product developed by Devart - dbForge Index Manager for SQL Server (1.10.38 - $ 99) receives information in one large query and then displays everything on the client: <br><br><pre> <code class="1c hljs">SELECT SCHEMA_NAME(o.[schema_id]) AS [schema_name] , o.name AS parent_name , o.[type] AS parent_type , i.name , i.type_desc , s.avg_fragmentation_in_percent , s.page_count , p.partition_number , p.[rows] , ISNULL(lob.is_lob_legacy, <span class="hljs-number"><span class="hljs-number">0</span></span>) AS is_lob_legacy , ISNULL(lob.is_lob, <span class="hljs-number"><span class="hljs-number">0</span></span>) AS is_lob , CASE WHEN ds.[type] = 'PS' THEN <span class="hljs-number"><span class="hljs-number">1</span></span> ELSE <span class="hljs-number"><span class="hljs-number">0</span></span> END AS is_partitioned FROM sys.dm_db_index_physical_stats(DB_ID(), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) s JOIN sys.partitions p ON s.[object_id] = p.[object_id] AND s.index_id = p.index_id AND s.partition_number = p.partition_number JOIN sys.indexes i ON i.[object_id] = s.[object_id] AND i.index_id = s.index_id LEFT JOIN ( SELECT c.[object_id] , index_id = ISNULL(i.index_id, <span class="hljs-number"><span class="hljs-number">1</span></span>) , is_lob_legacy = MAX(CASE WHEN c.system_type_id IN (<span class="hljs-number"><span class="hljs-number">34</span></span>, <span class="hljs-number"><span class="hljs-number">35</span></span>, <span class="hljs-number"><span class="hljs-number">99</span></span>) THEN <span class="hljs-number"><span class="hljs-number">1</span></span> END) , is_lob = MAX(CASE WHEN c.max_length = -<span class="hljs-number"><span class="hljs-number">1</span></span> THEN <span class="hljs-number"><span class="hljs-number">1</span></span> END) FROM sys.columns c LEFT JOIN sys.index_columns i ON c.[object_id] = i.[object_id] AND c.column_id = i.column_id AND i.index_id &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> WHERE c.system_type_id IN (<span class="hljs-number"><span class="hljs-number">34</span></span>, <span class="hljs-number"><span class="hljs-number">35</span></span>, <span class="hljs-number"><span class="hljs-number">99</span></span>) OR c.max_length = -<span class="hljs-number"><span class="hljs-number">1</span></span> GROUP BY c.[object_id], i.index_id ) lob ON lob.[object_id] = i.[object_id] AND lob.index_id = i.index_id JOIN sys.objects o ON o.[object_id] = i.[object_id] JOIN sys.data_spaces ds ON i.data_space_id = ds.data_space_id WHERE i.[type] IN (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) AND i.is_disabled = <span class="hljs-number"><span class="hljs-number">0</span></span> AND i.is_hypothetical = <span class="hljs-number"><span class="hljs-number">0</span></span> AND s.index_level = <span class="hljs-number"><span class="hljs-number">0</span></span> AND s.alloc_unit_type_desc = 'IN_ROW_DATA' AND o.[type] IN ('U', 'V')</code> </pre> <br>  The main problem with the veil of similar queries in a competing product was eliminated, but the drawbacks of this implementation are that no additional parameters are passed to the sys.dm_db_index_physical_stats function, which can limit the scanning of obviously unnecessary indexes.  In fact, this leads to obtaining information on all indices in the system and unnecessary disk loads at the scanning stage. <br><br>  It is important to note that the data obtained from sys.dm_db_index_physical_stats is not permanently cached in the buffer pool, therefore minimizing physical reads when obtaining information about index fragmentation was one of the priority tasks during development. <br><br>  After several experiments, it turned out to combine both approaches, dividing the scan into two parts.  First, the size of the sections is determined by one large query, filtering in advance those that are not included in the filtering range: <br><br><pre> <code class="1c hljs">INSERT INTO <span class="hljs-meta"><span class="hljs-meta">#AllocationUnits (ContainerID, ReservedPages, UsedPages) SELECT [container_id] , SUM([total_pages]) , SUM([used_pages]) FROM sys.allocation_units WITH(NOLOCK) GROUP BY [container_id] HAVING SUM([total_pages]) BETWEEN @MinIndexSize AND @MaxIndexSize</span></span></code> </pre> <br>  Next, we get only those sections that contain data to avoid unnecessary reads from empty indexes. <br><br><pre> <code class="1c hljs">SELECT [object_id] , [index_id] , [partition_id] , [partition_number] , [rows] , [data_compression] INTO <span class="hljs-meta"><span class="hljs-meta">#Partitions FROM sys.partitions WITH(NOLOCK) WHERE [object_id] &gt; 255 AND [rows] &gt; 0 AND [object_id] NOT IN (SELECT * FROM #ExcludeList)</span></span></code> </pre> <br>  Depending on the settings, only the types of indexes that the user wants to analyze are obtained (work with heaps, cluster / non-clustered indexes and columnistors is supported). <br><br><pre> <code class="1c hljs">INSERT INTO <span class="hljs-meta"><span class="hljs-meta">#Indexes SELECT ObjectID = i.[object_id] , IndexID = i.index_id , IndexName = i.[name] , PagesCount = a.ReservedPages , UnusedPagesCount = a.ReservedPages - a.UsedPages , PartitionNumber = p.[partition_number] , RowsCount = ISNULL(p.[rows], 0) , IndexType = i.[type] , IsAllowPageLocks = i.[allow_page_locks] , DataSpaceID = i.[data_space_id] , DataCompression = p.[data_compression] , IsUnique = i.[is_unique] , IsPK = i.[is_primary_key] , FillFactorValue = i.[fill_factor] , IsFiltered = i.[has_filter] FROM #AllocationUnits a JOIN #Partitions p ON a.ContainerID = p.[partition_id] JOIN sys.indexes i WITH(NOLOCK) ON i.[object_id] = p.[object_id] AND p.[index_id] = i.[index_id] WHERE i.[type] IN (0, 1, 2, 5, 6) AND i.[object_id] &gt; 255</span></span></code> </pre> <br>  After this, a little magic begins: for all small indices we determine the level of fragmentation by repeatedly calling the function sys.dm_db_index_physical_stats with full indication of all parameters. <br><br><pre> <code class="1c hljs">INSERT INTO <span class="hljs-meta"><span class="hljs-meta">#Fragmentation (ObjectID, IndexID, PartitionNumber, Fragmentation) SELECT i.ObjectID , i.IndexID , i.PartitionNumber , r.[avg_fragmentation_in_percent] FROM #Indexes i CROSS APPLY sys.dm_db_index_physical_stats(@DBID, i.ObjectID, i.IndexID, i.PartitionNumber, 'LIMITED') r WHERE i.PagesCount &lt;= @PreDescribeSize AND r.[index_level] = 0 AND r.[alloc_unit_type_desc] = 'IN_ROW_DATA' AND i.IndexType IN (0, 1, 2)</span></span></code> </pre> <br>  Next, we return all possible information to the client, filtering out the extra data: <br><br><pre> <code class="1c hljs">SELECT i.ObjectID , i.IndexID , i.IndexName , ObjectName = o.[name] , SchemaName = s.[name] , i.PagesCount , i.UnusedPagesCount , i.PartitionNumber , i.RowsCount , i.IndexType , i.IsAllowPageLocks , u.TotalWrites , u.TotalReads , u.TotalSeeks , u.TotalScans , u.TotalLookups , u.LastUsage , i.DataCompression , f.Fragmentation , IndexStats = STATS_DATE(i.ObjectID, i.IndexID) , IsLobLegacy = ISNULL(lob.IsLobLegacy, <span class="hljs-number"><span class="hljs-number">0</span></span>) , IsLob = ISNULL(lob.IsLob, <span class="hljs-number"><span class="hljs-number">0</span></span>) , IsSparse = CAST(CASE WHEN p.ObjectID IS <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> THEN <span class="hljs-number"><span class="hljs-number">0</span></span> ELSE <span class="hljs-number"><span class="hljs-number">1</span></span> END AS BIT) , IsPartitioned = CAST(CASE WHEN dds.[data_space_id] IS NOT <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> THEN <span class="hljs-number"><span class="hljs-number">1</span></span> ELSE <span class="hljs-number"><span class="hljs-number">0</span></span> END AS BIT) , FileGroupName = fg.[name] , i.IsUnique , i.IsPK , i.FillFactorValue , i.IsFiltered , a.IndexColumns , a.IncludedColumns FROM <span class="hljs-meta"><span class="hljs-meta">#Indexes i JOIN sys.objects o WITH(NOLOCK) ON o.[object_id] = i.ObjectID JOIN sys.schemas s WITH(NOLOCK) ON s.[schema_id] = o.[schema_id] LEFT JOIN #AggColumns a ON a.ObjectID = i.ObjectID AND a.IndexID = i.IndexID LEFT JOIN #Sparse p ON p.ObjectID = i.ObjectID LEFT JOIN #Fragmentation f ON f.ObjectID = i.ObjectID AND f.IndexID = i.IndexID AND f.PartitionNumber = i.PartitionNumber LEFT JOIN ( SELECT ObjectID = [object_id] , IndexID = [index_id] , TotalWrites = NULLIF([user_updates], 0) , TotalReads = NULLIF([user_seeks] + [user_scans] + [user_lookups], 0) , TotalSeeks = NULLIF([user_seeks], 0) , TotalScans = NULLIF([user_scans], 0) , TotalLookups = NULLIF([user_lookups], 0) , LastUsage = ( SELECT MAX(dt) FROM ( VALUES ([last_user_seek]) , ([last_user_scan]) , ([last_user_lookup]) , ([last_user_update]) ) t(dt) ) FROM sys.dm_db_index_usage_stats WITH(NOLOCK) WHERE [database_id] = @DBID ) u ON i.ObjectID = u.ObjectID AND i.IndexID = u.IndexID LEFT JOIN #Lob lob ON lob.ObjectID = i.ObjectID AND lob.IndexID = i.IndexID LEFT JOIN sys.destination_data_spaces dds WITH(NOLOCK) ON i.DataSpaceID = dds.[partition_scheme_id] AND i.PartitionNumber = dds.[destination_id] JOIN sys.filegroups fg WITH(NOLOCK) ON ISNULL(dds.[data_space_id], i.DataSpaceID) = fg.[data_space_id] WHERE o.[type] IN ('V', 'U') AND ( f.Fragmentation &gt;= @Fragmentation OR i.PagesCount &gt; @PreDescribeSize OR i.IndexType IN (5, 6) )</span></span></code> </pre> <br>  After that, point queries determine the level of fragmentation for large indices. <br><br><pre> <code class="1c hljs">EXEC sp_executesql N' DECLARE @DBID INT = DB_ID() SELECT [avg_fragmentation_in_percent] FROM sys.dm_db_index_physical_stats(@DBID, @ObjectID, @IndexID, @PartitionNumber, ''LIMITED'') WHERE [index_level] = 0 AND [alloc_unit_type_desc] = ''IN_ROW_DATA''' , N'@ObjectID int,@IndexID int,@PartitionNumber int' , @ObjectId = <span class="hljs-number"><span class="hljs-number">1044198770</span></span>, @IndexId = <span class="hljs-number"><span class="hljs-number">1</span></span>, @PartitionNumber = <span class="hljs-number"><span class="hljs-number">1</span></span> EXEC sp_executesql N' DECLARE @DBID INT = DB_ID() SELECT [avg_fragmentation_in_percent] FROM sys.dm_db_index_physical_stats(@DBID, @ObjectID, @IndexID, @PartitionNumber, ''LIMITED'') WHERE [index_level] = 0 AND [alloc_unit_type_desc] = ''IN_ROW_DATA''' , N'@ObjectID int,@IndexID int,@PartitionNumber int' , @ObjectId = <span class="hljs-number"><span class="hljs-number">1552724584</span></span>, @IndexId = <span class="hljs-number"><span class="hljs-number">0</span></span>, @PartitionNumber = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Due to this approach, when generating queries, it turned out to solve problems with scanning performance that were encountered in competitors' applications.  This could be completed, but in the process of development, new ideas gradually emerged that made it possible to expand the scope of application of their product. <br><br>  Initially, support for working with WAIT_AT_LOW_PRIORITY was implemented, then it became possible to use DATA_COMPRESSION and FILL_FACTOR for rebuild indexes. <br><br><img src="https://habrastorage.org/webt/kd/em/xj/kdemxjo8sj0hxa4y_omvv3dph6a.png" alt="SQL Index Manager Settings"><br><br>  The application has slightly overgrown with previously unplanned functionality like servicing columns: <br><br><pre> <code class="1c hljs">SELECT * FROM ( SELECT IndexID = [index_id] , PartitionNumber = [partition_number] , PagesCount = SUM([size_in_bytes]) / <span class="hljs-number"><span class="hljs-number">8192</span></span> , UnusedPagesCount = ISNULL(SUM(CASE WHEN [state] = <span class="hljs-number"><span class="hljs-number">1</span></span> THEN [size_in_bytes] END), <span class="hljs-number"><span class="hljs-number">0</span></span>) / <span class="hljs-number"><span class="hljs-number">8192</span></span> , Fragmentation = CAST(ISNULL(SUM(CASE WHEN [state] = <span class="hljs-number"><span class="hljs-number">1</span></span> THEN [size_in_bytes] END), <span class="hljs-number"><span class="hljs-number">0</span></span>) * <span class="hljs-number"><span class="hljs-number">100</span></span>. / SUM([size_in_bytes]) AS FLOAT) FROM sys.fn_column_store_row_groups(@ObjectID) GROUP BY [index_id] , [partition_number] ) t WHERE Fragmentation &gt;= @Fragmentation AND PagesCount BETWEEN @MinIndexSize AND @MaxIndexSize</code> </pre> <br>  Or the ability to create nonclustered indexes based on information from dm_db_missing_index: <br><br><pre> <code class="1c hljs">SELECT ObjectID = d.[object_id] , UserImpact = gs.[avg_user_impact] , TotalReads = gs.[user_seeks] + gs.[user_scans] , TotalSeeks = gs.[user_seeks] , TotalScans = gs.[user_scans] , LastUsage = ISNULL(gs.[last_user_scan], gs.[last_user_seek]) , IndexColumns = CASE WHEN d.[equality_columns] IS NOT <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> AND d.[inequality_columns] IS NOT <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> THEN d.[equality_columns] + ', ' + d.[inequality_columns] WHEN d.[equality_columns] IS NOT <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> AND d.[inequality_columns] IS <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> THEN d.[equality_columns] ELSE d.[inequality_columns] END , IncludedColumns = d.[included_columns] FROM sys.dm_db_missing_index_groups g WITH(NOLOCK) JOIN sys.dm_db_missing_index_group_stats gs WITH(NOLOCK) ON gs.[group_handle] = g.[index_group_handle] JOIN sys.dm_db_missing_index_details d WITH(NOLOCK) ON g.[index_handle] = d.[index_handle] WHERE d.[database_id] = DB_ID()</code> </pre> <br><h3>  Results </h3><br>  After six months of the active development phase, I am glad that the plans do not end there, because I want to further develop this product.  The next step is to add functionality for finding duplicate or unused indexes, as well as implement full support for maintaining statistics within SQL Server. <br><br>  Based on the fact that there are a lot of paid solutions on the market now, I want to believe that due to free positioning, more optimized metadata descraib and the availability of various useful trifles for someone, this product will definitely become useful in everyday tasks. <br><br>  The current version of the application can be downloaded on <a href="https://github.com/sergeysyrovatchenko/SQLIndexManager"><b>GitHub</b></a> .  Sources are in the same place. </div><p>Source: <a href="https://habr.com/ru/post/459914/">https://habr.com/ru/post/459914/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459900/index.html">Visualization of a column from DataFrame using the library Seaborn</a></li>
<li><a href="../459902/index.html">Interactive map of the subjects of Russia for a beginner. Errors that I made and which you should not allow</a></li>
<li><a href="../459906/index.html">Tic Tac Toe, Part 3: Undo / Redo with commands storage</a></li>
<li><a href="../45991/index.html">Lenovo will implement theft protection, remote shutdown by one SMS</a></li>
<li><a href="../459910/index.html">Situation: companies are not in a hurry to develop services for voice assistants - what are the risks</a></li>
<li><a href="../459918/index.html">Solution of the task with pwnable.kr 03 - bof. Stack buffer overflow</a></li>
<li><a href="../45992/index.html">Power over Ethernet technology</a></li>
<li><a href="../459924/index.html">Full cycle of testing React-applications. Report Avto.ru</a></li>
<li><a href="../459928/index.html">The student's path to developing mobile applications</a></li>
<li><a href="../45993/index.html">Nokia N97: New Smartphone Company with Touchscreen and Sliding QWERTY Keyboard</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>