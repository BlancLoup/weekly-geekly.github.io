<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Microservice architecture</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unfortunately, I have no experience with microservices, but about a year ago I was very actively interested in this topic and studied all the sources ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Microservice architecture</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/b77/3ef/843/b773ef843dc249509d033e609f4d5a44.jpg"><br><br>  Unfortunately, I have no experience with microservices, but about a year ago I was very actively interested in this topic and studied all the sources of information that I could find.  I looked at a few speeches at conferences, read a few articles from very reputable and experienced experts like Martin Fowler, Fred George, Adrian Cockroft and Chris Richardson to learn more about microservices.  This article is the result of my research. <br><a name="habracut"></a><br><h2>  Content </h2><br><ul><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">SOA and microservices</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">When should I use microservices?</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">Prerequisites</a> <br><ul><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">Continuous deployment</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">Complicated monitoring</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">Strong devops culture</a> </li></ul></li><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">Specifications</a> <br><ul><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">What is microservice?</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">How big is microservice?</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">Component view through services</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">Heterogeneity</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">Organization of human resources in accordance with business opportunities</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">Products, not projects</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">Smart endpoints and stupid pipes (Smart endpoints and dumb pipes)</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">Decentralized management</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">Decentralized data management</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">Infrastructure Automation</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">Crash Insurance (Design for failure)</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">Evolutionary architecture</a> </li></ul></li><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">Frontend / backend</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">Danger</a> <br><ul><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">Need to manage technology flexibility</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">It is necessary to manage interface instability</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">You need to be sure that the data is consistent.</a> </li></ul></li><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">How to decompose a single application</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/320962/">Conclusion</a> </li></ul><br>  Microservice architecture is an approach to creating an application, implying a rejection of a single, monolithic structure.  That is, instead of executing all the restricted application contexts on the server using in-process interactions, we use several small applications, each of which corresponds to some limited context.  Moreover, these applications run on different servers and interact with each other over the network, for example, using HTTP. <br><br>  In other words, we encapsulate certain application contexts in microservices, one for each, and we turn microservices themselves on different servers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="1"></a><h2>  SOA and microservices </h2><br>  According to Martin Fowler, the term SOA is abused by all and sundry, today it means a lot of things.  From Martin‚Äôs point of view, <a href="https://youtu.be/wgdBVIX9ifA%3Ft%3D14m30s">microservices are a kind of SOA</a> . <br><br><a name="2"></a><h2>  When should I use microservices? </h2><br>  As a theoretical architect who wants to become a practitioner, I consider the following.  When deciding whether to use microservices, in no case can one be guided by myths, or the desire to ‚Äútry it next time,‚Äù or the desire to be at the forefront of technology.  This, in accordance with the <a href="https://youtu.be/qiC9OAculcc%3Ft%3D5m55s">conclusions of Rachel Myers</a> , must be approached exclusively from a pragmatic point of view.  Rachel notes that <a href="https://youtu.be/qiC9OAculcc%3Ft%3D8m39s">architecture should</a> : <br><br><ul><li>  make the product more flexible and resilient to failure; </li><li>  facilitate understanding, debugging, and code modification; </li><li>  help in teamwork. </li></ul><br>  I agree with Rachel, but I also believe that monolithic architectural schemes satisfy these criteria. <br><br>  <a href="https://youtu.be/wgdBVIX9ifA%3Ft%3D17m55s">Martin Fowler highlights several advantages of</a> monolithic and microservice architectures that will help you decide which approach to choose: <br><table><tbody><tr><td colspan="2">  <b>Benefits</b> </td></tr><tr><td>  <b>Monolithic architecture</b> </td><td>  <b>Microservices</b> </td></tr><tr><td>  <b>Simplicity</b> <br><br>  Monolithic architecture is much easier to implement, manage and deploy. <br><br>  Microservices require careful management, as they are deployed on different servers and use the API. </td><td>  <b>Partial Deployment</b> <br><br>  Microservices allow you to update the application in parts as needed. <br><br>  With a single architecture, we have to re-deploy the entire application, which entails much more risks. </td></tr><tr><td>  <b>Consistency</b> <br><br>  With a monolithic architecture, it is easier to maintain the consistency of the code, handle errors, etc. But microservices can be completely controlled by different teams in compliance with different standards. </td><td>  <b>Availability</b> <br><br>  For microservices, accessibility is higher: even if one of them fails, it does not cause the entire application to fail. </td></tr><tr><td>  <b>Intermodular refactoring</b> <br><br>  A single architecture makes it easier to work in situations where several modules must interact with each other or when we want to move classes from one module to another.  In the case of microservices, we must very clearly define the boundaries of the modules! </td><td>  <b>Preservation of modularity</b> <br><br>  Maintaining modularity and encapsulation may not be easy, despite the SOLID rules.  However, microservices allow you to guarantee the absence of common states (shared state) between modules. </td></tr><tr><td></td><td>  <b>Multiplatform / heterogeneity</b> <br><br>  Microservices allow you to use different technologies and languages, in accordance with your tasks. </td></tr></tbody></table><br>  Personally, I like the <a href="https://youtu.be/yPvef9R3k-M%3Ft%3D29m23s">pragmatic approach of Eric Evans</a> .  From the point of view of hardware resources, microservices have advantages that common architectures do not have, and also facilitate the solution of a number of tasks from a software point of view: <br><table><tbody><tr><td colspan="2">  <b>Microservices</b> </td></tr><tr><td>  <b>Hardware advantages</b> </td><td>  <b>Software Benefits</b> </td></tr><tr><td>  <b>Independent scalability</b> <br><br>  When placing modules on separate server nodes, we can scale them independently of other modules. </td><td>  <b>Preservation of modularity</b> <br><br>  Both single and microservice architectures allow you to maintain modularity and encapsulation.  However, this can be quite a difficult task, which will take decades to complete, despite the SOLID rules.  But microservices allow you to provide a logical division of the application into modules due to the explicit physical separation of the servers.  Physical isolation protects against violation of the limits of limited contexts. </td></tr><tr><td>  <b>Independent technical stack</b> <br><br>  Due to the distribution of modules across different server nodes and an independent interaction language, we can use completely different programming languages, interaction tools, monitoring and data storage.  This allows you to choose the best and most convenient solutions, as well as experiment with new technologies. </td><td>  <b>Independent evolution of subsystems</b> <br><br>  Microservice can develop and break backward compatibility without burdening itself with support for older versions, since you can always leave the old version of microservice running the necessary time. </td></tr></tbody></table><br>  I believe that the main reasons for using microservices are hardware advantages that cannot be achieved with a single architecture.  So if the above points are important to you, then microservices have no alternative.  If the hardware advantages are not critical for you, then the complexity of the microservice architecture may outweigh its advantages.  It also seems to me that with the help of a single architecture, it is impossible to achieve partial deployment and partial accessibility, typical of microservices.  These are not key benefits (although these are benefits anyway). <br><br>  Regardless of our tastes and wishes, it is IMPOSSIBLE to start a new project right away using microservice architecture.  First you need to focus on understanding the task and on the way to achieve it, without spending resources on overcoming the enormous complexity of creating an ecosystem of microservices ( <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D16m40s">Rebecca Parsons</a> , <a href="https://leanpub.com/software-architecture-for-developers/read">Simon Brown</a> ). <br><br><a name="3"></a><h2>  Prerequisites </h2><br><a name="4"></a><h3>  Continuous deployment </h3><br>  <b>Opportunity and focus on constant acceleration</b> <br><br>  One of the reasons for using microservices is that we want to be able to change something quickly in order to respond to changes in business requirements, be ahead of the competition.  Or, in the words of Eric Evans, we need <a href="https://youtu.be/yPvef9R3k-M%3Ft%3D4m10s">to</a> be <a href="https://youtu.be/yPvef9R3k-M%3Ft%3D4m10s">aware of the chaos in companies</a> : <br><br><blockquote>  The reality of software development is that at first we never have a complete understanding of the problem.  Our understanding deepens as we work, and we constantly have to refactor.  So, refactoring is a need, but at the same time a danger, because the code becomes more confusing, especially if you do not respect the limited contexts.  Microservices force us to observe the limits of limited contexts, which allows us to preserve the efficiency, clarity, isolation and encapsulation of the code in separate communication modules.  If the module / microservice becomes entangled, then this entanglement only remains in it, and does not extend beyond its limits. </blockquote><br>  We need to act faster at all stages of development!  This is true for any architecture, but microservices are more convenient in this regard.  Martin Fowler says you need to be able to: <br><br><ul><li>  <b>Quickly commissioning:</b> quickly deploy new machines for development, testing, acceptance and operation. </li><li>  <b>Quickly deploy applications:</b> automatically and quickly deploy our services. </li></ul><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yPf5MfOZPY0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <a href="https://youtu.be/yPf5MfOZPY0%3Ft%3D3m17s">Fred George states</a> the same thing: there is a huge need to speed up the work in order to withstand the competition!  He gives a retrospective analysis of the time required for commissioning the server, and notes that in the 1990s it took 6 months, in 2010, thanks to cloud services, 30 minutes, and in 2015, Docker allowed to raise and launch a new server in less than in a minute. <br><br>  Adrian Cockroft, one of the key specialists at Netflix Cloud and a pioneer in the development of microservices, notes how important it is to <a href="https://youtu.be/pwpxq9-uw_0%3Ft%3D2m38s">be in the forefront in mastering new technologies</a> , as well as <a href="https://youtu.be/pwpxq9-uw_0%3Ft%3D15m16s">very quickly introduce new servers and deploy new versions of their applications</a> .  Adrian is a big Docker fan, because this service allows you to create a server and deploy environments for development, testing and operation in seconds. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/84a/680/977/84a68097797286651c2317b3cd869fe6.jpg" alt="image"><br><br><a name="5"></a><h3>  Complicated monitoring </h3><br>  Monitoring is extremely important ( <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D11m42s">Rebecca Parsons</a> ), we need to immediately find out that the server has crashed, that some component has stopped responding, that calls fail, and for each of the microservices ( <a href="https://youtu.be/yPf5MfOZPY0%3Ft%3D17m10s">Fred George</a> ).  We also need tools for quick debugging ( <a href="https://youtu.be/wgdBVIX9ifA%3Ft%3D24m40s">Martin Fowler</a> ). <br><br><a name="6"></a><h3>  Strong devops culture </h3><br>  We need devops to monitor and control, with close relations and good interaction between them and the developers ( <a href="https://youtu.be/wgdBVIX9ifA%3Ft%3D25m30s">Martin Fowler</a> ).  When working with microservices, we have to deploy more, the monitoring system becomes more complicated, the number of possible failures grows.  Therefore, a strong devops culture ( <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D28m34s">Rebecca Parsons</a> ) is very important in the company. <br><br><a name="7"></a><h2>  Specifications </h2><br>  Martin Fowler and James Lewis in their <a href="http://martinfowler.com/articles/microservices.html">well-known article</a> and speeches ( <a href="https://www.youtube.com/watch%3Fv%3DwgdBVIX9ifA">Fowler</a> , <a href="https://www.youtube.com/watch%3Fv%3DuicjqeZO690">Lewis</a> ) provide a set of characteristics for determining microservice. <br><br><a name="8"></a><h3>  What is microservice? </h3><br>  Personally, I fully agree with the <a href="https://youtu.be/pwpxq9-uw_0%3Ft%3D21m25s">definition of Adrian Cockroft</a> : <br><br><blockquote>  An architecture based on loosely coupled services with limited contexts.  (Loosely coupled service oriented architecture with bounded contexts.) </blockquote><br><img src="https://habrastorage.org/getpro/habr/post_images/198/fff/a95/198fffa95356e666e896b65ada4af1e9.jpg" alt="image"><br><br>  Limited context is the concept of explicit boundaries around a business context.  For example, in the framework of e-commerce, we operate with the terms "themes", "payment service providers" (payment providers), "orders", "shipping", "application store".  These are all limited contexts, which means candidates for microservices. <br><br>  Useful general information about microservices is provided in Sam Newman‚Äôs book Building Microservices.  According to James Lewis, <a href="https://youtu.be/uicjqeZO690%3Ft%3D8m30s">microservices should</a> : <br><br><ul><li>  cheap to replace; </li><li>  scale fast; </li><li>  be resilient to failure; </li><li>  in no way slow down our work. </li></ul><br><a name="9"></a><h3>  How big is microservice? </h3><br>  James Lewis argues that the service must be ‚Äú <a href="https://youtu.be/wgdBVIX9ifA%3Ft%3D16m13s">large enough to fit in your hand,</a> ‚Äù that is, so that one person can fully understand his device and work. <br><br>  There are different opinions about the size of microservices.  Martin Fowler <a href="https://youtu.be/wgdBVIX9ifA%3Ft%3D16m43s">describes cases</a> where the <b>ratio of the number of employees and services</b> ranged from 60 to 20 to 4 to 200. For example, in Amazon, the approach with the ‚Äútwo pizzas team‚Äù is used: there should be enough people in the microservice team to they could be fed with two pizzas. <br><br>  <a href="https://youtu.be/yPf5MfOZPY0%3Ft%3D16m">Fred George believes</a> that microservice should be ‚Äúvery, very small‚Äù in order to be created and accompanied by only one developer.  The same goes for James Lewis. <br><br>  I agree with James Lewis, Fred George and Adrian Cockroft.  It seems to me that <b>microservice should correspond to a limited context that one person can fully understand</b> .  That is, the wider the functionality of the application, the more microservices should be.  For example, <b>in Netflix there are about 800</b> !  ( <a href="https://youtu.be/yPf5MfOZPY0%3Ft%3D47m25s">Fred George</a> ) <br><br>  However, both at the very beginning of the microservice life cycle and later, the limited context may be too large for one person to understand.  It is necessary to identify such situations and split up such services into smaller ones.  This is in line with the concepts of evolutionary architecture and DDD, which implies that the architecture is constantly changing / refactoring as it goes deeper into the task and / or changes in business requirements.  As <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D10m37s">Rebecca Parsons</a> says, ‚Äúcrushing is extremely important‚Äù: <b>when developing microservices, it is most difficult to determine their boundaries</b> .  And while promoting the work, we will definitely unite or split up services. <br><br><a name="10"></a><h3>  Component view through services </h3><br><ol><li>  A component is an element of the system that can be <b>independently replaced, improved</b> ( <a href="https://youtu.be/wgdBVIX9ifA%3Ft%3D4m15s">Martin Fowler</a> ) and <b>scaled</b> ( <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D11m26s">Rebecca Parsons</a> ). </li><li>  When developing software, we use two types of components: <br>  A. <b>Libraries:</b> pieces of code used in applications that can be supplemented or replaced by other libraries, preferably without affecting the rest of the application.  The interaction takes place through language constructs.  However, <b>if the library of interest to us is written in another language, we cannot use this component</b> . <br>  B. <b>Services:</b> parts of applications that in fact are small applications running in their own processes.  The interaction is accomplished through interprocess communication, web service calls, message queuing, etc. <b>We can use the service written in another language, since it runs in its own process</b> (this approach is preferred by <a href="https://youtu.be/sAsRtZEGMMQ%3Ft%3D21m40s">Chad Fowler</a> ). </li><li>  Independent scalability - each service can be scaled independently of the rest of the application. </li></ol><br><a name="11"></a><h3>  Heterogeneity </h3><br>  Heterogeneity is the ability to build a system using different programming languages.  The approach has a number of advantages ( <a href="https://youtu.be/wgdBVIX9ifA%3Ft%3D17m55s">Martin Fowler</a> ), and <a href="https://youtu.be/sAsRtZEGMMQ%3Ft%3D21m40s">Chad Fowler</a> believes that systems must be heterogeneous by default, that is, developers <b>should</b> try to apply new technologies. <br><br>  The advantages of a heterogeneous system: <br><br><ul><li>  Prevents close ties through the use of different languages. </li><li>  Developers can experiment with technologies, which increases their own value and allows them not to go to other companies to try new items. <br>  Rule  When experimenting with new technologies: <br>  - you need to use small code units, modules / microservices to reduce the risk; <br>  - code elements must be disposable. </li></ul><br><a name="12"></a><h3>  Organization of human resources in accordance with business opportunities </h3><br>  Sometime within the development teams, groups organized themselves <b>based on the technologies used</b> .  As a result, the project was created by a DBA team, a server-side development team, and an interface development team that operated independently of each other.  Such a scheme affects the quality of the product, because knowledge in specific areas and development efforts are dispersed into subgroups. <br><br>  In the microservice approach, teams should be organized on the basis of business opportunities: for example, orders, shipments, catalogs, etc. Each team should have specialists in all the necessary technologies (interface, server, DBA, QA ...).  This will give each team enough knowledge to focus on creating specific parts of the application - microservices ( <a href="https://youtu.be/wgdBVIX9ifA%3Ft%3D6m30s">Martin Fowler</a> , <a href="https://youtu.be/yPvef9R3k-M%3Ft%3D2m55s">Eric Evans</a> ). <br><br>  The approach is combined with <a href="https://en.wikipedia.org/wiki/Conway%2527s_law">Conway's law</a> , which states that if we need highly connected separate microservices, then the structure of the organization should reflect the desired component structure. <br><br><blockquote>  Systems development organizations ... create architectures that replicate interaction structures within these organizations. <br><br>  Melvin Conway, 1967 </blockquote><br><a name="13"></a><h3>  Products, not projects </h3><br>  There used to be such an approach: the team creates some kind of functionality, and then transfers it to the support of another team. <br><br>  In the case of microservices, the team should be responsible for its product throughout its entire life cycle, including development, maintenance and decommissioning.  This forms ‚Äúgrocery thinking‚Äù, which means a strong link between the technical product and its business opportunities.  That is, a direct relationship is created: how the application helps its users expand their business opportunities. <br><br><a name="14"></a><h3>  Smart endpoints and dumb pipes </h3><br>  Again, in the good old days, companies used the Enterprise Service Bus architecture (service bus), which forms a communication channel between endpoints and business logic.  Then this approach was transformed into a spaghetti box. <br><br>  The microservice architecture takes business logic to the endpoints and uses simple methods of interaction like HTTP. <br><br><a name="15"></a><h3>  Decentralized management </h3><br>  Key decisions on microservices should be made by people who actually develop microservices.  Here, key decisions mean the choice of programming languages, deployment methodology, public interface contracts, etc. <br><br><a name="16"></a><h3>  Decentralized data management </h3><br>  In the traditional approach, an application has only one database, and many different components of the business logic of the application ‚Äúinteract‚Äù within this database: they directly read data belonging to other components from it.  It also means that the same degree of data integrity is typical for all components, even if for some of them this is not the best situation ( <a href="https://youtu.be/wgdBVIX9ifA%3Ft%3D9m19s">Martin Fowler</a> ). <br><br>  With a microservice architecture, when each business component is a microservice, all components have their own databases that are inaccessible to other microservices.  Component data is available (for reading and writing) only through the corresponding component interface.  Due to this, the degree of data stability varies depending on the component ( <a href="https://youtu.be/wgdBVIX9ifA%3Ft%3D9m19s">Martin Fowler</a> , <a href="https://youtu.be/sAsRtZEGMMQ%3Ft%3D21m40s">Chad Fowler</a> ). <br><br>  From the point of view of Fred George, this is the <a href="https://youtu.be/yPf5MfOZPY0%3Ft%3D18m41s">first challenge</a> on the path to microservice architecture. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66a/b64/157/66ab64157eae4346eded1d835853459c.jpg" alt="image"><br><br><a name="17"></a><h3>  Infrastructure Automation </h3><br>  <b>Continuous Deployment</b> ( <a href="https://youtu.be/wgdBVIX9ifA%3Ft%3D11m22s">Martin Fowler</a> , <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D12m45s">Rebecca Parsons</a> , <a href="https://youtu.be/sAsRtZEGMMQ%3Ft%3D21m40s">Chad Fowler</a> , <a href="https://youtu.be/yPvef9R3k-M%3Ft%3D5m45s">Eric Evans</a> ): <br><br><ol><li>  Blue and green deployment: <b>zero downtime</b> . </li><li>  <b>Automation:</b> with one click you can deploy multiple servers. </li><li>  <b>Phoenix servers:</b> quick start and stop. </li><li>  <b>Monitoring:</b> you can see when something went wrong, and debug. </li></ol><br><a name="18"></a><h3>  Crash Insurance (Design for failure) </h3><br>  The servers over which the application is distributed sooner or later fall, especially different nodes.  Therefore, the application architecture must be resilient to such failures ( <a href="https://youtu.be/wgdBVIX9ifA%3Ft%3D12m11s">Martin Fowler</a> ). <br><br>  Chaos monkey is a tool created in Netflix.  It allows you to shut down servers to test system resilience to this type of failure ( <a href="https://youtu.be/wgdBVIX9ifA%3Ft%3D12m31s">Martin Fowler</a> ). <br><br>  <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D12m14s">Rebecca Parsons</a> considers it very important that we no longer use even in-process communication between services; instead, we resort to HTTP for communication, which is not nearly as reliable.  As a result, there will be failures when communicating services with each other, and the system should be ready for this. <br><br><a name="19"></a><h3>  Evolutionary Architecture </h3><br>  The architecture of the entire application should not be static, it should be easy to develop in accordance with the needs of the business.  For example, you can: <br><br><ul><li>  Transform (refactor) a single application into a microservice application, isolating and transferring business logic sets (limited contexts) into separate microservices. </li><li>  Combine existing microservices, for example, when it is often necessary to simultaneously change different microservices. </li><li>  Separate existing microservices when you need and have the opportunity to develop them individually or when we understand that separation will seriously affect business logic. </li><li>  Temporarily add some possibility to the application by creating a microservice that will work for a certain time. </li></ul><br><a name="20"></a><h2>  Frontend / backend </h2><br>  There are two approaches to structuring the frontend and backend with microservice architecture: <br><br><ol><li>  <b>Spread out all parts of the user interface on microservices</b> and maintain the relationship between the corresponding microservices.  This allows you to establish in-process interaction between the front end and the backend.  But then it will be very difficult, if possible at all, to maintain UI connectivity.  In the case of cross-border changes in the UI, we will have to simultaneously update several microservices, creating relationships and breaking the isolation and independence of microservices provided by the architecture itself.  It turns out almost antipattern! </li><li>  <b>Spread the frontend and backend code bases</b> , leaving the application UI as one, so that they then interact via HTTP.  Microservices will be separated from each other, which further separates the front-end and backend.  But the UI can be maintained entirely, easily maintaining its connectivity.  This structure recommends using <a href="https://youtu.be/qiC9OAculcc%3Ft%3D27m18s">Rachel Myers</a> , and as I understand it, this is the only way.  In this case, we have two options for interaction between the front end and the backend: <br><ol><li>  There are many small asynchronous HTTP requests instead of one large, which will exclude the possibility of blocking (this approach is preferred by <a href="https://youtu.be/sAsRtZEGMMQ%3Ft%3D21m40s">Chad Fowler</a> ). </li><li>  One big request to specialized services (gateway / aggregator / cache) that collect data from the entire microservice ecosystem.  This reduces the complexity of the UI. </li></ol></li></ol><br><a name="21"></a><h2>  Danger </h2><br><a name="22"></a><h3>  Need to manage technology flexibility </h3><br>  One of the advantages of microservices is that we can use different technologies to solve the same problem.  For example, in each microservice use different libraries for XML parsing or different data security tools.  But the opportunity itself does not mean that we should do it.  It is possible that the abundance of technology and libraries will get out of control.  So choose a basic set of tools and only refer to others when you really need it ( <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D13m5s">Rebecca Parsons</a> ). <br><br><a name="23"></a><h3>  Need to manage interface instability </h3><br>  At the beginning of the development of microservice, its API is particularly unstable.  But even at later stages, when microservice is sufficiently developed, we have to change the API, its input and output.  Make changes carefully because other applications will rely on the stability of the API ( <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D15m23s">Rebecca Parsons</a> ). <br><br><a name="24"></a><h3>  You need to be sure that the data is consistent. </h3><br>  Microservices have their own data storage.  And in many cases, data belonging to one microservice will be partially or fully copied by another, <i>client</i> microservice.  When the data at the <i>supplier</i> changes, it initiates an event to start updating the data copied by the client microservice.  The event enters the message queue and waits for the client microservice to receive it. <br><br>  This scheme means that the client microservice will have outdated data until it detects the necessary event.  Data is not consistent. <br><br>  Of course, as a result, the changes will be applied to all copies, and the data will again become consistent.  This is called eventual consistency - coherence in the long run.  That is, we know that for a short period of time the data remains inconsistent.  This effect is important during application development, from the server side to the UX levels ( <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D14m">Rebecca Parsons</a> ). <br><br><a name="25"></a><h2>  How to decompose a single application </h2><br>  Starting to create an application, you must initially adhere to a single architecture - because of its simplicity.  At the same time, you should try to create it as modular as possible so that each component is easily transferred to a separate microservice ( <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D16m40s">Rebecca Parsons</a> ).  This is combined with the <a href="https://leanpub.com/software-architecture-for-developers/read">idea of ‚Äã‚ÄãSimon Brown</a> to develop an application as a set of separate components in a single extensible module. <br><br>  When decomposing a single architecture into a microservice, or into a set of separate components, it is necessary to think about several dimensions in support of our solution: <br><br><ul><li>  Think of <b>limited contexts</b> , as defined in DDD ( <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D17m23s">Rebecca Parsons</a> , <a href="https://youtu.be/qiC9OAculcc%3Ft%3D12m52s">Rachel Myers</a> ) <br><ul><li>  Each microservice should represent a limited context, from the point of view of the business concept and from the technical point of view.  Usually, microservice should include connections between code elements (between data and / or business logic), as well as several connections with external code elements. </li></ul></li><li>  Think about <b>business opportunities</b> (Rebecca Parsons: <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D18m32s">1</a> , <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D17m23s">2</a> ) <br><ul><li>  What value streams exist in the organization?  Business products?  What business services are delivered? </li></ul></li><li>  Think about the <b>needs of consumers</b> (Rebecca Parsons: <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D18m32s">1</a> , <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D17m23s">2</a> , <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D18m54s">3</a> ) <br><ul><li>  We can look at the product not only as creators, but also as consumers: what do they want from our service?  How will they use it?  What do they expect? </li></ul></li><li>  Think about <b>interaction patterns</b> <br><ul><li>  Which parts of the system can use the same data?  What business logic will interact more intensively?  (Rebecca Parsons: <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D18m32s">1</a> , <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D17m23s">2</a> , <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D19m17s">3</a> ) </li><li>  Is there a single point of failure in architecture due to the rigid dependence of one microservice on many others?  ( <a href="https://youtu.be/qiC9OAculcc%3Ft%3D18m41s">Rachel Myers</a> ) </li></ul></li><li>  Think about <b>data architecture</b> (Rebecca Parsons: <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D18m32s">1</a> , <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D19m58s">2</a> , <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D17m23s">3</a> , <a href="https://youtu.be/qiC9OAculcc%3Ft%3D12m52s">Rachel Myers</a> ) <br><ul><li>  Services have their own data, they have their own databases, and we need to proceed from the principle of consistency in the final analysis.  If two data structures are very dependent on each other, then it may be better to keep them in one microservice, so that you don‚Äôt have to create a mechanism for working with consistency in the final analysis. </li></ul></li><li>  Think of patterns of <b>interrelated changes</b> (Rebecca Parsons: <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D18m32s">1</a> , <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D20m38s">2</a> , <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D17m23s">3</a> , <a href="https://youtu.be/qiC9OAculcc%3Ft%3D38m11s">Rachel Myers</a> ) <br><ul><li>  If it is possible to foresee the simultaneous change of two code elements, then it is better to store them in one microservice in order to eliminate unnecessary efforts to change the API. </li></ul></li><li>  Get ready for <b>merging and sharing services</b> ( <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D20m56s">Rebecca Parsons</a> ) <br><ul><li>  You probably can't always do it on time.  But as we gain experience and deepen into a task, we begin to better understand the location of limited contexts.  Business will also change, and we will have to quickly adapt to this!  So our system should allow to quickly divide and merge microservices. </li></ul></li><li>  Template <b>Tolerant reader</b> ( <a href="https://youtu.be/WhHtVUlJNA0%3Ft%3D21m37s">Rebecca Parsons</a> ) <br><ul><li>  There may always be a need to make a critical change in backward compatibility (backwards compatibility breaking change).  But we can try to do it only as a last resort.  In order not to constantly change your service, create it so that the service has to be changed only when really important data changes. </li></ul></li><li>  <b>Without saving the state and nodes Phoenix</b> ( <a href="https://youtu.be/qiC9OAculcc%3Ft%3D27m18s">Rachel Myers</a> , <a href="https://youtu.be/sAsRtZEGMMQ%3Ft%3D21m40s">Chad Fowler</a> , <a href="https://youtu.be/yPvef9R3k-M%3Ft%3D5m45s">Eric Evans</a> ) <br><ul><li>  Do not duplicate static files (HTML, CSS, JS, images) in applications and services. </li><li>  User interface applications must be completely separated from the microservice ecosystem. </li><li>  Use single knots. </li><li>  Use immutable deployments: never update software on existing sites. </li></ul></li><li>  <b>Convention over configuration priority</b> ( <a href="https://youtu.be/sAsRtZEGMMQ%3Ft%3D21m40s">Chad Fowler</a> ) <br><ul><li>  The structure and naming system adopted in your architecture should be the same for the entire microservice ecosystem. </li><li>  Create a microservice sandbox generator so that you have a starting point with an already defined familiar structure. </li></ul></li><li>  <b>Optimizing the interaction between microservices</b> ( <a href="https://youtu.be/sAsRtZEGMMQ%3Ft%3D21m40s">Chad Fowler</a> ) <br><ul><li>  Create a basic HTTP REST client library optimized for REST calls, on the basis of which you can build a specific microservice client, it will be used by other microservices.  This optimized client should be ported to all languages ‚Äã‚Äãused in your ecosystem. </li></ul></li><li>  <b>Service discovery</b> ( <a href="https://youtu.be/sAsRtZEGMMQ%3Ft%3D21m40s">Chad Fowler</a> ) <br><ul><li>  Each microservice should know how to contact with others.    (  ) ,         . </li></ul></li><li> <b></b> ( <a href="https://youtu.be/sAsRtZEGMMQ%3Ft%3D21m40s"> </a> ) <br><ul><li>  : , , . </li><li>            . </li></ul></li><li> <b>     </b> ( <a href="https://youtu.be/sAsRtZEGMMQ%3Ft%3D21m40s"> </a> ) <br><ul><li>         (  ‚Äî joins). </li><li>   . </li><li>      , . </li><li>       API-  . </li><li>        . </li></ul></li><li> <b> </b> ( <a href="https://youtu.be/sAsRtZEGMMQ%3Ft%3D21m40s"> </a> ) <br><ul><li>   . </li><li>    . </li><li>     =&gt;   (spot instances) AWS   85  95 %  . </li></ul></li><li> <b></b> ( <a href="https://youtu.be/sAsRtZEGMMQ%3Ft%3D21m40s"> </a> ) <br><ul><li>        Docker. </li></ul></li></ul><br><a name="26"></a><h2>  Conclusion </h2><br>       ,    .        ,   (,   )    ,        ,              ,    ,   . <br><br>     ,     .     , , ,    .     . <br><br><h2>  useful links </h2><br><h3>  Articles </h3><br> Werner Vogels ‚Ä¢  2008 ‚Ä¢ <a href="http://www.allthingsdistributed.com/2008/12/eventually_consistent.html">Eventually Consistent ‚Äì Revisited</a> <br> Oracle ‚Ä¢  2012 ‚Ä¢ <a href="http://www.oracle.com/technetwork/consistency-explained-1659908.pdf">De-mystifying ‚Äúeventual consistency‚Äù in distributed systems</a> <br>      ‚Ä¢  2014 ‚Ä¢ <a href="http://martinfowler.com/articles/microservices.html">Microservices</a> <br><br><h3>  Conferences </h3><br>   ‚Ä¢  2015 ‚Ä¢ <a href="https://www.youtube.com/watch%3Fv%3Dpwpxq9-uw_0">The State of the Art in Microservices</a> <br>   ‚Ä¢  2015 ‚Ä¢ <a href="https://www.youtube.com/watch%3Fv%3DsAsRtZEGMMQ">From Homogeneous Monolith to Radically Heterogeneous Microservices Architecture</a> <br>   ‚Ä¢  2015 ‚Ä¢ <a href="https://www.youtube.com/watch%3Fv%3DyPvef9R3k-M">DDD &amp; Microservices: At Last, Some Boundaries!</a> <br>   ‚Ä¢  2015 ‚Ä¢ <a href="https://www.youtube.com/watch%3Fv%3DyPf5MfOZPY0">Challenges in implementing Microservices</a> <br>   ‚Ä¢  2015 ‚Ä¢ <a href="https://www.youtube.com/watch%3Fv%3DuicjqeZO690">Microservices and the Inverse Conway Manoeuvre</a> <br>  - ‚Ä¢  2014 ‚Ä¢ <a href="https://www.youtube.com/watch%3Fv%3D1aaw7iYS_VM">Real World Microservices</a> <br>   ‚Ä¢  2015 ‚Ä¢ <a href="https://www.youtube.com/watch%3Fv%3DwgdBVIX9ifA">Microservices</a> <br>   ‚Ä¢  2015 ‚Ä¢ <a href="https://www.youtube.com/watch%3Fv%3DqiC9OAculcc">Stop Building Services, Episode 1: The Phantom Menace</a> <br>   ‚Ä¢  2015 ‚Ä¢ <a href="https://www.youtube.com/watch%3Fv%3DWhHtVUlJNA0">Evolutionary Architecture &amp; Micro-Services</a> </div><p>Source: <a href="https://habr.com/ru/post/320962/">https://habr.com/ru/post/320962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320952/index.html">Founder's advice. Dmitry Barychev, ‚ÄúTrack parcel.rf‚Äù</a></li>
<li><a href="../320954/index.html">Hyper-Converged Platforms: From Exotic to Mainstream</a></li>
<li><a href="../320956/index.html">Google publishes Chrome source code for iOS</a></li>
<li><a href="../320958/index.html">Game theory and poker. Counting the number of possible strategies</a></li>
<li><a href="../320960/index.html">CEF, ES6, Angular 2, TypeScript using .Net Core classes. Creating a cross-platform GUI for .Net using CEF</a></li>
<li><a href="../320964/index.html">Matrix with ideas for startups</a></li>
<li><a href="../320966/index.html">CryptoAPI of the Linux kernel: development and application of Russian cryptography</a></li>
<li><a href="../320968/index.html">Over the past year, users of ad blockers have become 30% more</a></li>
<li><a href="../320970/index.html">Powershell and stack depth</a></li>
<li><a href="../320972/index.html">A little Intel Xeon Phi can now get everyone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>