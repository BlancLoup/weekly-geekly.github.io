<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Backend for the frontend, or How in Yandex.Market create an API without crutches</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Why are some APIs more convenient to use than others? What can we do as front-end vendors on our side to work with an API of acceptable quality? Today...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Backend for the frontend, or How in Yandex.Market create an API without crutches</h1><div class="post__text post__text-html js-mediator-article"><p>  Why are some APIs more convenient to use than others?  What can we do as front-end vendors on our side to work with an API of acceptable quality?  Today, I will tell Habr's readers both about technical options and organizational measures that will help front-end and back-bidders find a common language and work efficiently. </p><br><img src="https://habrastorage.org/webt/us/fq/lo/usfqlosft_umexv3_kh5zyd_wdy.png"><br><p>  This fall Yandex.Market is 18 years old.  All this time, Market's partner interface has been developing.  In short, this is an admin panel, with which stores can upload catalogs, work with an assortment, follow statistics, respond to reviews, etc.  The specifics of the project are such that you have to interact a lot with various backends.  At the same time, data is not always available in one place, from one specific backend. </p><br><p><a name="habracut"></a></p><h3>  Problem symptoms </h3><br>  So, imagine, there was some kind of task.  The manager goes with the task to the designers - they draw the layout.  Then he goes to the back-tenders - they make some <a href="https://ru.stackoverflow.com/questions/431135/%25D0%25A7%25D1%2582%25D0%25BE-%25D1%2582%25D0%25B0%25D0%25BA%25D0%25BE%25D0%25B5-%25D1%2580%25D1%2583%25D1%2587%25D0%25BA%25D0%25B8-%25D0%25BD%25D0%25B0-%25D1%2581%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B3%25D0%25B5-%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2581%25D1%2582%25D0%25BE%25D0%25B2">pens</a> and write the list of parameters and the response format on the inside wiki. <br><p>  Then the manager goes to the front-end with the words ‚ÄúI brought you an API‚Äù and offers everything in a quick script, since, in his opinion, almost all the work has already been done. </p><br><p>  You look at the documentation and see this: </p><br><pre><code class="xml hljs">‚Ññ |   ---------------------- 53 | feed_shoffed_id 54 | fesh 55 | filter-currency 56 | showVendors</code> </pre> <br><p>  Noticing anything strange?  Camel, Snake and Kebab Case in one handle.  I'm not talking about the fesh parameter.  What is fesh anyway?  That word doesn't even exist.  Try to guess before you open the spoiler. </p><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><p>  Fesh is a filter by store ID.  You can pass several aydishnikami comma.  Before the ID there can be a minus sign, which means that this store should be excluded from the results. </p></div></div><br><p>  In this case, of course, from JavaSctipt, I can not access the properties of such an object through dot notation.  Not to mention the fact that if you have more than 50 parameters in one place, then, obviously, you've turned somewhere in the wrong place. </p><br><p>  There are a lot of inconvenient API options.  The classic example is that the API searches and returns results: </p><br><pre> <code class="javascript hljs">result: [ {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'IPhone 8'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'IPhone 8 Plus'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'IPhone X'</span></span>}, ] result: {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'IPhone 8'</span></span>} result: <span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre> <br><p>  If the goods are found, we get an array.  If one item is found, we get an object with this item.  If nothing is found, then at best we get null.  In the worst case, the backend answers 404 or even 400 (Bad Request). </p><br><p>  There are situations easier.  For example, you need to get a list of stores in one backend, and store options in another.  In some pens there is not enough data, in some data there is too much.  Filtering all of this on the client or doing multiple Ajax requests is a bad idea. </p><br><p>  So, what could be the solutions to this problem?  What can we do as front-end vendors on our side to work with an API of acceptable quality? </p><br><h3>  Backend for frontend </h3><br><p>  We use the React / Redux client in the partner interface.  Under the client is Node.js, which does a lot of auxiliary things, for example, it pushes onto the InitialState page for Redax.  If you have server-side rendering, it doesn‚Äôt matter with which client framework, most likely, it is rendered by the node.  But what if you go a step further and not contact the client directly to the backend, but make your own proxying API on the node, as sharpened as possible for client needs? <br>  This technique is called BFF (Backend For Frontend).  This term was first <a href="http://philcalcado.com/2015/09/18/the_back_end_for_front_end_pattern_bff.html">introduced by</a> SoundCloud in 2015, and the idea can be schematically depicted as follows: </p><br><img src="https://habrastorage.org/webt/du/jw/re/dujwreelvkjlvykh1ut-dphjhxe.png"><br><p>  Thus, you stop going directly to the API from client code.  Each handle, each method of the real API, you duplicate on the node and from the client go exclusively to the node.  And the node already proxies the request to the real API and returns the answer to you. </p><br><p>  This concerns not only primitive get-requests, but generally all requests, including those with multipart / form-data.  For example, a store uploads a .xls file with its catalog through a form on the site.  So, in this implementation, the directory is loaded not directly into the API, but into your node's handle, which proxies stream to a real backend. </p><br><p>  Remember that result example when the backend returned a null, an array or an object?  Now we can bring it to a normal form - something like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getItems</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isNull(response)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isObject(response)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [response] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response }</code> </pre> <br><p>  This code looks awful.  Because he is terrible.  But we still need to do it.  We have a choice: do it on the server or on the client.  I choose a server. </p><br><p>  We can also put all these kebab and snake cases into a style that is convenient for us and immediately put down the default value if necessary. </p><br><pre> <code class="javascript hljs">query: { <span class="hljs-string"><span class="hljs-string">'feed_shoffer_id'</span></span>: <span class="hljs-string"><span class="hljs-string">'feedShofferId'</span></span>, <span class="hljs-string"><span class="hljs-string">'pi-from'</span></span>: <span class="hljs-string"><span class="hljs-string">'piFrom'</span></span>, <span class="hljs-string"><span class="hljs-string">'show-urls'</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{showUrls = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'offercard'</span></span></span></span><span class="hljs-function"><span class="hljs-params">}</span></span></span><span class="hljs-function">) =&gt;</span></span> showUrls, }</code> </pre> <br><p>  What other advantages do we get? </p><br><ol><li>  <strong>Filtering</strong>  The client receives only what he needs, no more, no less. </li><li>  <strong>Aggregation</strong>  No need to spend client network and battery to make multiple Ajax requests.  A noticeable gain in speed due to the fact that opening a connection is an expensive operation. </li><li>  <strong>Caching</strong>  Your repeated aggregated call will not once again pull anyone, but simply return 304 Not Modified. </li><li>  <strong>Hiding</strong> data.  For example, you may have tokens that are needed between backends and should not fall on the client.  The client may not have rights even to know about the existence of these tokens, not to mention their contents. </li><li>  <strong>Microservices</strong> .  If you have a monolith on the back, then BFF is the first step to microservices. </li></ol><br><p>  Now about the minuses. </p><br><ol><li>  Increased <strong>complexity</strong> .  Any abstraction is another layer that needs to be coded, deployed, supported.  Another moving part of the mechanism that can fail. </li><li>  <strong>Duplication</strong> pens.  For example, multiple endpoints can perform the same type of aggregation. </li><li>  BFF is a <strong>boundary layer</strong> that should support general routing, restrictions on user rights, query logging, etc. </li></ol><br><p>  To neutralize these disadvantages, it is enough to follow simple rules.  The first is to separate the interface and business logic.  Your BFF should not change the business logic of the main API.  The second is that your interlayer should only convert data when absolutely necessary.  We are not talking about a self-contained comprehensive API, but only about a proxy that fills the gap, correcting the flaws in the backend. </p><br><h3>  Graphql </h3><br><p>  GraphQL solves similar problems.  With GraphQL, instead of a lot of ‚Äústupid‚Äù endpoint, you have one smart pen that can work with complex queries and generate data in the form in which the client requests them. </p><br><p>  In this case, GraphQL can work on top of REST, that is, the data source is not a base, but a restart API.  Due to GraphQL's declarativeness, due to the fact that all this is friendly with React and Redox, your client becomes easier. </p><br><p>  In fact, I see GraphQL as a BFF implementation with my own protocol and strict query language. </p><br><p>  This is an excellent solution, but it has several drawbacks, in particular, with typing, with differentiation of rights, and in general it is a relatively fresh approach.  Therefore, we have not yet switched to it, but in the long term this seems to me the most optimal way to create an API. </p><br><h3>  Best Friends Forever </h3><br><p>  No technical solution will work correctly without organizational changes.  You still need documentation, guarantees that the format of the answer does not suddenly change, and so on. </p><br><p>  It should be understood that we are all in the same boat.  To an abstract customer, be it a manager or your manager, by and large it doesn‚Äôt matter - you have GraphQL there or BFF.  It is more important for him that the task be solved and no errors appear on the sale.  For him, there is not much difference, due to whose fault an error occurred in the sale - the fault of the front or back.  Therefore, you need to negotiate with backenders. </p><br><p>  In addition, the backward flaws that I mentioned at the beginning of the report do not always arise because of someone‚Äôs malicious actions.  It is possible that the fesh parameter has some meaning. </p><br><img src="https://habrastorage.org/webt/zh/mh/ni/zhmhnidl5c9zkj_yh04ui_eimhe.png"><br><p>  Note the commit date.  It turns out quite recently fesh celebrated its seventeenth anniversary. </p><br><p>  See any weird identifiers on the left?  This is SVN, simply because in 2001 there was no guide.  Not a githaba as a service, but specifically a gita as a version control system.  He appeared only in 2005. </p><br><h3>  Documentation </h3><br><p>  So, all we need is not to quarrel with back-tenders, but to agree.  This can be done only if we find one single source of truth.  This source should be documentation. </p><br><p>  The most important thing here is to write documentation before we start working on functionality.  As with the marriage contract, it is better to agree on everything on the shore. </p><br><p>  How it works?  Relatively speaking, three are going to: the manager, the fronder and the backender.  Fronteder is well versed in the subject area, so his participation is critically important.  They gather and begin to think about the API: in what ways, what answers should be returned, including the name and format of the fields. </p><br><h3>  Swagger </h3><br><p>  A good option for API documentation is <a href="https://swagger.io/">Swagger</a> format, now it is called OpenAPI.  It is better to use Swagger in YAML format, because, unlike JSON, it is better readable by man, and for the machine there is no difference. </p><br><p>  As a result, all agreements are recorded in Swagger-format and published in a common repository.  Documentation for the sales backend should be in the wizard. </p><br><p>  The master is protected from commits, the code gets into it only through the pool of requests, it is impossible to push into it.  The representative of the front-team is obliged to conduct a review of the request rekvesta, without his apruva code in the master does not go.  This protects you from unexpected API changes without prior notice. </p><br><p>  So, you gathered, wrote Swagger, thus actually signed the contract.  From this point on, you, as a front-endender, can begin your work without waiting for the creation of a real API.  After all, what was the point of separation between client and server if we cannot work in parallel and client developers have to wait for server developers?  If we have a ‚Äúcontract‚Äù, then we can calmly parallel this matter. </p><br><h3>  Faker.js </h3><br><p>  For these purposes, great <a href="https://github.com/marak/Faker.js/">faker</a> .  This is a library for generating huge amounts of fake data.  She can generate different types of data: dates, names, addresses, etc., all this is well localized, there is support for the Russian language. </p><br><p>  At the same time, the faker is friendly with the Swager, and you can safely raise the mock server, which, based on the Swagger-scheme, will generate you fake answers along the right paths. </p><br><h3>  Validation </h3><br><p>  Swagger can be converted to a json-scheme, and using tools such as <a href="https://github.com/epoberezkin/ajv">ajv,</a> you can <a href="https://github.com/epoberezkin/ajv">run backends</a> in your BFF, right in runtime, and backtesting replies to testers, backenders, etc., in case of discrepancies. </p><br><p>  Suppose a tester finds a bug on a site, for example, nothing happens when you click on a button.  What does the tester do?  He puts the ticket on the front-end: ‚Äúthis is your button, so it‚Äôs not pressed, fix it‚Äù. </p><br><p>  If there is a validator between you and the backend, then the tester will know that the button is actually pressed, just the backend sends the wrong answer.  The wrong one is a response that the front does not expect, that is, it does not comply with the ‚Äúcontract‚Äù.  And here it is already necessary either to repair the backing or to change the contract. </p><br><h3>  findings </h3><br><ol><li>  We take an active part in the design of the API.  We design API so that it was convenient to use them in 17 years. </li><li>  We require Swagger documentation.  No documentation - the backing job was not done. </li><li>  There is documentation - we publish it in git, while any changes in the API should be approved by a representative of the front team. </li><li>  Raise the fake server and start working on the front without waiting for the real API. </li><li>  We put the node under the frontend and validate all the answers.  Plus we get the ability to aggregate, normalize and cache data. </li></ol><br><h4>  see also </h4><br><p>  ‚Üí <a href="https://habr.com/company/yamoney/blog/347390/">How to build a REST-like API in a large project</a> <br>  ‚Üí <a href="https://hackernoon.com/frontend-in-the-backend-a-pattern-for-cleaner-code-b497c92d0b49">Backend In the Frontend</a> <br>  ‚Üí <a href="https://www.linkedin.com/pulse/using-graphql-bff-pattern-implementation-rafael-rocha">Using GraphQL as BFF Pattern Implementation</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/428141/">https://habr.com/ru/post/428141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../428129/index.html">Simple fuzzy logic blinded "from what it was" for a gas turbine engine</a></li>
<li><a href="../428131/index.html">The whole truth about the RTOS. Article # 17. Event flag groups: introduction and basic services</a></li>
<li><a href="../428133/index.html">Hasura. High-Performance GraphQL to SQL Server Architecture</a></li>
<li><a href="../428135/index.html">How to configure or disable lint in the built-in code editor</a></li>
<li><a href="../428137/index.html">Olympiad, idea competition, lectures on IT project management and film screenings: 10 upcoming events at ITMO University</a></li>
<li><a href="../428143/index.html">Approach to RBAC implementation in ReactJS</a></li>
<li><a href="../428147/index.html">Script collector quotes and recognition of text from video to Python</a></li>
<li><a href="../428149/index.html">Your new ally in the sky Mavic 2 Enterprise</a></li>
<li><a href="../428151/index.html">Express performance review of PostgreSQL 10.5 in the latest cloud services of Yandex. Oblak</a></li>
<li><a href="../428155/index.html">Speed ‚Äã‚Äãlimit for electric vehicles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>