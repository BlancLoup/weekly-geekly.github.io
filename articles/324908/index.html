<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A brief history of javascript. Part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The third and final part of the translation of articles from the blog service Auth0 A Brief History of JavaScript . Key points: transpilers and ECMASc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A brief history of javascript. Part 3</h1><div class="post__text post__text-html js-mediator-article">  The third and final part of the translation of articles from the blog service Auth0 <a href="https://auth0.com/blog/a-brief-history-of-javascript/">A Brief History of JavaScript</a> .  Key points: transpilers and ECMAScript 2015, a little about the new process of preparing updates, what to expect in the future and how Asm.js and WebAssembly will affect it.  The translation was prepared by the Front Typing department of the company. <br><br>  <a href="https://habrahabr.ru/company/livetyping/blog/324196/">A brief history of javascript.</a>  <a href="https://habrahabr.ru/company/livetyping/blog/324196/">Part 1</a> <br>  <a href="https://habrahabr.ru/company/livetyping/blog/324506/">A brief history of javascript.</a>  <a href="https://habrahabr.ru/company/livetyping/blog/324506/">Part 2</a> <br><br><img src="https://habrastorage.org/files/1d4/b17/670/1d4b176701b74c81b3f4c58dfc6f1488.jpg"><br><a name="habracut"></a><br><h2>  ECMAScript 6 (2015) and 7 (2016): a universal programming language </h2><br>  The ECMAScript Harmony plan became the basis for further JavaScript enhancements.  Many of the ideas from ECMAScript 4 have sunk into oblivion for the benefit of all, but some have been revised.  ECMAScript 6, later renamed ECMAScript 2015, should have brought great change.  Almost all updates that somehow influenced the syntax were postponed specifically for this version.  By 2015, the committee was finally able to overcome all internal differences, and ECMAScript 6 saw the light.  Most browser manufacturers have already worked on supporting this version, but so far not all browsers are fully compatible with ECMAScript 2015. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The release of ECMAScript 2015 caused a sharp increase in the popularity of transporters, such as Babel or Traceur.  Due to the fact that the manufacturers of these transpilers followed the work of the technical committee, many people had the opportunity to experience the benefits of ECMAScript 2015 long before its release. <br><br>  Some of the main features of ECMAScript 4 were implemented in this version with a slightly different approach.  For example, classes in ECMAScript 2015 are more than just syntactic sugar on top of prototypes.  This approach facilitates the development and implementation of new features. <br><br>  We <i>(the editors of the Auth0 blog - approx. Lane)</i> did a detailed review of the new features of ECMAScript 2015 in our article <a href="https://auth0.com/blog/a-rundown-of-es6-features/">‚ÄúA summary of the possibilities of JavaScript</a> . <a href="https://auth0.com/blog/a-rundown-of-es6-features/">‚Äù</a>  You can also read the <a href="http://kangax.github.io/compat-table/es6/">ECMAScript compatibility table</a> to get an idea of ‚Äã‚Äãhow the implementation process is going. <br><br>  A short list of new features includes: <br><br><ul><li>  Let (lexical) and const (unchangeable) bindings </li><li>  Arrow functions (short anonymous functions) and lexical this </li><li>  Classes (syntactic sugar over prototypes) </li><li>  Object literal improvements (computed keys, shortened method definitions, etc.) </li><li>  Pattern lines </li><li>  Promises </li><li>  Generators, iterable objects, iterators and for..of </li><li>  The default function parameters and rest statement </li><li>  Spread syntakis </li><li>  Destructuring </li><li>  Modular syntax </li><li>  New collections (Set, Map, WeakSet, WeakMap) </li><li>  Proxy and Reflect </li><li>  Symbols data type </li><li>  Typed Arrays </li><li>  Class inheritance </li><li>  Tail recursion optimization </li><li>  Simplified Unicode Support </li><li>  Binary and octal literals </li></ul><br>  All these features opened JavaScript for an even greater number of programmers and made a significant contribution to a lot of programming. <br><br>  It may surprise some people how so many new opportunities could have slipped past the standardization process, during which ECMAScript 4 was ruined. I would like to note that most of the most aggressive ECMAScript 4 innovations, such as namespaces or optional typing, were forgotten and more did not return, while others were rethought with regard to the objections.  Work on ECMAScript 2015 was very hard and took almost six years (and even more, given the time required for implementation).  But the very fact that the ECMAScript technical committee was able to cope with such a difficult task became a good sign. <br><br>  In 2016, a small ECMAScript update was released.  This version is the result of a new preparation process adopted in TC-39.  All new proposals must go through four stages.  A proposal that has reached the fourth stage has every chance of being included in the next version of ECMAScript (however, the committee has the right to postpone it for a later version).  Thus, each proposal is developed individually (of course, taking into account its interaction with other proposals), without slowing down the development of ECMAScript. <br><br>  If the proposal is ready for inclusion in the standard, and a sufficient number of other proposals have reached the fourth stage, a new version of ECMAScript will be released. <br><br>  The version released in 2016 was very small.  It included: <br><br><ul><li>  Exponentiation operator (**) </li><li>  Array.prototype.includes </li><li>  A few minor corrections (generators cannot be used with new, etc.) </li></ul><br>  Nevertheless, several interesting proposals have already reached the fourth stage in 2016.  What does ECMAScript prepare for us? <br><br><h2>  The future is close and not very: ECMAScript 2017 and the following versions </h2><br>  The most important proposal, reached the fourth stage, is async / await.  This is an extension of JavaScript syntax that makes working with promises more enjoyable.  For example, consider the ECMAScript 2015 code: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apiDoSomethingMoreComplex</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">withThis</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> urlA = <span class="hljs-string"><span class="hljs-string">'...'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> urlB = <span class="hljs-string"><span class="hljs-string">'...'</span></span>; httpLib.request(urlA, withThis).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parsed = parseResult(result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { database.update(updateStatement, parsed).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(parsed); }, error =&gt; { reject(error); }); }); }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> httpLib.request(urlB, result); }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> worker.processData(result); }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> { logger.info(<span class="hljs-string"><span class="hljs-string">`apiDoSomethingMoreComplex success (</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${result}</span></span></span><span class="hljs-string">)`</span></span>); }, error =&gt; { logger.error(error); }); }</code> </pre> <br>  And compare it with the code that uses async / await: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apiDoSomethingMoreComplex</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">withThis</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> urlA = <span class="hljs-string"><span class="hljs-string">'...'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> urlB = <span class="hljs-string"><span class="hljs-string">'...'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> httpLib.request(urlA, withThis); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parsed = parseResult(result); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> database.update(updateStatement, parsed); result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> httpLib.request(urlB, parsed); result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> worker.processData(result); logger.info(<span class="hljs-string"><span class="hljs-string">`apiDoSomethingMoreComplex success (</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${result}</span></span></span><span class="hljs-string">)`</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(e) { logger.error(e); } }</code> </pre> <br>  Other proposals that have reached the fourth stage are quite small: <br><br><ul><li>  Object.values ‚Äã‚Äãand Object.entries </li><li>  Line alignment </li><li>  Object.getOwnPropertyDescriptors </li><li>  Comma delimiters in function parameters </li></ul><br>  All these proposals are intended for the release of 2017, but the committee has the right to postpone them until the next release.  But even the addition of async / await will be awesome. <br><br>  The future does not end there.  Let's look at <a href="https://github.com/tc39/proposals">some other suggestions</a> to get an idea of ‚Äã‚Äãwhat lies ahead.  Here are some of the most interesting: <br><br><ul><li>  SIMD API </li><li>  Asynchronous iterators (async / await + iteration) </li><li>  Switch generators </li><li>  Operations with 64-bit integers </li><li>  Areas (isolation states) </li><li>  Shared Memory and Atomics </li></ul><br>  JavaScript is becoming more and more like a general purpose language.  But there is another big detail in the future of javascript that will make its own adjustments. <br><br><h3>  WebAssembly </h3><br>  If you have not heard of WebAssembly, you should <a href="https://auth0.com/blog/7-things-you-should-know-about-web-assembly/">read about it</a> .  A huge number of libraries and frameworks that appeared after the release of ECMAScript 5, as well as the general development of the language, made JavaScript an interesting target for other languages.  For large code structures, interoperability is a key need.  Take, for example, games.  The most common language in which games are written is C ++, so they can be ported to a large number of architectures.  Nevertheless, porting to the Windows browser or console game was considered an impossible task.  However, this was made possible thanks to the rapid development and unprecedented efficiency of today's JavaScript virtual machines.  Tools like <a href="https://github.com/kripken/emscripten">Emscripten</a> were born to perform such tasks. <br><br>  Orienting the situation quickly, Mozilla began work on making JavaScript a suitable target for compilers.  This is how Asm.js came into being - a subset of JavaScript that is ideally suited as a similar target.  JavaScript virtual machines can be optimized to recognize this subset and produce code that is much better than the one that the current virtual machines generate.  Thanks to JavaScript, browsers are slowly becoming a new target for compilers. <br><br>  Yet there are huge limitations that even Asm.js cannot overcome.  In JavaScript, you must make such changes that differ from its current purpose.  Something completely different is needed to make the web a worthy target for other programming languages.  And that‚Äôs what WebAssembly is for ‚Äî a low-level programming language for the web.  Any program can be compiled into WebAssembly using a suitable compiler and then run in a suitable virtual machine (JavaScript virtual machines can provide the necessary level of semantics).  The first versions of WebAssembly are 100% compatible with the Web.js specification.  WebAssembly promises not only faster loading time (bytecode is processed faster than text), but also the possibility of optimization not available in Asm.js.  Imagine a web with perfect interoperability between JavaScript and your programming language. <br><br>  At first glance, this may hinder the growth of JavaScript, but in reality everything is completely different.  Due to the fact that other languages ‚Äã‚Äãand frameworks will get interoperability with JavaScript, it will be able to continue its development as a general-purpose language.  And WebAssembly is a necessary tool for this. <br><br>  Currently, dev versions of Chrome, Firefox and Microsoft Edge have initial support for WebAssembly and are capable of playing <a href="http://webassembly.org/demo/">demo applications</a> . <br><br><h2>  Using JavaScript in Auth0 </h2><br>  We at Auth0 <a href="https://github.com/auth0">use JavaScript very tightly</a> , which is the main programming language everywhere, from the <a href="https://github.com/auth0/lock">Lock library</a> to backends.  Its asynchronous nature and ultimate simplicity for new developers are key to our success.  We are watching with interest the development of the language and its influence on the entire ecosystem. <br>  Sign up for free with Auth0 and get acquainted with the ecosystem written entirely in JavaScript.  Do not worry, we have <a href="https://auth0.com/docs/quickstarts">client libraries for all popular frameworks and platforms</a> . <br><br><h2>  Conclusion </h2><br>  JavaScript history is long and full of unexpected turns.  Initially proposed as a ‚ÄúScheme for the Web,‚Äù he borrowed its syntax from Java.  Its first prototype was developed in a few weeks.  Adjusting to the requirements of the market, he changed three names in less than two years, after which he was standardized and got a name more suitable for <a href="http://www.infoworld.com/article/2653798/application-development/javascript-creator-ponders-past--future.html">skin disease</a> .  After three successful releases, the language has been cooking in hellish cauldrons for almost eight years.  Then, thanks to the success of a single technology (AJAX), the community was able to overcome controversy and resume development.  Version 4 was abandoned, and a small update known as version 3.1 was renamed to version 5. Version 6 spent many years in development (again), but this time the committee successfully completed the work, changing the number in the title to 2015. It was a very big update, and its implementation took a lot of time.  As a result, JavaScript got a second wind.  The community has revived as never before.  Thanks to Node.js, V8 and other JavaScript projects, it rose to heights that the developers of the first version didn‚Äôt even think about, and thanks to Asm.js and WebAssembly it will fly even higher.  Active proposals, which are in different stages, make the future of JavaScript clean and bright.  Having come a long way, full of unexpected turns and obstacles, JavaScript remains one of the most successful languages ‚Äã‚Äãin programming history.  And this is the best proof of its reliability.  Always put on javascript. </div><p>Source: <a href="https://habr.com/ru/post/324908/">https://habr.com/ru/post/324908/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324898/index.html">Tensorflow deep learning library</a></li>
<li><a href="../324900/index.html">MIPSfpga and interrupts</a></li>
<li><a href="../324902/index.html">How Discord Indexes Billions of Posts</a></li>
<li><a href="../324904/index.html">Five important principles of working with data, which we forget when preparing a project presentation</a></li>
<li><a href="../324906/index.html">The story of how I went to Google Next 17. A brief pressing on the announcements and the most important</a></li>
<li><a href="../324910/index.html">Why do you need a manufacturer‚Äôs service for IT equipment and its cost estimate?</a></li>
<li><a href="../324912/index.html">PayPal Node.js</a></li>
<li><a href="../324914/index.html">We develop video chat between the browser and the mobile application</a></li>
<li><a href="../324916/index.html">The winning decision of the ML Boot Camp III contest</a></li>
<li><a href="../324918/index.html">Docker and detection of available resources inside the container</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>