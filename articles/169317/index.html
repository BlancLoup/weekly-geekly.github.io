<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The problem of determining whether a point belongs to a polygon</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, dear habravchane! 
 In the process of developing an application for Android, which involves user interaction with graphic primitives (dots, lin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The problem of determining whether a point belongs to a polygon</h1><div class="post__text post__text-html js-mediator-article">  Hello, dear habravchane! <br>  In the process of developing an application for Android, which involves user interaction with graphic primitives (dots, lines, ellipses, rectangles, etc.), a rather unpleasant situation arose: the user can define an arbitrary polygon and make it inactive, but in the future activate this polygon and continue working with it (for example, move to another place or add / delete vertices) it is necessary for an inactive object to determine whether the user has touched this  object, ie  it was necessary to solve the problem of the point belonging to the polygon. <br><br>  This problem is widely known in computational geometry and I bring to your attention the results of my research on this topic. <br><a name="habracut"></a><br><h5>  Introduction </h5><br>  Computational geometry usually assumes that a polygon is simple, i.e.  without self-intersections, but the problem is also considered for complex polygons.  This problem is most often solved by the following methods: <br><ul><li>  the method of taking into account the number of intersections, which counts the number of times the ray outgoing from point <i>P</i> crosses the boundaries of the polygon.  If the number of intersections is odd, then it is declared that the point lies inside the polygon, if it is even - outside. </li><li>  method of counting the number of revolutions, which counts the number of revolutions, which makes the oriented boundary of the polygon around a given point <i>P.</i>  In algebraic topology, this number is called the winding number.  A point is considered to lie outside the polygon only if the number of revolutions is zero, otherwise the point lies inside the contour of the polygon. </li></ul><br>  If the polygon is simple (that is, it does not have self-intersections), then both methods give the same result for all points.  However, if the polygon has a complex shape, then the methods may return different results for some points.  For example, if a polygon intersects with itself, then when using the method of taking into account the intersections, points in the intersection region are defined as points outside.  However, the same points will be considered lying inside the polygon when using the method of counting the speed (see figure). <br><br><img src="https://habrastorage.org/storage2/388/6a2/385/3886a2385dd6a6bd01a40f44047d8a1b.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The method of counting the number of intersections and its optimization are described in detail in <a href="http://habrahabr.ru/post/161237/">this</a> article, so let's consider the second algorithm for solving the problem. <br><br><h5>  Turnover Method </h5><br>  This method determines whether a point lies inside a complex polygon, comparing how many times a polygon is wrapped around a point.  The point does not belong to the polygon only in the case when the number of revolutions (winding number) is zero. <br><br>  Let a continuous two-dimensional curve <i>C</i> be defined by the points <i>C (u) = C (x (u), y (u))</i> , where <i>0 ‚â§ u ‚â§ 1</i> and <i>C (0) = C (1)</i> .  Also let <i>P</i> be a point not lying on the curve <i>C.</i>  Declare the vector <i>c (P, u)</i> (from point <i>P</i> to curve <i>C</i> ): <br><br><img src="https://habrastorage.org/storage2/4ed/a1a/89f/4eda1a89f3686bee42aa1537a882235f.png"><br><br>  and the unit vector <i>w (P, u)</i> : <br><br><img src="https://habrastorage.org/storage2/121/846/a74/121846a745ac07058768600564b2b730.png">  , <br><br>  which gives a continuous function <i>W (P): C ‚Üí S <sup>1</sup></i> , mapping the point <i>C (u) of the</i> curve <i>C</i> to the point <i>w (P, u)</i> on the unit circle <i>S <sup>1</sup> = {(x, y) |</i>  <i>x2 + y2 = 1}</i> .  This mapping can be represented in polar coordinates: <br><br><img src="https://habrastorage.org/storage2/c52/305/b21/c52305b212714c32435d9866427a1ee9.png">  , <br><br>  where <i>Œ∏ (u)</i> is a positive counterclockwise rotation in radians. <br>  Then the rotation number <i>wn (P, C) of a</i> continuous curve <i>C</i> around the point <i>P</i> is equal to an integer number of times when <i>W (P)</i> turns the curve <i>C</i> around the unit circle <i>S <sup>1</sup></i> .  This corresponds to the homotopy class <i>S <sup>1</sup></i> and can be calculated through the integral: <br><br><img src="https://habrastorage.org/storage2/581/369/aea/581369aea931a2139039497a298529b1.png"><br><br>  When curve <i>C</i> is a polygon with vertices <i>V <sub>0</sub></i> , <i>V <sub>1</sub></i> , ..., <i>V <sub>n</sub> = V <sub>0</sub></i> , the integral is reduced to the sign sum of the angles at which each edge of the polygon <i>V <sub>i</sub> V <sub>i + 1 is</sub></i> <i>opposite</i> to the point <i>P.</i>  Thus, if Œ∏ <sub>i</sub> is equal to the angle between <i>PV <sub>i</sub></i> and <i>PV <sub>i + 1</sub></i> , then: <br><br><img src="https://habrastorage.org/storage2/d4f/638/d52/d4f638d52bcc46bc0be2511a64baaa4d.png">  (one) <br><br>  The figure shows how you can graphically represent the signed sum of the angles. <br><img src="https://habrastorage.org/storage2/92c/334/1fc/92c3341fc51f565d1c5065df470c6ec5.png"><br><br>  It is obvious that formula (1) is not very effective, since it uses the compositive power of the arcgon-sine trigonometric function.  It is necessary to replace this formula with a more efficient one. <br><br><h5>  Optimization of the method of accounting for turnovers </h5><br>  Take any point <i>Q</i> on the unit circle.  Then, as the curve <i>W (P)</i> wraps around <i>S <sup>1</sup></i> , it passes the point <i>Q a</i> certain number of times.  If we count (+1) when the curve passes <i>Q</i> counterclockwise, and (-1) when the curve passes clockwise, the accumulated amount will be the total number of times <i>W (P) is</i> wrapped around <i>S <sup>1</sup></i> and equal to <i>wn (P , C)</i> is the number of revolutions of the continuous curve <i>C</i> around the point <i>P.</i>  Further, if we take an infinite ray <i>R</i> with a beginning at the point <i>P</i> and passing in the direction of the vector <i>Q</i> , then the intersection of the ray <i>R</i> and the curve <i>C</i> corresponds to the point where <i>W (P)</i> passes <i>Q.</i>  To develop a mathematical apparatus, it is necessary to distinguish between positive and negative transitions, where <i>C</i> crosses <i>R</i> in directions from right to left or from left to right.  This can be determined by the sign of the scalar product of the normal vector to <i>C</i> and the direction of the vector <i>q = Q</i> , and it is necessary to calculate the scalar product for each edge of the polygon.  For a horizontal ray <i>R</i> with the origin at point <i>P</i> , it is sufficient to check whether the edge of the edge is above or below the ray.  If the edge intersects the direct ray from bottom to top, then the intersection is positive (+1), but if it intersects the edge from top to bottom, then the intersection is negative (-1).  The sum of the intersection signs gives the number of revolutions <i>wn (P, C)</i> . <br><br><img src="https://habrastorage.org/storage2/f11/076/fb4/f11076fb4c12c005071eb9d321531da8.png"><br><br>  Moreover, it is possible to avoid calculating the actual intersection point of the edge and ray.  To do this, it is sufficient to determine from which side the edge intersects the ray.  If the ascending edge intersects the ray to the right of point <i>P</i> , then <i>P</i> is to the left of the edge, since  the triangle <i>V <sub>i</sub> V <sub>i + 1</sub> P is</i> oriented counterclockwise.  If the descending edge intersects the ray from the left, then the point <i>P</i> is located to the right of the edge, since the triangle <i>V <sub>i</sub> V <sub>i + 1 is</sub></i> oriented clockwise. <br><br><img src="https://habrastorage.org/storage2/ede/0b6/f58/ede0b6f582af62b922e97a95cf6301be.png"><br><br>  The figure on the left shows the ascending edge, and on the right - the descending edge. <br><br>  In conclusion, I would like to say that the method of accounting for turns requires a complete search of the vertices of a given polygon, and this, in my opinion, is its drawback.  However, it is more than compensated by the ease of implementation and the presence of only two multiplication operations at each iteration of the loop through the vertices. <br><br>  UPD: <br><h5>  Implementation </h5><br>  Probably in vain, I did not immediately attach the source code, so I am fixing it. <br><div class="spoiler">  <b class="spoiler_title">Source</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Polygon</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       private ArrayList&lt;Float&gt; xPoints = new ArrayList&lt;Float&gt;(); private ArrayList&lt;Float&gt; yPoints = new ArrayList&lt;Float&gt;(); //   get  set ,     // ,      public boolean ontains(float _pointX, float _pointY) { float windingNumber = 0; //    float startX = 0; float startY = 0; float endX = 0; float endY = 0; int count = xPoints.size(); for (int i = 1; i &lt;= count; i++) { startX = xPoints.get(i - 1); startY = yPoints.get(i - 1); if (i == count) { endX = xPoints.get(0); endY = yPoints.get(0); } else { endX = xPoints.get(i); endY = yPoints.get(i); } if (startY &lt;= _pointY) { if (endY &gt; _pointY) { //   if (isLeft(startX, startY, endX, endY, _pointX, _pointY) &gt; 0) { //  P     ++windingNumber; } } } else { if (endY &lt;= _pointY) { //   if (isLeft(startX, startY, endX, endY, _pointX, _pointY) &lt; 0) { //  P    --windingNumber; } } } } return (windingNumber != 0); } // start*  end* -  ,  . point* -   P,   private float isLeft(float _startX, float _startY, float _endX, float _endY, float _pointX, float _pointY) { return ((_endX - _startX) * (_pointY - _startY) - (_pointX - _startX) * (_endY - _startY)); } }</span></span></code> </pre> </div></div><br><br>  <b>Primary source:</b> <a href="http://geomalgorithms.com/index.html">GeometryAlgorithms.com</a> </div><p>Source: <a href="https://habr.com/ru/post/169317/">https://habr.com/ru/post/169317/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../169305/index.html">LangPrism - web content crowdsourcing translation service</a></li>
<li><a href="../169307/index.html">It is cheaper for Australians to fly to the USA to buy software</a></li>
<li><a href="../169309/index.html">IT AS IS (competition results)</a></li>
<li><a href="../169311/index.html">Testing code performance on multiple versions of PHP</a></li>
<li><a href="../169313/index.html">10 wacky projects raised over $ 900,000 on KickStarter</a></li>
<li><a href="../169319/index.html">Veeam Backup Cloud Edition has been released with support for Azure, Amazon, Google, HP Cloud and several other cloud platforms.</a></li>
<li><a href="../169321/index.html">New perspectives on Java Enterprise with the Polyglot JVM</a></li>
<li><a href="../169323/index.html">Habra Kadabra - literacy support for authors of articles on Habrahabr</a></li>
<li><a href="../169327/index.html">In the wake of the movie "The Pirate Bay: Away From Keyboard" or the future of the Internet</a></li>
<li><a href="../169329/index.html">Continuous Integration in Dnevnik.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>