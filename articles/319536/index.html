<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Performance Optimization in React</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuation of a series of translations of the section "Advanced Guides" (Advanced Guides) of the official documentation of the React.js library. 
 P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Performance Optimization in React</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/ddf/d6c/b63/ddfd6cb635004c5da7cab5ccd531388c.jpg" alt="React. Advanced Guides. Part Five"></p><br><p>  Continuation of a series of translations of the section "Advanced Guides" (Advanced Guides) of the official documentation of the React.js library. </p><br><h2 id="optimizaciya-proizvoditelnosti-v-react">  Performance Optimization in React </h2><br><p>  Internally, React uses several advanced techniques that minimize the number of expensive DOM operations required to update the user interface.  For most applications using React, the speed of the resulting interface is sufficient without additional actions to optimize performance.  However, there are several ways you can speed up your React application. </p><br><a name="habracut"></a><br><h2 id="ispolzovanie-okonchatelnoy-production-sborki">  Using the final (production) build </h2><br><p>  If you are testing performance or experiencing performance problems in your React application, make sure you test the minified final (production) build: </p><br><ul><li> To create a React application build, you need to run <code>npm run build</code> and follow the instructions. </li><li>  For single-file assemblies, we offer versions of React prepared for final assembly that have the <code>.min.js</code> extension. </li><li>  For the Browserify collector, you need to run the build with the <code>NODE_ENV=production</code> parameter. </li><li>  For the Webpack collector, you need to add the following plugins to the configuration configuration file of the final assembly (production config): </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> webpack.DefinePlugin({ <span class="hljs-string"><span class="hljs-string">'process.env'</span></span>: { <span class="hljs-attr"><span class="hljs-attr">NODE_ENV</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(<span class="hljs-string"><span class="hljs-string">'production'</span></span>) } }), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> webpack.optimize.UglifyJsPlugin()</code> </pre> <br><p>  A development build includes additional warnings that help develop an application, but they slow down an application by performing additional actions. </p><br><h2 id="profilirovanie-komponentov-s-pomoschyu-timeline-v-chrome">  Component profiling using Timeline in Chrome </h2><br><p>  Using performance tools in supported browsers, in <strong>development</strong> mode, you can visualize how components are mounted, updated and unmounted.  For example: </p><br><p><img src="https://habrastorage.org/files/56f/276/fc0/56f276fc06984728ae8a26af42b4b25b.png" alt="React components in Timeline Chrome"></p><br><p>  Perform the following steps in Chrome: </p><br><ol><li><p>  Load your application with the <code>?react_perf</code> parameter in the query string (for example: <code>http://localhost:3000/?react_perf</code> ). </p><br></li><li><p>  Open the <strong><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool">Timeline</a></strong> tab in the Chrome Developer Tools and click <strong>Record</strong> . </p><br></li><li><p>  Perform the actions you want to profile.  Do not record actions for more than 20 seconds - otherwise Chrome may hang. </p><br></li><li><p>  Stop recording. </p><br></li><li>  React events will be grouped under the <strong>User Timing</strong> label. </li></ol><br><p>  Please note that <strong>these numbers are relative, since</strong>  <strong>components will be displayed faster in production mode</strong> .  Ultimately, this should help you to imagine where the user interface receives updates by mistake, and how deep and often updates your user interface. </p><br><p>  Currently, this feature is supported only by Chrome, Edge and IE, but since  we use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API">User Timing API</a> standard, we expect other browsers to add support for this feature. </p><br><h2 id="izbegayte-izlishney-pererisovki">  Avoid unnecessary redrawing. </h2><br><p>  React creates and maintains its own internal representation of the displayed user interface.  It includes elements of React returned by your components.  This allows React to avoid creating existing DOM nodes and accessing them beyond necessity, which may be slower than operations with JavaScript objects.  Sometimes this model is called the ‚Äúvirtual DOM‚Äù, although Native React (React Native) works as well. </p><br><p>  When the properties of the component (props) or state change, React compares the new returned version of the item with the one previously displayed in the DOM, and if they are not equivalent, it updates the DOM. </p><br><p>  In some cases, your component can be accelerated by redefining the life cycle function <code>shouldComponentUpdate</code> , which is called before the re-mapping (re-rendering) process begins.  The default function definition returns <code>true</code> , allowing React to update: </p><br><pre> <code class="javascript hljs">shouldComponentUpdate(nextProps, nextState) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  If you know that in some cases your component does not need to be updated, you can return <code>false</code> from the <code>shouldComponentUpdate</code> function to skip the re-mapping (re-rendering) process, including calling the <code>render()</code> method in the current component and down the hierarchy. </p><br><h2 id="shouldcomponentupdate-v-deystvii">  shouldComponentUpdate in action </h2><br><p>  The figure shows a tree of components.  The <code>SCU</code> label displays the result returned by the function <code>shouldComponentUpdate</code> , and the <code>vDOMEq</code> label <code>vDOMEq</code> whether the React element is equivalent to the previous view.  The color of the circles indicates the need to redraw the component. </p><br><p><img src="https://habrastorage.org/files/ebe/0d4/64f/ebe0d464fa3c4bb7b2983ccbe8a03e1b.png" alt="Component tree"></p><br><p>  In the C2 component, the function <code>shouldComponentUpdate</code> returned <code>false</code> , as a result of which the entire subtree, starting from C2 and below, React will not redraw (call the render function), and for this you do not even have to call the function <code>shouldComponentUpdate</code> in components C4 and C5. </p><br><p>  For C1 and C3 - <code>shouldComponentUpdate</code> returned <code>true</code> , so React had to go down and check the descendants.  For C6, <code>shouldComponentUpdate</code> returned <code>true</code> , and since these elements are not equivalent to a virtual DOM, React had to be updated with DOM. </p><br><p>  Well, the last interesting option is C8.  React had to render the component, but since  the new internal representation of the React element is equivalent to the previous one; it was not necessary to update the DOM. </p><br><p>  Note that React had to make changes to the DOM only for C6, which were inevitable.  In the case of C8 - we were helped by comparing the rendered React elements, for the C2 tree and the C7 component we didn‚Äôt even have to compare the elements - <code>shouldComponentUpdate</code> returned <code>false</code> and the <code>render</code> method was not called. </p><br><h2 id="primery">  Examples </h2><br><p>  Imagine the option that our component changes only when the <code>props.color</code> property or <code>state.count</code> .  We can implement the verification of these cases in the function <code>shouldComponentUpdate</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CounterButton</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = {<span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>}; } shouldComponentUpdate(nextProps, nextState) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.color !== nextProps.color) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.count !== nextState.count) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;button color={</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.props.color} onClick={(</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function"> =&gt;</span></span> ({<span class="hljs-attr"><span class="hljs-attr">count</span></span>: state.count + <span class="hljs-number"><span class="hljs-number">1</span></span>}))}&gt; Count: {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.count} &lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt; ); } }</span></span></code> </pre> <br><p>  In this code, the function <code>shouldComponentUpdate</code> checks for any changes to the <code>props.color</code> property or the <code>state.count</code> state.  If their values ‚Äã‚Äãhave not changed, the component is not updated.  If your component is more complex, you can use a similar template, but producing a "superficial comparison" of all the properties (fields) of <code>props</code> and <code>state</code> to determine if the component needs to be updated.  This template is used quite often, so React has a helper for implementing this logic - just inherit your component from <code>React.PureComponent</code> .  The following code achieves the same goal as the previous one, but it is actually simpler: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CounterButton</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = {<span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>}; } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;button color={</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.props.color} onClick={(</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function"> =&gt;</span></span> ({<span class="hljs-attr"><span class="hljs-attr">count</span></span>: state.count + <span class="hljs-number"><span class="hljs-number">1</span></span>}))}&gt; Count: {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.count} &lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt; ); } }</span></span></code> </pre> <br><p>  In most cases, you can use <code>React.PureComponent</code> instead of writing your own function <code>shouldComponentUpdate</code> .  However, <code>React.PureComponent</code> implements only a superficial comparison, and there are cases when the properties (props) or states can be changed in such a way that a superficial comparison is not enough - such a situation can occur with more complex data structures.  For example, suppose you need to implement a <code>ListOfWords</code> component to display a list of words separated by commas, with the parent component <code>WordAdder</code> , which, when a button is <code>WordAdder</code> , adds a word to the list.  The following code <em>will not work</em> correctly: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListOfWords</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{this.props.words.join(',')}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WordAdder</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = { <span class="hljs-attr"><span class="hljs-attr">words</span></span>: [<span class="hljs-string"><span class="hljs-string">'marklar'</span></span>] }; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handleClick = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handleClick.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } handleClick() { <span class="hljs-comment"><span class="hljs-comment">//           const words = this.state.words; words.push('marklar'); this.setState({words: words}); } render() { return ( &lt;div&gt; &lt;button onClick={this.handleClick} /&gt; &lt;ListOfWords words={this.state.words} /&gt; &lt;/div&gt; ); } }</span></span></code> </pre> <br><p>  The problem is that <code>PureComponent</code> makes a simple superficial comparison between the old and new values ‚Äã‚Äãof the <code>this.props.words</code> array.  A simple comparison returns <code>true</code> if both compared values ‚Äã‚Äãrefer to the same object (array).  Since the specified code of the <code>handleClick</code> method of the <code>handleClick</code> component <code>WordAdder</code> changes the array of <code>words</code> , the comparison of the old and the new value of <code>this.props.words</code> returns equivalence, despite the fact that the words themselves in the array have changed.  The <code>ListOfWords</code> component <code>ListOfWords</code> not be updated, having new words that need to be displayed. </p><br><h2 id="sila-neizmenyaemyh-dannyh">  The power of immutable data </h2><br><p>  The easiest way to solve this problem is to not change (not mutate) the values ‚Äã‚Äãthat you use in properties (props) or state.  For example, the <code>handleClick</code> method can be rewritten using the <code>concat</code> method, which returns a shallow copy of the array with the addition of new values: </p><br><pre> <code class="javascript hljs">handleClick() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prevState</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">words</span></span>: prevState.words.concat([<span class="hljs-string"><span class="hljs-string">'marklar'</span></span>]) })); }</code> </pre> <br><p>  ES6 supports spreading <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator">syntax</a> for arrays, which can make the code even easier.  If you use the Create React App to create your application, this syntax is available by default. </p><br><pre> <code class="javascript hljs">handleClick() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prevState</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">words</span></span>: [...prevState.words, <span class="hljs-string"><span class="hljs-string">'marklar'</span></span>], })); };</code> </pre> <br><p>  In the same way, you can rewrite the code to avoid changes (mutations) of objects.  For example, imagine that we have a <code>colormap</code> object and we want to write a function that changes the value of <code>colormap.right</code> and sets it to <code>'blue'</code> .  We could mistakenly write: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateColorMap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">colormap</span></span></span><span class="hljs-function">) </span></span>{ colormap.right = <span class="hljs-string"><span class="hljs-string">'blue'</span></span>; }</code> </pre> <br><p>  To implement this without mutations of the original object, we can use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a> method: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateColorMap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">colormap</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, colormap, {<span class="hljs-attr"><span class="hljs-attr">right</span></span>: <span class="hljs-string"><span class="hljs-string">'blue'</span></span>}); }</code> </pre> <br><p>  <code>updateColorMap</code> now returns a new object, rather than changing the old one.  <code>Object.assign</code> is included in ES6 and requires the inclusion of babel-polyfill. </p><br><p>  In ES6, there is the possibility of expanding <a href="https://github.com/sebmarkbage/ecmascript-rest-spread">(spread) the properties of an object</a> and therefore we can implement an update of an object without mutation even more simply: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateColorMap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">colormap</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {...colormap, <span class="hljs-attr"><span class="hljs-attr">right</span></span>: <span class="hljs-string"><span class="hljs-string">'blue'</span></span>}; }</code> </pre> <br><p>  If you use the Create React App to create your application, <code>Object.assign</code> and the <code>Object.assign</code> syntax for objects are available by default. </p><br><h2 id="ispolzovanie-neizmenyaemyh-struktur-dannyh">  Using immutable data structures </h2><br><p>  <a href="https://github.com/facebook/immutable-js">Immutable.js</a> is another way to solve this problem.  This library provides immutable, permanent collections that work through structural exchange: </p><br><ul><li>  <em>Unchangeable</em> : once created, the collection cannot be changed at another time. </li><li>  <em>Persistent</em> : A new collection can be created from a previous collection and a modified data set.  The original collection remains valid after creating a new collection. </li><li>  <em>Structural exchange</em> : a new collection is created using as much as possible the same structure as the original collection, reducing copying to a minimum to improve performance. </li></ul><br><p>  Immutability makes change tracking easy.  Changes always lead to the creation of a new object and we can only check whether the link to the object has changed.  For example, in the native JavaScript code: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">"bar"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> y = x; y.foo = <span class="hljs-string"><span class="hljs-string">"baz"</span></span>; x === y; <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br><p>  Although <code>y</code> been changed, <code>y</code> refers to the same object as <code>x</code> - their comparison returns <code>true</code> .  We can rewrite this code using immutable.js: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SomeRecord = Immutable.Record({ <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SomeRecord({ <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> y = x.set(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'baz'</span></span>); x === y; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br><p>  In this case, because  when <code>x</code> was changed, a reference to the new object was returned, we can safely assume that <code>x</code> has changed. </p><br><p>  Two more libraries that can help use immutable data are <a href="https://github.com/rtfeldman/seamless-immutable">seamless-immutable</a> and <a href="https://github.com/kolodny/immutability-helper">immutability-helper</a> . </p><br><p>  Immutable data structures provide you with the easiest way to track changes in objects ‚Äî and this is what we need to use <code>shouldComponentUpdate</code> , which in most cases will give you a good performance boost. </p><br><p>  Previous parts: </p><br><ul><li>  <a href="https://habrahabr.ru/post/319520/">Uncontrolled components in React.</a> </li><li>  <a href="https://habrahabr.ru/post/319510/">Ref attributes and DOM in React.</a> </li><li>  <a href="https://habrahabr.ru/post/319358/">PropTypes - type checking in React.</a> </li><li>  <a href="https://habrahabr.ru/post/319270/">JSX - details.</a> </li></ul><br><p>  Original source: <a href="https://facebook.github.io/react/docs/optimizing-performance.html">React - Advanced Guides - Optimizing Performance</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/319536/">https://habr.com/ru/post/319536/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319526/index.html">Horizontal scaling. What, why, when and how?</a></li>
<li><a href="../319528/index.html">A person. Commander Norton</a></li>
<li><a href="../319530/index.html">Shadow on the fence, or 25 trees for Adam Jensen</a></li>
<li><a href="../319532/index.html">Indecently simple implementation of indecently simple maze generation algorithm</a></li>
<li><a href="../319534/index.html">Registration is open or NeoQUEST, you are just a space</a></li>
<li><a href="../319542/index.html">How I did the fastest site in Thailand</a></li>
<li><a href="../319544/index.html">How well do Assassin's Creed II missions use the open world?</a></li>
<li><a href="../319548/index.html">Algorithm for finding the equivalent points of the abscissa axis of a polynomial function</a></li>
<li><a href="../319550/index.html">Load balancing with Pacemaker and iPaddr (Active / Active cluster)</a></li>
<li><a href="../319552/index.html">Step-by-step configuration of web services in OTRS 5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>