<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing celestial bees on Cloud Haskell</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 Only 11577635 seconds have passed since the end of GoTo's fall school at ITMO. The week of the direction of Distributed Systems began wit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing celestial bees on Cloud Haskell</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/k6/v7/xb/k6v7xbqhmr9mg_r39khefhckdq4.jpeg"><br>  Hi, Habr! <br><br>  Only 11577635 seconds have passed since the end of GoTo's fall school at ITMO.  The week of the direction of Distributed Systems began with the prototyping of a distributed system on Cloud Haskell.  We started cheerfully and quickly found out that it was difficult to understand the existing documentation without PhD - and decided to write a training manual. <br><br>  Under the cat, an introduction to p2p cloud haskell, a slightly functional PC prototyping stack, motivation and ‚Äúbut why‚Äù. <br><a name="habracut"></a><br><hr><br>  Suppose you want to do something distributed <del>  (say% sCoin) </del>  that is not covered by well-existing systems (YARN does not answer all the questions).  If you start doing everything with your hands, you can quickly find a huge number of problems - from multiplexing connections and encryption to breaking through NAT and peer routing, which you really don't want to solve (not for the first time in human history), especially if the goal is a final product or a beautiful <em>working</em> prototype. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Any application programmer from such a problem statement will quickly come up with the word "library".  And really.  You can take discovery and routing bits from, for example, Kademlia, standard NAT breakdown mechanisms ‚Äî STUN, TURN, ICE ‚Äî in general, are also known; etc. <br><br>  But it will still require a lot of time and expertise.  Investors patience may not be enough. <br><br>  Here, the more experienced colleagues will come up with the idea: ‚Äúwe need a framework!‚Äù.  And true.  For Prototyping Distributed Systems and Applications. <br><br>  And someone will even say: <a href="https://libp2p.io/">bs</a> , this is <a href="https://libp2p.io/">libp2p</a> !  And he will be right.  Partially. <br><br>  libp2p solves the problem of transport, its multiplexing and encryption, discovery, peer routing, NAT punching, connection upgrade, etc.  - in general, many network and crypto requirements of distributed applications.  On Go and JS. <br><br>  This is a great framework, but it has a couple of problems.  This is Go and JS.  In addition, it would be nice to have something in the framework for replication. <br><br><hr><br><blockquote>  The Haskell Cloud </blockquote><br>  <em><a href="http://www.scs.stanford.edu/14sp-cs240h/projects/joshi.pdf">http://www.scs.stanford.edu/14sp-cs240h/projects/joshi.pdf</a> , paraphrased</em> <br><br>  Our project began with an ambition to make a blockchain (excuse me, innovation) on Haskell - so we did not have libp2p - and in four days.  We started looking for something that would make the network (transport, discovery, serialization) for us.  Found <a href="https://haskell-distributed.github.io/">Cloud Haskell</a> .  Found that the documentation is rather complicated.  We decided to write your own introduction.  So: <br><a name="pishiem-niebiesnykh-pchielok-na-cloud-haskell"></a><br><h1>  Writing celestial bees on Cloud Haskell </h1><br>  In the example, we will write a system of bees: there is a hive ‚Äî a cluster of machines, and bees ‚Äî a node (machine).  The bees go to search for flowers to search for and return to the hive with the coordinates of tasty flowers, and all other bees should learn about these coordinates. <br><br>  It is not at all necessary for you to run the program on several computers - a laptop on which we will simultaneously launch our program is enough. <br><br>  The full code is in the <a href="https://github.com/SenchoPens/cloud-bees">repository</a> . <br><br>  Cloud Haskell works on the principle of exchanging messages between nodes (such a model is called <em>message passing</em> ), because nodes do not share the common resource space (RAM, ...) - the <em>shared state</em> model is not easy to use.  <em>Actor Model</em> is a particular example of a <em>message passing</em> model, when messages are sent by <em>actors to</em> other actors and receive messages in their <em>mailbox</em> - as message passing looks like in Haskell Cloud. <br><br><hr><br>  <strong>1.</strong> First, <em>let's</em> define the types of data whose representatives the bees will exchange: <em>src / Types.hs</em> <br><br><pre><code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Flower</span></span></span><span class="hljs-class"> = (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">) </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--   type Flowers = GSet Flower -- Grow-Only Set </span></span></span></span></code> </pre> <br><ul><li>  Bees should be aware of every flower known to at least one bee in the hive, therefore they need to maintain a single state of the ‚Äúdatabase‚Äù of flowers in their bee brain ‚Äî solve the problem <em>of data replication</em> , for which you need to be able to reach a <em>consensus</em> : resolve conflicts between different bee databases .  To do this, we will use the <em>GSet</em> data <em>structure</em> (Grow-only Set) - a set in which elements can only <strong>be added</strong> , but <strong>not deleted</strong> .  This is one of the <a href="https://habrahabr.ru/post/272987/"><em>CRDT</em></a> data structures.  To work with GSet on Haskell, we used the excellent <a href="https://hackage.haskell.org/package/crdt">crdt</a> library of Yuri Syrovetsky ( <a href="https://habr.com/users/cblp/">@cblp</a> ). <pre> <code class="hljs ruby"> Log A Log B <span class="hljs-params"><span class="hljs-params">| |</span></span> logA.append(<span class="hljs-string"><span class="hljs-string">"one"</span></span>) logA.append(<span class="hljs-string"><span class="hljs-string">"two"</span></span>) <span class="hljs-params"><span class="hljs-params">| |</span></span> vv +-----+ +-------+ <span class="hljs-params"><span class="hljs-params">|"one"|</span></span> <span class="hljs-params"><span class="hljs-params">|"hello"|</span></span> +-----+ +-------+ <span class="hljs-params"><span class="hljs-params">| |</span></span> logA.append(<span class="hljs-string"><span class="hljs-string">"two"</span></span>) logA.append(<span class="hljs-string"><span class="hljs-string">"world"</span></span>) <span class="hljs-params"><span class="hljs-params">| |</span></span> vv +-----------+ +---------------+ <span class="hljs-params"><span class="hljs-params">|"one","two"|</span></span> <span class="hljs-params"><span class="hljs-params">|"hello","world"|</span></span> +-----------+ +---------------+ <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> logA.join(logB) &lt;----------+ <span class="hljs-params"><span class="hljs-params">| v +---------------------------+ |</span></span><span class="hljs-string"><span class="hljs-string">"one"</span></span>,<span class="hljs-string"><span class="hljs-string">"hello"</span></span>,<span class="hljs-string"><span class="hljs-string">"two"</span></span>,<span class="hljs-string"><span class="hljs-string">"world"</span></span><span class="hljs-params"><span class="hljs-params">| +---------------------------+</span></span></code> </pre><br>  Scheme for achieving consensus using CRDT (From <a href="https://github.com/haadcode/ipfs-log">https://github.com/haadcode/ipfs-log</a> ) </li><li>  An interface is needed that will serve as bee receptors: adding an element to GSet, as well as viewing delicious flowers known to the beehive, we realize this as a REPL (interactive shell). </li></ul><br>  <strong>2.</strong> We proceed to the implementation of the node, which we will later run from the command line: <em>app / Main.hs</em> <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">--   [port, bootstrapPort] &lt;- getArgs -- (1)     bootstrap      let hostName = "127.0.0.1" -- IP  P2P.bootstrap --       : hostName port --   (\port -&gt; (hostName, port)) initRemoteTable -- (2)  remote table [P2P.makeNodeId (hostName ++ ":" ++ bootstrapPort)] --    bootstrap  spawnNode --    ,     </span></span></code> </pre> <br><ol><li>  To start, the nodes must somehow learn about each other, that is, perform <em>peer discovery</em> .  In Cloud Haskell there is an out-of-box solution ‚Äî when initializing a node, it‚Äôs enough for us to specify at least one other <em>bootstrap</em> node: the node performs with the bootstrap node of the <em>Peer Exchange</em> - they exchange the addresses of the node they know (aka <em>peers</em> ). </li><li>  <em>Remote table</em> is a thing that allows peers to exchange haskell types, if they support <em>serialization</em> , that is, they can be represented in a format that can be sent over the network and restored back to a Haskell object.  A type supports serialization if it implements the <code>class (Binary a, Typeable) =&gt; Serializable a</code> time <code>class (Binary a, Typeable) =&gt; Serializable a</code> .  You don‚Äôt have to invent the <code>Serializable</code> implementation yourself, <code>Binary</code> and <code>Typeable</code> - haskell does it for you (using the automatic deriving magic mechanism): <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE DeriveDataTypeable #-}</span></span> <span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE DeriveGeneric #-}</span></span> <span class="hljs-comment"><span class="hljs-comment">--  ,    Binary data Example = Example deriving (Typeable, Generic) instance Binary Example</span></span></code> </pre>  Next we will omit <code>deriving ...</code> , <code>instance Binary</code> binary and pragmas for the sake of brevity. </li></ol><br>  <strong>3.</strong> Now we write the startup logic for the node: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">spawnNode</span></span> :: <span class="hljs-type"><span class="hljs-type">Process</span></span> () <span class="hljs-comment"><span class="hljs-comment">-- (1)     spawnNode = do liftIO $ threadDelay 3000000 --  bootstrap     let flowers = S.initial :: Flowers --  GSet     self &lt;- getSelfPid -- (3)   Pid  REPL     repl &lt;- spawnLocal $ runRepl self -- (2)  REPL    register "bees" self --        "bees" spawnLocal $ forever $ do -- (3)  : send self Tick --          liftIO $ threadDelay $ 10^6 --  0.1   ,     runNode (NodeConfig repl) flowers -- (5)  </span></span></code> </pre> <br><ol><li>  In Cloud Haskell, the main functional unit is <code>Process</code> (not to be confused with the OS process).  They are based on lightweight green streams and can send messages to other processes ( <code>send</code> function to send to a specific process or <code>P2P.nsendPeers</code> to send to all familiar nodes), receive messages to their <em>mailbox</em> ( <code>expect</code> or <code>receive*</code> function), start other processes (for example, locally with using <code>spawnLocal</code> ), etc. </li><li>  We need to implement the REPL in a separate thread, otherwise the main thread (node) will be blocked, therefore we need to make a thread-safe interface for GSet so that it can be changed for both the REPL and the node.  Since the system is based on actors, we will send messages to change the set and process them sequentially in an infinite loop of processing messages in the main thread. </li><li>  We run the REPL as a separate cloud-haskell process (i.e., as a green stream), and also pass it the main process Pid (unique process identifier) ‚Äã‚Äãso that the REPL knows where to send commands entered by the user as messages.  Next we get Pid REPL (spawnLocal returns <code>spawnLocal</code> ) to send it answers to commands.  The REPL code is <a href="">here</a> . </li><li>  How will flower replication work? <br><ul><li>  Each node will periodically send its status to all peers ( <em>broadcast</em> ) - and this together with CRDT solves the replication problem: <br>  Let there be nodes <code>A</code> and <code>B</code>  Suppose <code>A</code> does not have an element <strong>x</strong> , while <code>B</code> <strong>x</strong> has one.  After <code>B</code> makes a broadcast, <code>A</code> will add <strong>x</strong> - a consensus has been reached, r.t. <br>  If we had an ordinary set, but not GSet, then nothing would have happened: Suppose <code>A</code> and <code>B</code> have an element <strong>y</strong> .  Let <code>A</code> remove <strong>y</strong> .  After <code>B</code> makes a broadcast, <code>A</code> will get <strong>y</strong> back. </li><li>  When we send a message to all the nodes, we must specify the name of the <em>service</em> - in fact, we send a message only to those nodes that have registered themselves in the <em>register</em> as supporting this service.  Here we register our node as a supporting service ‚Äúbees‚Äù: <code>register "bees" self</code> . </li><li>  Noda should know when to send others their status.  The simplest solution is to do it on a timer: wait a second, and then act, but then we would block the main message processing flow.  Here we start the process via <code>spawnLocal</code> , which first sends a Tick message to the main process (when the main process sees the Tick, it sends its state to the nodes), and then waits for 1 second and repeats. </li></ul></li></ol><br>  <strong>4.</strong> Ok, now (finally!) We can proceed to the logic of the main process - node execution code: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">runNode</span></span> :: <span class="hljs-type"><span class="hljs-type">NodeConfig</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Flowers</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Process</span></span> () <span class="hljs-comment"><span class="hljs-comment">-- (1)    runNode config@(NodeConfig repl) flowers = do let run = runNode config receiveWait -- (2)   [ match (\command -&gt; -- (3)    -  Command  REPL,  newFlowers &lt;- handleReplCommand config flowers --     run newFlowers) , match (\Tick -&gt; do --   ,        P2P.nsendPeers "bees" flowers --     run flowers) , match (\newFlowers -&gt; do -- -    run $ newFlowers `union` flowers) --     -     ]</span></span></code> </pre> <br><ol><li>  Let's look at the signature: <code>runNode</code> accepts the <code>runNode</code> node configuration ‚Äî information that will not change during execution.  In our case, this is just a Pid REPL.  She also takes her current state - GSet flowers.  But how to add a flower, because GSet is an immutable data type?  Very simple: let's make our function recursive, and with each change of state we will start it again. </li><li>  <code>receiveWait</code> accepts a list of functions with one argument (incoming message), pulls out a message, and calls a function that matches the message type. </li><li>  If we received a message of this type: <code>data Command = Add Flower | Show</code>  <code>data Command = Add Flower | Show</code> , this is the REPL command.  <code>handleReplCommmand</code> - the function to process the command: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">handleReplCommand</span></span> :: <span class="hljs-type"><span class="hljs-type">NodeConfig</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Flowers</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Command</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Process</span></span> <span class="hljs-type"><span class="hljs-type">Flowers</span></span> handleReplCommand (<span class="hljs-type"><span class="hljs-type">NodeConfig</span></span> repl) flowers (<span class="hljs-type"><span class="hljs-type">Add</span></span> flower) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">--      send repl (Added flower) --  REPL ,    return $ S.add flower flowers --       handleReplCommand (NodeConfig repl) flowers Show = do --    send repl (HereUR $ toList flowers) --      return flowers</span></span></code> </pre> </li><li>  If Tick comes from a ticker, then you need to send your status: <code>P2P.nsendPeers "bees" flowers</code> .  Here ‚Äúbees‚Äù is the name of the service, that is, we send flowers only to those nodes that have registered themselves as ‚Äúbees‚Äù. </li><li>  If we received flowers from some other bee, we need to add all unfamiliar flowers to ourselves, that is, simply combine many new ones with many existing ones. </li></ol><br>  <strong>5.</strong> That's it!  Download the full source code and compile: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">git</span></span> clone https://github.com/SenchoPens/cloud-bees.git cd cloud-bees stack setup <span class="hljs-comment"><span class="hljs-comment"># Stack  GHC stack build # </span></span></code> </pre> <br>  Now run this line in one terminal: <br><br><pre> <code class="hljs javascript">stack exec cloud-bees-exe <span class="hljs-number"><span class="hljs-number">9000</span></span> <span class="hljs-number"><span class="hljs-number">9001</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;<span class="hljs-regexp"><span class="hljs-regexp">/dev/</span></span><span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre> <br>  And in another this: <br><br><pre> <code class="hljs javascript">stack exec cloud-bees-exe <span class="hljs-number"><span class="hljs-number">9001</span></span> <span class="hljs-number"><span class="hljs-number">9000</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;<span class="hljs-regexp"><span class="hljs-regexp">/dev/</span></span><span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre> <br>  REPL will display the prompt.  Try adding <code>Add (1, 2)</code> in one terminal, i.e.  add a flower with coordinates (1, 2), and in another - <code>Show</code> , and you will see that the second node now has such a flower. <br><br><ul><li>  Part <code>2&gt;/dev/null</code> needed to hide the stderr, in which Cloud Haskell displays the log.  If this is not done, then we will not be able to use the REPL normally.  You can replace <code>/dev/null</code> with <code>log.txt</code> and then see what it output. </li></ul><br><hr><br>  I hope we convinced you that creating Haskell distributed systems is not so scary :) <br><br>  You can come up with a lot of real juz-cases for a similar system: for example, solving the problem of hares in public transport: a person passing through the transport on the card is marked as entered (add his id to the first GSet), and exit - as released (add the id in second GSet).  At night (when the transport is not working) a check occurs - if the person entered and left, he is not a hare. <br><br>  If you're interested, you can see our <a href="https://github.com/mreluzeon/block-monad">more extensive project with encryption, which we did during the shift</a> . <br><br><hr><br>  <em>With love, Arseny and company, Grade 9;</em>  <em>under the gentle guidance of <a href="https://habr.com/users/wldhx/" class="user_link">wldhx</a></em> </div><p>Source: <a href="https://habr.com/ru/post/351496/">https://habr.com/ru/post/351496/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351484/index.html">NeoQuest 2018: Cheating and only</a></li>
<li><a href="../351486/index.html">Video conferencing in 7 steps</a></li>
<li><a href="../351488/index.html">Digital events in Moscow from March 19 to March 25</a></li>
<li><a href="../351490/index.html">KOMPAS-3D Home - professional CAD software for home and hobby</a></li>
<li><a href="../351492/index.html">C ++ 20 is getting closer. Meeting in jacksonville</a></li>
<li><a href="../351498/index.html">Use Reflection.Emit to precompile expressions in MSIL</a></li>
<li><a href="../351500/index.html">SellAnyCar: how auto auctions work in the desert</a></li>
<li><a href="../351504/index.html">Introduction to Angular Modules - Root Module</a></li>
<li><a href="../351506/index.html">Where worlds are created: jobs 22 game developers</a></li>
<li><a href="../351510/index.html">Rather simple and effective algorithm for recognition and tracking of movement</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>