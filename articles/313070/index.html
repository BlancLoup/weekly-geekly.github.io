<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Java Continuations</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It is intensely difficult to distinguish ... 

 Grady booch 
 Let's go back a few decades ago and take a look at how the sample programs of those year...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Java Continuations</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  It is intensely difficult to distinguish ... <br><br>  Grady booch </blockquote><br>  Let's go back a few decades ago and take a look at how the sample programs of those years looked like.  Then dominated the imperative approach.  Let me remind you that the name it received due to the total control of the program over the calculation process: the program clearly states what should be done and when.  Like a set of orders of the Emperor.  Most operating systems offered this approach for writing executable programs.  It is widely used to this day, for example, when writing various kinds of utilities.  Moreover, with this approach begins the study of programming in school.  What is the reason for its popularity?  The fact is that the imperative style is very simple and understandable to man.  To master it is not difficult. <br><a name="habracut"></a><br>  Take a look at an example.  I chose Pascal to make the code archaic.  The program prompts you to enter a value for the variable ‚Äúx‚Äù, reads the entered value from the console, then the same for the variable ‚Äúy‚Äù, at the end displays the sum of ‚Äúx‚Äù and ‚Äúy‚Äù.  All actions are initiated by the program - both input and output.  In strict sequence. <br><br><pre><code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(<span class="hljs-string"><span class="hljs-string">'x = '</span></span>); readln(x); <span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(<span class="hljs-string"><span class="hljs-string">'y = '</span></span>); readln(y); writeln(<span class="hljs-string"><span class="hljs-string">'x + y = '</span></span>, x + y); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre> <br>  Now let's rewrite the code a bit and introduce a number of abstractions (yes, the term ‚Äúabstraction‚Äù is not proprietary to the PLO) in order to emphasize the main actions of the program. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> x := receiveArg; y := receiveArg; sendResult(<span class="hljs-string"><span class="hljs-string">'x + y = '</span></span>, x + y); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br>  In fact, entering abstractions where it would seem possible to do without them is another tool for dealing with complexity;  this is all the same encapsulation, even if there are no classes or visibility modifiers.  Later we will remember about this code.  In the meantime, move on. <br><br>  The evolution of operating systems led to the appearance of graphical shells, and the imperative style ceased to be dominant.  Graphic OSs offer a completely different approach to program structure, the so-called.  event-driven approach.  The essence of the approach is that the program is idle most of the time, does nothing and reacts only to ‚Äústimuli‚Äù from the operating system.  The point is that the graphical user interface gives the user simultaneous access to all window controls and we cannot poll them sequentially, as happens in imperative programs.  On the contrary, the program should promptly respond to any user actions with any part of the window, if this is provided by logic or it is expected by the user.  The event-driven approach is not the choice of application developers, it is the choice of OS developers, because  This model allows more efficient use of machine resources.  In addition, the OS assumes the maintenance of the graphical shell and in this sense is a ‚Äúfat‚Äù intermediary between the client and the application programs.  In fact, technically applied programs remain imperative, since  they have an imperative "nucleus", the so-called.  message loop or event loop.  But in most cases this nucleolus is typical and hidden in the depths of the graphic libraries used by programmers. <br><br>  Is the event-driven approach an evolutionary development of software development?  Rather, it is a necessity.  It just turned out to be easier and more economical.  This approach has known drawbacks.  First of all, it is less natural than the imperative approach, and leads to additional overhead, but more on that later.  I started talking about this approach, which is why: the fact is that this approach has spread far beyond the limits of application software.  This is the external interface of most servers.  Roughly speaking, a typical server declares a list of commands that it can execute.  Like an application graphics program, the server is idle until an event command arrives from outside, which it can process.  Why did the event-drive approach migrate to the server architecture?  After all, there are no restrictions on the part of the graphical OS shell.  I think that there are several reasons: first of all, the features of the used network protocols (as a rule, the connection is initiated by the client) and the same need to save machine resources, the consumption of which is easy to regulate in the event-driven approach. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Response </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Request request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (request.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"sum"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = request.get(<span class="hljs-string"><span class="hljs-string">"x"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = request.get(<span class="hljs-string"><span class="hljs-string">"y"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response(x + y); ...</code> </pre><br>  And here I would like to draw attention to one of the major drawbacks of the event-driven approach - this is a large overhead and the absence of explicit abstractions in the code that reflect the logic of the server's behavior.  First of all, I mean the relationship between the various commands that the server declares: not all of them are independent, some must be performed in a certain sequence.  But since  When using event-driven, it is not always possible to reflect the relationship between different operations, there are overhead costs in the form of restoring the context to perform each operation, and in the form of additional checks that are needed to make sure that this operation can be performed.  In other words, in case the protocol implemented by the server is complicated, the saving of resources from using the event-driven approach becomes not so obvious.  But despite this, there are other good reasons for its use: language tools, standards, and used libraries do not leave the developer a choice.  However, then I want to talk about the important changes that have occurred in recent years, and about the fact that this approach fits well with the new reality. <br><br>  Here I must note that the imperative style is also used when writing server-side code: it is quite suitable for p2p connections, or in ‚Äúreal-time‚Äù programs, for example, in games where the amount of resources used is limited, and the speed of response from the server is very important. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { Request request = receive(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (request.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"sum"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = receiveInt(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = receiveInt(); send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response(x + y)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ...</code> </pre><br>  Remember the Pascal code to which I added the receiveArg and sendResult operations.  Agree that it is very similar to what we see in this example: we consistently request arguments and send the result.  The only difference is that here the role of the console is played by the network connection with the client.  Imperative style allows you to get rid of overhead in the processing of related operations.  However, without the use of special mechanisms, which will be discussed later, it more aggressively exploits the resources of the machine, and is unsuitable for the implementation of servers serving more connections.  Judge for yourself: if in the event-driven approach, the flow is allocated to a separate operation, then the flow is allocated at least to the session, the lifetime of which is significantly longer.  Spoiler: aggressive use of resources in the imperative approach is a removable drawback. <br><br>  Now let's take a look at the ‚Äútypical‚Äù server implementation - the code below is not associated with any framework and reflects only the query processing scheme.  As a basis, I took the procedure of registering a new user with confirmation via SMS-code.  Let this procedure consist of two related operations: register and confirm. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Response </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onReceived</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Request request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (request.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"register"</span></span>: User user = registerUser(request); user.confCode = generateConfirmationCode(); sendSms(<span class="hljs-string"><span class="hljs-string">"Confirmation code "</span></span> + user.confCode); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response.ok; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"confirm"</span></span>: String code = request.get(<span class="hljs-string"><span class="hljs-string">"code"</span></span>); User user = lookupUser(request); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (user == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !Objects.equals(code, user.confCode)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response.fail; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user.confirm() ? Response.ok : Response.fail; ...</code> </pre><br><br>  Let's run through the code.  Operation register.  Here we create a new client using data from the request.  But let's think about what the client creation process involves: it is, potentially, a series of calls to one or several external systems (code generation, sending SMS), disk operations.  For example, the operation sendSms, will return control to us only after the SMS message with the code is successfully sent to the user.  Calls to external systems (the delivery time of the request, the time it was processed, the time the result was transferred back) and disk operations take time and will lead to downtime of the current stream.  Note: we bind the generated code to the client (the confCode field).  The fact is that after processing this request, we will leave the handler, and all local variables will be reset.  We also need to save the code for later comparison when the confirm request is received.  When processing it, we first restore the execution context.  These are the overheads that I mentioned. <br><br>  Synchronous processing of requests, as in our example, is associated with an abundance of blocking operations, resulting in downtime of a valuable system resource.  And everything would be fine, but increasing requirements for throughput and response time are imposed on service systems.  Downtime system resources become an unaffordable luxury.  Let's take a look at the chart. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d35/462/d35/d35462d3565b36fc9f08f85bafc62bc2.png" alt="image"></div><br>  Here I made a blocking call.  The shaded area is a simple calling thread.  Is it significant?  Remember the size and number of timeouts used in your system.  They eloquently tell you about the amount of possible downtime.  This is not about milliseconds, but about tens of seconds, and sometimes minutes.  With a load of 1000 TpS, an idle time of 1 second is 1000 operations for the processing of which an additional resource was allocated. <br><br>  What solutions does the industry offer us to increase throughput and decrease response time?  Iron developers, for example, offer multi-core.  Yes, it expands the capabilities of a single machine.  Event-driven approach, thanks to scalability, easily utilizes a new resource.  But the synchronous implementation of query handlers makes the use of threads inefficient.  And here asynchronous calls come to the rescue. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfd/783/ecc/cfd783ecc23d5f47d6b7ae95f54bc95d.png" alt="image"></div><br>  The task of an asynchronous call is to initiate the operation and return control as soon as possible.  The result of the operation we get through the callback function, which is passed as an additional parameter.  Thus, immediately after such a call, we can continue to work, or complete it until the result is received.  Let's modify our example and rewrite it in asynchronous style. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onReceived</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Request request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (request.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"register"</span></span>: registerUser(request, user -&gt; { generateConfirmationCode(code -&gt; { user.confCode = code; sendSms(<span class="hljs-string"><span class="hljs-string">"Confirmation code "</span></span> + code, () -&gt; { reply(Response.ok); }); }); }); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ...</code> </pre><br>  Here I gave only one operation register.  But this is enough to see the main drawback of the asynchronous style: the worst readability of the code, the increase in its size.  Appearances of callbacks, instead of a series of synchronous calls.  This example looks bearable only thanks to lambda.  Without them, it would be more difficult to perceive asynchronous code.  In other words, the Java language is not well adapted to the new requirements.  It does not have the necessary tools that make working with asynchronous code more comfortable. <br><br>  How to be?  Is there a way to keep the comfort of working with synchronous code, and at the same time get rid of its key flaws, using asynchronous mechanisms? <br><br>  Yes, there is such a way. <br><br><h3>  Continuations </h3><br>  Continuations are another mechanism for controlling the progress of a program (in addition to cycles, conditional branches, method calls, etc.), which allows you to suspend the execution of a method at a certain point for an indefinite period, releasing the current flow. <br><br>  Here are the main artifacts of this tool. <br><br><ul><li>  <i>Suspendable method</i> - a method whose execution can be suspended indefinitely and then resumed </li><li>  <i>Coroutine</i> / <i>Fiber</i> retain stack when execution is suspended.  The stack can be transferred over the network to another machine in order to resume execution of the suspended method there. </li><li>  <i>CoIterator</i> allows you to create a type of iterator called generator (implemented in the Mana library) </li></ul><br>  This is not a complete list.  Artifacts such as <i>Channel</i> , <i>Reactive dataflow</i> and <i>Actor</i> are also very curious, but these are topics for individual articles.  Here I will not consider them. <br><br>  Currently, the continuations are supported by a number of web-frameworks.  Common solutions that allow using continuations in Java, unfortunately, can be counted on fingers.  Until recently, they were all for the most part artisanal (experiment) or very obsolete. <br><br><ul><li>  <a href="https://sourceforge.net/projects/jauvm/">Jau VM</a> - add-on over JVM, "experimental" project (2005) </li><li>  <a href="http://commons.apache.org/sandbox/commons-javaflow/">JavaFlow</a> - an attempt to create a capital library, not supported since 2008 </li><li>  <a href="https://code.google.com/archive/p/jyield/">jyield</a> - a small "experimental" project (February 2010) </li><li>  <a href="https://code.google.com/archive/p/coroutines/">coroutines</a> - another ‚Äúpilot‚Äù project (October 2010) </li><li>  <a href="https://github.com/idubrov/jconts">jcont</a> - relatively fresh attempt (2013) </li><li>  <a href="http://www.matthiasmann.de/content/view/24/26/">Continuations library</a> Matisa Mana - the simplest and most successful, in my opinion, solution for Java </li></ul><br>  The concept implemented by Mann is simple and easy to learn.  Unfortunately, it is not currently supported.  In addition, the original article describing the library has literally become unavailable recently. <br><br>  But it is not all that bad.  Gentlemen from <a href="http://docs.paralleluniverse.co/">Parallel Universe</a> , having taken Man‚Äôs library as a basis, reworked it, making its own more weighty version - <a href="http://docs.paralleluniverse.co/quasar/">Quasar</a> . <br><br>  Quasar inherited the main ideas from the Man library, developed them, and added some infrastructure to it.  In addition, at the moment it is the only such solution that works with <nobr>Java 8</nobr> . <br><br>  What gives us this tool?  First of all, we get the opportunity to write asynchronous code, without losing the visibility of synchronous.  Moreover, now we can write server code in imperative style. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { Request request = receive(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (request.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"register"</span></span>: User user = registerUser(request); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> confCode = generateConfirmationCode(); sendSms(<span class="hljs-string"><span class="hljs-string">"Confirmation code "</span></span> + confCode); reply(Response.confirm); String code = receiveConfirmationCode(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Objects.equals(code, confCode) &amp;&amp; user.confirm()) { reply(Response.ok); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reply(Response.fail); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ...</code> </pre><br>  This is an example of the same user registration.  Please note that there is only one option left for the register / confirm pair request: register.  confirm disappeared, because  here we no longer need it.  In this implementation, the minimum overhead: the entire context of the operation is stored in local variables, we do not need to remember the generated code, look around the user again.  After registering it, generating code and sending SMS, we just expect to receive this code from the client and nothing more.  Not a new request with a bunch of extra attributes, but just one code! <br><br>  How does this work?  I propose to start with the library Mana.  The library contains only a few classes, the main of which is Coroutine. <br><br><pre> <code class="java hljs">Coroutine co = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Coroutine(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CoroutineProto() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">coExecute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> SuspendExecution </span></span>{ ... Coroutine.yield(); <span class="hljs-comment"><span class="hljs-comment">// suspend execution ... } }); ... co.run(); // run execution ... co.run(); // resume execution</span></span></code> </pre><br>  Coroutine is, in essence, a shell for Runnable.  More precisely, not for the standard Runnndable, but for the special version of this interface - CoroutineProto.  The task of the coroutine is to preserve the state of the stack at the moments when the execution of the embedded task is suspended.  The Korutins themselves do nothing: the execution of the nested when initiated by the run method, which starts or resumes, after stopping, the execution of the code in the coExecute method.  Control from the run method returns after the coExecute method finishes its work, or suspends it by calling the static method Coroutine.yield.  You can find out about the state of the coExecute method in a call to Couroutine.getState.  The three methods, run, yield, and getState, in fact, describe the entire meaningful interface of the Coroutine class.  Everything is very simple.  Notice the SuspendExecution exception.  First of all, it is a marker indicating that the method may pause.  A special feature of the Mana library is that this exception is actually thrown at the moment of suspension (the only ‚Äúempty‚Äù - without a stack is an instance).  This exception cannot be "strangled".  This is one of the disadvantages of the library. <br><br>  One of the uses of Corutin Man was to create a special kind of iterator: generators.  Apparently, Mana (like his predecessors) was oppressed by the fact that there are support for generators in many languages, including  in C # (yield return, yield break).  In his library, he included a special class CoIterator, which implements the Iterator interface.  To create a generator, you need to examine the CoIterator and implement the abstract suspended run method.  In the CoIterator constructor, a korutin is generated, which feeds the abstract run method. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestIterator</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoIterator</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> SuspendExecution </span></span>{ produce(<span class="hljs-string"><span class="hljs-string">"A"</span></span>); produce(<span class="hljs-string"><span class="hljs-string">"B"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { produce(<span class="hljs-string"><span class="hljs-string">"C"</span></span> + i); } produce(<span class="hljs-string"><span class="hljs-string">"D"</span></span>); produce(<span class="hljs-string"><span class="hljs-string">"E"</span></span>); } }</code> </pre><br>  After Man‚Äôs idea of ‚Äã‚Äãhis library becomes clear, mastering Quasar is easy.  Quasar uses a slightly different terminology.  For example, the Fiber used in Quasar in the role of Korutin is, in fact, a lightweight version of the stream (the term is probably borrowed from the Win API, where the filers have been present for quite some time).  Using it is as easy as using korutiny. <br><br><pre> <code class="java hljs">Fiber fiber = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Fiber (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SuspendableRunnable() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> SuspendExecution, InterruptedException </span></span>{ ... Fiber.park(); <span class="hljs-comment"><span class="hljs-comment">// suspend execution ... } }).start(); // start execution ... fiber.unpark(); // resume execution</span></span></code> </pre><br>  Here we see SuspendExecution already familiar to us.  However, in Quasar, he honestly plays the role of a marker, and is not required.  Instead, you can use the @Suspendable annotation. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Suspendable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> g() * <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(SuspendExecution s) { <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } }</code> </pre><br>  Thus, we get the ability to create suspendable implementations of virtually any interfaces, which the Man library did not allow us to do, requiring the presence of a marker exception. <br><br>  The Quasar library has everything you need to "turn" asynchronous interfaces into pseudo-synchronous, providing the client code with the visibility of synchronous and efficient asynchronous.  In addition, instances of Fiber are serializable, i.e.  and they can be partially performed on different machines: start on one node, pause, transfer over the network to another node, and resume execution there. <br><br>  To understand the power of the faibers, let's imagine the following situation.  Suppose we have a classic server with synchronous processing of requests.  Let us, when processing requests from users, our server from time to time access external resources.  To DB, for example.  Suppose we have allocated 1000 threads for the server to work.  And so, at some point, our external resource began to ‚Äúblunt‚Äù.  In this case, the handlers of new requisitions will begin to freeze when accessing this resource, blocking their flows.  With a high load on the server, the thread pool will be quickly used up, and rejects will begin.  If the thread pool is shared, even those requests that are not related to the external resource will be rejected.  In this case, the server can do nothing at all.  A bottleneck in our entire system was an external resource that could not cope with the load and failed. <br><br>  What will help us faybery?  Fiber turns our synchronous handler into asynchronous.  Now, when accessing an external resource, we can calmly return the thread to the pool, and request only a little memory from the machine to save the current execution stack.  When a response comes from an external resource, we will take a free stream in the pool, restore the stack and continue processing the request.  Beauty! <br><br>  But here it is necessary to make a reservation: it will all work only if the interface to an external resource is asynchronous.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, a lot of libraries provide only a synchronous interface. </font><font style="vertical-align: inherit;">A typical JDBC example. </font><font style="vertical-align: inherit;">But it should be noted that Java is moving in the direction of asynchrony. </font><font style="vertical-align: inherit;">Old interfaces are rewritten (NIO, AIO, CompletableFuture, Servlet 3.0), new ones are often asynchronous initially (Netty, ZooKeeper). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, I would very much like to see progress in this direction on the part of Oracle. </font><font style="vertical-align: inherit;">The work </font></font><a href="http://bugs.java.com/bugdatabase/view_bug.do%3Fbug_id%3D6655643"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is underway</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but very slowly, and in the next version of Java, full-time support for the continuations should not be expected. </font><font style="vertical-align: inherit;">Hopefully, the Quasar library will not remain unique, and we will see many more interesting solutions that make writing asynchronous code simple and convenient.</font></font></div><p>Source: <a href="https://habr.com/ru/post/313070/">https://habr.com/ru/post/313070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../313058/index.html">Architecture and programming computer Texas Instruments TI-99 / 4a</a></li>
<li><a href="../313062/index.html">Programming & Music: Buttervo Frequency Filter. Part 3</a></li>
<li><a href="../313064/index.html">Customer support operator, manager, programmer</a></li>
<li><a href="../313066/index.html">Overview of options for implementing failover clusters: Stratus, VMware, VMmanager Cloud</a></li>
<li><a href="../313068/index.html">Media: German military hacked into the network of the Afghan mobile operator to find out the whereabouts of the hostage</a></li>
<li><a href="../313072/index.html">New podcast about computer science</a></li>
<li><a href="../313076/index.html">Artem Kukharenko, the founder of NTechLab - about face recognition, the potential of neural networks and business</a></li>
<li><a href="../313078/index.html">FreePBX: first steps on rake</a></li>
<li><a href="../313080/index.html">Divide and Conquer: Multidimensional Security Policies</a></li>
<li><a href="../313082/index.html">Work not from the office - to be or not to be, that is the question</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>