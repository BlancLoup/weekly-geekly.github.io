<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unrolled linked list in Java</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. 

 From time to time, like most programmers, I study some new structures and algorithms. 

 This time, I came across articles on cache obliviou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unrolled linked list in Java</h1><div class="post__text post__text-html js-mediator-article">  Hello. <br><br>  From time to time, like most programmers, I study some new structures and algorithms. <br><br>  This time, I came across articles on cache oblivious algorithms.  These are algorithms that are initially more optimized for working with the caching subsystem of modern processors. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      One of the representatives of this group is the Unrolled linked list. <br><br>  What is it? <br><a name="habracut"></a><br>  To understand what it is and what it is eaten with, I suggest recalling the most popular implementations of lists: ArrayList (with some simplification, we will talk about arrays instead of the list itself) and LinkedList. <br><br>  Consider their main advantages and disadvantages: <br><br>  <b>ArrayList</b> : <br><br>  <b>Virtues</b> <br><ul><li>  Compactness ‚Äî an array is the most (at least one of) compact data structures for representing lists; </li><li>  The insertion speed at the end of an empty array is a very fast operation, fact !; </li><li>  The speed of taking an element by index is also very high, the number of cache miss can be estimated at N / B, where B is the size of the cache line, and N is the number of array elements, which can be considered a reference for this kind of structure. </li></ul><br><br>  <b>disadvantages</b> <br><ul><li>  Inserting in the middle is not a very convenient operation for an array, you have to shift the right-hand side, which, even with arraycopy, is not free; </li><li>  The length of the memory area - to store large arrays requires a large continuous chunk of memory.  And while many garbage collectors effectively deal with memory fragmentation, the likelihood of OutOfMemmory especially for large lists is essential. </li></ul><br><br>  <b>LinkedList</b> : <br><br>  <b>Virtues</b> <br><ul><li>  Relatively simpler and faster insertion into the middle; </li><li>  No problem when working with highly fragmented memory. </li></ul><br><br>  <b>disadvantages</b> <br><ul><li>  Significantly larger amount of necessary memory for storing data of the same size (up to 4 times); </li><li>  When iterating through the list, the number of cache miss in the worst case may be equal to the number of nodes in the list.  Even in the best case, when all the nodes are in memory one after another, due to the larger size of the node, the amount of cache miss will be several times larger than that for ArrayList. </li></ul><br><br>  So, UnrolledLinkedList tries to combine the merits of the two lists without inheriting their disadvantages. <br>  Consider the device of this list in more detail. <br><br>  In simple terms, UnrolledLinkedList is a connected (doubly-connected) list of arrays of length n.  That is, each node contains not one value, but an array of values.  At the same time, the array is small enough for insertion and deletion operations to be very fast and memory fragmentation had less influence on the ability to create a node, but large enough to fit completely into the cache line to reduce the number of cache miss.  Additionally, each node stores the number of elements added to it.  Graphically, this list can be represented as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d54/3b0/9c6/d543b09c633b46989e6baf8c1fcfa082.png" alt="image"><br><br>  Consider the operations for this list: <br><br>  <b>Insert in the node:</b> <br>  In the case of free cells, a new element is simply added to the end of the array.  If the array is already full, then we create a new node for the current one and transfer the right half of the array to it, thereby creating a place to insert new values.  A new item in this case will be inserted at the end of the new node.  The same can be applied to the insert in the middle of the array. <br><br>  Graphically, this operation can be represented as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b4d/7de/071/b4d7de0715ed116a4eab7d54529a8328.png" alt="image"><br><br>  <b>Remove from node:</b> <br>  The operation is quite simple, we simply remove the desired element from the array and make the shift of the remaining elements, if necessary.  But there is one thing, but if the number of elements in the array decreases to n / 2, then n / 2 elements are transferred from the neighboring cells.  If after this one of the cells is empty, it is deleted.  This operation is needed to reduce memory consumption with the gradual clearing of large lists. <br><br>  <b>Search node by index:</b> <br>  As in the coherent list, the search begins with a head or tail, from which it is closer, the difference is that there is no need to iterate over arrays - you just need to summarize the values ‚Äã‚Äãof the fields containing the number of elements in the node.  Thus, the search for the desired node is much faster than in LinkedList, although the asymptotic behavior is still O (N). <br><br>  Initially it seemed to me that half of the empty cells in each node is too wasteful.  However, as shown by small experiments, the average cell fill level is 70%, and even with a 50% fill, the memory consumption should be significantly less than that of the linked list.  Moreover, the list allows you to customize yourself for various needs.  I tried to play with the fill factor of the array, but did not extract significant benefits, so I left everything as it is. <br><br>  Speaking about the number of cache miss, when iterating over such a list, it can be estimated as (N / n + 1) (n / B), where N is the list length, n is the length of the node array, B is the length of the cache line.  This estimate is quite close to the estimate for ArrayList. <br><br>  At the time of writing, I also had the idea that such a list could be a fairly effective implementation of a concurrent collection with the ability to block only one node.  However, this is a topic for a new study and a new article. <br><br>  Sources are posted on <a href="https://github.com/Falland/UnrolledList">github</a> . <br>  They are a rather crude code, so please do not kick your feet for quality.  However, in any case, I would appreciate any criticism. <br><br>  There are some attempts in the source code to measure and compare different lists, but I‚Äôm embarrassed to present them in the article, because I‚Äôm not so sure that all measurements were made correctly and I didn‚Äôt shoot myself in the leg.  I would be very happy with the help of experts in the field of benchmarking for the final placement of points above the lists! <br><br>  Thanks for attention. <br><br>  Sources: <br>  <a href="http://blogs.msdn.com/b/devdev/archive/2005/08/22/454887.aspx">blogs.msdn.com/b/devdev/archive/2005/08/22/454887.aspx</a> <br>  <a href="http://en.wikipedia.org/wiki/Unrolled_linked_list">en.wikipedia.org/wiki/Unrolled_linked_list</a> <br><br>  UPD: Still got to measure performance and size.  For microbenchmarking, I used the Google caller caliper. <br>  Here are the results: <br>  Linear iteration <br>  length benchmark us linear runtime <br>  1000 UnrolledListIteration 6.34 = <br>  1000 ArrayListIteration 5.56 = <br>  1000 LinkedListIteration 5.93 = <br>  100,000 UnrolledListIteration 827.68 == <br>  100,000 ArrayListIteration 637.05 = <br>  100,000 LinkedListIteration 1124.38 == <br>  1,000,000 UnrolledListIteration 9056,77 ======================= <br>  1,000,000 ArrayListIteration 6731,73 ================= <br>  1,000,000 LinkedListIteration 11800,96 ============================== <br><br>  Random Access: <br>  length benchmark us linear runtime <br>  1000 UnrolledListIteration 6.34 = <br>  1000 ArrayListIteration 5.53 = <br>  1000 LinkedListIteration 5.97 = <br>  100,000 UnrolledListIteration 844.30 == <br>  100,000 ArrayListIteration 652.21 = <br>  100,000 LinkedListIteration 1106.90 === <br>  1,000,000 UnrolledListIteration 9066,88 ========================== <br>  1,000,000 ArrayListIteration 6723.21 =================== <br>  1000000 LinkedListIteration 10339,15 ============================= <br><br>  Size of: <br>  ArrayList is 45172432,000 bytes // This is not fair results, but the memory consumption is indicative of a gradual increase in volume. <br>  ArrayList with lenght 1KK is 24000064,000 bytes <br>  UnrolledList is 26250048,000 bytes <br>  LinkedList is 56000048,000 bytes <br><br>  These are the results that are consistent with the theory) <br>  The repository is updated, everyone who wants to get acquainted with the updates or run their tests - you are welcome. </div><p>Source: <a href="https://habr.com/ru/post/149918/">https://habr.com/ru/post/149918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../149913/index.html">Maemo-MeeGo story</a></li>
<li><a href="../149914/index.html">Turn the Raspberry Pi into a retro gaming console</a></li>
<li><a href="../149915/index.html">State services. Registration of SP or all is not so transparent</a></li>
<li><a href="../149916/index.html">How to make Time Machine back up to a network drive</a></li>
<li><a href="../149917/index.html">Do you listen to music while working?</a></li>
<li><a href="../149919/index.html">Some features of VimL</a></li>
<li><a href="../149921/index.html">McDonald's is testing PayPal order payment system.</a></li>
<li><a href="../149922/index.html">The list of Russian scientific journals on information technology</a></li>
<li><a href="../149923/index.html">OnLive officially announced the transfer of its assets to the new owner</a></li>
<li><a href="../149925/index.html">IEEE is preparing a 1Tbps Ethernet standard</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>