<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Some dictionary internals in CPython (and PyPy)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The internal structure of dictionaries in Python is not limited to bucket and closed hashing alone. This is an amazing world of shared keys, caching h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Some dictionary internals in CPython (and PyPy)</h1><div class="post__text post__text-html js-mediator-article">  The internal structure of dictionaries in Python is not limited to bucket and closed hashing alone.  This is an amazing world of shared keys, caching hashes, DKIX_DUMMY and quick comparisons that can be made even faster (at the cost of a bug with an approximate probability of 2 ^ -64). <br><br>  If you do not know the number of elements in the newly created dictionary, how much memory is spent on each element, why now (CPython 3.6 and later) the dictionary is implemented with two arrays and how does this relate to maintaining the insertion order, or simply did not watch the presentation of Raymond Hettinger ‚ÄúModern Python Dictionaries A confluence of a great dozen great ideas. ‚Äù  Then welcome. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xrBiThaASEE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  However, people familiar with the lecture may also find some details and up-to-date information, and for completely newbies who are not familiar with buckets and closed hashing, the article will also be interesting. <br><a name="habracut"></a><br>  CPython dictionaries are everywhere, classes, global variables, kwargs parameters are based on them, the <a href="https://habr.com/post/418305/">interpreter creates thousands of dictionaries</a> , even if you yourself have not added a single curly brace to your script.  But for solving many applied tasks, dictionaries are also used, it is not surprising that their implementation continues to improve and become increasingly overgrown with various tricks. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Basic implementation of dictionaries (via Hashmap) </h2><br>  If you are familiar with how standard Hashmap and private hashing work, you can proceed to the next chapter. <br><br>  The idea behind the dictionaries is simple: if we have an array in which objects of the same size are stored, then we can easily access the necessary object, knowing the index. <br><br><img src="https://habrastorage.org/webt/wq/m3/nk/wqm3nkortrkb_eyjwlorn4ahreq.png"><br><br>  We simply add an index multiplied by the size of the object to the offset of the array, and get the address of the desired object. <br><br>  But what if we want to organize a search not by an integer index, but by a variable of another type, for example, to find users at their email address? <br><br>  In the case of a simple array, we will have to look through the mail of all users in the array and compare them with the desired one, this approach is called linear search and, obviously, it is much slower than accessing an object by index. <br><br>  Linear searches can be significantly accelerated if we limit the size of the area in which to search.  This is usually achieved by taking the remainder of the <a href="https://ru.wikipedia.org/wiki/%25D0%25A5%25D0%25B5%25D1%2588%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">hash</a> .  The field for which the search is carried out - key. <br><br><img src="https://habrastorage.org/webt/hn/1l/f4/hn1lf445vm6bnorbgvx7n5mbfos.png"><br><br>  As a result, linear search is carried out not over the entire large array, but according to its part. <br><br>  But what if there is already an element there?  This could very well happen, since no one guaranteed that the remains of the hash division would be unique (like the hash itself).  In this case, the object will be placed at the next index, if it is also occupied, it will be shifted by one more index and so until it finds a free one.  When retrieving an item, all keys with the same hash will be viewed. <br><br><img src="https://habrastorage.org/webt/8a/0d/uj/8a0dujuj4hduhrbihtpomacvg0i.png"><br><br>  This type of hashing is called closed.  If there are few free cells in the dictionary, then such a search threatens to degenerate into a linear one, respectively, we lose all the gain, for which the dictionary was created, to avoid this, the interpreter keeps the array filled 1/2 - 2/3.  If there are not enough free cells, then a new array is created twice as large as the previous one and the elements from the old one are transferred to the new one by one. <br><br>  What to do if the item has been deleted?  In this case, an empty cell is formed in the array and the search algorithm by the key cannot distinguish, this cell is empty because there was no element with such a hash in the dictionary, or because it was deleted.  To avoid data loss during deletion, a cell is marked with a special flag (DKIX_DUMMY).  If this flag is encountered during the search for an element, the search will continue, the cell is considered to be occupied, and if inserted, the cell will be overwritten. <br><br><h2>  Implementation Features in Python </h2><br>  Each dictionary element must contain a link to the target object and a key.  The key must be stored for handling collisions, the object - for obvious reasons.  Since both the key and the object can be of any type and size, we cannot store them directly in the structure, they are in dynamic memory, and references to them are stored in the structure of the list element.  That is, the size of one element must be at least equal to the size of two pointers (16 bytes on 64-bit systems).  However, the interpreter also stores the hash, this is done in order not to recompute it with each increase in the size of the dictionary.  Instead of calculating the hash of each key in a new way and taking the remainder of dividing by the number of buckets, the interpreter simply reads the already stored value.  But what if the key object was changed?  In this case, the hash should be recalculated and the stored value will be incorrect?  Such a situation is impossible, since mutable types cannot be dictionary keys. <br><br>  The structure of the dictionary element is defined as follows: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> Py_hash_t me_hash; <span class="hljs-comment"><span class="hljs-comment">//  PyObject *me_key; //    PyObject *me_value; //     } PyDictKeyEntry;</span></span></code> </pre> <br>  The minimum dictionary size is declared constant PyDict_MINSIZE, which is equal to 8. The developers decided that this is the optimal size in order to avoid unnecessary memory consumption for storing null values ‚Äã‚Äãand time for dynamic expansion of the array.  Thus, when creating a dictionary (prior to version 3.6), you needed at least 8 elements in the dictionary * 24 bytes in the structure = 192 bytes (this is without taking into account the other fields: expenses for a dictionary-like variable itself, a count of the number of elements, etc.) <br><br>  Dictionaries are also used to implement custom class fields.  Python allows you to dynamically change the number of attributes, this dynamic does not require additional costs, since adding / deleting an attribute is essentially equivalent to the corresponding dictionary operation.  However, this functionality is used by a minority of programs, the majority is limited to the fields declared in __init__.  But each object must keep its dictionary, with its keys and hashes, despite the fact that they coincide with other objects.  The logical improvement here is the storage of shared keys in only one place, and this is exactly what was implemented in the <a href="https://www.python.org/dev/peps/pep-0412/">PEP 412 - Key-Sharing Dictionary</a> .  The ability to dynamically change the dictionary did not disappear: if the order changes or the number of keys is changed, the dictionary is converted from the dividing keys to the usual one. <br><br>  To avoid collisions, the maximum ‚Äúload‚Äù of the dictionary is 2/3 of the current size of the array. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USABLE_FRACTION(n) (((n) &lt;&lt; 1)/3)</span></span></code> </pre> <br>  Thus, the first expansion will occur after the addition of the 6th element. <br><br>  The array turns out to be quite discharged, while the program runs from half to one third of the cells remain empty, which leads to increased memory consumption.  In order to circumvent this restriction and, if possible, to store only the necessary data, a new <s>level of abstraction</s> array was added. <br><br>  Instead of storing a flat array, for example: <br><br><pre> <code class="python hljs"> d = {<span class="hljs-string"><span class="hljs-string">'timmy'</span></span>: <span class="hljs-string"><span class="hljs-string">'red'</span></span>, <span class="hljs-string"><span class="hljs-string">'barry'</span></span>: <span class="hljs-string"><span class="hljs-string">'green'</span></span>, <span class="hljs-string"><span class="hljs-string">'guido'</span></span>: <span class="hljs-string"><span class="hljs-string">'blue'</span></span>} <span class="hljs-comment"><span class="hljs-comment"># -&gt; entries = [['--', '--', '--'], [-8522787127447073495, 'barry', 'green'], ['--', '--', '--'], ['--', '--', '--'], ['--', '--', '--'], [-9092791511155847987, 'timmy', 'red'], ['--', '--', '--'], [-6480567542315338377, 'guido', 'blue']]</span></span></code> </pre><br>  Starting from version 3.6 dictionaries are organized as follows: <br><br><pre> <code class="python hljs"> indices = [<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>] entries = [[<span class="hljs-number"><span class="hljs-number">-9092791511155847987</span></span>, <span class="hljs-string"><span class="hljs-string">'timmy'</span></span>, <span class="hljs-string"><span class="hljs-string">'red'</span></span>], [<span class="hljs-number"><span class="hljs-number">-8522787127447073495</span></span>, <span class="hljs-string"><span class="hljs-string">'barry'</span></span>, <span class="hljs-string"><span class="hljs-string">'green'</span></span>], [<span class="hljs-number"><span class="hljs-number">-6480567542315338377</span></span>, <span class="hljs-string"><span class="hljs-string">'guido'</span></span>, <span class="hljs-string"><span class="hljs-string">'blue'</span></span>]]</code> </pre><br>  Those.  only those records that are really needed are stored, they are moved from the hash table to a separate array, and only the indexes of the corresponding records are stored in the hash table.  If initially the array took 192 bytes, then now only 80 (3 * 24-bytes for each record + 8 bytes per indices).  58% compression achieved. [2] <br><br>  The element size in indices also changes dynamically, initially it is equal to one byte, that is, the entire array can be placed in one register, when the index starts not getting into 8 bits, then the elements expand to 16, then to 32 bits.  There are special constants DKIX_EMPTY and DKIX_DUMMY, for the empty and deleted elements, respectively, the expansion of the indexes to 16 bytes occurs when the elements in the dictionary becomes more than 127. <br><br>  New objects are added to the entries, that is, when expanding the dictionary, there is no need to move them, you just need to increase the size of indices and refill it with indices. <br><br>  When iterating over the dictionary, the array of indices is not needed, the elements are sequentially returned from the entries, since  elements are added to the end of the entries each time, the dictionary automatically saves the order of entries.  Thus, in addition to reducing the required memory for storing the dictionary, we obtained faster dynamic expansion and preservation of the order of the keys.  Reducing memory is good in and of itself, but at the same time it can increase speed, as it allows a greater number of entries to get into the processor‚Äôs cache. <br><br>  CPython developers liked this implementation so much that dictionaries are now required to maintain the insertion order according to the specification.  If earlier the order of dictionaries was determined, i.e.  it was strictly defined by the hash and was unchanged from launch to launch, then a bit of randomness was added to it, so that the keys went differently each time, now the dictionary keys are required to maintain order.  How much it was necessary, and what to do if there will be an even more efficient implementation of the dictionary, but not preserving the order of insertion, is unclear. <br><br>  However, and so there were requests to implement a mechanism for preserving the order of attribute declaration in <a href="https://www.python.org/dev/peps/pep-0520/">classes</a> and in <a href="https://www.python.org/dev/peps/pep-0468/">kwargs</a> , this implementation makes it possible to close these problems without special mechanisms. <br><br>  This is what <a href="">CPython</a> looks like: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dictkeysobject</span></span></span><span class="hljs-class"> {</span></span> Py_ssize_t dk_refcnt; <span class="hljs-comment"><span class="hljs-comment">/* Size of the hash table (dk_indices). It must be a power of 2. */</span></span> Py_ssize_t dk_size; <span class="hljs-comment"><span class="hljs-comment">/* Function to lookup in the hash table (dk_indices): - lookdict(): general-purpose, and may return DKIX_ERROR if (and only if) a comparison raises an exception. - lookdict_unicode(): specialized to Unicode string keys, comparison of which can never raise an exception; that function can never return DKIX_ERROR. - lookdict_unicode_nodummy(): similar to lookdict_unicode() but further specialized for Unicode string keys that cannot be the &lt;dummy&gt; value. - lookdict_split(): Version of lookdict() for split tables. */</span></span> dict_lookup_func dk_lookup; <span class="hljs-comment"><span class="hljs-comment">/* Number of usable entries in dk_entries. */</span></span> Py_ssize_t dk_usable; <span class="hljs-comment"><span class="hljs-comment">/* Number of used entries in dk_entries. */</span></span> Py_ssize_t dk_nentries; <span class="hljs-comment"><span class="hljs-comment">/* Actual hash table of dk_size entries. It holds indices in dk_entries, or DKIX_EMPTY(-1) or DKIX_DUMMY(-2). Indices must be: 0 &lt;= indice &lt; USABLE_FRACTION(dk_size). The size in bytes of an indice depends on dk_size: - 1 byte if dk_size &lt;= 0xff (char*) - 2 bytes if dk_size &lt;= 0xffff (int16_t*) - 4 bytes if dk_size &lt;= 0xffffffff (int32_t*) - 8 bytes otherwise (int64_t*) Dynamically sized, SIZEOF_VOID_P is minimum. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> dk_indices[]; <span class="hljs-comment"><span class="hljs-comment">/* char is required to avoid strict aliasing. */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* "PyDictKeyEntry dk_entries[dk_usable];" array follows: see the DK_ENTRIES() macro */</span></span> };</code> </pre><br>  But the iteration is more complicated than one could initially think of, there are additional mechanisms for checking that the dictionary was not changed during the iteration, one of them is the <a href="https://www.python.org/dev/peps/pep-0509/">version of the dictionary</a> as a 64-bit number that each dictionary stores. <br><br>  Finally, consider the mechanism for resolving collisions.  The fact is that in python, hash values ‚Äã‚Äãare easily predictable: <br><br><pre> <code class="python hljs"> &gt;&gt;&gt;[hash(i) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">4</span></span>)] [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre><br>  And since during the creation of the dictionary from these hashes, the remainder of the division is taken, then in essence it determines in which bucket the record will go, only the last few bits of the key (if it is integer).  You can imagine a situation where we have a lot of objects ‚Äúwant‚Äù to get into neighboring buckets, in this case, when searching, we will have to look through a lot of objects that are not in their proper places.  To reduce the number of collisions and increase the number of bits that determine which batch the recording will go to, the following mechanism has been implemented: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//   i = i + 1 % n //   : #define PERTURB_SHIFT 5 perturb &gt;&gt;= PERTURB_SHIFT; j = (5*j) + 1 + perturb; //   j % n    </span></span></code> </pre><br>  perturb is an integer variable initialized by a hash.  It should be noted that in case of a large number of collisions, it is reset to zero and the following index is calculated by the formula: <br><br><pre> <code class="cpp hljs"> j = (<span class="hljs-number"><span class="hljs-number">5</span></span> * j + <span class="hljs-number"><span class="hljs-number">1</span></span>) % n</code> </pre><br>  When an item is retrieved from the dictionary, the same search is performed: the slot index is calculated in which the item should be located, if the slot is empty, then the exception ‚Äúvalue not found‚Äù is thrown.  If there is a value in this slot, it is necessary to check that its key corresponds to the required one, this may well not be executed if a collision occurs.  However, almost any object can be the key, including one for which the comparison operation takes considerable time.  In order to avoid a lengthy comparison operation, several tricks have been applied in Python: <br><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment">#   (   ,  C) def eq(key, entity): if id(key) == id(entity): return True if hash(key) != hash(entity): return False return key == entity</span></span></code> </pre><br>  Pointers are compared first, if the key pointer of the object being searched for is equal to the pointer of the object being searched, that is, pointing to the same memory area, then the comparison immediately returns true.  But that's not all.  As you know, equal objects should have equal hashes, which means that objects with different hashes are not equal.  After checking the pointers, hashes are checked, if they are not equal, false is returned.  And only if the hashes are equal, an honest comparison will be called. <br><br>  What is the probability of such an outcome?  Approximately 2 ^ -64, of course, due to the light predictability of the hash value, you can easily find an example, but in reality, this check doesn‚Äôt happen often, how much?  Raymond Hettinger put together an interpreter by modifying the last comparison operation with a simple return true.  Those.  the interpreter considered objects equal if their hashes are equal.  After that, he set automated tests on such an interpreter for many popular projects that were completed successfully.  It may seem strange to consider objects with equal hashes equal, not to additionally check their contents, and to rely solely on the hash, but you do it regularly when using git or torrent protocols.  They consider files (file blocks) equal, if their hashes are equal, which may well lead to errors, but their creators (and all of us) hope that it is worth noting, not unreasonably, that the probability of a collision is extremely small. <br><br>  Now you should have a definitive structure of the dictionary, which looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> PyObject_HEAD <span class="hljs-comment"><span class="hljs-comment">/* Number of items in the dictionary */</span></span> Py_ssize_t ma_used; <span class="hljs-comment"><span class="hljs-comment">/* Dictionary version: globally unique, value change each time the dictionary is modified */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ma_version_tag; PyDictKeysObject *ma_keys; <span class="hljs-comment"><span class="hljs-comment">/* If ma_values is NULL, the table is "combined": keys and values are stored in ma_keys. If ma_values is not NULL, the table is splitted: keys are stored in ma_keys and values are stored in ma_values */</span></span> PyObject **ma_values; } PyDictObject;</code> </pre><br><h2>  Future changes </h2><br>  In the previous chapter, we considered what has already been implemented and can be used by everyone in their work, but the improvements are not limited to these: plans for version 3.8 are <a href="https://docs.python.org/dev/whatsnew/3.8.html">support for reversed dictionaries</a> .  Indeed, instead of iterating from the beginning of the array of elements and increasing the indices, nothing prevents us from starting at the end and decreasing the indices. <br><br><h2>  Additional materials </h2><br>  For a deeper immersion in the topic, it is recommended to read the following materials: <br><br><ol><li>  Record of the report at the beginning of the article </li><li>  <a href="https://mail.python.org/pipermail/python-dev/2012-December/123028.html">Proposal for a new implementation of dictionaries</a> </li><li>  <a href="">CPython dictionary source code</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/432996/">https://habr.com/ru/post/432996/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../432986/index.html">C vs Go cycles and simple math</a></li>
<li><a href="../432988/index.html">Eighth Webmaster. Live on Habr√©</a></li>
<li><a href="../432990/index.html">Edison Wooden Lamp with voice control. Issue price of $ 5</a></li>
<li><a href="../432992/index.html">Put on headphones and died: we deal with the strange death of a schoolboy in Rembau</a></li>
<li><a href="../432994/index.html">Vivaldi 2.2 - Quantity, turning into quality</a></li>
<li><a href="../432998/index.html">Christmas story</a></li>
<li><a href="../433000/index.html">Compiling Kotlin: JetBrains VS ANTLR VS JavaCC</a></li>
<li><a href="../433002/index.html">Go yourself on ... or the rules of communication in a team</a></li>
<li><a href="../433004/index.html">Reliable cloud migration strategy in 2019: 7 tips</a></li>
<li><a href="../433008/index.html">USB devices - "sudden" threat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>