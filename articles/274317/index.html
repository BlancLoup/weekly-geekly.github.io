<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Sinon.js - mock-library for JavaScript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sinon.js is a JavaScript mock library that can be used with any test framework. It provides functions for emulating and testing the desired behavior i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Sinon.js - mock-library for JavaScript</h1><div class="post__text post__text-html js-mediator-article">  Sinon.js is a JavaScript mock library that can be used with any test framework.  It provides functions for emulating and testing the desired behavior in JavaScript.  The library has three types of testing with spy, stub and mock.  In this post, we will look at the Sinon.js API documentation along with a brief introduction to the concept of the methods of this library. <br><br><img src="https://habrastorage.org/files/65f/f58/f12/65ff58f123fa431a99aa5b19f416ea04.jpg"><br><a name="habracut"></a><br><h4>  Spy </h4><br>  Spy is a function that records the arguments, the return value, the initial value, and the errors returned (if any) for all calls.  Test spy can be an anonymous function or can be created on top of an existing function. <br><br>  Test spies are useful to check callbacks and how certain functions / methods are used throughout the system during tests.  The following simplified example shows how to use spies to test processing a callback function: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"test should call subscribers on publish"</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callback = sinon.spy(); PubSub.subscribe(<span class="hljs-string"><span class="hljs-string">"message"</span></span>, callback); PubSub.publishSync(<span class="hljs-string"><span class="hljs-string">"message"</span></span>); assertTrue(callback.called); }</code> </pre> <br><br>  Sinon.spy can also monitor existing functions.  When executing the original function, it will behave just as normal, but you will have access to data about all the calls.  The following is a slightly abstract example. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">setUp</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ sinon.spy(jQuery, <span class="hljs-string"><span class="hljs-string">"ajax"</span></span>); }, <span class="hljs-attr"><span class="hljs-attr">tearDown</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ jQuery.ajax.restore(); <span class="hljs-comment"><span class="hljs-comment">// Unwraps the spy }, "test should inspect jQuery.getJSON's usage of jQuery.ajax": function () { jQuery.getJSON("/some/resource"); assert(jQuery.ajax.calledOnce); assertEquals("/some/resource", jQuery.ajax.getCall(0).args[0].url); assertEquals("json", jQuery.ajax.getCall(0).args[0].dataType); } }</span></span></code> </pre><br><h4>  Spyware creation: sinon.spy () </h4><br> <b><u><code>var spy = sinon.spy();</code></u></b> <br>  Specifies an anonymous function that records the arguments of the current value, error messages, and return value arguments for all calls. <br> <b><u><code>var spy = sinon.spy(myFunc);</code></u></b> <br>  Creates a spy on top of the finished function. <br> <b><u><code>var spy = sinon.spy(object, "method");</code></u></b> <br>  Creates a spy for <code>object.method</code> and replaces the original method.  It acts exactly the same as the original version in all cases.  The original method can be restored using <code>object.method.restore ()</code> . <br><br><h4>  Spy api </h4><br>  Spy provides a wide interface for controlling their use.  The examples above showed the logical property <code>calledOnce</code> , as well as the <code>getCall</code> method and the arguments of the returned object.  There are three ways to check call data. <br><br>  The most preferred approach is to use the method <code>calledWith</code> , since it saves your test from unnecessary specifics.  After all, you don‚Äôt always need to know how many times a function call was made; sometimes the return value data is enough. <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"test should call subscribers with message as first argument"</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> message = <span class="hljs-string"><span class="hljs-string">'an example message'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spy = sinon.spy(); PubSub.subscribe(message, spy); PubSub.publishSync(message, <span class="hljs-string"><span class="hljs-string">"some payload"</span></span>); assert(spy.calledWith(message)); }</code> </pre><br>  If you want more specificity, you can directly check the first parameter of the first call.  The following methods will help you do this: <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"test should call subscribers with message as first argument"</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> message = <span class="hljs-string"><span class="hljs-string">'an example message'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spy = sinon.spy(); PubSub.subscribe(message, spy); PubSub.publishSync(message, <span class="hljs-string"><span class="hljs-string">"some payload"</span></span>); assertEquals(message, spy.args[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre><br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"test should call subscribers with message as first argument"</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> message = <span class="hljs-string"><span class="hljs-string">'an example message'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spy = sinon.spy(); PubSub.subscribe(message, spy); PubSub.publishSync(message, <span class="hljs-string"><span class="hljs-string">"some payload"</span></span>); assertEquals(message, spy.getCall(<span class="hljs-number"><span class="hljs-number">0</span></span>).args[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre><br><br>  The first example uses a two-dimensional array of arguments directly on the spy, while the second example selects the first value of the call, and then refers to its argument.  Which way to use is a matter of preference, but it is recommended to use the <code>spy.calledWith (arg1, arg2...)</code> approach <code>spy.calledWith (arg1, arg2...)</code> if there is no need to make the tests more detailed. <br><br><div class="spoiler">  <b class="spoiler_title">Spy api</b> <div class="spoiler_text">  Spy object or object returned from <code>sinon.spy()</code> .  When tracking existing methods with <code>sinon.spy (object, method)</code> , the following properties and methods are also available for use on <code>object.method</code> . <br><br> <b><u><code>spy.withArgs(arg1[, arg2, ...]);</code></u></b> <br>  Creates a spy that records calls only when the received arguments match those passed for <code>withArgs</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"should call method once with each argument"</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spy = sinon.spy(object, <span class="hljs-string"><span class="hljs-string">"method"</span></span>); spy.withArgs(<span class="hljs-number"><span class="hljs-number">42</span></span>); spy.withArgs(<span class="hljs-number"><span class="hljs-number">1</span></span>); object.method(<span class="hljs-number"><span class="hljs-number">42</span></span>); object.method(<span class="hljs-number"><span class="hljs-number">1</span></span>); assert(spy.withArgs(<span class="hljs-number"><span class="hljs-number">42</span></span>).calledOnce); assert(spy.withArgs(<span class="hljs-number"><span class="hljs-number">1</span></span>).calledOnce); }</code> </pre><br> <b><u><code>spy.callCount</code></u></b> <br>  Displays the number of calls registered. <br> <b><u><code>spy.called</code></u></b> <br>  Provides confirmation if spy was called at least once. <br> <b><u><code>spy.calledOnce</code></u></b> <br>  Provides confirmation if spy was called only once. <br> <b><u><code>spy.calledTwice</code></u></b> <br>  Provides confirmation if spy was called only two times. <br> <b><u><code>spy.calledThrice</code></u></b> <br>  Provides confirmation if spy was called only three times. <br> <b><u><code>spy.firstCall</code></u></b> <br>  First call <br> <b><u><code>spy.secondCall</code></u></b> <br>  Second call <br> <b><u><code>spy.thirdCall</code></u></b> <br>  The third challenge. <br> <b><u><code>spy.lastCall</code></u></b> <br>  Last call. <br> <b><u><code>spy.calledBefore(anotherSpy);</code></u></b> <br>  Gives confirmation if the spy was called before <code>anotherSpy</code> . <br> <b><u><code>spy.calledAfter(anotherSpy);</code></u></b> <br>  Gives confirmation if the spy was called after <code>anotherSpy</code> . <br> <b><u><code>spy.calledOn(obj);</code></u></b> <br>  Gives confirmation if the spy was called at least once with obj as this. <br> <b><u><code>spy.alwaysCalledOn(obj);</code></u></b> <br>  Returns a confirmation if the spy is always called with obj like this. <br> <b><u><code>spy.calledWith(arg1, arg2, ...);</code></u></b> <br>  Gives confirmation if the spy is called at least once with the arguments provided.  It can be executed even in case of partial coincidence, Sinon checks only the arguments provided against the actual arguments, thus getting a match with the provided arguments (in the same places) will issue a confirmation. <br> <b><u><code>spy.alwaysCalledWith(arg1, arg2, ...);</code></u></b> <br>  Gives confirmation if the spy is always called with the provided arguments (and partly with others). <br> <b><u><code>spy.alwaysCalledWithExactly(arg1, arg2, ...);</code></u></b> <br>  Gives confirmation if the spy is always called in full compliance with the arguments provided. <br> <b><u><code>spy.calledWithMatch(arg1, arg2, ...);</code></u></b> <br>  Gives confirmation if the spy is always called with the provided arguments (and partly with others).  It behaves just like <code>spy.calledWith(sinon.match(arg1), sinon.match(arg2), ...)</code> . <br> <b><u><code>spy.alwaysCalledWithMatch(arg1, arg2, ...);</code></u></b> <br>  Gives confirmation if the spy is always called with the provided arguments.  It behaves just like <code>spy.alwaysCalledWith(sinon.match(arg1), sinon.match(arg2), ...)</code> . <br> <b><u><code>spy.calledWithNew();</code></u></b> <br>  Gives confirmation if spy / stub was called by a new operator.  Remember that this is a result based on the value of this object and the prototype of the spy function; this can give a false positive result if you actively return the correct object type. <br> <b><u><code>spy.neverCalledWith(arg1, arg2, ...);</code></u></b> <br>  Displays if spy / stub has never been called with the provided arguments. <br> <b><u><code>spy.neverCalledWithMatch(arg1, arg2, ...);</code></u></b> <br>  Gives confirmation if spy / stub has never been called with a large value provided by the arguments.  It behaves just like <code>spy.neverCalledWith(sinon.match(arg1), sinon.match(arg2), ...).</code>  . <br> <b><u><code>spy.threw();</code></u></b> <br>  Gives confirmation if the spy issued an exception at least once. <br> <b><u><code>spy.threw("TypeError");</code></u></b> <br>  Gives confirmation if the spy has thrown an exception for the specified type, at least once. <br> <b><u><code>spy.threw(obj);</code></u></b> <br>  Gives confirmation if the spy has thrown an exception for the specified object at least once. <br> <b><u><code>spy.alwaysThrew();</code></u></b> <br>  Gives confirmation if the spy always threw an exception. <br> <b><u><code>spy.alwaysThrew("TypeError");</code></u></b> <br>  Gives confirmation if the spy always throws an exception for the specified type. <br> <b><u><code>spy.alwaysThrew(obj);</code></u></b> <br>  Returns a confirmation if the spy always throws exceptions for the specified object. <br> <b><u><code>spy.returned(obj);</code></u></b> <br>  Returns a confirmation if the spy returns the specified value at least once.  Uses deep comparison for objects and arrays.  Use spy.returned (sinon.match.same (obj)) for a strict comparison. <br> <b><u><code>spy.alwaysReturned(obj);</code></u></b> <br>  Gives confirmation if the spy always returns the specified value. <br> <b><u><code>var spyCall = spy.getCall(n);</code></u></b> <br>  Displays the nth [call] (# spycall).  Provides access to individual calls, helps to more closely check the behavior if the spy is called more than once.  Example: <br><br><pre> <code class="javascript hljs">sinon.spy(jQuery, <span class="hljs-string"><span class="hljs-string">"ajax"</span></span>); jQuery.ajax(<span class="hljs-string"><span class="hljs-string">"/stuffs"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spyCall = jQuery.ajax.getCall(<span class="hljs-number"><span class="hljs-number">0</span></span>); assertEquals(<span class="hljs-string"><span class="hljs-string">"/stuffs"</span></span>, spyCall.args[<span class="hljs-number"><span class="hljs-number">0</span></span>]);</code> </pre><br> <b><u><code>spy.thisValues</code></u></b> <br>  The area for the <code>spy.thisValues[0]</code> object represents the object for the first call. <br> <b><u><code>spy.args</code></u></b> <br>  The argument array <code>spy.args [0]</code> is an array with the arguments obtained in the first call. <br> <b><u><code>spy.exceptions</code></u></b> <br>  The array for issued exceptions <code>spy.exceptions[0]</code> presents the exceptions issued by the first call.  If the call did not generate an error, the value in the <code>.exceptions</code> field will be <code>'undefined'</code> . <br> <b><u><code>spy.returnValues</code></u></b> <br>  The array of returned values, <code>spy.returnValues[0]</code> is the return value of the first call.  If the call returned an <code>.returnValues</code> field value in <code>.returnValues</code> would be <code>'undefined'</code> . <br> <b><u><code>spy.reset()</code></u></b> <br>  Resets the spy status. <br> <b><u><code>spy.printf(format string", [arg1, arg2, ...])`</code></u></b> <br>  Returns the transmitted sequence format with the following substitutions: <br><ul><li>  #n: spy name ("spy" by default) </li><li>  #s: how many times the spy was called in words (‚Äúonce‚Äù, ‚Äútwice‚Äù, etc.) </li><li>  #C: list of consecutive spy calls, each call is marked with a new line prefix and four spaces </li><li>  #t: a comma delimited list of values ‚Äã‚Äãwith which the spy was called </li><li>  #: n formatted value of the nth argument passed to printf </li><li>  # *: a comma-separated list of (non-formatted sequences) arguments passed to printf </li></ul><br><h4>  Individual spy calls </h4><br> <b><u><code>var spyCall = spy.getCall(n)</code></u></b> <br>  Provides nth <code>[call](#spycall)</code> .  Access to individual calls helps with more detailed behavioral testing when a spy is called several times.  Example: <br><br><pre> <code class="javascript hljs">sinon.spy(jQuery, <span class="hljs-string"><span class="hljs-string">"ajax"</span></span>); jQuery.ajax(<span class="hljs-string"><span class="hljs-string">"/stuffs"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spyCall = jQuery.ajax.getCall(<span class="hljs-number"><span class="hljs-number">0</span></span>); assertEquals(<span class="hljs-string"><span class="hljs-string">"/stuffs"</span></span>, spyCall.args[<span class="hljs-number"><span class="hljs-number">0</span></span>]);</code> </pre><br> <b><u><code>spyCall.calledOn(obj);</code></u></b> <br>  Provides confirmation if the object was relevant for this call. <br> <b><u><code>spyCall.calledWith(arg1, arg2, ...);</code></u></b> <br>  Provides confirmation if the call received the provided arguments (possibly similar). <br> <b><u><code>spyCall.calledWithExactly(arg1, arg2, ...);</code></u></b> <br>  Provides confirmation if the call received the provided arguments and no other. <br> <b><u><code>spyCall.calledWithMatch(arg1, arg2, ...);</code></u></b> <br>  Provides confirmation if the call received the provided arguments (possibly similar).  It behaves just like <code>spyCall.calledWith (sinon.match (arg1), sinon.match (arg2)...).</code> <br> <b><u><code>spyCall.notCalledWith(arg1, arg2, ...);</code></u></b> <br>  Provides acknowledgment if the call did not receive the provided arguments. <br> <b><u><code>spyCall.notCalledWithMatch(arg1, arg2, ...);</code></u></b> <br>  Provides acknowledgment if the call did not receive the provided arguments.  It behaves just like <code>spyCall.notCalledWith(sinon.match(arg1), sinon.match(arg2), ...).;</code> <br> <b><u><code>spyCall.threw();</code></u></b> <br>  Provides confirmation if the call issued an error. <br> <b><u><code>spyCall.threw(TypeError");</code></u></b> <br>  Provides confirmation if the call issued an error of the specified type. <br> <b><u><code>spyCall.threw(obj);</code></u></b> <br>  Provides confirmation if the call issued an error for the intended object. <br> <b><u><code>spyCall.thisValue</code></u></b> <br>  Challenges to the value of <code>this</code> . <br> <b><u><code>spyCall.args</code></u></b> <br>  Array of arguments received. <br> <b><u><code>spyCall.exception</code></u></b> <br>  The issued exception (error), if any. <br> <b><u><code>spyCall.returnValue</code></u></b> <br>  Return value. <br></div></div><br><h4>  Stubs </h4><br>  Stubs (stubs) are functions with preprogrammed behavior.  They fully support the spyware API in addition to methods that can be used to change the behavior of stubs. <br><br>  Like spies, stubs can be anonymous or wrap existing functions.  When wrapping an existing function with a cap, the original function is not called. <br><br>  Use stubs is worth when you want: <br><ol><li>  Control the behavior of the test and force the code to issue an error at some point  Examples include forcing error output methods to verify its processing. </li><li>  If you want to prevent an immediate call to a specific method (perhaps because it causes undesirable behavior, for example, <code>XMLHttpRequest</code> or similar). </li></ol><br>  The following example is another PubSubJS test by Morgan Roderick, which shows how to create an anonymous stub that gives an error when called. <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"test should call all subscribers, even if there are exceptions"</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> message = <span class="hljs-string"><span class="hljs-string">'an example message'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> error = <span class="hljs-string"><span class="hljs-string">'an example error message'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stub = sinon.stub().throws(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spy1 = sinon.spy(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spy2 = sinon.spy(); PubSub.subscribe(message, stub); PubSub.subscribe(message, spy1); PubSub.subscribe(message, spy2); PubSub.publishSync(message, <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>); assert(spy1.called); assert(spy2.called); assert(stub.calledBefore(spy1)); }</code> </pre><br>  Please note that the plugs are also included in the spy interface.  The test verifies that all necessary callbacks were called and the stub produced an error for the current call before the new call. <br><br><h5>  Determining the behavior of stubs on consecutive calls </h5><br>  Repeated calls to certain behaviors, such as <code>returns</code> or <code>throws</code> override the stub behavior.  Starting with Sinon 1.8, you can use the &lt;codeonCall &lt;/ code method to get a different response from a stub on consecutive calls. <br><br>  Note that in Sinon versions 1.5 and 1.7, multiple calls for <code>yields*</code> and <code>callsArg*</code> are a family of methods for defining a behavioral series during successive calls. <br><br><div class="spoiler">  <b class="spoiler_title">Stub API</b> <div class="spoiler_text"> <b><u><code>var stub = sinon.stub();</code></u></b> <br>  Creates an anonymous stub function. <br> <b><u><code>var stub = sinon.stub(object, "method");</code></u></b> <br>  Replaces <code>object.method</code> with a stub function.  The original function can be restored by calling <code>object.method.restore ();</code>  or <code>stub.restore ();</code>  .  An error may be issued if the properties are not related to the function ‚Äî this is done to avoid typing errors when using the stub. <br> <b><u><code>var stub = sinon.stub(object, "method", func);</code></u></b> <br>  Replaces <code>object.method</code> and <code>func</code> wrapped by spy.  Commonly used <code>object.method.restore ();</code>  to restore the original method. <br> <b><u><code>var stub = sinon.stub(obj);</code></u></b> <br>  Stub for the specified object.  Note that the method of individual stubs is the best practice for use on objects that you do not understand or those that control all methods (for example, depending on the library).  The method of individual stubs tests the behavior of an object more accurately and less susceptible to unexpected behavior during changes in the object's code. <br><br>  If you want to create a stub object for <code>MyConstructor</code> , but do not want the constructor to be called, use this utility function: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stub = sinon.createStubInstance(MyConstructor)</code> </pre><br> <b><u><code>stub.withArgs(arg1[, arg2, ...]);</code></u></b> <br>  The stub method is for specified arguments only.  This method is useful for gaining more expression in your statements, where you can access the spy with the same challenge.  It is also useful to create a stub that may act differently in response to various parameters. <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"test should stub method differently based on arguments"</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callback = sinon.stub(); callback.withArgs(<span class="hljs-number"><span class="hljs-number">42</span></span>).returns(<span class="hljs-number"><span class="hljs-number">1</span></span>); callback.withArgs(<span class="hljs-number"><span class="hljs-number">1</span></span>).throws(<span class="hljs-string"><span class="hljs-string">"TypeError"</span></span>); callback(); <span class="hljs-comment"><span class="hljs-comment">// No return value, no exception callback(42); // Returns 1 callback(1); // Throws TypeError }</span></span></code> </pre><br> <b><u><code>stub.onCall(n);</code></u></b> <br>  <i>Added to Sinon.JS 1.8.</i> <br>  Defines the behavior of a stub on an nth call.  Useful for testing sequential interactions. <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"test should stub method differently on consecutive calls"</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callback = sinon.stub(); callback.onCall(<span class="hljs-number"><span class="hljs-number">0</span></span>).returns(<span class="hljs-number"><span class="hljs-number">1</span></span>); callback.onCall(<span class="hljs-number"><span class="hljs-number">1</span></span>).returns(<span class="hljs-number"><span class="hljs-number">2</span></span>); callback.returns(<span class="hljs-number"><span class="hljs-number">3</span></span>); callback(); <span class="hljs-comment"><span class="hljs-comment">// Returns 1 callback(); // Returns 2 callback(); // All following calls return 3 }</span></span></code> </pre><br>  There are ways such as <code>onFirstCall, onSecondCall, onThirdCall</code> , to make reading certain stubs more natural. <br>  <code>`onCall`</code> can be combined with all the methods defining the behavior in this section.  In particular, it can be used with <code>'withArgs'</code> . <br><br><pre> <code class="actionscript hljs"><span class="hljs-string"><span class="hljs-string">"test should stub method differently on consecutive calls with certain argument"</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callback = sinon.stub(); callback.withArgs(<span class="hljs-number"><span class="hljs-number">42</span></span>) .onFirstCall().returns(<span class="hljs-number"><span class="hljs-number">1</span></span>) .onSecondCall().returns(<span class="hljs-number"><span class="hljs-number">2</span></span>); callback.returns(<span class="hljs-number"><span class="hljs-number">0</span></span>); callback(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Returns 0 callback(42); // Returns 1 callback(1); // Returns 0 callback(42); // Returns 2 callback(1); // Returns 0 callback(42); // Returns 0 }</span></span></code> </pre><br>  Notice how the stub behavior for argument 42 returns to the default behavior once the calls are no longer defined. <br> <b><u><code>stub.onFirstCall();</code></u></b> <br>  Nickname for stub.onCall (0); <br> <b><u><code>stub.onSecondCall();</code></u></b> <br>  Nickname for stub.onCall (1); <br> <b><u><code>stub.onThirdCall();</code></u></b> <br>  Nickname for stub.onCall (2); <br> <b><u><code>stub.returns(obj);</code></u></b> <br>  Causes the stub to return the specified object. <br> <b><u><code>stub.returnsArg(index);</code></u></b> <br>  Causes the stub to return an argument with the specified index. <code>stub.callsArg (0);</code>  causes the stub to return the primary argument. <br> <b><u><code>stub.returnsThis();</code></u></b> <br>  The stub returns the value of <code>this</code> . <br> <b><u><code>stub.throws();</code></u></b> <br>  Causes the stub to throw an exception (Error). <br> <b><u><code>stub.throws("TypeError");</code></u></b> <br>  Causes the stub to produce an error of the specified type. <br> <b><u><code>stub.throws(obj);</code></u></b> <br>  Causes the stub to generate an error for the specified object. <br> <b><u><code>stub.callsArg(index);</code></u></b> <br>  Causes the stub to invoke the argument at the specified index as a callback function. <code>stub.callsArg (0);</code>  causes the stub to invoke the primary argument, like a callback. <br> <b><u><code>stub.callsArgOn(index, context);</code></u></b> <br>  Runs just like <code>stub.callsArg(index);</code>  , but with an additional parameter for passing <code>this</code> context. <br> <b><u><code>stub.callsArgWith(index, arg1, arg2, ...);</code></u></b> <br>  It is executed in the same way as callsArg, but with arguments to pass to the callback function. <br> <b><u><code>stub.callsArgOnWith(index, context, arg1, arg2, ...);</code></u></b> <br>  It is executed exactly the same as <code>stub.callsArgWith(index, arg1, arg2, ...);</code>  , but with an additional parameter for passing <code>this</code> context. <br> <b><u><code>stub.yields([arg1, arg2, ...])</code></u></b> <br>  It behaves almost the same as callsArg.  Causes the stub to invoke the first callback it receives with the specified arguments (if any).  If the method accepts more than one callback, you need to use callsArg, so that the stub has the ability to call other callbacks other than the first. <br> <b><u><code>stub.yieldsOn(context, [arg1, arg2, ...])</code></u></b> <br>  It is executed exactly the same as <code>stub.yieldsOn(context, [arg1, arg2, ...]);</code>  , but with an additional parameter for passing <code>this</code> context. <br> <b><u><code>stub.yieldsTo(property, [arg1, arg2, ...])</code></u></b> <br>  Causes the spy to call the callback passed as a property of the object to the spy.  Just like <code>yields, yieldsTo</code> takes the first matching argument, finds the callback and calls it with (optional) arguments. <br> <b><u><code>stub.yieldsToOn(property, context, [arg1, arg2, ...])</code></u></b> <br>  It is executed in the same way as <code>stub.yieldsTo(property, [arg1, arg2, ...]);</code>  , but with an additional parameter for passing <code>this</code> context. <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"test should fake successful ajax request"</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ sinon.stub(jQuery, <span class="hljs-string"><span class="hljs-string">"ajax"</span></span>).yieldsTo(<span class="hljs-string"><span class="hljs-string">"success"</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]); jQuery.ajax({ <span class="hljs-attr"><span class="hljs-attr">success</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ assertEquals([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], data); } }); }</code> </pre><br> <b><u><code>stub.yield([arg1, arg2, ...])</code></u></b> <br>  Calls callbacks sent to a stub with the specified parameters.  If the stub is never called with the specified function arguments, the <code>yield</code> will <code>invokeCallback</code> error, with the alias <code>invokeCallback</code> . <br> <b><u><code>stub.yieldTo(callback, [arg1, arg2, ...])</code></u></b> <br>  Calls callbacks passed as a property of an object to a spy.  Just like <code>yields, yieldsTo</code> takes the first matching argument, finds the callback and calls it with (optional) arguments. <br> <b><u><code>stub.callArg(argNum)</code></u></b> <br>  Just like <code>yield</code> , but with the exact argument number, the defining callback to be called again.  Useful if the function is called with more than one callback, and simply calling the first callback is not required. <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"calling the last callback"</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callback = sinon.stub(); callback(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Success!"</span></span>); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Oh noes!"</span></span>); }); callback.callArg(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Logs "Oh noes!" }</span></span></code> </pre><br> <b><u><code>stub.callArgWith(argNum, [arg1, arg2, ...])</code></u></b> <br>  Like <code>stub.callArg(argNum)</code> , but with arguments. <br> <b><u><code>stub.callsArgAsync(index);</code></u></b> <br>  Performs the same as the corresponding synchronous duplicate, but with a postponed callback (which is executed not immediately, but after a short timeout, and in another ‚Äúthread‚Äù). <br><br> <b><u><code>stub.callsArgAsync(index);</code></u></b> <br> <b><u><code>stub.callsArgOnAsync(index, context);</code></u></b> <br> <b><u><code>stub.callsArgWithAsync(index, arg1, arg2, ...);</code></u></b> <br> <b><u><code>stub.callsArgOnWithAsync(index, context, arg1, arg2, ...);</code></u></b> <br> <b><u><code>stub.yieldsAsync([arg1, arg2, ...])</code></u></b> <br> <b><u><code>stub.yieldsOnAsync(context, [arg1, arg2, ...])</code></u></b> <br> <b><u><code>stub.yieldsToAsync(property, [arg1, arg2, ...])</code></u></b> <br> <b><u><code>stub.yieldsToOnAsync(property, context, [arg1, arg2, ...])</code></u></b> <br>  They are executed in the same way as their corresponding synchronous duplicates, but with a postponed callback (which is executed a immediately, but after a short timeout and in another ‚Äúthread‚Äù) <br><br></div></div><br><h4>  Mocks </h4><br>  Mocks (imitation) are imitation methods (like spies) with preprogrammed behavior (like a stub), as well as preprogrammed waiting.  Simulation will not be able to perform the test if it is not used exactly as expected. <br><br>  Simulations can only be used for the test method.  In each unit testing there must be at least one unit in the testing process.  To control how this block is used and to set the expected result (as opposed to statements obtained after the fact), use an imitation. <br><br>  Simulations are completed with the test expectations that you set, which can lead to the failure of the entire test.  Thus, the test imposes execution details.  There is a simple rule: if you do not add an assertion for some calls, do not imitate them.  Better use a stub instead.  In any case, you should not have more than one simulation (possibly with several specified expectations) in one test. <br><br>  Expectations can use both spy and stub APIs. <br><br>  To see how imitation looks in Sinon.JS, here is one example of PubSubJS.  This time, using the callback method and how its behavior is checked using imitation: <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"test should call all subscribers when exceptions"</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myAPI = { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spy = sinon.spy(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mock = sinon.mock(myAPI); mock.expects(<span class="hljs-string"><span class="hljs-string">"method"</span></span>).once().throws(); PubSub.subscribe(<span class="hljs-string"><span class="hljs-string">"message"</span></span>, myAPI.method); PubSub.subscribe(<span class="hljs-string"><span class="hljs-string">"message"</span></span>, spy); PubSub.publishSync(<span class="hljs-string"><span class="hljs-string">"message"</span></span>, <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>); mock.verify(); assert(spy.calledOnce); }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Mocks api</b> <div class="spoiler_text"> <b><u><code>var mock = sinon.mock(obj);</code></u></b> <br>  Creates a simulation for the specified object.  The object itself does not change, but it wraps a mock object to set expectations on the object's methods. <br> <b><u><code>var expectation = mock.expects("method");</code></u></b> <br>  Overrides <code>obj.method</code> with a simulation function and returns it. <br> <b><u><code>mock.restore();</code></u></b> <br>  Restores all simulation methods. <br> <b><u><code>mock.verify();</code></u></b> <br>  Searches for the specified imitation.  If the specified simulation was not detected, an error message is displayed.  In addition, it helps to restore imitation methods. <br></div></div><br><h4>  Expectations </h4><br>  All expectations methods (expectations) return expectations.  This means that you can chain them together.  Typical use: <br><pre> <code class="javascript hljs">sinon.mock(jQuery).expects(<span class="hljs-string"><span class="hljs-string">"ajax"</span></span>).atLeast(<span class="hljs-number"><span class="hljs-number">2</span></span>).atMost(<span class="hljs-number"><span class="hljs-number">5</span></span>); jQuery.ajax.verify();</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Expectations API</b> <div class="spoiler_text"> <b><u><code>var expectation = sinon.expectation.create([methodName]);</code></u></b> <br>  Creates a wait without a mock = object, basically it is an anonymous simulation function.          ,     . <br> <b><u><code>var expectation = sinon.mock();</code></u></b> <br>      <code>var expectation = sinon.expectation.create([methodName]);</code> <br> <b><u><code>expectation.atLeast(number);</code></u></b> <br>     . <br> <b><u><code>expectation.atMost(number);</code></u></b> <br>     . <br> <b><u><code>expectation.never();</code></u></b> <br> ,       . <br> <b><u><code>expectation.once();</code></u></b> <br> ,        . <br> <b><u><code>expectation.twice();</code></u></b> <br> ,       . <br> <b><u><code>expectation.thrice();</code></u></b> <br> ,       . <br> <b><u><code>expectation.exactly(number);</code></u></b> <br> ,        . <br> <b><u><code>expectation.withArgs(arg1, arg2, ...);</code></u></b> <br> ,        ( ). <br> <b><u><code>expectation.withExactArgs(arg1, arg2, ...);</code></u></b> <br> ,          . <br> <b><u><code>expectation.on(obj);</code></u></b> <br> ,      <code>obj</code>  <code>this</code> . <br> <b><u><code>expectation.verify();</code></u></b> <br>      ,      . <br></div></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fake timers </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fake timers are a synchronous implementation of setTimeout and Sinon.JS helpers, which can overwrite global functions and allow you to more easily test code using them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To use fake timers with IE, you need to install sinon-ie-1.17.2 immediately after installing sinon-1.17.2.js. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For offline use of fake timers, it is recommended to use the lolex package. </font><font style="vertical-align: inherit;">This provides the same functional set and was previously extracted from Sinon.JS.</font></font><br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">setUp</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clock = sinon.useFakeTimers(); }, <span class="hljs-attr"><span class="hljs-attr">tearDown</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clock.restore(); }, <span class="hljs-string"><span class="hljs-string">"test should animate element over 500ms"</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> el = jQuery(<span class="hljs-string"><span class="hljs-string">"&lt;div&gt;&lt;/div&gt;"</span></span>); el.appendTo(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body); el.animate({ <span class="hljs-attr"><span class="hljs-attr">height</span></span>: <span class="hljs-string"><span class="hljs-string">"200px"</span></span>, <span class="hljs-attr"><span class="hljs-attr">width</span></span>: <span class="hljs-string"><span class="hljs-string">"200px"</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clock.tick(<span class="hljs-number"><span class="hljs-number">510</span></span>); assertEquals(<span class="hljs-string"><span class="hljs-string">"200px"</span></span>, el.css(<span class="hljs-string"><span class="hljs-string">"height"</span></span>)); assertEquals(<span class="hljs-string"><span class="hljs-string">"200px"</span></span>, el.css(<span class="hljs-string"><span class="hljs-string">"width"</span></span>)); } }</code> </pre><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fake timers API</font></font></b> <div class="spoiler_text"> <b><u><code>var clock = sinon.useFakeTimers();</code></u></b> <br> Sinon   <code>setTimeout, setInterval, clearTimeout, clearInterval</code>     ,      .     UNIX    . <br> <b><u><code>var clock = sinon.useFakeTimers(now);</code></u></b> <br>     ,     ,               <code>(now)</code> . <br> <b><u><code>var clock = sinon.useFakeTimers([now, ]prop1, prop2, ...);</code></u></b> <br>        .   ‚Äî <code>setTimeout, clearTimeout, setInterval</code> , <code>clearInterval</code> ,  .       . <br> <b><u><code>clock.tick(ms);</code></u></b> <br>     <code>ms</code>    .     ,       . <br> <b><u><code>clock.restore();</code></u></b> <br>   .   <code>tearDown</code> <br></div></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fake XMLHttpRequest </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It provides a fake implementation </font></font><code>XMLHttpRequest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and provides several interfaces for managing the objects it creates. </font><font style="vertical-align: inherit;">Also forges its own </font></font><code>XMLHttpRequest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>ActiveXObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Helps with testing queries executed with XHR. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To use XHR with IE, you need to install sinon-ie-1.17.2 immediately after installing sinon-1.17.2.js. The </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fake server and XHR can be used completely autonomously, provided that sinon-server-1.17.2 is loaded. </font><font style="vertical-align: inherit;">When using a fake server in IE, you also need sinon-1.17.2. </font><font style="vertical-align: inherit;">Download it after sinon-server-1.17.2.</font></font><br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">setUp</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.xhr = sinon.useFakeXMLHttpRequest(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> requests = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requests = []; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.xhr.onCreate = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xhr</span></span></span><span class="hljs-function">) </span></span>{ requests.push(xhr); }; }, <span class="hljs-attr"><span class="hljs-attr">tearDown</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.xhr.restore(); }, <span class="hljs-string"><span class="hljs-string">"test should fetch comments from server"</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callback = sinon.spy(); myLib.getCommentsFor(<span class="hljs-string"><span class="hljs-string">"/some/article"</span></span>, callback); assertEquals(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requests.length); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requests[<span class="hljs-number"><span class="hljs-number">0</span></span>].respond(<span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json"</span></span> }, <span class="hljs-string"><span class="hljs-string">'[{ "id": 12, "comment": "Hey there" }]'</span></span>); assert(callback.calledWith([{ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-attr"><span class="hljs-attr">comment</span></span>: <span class="hljs-string"><span class="hljs-string">"Hey there"</span></span> }])); } }</code> </pre><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sinon.useFakeXMLHttpRequest</font></font></b> <div class="spoiler_text"> <b><u><code>var xhr = sinon.useFakeXMLHttpRequest();</code></u></b> <br> Sinon   XMLHttpRequest        ,      .  ,   <code>ActiveXObject</code> ,         progID XMLHTTP.  progID,   XMLDOM,  . <br><br>   XMLHttpRequest    sinon.xhr. XMLHttpRequest. <br><br> <b><u><code>xhr.onCreate = function (xhr) {};</code></u></b> <br>   onCreate     <code><code>useFakeXMLHttpRequest ()&lt;/code.     FakeXMLHttpRequest</code>   .     API    XHR.    ,          jQuery.ajax (  /) <br> <b><u><code>xhr.restore();</code></u></b> <br>   (). <br></code> <br><div class="spoiler"> <b class="spoiler_title">FakeXMLHttpRequest</b> <div class="spoiler_text"> <b><u><code>String request.url</code></u></b> <br> URL-    . <br> <b><u><code>String request.method</code></u></b> <br>    . <br> <b><u><code>Object request.requestHeaders</code></u></b> <br>      , ..: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"Accept"</span></span>: <span class="hljs-string"><span class="hljs-string">"text/html, */*"</span></span>, <span class="hljs-string"><span class="hljs-string">"Connection"</span></span>: <span class="hljs-string"><span class="hljs-string">"keep-alive"</span></span> }</code> </pre><br> <b><u><code>String request.requestBody</code></u></b> <br>  . <br> <b><u><code>int request.status</code></u></b> <br>  .   ,      . <br> <b><u><code>String request.statusText</code></u></b> <br> ,     . <br> <b><u><code>boolean request.async</code></u></b> <br>      . <br> <b><u><code>String request.username</code></u></b> <br>  ,   . <br> <b><u><code>String request.password</code></u></b> <br> ,   . <br> <b><u><code>Document request.responseXML</code></u></b> <br>   ,          . <br> <b><u><code>String request.getResponseHeader(header);</code></u></b> <br>       ,           . <br> <b><u><code>Object request.getAllResponseHeaders();</code></u></b> <br>        . <br></div></div><br><h4>   </h4><br>   Sinon.JS     / ,                   .    <code>FakeXMLHttpRequest</code> (  Sinon 1.3.0)     : <br><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"> <b><u><code>FakeXMLHttpRequest.useFilters</code></u></b> <br>     . Sinon   ,           . <br> <b><u><code>FakeXMLHttpRequest.addFilter(fn)</code></u></b> <br>   ,  ,     ‚Äî   .   ,  <code>xhr.open</code>      (, URL, ,  , ).    ,     . <br></div></div><br><h4>    </h4><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"> <b><u><code>request.setResponseHeaders(object);</code></u></b> <br>   , , <code>{ "Content-Type": "text/html", /* ... */ }</code> ,   <code>readyState</code>   <code>onreadystatechange</code> . <br> <b><u><code>request.setResponseBody(body);</code></u></b> <br>   ,   <code>readyState</code>   <code>onreadystatechange</code> .    <code>responseXML</code>   ,    . <br> <b><u><code>request.respond(status, headers, body);</code></u></b> <br>           <code>statusText</code> .    ,       <code>sinon. FakeXMLHttpRequest.statusCodes</code> . <br> <b><u><code>Boolean request.autoRespond</code></u></b> <br>     ,          -.-    10 ,         <code>autoRespondAfter</code> . <br><br>    ,    ,             . <br><br> <b><u><code>Number request.autoRespondAfter</code></u></b> <br>   ,         .     10 . <br></div></div><br><h4> FakeServe </h4><br> API      <code>FakeXMLHttpRequest</code> <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">setUp</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.server = sinon.fakeServer.create(); }, <span class="hljs-attr"><span class="hljs-attr">tearDown</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.server.restore(); }, <span class="hljs-string"><span class="hljs-string">"test should fetch comments from server"</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.server.respondWith(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-string"><span class="hljs-string">"/some/article/comments.json"</span></span>, [<span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json"</span></span> }, <span class="hljs-string"><span class="hljs-string">'[{ "id": 12, "comment": "Hey there" }]'</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callback = sinon.spy(); myLib.getCommentsFor(<span class="hljs-string"><span class="hljs-string">"/some/article"</span></span>, callback); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.server.respond(); sinon.assert.calledWith(callback, [{ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-attr"><span class="hljs-attr">comment</span></span>: <span class="hljs-string"><span class="hljs-string">"Hey there"</span></span> }]); } }</code> </pre><br><div class="spoiler"> <b class="spoiler_title">API FakeServe</b> <div class="spoiler_text"> <b><u><code>var server = sinon.fakeServer.create([config]);</code></u></b> <br>   .     <code>sinon.useFakeXMLHttpRequest ()</code> . /      . <br> <b><u><code>var server = sinon.fakeServerWithClock.create();</code></u></b> <br>  ,    .      XHR,   , , jQuery 1.3.x    <code>onreadystatechange</code> . jQuery 1.3.x  ,      <br> <b><u><code>server.configure(config)</code></u></b> <br>   .      . <br> <b><u><code>server.respondWith(response);</code></u></b> <br>     : <br><br><ul><li> ,    </li><li>   ,    , , <code>[200, { "Content-Type": "text/html", "Content-Length": 2 }, "OK"]</code> </li><li> . </li></ul><br><br>     200      .     <code>[404, {}, ""]</code> <br><br>    ,      .       ,    . <br><br> <b><u><code>server.respondWith(url, response);</code></u></b> <br>       URL, , <code>/posts/1</code> <br> <b><u><code>server.respondWith(method, url, response);</code></u></b> <br>        URL   .  ‚Äî  HTTP. <br> <b><u><code>server.respondWith(urlRegExp, response);</code></u></b> <br> URL    , , <code>/\/post\//\d+</code> .               <code>XMLHttpRequest</code> . <br><pre> <code class="javascript hljs">server.respondWith(<span class="hljs-regexp"><span class="hljs-regexp">/\/todo-items\/(\d+)/</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xhr, id</span></span></span><span class="hljs-function">) </span></span>{ xhr.respond(<span class="hljs-number"><span class="hljs-number">200</span></span>, { ?Content-Type?: ?application/json? }, ?[{ ?id?: ? + id + ? }]?); });</code> </pre><br> <b><u><code>server.respondWith(method, urlRegExp, response);</code></u></b> <br>      URL-,    . <br> <b><u><code>server.respond();</code></u></b> <br>      ,   .         <code>respondWith</code> ,    <code>[404, {}, ""]</code> .      ,  ,  <code>respondWith</code>  .     , <code>respondWith</code>           . <br> <b><u><code>server.autoRespond = true;</code></u></b> <br>    ‚Äî          -. -    10 ,        <code>autoRespondAfter</code> .    ,                .      respondImmediately  . <br> <b><u><code>server.autoRespondAfter = ms;</code></u></b> <br>         -. <br> <b><u><code>server.respondImmediately = true;</code></u></b> <br>  ,        .                  .       , . server.autoRespond  server.autoRespondAfter. <br> <b><u><code>Boolean `server.fakeHTTPMethods`</code></u></b> <br>   ,   <code>method</code>    POST      .  ,    Ruby  Rails.     HTTP   server.getHTTPMethod. <br> <b><u><code>server.getHTTPMethod(request)</code></u></b> <br> ,    HTTP,    .       <code>request.method</code> .  <code>server.fakeHTTPMethods</code>  ,     <code>_method</code> ,     POST.         . <br> <b><u><code>server.restore();</code></u></b> <br>   XHR . <br></div></div><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text">            : <br><br><pre> <code class="javascript hljs">server.autoRespond = <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br>          <code>fakeServer.create</code>  <code>.configure</code> . <br><br> <b><u><code>boolean autoRespond</code></u></b> <br>         -. -    10 ,        <code>autoRespondAfter</code> .    ,    ,             .         . <br> <b><u><code>int autoRespondAfter (ms)</code></u></b> <br>          -. <br> <b><u><code>boolean respondImmediately</code></u></b> <br>        .    ,            .       , . <code>server.autoRespond</code>  <code>server.autoRespondAfter</code> . <br> <b><u><code>boolean fakeHTTPMethods</code></u></b> <br>   _method    POST      .  ,    Ruby  Rails.     HTTP   <code>server.getHTTPMethod</code> . <br></div></div><br><h4> JSON-P </h4><br> JSON-P    Ajax,     .  JSON-P         .         .    ‚Äî     jQuery   . <br><br><pre> <code class="javascript hljs">sinon.stub(jQuery, <span class="hljs-string"><span class="hljs-string">"ajax"</span></span>); sinon.assert.calledOnce(jQuery.ajax);</code> </pre><br>  ,    ,      JQuery      <code>jQuery.ajax</code> ,   JSON-P.            . <br><br><h4> Assertions </h4><br> Sinon.JS    ,           .      ,                   . <br><br>  ,       ,     <code>sinon.assert.fail</code>  <code>sinon.assert.failException</code>    <code>sinon.assert.expose</code>  <code>sinon.assert.pass</code> . <br><br>      ,   . <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"test should call subscribers with message as first argument"</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> message = <span class="hljs-string"><span class="hljs-string">"an example message"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spy = sinon.spy(); PubSub.subscribe(message, spy); PubSub.publishSync(message, <span class="hljs-string"><span class="hljs-string">"some payload"</span></span>); sinon.assert.calledOnce(spy); sinon.assert.calledWith(spy, message); }</code> </pre><br><div class="spoiler"> <b class="spoiler_title">Assertions API</b> <div class="spoiler_text"> <b><u><code>sinon.assert.fail(message)</code></u></b> <br>    ,   .       <code>sinon.assert.failException</code> .       ,    ,       . <br> <b><u><code>sinon.assert.failException</code></u></b> <br>      . <br> <b><u><code>sinon.assert.pass(assertion)</code></u></b> <br>   ,   .      . <br> <b><u><code>sinon.assert.notCalled(spy)</code></u></b> <br> ,     . <br> <b><u><code>sinon.assert.called(spy)</code></u></b> <br> ,       . <br> <b><u><code>sinon.assert.calledOnce(spy)</code></u></b> <br> ,      . <br> <b><u><code>sinon.assert.calledTwice()</code></u></b> <br> ,      . <br> <b><u><code>sinon.assert.calledThrice()</code></u></b> <br> ,      . <br> <b><u><code>sinon.assert.callCount(spy, num)</code></u></b> <br>      . <br> <b><u><code>sinon.assert.callOrder(spy1, spy2, ...)</code></u></b> <br> ,        . <br> <b><u><code>sinon.assert.calledOn(spy, obj)</code></u></b> <br> ,        this. <br> <b><u><code>sinon.assert.alwaysCalledOn(spy, obj)</code></u></b> <br> ,         this. <br> <b><u><code>sinon.assert.calledWith(spy, arg1, arg2, ...)</code></u></b> <br> ,        ( ). <br> <b><u><code>sinon.assert.alwaysCalledWith(spy, arg1, arg2, ...)</code></u></b> <br> ,         ( ). <br> <b><u><code>sinon.assert.neverCalledWith(spy, arg1, arg2, ...)</code></u></b> <br> ,        . <br> <b><u><code>sinon.assert.calledWithExactly(spy, arg1, arg2, ...)</code></u></b> <br> ,          . <br> <b><u><code>sinon.assert.alwaysCalledWithExactly(spy, arg1, arg2, ...)</code></u></b> <br> ,           . <br> <b><u><code>sinon.assert.calledWithMatch(spy, arg1, arg2, ...)</code></u></b> <br> ,      .       <code>sinon.assert.calledWith(spy, sinon.match(arg1), sinon.match(arg2), ...)</code> . <br> <b><u><code>sinon.assert.alwaysCalledWithMatch(spy, arg1, arg2, ...)</code></u></b> <br> ,       .       <code>sinon.assert.alwaysCalledWith(spy, sinon.match(arg1), sinon.match(arg2), ...)</code> . <br> <b><u><code>sinon.assert.neverCalledWithMatch(spy, arg1, arg2, ...)</code></u></b> <br> ,        .       <code>sinon.assert.neverCalledWith(spy, sinon.match(arg1), sinon.match(arg2), ...)</code> . <br> <b><u><code>sinon.assert.threw(spy, exception)</code></u></b> <br> ,      ().    ,   ,   .  ,             . <br> <b><u><code>sinon.assert.alwaysThrew(spy, exception)</code></u></b> <br>      ,        . <br> <b><u><code>sinon.assert.expose(object, options)</code></u></b> <br>             . , JsTestDriver   ,    Sinon.JS      : <br><pre> <code class="javascript hljs">sinon.assert.expose(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);</code> </pre><br>   assertCalled(spy),assertCallOrder(spy1, spy2, ...)  .. <br><br>         . Prefix ‚Äî ,   .    <code>assert</code> ,   <code>sinon.assert.called</code>  <code>target.assertCalled</code> .    ,    <code>target.called</code> .  , <code>includeFail</code>          <code>failException</code> . <br></div></div><br><h4> Matchers </h4><br>        <code>spy.calledWith</code> , <code>spy.returned</code>    <code>sinon.assert</code>  <code>spy.withArgs</code> . <br>     ,        . <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"test should assert fuzzy"</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> book = { <span class="hljs-attr"><span class="hljs-attr">pages</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-attr"><span class="hljs-attr">author</span></span>: <span class="hljs-string"><span class="hljs-string">"cjno"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spy = sinon.spy(); spy(book); sinon.assert.calledWith(spy, sinon.match({ <span class="hljs-attr"><span class="hljs-attr">author</span></span>: <span class="hljs-string"><span class="hljs-string">"cjno"</span></span> })); sinon.assert.calledWith(spy, sinon.match.has(<span class="hljs-string"><span class="hljs-string">"pages"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>)); }</code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"test should stub method differently based on argument types"</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callback = sinon.stub(); callback.withArgs(sinon.match.string).returns(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); callback.withArgs(sinon.match.number).throws(<span class="hljs-string"><span class="hljs-string">"TypeError"</span></span>); callback(<span class="hljs-string"><span class="hljs-string">"abc"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Returns true callback(123); // Throws TypeError }</span></span></code> </pre><br><div class="spoiler"> <b class="spoiler_title">Matchers API</b> <div class="spoiler_text"> <b><u><code>sinon.match(number)</code></u></b> <br> ,      . <br> <b><u><code>sinon.match(string)</code></u></b> <br> ,         . <br> <b><u><code>sinon.match(regexp)</code></u></b> <br> ,         . <br> <b><u><code>sinon.match(object)</code></u></b> <br> ,              .   . <br> <b><u><code>sinon.match(function)</code></u></b> <br>   . <br> <b><u><code>sinon.match.any</code></u></b> <br>   . <br> <b><u><code>sinon.match.defined</code></u></b> <br> ,    . <br> <b><u><code>sinon.match.truthy</code></u></b> <br> ,    . <br> <b><u><code>sinon.match.falsy</code></u></b> <br> ,    . <br> <b><u><code>sinon.match.bool</code></u></b> <br> ,     . <br> <b><u><code>sinon.match.number</code></u></b> <br> ,    . <br> <b><u><code>sinon.match.string</code></u></b> <br>     . <br> <b><u><code>sinon.match.object</code></u></b> <br>     . <br> <b><u><code>sinon.match.func</code></u></b> <br> ,    . <br> <b><u><code>sinon.match.array</code></u></b> <br> ,    . <br> <b><u><code>sinon.match.regexp</code></u></b> <br> ,     . <br> <b><u><code>sinon.match.date</code></u></b> <br> ,     . <br> <b><u><code>sinon.match.same(ref)</code></u></b> <br>  ,    <code>ref</code> <br> <b><u><code>sinon.match.typeOf(type)</code></u></b> <br> ,     ,       <code>undefined</code> , <code>null</code> , <code>boolean</code> , <code>number</code> , <code>string</code> , <code>object</code> , <code>function</code> , <code>array</code> , <code>regexp</code>  <code>date</code> . <br> <b><u><code>sinon.match.instanceOf(type)</code></u></b> <br> ,      . <br> <b><u><code>sinon.match.has(property[, expectation])</code></u></b> <br>  ,    .        . <br> <b><u><code>sinon.match.hasOwn(property[, expectation])</code></u></b> <br>      sinon.match.has,       .   . <br></div></div><br><h4>   </h4><br>    ¬´¬ª  ¬´¬ª.     .    ,    ()     ()  . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stringOrNumber = sinon.match.string.or(sinon.match.number); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bookWithPages = sinon.match.instanceOf(Book).and(sinon.match.has(<span class="hljs-string"><span class="hljs-string">"pages"</span></span>));</code> </pre><br><h4>   </h4><br>     <code>sinon.match</code> ,       .       ,  <code>true</code> ,      'false' ‚Äî  .   ,       ,     . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> trueIsh = sinon.match(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !!value; }, <span class="hljs-string"><span class="hljs-string">"trueIsh"</span></span>);</code> </pre><br><h4> Sandboxes </h4><br>     ,     / .     ,  XHR,    /    ,    ,   . <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"test using sinon.test sandbox"</span></span>: sinon.test(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myAPI = { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mock(myAPI).expects(<span class="hljs-string"><span class="hljs-string">"method"</span></span>).once(); PubSub.subscribe(<span class="hljs-string"><span class="hljs-string">"message"</span></span>, myAPI.method); PubSub.publishSync(<span class="hljs-string"><span class="hljs-string">"message"</span></span>, <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>); })</code> </pre><br><div class="spoiler"> <b class="spoiler_title">Sandbox API</b> <div class="spoiler_text"> <b><u><code>var sandbox = sinon.sandbox.create();</code></u></b> <br>   sandbox. <br> <b><u><code>var sandbox = sinon.sandbox.create(config);</code></u></b> <br> 'sinon.sandbox.create (config)'  ‚Äî    ,     Sinon.JS , ,    . <br><br>     sandbox.    sandbox    ,  ,      .      : <br><br><pre> <code class="javascript hljs">sinon.defaultConfig = { <span class="hljs-comment"><span class="hljs-comment">// ... injectInto: null, properties: ["spy", "stub", "mock", "clock", "server", "requests"], useFakeTimers: true, useFakeServer: true }</span></span></code> </pre><br><ul><li> <b><u><code>injectInto</code></u></b> <br>  sandbox         .   ¬´injectInto¬ª      .    `sinon.test`   ,   ` this`     . </li><li> <b><u><code>properties</code></u></b> <br>   .    ,    ¬´server¬ª   .   '',    ,     'useFakeServer'  . </li><li> <b><u><code>useFakeTimers</code></u></b> <br>  'true',  sandbox   ''.        . </li><li> <b><u><code>useFakeServer</code></u></b> <br>  `true`, `server`   `requests`   sandbox.        .    ‚Äî 'sinon.fakeServer',     jQuery 1.3.x     ,    'onreadystatechange'  XHR  ,    : <br><br><pre> <code class="javascript hljs">sinon.config = { <span class="hljs-attr"><span class="hljs-attr">useFakeServer</span></span>: sinon.fakeServerWithClock };</code> </pre><br></li></ul><br> <b><u><code>sandbox.spy();</code></u></b> <br>    <code>sinon.spy</code> ,              <code>sandbox.restore ()</code> . <br> <b><u><code>sandbox.stub();</code></u></b> <br>     <code>sinon.stub</code> ,              <code>sandbox.restore ()</code> .  <code>sandbox stub</code>   ,     .  ,         ,         . <br> <b><u><code>sandbox.mock();</code></u></b> <br>    <code>sinon.mock</code> ,              <code>sandbox.restore ()</code> . <br> <b><u><code>sandbox.useFakeTimers();</code></u></b> <br>     sandbox,  ,        sandbox.restore ().   sandbox.clock. <br> <b><u><code>sandbox.useFakeXMLHttpRequest();</code></u></b> <br>  XHR      <code>sandbox</code> ,  ,        <code>sandbox.restore ()</code> .    <code>sandbox.requests</code> . <br> <b><u><code>sandbox.useFakeServer();</code></u></b> <br>  XHR      <code>sandbox</code> ,  ,        <code>sandbox.restore ()</code> .    <code>sandbox.requests</code>     <code>sandbox.server</code> . <br> <b><u><code>sandbox.restore();</code></u></b> <br>      sandbox. <br></div></div><br><h4>   </h4><br>     <code>sinon.test</code>  Sinon.JS     <code>sandbox</code> .       <code>sinon.config</code> . <br> <b><u><code>var wrappedFn = sinon.test(fn);</code></u></b> <br> <br>   <code>wrappedFn</code>     .  ,  sandbox    ,    .   <code>spy</code> , <code>stub</code>  <code>mock</code>  sandbox      ,  ,    <code>this.spy () (stub  mock)</code> ,         <code>sandbox.spy () (stub  mock)</code> ,      . <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">injectIntoThis</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">injectInto</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">properties</span></span>: [<span class="hljs-string"><span class="hljs-string">"spy"</span></span>, <span class="hljs-string"><span class="hljs-string">"stub"</span></span>, <span class="hljs-string"><span class="hljs-string">"mock"</span></span>, <span class="hljs-string"><span class="hljs-string">"clock"</span></span>, <span class="hljs-string"><span class="hljs-string">"server"</span></span>, <span class="hljs-string"><span class="hljs-string">"requests"</span></span>], <span class="hljs-attr"><span class="hljs-attr">useFakeTimers</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">useFakeServer</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre><br>   <code>sinon.config</code> ,     , : <br><br><pre> <code class="javascript hljs">sinon.config = { <span class="hljs-attr"><span class="hljs-attr">useFakeTimers</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">useFakeServer</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>          .  , sandbox                 . <br><h5> sinon.config </h5><br>     Sinon     <code>sinon.test</code> .     : <br><br> <b><u><code>Boolean injectIntoThis</code></u></b> <br>  ,        .   . <br> <b><u><code>Object injectInto</code></u></b> <br> ,   .   <code>null</code> ( )  <code>injectIntoThis</code> <code>false</code> (  ),        . <br> <b><u><code>Array properties</code></u></b> <br>   .    ‚Äî : <code>[spy, stub, mock, clock, server, requests]</code> .     ,      ‚Äî . <br> <b><u><code>Boolean useFakeTimers</code></u></b> <br>  ,         .    . <br> <b><u><code>Boolean useFakeServer</code></u></b> <br>  XHR  ,           .    ‚Äî . <br><br><h4>   </h4><br>       <code>sinon.test</code>   ,    <code>sinon.testCase</code> ,     ,       <code>sinon.test</code>   :`  <code>setUp</code>  <code>tearDown</code>    . <br><br> <b><u><code>var obj = sinon.testCase({});</code></u></b> <br> <br><h4> Sinon.JS  </h4><br> Sinon.JS   ,  .      ,      API. <br><br><div class="spoiler"> <b class="spoiler_title"> API</b> <div class="spoiler_text"> <b><u><code>sinon.createStubInstance(constructor)</code></u></b> <br>      ,       .     .    API . <br> <b><u><code>sinon.format(object)</code></u></b> <br>         .    . <br> <b><u><code>sinon.log(string)</code></u></b> <br>   ,   . <br></div></div><br>    ,      <a href=""></a>     . <br><br><div class="spoiler">  <b class="spoiler_title">Source</b> <div class="spoiler_text"> (function (root, factory) { <br> 'use strict'; <br> if (typeof define === 'function' &amp;&amp; define.amd) { <br> define('sinon', [], function () { <br> return (root.sinon = factory()); <br>  }); <br> } else if (typeof exports === 'object') { <br> module.exports = factory(); <br>  } else { <br> root.sinon = factory(); <br>  } <br> }(this, function () { <br> 'use strict'; <br> var samsam, formatio, lolex; <br> (function () { <br> function define(mod, deps, fn) { <br> if (mod == ¬´samsam¬ª) { <br> samsam = deps(); <br> } else if (typeof deps === ¬´function¬ª &amp;&amp; mod.length === 0) { <br> lolex = deps(); <br> } else if (typeof fn === ¬´function¬ª) { <br> formatio = fn(samsam); <br>  } <br>  } <br> define.amd = {}; <br> ((typeof define === ¬´function¬ª &amp;&amp; define.amd &amp;&amp; function (m) { define(¬´samsam¬ª, m); }) || <br> (typeof module === ¬´object¬ª &amp;&amp; <br> function (m) { module.exports = m(); }) || // Node <br> function (m) { this.samsam = m(); } // Browser globals <br> )(function () { <br> var o = Object.prototype; <br> var div = typeof document !== ¬´undefined¬ª &amp;&amp; document.createElement(¬´div¬ª); <br><br> function isNaN(value) { <br> // Unlike global isNaN, this avoids type coercion <br> // typeof check avoids IE host object issues, hat tip to <br> // lodash <br> var val = value; // JsLint thinks value !== value is ¬´weird¬ª <br> return typeof value === ¬´number¬ª &amp;&amp; value !== val; <br>  } <br><br> function getClass(value) { <br> // Returns the internal [[Class]] by calling Object.prototype.toString <br> // with the provided value as this. Return value is a string, naming the <br> // internal class, eg ¬´Array¬ª <br> return o.toString.call(value).split(/[ \]]/)[1]; <br>  } <br><br> /** <br> * <a href="https://habrahabr.ru/users/name/" class="user_link">name</a> samsam.isArguments <br> * <a href="https://habrahabr.ru/users/param/" class="user_link">param</a> Object object <br>  * <br> * Returns ``true`` if ``object`` is an ``arguments`` object, <br> * ``false`` otherwise. <br> */ <br> function isArguments(object) { <br> if (getClass(object) === 'Arguments') { return true;  } <br> if (typeof object !== ¬´object¬ª || typeof object.length !== ¬´number¬ª || <br> getClass(object) === ¬´Array¬ª) { <br>  return false; <br>  } <br> if (typeof object.callee == ¬´function¬ª) { return true;  } <br>  try { <br> object[object.length] = 6; <br> delete object[object.length]; <br>  } catch (e) { <br>  return true; <br>  } <br>  return false; <br>  } <br><br> /** <br> * <a href="https://habrahabr.ru/users/name/" class="user_link">name</a> samsam.isElement <br> * <a href="https://habrahabr.ru/users/param/" class="user_link">param</a> Object object <br>  * <br> * Returns ``true`` if ``object`` is a DOM element node. Unlike <br> * Underscore.js/lodash, this function will return ``false`` if ``object`` <br> * is an *element-like* object, ie a regular object with a ``nodeType`` <br> * property that holds the value ``1``. <br> */ <br> function isElement(object) { <br> if (!object || object.nodeType !== 1 || !div) { return false;  } <br>  try { <br> object.appendChild(div); <br> object.removeChild(div); <br>  } catch (e) { <br>  return false; <br>  } <br>  return true; <br>  } <br><br> /** <br> * <a href="https://habrahabr.ru/users/name/" class="user_link">name</a> samsam.keys <br> * <a href="https://habrahabr.ru/users/param/" class="user_link">param</a> Object object <br>  * <br> * Return an array of own property names. <br> */ <br> function keys(object) { <br> var ks = [], prop; <br> for (prop in object) { <br> if (o.hasOwnProperty.call(object, prop)) { ks.push(prop);  } <br>  } <br> return ks; <br>  } <br><br> /** <br> * <a href="https://habrahabr.ru/users/name/" class="user_link">name</a> samsam.isDate <br> * <a href="https://habrahabr.ru/users/param/" class="user_link">param</a> Object value <br>  * <br> * Returns true if the object is a ``Date``, or *date-like*. Duck typing <br> * of date objects work by checking that the object has a ``getTime`` <br> * function whose return value equals the return value from the object's <br> * ``valueOf``. <br> */ <br> function isDate(value) { <br> return typeof value.getTime == ¬´function¬ª &amp;&amp; <br> value.getTime() == value.valueOf(); <br>  } <br><br> /** <br> * <a href="https://habrahabr.ru/users/name/" class="user_link">name</a> samsam.isNegZero <br> * <a href="https://habrahabr.ru/users/param/" class="user_link">param</a> Object value <br>  * <br> * Returns ``true`` if ``value`` is ``-0``. <br> */ <br> function isNegZero(value) { <br> return value === 0 &amp;&amp; 1 / value === -Infinity; <br>  } <br><br> /** <br> * <a href="https://habrahabr.ru/users/name/" class="user_link">name</a> samsam.equal <br> * <a href="https://habrahabr.ru/users/param/" class="user_link">param</a> Object obj1 <br> * <a href="https://habrahabr.ru/users/param/" class="user_link">param</a> Object obj2 <br>  * <br> * Returns ``true`` if two objects are strictly equal. Compared to <br> * ``===`` there are two exceptions: <br>  * <br> * ‚Äî NaN is considered equal to NaN <br> * ‚Äî -0 and +0 are not considered equal <br> */ <br> function identical(obj1, obj2) { <br> if (obj1 === obj2 || (isNaN(obj1) &amp;&amp; isNaN(obj2))) { <br> return obj1 !== 0 || isNegZero(obj1) === isNegZero(obj2); <br>  } <br>  } <br><br> /** <br> * <a href="https://habrahabr.ru/users/name/" class="user_link">name</a> samsam.deepEqual <br> * <a href="https://habrahabr.ru/users/param/" class="user_link">param</a> Object obj1 <br> * <a href="https://habrahabr.ru/users/param/" class="user_link">param</a> Object obj2 <br>  * <br> * Deep equal comparison. Two values are ¬´deep equal¬ª if: <br>  * <br> * ‚Äî They are equal, according to samsam.identical <br> * ‚Äî They are both date objects representing the same time <br> * ‚Äî They are both arrays containing elements that are all deepEqual <br> * ‚Äî They are objects with the same set of properties, and each property <br> * in ``obj1`` is deepEqual to the corresponding property in ``obj2`` <br>  * <br> * Supports cyclic objects. <br> */ <br> function deepEqualCyclic(obj1, obj2) { <br><br> // used for cyclic comparison <br> // contain already visited objects <br> var objects1 = [], <br> objects2 = [], <br> // contain pathes (position in the object structure) <br> // of the already visited objects <br> // indexes same as in objects arrays <br> paths1 = [], <br> paths2 = [], <br> // contains combinations of already compared objects <br> // in the manner: { "$1['ref']$2['ref']": true } <br> compared = {}; <br><br> /** <br> * used to check, if the value of a property is an object <br> * (cyclic logic is only needed for objects) <br> * only needed for cyclic logic <br> */ <br> function isObject(value) { <br><br> if (typeof value === 'object' &amp;&amp; value !== null &amp;&amp; <br> !(value instanceof Boolean) &amp;&amp; <br> !(value instanceof Date) &amp;&amp; <br> !(value instanceof Number) &amp;&amp; <br> !(value instanceof RegExp) &amp;&amp; <br> !(value instanceof String)) { <br><br>  return true; <br>  } <br><br>  return false; <br>  } <br><br> /** <br> * returns the index of the given object in the <br> * given objects array, -1 if not contained <br> * only needed for cyclic logic <br> */ <br> function getIndex(objects, obj) { <br><br> var i; <br> for (i = 0; i &lt; objects.length; i++) { <br> if (objects[i] === obj) { <br> return i; <br>  } <br>  } <br><br> return -1; <br>  } <br><br> // does the recursion for the deep equal check <br> return (function deepEqual(obj1, obj2, path1, path2) { <br> var type1 = typeof obj1; <br> var type2 = typeof obj2; <br><br> // == null also matches undefined <br> if (obj1 === obj2 || <br> isNaN(obj1) || isNaN(obj2) || <br> obj1 == null || obj2 == null || <br> type1 !== ¬´object¬ª || type2 !== ¬´object¬ª) { <br><br> return identical(obj1, obj2); <br>  } <br><br> // Elements are only equal if identical(expected, actual) <br> if (isElement(obj1) || isElement(obj2)) { return false;  } <br><br> var isDate1 = isDate(obj1), isDate2 = isDate(obj2); <br> if (isDate1 || isDate2) { <br> if (!isDate1 || !isDate2 || obj1.getTime() !== obj2.getTime()) { <br>  return false; <br>  } <br>  } <br><br> if (obj1 instanceof RegExp &amp;&amp; obj2 instanceof RegExp) { <br> if (obj1.toString() !== obj2.toString()) { return false;  } <br>  } <br><br> var class1 = getClass(obj1); <br> var class2 = getClass(obj2); <br> var keys1 = keys(obj1); <br> var keys2 = keys(obj2); <br><br> if (isArguments(obj1) || isArguments(obj2)) { <br> if (obj1.length !== obj2.length) { return false;  } <br>  } else { <br> if (type1 !== type2 || class1 !== class2 || <br> keys1.length !== keys2.length) { <br>  return false; <br>  } <br>  } <br><br> var key, i, l, <br> // following vars are used for the cyclic logic <br> value1, value2, <br> isObject1, isObject2, <br> index1, index2, <br> newPath1, newPath2; <br><br> for (i = 0, l = keys1.length; i &lt; l; i++) { <br> key = keys1[i]; <br> if (!o.hasOwnProperty.call(obj2, key)) { <br>  return false; <br>  } <br><br> // Start of the cyclic logic <br><br> value1 = obj1[key]; <br> value2 = obj2[key]; <br><br> isObject1 = isObject(value1); <br> isObject2 = isObject(value2); <br><br> // determine, if the objects were already visited <br> // (it's faster to check for isObject first, than to <br> // get -1 from getIndex for non objects) <br> index1 = isObject1? getIndex(objects1, value1): -1; <br> index2 = isObject2? getIndex(objects2, value2): -1; <br><br> // determine the new pathes of the objects <br> // ‚Äî for non cyclic objects the current path will be extended <br> // by current property name <br> // ‚Äî for cyclic objects the stored path is taken <br> newPath1 = index1 !== -1 <br>  ? paths1[index1] <br> : path1 + '[' + JSON.stringify(key) + ']'; <br> newPath2 = index2 !== -1 <br>  ? paths2[index2] <br> : path2 + '[' + JSON.stringify(key) + ']'; <br><br> // stop recursion if current objects are already compared <br> if (compared[newPath1 + newPath2]) { <br>  return true; <br>  } <br><br> // remember the current objects and their pathes <br> if (index1 === -1 &amp;&amp; isObject1) { <br> objects1.push(value1); <br> paths1.push(newPath1); <br>  } <br> if (index2 === -1 &amp;&amp; isObject2) { <br> objects2.push(value2); <br> paths2.push(newPath2); <br>  } <br><br> // remember that the current objects are already compared <br> if (isObject1 &amp;&amp; isObject2) { <br> compared[newPath1 + newPath2] = true; <br>  } <br><br> // End of cyclic logic <br><br> // neither value1 nor value2 is a cycle <br> // continue with next level <br> if (!deepEqual(value1, value2, newPath1, newPath2)) { <br>  return false; <br>  } <br>  } <br><br>  return true; <br><br> }(obj1, obj2, '$1', '$2')); <br>  } <br><br> var match; <br><br> function arrayContains(array, subset) { <br> if (subset.length === 0) { return true;  } <br> var i, l, j, k; <br> for (i = 0, l = array.length; i &lt; l; ++i) { <br> if (match(array[i], subset[0])) { <br> for (j = 0, k = subset.length; j &lt; k; ++j) { <br> if (!match(array[i + j], subset[j])) { return false;  } <br>  } <br>  return true; <br>  } <br>  } <br>  return false; <br>  } <br><br> /** <br> * <a href="https://habrahabr.ru/users/name/" class="user_link">name</a> samsam.match <br> * <a href="https://habrahabr.ru/users/param/" class="user_link">param</a> Object object <br> * <a href="https://habrahabr.ru/users/param/" class="user_link">param</a> Object matcher <br>  * <br> * Compare arbitrary value ``object`` with matcher. <br> */ <br> match = function match(object, matcher) { <br> if (matcher &amp;&amp; typeof matcher.test === ¬´function¬ª) { <br> return matcher.test(object); <br>  } <br><br> if (typeof matcher === ¬´function¬ª) { <br> return matcher(object) === true; <br>  } <br><br> if (typeof matcher === ¬´string¬ª) { <br> matcher = matcher.toLowerCase(); <br> var notNull = typeof object === ¬´string¬ª || !!object; <br> return notNull &amp;&amp; <br> (String(object)).toLowerCase().indexOf(matcher) &gt;= 0; <br>  } <br><br> if (typeof matcher === ¬´number¬ª) { <br> return matcher === object; <br>  } <br><br> if (typeof matcher === ¬´boolean¬ª) { <br> return matcher === object; <br>  } <br><br> if (typeof(matcher) === ¬´undefined¬ª) { <br> return typeof(object) === ¬´undefined¬ª; <br>  } <br><br> if (matcher === null) { <br> return object === null; <br>  } <br><br> if (getClass(object) === ¬´Array¬ª &amp;&amp; getClass(matcher) === ¬´Array¬ª) { <br> return arrayContains(object, matcher); <br>  } <br><br> if (matcher &amp;&amp; typeof matcher === ¬´object¬ª) { <br> if (matcher === object) { <br>  return true; <br>  } <br> var prop; <br> for (prop in matcher) { <br> var value = object[prop]; <br> if (typeof value === ¬´undefined¬ª &amp;&amp; <br> typeof object.getAttribute === ¬´function¬ª) { <br> value = object.getAttribute(prop); <br>  } <br> if (matcher[prop] === null || typeof matcher[prop] === 'undefined') { <br> if (value !== matcher[prop]) { <br>  return false; <br>  } <br> } else if (typeof value === ¬´undefined¬ª || !match(value, matcher[prop])) { <br>  return false; <br>  } <br>  } <br>  return true; <br>  } <br><br> throw new Error(¬´Matcher was not a string, a number, a ¬ª + <br> ¬´function, a boolean or an object¬ª); <br>  }; <br><br> return { <br> isArguments: isArguments, <br> isElement: isElement, <br> isDate: isDate, <br> isNegZero: isNegZero, <br> identical: identical, <br> deepEqual: deepEqualCyclic, <br> match: match, <br> keys: keys <br>  }; <br>  }); <br> ((typeof define === ¬´function¬ª &amp;&amp; define.amd &amp;&amp; function (m) { <br> define(¬´formatio¬ª, [¬´samsam¬ª], m); <br> }) || (typeof module === ¬´object¬ª &amp;&amp; function (m) { <br> module.exports = m(require(¬´samsam¬ª)); <br> }) || function (m) { this.formatio = m(this.samsam);  } <br> )(function (samsam) { <br><br> var formatio = { <br> excludeConstructors: [¬´Object¬ª, /^.$/], <br> quoteStrings: true, <br> limitChildrenCount: 0 <br>  }; <br><br> var hasOwn = Object.prototype.hasOwnProperty; <br><br> var specialObjects = []; <br> if (typeof global !== ¬´undefined¬ª) { <br> specialObjects.push({ object: global, value: "[object global]" }); <br>  } <br> if (typeof document !== ¬´undefined¬ª) { <br> specialObjects.push({ <br> object: document, <br> value: "[object HTMLDocument]" <br>  }); <br>  } <br> if (typeof window !== ¬´undefined¬ª) { <br> specialObjects.push({ object: window, value: "[object Window]" }); <br>  } <br><br> function functionName(func) { <br> if (!func) { return "";  } <br> if (func.displayName) { return func.displayName;  } <br> if (func.name) { return func.name;  } <br> var matches = func.toString().match(/function\s+([^\(]+)/m); <br> return (matches &amp;&amp; matches[1]) || ""; <br>  } <br><br> function constructorName(f, object) { <br> var name = functionName(object &amp;&amp; object.constructor); <br> var excludes = f.excludeConstructors || <br> formatio.excludeConstructors || []; <br><br> var i, l; <br> for (i = 0, l = excludes.length; i &lt; l; ++i) { <br> if (typeof excludes[i] === ¬´string¬ª &amp;&amp; excludes[i] === name) { <br> return ""; <br> } else if (excludes[i].test &amp;&amp; excludes[i].test(name)) { <br> return ""; <br>  } <br>  } <br><br> return name; <br>  } <br><br> function isCircular(object, objects) { <br> if (typeof object !== ¬´object¬ª) { return false;  } <br> var i, l; <br> for (i = 0, l = objects.length; i &lt; l; ++i) { <br> if (objects[i] === object) { return true;  } <br>  } <br>  return false; <br>  } <br><br> function ascii(f, object, processed, indent) { <br> if (typeof object === ¬´string¬ª) { <br> var qs = f.quoteStrings; <br> var quote = typeof qs !== ¬´boolean¬ª || qs; <br> return processed || quote? '"' + object + '"': object; <br>  } <br><br> if (typeof object === ¬´function¬ª &amp;&amp; !(object instanceof RegExp)) { <br> return ascii.func(object); <br>  } <br><br> processed = processed || []; <br><br> if (isCircular(object, processed)) { return "[Circular]";  } <br><br> if (Object.prototype.toString.call(object) === "[object Array]") { <br> return ascii.array.call(f, object, processed); <br>  } <br><br> if (!object) { return String((1/object) === -Infinity? "-0": object);  } <br> if (samsam.isElement(object)) { return ascii.element(object);  } <br><br> if (typeof object.toString === ¬´function¬ª &amp;&amp; <br> object.toString !== Object.prototype.toString) { <br> return object.toString(); <br>  } <br><br> var i, l; <br> for (i = 0, l = specialObjects.length; i &lt; l; i++) { <br> if (object === specialObjects[i].object) { <br> return specialObjects[i].value; <br>  } <br>  } <br><br> return ascii.object.call(f, object, processed, indent); <br>  } <br><br> ascii.func = function (func) { <br> return ¬´function ¬ª + functionName(func) + "() {}"; <br>  }; <br><br> ascii.array = function (array, processed) { <br> processed = processed || []; <br> processed.push(array); <br> var pieces = []; <br> var i, l; <br> l = (this.limitChildrenCount &gt; 0)? <br> Math.min(this.limitChildrenCount, array.length): array.length; <br><br> for (i = 0; i &lt; l; ++i) { <br> pieces.push(ascii(this, array[i], processed)); <br>  } <br><br> if(l &lt; array.length) <br> pieces.push("[‚Ä¶ " + (array.length ‚Äî l) + " more elements]"); <br><br> return "[" + pieces.join(", ") + "]"; <br>  }; <br><br> ascii.object = function (object, processed, indent) { <br> processed = processed || []; <br> processed.push(object); <br> indent = indent || 0; <br> var pieces = [], properties = samsam.keys(object).sort(); <br> var length = 3; <br> var prop, str, obj, i, k, l; <br> l = (this.limitChildrenCount &gt; 0)? <br> Math.min(this.limitChildrenCount, properties.length): properties.length; <br><br> for (i = 0; i &lt; l; ++i) { <br> prop = properties[i]; <br> obj = object[prop]; <br><br> if (isCircular(obj, processed)) { <br> str = "[Circular]"; <br>  } else { <br> str = ascii(this, obj, processed, indent + 2); <br>  } <br><br> str = (/\s/.test(prop)? '"' + prop + '"': prop) + ": " + str; <br> length += str.length; <br> pieces.push(str); <br>  } <br><br> var cons = constructorName(this, object); <br> var prefix = cons? "[" + cons + "] ": ""; <br> var is = ""; <br> for (i = 0, k = indent; i &lt; k; ++i) { is += " ";  } <br><br> if(l &lt; properties.length) <br> pieces.push("[‚Ä¶ " + (properties.length ‚Äî l) + " more elements]"); <br><br> if (length + indent &gt; 80) { <br> return prefix + "{\n " + is + pieces.join(",\n " + is) + "\n" + <br> is + "}"; <br>  } <br> return prefix + "{ " + pieces.join(", ") + " }"; <br>  }; <br><br> ascii.element = function (element) { <br> var tagName = element.tagName.toLowerCase(); <br> var attrs = element.attributes, attr, pairs = [], attrName, i, l, val; <br><br> for (i = 0, l = attrs.length; i &lt; l; ++i) { <br> attr = attrs.item(i); <br> attrName = attr.nodeName.toLowerCase().replace(¬´html:¬ª, ""); <br> val = attr.nodeValue; <br> if (attrName !== ¬´contenteditable¬ª || val !== ¬´inherit¬ª) { <br> if (!!val) { pairs.push(attrName + "=\"" + val + "\"");  } <br>  } <br>  } <br><br> var formatted = "&lt;" + tagName + (pairs.length &gt; 0? " ": ""); <br> var content = element.innerHTML; <br><br> if (content.length &gt; 20) { <br> content = content.substr(0, 20) + "[...]"; <br>  } <br><br> var res = formatted + pairs.join(" ") + "&gt;" + content + <br> "&lt;/" + tagName + "&gt;"; <br><br> return res.replace(/ contentEditable=¬´inherit¬ª/, ""); <br>  }; <br><br> function Formatio(options) { <br> for (var opt in options) { <br> this[opt] = options[opt]; <br>  } <br>  } <br><br> Formatio.prototype = { <br> functionName: functionName, <br><br> configure: function (options) { <br> return new Formatio(options); <br>  }, <br><br> constructorName: function (object) { <br> return constructorName(this, object); <br>  }, <br><br> ascii: function (object, processed, indent) { <br> return ascii(this, object, processed, indent); <br>  } <br>  }; <br><br> return Formatio.prototype; <br>  }); <br> !function(e){if(¬´object¬ª==typeof exports&amp;&amp;¬´undefined¬ª!=typeof module)module.exports=e();else if(¬´function¬ª==typeof define&amp;&amp;define.amd)define([],e);else{var f;¬´undefined¬ª!=typeof window?f=window:¬´undefined¬ª!=typeof global?f=global:¬´undefined¬ª!=typeof self&amp;&amp;(f=self),f.lolex=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==¬´function¬ª&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);var f=new Error(¬´Cannot find module '¬ª+o+"'");throw f.code=¬´MODULE_NOT_FOUND¬ª,f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==¬´function¬ª&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){ <br> (function (global){ <br> /*global global, window*/ <br> /** <br> * <a href="https://habrahabr.ru/users/author/" class="user_link">author</a> Christian Johansen (christian@cjohansen.no) and contributors <br> * @license BSD <br>  * <br> * Copyright ¬© 2010-2014 Christian Johansen <br> */ <br><br> (function (global) { <br><br> // Make properties writable in IE, as per <br> // <a href="http://www.adequatelygood.com/Replacing-setTimeout-Globally.html">www.adequatelygood.com/Replacing-setTimeout-Globally.html</a> <br> // JSLint being anal <br> var glbl = global; <br><br> global.setTimeout = glbl.setTimeout; <br> global.clearTimeout = glbl.clearTimeout; <br> global.setInterval = glbl.setInterval; <br> global.clearInterval = glbl.clearInterval; <br> global.Date = glbl.Date; <br><br> // setImmediate is not a standard function <br> // avoid adding the prop to the window object if not present <br> if('setImmediate' in global) { <br> global.setImmediate = glbl.setImmediate; <br> global.clearImmediate = glbl.clearImmediate; <br>  } <br><br> // node expects setTimeout/setInterval to return a fn object w/ .ref()/.unref() <br> // browsers, a number. <br> // see <a href="https://github.com/cjohansen/Sinon.JS/pull/436">github.com/cjohansen/Sinon.JS/pull/436</a> <br><br> var NOOP = function () { return undefined;  }; <br> var timeoutResult = setTimeout(NOOP, 0); <br> var addTimerReturnsObject = typeof timeoutResult === ¬´object¬ª; <br> clearTimeout(timeoutResult); <br><br> var NativeDate = Date; <br> var uniqueTimerId = 1; <br><br> /** <br> * Parse strings like ¬´01:10:00¬ª (meaning 1 hour, 10 minutes, 0 seconds) into <br> * number of milliseconds. This is used to support human-readable strings passed <br> * to clock.tick() <br> */ <br> function parseTime(str) { <br> if (!str) { <br>  return 0; <br>  } <br><br> var strings = str.split(":"); <br> var l = strings.length, i = l; <br> var ms = 0, parsed; <br><br> if (l &gt; 3 || !/^(\d\d:){0,2}\d\d?$/.test(str)) { <br> throw new Error(¬´tick only understands numbers and 'h:m:s'¬ª); <br>  } <br><br> while (i--) { <br> parsed = parseInt(strings[i], 10); <br><br> if (parsed &gt;= 60) { <br> throw new Error(¬´Invalid time ¬ª + str); <br>  } <br><br> ms += parsed * Math.pow(60, (l ‚Äî i ‚Äî 1)); <br>  } <br><br> return ms * 1000; <br>  } <br><br> /** <br> * Used to grok the `now` parameter to createClock. <br> */ <br> function getEpoch(epoch) { <br> if (!epoch) { return 0;  } <br> if (typeof epoch.getTime === ¬´function¬ª) { return epoch.getTime();  } <br> if (typeof epoch === ¬´number¬ª) { return epoch;  } <br> throw new TypeError(¬´now should be milliseconds since UNIX epoch¬ª); <br>  } <br><br> function inRange(from, to, timer) { <br> return timer &amp;&amp; timer.callAt &gt;= from &amp;&amp; timer.callAt &lt;= to; <br>  } <br><br> function mirrorDateProperties(target, source) { <br> var prop; <br> for (prop in source) { <br> if (source.hasOwnProperty(prop)) { <br> target[prop] = source[prop]; <br>  } <br>  } <br><br> // set special now implementation <br> if (source.now) { <br> target.now = function now() { <br> return target.clock.now; <br>  }; <br>  } else { <br> delete target.now; <br>  } <br><br> // set special toSource implementation <br> if (source.toSource) { <br> target.toSource = function toSource() { <br> return source.toSource(); <br>  }; <br>  } else { <br> delete target.toSource; <br>  } <br><br> // set special toString implementation <br> target.toString = function toString() { <br> return source.toString(); <br>  }; <br><br> target.prototype = source.prototype; <br> target.parse = source.parse; <br> target.UTC = source.UTC; <br> target.prototype.toUTCString = source.prototype.toUTCString; <br><br> return target; <br>  } <br><br> function createDate() { <br> function ClockDate(year, month, date, hour, minute, second, ms) { <br> // Defensive and verbose to avoid potential harm in passing <br> // explicit undefined when user does not pass argument <br> switch (arguments.length) { <br> case 0: <br> return new NativeDate(ClockDate.clock.now); <br> case 1: <br> return new NativeDate(year); <br> case 2: <br> return new NativeDate(year, month); <br> case 3: <br> return new NativeDate(year, month, date); <br> case 4: <br> return new NativeDate(year, month, date, hour); <br> case 5: <br> return new NativeDate(year, month, date, hour, minute); <br> case 6: <br> return new NativeDate(year, month, date, hour, minute, second); <br> default: <br> return new NativeDate(year, month, date, hour, minute, second, ms); <br>  } <br>  } <br><br> return mirrorDateProperties(ClockDate, NativeDate); <br>  } <br><br> function addTimer(clock, timer) { <br> if (timer.func === undefined) { <br> throw new Error(¬´Callback must be provided to timer calls¬ª); <br>  } <br><br> if (!clock.timers) { <br> clock.timers = {}; <br>  } <br><br> timer.id = uniqueTimerId++; <br> timer.createdAt = clock.now; <br> timer.callAt = clock.now + (timer.delay || (clock.duringTick? 1: 0)); <br><br> clock.timers[timer.id] = timer; <br><br> if (addTimerReturnsObject) { <br> return { <br> id: timer.id, <br> ref: NOOP, <br> unref: NOOP <br>  }; <br>  } <br><br> return timer.id; <br>  } <br><br> function compareTimers(a, b) { <br> // Sort first by absolute timing <br> if (a.callAt &lt; b.callAt) { <br> return -1; <br>  } <br> if (a.callAt &gt; b.callAt) { <br>  return 1; <br>  } <br><br> // Sort next by immediate, immediate timers take precedence <br> if (a.immediate &amp;&amp; !b.immediate) { <br> return -1; <br>  } <br> if (!a.immediate &amp;&amp; b.immediate) { <br>  return 1; <br>  } <br><br> // Sort next by creation time, earlier-created timers take precedence <br> if (a.createdAt &lt; b.createdAt) { <br> return -1; <br>  } <br> if (a.createdAt &gt; b.createdAt) { <br>  return 1; <br>  } <br><br> // Sort next by id, lower-id timers take precedence <br> if (a.id &lt; b.id) { <br> return -1; <br>  } <br> if (a.id &gt; b.id) { <br>  return 1; <br>  } <br><br> // As timer ids are unique, no fallback `0` is necessary <br>  } <br><br> function firstTimerInRange(clock, from, to) { <br> var timers = clock.timers, <br> timer = null, <br> id, <br> isInRange; <br><br> for (id in timers) { <br> if (timers.hasOwnProperty(id)) { <br> isInRange = inRange(from, to, timers[id]); <br><br> if (isInRange &amp;&amp; (!timer || compareTimers(timer, timers[id]) === 1)) { <br> timer = timers[id]; <br>  } <br>  } <br>  } <br><br> return timer; <br>  } <br><br> function callTimer(clock, timer) { <br> var exception; <br><br> if (typeof timer.interval === ¬´number¬ª) { <br> clock.timers[timer.id].callAt += timer.interval; <br>  } else { <br> delete clock.timers[timer.id]; <br>  } <br><br>  try { <br> if (typeof timer.func === ¬´function¬ª) { <br> timer.func.apply(null, timer.args); <br>  } else { <br> eval(timer.func); <br>  } <br>  } catch (e) { <br> exception = e; <br>  } <br><br> if (!clock.timers[timer.id]) { <br> if (exception) { <br> throw exception; <br>  } <br>  return; <br>  } <br><br> if (exception) { <br> throw exception; <br>  } <br>  } <br><br> function timerType(timer) { <br> if (timer.immediate) { <br> return ¬´Immediate¬ª; <br> } else if (typeof timer.interval !== ¬´undefined¬ª) { <br> return ¬´Interval¬ª; <br>  } else { <br> return ¬´Timeout¬ª; <br>  } <br>  } <br><br> function clearTimer(clock, timerId, ttype) { <br> if (!timerId) { <br> // null appears to be allowed in most browsers, and appears to be <br> // relied upon by some libraries, like Bootstrap carousel <br>  return; <br>  } <br><br> if (!clock.timers) { <br> clock.timers = []; <br>  } <br><br> // in Node, timerId is an object with .ref()/.unref(), and <br> // its .id field is the actual timer id. <br> if (typeof timerId === ¬´object¬ª) { <br> timerId = timerId.id; <br>  } <br><br> if (clock.timers.hasOwnProperty(timerId)) { <br> // check that the ID matches a timer of the correct type <br> var timer = clock.timers[timerId]; <br> if (timerType(timer) === ttype) { <br> delete clock.timers[timerId]; <br>  } else { <br> throw new Error(¬´Cannot clear timer: timer created with set¬ª + ttype + "() but cleared with clear" + timerType(timer) + "()"); <br>  } <br>  } <br>  } <br><br> function uninstall(clock, target) { <br> var method, <br> i, <br> l; <br><br> for (i = 0, l = clock.methods.length; i &lt; l; i++) { <br> method = clock.methods[i]; <br><br> if (target[method].hadOwnProperty) { <br> target[method] = clock["_" + method]; <br>  } else { <br>  try { <br> delete target[method]; <br> } catch (ignore) {} <br>  } <br>  } <br><br> // Prevent multiple executions which will completely remove these props <br> clock.methods = []; <br>  } <br><br> function hijackMethod(target, method, clock) { <br> var prop; <br><br> clock[method].hadOwnProperty = Object.prototype.hasOwnProperty.call(target, method); <br> clock["_" + method] = target[method]; <br><br> if (method === ¬´Date¬ª) { <br> var date = mirrorDateProperties(clock[method], target[method]); <br> target[method] = date; <br>  } else { <br> target[method] = function () { <br> return clock[method].apply(clock, arguments); <br>  }; <br><br> for (prop in clock[method]) { <br> if (clock[method].hasOwnProperty(prop)) { <br> target[method][prop] = clock[method][prop]; <br>  } <br>  } <br>  } <br><br> target[method].clock = clock; <br>  } <br><br> var timers = { <br> setTimeout: setTimeout, <br> clearTimeout: clearTimeout, <br> setImmediate: global.setImmediate, <br> clearImmediate: global.clearImmediate, <br> setInterval: setInterval, <br> clearInterval: clearInterval, <br> Date: Date <br>  }; <br><br> var keys = Object.keys || function (obj) { <br> var ks = [], <br> key; <br><br> for (key in obj) { <br> if (obj.hasOwnProperty(key)) { <br> ks.push(key); <br>  } <br>  } <br><br> return ks; <br>  }; <br><br> exports.timers = timers; <br><br> function createClock(now) { <br> var clock = { <br> now: getEpoch(now), <br> timeouts: {}, <br> Date: createDate() <br>  }; <br><br> clock.Date.clock = clock; <br><br> clock.setTimeout = function setTimeout(func, timeout) { <br> return addTimer(clock, { <br> func: func, <br> args: Array.prototype.slice.call(arguments, 2), <br> delay: timeout <br>  }); <br>  }; <br><br> clock.clearTimeout = function clearTimeout(timerId) { <br> return clearTimer(clock, timerId, ¬´Timeout¬ª); <br>  }; <br><br> clock.setInterval = function setInterval(func, timeout) { <br> return addTimer(clock, { <br> func: func, <br> args: Array.prototype.slice.call(arguments, 2), <br> delay: timeout, <br> interval: timeout <br>  }); <br>  }; <br><br> clock.clearInterval = function clearInterval(timerId) { <br> return clearTimer(clock, timerId, ¬´Interval¬ª); <br>  }; <br><br> clock.setImmediate = function setImmediate(func) { <br> return addTimer(clock, { <br> func: func, <br> args: Array.prototype.slice.call(arguments, 1), <br> immediate: true <br>  }); <br>  }; <br><br> clock.clearImmediate = function clearImmediate(timerId) { <br> return clearTimer(clock, timerId, ¬´Immediate¬ª); <br>  }; <br><br> clock.tick = function tick(ms) { <br> ms = typeof ms === ¬´number¬ª? ms: parseTime(ms); <br> var tickFrom = clock.now, tickTo = clock.now + ms, previous = clock.now; <br> var timer = firstTimerInRange(clock, tickFrom, tickTo); <br> var oldNow; <br><br> clock.duringTick = true; <br><br> var firstException; <br> while (timer &amp;&amp; tickFrom &lt;= tickTo) { <br> if (clock.timers[timer.id]) { <br> tickFrom = clock.now = timer.callAt; <br>  try { <br> oldNow = clock.now; <br> callTimer(clock, timer); <br> // compensate for any setSystemTime() call during timer callback <br> if (oldNow !== clock.now) { <br> tickFrom += clock.now ‚Äî oldNow; <br> tickTo += clock.now ‚Äî oldNow; <br> previous += clock.now ‚Äî oldNow; <br>  } <br>  } catch (e) { <br> firstException = firstException || e; <br>  } <br>  } <br><br> timer = firstTimerInRange(clock, previous, tickTo); <br> previous = tickFrom; <br>  } <br><br> clock.duringTick = false; <br> clock.now = tickTo; <br><br> if (firstException) { <br> throw firstException; <br>  } <br><br> return clock.now; <br>  }; <br><br> clock.reset = function reset() { <br> clock.timers = {}; <br>  }; <br><br> clock.setSystemTime = function setSystemTime(now) { <br> // determine time difference <br> var newNow = getEpoch(now); <br> var difference = newNow ‚Äî clock.now; <br><br> // update 'system clock' <br> clock.now = newNow; <br><br> // update timers and intervals to keep them stable <br> for (var id in clock.timers) { <br> if (clock.timers.hasOwnProperty(id)) { <br> var timer = clock.timers[id]; <br> timer.createdAt += difference; <br> timer.callAt += difference; <br>  } <br>  } <br>  }; <br><br> return clock; <br>  } <br> exports.createClock = createClock; <br><br> exports.install = function install(target, now, toFake) { <br> var i, <br> l; <br><br> if (typeof target === ¬´number¬ª) { <br> toFake = now; <br> now = target; <br> target = null; <br>  } <br><br> if (!target) { <br> target = global; <br>  } <br><br> var clock = createClock(now); <br><br> clock.uninstall = function () { <br> uninstall(clock, target); <br>  }; <br><br> clock.methods = toFake || []; <br><br> if (clock.methods.length === 0) { <br> clock.methods = keys(timers); <br>  } <br><br> for (i = 0, l = clock.methods.length; i &lt; l; i++) { <br> hijackMethod(target, clock.methods[i], clock); <br>  } <br><br> return clock; <br>  }; <br><br> }(global || this)); <br><br> }).call(this,typeof global !== ¬´undefined¬ª? global: typeof self !== ¬´undefined¬ª? self: typeof window !== ¬´undefined¬ª? window: {}) <br> },{}]},{},[1])(1) <br>  }); <br>  }) (); <br> var define; <br> /** <br> * Sinon core utilities. For internal use only. <br>  * <br> * <a href="https://habrahabr.ru/users/author/" class="user_link">author</a> Christian Johansen (christian@cjohansen.no) <br> * @license BSD <br>  * <br> * Copyright ¬© 2010-2013 Christian Johansen <br> */ <br> var sinon = (function () { <br> ¬´use strict¬ª; <br> // eslint-disable-line no-unused-vars <br><br> var sinonModule; <br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var isAMD = typeof define === ¬´function¬ª &amp;&amp; typeof define.amd === ¬´object¬ª &amp;&amp; define.amd; <br><br> function loadDependencies(require, exports, module) { <br> sinonModule = module.exports = require("./sinon/util/core"); <br> require("./sinon/extend"); <br> require("./sinon/walk"); <br> require("./sinon/typeOf"); <br> require("./sinon/times_in_words"); <br> require("./sinon/spy"); <br> require("./sinon/call"); <br> require("./sinon/behavior"); <br> require("./sinon/stub"); <br> require("./sinon/mock"); <br> require("./sinon/collection"); <br> require("./sinon/assert"); <br> require("./sinon/sandbox"); <br> require("./sinon/test"); <br> require("./sinon/test_case"); <br> require("./sinon/match"); <br> require("./sinon/format"); <br> require("./sinon/log_error"); <br>  } <br><br> if (isAMD) { <br> define(loadDependencies); <br> } else if (isNode) { <br> loadDependencies(require, module.exports, module); <br> sinonModule = module.exports; <br>  } else { <br> sinonModule = {}; <br>  } <br><br> return sinonModule; <br> }()); <br><br> /** <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> ../../sinon.js <br> */ <br> /** <br> * Sinon core utilities. For internal use only. <br>  * <br> * <a href="https://habrahabr.ru/users/author/" class="user_link">author</a> Christian Johansen (christian@cjohansen.no) <br> * @license BSD <br>  * <br> * Copyright ¬© 2010-2013 Christian Johansen <br> */ <br> (function (sinonGlobal) { <br><br> var div = typeof document !== ¬´undefined¬ª &amp;&amp; document.createElement(¬´div¬ª); <br> var hasOwn = Object.prototype.hasOwnProperty; <br><br> function isDOMNode(obj) { <br> var success = false; <br><br>  try { <br> obj.appendChild(div); <br> success = div.parentNode === obj; <br>  } catch (e) { <br>  return false; <br> } finally { <br>  try { <br> obj.removeChild(div); <br>  } catch (e) { <br> // Remove failed, not much we can do about that <br>  } <br>  } <br><br> return success; <br>  } <br><br> function isElement(obj) { <br> return div &amp;&amp; obj &amp;&amp; obj.nodeType === 1 &amp;&amp; isDOMNode(obj); <br>  } <br><br> function isFunction(obj) { <br> return typeof obj === ¬´function¬ª || !!(obj &amp;&amp; obj.constructor &amp;&amp; obj.call &amp;&amp; obj.apply); <br>  } <br><br> function isReallyNaN(val) { <br> return typeof val === ¬´number¬ª &amp;&amp; isNaN(val); <br>  } <br><br> function mirrorProperties(target, source) { <br> for (var prop in source) { <br> if (!hasOwn.call(target, prop)) { <br> target[prop] = source[prop]; <br>  } <br>  } <br>  } <br><br> function isRestorable(obj) { <br> return typeof obj === ¬´function¬ª &amp;&amp; typeof obj.restore === ¬´function¬ª &amp;&amp; obj.restore.sinon; <br>  } <br><br> // Cheap way to detect if we have ES5 support. <br> var hasES5Support = ¬´keys¬ª in Object; <br><br> function makeApi(sinon) { <br> sinon.wrapMethod = function wrapMethod(object, property, method) { <br> if (!object) { <br> throw new TypeError(¬´Should wrap property of object¬ª); <br>  } <br><br> if (typeof method !== ¬´function¬ª &amp;&amp; typeof method !== ¬´object¬ª) { <br> throw new TypeError(¬´Method wrapper should be a function or a property descriptor¬ª); <br>  } <br><br> function checkWrappedMethod(wrappedMethod) { <br> var error; <br><br> if (!isFunction(wrappedMethod)) { <br> error = new TypeError(¬´Attempted to wrap ¬ª + (typeof wrappedMethod) + " property " + <br> property + " as function"); <br> } else if (wrappedMethod.restore &amp;&amp; wrappedMethod.restore.sinon) { <br> error = new TypeError(¬´Attempted to wrap ¬ª + property + " which is already wrapped"); <br> } else if (wrappedMethod.calledBefore) { <br> var verb = wrappedMethod.returns? ¬´stubbed¬ª: ¬´spied on¬ª; <br> error = new TypeError(¬´Attempted to wrap ¬ª + property + " which is already " + verb); <br>  } <br><br> if (error) { <br> if (wrappedMethod &amp;&amp; wrappedMethod.stackTrace) { <br> error.stack += "\n--------------\n" + wrappedMethod.stackTrace; <br>  } <br> throw error; <br>  } <br>  } <br><br> var error, wrappedMethod, i; <br><br> // IE 8 does not support hasOwnProperty on the window object and Firefox has a problem <br> // when using hasOwn.call on objects from other frames. <br> var owned = object.hasOwnProperty? object.hasOwnProperty(property): hasOwn.call(object, property); <br><br> if (hasES5Support) { <br> var methodDesc = (typeof method === ¬´function¬ª)? {value: method}: method; <br> var wrappedMethodDesc = sinon.getPropertyDescriptor(object, property); <br><br> if (!wrappedMethodDesc) { <br> error = new TypeError(¬´Attempted to wrap ¬ª + (typeof wrappedMethod) + " property " + <br> property + " as function"); <br> } else if (wrappedMethodDesc.restore &amp;&amp; wrappedMethodDesc.restore.sinon) { <br> error = new TypeError(¬´Attempted to wrap ¬ª + property + " which is already wrapped"); <br>  } <br> if (error) { <br> if (wrappedMethodDesc &amp;&amp; wrappedMethodDesc.stackTrace) { <br> error.stack += "\n--------------\n" + wrappedMethodDesc.stackTrace; <br>  } <br> throw error; <br>  } <br><br> var types = sinon.objectKeys(methodDesc); <br> for (i = 0; i &lt; types.length; i++) { <br> wrappedMethod = wrappedMethodDesc[types[i]]; <br> checkWrappedMethod(wrappedMethod); <br>  } <br><br> mirrorProperties(methodDesc, wrappedMethodDesc); <br> for (i = 0; i &lt; types.length; i++) { <br> mirrorProperties(methodDesc[types[i]], wrappedMethodDesc[types[i]]); <br>  } <br> Object.defineProperty(object, property, methodDesc); <br>  } else { <br> wrappedMethod = object[property]; <br> checkWrappedMethod(wrappedMethod); <br> object[property] = method; <br> method.displayName = property; <br>  } <br><br> method.displayName = property; <br><br> // Set up a stack trace which can be used later to find what line of <br> // code the original method was created on. <br> method.stackTrace = (new Error(¬´Stack Trace for original¬ª)).stack; <br><br> method.restore = function () { <br> // For prototype properties try to reset by delete first. <br> // If this fails (ex: localStorage on mobile safari) then force a reset <br> // via direct assignment. <br> if (!owned) { <br> // In some cases `delete` may throw an error <br>  try { <br> delete object[property]; <br> } catch (e) {} // eslint-disable-line no-empty <br> // For native code functions `delete` fails without throwing an error <br> // on Chrome &lt; 43, PhantomJS, etc. <br> } else if (hasES5Support) { <br> Object.defineProperty(object, property, wrappedMethodDesc); <br>  } <br><br> // Use strict equality comparison to check failures then force a reset <br> // via direct assignment. <br> if (object[property] === method) { <br> object[property] = wrappedMethod; <br>  } <br>  }; <br><br> method.restore.sinon = true; <br><br> if (!hasES5Support) { <br> mirrorProperties(method, wrappedMethod); <br>  } <br><br> return method; <br>  }; <br><br> sinon.create = function create(proto) { <br> var F = function () {}; <br> F.prototype = proto; <br> return new F(); <br>  }; <br><br> sinon.deepEqual = function deepEqual(a, b) { <br> if (sinon.match &amp;&amp; sinon.match.isMatcher(a)) { <br> return a.test(b); <br>  } <br><br> if (typeof a !== ¬´object¬ª || typeof b !== ¬´object¬ª) { <br> return isReallyNaN(a) &amp;&amp; isReallyNaN(b) || a === b; <br>  } <br><br> if (isElement(a) || isElement(b)) { <br> return a === b; <br>  } <br><br> if (a === b) { <br>  return true; <br>  } <br><br> if ((a === null &amp;&amp; b !== null) || (a !== null &amp;&amp; b === null)) { <br>  return false; <br>  } <br><br> if (a instanceof RegExp &amp;&amp; b instanceof RegExp) { <br> return (a.source === b.source) &amp;&amp; (a.global === b.global) &amp;&amp; <br> (a.ignoreCase === b.ignoreCase) &amp;&amp; (a.multiline === b.multiline); <br>  } <br><br> var aString = Object.prototype.toString.call(a); <br> if (aString !== Object.prototype.toString.call(b)) { <br>  return false; <br>  } <br><br> if (aString === "[object Date]") { <br> return a.valueOf() === b.valueOf(); <br>  } <br><br> var prop; <br> var aLength = 0; <br> var bLength = 0; <br><br> if (aString === "[object Array]" &amp;&amp; a.length !== b.length) { <br>  return false; <br>  } <br><br> for (prop in a) { <br> if (a.hasOwnProperty(prop)) { <br> aLength += 1; <br><br> if (!(prop in b)) { <br>  return false; <br>  } <br><br> if (!deepEqual(a[prop], b[prop])) { <br>  return false; <br>  } <br>  } <br>  } <br><br> for (prop in b) { <br> if (b.hasOwnProperty(prop)) { <br> bLength += 1; <br>  } <br>  } <br><br> return aLength === bLength; <br>  }; <br><br> sinon.functionName = function functionName(func) { <br> var name = func.displayName || func.name; <br><br> // Use function decomposition as a last resort to get function <br> // name. Does not rely on function decomposition to work ‚Äî if it <br> // doesn't debugging will be slightly less informative <br> // (ie toString will say 'spy' rather than 'myFunc'). <br> if (!name) { <br> var matches = func.toString().match(/function ([^\s\(]+)/); <br> name = matches &amp;&amp; matches[1]; <br>  } <br><br> return name; <br>  }; <br><br> sinon.functionToString = function toString() { <br> if (this.getCall &amp;&amp; this.callCount) { <br> var thisValue, <br> prop; <br> var i = this.callCount; <br><br> while (i--) { <br> thisValue = this.getCall(i).thisValue; <br><br> for (prop in thisValue) { <br> if (thisValue[prop] === this) { <br> return prop; <br>  } <br>  } <br>  } <br>  } <br><br> return this.displayName || ¬´sinon fake¬ª; <br>  }; <br><br> sinon.objectKeys = function objectKeys(obj) { <br> if (obj !== Object(obj)) { <br> throw new TypeError(¬´sinon.objectKeys called on a non-object¬ª); <br>  } <br><br> var keys = []; <br> var key; <br> for (key in obj) { <br> if (hasOwn.call(obj, key)) { <br> keys.push(key); <br>  } <br>  } <br><br> return keys; <br>  }; <br><br> sinon.getPropertyDescriptor = function getPropertyDescriptor(object, property) { <br> var proto = object; <br> var descriptor; <br><br> while (proto &amp;&amp; !(descriptor = Object.getOwnPropertyDescriptor(proto, property))) { <br> proto = Object.getPrototypeOf(proto); <br>  } <br> return descriptor; <br>  }; <br><br> sinon.getConfig = function (custom) { <br> var config = {}; <br> custom = custom || {}; <br> var defaults = sinon.defaultConfig; <br><br> for (var prop in defaults) { <br> if (defaults.hasOwnProperty(prop)) { <br> config[prop] = custom.hasOwnProperty(prop)? custom[prop]: defaults[prop]; <br>  } <br>  } <br><br> return config; <br>  }; <br><br> sinon.defaultConfig = { <br> injectIntoThis: true, <br> injectInto: null, <br> properties: [¬´spy¬ª, ¬´stub¬ª, ¬´mock¬ª, ¬´clock¬ª, ¬´server¬ª, ¬´requests¬ª], <br> useFakeTimers: true, <br> useFakeServer: true <br>  }; <br><br> sinon.timesInWords = function timesInWords(count) { <br> return count === 1 &amp;&amp; ¬´once¬ª || <br> count === 2 &amp;&amp; ¬´twice¬ª || <br> count === 3 &amp;&amp; ¬´thrice¬ª || <br> (count || 0) + " times"; <br>  }; <br><br> sinon.calledInOrder = function (spies) { <br> for (var i = 1, l = spies.length; i &lt; l; i++) { <br> if (!spies[i ‚Äî 1].calledBefore(spies[i]) || !spies[i].called) { <br>  return false; <br>  } <br>  } <br><br>  return true; <br>  }; <br><br> sinon.orderByFirstCall = function (spies) { <br> return spies.sort(function (a, b) { <br> // uuid, won't ever be equal <br> var aCall = a.getCall(0); <br> var bCall = b.getCall(0); <br> var aId = aCall &amp;&amp; aCall.callId || -1; <br> var bId = bCall &amp;&amp; bCall.callId || -1; <br><br> return aId &lt; bId? -1: 1; <br>  }); <br>  }; <br><br> sinon.createStubInstance = function (constructor) { <br> if (typeof constructor !== ¬´function¬ª) { <br> throw new TypeError(¬´The constructor should be a function.¬ª); <br>  } <br> return sinon.stub(sinon.create(constructor.prototype)); <br>  }; <br><br> sinon.restore = function (object) { <br> if (object !== null &amp;&amp; typeof object === ¬´object¬ª) { <br> for (var prop in object) { <br> if (isRestorable(object[prop])) { <br> object[prop].restore(); <br>  } <br>  } <br> } else if (isRestorable(object)) { <br> object.restore(); <br>  } <br>  }; <br><br> return sinon; <br>  } <br><br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var isAMD = typeof define === ¬´function¬ª &amp;&amp; typeof define.amd === ¬´object¬ª &amp;&amp; define.amd; <br><br> function loadDependencies(require, exports) { <br> makeApi(exports); <br>  } <br><br> if (isAMD) { <br> define(loadDependencies); <br>  return; <br>  } <br><br> if (isNode) { <br> loadDependencies(require, module.exports, module); <br>  return; <br>  } <br><br> if (sinonGlobal) { <br> makeApi(sinonGlobal); <br>  } <br> }( <br> typeof sinon === ¬´object¬ª &amp;&amp; sinon // eslint-disable-line no-undef <br> )); <br><br> /** <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> util/core.js <br> */ <br> (function (sinonGlobal) { <br><br> function makeApi(sinon) { <br><br> // Adapted from <a href="https://developer.mozilla.org/en/docs/ECMAScript_DontEnum_attribute">developer.mozilla.org/en/docs/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug</a> <br> var hasDontEnumBug = (function () { <br> var obj = { <br> constructor: function () { <br> return ¬´0¬ª; <br>  }, <br> toString: function () { <br> return ¬´1¬ª; <br>  }, <br> valueOf: function () { <br> return ¬´2¬ª; <br>  }, <br> toLocaleString: function () { <br> return ¬´3¬ª; <br>  }, <br> prototype: function () { <br> return ¬´4¬ª; <br>  }, <br> isPrototypeOf: function () { <br> return ¬´5¬ª; <br>  }, <br> propertyIsEnumerable: function () { <br> return ¬´6¬ª; <br>  }, <br> hasOwnProperty: function () { <br> return ¬´7¬ª; <br>  }, <br> length: function () { <br> return ¬´8¬ª; <br>  }, <br> unique: function () { <br> return ¬´9¬ª; <br>  } <br>  }; <br><br> var result = []; <br> for (var prop in obj) { <br> if (obj.hasOwnProperty(prop)) { <br> result.push(obj[prop]()); <br>  } <br>  } <br> return result.join("") !== ¬´0123456789¬ª; <br>  }) (); <br><br> /* Public: Extend target in place with all (own) properties from sources in-order. Thus, last source will <br> * override properties in previous sources. <br>  * <br> * target ‚Äî The Object to extend <br> * sources ‚Äî Objects to copy properties from. <br>  * <br> * Returns the extended target <br> */ <br> function extend(target /*, sources */) { <br> var sources = Array.prototype.slice.call(arguments, 1); <br> var source, i, prop; <br><br> for (i = 0; i &lt; sources.length; i++) { <br> source = sources[i]; <br><br> for (prop in source) { <br> if (source.hasOwnProperty(prop)) { <br> target[prop] = source[prop]; <br>  } <br>  } <br><br> // Make sure we copy (own) toString method even when in JScript with DontEnum bug <br> // See <a href="https://developer.mozilla.org/en/docs/ECMAScript_DontEnum_attribute">developer.mozilla.org/en/docs/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug</a> <br> if (hasDontEnumBug &amp;&amp; source.hasOwnProperty(¬´toString¬ª) &amp;&amp; source.toString !== target.toString) { <br> target.toString = source.toString; <br>  } <br>  } <br><br> return target; <br>  } <br><br> sinon.extend = extend; <br> return sinon.extend; <br>  } <br><br> function loadDependencies(require, exports, module) { <br> var sinon = require("./util/core"); <br> module.exports = makeApi(sinon); <br>  } <br><br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var isAMD = typeof define === ¬´function¬ª &amp;&amp; typeof define.amd === ¬´object¬ª &amp;&amp; define.amd; <br><br> if (isAMD) { <br> define(loadDependencies); <br>  return; <br>  } <br><br> if (isNode) { <br> loadDependencies(require, module.exports, module); <br>  return; <br>  } <br><br> if (sinonGlobal) { <br> makeApi(sinonGlobal); <br>  } <br> }( <br> typeof sinon === ¬´object¬ª &amp;&amp; sinon // eslint-disable-line no-undef <br> )); <br><br> /** <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> util/core.js <br> */ <br> (function (sinonGlobal) { <br><br> function makeApi(sinon) { <br><br> function timesInWords(count) { <br> switch (count) { <br> case 1: <br> return ¬´once¬ª; <br> case 2: <br> return ¬´twice¬ª; <br> case 3: <br> return ¬´thrice¬ª; <br> default: <br> return (count || 0) + " times"; <br>  } <br>  } <br><br> sinon.timesInWords = timesInWords; <br> return sinon.timesInWords; <br>  } <br><br> function loadDependencies(require, exports, module) { <br> var core = require("./util/core"); <br> module.exports = makeApi(core); <br>  } <br><br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var isAMD = typeof define === ¬´function¬ª &amp;&amp; typeof define.amd === ¬´object¬ª &amp;&amp; define.amd; <br><br> if (isAMD) { <br> define(loadDependencies); <br>  return; <br>  } <br><br> if (isNode) { <br> loadDependencies(require, module.exports, module); <br>  return; <br>  } <br><br> if (sinonGlobal) { <br> makeApi(sinonGlobal); <br>  } <br> }( <br> typeof sinon === ¬´object¬ª &amp;&amp; sinon // eslint-disable-line no-undef <br> )); <br><br> /** <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> util/core.js <br> */ <br> /** <br> * Format functions <br>  * <br> * <a href="https://habrahabr.ru/users/author/" class="user_link">author</a> Christian Johansen (christian@cjohansen.no) <br> * @license BSD <br>  * <br> * Copyright ¬© 2010-2014 Christian Johansen <br> */ <br> (function (sinonGlobal) { <br><br> function makeApi(sinon) { <br> function typeOf(value) { <br> if (value === null) { <br> return ¬´null¬ª; <br> } else if (value === undefined) { <br> return ¬´undefined¬ª; <br>  } <br> var string = Object.prototype.toString.call(value); <br> return string.substring(8, string.length ‚Äî 1).toLowerCase(); <br>  } <br><br> sinon.typeOf = typeOf; <br> return sinon.typeOf; <br>  } <br><br> function loadDependencies(require, exports, module) { <br> var core = require("./util/core"); <br> module.exports = makeApi(core); <br>  } <br><br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var isAMD = typeof define === ¬´function¬ª &amp;&amp; typeof define.amd === ¬´object¬ª &amp;&amp; define.amd; <br><br> if (isAMD) { <br> define(loadDependencies); <br>  return; <br>  } <br><br> if (isNode) { <br> loadDependencies(require, module.exports, module); <br>  return; <br>  } <br><br> if (sinonGlobal) { <br> makeApi(sinonGlobal); <br>  } <br> }( <br> typeof sinon === ¬´object¬ª &amp;&amp; sinon // eslint-disable-line no-undef <br> )); <br><br> /** <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> util/core.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> typeOf.js <br> */ <br> /*jslint eqeqeq: false, onevar: false, plusplus: false*/ <br> /*global module, require, sinon*/ <br> /** <br> * Match functions <br>  * <br> * <a href="https://habrahabr.ru/users/author/" class="user_link">author</a> Maximilian Antoni (mail@maxantoni.de) <br> * @license BSD <br>  * <br> * Copyright ¬© 2012 Maximilian Antoni <br> */ <br> (function (sinonGlobal) { <br><br> function makeApi(sinon) { <br> function assertType(value, type, name) { <br> var actual = sinon.typeOf(value); <br> if (actual !== type) { <br> throw new TypeError(¬´Expected type of ¬ª + name + " to be " + <br> type + ", but was " + actual); <br>  } <br>  } <br><br> var matcher = { <br> toString: function () { <br> return this.message; <br>  } <br>  }; <br><br> function isMatcher(object) { <br> return matcher.isPrototypeOf(object); <br>  } <br><br> function matchObject(expectation, actual) { <br> if (actual === null || actual === undefined) { <br>  return false; <br>  } <br> for (var key in expectation) { <br> if (expectation.hasOwnProperty(key)) { <br> var exp = expectation[key]; <br> var act = actual[key]; <br> if (isMatcher(exp)) { <br> if (!exp.test(act)) { <br>  return false; <br>  } <br> } else if (sinon.typeOf(exp) === ¬´object¬ª) { <br> if (!matchObject(exp, act)) { <br>  return false; <br>  } <br> } else if (!sinon.deepEqual(exp, act)) { <br>  return false; <br>  } <br>  } <br>  } <br>  return true; <br>  } <br><br> function match(expectation, message) { <br> var m = sinon.create(matcher); <br> var type = sinon.typeOf(expectation); <br> switch (type) { <br> case ¬´object¬ª: <br> if (typeof expectation.test === ¬´function¬ª) { <br> m.test = function (actual) { <br> return expectation.test(actual) === true; <br>  }; <br> m.message = ¬´match(¬ª + sinon.functionName(expectation.test) + ")"; <br> return m; <br>  } <br> var str = []; <br> for (var key in expectation) { <br> if (expectation.hasOwnProperty(key)) { <br> str.push(key + ": " + expectation[key]); <br>  } <br>  } <br> m.test = function (actual) { <br> return matchObject(expectation, actual); <br>  }; <br> m.message = ¬´match(¬ª + str.join(", ") + ")"; <br>  break; <br> case ¬´number¬ª: <br> m.test = function (actual) { <br> // we need type coercion here <br> return expectation == actual; // eslint-disable-line eqeqeq <br>  }; <br>  break; <br> case ¬´string¬ª: <br> m.test = function (actual) { <br> if (typeof actual !== ¬´string¬ª) { <br>  return false; <br>  } <br> return actual.indexOf(expectation) !== -1; <br>  }; <br> m.message = ¬´match(\¬ª" + expectation + "\")"; <br>  break; <br> case ¬´regexp¬ª: <br> m.test = function (actual) { <br> if (typeof actual !== ¬´string¬ª) { <br>  return false; <br>  } <br> return expectation.test(actual); <br>  }; <br>  break; <br> case ¬´function¬ª: <br> m.test = expectation; <br> if (message) { <br> m.message = message; <br>  } else { <br> m.message = ¬´match(¬ª + sinon.functionName(expectation) + ")"; <br>  } <br>  break; <br> default: <br> m.test = function (actual) { <br> return sinon.deepEqual(expectation, actual); <br>  }; <br>  } <br> if (!m.message) { <br> m.message = ¬´match(¬ª + expectation + ")"; <br>  } <br> return m; <br>  } <br><br> matcher.or = function (m2) { <br> if (!arguments.length) { <br> throw new TypeError(¬´Matcher expected¬ª); <br> } else if (!isMatcher(m2)) { <br> m2 = match(m2); <br>  } <br> var m1 = this; <br> var or = sinon.create(matcher); <br> or.test = function (actual) { <br> return m1.test(actual) || m2.test(actual); <br>  }; <br> or.message = m1.message + ".or(" + m2.message + ")"; <br> return or; <br>  }; <br><br> matcher.and = function (m2) { <br> if (!arguments.length) { <br> throw new TypeError(¬´Matcher expected¬ª); <br> } else if (!isMatcher(m2)) { <br> m2 = match(m2); <br>  } <br> var m1 = this; <br> var and = sinon.create(matcher); <br> and.test = function (actual) { <br> return m1.test(actual) &amp;&amp; m2.test(actual); <br>  }; <br> and.message = m1.message + ".and(" + m2.message + ")"; <br> return and; <br>  }; <br><br> match.isMatcher = isMatcher; <br><br> match.any = match(function () { <br>  return true; <br> }, ¬´any¬ª); <br><br> match.defined = match(function (actual) { <br> return actual !== null &amp;&amp; actual !== undefined; <br> }, ¬´defined¬ª); <br><br> match.truthy = match(function (actual) { <br> return !!actual; <br> }, ¬´truthy¬ª); <br><br> match.falsy = match(function (actual) { <br> return !actual; <br> }, ¬´falsy¬ª); <br><br> match.same = function (expectation) { <br> return match(function (actual) { <br> return expectation === actual; <br> }, ¬´same(¬ª + expectation + ")"); <br>  }; <br><br> match.typeOf = function (type) { <br> assertType(type, ¬´string¬ª, ¬´type¬ª); <br> return match(function (actual) { <br> return sinon.typeOf(actual) === type; <br> }, ¬´typeOf(\¬ª" + type + "\")"); <br>  }; <br><br> match.instanceOf = function (type) { <br> assertType(type, ¬´function¬ª, ¬´type¬ª); <br> return match(function (actual) { <br> return actual instanceof type; <br> }, ¬´instanceOf(¬ª + sinon.functionName(type) + ")"); <br>  }; <br><br> function createPropertyMatcher(propertyTest, messagePrefix) { <br> return function (property, value) { <br> assertType(property, ¬´string¬ª, ¬´property¬ª); <br> var onlyProperty = arguments.length === 1; <br> var message = messagePrefix + "(\"" + property + "\""; <br> if (!onlyProperty) { <br> message += ", " + value; <br>  } <br> message += ")"; <br> return match(function (actual) { <br> if (actual === undefined || actual === null || <br> !propertyTest(actual, property)) { <br>  return false; <br>  } <br> return onlyProperty || sinon.deepEqual(value, actual[property]); <br> }, message); <br>  }; <br>  } <br><br> match.has = createPropertyMatcher(function (actual, property) { <br> if (typeof actual === ¬´object¬ª) { <br> return property in actual; <br>  } <br> return actual[property] !== undefined; <br> }, ¬´has¬ª); <br><br> match.hasOwn = createPropertyMatcher(function (actual, property) { <br> return actual.hasOwnProperty(property); <br> }, ¬´hasOwn¬ª); <br><br> match.bool = match.typeOf(¬´boolean¬ª); <br> match.number = match.typeOf(¬´number¬ª); <br> match.string = match.typeOf(¬´string¬ª); <br> match.object = match.typeOf(¬´object¬ª); <br> match.func = match.typeOf(¬´function¬ª); <br> match.array = match.typeOf(¬´array¬ª); <br> match.regexp = match.typeOf(¬´regexp¬ª); <br> match.date = match.typeOf(¬´date¬ª); <br><br> sinon.match = match; <br> return match; <br>  } <br><br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var isAMD = typeof define === ¬´function¬ª &amp;&amp; typeof define.amd === ¬´object¬ª &amp;&amp; define.amd; <br><br> function loadDependencies(require, exports, module) { <br> var sinon = require("./util/core"); <br> require("./typeOf"); <br> module.exports = makeApi(sinon); <br>  } <br><br> if (isAMD) { <br> define(loadDependencies); <br>  return; <br>  } <br><br> if (isNode) { <br> loadDependencies(require, module.exports, module); <br>  return; <br>  } <br><br> if (sinonGlobal) { <br> makeApi(sinonGlobal); <br>  } <br> }( <br> typeof sinon === ¬´object¬ª &amp;&amp; sinon // eslint-disable-line no-undef <br> )); <br><br> /** <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> util/core.js <br> */ <br> /** <br> * Format functions <br>  * <br> * <a href="https://habrahabr.ru/users/author/" class="user_link">author</a> Christian Johansen (christian@cjohansen.no) <br> * @license BSD <br>  * <br> * Copyright ¬© 2010-2014 Christian Johansen <br> */ <br> (function (sinonGlobal, formatio) { <br><br> function makeApi(sinon) { <br> function valueFormatter(value) { <br> return "" + value; <br>  } <br><br> function getFormatioFormatter() { <br> var formatter = formatio.configure({ <br> quoteStrings: false, <br> limitChildrenCount: 250 <br>  }); <br><br> function format() { <br> return formatter.ascii.apply(formatter, arguments); <br>  } <br><br> return format; <br>  } <br><br> function getNodeFormatter() { <br>  try { <br> var util = require(¬´util¬ª); <br>  } catch (e) { <br> /* Node, but no util module ‚Äî would be very old, but better safe than sorry */ <br>  } <br><br> function format(v) { <br> var isObjectWithNativeToString = typeof v === ¬´object¬ª &amp;&amp; v.toString === Object.prototype.toString; <br> return isObjectWithNativeToString? util.inspect(v): v; <br>  } <br><br> return util? format: valueFormatter; <br>  } <br><br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var formatter; <br><br> if (isNode) { <br>  try { <br> formatio = require(¬´formatio¬ª); <br>  } <br> catch (e) {} // eslint-disable-line no-empty <br>  } <br><br> if (formatio) { <br> formatter = getFormatioFormatter(); <br> } else if (isNode) { <br> formatter = getNodeFormatter(); <br>  } else { <br> formatter = valueFormatter; <br>  } <br><br> sinon.format = formatter; <br> return sinon.format; <br>  } <br><br> function loadDependencies(require, exports, module) { <br> var sinon = require("./util/core"); <br> module.exports = makeApi(sinon); <br>  } <br><br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var isAMD = typeof define === ¬´function¬ª &amp;&amp; typeof define.amd === ¬´object¬ª &amp;&amp; define.amd; <br><br> if (isAMD) { <br> define(loadDependencies); <br>  return; <br>  } <br><br> if (isNode) { <br> loadDependencies(require, module.exports, module); <br>  return; <br>  } <br><br> if (sinonGlobal) { <br> makeApi(sinonGlobal); <br>  } <br> }( <br> typeof sinon === ¬´object¬ª &amp;&amp; sinon, // eslint-disable-line no-undef <br> typeof formatio === ¬´object¬ª &amp;&amp; formatio // eslint-disable-line no-undef <br> )); <br><br> /** <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> util/core.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> match.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> format.js <br> */ <br> /** <br> * Spy calls <br>  * <br> * <a href="https://habrahabr.ru/users/author/" class="user_link">author</a> Christian Johansen (christian@cjohansen.no) <br> * <a href="https://habrahabr.ru/users/author/" class="user_link">author</a> Maximilian Antoni (mail@maxantoni.de) <br> * @license BSD <br>  * <br> * Copyright ¬© 2010-2013 Christian Johansen <br> * Copyright ¬© 2013 Maximilian Antoni <br> */ <br> (function (sinonGlobal) { <br><br> var slice = Array.prototype.slice; <br><br> function makeApi(sinon) { <br> function throwYieldError(proxy, text, args) { <br> var msg = sinon.functionName(proxy) + text; <br> if (args.length) { <br> msg += " Received [" + slice.call(args).join(", ") + "]"; <br>  } <br> throw new Error(msg); <br>  } <br><br> var callProto = { <br> calledOn: function calledOn(thisValue) { <br> if (sinon.match &amp;&amp; sinon.match.isMatcher(thisValue)) { <br> return thisValue.test(this.thisValue); <br>  } <br> return this.thisValue === thisValue; <br>  }, <br><br> calledWith: function calledWith() { <br> var l = arguments.length; <br> if (l &gt; this.args.length) { <br>  return false; <br>  } <br> for (var i = 0; i &lt; l; i += 1) { <br> if (!sinon.deepEqual(arguments[i], this.args[i])) { <br>  return false; <br>  } <br>  } <br><br>  return true; <br>  }, <br><br> calledWithMatch: function calledWithMatch() { <br> var l = arguments.length; <br> if (l &gt; this.args.length) { <br>  return false; <br>  } <br> for (var i = 0; i &lt; l; i += 1) { <br> var actual = this.args[i]; <br> var expectation = arguments[i]; <br> if (!sinon.match || !sinon.match(expectation).test(actual)) { <br>  return false; <br>  } <br>  } <br>  return true; <br>  }, <br><br> calledWithExactly: function calledWithExactly() { <br> return arguments.length === this.args.length &amp;&amp; <br> this.calledWith.apply(this, arguments); <br>  }, <br><br> notCalledWith: function notCalledWith() { <br> return !this.calledWith.apply(this, arguments); <br>  }, <br><br> notCalledWithMatch: function notCalledWithMatch() { <br> return !this.calledWithMatch.apply(this, arguments); <br>  }, <br><br> returned: function returned(value) { <br> return sinon.deepEqual(value, this.returnValue); <br>  }, <br><br> threw: function threw(error) { <br> if (typeof error === ¬´undefined¬ª || !this.exception) { <br> return !!this.exception; <br>  } <br><br> return this.exception === error || this.exception.name === error; <br>  }, <br><br> calledWithNew: function calledWithNew() { <br> return this.proxy.prototype &amp;&amp; this.thisValue instanceof this.proxy; <br>  }, <br><br> calledBefore: function (other) { <br> return this.callId &lt; other.callId; <br>  }, <br><br> calledAfter: function (other) { <br> return this.callId &gt; other.callId; <br>  }, <br><br> callArg: function (pos) { <br> this.args[pos](); <br>  }, <br><br> callArgOn: function (pos, thisValue) { <br> this.args[pos].apply(thisValue); <br>  }, <br><br> callArgWith: function (pos) { <br> this.callArgOnWith.apply(this, [pos, null].concat(slice.call(arguments, 1))); <br>  }, <br><br> callArgOnWith: function (pos, thisValue) { <br> var args = slice.call(arguments, 2); <br> this.args[pos].apply(thisValue, args); <br>  }, <br><br> ¬´yield¬ª: function () { <br> this.yieldOn.apply(this, [null].concat(slice.call(arguments, 0))); <br>  }, <br><br> yieldOn: function (thisValue) { <br> var args = this.args; <br> for (var i = 0, l = args.length; i &lt; l; ++i) { <br> if (typeof args[i] === ¬´function¬ª) { <br> args[i].apply(thisValue, slice.call(arguments, 1)); <br>  return; <br>  } <br>  } <br> throwYieldError(this.proxy, " cannot yield since no callback was passed.", args); <br>  }, <br><br> yieldTo: function (prop) { <br> this.yieldToOn.apply(this, [prop, null].concat(slice.call(arguments, 1))); <br>  }, <br><br> yieldToOn: function (prop, thisValue) { <br> var args = this.args; <br> for (var i = 0, l = args.length; i &lt; l; ++i) { <br> if (args[i] &amp;&amp; typeof args[i][prop] === ¬´function¬ª) { <br> args[i][prop].apply(thisValue, slice.call(arguments, 2)); <br>  return; <br>  } <br>  } <br> throwYieldError(this.proxy, " cannot yield to '" + prop + <br> "' since no callback was passed.", args); <br>  }, <br><br> getStackFrames: function () { <br> // Omit the error message and the two top stack frames in sinon itself: <br> return this.stack &amp;&amp; this.stack.split("\n").slice(3); <br>  }, <br><br> toString: function () { <br> var callStr = this.proxy.toString() + "("; <br> var args = []; <br><br> for (var i = 0, l = this.args.length; i &lt; l; ++i) { <br> args.push(sinon.format(this.args[i])); <br>  } <br><br> callStr = callStr + args.join(", ") + ")"; <br><br> if (typeof this.returnValue !== ¬´undefined¬ª) { <br> callStr += " =&gt; " + sinon.format(this.returnValue); <br>  } <br><br> if (this.exception) { <br> callStr += " !" + this.exception.name; <br><br> if (this.exception.message) { <br> callStr += "(" + this.exception.message + ")"; <br>  } <br>  } <br> if (this.stack) { <br> callStr += this.getStackFrames()[0].replace(/^\s*(?:at\s+|@)?/, " at "); <br><br>  } <br><br> return callStr; <br>  } <br>  }; <br><br> callProto.invokeCallback = callProto.yield; <br><br> function createSpyCall(spy, thisValue, args, returnValue, exception, id, stack) { <br> if (typeof id !== ¬´number¬ª) { <br> throw new TypeError(¬´Call id is not a number¬ª); <br>  } <br> var proxyCall = sinon.create(callProto); <br> proxyCall.proxy = spy; <br> proxyCall.thisValue = thisValue; <br> proxyCall.args = args; <br> proxyCall.returnValue = returnValue; <br> proxyCall.exception = exception; <br> proxyCall.callId = id; <br> proxyCall.stack = stack; <br><br> return proxyCall; <br>  } <br> createSpyCall.toString = callProto.toString; // used by mocks <br><br> sinon.spyCall = createSpyCall; <br> return createSpyCall; <br>  } <br><br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var isAMD = typeof define === ¬´function¬ª &amp;&amp; typeof define.amd === ¬´object¬ª &amp;&amp; define.amd; <br><br> function loadDependencies(require, exports, module) { <br> var sinon = require("./util/core"); <br> require("./match"); <br> require("./format"); <br> module.exports = makeApi(sinon); <br>  } <br><br> if (isAMD) { <br> define(loadDependencies); <br>  return; <br>  } <br><br> if (isNode) { <br> loadDependencies(require, module.exports, module); <br>  return; <br>  } <br><br> if (sinonGlobal) { <br> makeApi(sinonGlobal); <br>  } <br> }( <br> typeof sinon === ¬´object¬ª &amp;&amp; sinon // eslint-disable-line no-undef <br> )); <br><br> /** <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> times_in_words.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> util/core.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> extend.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> call.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> format.js <br> */ <br> /** <br> * Spy functions <br>  * <br> * <a href="https://habrahabr.ru/users/author/" class="user_link">author</a> Christian Johansen (christian@cjohansen.no) <br> * @license BSD <br>  * <br> * Copyright ¬© 2010-2013 Christian Johansen <br> */ <br> (function (sinonGlobal) { <br><br> function makeApi(sinon) { <br> var push = Array.prototype.push; <br> var slice = Array.prototype.slice; <br> var callId = 0; <br><br> function spy(object, property, types) { <br> if (!property &amp;&amp; typeof object === ¬´function¬ª) { <br> return spy.create(object); <br>  } <br><br> if (!object &amp;&amp; !property) { <br> return spy.create(function () { }); <br>  } <br><br> if (types) { <br> var methodDesc = sinon.getPropertyDescriptor(object, property); <br> for (var i = 0; i &lt; types.length; i++) { <br> methodDesc[types[i]] = spy.create(methodDesc[types[i]]); <br>  } <br> return sinon.wrapMethod(object, property, methodDesc); <br>  } <br><br> return sinon.wrapMethod(object, property, spy.create(object[property])); <br>  } <br><br> function matchingFake(fakes, args, strict) { <br> if (!fakes) { <br> return undefined; <br>  } <br><br> for (var i = 0, l = fakes.length; i &lt; l; i++) { <br> if (fakes[i].matches(args, strict)) { <br> return fakes[i]; <br>  } <br>  } <br>  } <br><br> function incrementCallCount() { <br> this.called = true; <br> this.callCount += 1; <br> this.notCalled = false; <br> this.calledOnce = this.callCount === 1; <br> this.calledTwice = this.callCount === 2; <br> this.calledThrice = this.callCount === 3; <br>  } <br><br> function createCallProperties() { <br> this.firstCall = this.getCall(0); <br> this.secondCall = this.getCall(1); <br> this.thirdCall = this.getCall(2); <br> this.lastCall = this.getCall(this.callCount ‚Äî 1); <br>  } <br><br> var vars = ¬´a,b,c,d,e,f,g,h,i,j,k,l¬ª; <br> function createProxy(func, proxyLength) { <br> // Retain the function length: <br> var p; <br> if (proxyLength) { <br> eval(¬´p = (function proxy(¬ª + vars.substring(0, proxyLength * 2 ‚Äî 1) + // eslint-disable-line no-eval <br> ") { return p.invoke(func, this, slice.call(arguments)); });"); <br>  } else { <br> p = function proxy() { <br> return p.invoke(func, this, slice.call(arguments)); <br>  }; <br>  } <br> p.isSinonProxy = true; <br> return p; <br>  } <br><br> var uuid = 0; <br><br> // Public API <br> var spyApi = { <br> reset: function () { <br> if (this.invoking) { <br> var err = new Error(¬´Cannot reset Sinon function while invoking it. ¬ª + <br> ¬´Move the call to .reset outside of the callback.¬ª); <br> err.name = ¬´InvalidResetException¬ª; <br> throw err; <br>  } <br><br> this.called = false; <br> this.notCalled = true; <br> this.calledOnce = false; <br> this.calledTwice = false; <br> this.calledThrice = false; <br> this.callCount = 0; <br> this.firstCall = null; <br> this.secondCall = null; <br> this.thirdCall = null; <br> this.lastCall = null; <br> this.args = []; <br> this.returnValues = []; <br> this.thisValues = []; <br> this.exceptions = []; <br> this.callIds = []; <br> this.stacks = []; <br> if (this.fakes) { <br> for (var i = 0; i &lt; this.fakes.length; i++) { <br> this.fakes[i].reset(); <br>  } <br>  } <br><br> return this; <br>  }, <br><br> create: function create(func, spyLength) { <br> var name; <br><br> if (typeof func !== ¬´function¬ª) { <br> func = function () { }; <br>  } else { <br> name = sinon.functionName(func); <br>  } <br><br> if (!spyLength) { <br> spyLength = func.length; <br>  } <br><br> var proxy = createProxy(func, spyLength); <br><br> sinon.extend(proxy, spy); <br> delete proxy.create; <br> sinon.extend(proxy, func); <br><br> proxy.reset(); <br> proxy.prototype = func.prototype; <br> proxy.displayName = name || ¬´spy¬ª; <br> proxy.toString = sinon.functionToString; <br> proxy.instantiateFake = sinon.spy.create; <br> proxy.id = ¬´spy#¬ª + uuid++; <br><br> return proxy; <br>  }, <br><br> invoke: function invoke(func, thisValue, args) { <br> var matching = matchingFake(this.fakes, args); <br> var exception, returnValue; <br><br> incrementCallCount.call(this); <br> push.call(this.thisValues, thisValue); <br> push.call(this.args, args); <br> push.call(this.callIds, callId++); <br><br> // Make call properties available from within the spied function: <br> createCallProperties.call(this); <br><br>  try { <br> this.invoking = true; <br><br> if (matching) { <br> returnValue = matching.invoke(func, thisValue, args); <br>  } else { <br> returnValue = (this.func || func).apply(thisValue, args); <br>  } <br><br> var thisCall = this.getCall(this.callCount ‚Äî 1); <br> if (thisCall.calledWithNew() &amp;&amp; typeof returnValue !== ¬´object¬ª) { <br> returnValue = thisValue; <br>  } <br>  } catch (e) { <br> exception = e; <br> } finally { <br> delete this.invoking; <br>  } <br><br> push.call(this.exceptions, exception); <br> push.call(this.returnValues, returnValue); <br> push.call(this.stacks, new Error().stack); <br><br> // Make return value and exception available in the calls: <br> createCallProperties.call(this); <br><br> if (exception !== undefined) { <br> throw exception; <br>  } <br><br> return returnValue; <br>  }, <br><br> named: function named(name) { <br> this.displayName = name; <br> return this; <br>  }, <br><br> getCall: function getCall(i) { <br> if (i &lt; 0 || i &gt;= this.callCount) { <br> return null; <br>  } <br><br> return sinon.spyCall(this, this.thisValues[i], this.args[i], <br> this.returnValues[i], this.exceptions[i], <br> this.callIds[i], this.stacks[i]); <br>  }, <br><br> getCalls: function () { <br> var calls = []; <br> var i; <br><br> for (i = 0; i &lt; this.callCount; i++) { <br> calls.push(this.getCall(i)); <br>  } <br><br> return calls; <br>  }, <br><br> calledBefore: function calledBefore(spyFn) { <br> if (!this.called) { <br>  return false; <br>  } <br><br> if (!spyFn.called) { <br>  return true; <br>  } <br><br> return this.callIds[0] &lt; spyFn.callIds[spyFn.callIds.length ‚Äî 1]; <br>  }, <br><br> calledAfter: function calledAfter(spyFn) { <br> if (!this.called || !spyFn.called) { <br>  return false; <br>  } <br><br> return this.callIds[this.callCount ‚Äî 1] &gt; spyFn.callIds[spyFn.callCount ‚Äî 1]; <br>  }, <br><br> withArgs: function () { <br> var args = slice.call(arguments); <br><br> if (this.fakes) { <br> var match = matchingFake(this.fakes, args, true); <br><br> if (match) { <br> return match; <br>  } <br>  } else { <br> this.fakes = []; <br>  } <br><br> var original = this; <br> var fake = this.instantiateFake(); <br> fake.matchingAguments = args; <br> fake.parent = this; <br> push.call(this.fakes, fake); <br><br> fake.withArgs = function () { <br> return original.withArgs.apply(original, arguments); <br>  }; <br><br> for (var i = 0; i &lt; this.args.length; i++) { <br> if (fake.matches(this.args[i])) { <br> incrementCallCount.call(fake); <br> push.call(fake.thisValues, this.thisValues[i]); <br> push.call(fake.args, this.args[i]); <br> push.call(fake.returnValues, this.returnValues[i]); <br> push.call(fake.exceptions, this.exceptions[i]); <br> push.call(fake.callIds, this.callIds[i]); <br>  } <br>  } <br> createCallProperties.call(fake); <br><br> return fake; <br>  }, <br><br> matches: function (args, strict) { <br> var margs = this.matchingAguments; <br><br> if (margs.length &lt;= args.length &amp;&amp; <br> sinon.deepEqual(margs, args.slice(0, margs.length))) { <br> return !strict || margs.length === args.length; <br>  } <br>  }, <br><br> printf: function (format) { <br> var spyInstance = this; <br> var args = slice.call(arguments, 1); <br> var formatter; <br><br> return (format || "").replace(/%(.)/g, function (match, specifyer) { <br> formatter = spyApi.formatters[specifyer]; <br><br> if (typeof formatter === ¬´function¬ª) { <br> return formatter.call(null, spyInstance, args); <br> } else if (!isNaN(parseInt(specifyer, 10))) { <br> return sinon.format(args[specifyer ‚Äî 1]); <br>  } <br><br> return "%" + specifyer; <br>  }); <br>  } <br>  }; <br><br> function delegateToCalls(method, matchAny, actual, notCalled) { <br> spyApi[method] = function () { <br> if (!this.called) { <br> if (notCalled) { <br> return notCalled.apply(this, arguments); <br>  } <br>  return false; <br>  } <br><br> var currentCall; <br> var matches = 0; <br><br> for (var i = 0, l = this.callCount; i &lt; l; i += 1) { <br> currentCall = this.getCall(i); <br><br> if (currentCall[actual || method].apply(currentCall, arguments)) { <br> matches += 1; <br><br> if (matchAny) { <br>  return true; <br>  } <br>  } <br>  } <br><br> return matches === this.callCount; <br>  }; <br>  } <br><br> delegateToCalls(¬´calledOn¬ª, true); <br> delegateToCalls(¬´alwaysCalledOn¬ª, false, ¬´calledOn¬ª); <br> delegateToCalls(¬´calledWith¬ª, true); <br> delegateToCalls(¬´calledWithMatch¬ª, true); <br> delegateToCalls(¬´alwaysCalledWith¬ª, false, ¬´calledWith¬ª); <br> delegateToCalls(¬´alwaysCalledWithMatch¬ª, false, ¬´calledWithMatch¬ª); <br> delegateToCalls(¬´calledWithExactly¬ª, true); <br> delegateToCalls(¬´alwaysCalledWithExactly¬ª, false, ¬´calledWithExactly¬ª); <br> delegateToCalls(¬´neverCalledWith¬ª, false, ¬´notCalledWith¬ª, function () { <br>  return true; <br>  }); <br> delegateToCalls(¬´neverCalledWithMatch¬ª, false, ¬´notCalledWithMatch¬ª, function () { <br>  return true; <br>  }); <br> delegateToCalls(¬´threw¬ª, true); <br> delegateToCalls(¬´alwaysThrew¬ª, false, ¬´threw¬ª); <br> delegateToCalls(¬´returned¬ª, true); <br> delegateToCalls(¬´alwaysReturned¬ª, false, ¬´returned¬ª); <br> delegateToCalls(¬´calledWithNew¬ª, true); <br> delegateToCalls(¬´alwaysCalledWithNew¬ª, false, ¬´calledWithNew¬ª); <br> delegateToCalls(¬´callArg¬ª, false, ¬´callArgWith¬ª, function () { <br> throw new Error(this.toString() + " cannot call arg since it was not yet invoked."); <br>  }); <br> spyApi.callArgWith = spyApi.callArg; <br> delegateToCalls(¬´callArgOn¬ª, false, ¬´callArgOnWith¬ª, function () { <br> throw new Error(this.toString() + " cannot call arg since it was not yet invoked."); <br>  }); <br> spyApi.callArgOnWith = spyApi.callArgOn; <br> delegateToCalls(¬´yield¬ª, false, ¬´yield¬ª, function () { <br> throw new Error(this.toString() + " cannot yield since it was not yet invoked."); <br>  }); <br> // ¬´invokeCallback¬ª is an alias for ¬´yield¬ª since ¬´yield¬ª is invalid in strict mode. <br> spyApi.invokeCallback = spyApi.yield; <br> delegateToCalls(¬´yieldOn¬ª, false, ¬´yieldOn¬ª, function () { <br> throw new Error(this.toString() + " cannot yield since it was not yet invoked."); <br>  }); <br> delegateToCalls(¬´yieldTo¬ª, false, ¬´yieldTo¬ª, function (property) { <br> throw new Error(this.toString() + " cannot yield to '" + property + <br> "' since it was not yet invoked."); <br>  }); <br> delegateToCalls(¬´yieldToOn¬ª, false, ¬´yieldToOn¬ª, function (property) { <br> throw new Error(this.toString() + " cannot yield to '" + property + <br> "' since it was not yet invoked."); <br>  }); <br><br> spyApi.formatters = { <br> c: function (spyInstance) { <br> return sinon.timesInWords(spyInstance.callCount); <br>  }, <br><br> n: function (spyInstance) { <br> return spyInstance.toString(); <br>  }, <br><br> C: function (spyInstance) { <br> var calls = []; <br><br> for (var i = 0, l = spyInstance.callCount; i &lt; l; ++i) { <br> var stringifiedCall = " " + spyInstance.getCall(i).toString(); <br> if (/\n/.test(calls[i ‚Äî 1])) { <br> stringifiedCall = "\n" + stringifiedCall; <br>  } <br> push.call(calls, stringifiedCall); <br>  } <br><br> return calls.length &gt; 0? "\n" + calls.join("\n"): ""; <br>  }, <br><br> t: function (spyInstance) { <br> var objects = []; <br><br> for (var i = 0, l = spyInstance.callCount; i &lt; l; ++i) { <br> push.call(objects, sinon.format(spyInstance.thisValues[i])); <br>  } <br><br> return objects.join(", "); <br>  }, <br><br> "*": function (spyInstance, args) { <br> var formatted = []; <br><br> for (var i = 0, l = args.length; i &lt; l; ++i) { <br> push.call(formatted, sinon.format(args[i])); <br>  } <br><br> return formatted.join(", "); <br>  } <br>  }; <br><br> sinon.extend(spy, spyApi); <br><br> spy.spyCall = sinon.spyCall; <br> sinon.spy = spy; <br><br> return spy; <br>  } <br><br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var isAMD = typeof define === ¬´function¬ª &amp;&amp; typeof define.amd === ¬´object¬ª &amp;&amp; define.amd; <br><br> function loadDependencies(require, exports, module) { <br> var core = require("./util/core"); <br> require("./call"); <br> require("./extend"); <br> require("./times_in_words"); <br> require("./format"); <br> module.exports = makeApi(core); <br>  } <br><br> if (isAMD) { <br> define(loadDependencies); <br>  return; <br>  } <br><br> if (isNode) { <br> loadDependencies(require, module.exports, module); <br>  return; <br>  } <br><br> if (sinonGlobal) { <br> makeApi(sinonGlobal); <br>  } <br> }( <br> typeof sinon === ¬´object¬ª &amp;&amp; sinon // eslint-disable-line no-undef <br> )); <br><br> /** <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> util/core.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> extend.js <br> */ <br> /** <br> * Stub behavior <br>  * <br> * <a href="https://habrahabr.ru/users/author/" class="user_link">author</a> Christian Johansen (christian@cjohansen.no) <br> * <a href="https://habrahabr.ru/users/author/" class="user_link">author</a> Tim Fischbach (mail@timfischbach.de) <br> * @license BSD <br>  * <br> * Copyright ¬© 2010-2013 Christian Johansen <br> */ <br> (function (sinonGlobal) { <br><br> var slice = Array.prototype.slice; <br> var join = Array.prototype.join; <br> var useLeftMostCallback = -1; <br> var useRightMostCallback = -2; <br><br> var nextTick = (function () { <br> if (typeof process === ¬´object¬ª &amp;&amp; typeof process.nextTick === ¬´function¬ª) { <br> return process.nextTick; <br>  } <br><br> if (typeof setImmediate === ¬´function¬ª) { <br> return setImmediate; <br>  } <br><br> return function (callback) { <br> setTimeout(callback, 0); <br>  }; <br>  }) (); <br><br> function throwsException(error, message) { <br> if (typeof error === ¬´string¬ª) { <br> this.exception = new Error(message || ""); <br> this.exception.name = error; <br> } else if (!error) { <br> this.exception = new Error(¬´Error¬ª); <br>  } else { <br> this.exception = error; <br>  } <br><br> return this; <br>  } <br><br> function getCallback(behavior, args) { <br> var callArgAt = behavior.callArgAt; <br><br> if (callArgAt &gt;= 0) { <br> return args[callArgAt]; <br>  } <br><br> var argumentList; <br><br> if (callArgAt === useLeftMostCallback) { <br> argumentList = args; <br>  } <br><br> if (callArgAt === useRightMostCallback) { <br> argumentList = slice.call(args).reverse(); <br>  } <br><br> var callArgProp = behavior.callArgProp; <br><br> for (var i = 0, l = argumentList.length; i &lt; l; ++i) { <br> if (!callArgProp &amp;&amp; typeof argumentList[i] === ¬´function¬ª) { <br> return argumentList[i]; <br>  } <br><br> if (callArgProp &amp;&amp; argumentList[i] &amp;&amp; <br> typeof argumentList[i][callArgProp] === ¬´function¬ª) { <br> return argumentList[i][callArgProp]; <br>  } <br>  } <br><br> return null; <br>  } <br><br> function makeApi(sinon) { <br> function getCallbackError(behavior, func, args) { <br> if (behavior.callArgAt &lt; 0) { <br> var msg; <br><br> if (behavior.callArgProp) { <br> msg = sinon.functionName(behavior.stub) + <br> " expected to yield to '" + behavior.callArgProp + <br> "', but no object with such a property was passed."; <br>  } else { <br> msg = sinon.functionName(behavior.stub) + <br> " expected to yield, but no callback was passed."; <br>  } <br><br> if (args.length &gt; 0) { <br> msg += " Received [" + join.call(args, ", ") + "]"; <br>  } <br><br> return msg; <br>  } <br><br> return ¬´argument at index ¬ª + behavior.callArgAt + " is not a function: " + func; <br>  } <br><br> function callCallback(behavior, args) { <br> if (typeof behavior.callArgAt === ¬´number¬ª) { <br> var func = getCallback(behavior, args); <br><br> if (typeof func !== ¬´function¬ª) { <br> throw new TypeError(getCallbackError(behavior, func, args)); <br>  } <br><br> if (behavior.callbackAsync) { <br> nextTick(function () { <br> func.apply(behavior.callbackContext, behavior.callbackArguments); <br>  }); <br>  } else { <br> func.apply(behavior.callbackContext, behavior.callbackArguments); <br>  } <br>  } <br>  } <br><br> var proto = { <br> create: function create(stub) { <br> var behavior = sinon.extend({}, sinon.behavior); <br> delete behavior.create; <br> behavior.stub = stub; <br><br> return behavior; <br>  }, <br><br> isPresent: function isPresent() { <br> return (typeof this.callArgAt === ¬´number¬ª || <br> this.exception || <br> typeof this.returnArgAt === ¬´number¬ª || <br> this.returnThis || <br> this.returnValueDefined); <br>  }, <br><br> invoke: function invoke(context, args) { <br> callCallback(this, args); <br><br> if (this.exception) { <br> throw this.exception; <br> } else if (typeof this.returnArgAt === ¬´number¬ª) { <br> return args[this.returnArgAt]; <br> } else if (this.returnThis) { <br> return context; <br>  } <br><br> return this.returnValue; <br>  }, <br><br> onCall: function onCall(index) { <br> return this.stub.onCall(index); <br>  }, <br><br> onFirstCall: function onFirstCall() { <br> return this.stub.onFirstCall(); <br>  }, <br><br> onSecondCall: function onSecondCall() { <br> return this.stub.onSecondCall(); <br>  }, <br><br> onThirdCall: function onThirdCall() { <br> return this.stub.onThirdCall(); <br>  }, <br><br> withArgs: function withArgs(/* arguments */) { <br> throw new Error( <br> ¬´Defining a stub by invoking \¬ªstub.onCall(...).withArgs(...)\" " + <br> ¬´is not supported. Use \¬ªstub.withArgs(...).onCall(...)\" " + <br> ¬´to define sequential behavior for calls with certain arguments.¬ª <br>  ); <br>  }, <br><br> callsArg: function callsArg(pos) { <br> if (typeof pos !== ¬´number¬ª) { <br> throw new TypeError(¬´argument index is not number¬ª); <br>  } <br><br> this.callArgAt = pos; <br> this.callbackArguments = []; <br> this.callbackContext = undefined; <br> this.callArgProp = undefined; <br> this.callbackAsync = false; <br><br> return this; <br>  }, <br><br> callsArgOn: function callsArgOn(pos, context) { <br> if (typeof pos !== ¬´number¬ª) { <br> throw new TypeError(¬´argument index is not number¬ª); <br>  } <br> if (typeof context !== ¬´object¬ª) { <br> throw new TypeError(¬´argument context is not an object¬ª); <br>  } <br><br> this.callArgAt = pos; <br> this.callbackArguments = []; <br> this.callbackContext = context; <br> this.callArgProp = undefined; <br> this.callbackAsync = false; <br><br> return this; <br>  }, <br><br> callsArgWith: function callsArgWith(pos) { <br> if (typeof pos !== ¬´number¬ª) { <br> throw new TypeError(¬´argument index is not number¬ª); <br>  } <br><br> this.callArgAt = pos; <br> this.callbackArguments = slice.call(arguments, 1); <br> this.callbackContext = undefined; <br> this.callArgProp = undefined; <br> this.callbackAsync = false; <br><br> return this; <br>  }, <br><br> callsArgOnWith: function callsArgWith(pos, context) { <br> if (typeof pos !== ¬´number¬ª) { <br> throw new TypeError(¬´argument index is not number¬ª); <br>  } <br> if (typeof context !== ¬´object¬ª) { <br> throw new TypeError(¬´argument context is not an object¬ª); <br>  } <br><br> this.callArgAt = pos; <br> this.callbackArguments = slice.call(arguments, 2); <br> this.callbackContext = context; <br> this.callArgProp = undefined; <br> this.callbackAsync = false; <br><br> return this; <br>  }, <br><br> yields: function () { <br> this.callArgAt = useLeftMostCallback; <br> this.callbackArguments = slice.call(arguments, 0); <br> this.callbackContext = undefined; <br> this.callArgProp = undefined; <br> this.callbackAsync = false; <br><br> return this; <br>  }, <br><br> yieldsRight: function () { <br> this.callArgAt = useRightMostCallback; <br> this.callbackArguments = slice.call(arguments, 0); <br> this.callbackContext = undefined; <br> this.callArgProp = undefined; <br> this.callbackAsync = false; <br><br> return this; <br>  }, <br><br> yieldsOn: function (context) { <br> if (typeof context !== ¬´object¬ª) { <br> throw new TypeError(¬´argument context is not an object¬ª); <br>  } <br><br> this.callArgAt = useLeftMostCallback; <br> this.callbackArguments = slice.call(arguments, 1); <br> this.callbackContext = context; <br> this.callArgProp = undefined; <br> this.callbackAsync = false; <br><br> return this; <br>  }, <br><br> yieldsTo: function (prop) { <br> this.callArgAt = useLeftMostCallback; <br> this.callbackArguments = slice.call(arguments, 1); <br> this.callbackContext = undefined; <br> this.callArgProp = prop; <br> this.callbackAsync = false; <br><br> return this; <br>  }, <br><br> yieldsToOn: function (prop, context) { <br> if (typeof context !== ¬´object¬ª) { <br> throw new TypeError(¬´argument context is not an object¬ª); <br>  } <br><br> this.callArgAt = useLeftMostCallback; <br> this.callbackArguments = slice.call(arguments, 2); <br> this.callbackContext = context; <br> this.callArgProp = prop; <br> this.callbackAsync = false; <br><br> return this; <br>  }, <br><br> throws: throwsException, <br> throwsException: throwsException, <br><br> returns: function returns(value) { <br> this.returnValue = value; <br> this.returnValueDefined = true; <br> this.exception = undefined; <br><br> return this; <br>  }, <br><br> returnsArg: function returnsArg(pos) { <br> if (typeof pos !== ¬´number¬ª) { <br> throw new TypeError(¬´argument index is not number¬ª); <br>  } <br><br> this.returnArgAt = pos; <br><br> return this; <br>  }, <br><br> returnsThis: function returnsThis() { <br> this.returnThis = true; <br><br> return this; <br>  } <br>  }; <br><br> function createAsyncVersion(syncFnName) { <br> return function () { <br> var result = this[syncFnName].apply(this, arguments); <br> this.callbackAsync = true; <br> return result; <br>  }; <br>  } <br><br> // create asynchronous versions of callsArg* and yields* methods <br> for (var method in proto) { <br> // need to avoid creating anotherasync versions of the newly added async methods <br> if (proto.hasOwnProperty(method) &amp;&amp; method.match(/^(callsArg|yields)/) &amp;&amp; !method.match(/Async/)) { <br> proto[method + ¬´Async¬ª] = createAsyncVersion(method); <br>  } <br>  } <br><br> sinon.behavior = proto; <br> return proto; <br>  } <br><br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var isAMD = typeof define === ¬´function¬ª &amp;&amp; typeof define.amd === ¬´object¬ª &amp;&amp; define.amd; <br><br> function loadDependencies(require, exports, module) { <br> var sinon = require("./util/core"); <br> require("./extend"); <br> module.exports = makeApi(sinon); <br>  } <br><br> if (isAMD) { <br> define(loadDependencies); <br>  return; <br>  } <br><br> if (isNode) { <br> loadDependencies(require, module.exports, module); <br>  return; <br>  } <br><br> if (sinonGlobal) { <br> makeApi(sinonGlobal); <br>  } <br> }( <br> typeof sinon === ¬´object¬ª &amp;&amp; sinon // eslint-disable-line no-undef <br> )); <br><br> /** <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> util/core.js <br> */ <br> (function (sinonGlobal) { <br><br> function makeApi(sinon) { <br> function walkInternal(obj, iterator, context, originalObj, seen) { <br> var proto, prop; <br><br> if (typeof Object.getOwnPropertyNames !== ¬´function¬ª) { <br> // We explicitly want to enumerate through all of the prototype's properties <br> // in this case, therefore we deliberately leave out an own property check. <br> /* eslint-disable guard-for-in */ <br> for (prop in obj) { <br> iterator.call(context, obj[prop], prop, obj); <br>  } <br> /* eslint-enable guard-for-in */ <br><br>  return; <br>  } <br><br> Object.getOwnPropertyNames(obj).forEach(function (k) { <br> if (!seen[k]) { <br> seen[k] = true; <br> var target = typeof Object.getOwnPropertyDescriptor(obj, k).get === ¬´function¬ª? <br> originalObj: obj; <br> iterator.call(context, target[k], k, target); <br>  } <br>  }); <br><br> proto = Object.getPrototypeOf(obj); <br> if (proto) { <br> walkInternal(proto, iterator, context, originalObj, seen); <br>  } <br>  } <br><br> /* Public: walks the prototype chain of an object and iterates over every own property <br> * name encountered. The iterator is called in the same fashion that Array.prototype.forEach <br> * works, where it is passed the value, key, and own object as the 1st, 2nd, and 3rd positional <br> * argument, respectively. In cases where Object.getOwnPropertyNames is not available, walk will <br> * default to using a simple for..in loop. <br>  * <br> * obj ‚Äî The object to walk the prototype chain for. <br> * iterator ‚Äî The function to be called on each pass of the walk. <br> * context ‚Äî (Optional) When given, the iterator will be called with this object as the receiver. <br> */ <br> function walk(obj, iterator, context) { <br> return walkInternal(obj, iterator, context, obj, {}); <br>  } <br><br> sinon.walk = walk; <br> return sinon.walk; <br>  } <br><br> function loadDependencies(require, exports, module) { <br> var sinon = require("./util/core"); <br> module.exports = makeApi(sinon); <br>  } <br><br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var isAMD = typeof define === ¬´function¬ª &amp;&amp; typeof define.amd === ¬´object¬ª &amp;&amp; define.amd; <br><br> if (isAMD) { <br> define(loadDependencies); <br>  return; <br>  } <br><br> if (isNode) { <br> loadDependencies(require, module.exports, module); <br>  return; <br>  } <br><br> if (sinonGlobal) { <br> makeApi(sinonGlobal); <br>  } <br> }( <br> typeof sinon === ¬´object¬ª &amp;&amp; sinon // eslint-disable-line no-undef <br> )); <br><br> /** <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> util/core.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> extend.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> spy.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> behavior.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> walk.js <br> */ <br> /** <br> * Stub functions <br>  * <br> * <a href="https://habrahabr.ru/users/author/" class="user_link">author</a> Christian Johansen (christian@cjohansen.no) <br> * @license BSD <br>  * <br> * Copyright ¬© 2010-2013 Christian Johansen <br> */ <br> (function (sinonGlobal) { <br><br> function makeApi(sinon) { <br> function stub(object, property, func) { <br> if (!!func &amp;&amp; typeof func !== ¬´function¬ª &amp;&amp; typeof func !== ¬´object¬ª) { <br> throw new TypeError(¬´Custom stub should be a function or a property descriptor¬ª); <br>  } <br><br> var wrapper; <br><br> if (func) { <br> if (typeof func === ¬´function¬ª) { <br> wrapper = sinon.spy &amp;&amp; sinon.spy.create? sinon.spy.create(func): func; <br>  } else { <br> wrapper = func; <br> if (sinon.spy &amp;&amp; sinon.spy.create) { <br> var types = sinon.objectKeys(wrapper); <br> for (var i = 0; i &lt; types.length; i++) { <br> wrapper[types[i]] = sinon.spy.create(wrapper[types[i]]); <br>  } <br>  } <br>  } <br>  } else { <br> var stubLength = 0; <br> if (typeof object === ¬´object¬ª &amp;&amp; typeof object[property] === ¬´function¬ª) { <br> stubLength = object[property].length; <br>  } <br> wrapper = stub.create(stubLength); <br>  } <br><br> if (!object &amp;&amp; typeof property === ¬´undefined¬ª) { <br> return sinon.stub.create(); <br>  } <br><br> if (typeof property === ¬´undefined¬ª &amp;&amp; typeof object === ¬´object¬ª) { <br> sinon.walk(object || {}, function (value, prop, propOwner) { <br> // we don't want to stub things like toString(), valueOf(), etc. so we only stub if the object <br> // is not Object.prototype <br> if ( <br> propOwner !== Object.prototype &amp;&amp; <br> prop !== ¬´constructor¬ª &amp;&amp; <br> typeof sinon.getPropertyDescriptor(propOwner, prop).value === ¬´function¬ª <br> ) { <br> stub(object, prop); <br>  } <br>  }); <br><br> return object; <br>  } <br><br> return sinon.wrapMethod(object, property, wrapper); <br>  } <br><br> /*eslint-disable no-use-before-define*/ <br> function getParentBehaviour(stubInstance) { <br> return (stubInstance.parent &amp;&amp; getCurrentBehavior(stubInstance.parent)); <br>  } <br><br> function getDefaultBehavior(stubInstance) { <br> return stubInstance.defaultBehavior || <br> getParentBehaviour(stubInstance) || <br> sinon.behavior.create(stubInstance); <br>  } <br><br> function getCurrentBehavior(stubInstance) { <br> var behavior = stubInstance.behaviors[stubInstance.callCount ‚Äî 1]; <br> return behavior &amp;&amp; behavior.isPresent()? behavior: getDefaultBehavior(stubInstance); <br>  } <br> /*eslint-enable no-use-before-define*/ <br><br> var uuid = 0; <br><br> var proto = { <br> create: function create(stubLength) { <br> var functionStub = function () { <br> return getCurrentBehavior(functionStub).invoke(this, arguments); <br>  }; <br><br> functionStub.id = ¬´stub#¬ª + uuid++; <br> var orig = functionStub; <br> functionStub = sinon.spy.create(functionStub, stubLength); <br> functionStub.func = orig; <br><br> sinon.extend(functionStub, stub); <br> functionStub.instantiateFake = sinon.stub.create; <br> functionStub.displayName = ¬´stub¬ª; <br> functionStub.toString = sinon.functionToString; <br><br> functionStub.defaultBehavior = null; <br> functionStub.behaviors = []; <br><br> return functionStub; <br>  }, <br><br> resetBehavior: function () { <br> var i; <br><br> this.defaultBehavior = null; <br> this.behaviors = []; <br><br> delete this.returnValue; <br> delete this.returnArgAt; <br> this.returnThis = false; <br><br> if (this.fakes) { <br> for (i = 0; i &lt; this.fakes.length; i++) { <br> this.fakes[i].resetBehavior(); <br>  } <br>  } <br>  }, <br><br> onCall: function onCall(index) { <br> if (!this.behaviors[index]) { <br> this.behaviors[index] = sinon.behavior.create(this); <br>  } <br><br> return this.behaviors[index]; <br>  }, <br><br> onFirstCall: function onFirstCall() { <br> return this.onCall(0); <br>  }, <br><br> onSecondCall: function onSecondCall() { <br> return this.onCall(1); <br>  }, <br><br> onThirdCall: function onThirdCall() { <br> return this.onCall(2); <br>  } <br>  }; <br><br> function createBehavior(behaviorMethod) { <br> return function () { <br> this.defaultBehavior = this.defaultBehavior || sinon.behavior.create(this); <br> this.defaultBehavior[behaviorMethod].apply(this.defaultBehavior, arguments); <br> return this; <br>  }; <br>  } <br><br> for (var method in sinon.behavior) { <br> if (sinon.behavior.hasOwnProperty(method) &amp;&amp; <br> !proto.hasOwnProperty(method) &amp;&amp; <br> method !== ¬´create¬ª &amp;&amp; <br> method !== ¬´withArgs¬ª &amp;&amp; <br> method !== ¬´invoke¬ª) { <br> proto[method] = createBehavior(method); <br>  } <br>  } <br><br> sinon.extend(stub, proto); <br> sinon.stub = stub; <br><br> return stub; <br>  } <br><br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var isAMD = typeof define === ¬´function¬ª &amp;&amp; typeof define.amd === ¬´object¬ª &amp;&amp; define.amd; <br><br> function loadDependencies(require, exports, module) { <br> var core = require("./util/core"); <br> require("./behavior"); <br> require("./spy"); <br> require("./extend"); <br> module.exports = makeApi(core); <br>  } <br><br> if (isAMD) { <br> define(loadDependencies); <br>  return; <br>  } <br><br> if (isNode) { <br> loadDependencies(require, module.exports, module); <br>  return; <br>  } <br><br> if (sinonGlobal) { <br> makeApi(sinonGlobal); <br>  } <br> }( <br> typeof sinon === ¬´object¬ª &amp;&amp; sinon // eslint-disable-line no-undef <br> )); <br><br> /** <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> times_in_words.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> util/core.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> call.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> extend.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> match.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> spy.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> stub.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> format.js <br> */ <br> /** <br> * Mock functions. <br>  * <br> * <a href="https://habrahabr.ru/users/author/" class="user_link">author</a> Christian Johansen (christian@cjohansen.no) <br> * @license BSD <br>  * <br> * Copyright ¬© 2010-2013 Christian Johansen <br> */ <br> (function (sinonGlobal) { <br><br> function makeApi(sinon) { <br> var push = [].push; <br> var match = sinon.match; <br><br> function mock(object) { <br> // if (typeof console !== undefined &amp;&amp; console.warn) { <br> // console.warn(¬´mock will be removed from Sinon.JS v2.0¬ª); <br> // } <br><br> if (!object) { <br> return sinon.expectation.create(¬´Anonymous mock¬ª); <br>  } <br><br> return mock.create(object); <br>  } <br><br> function each(collection, callback) { <br> if (!collection) { <br>  return; <br>  } <br><br> for (var i = 0, l = collection.length; i &lt; l; i += 1) { <br> callback(collection[i]); <br>  } <br>  } <br><br> function arrayEquals(arr1, arr2, compareLength) { <br> if (compareLength &amp;&amp; (arr1.length !== arr2.length)) { <br>  return false; <br>  } <br><br> for (var i = 0, l = arr1.length; i &lt; l; i++) { <br> if (!sinon.deepEqual(arr1[i], arr2[i])) { <br>  return false; <br>  } <br>  } <br>  return true; <br>  } <br><br> sinon.extend(mock, { <br> create: function create(object) { <br> if (!object) { <br> throw new TypeError(¬´object is null¬ª); <br>  } <br><br> var mockObject = sinon.extend({}, mock); <br> mockObject.object = object; <br> delete mockObject.create; <br><br> return mockObject; <br>  }, <br><br> expects: function expects(method) { <br> if (!method) { <br> throw new TypeError(¬´method is falsy¬ª); <br>  } <br><br> if (!this.expectations) { <br> this.expectations = {}; <br> this.proxies = []; <br>  } <br><br> if (!this.expectations[method]) { <br> this.expectations[method] = []; <br> var mockObject = this; <br><br> sinon.wrapMethod(this.object, method, function () { <br> return mockObject.invokeMethod(method, this, arguments); <br>  }); <br><br> push.call(this.proxies, method); <br>  } <br><br> var expectation = sinon.expectation.create(method); <br> push.call(this.expectations[method], expectation); <br><br> return expectation; <br>  }, <br><br> restore: function restore() { <br> var object = this.object; <br><br> each(this.proxies, function (proxy) { <br> if (typeof object[proxy].restore === ¬´function¬ª) { <br> object[proxy].restore(); <br>  } <br>  }); <br>  }, <br><br> verify: function verify() { <br> var expectations = this.expectations || {}; <br> var messages = []; <br> var met = []; <br><br> each(this.proxies, function (proxy) { <br> each(expectations[proxy], function (expectation) { <br> if (!expectation.met()) { <br> push.call(messages, expectation.toString()); <br>  } else { <br> push.call(met, expectation.toString()); <br>  } <br>  }); <br>  }); <br><br> this.restore(); <br><br> if (messages.length &gt; 0) { <br> sinon.expectation.fail(messages.concat(met).join("\n")); <br> } else if (met.length &gt; 0) { <br> sinon.expectation.pass(messages.concat(met).join("\n")); <br>  } <br><br>  return true; <br>  }, <br><br> invokeMethod: function invokeMethod(method, thisValue, args) { <br> var expectations = this.expectations &amp;&amp; this.expectations[method]? this.expectations[method]: []; <br> var expectationsWithMatchingArgs = []; <br> var currentArgs = args || []; <br> var i, available; <br><br> for (i = 0; i &lt; expectations.length; i += 1) { <br> var expectedArgs = expectations[i].expectedArguments || []; <br> if (arrayEquals(expectedArgs, currentArgs, expectations[i].expectsExactArgCount)) { <br> expectationsWithMatchingArgs.push(expectations[i]); <br>  } <br>  } <br><br> for (i = 0; i &lt; expectationsWithMatchingArgs.length; i += 1) { <br> if (!expectationsWithMatchingArgs[i].met() &amp;&amp; <br> expectationsWithMatchingArgs[i].allowsCall(thisValue, args)) { <br> return expectationsWithMatchingArgs[i].apply(thisValue, args); <br>  } <br>  } <br><br> var messages = []; <br> var exhausted = 0; <br><br> for (i = 0; i &lt; expectationsWithMatchingArgs.length; i += 1) { <br> if (expectationsWithMatchingArgs[i].allowsCall(thisValue, args)) { <br> available = available || expectationsWithMatchingArgs[i]; <br>  } else { <br> exhausted += 1; <br>  } <br>  } <br><br> if (available &amp;&amp; exhausted === 0) { <br> return available.apply(thisValue, args); <br>  } <br><br> for (i = 0; i &lt; expectations.length; i += 1) { <br> push.call(messages, " " + expectations[i].toString()); <br>  } <br><br> messages.unshift(¬´Unexpected call: ¬ª + sinon.spyCall.toString.call({ <br> proxy: method, <br> args: args <br> })); <br><br> sinon.expectation.fail(messages.join("\n")); <br>  } <br>  }); <br><br> var times = sinon.timesInWords; <br> var slice = Array.prototype.slice; <br><br> function callCountInWords(callCount) { <br> if (callCount === 0) { <br> return ¬´never called¬ª; <br>  } <br><br> return ¬´called ¬ª + times(callCount); <br>  } <br><br> function expectedCallCountInWords(expectation) { <br> var min = expectation.minCalls; <br> var max = expectation.maxCalls; <br><br> if (typeof min === ¬´number¬ª &amp;&amp; typeof max === ¬´number¬ª) { <br> var str = times(min); <br><br> if (min !== max) { <br> str = ¬´at least ¬ª + str + " and at most " + times(max); <br>  } <br><br> return str; <br>  } <br><br> if (typeof min === ¬´number¬ª) { <br> return ¬´at least ¬ª + times(min); <br>  } <br><br> return ¬´at most ¬ª + times(max); <br>  } <br><br> function receivedMinCalls(expectation) { <br> var hasMinLimit = typeof expectation.minCalls === ¬´number¬ª; <br> return !hasMinLimit || expectation.callCount &gt;= expectation.minCalls; <br>  } <br><br> function receivedMaxCalls(expectation) { <br> if (typeof expectation.maxCalls !== ¬´number¬ª) { <br>  return false; <br>  } <br><br> return expectation.callCount === expectation.maxCalls; <br>  } <br><br> function verifyMatcher(possibleMatcher, arg) { <br> var isMatcher = match &amp;&amp; match.isMatcher(possibleMatcher); <br><br> return isMatcher &amp;&amp; possibleMatcher.test(arg) || true; <br>  } <br><br> sinon.expectation = { <br> minCalls: 1, <br> maxCalls: 1, <br><br> create: function create(methodName) { <br> var expectation = sinon.extend(sinon.stub.create(), sinon.expectation); <br> delete expectation.create; <br> expectation.method = methodName; <br><br> return expectation; <br>  }, <br><br> invoke: function invoke(func, thisValue, args) { <br> this.verifyCallAllowed(thisValue, args); <br><br> return sinon.spy.invoke.apply(this, arguments); <br>  }, <br><br> atLeast: function atLeast(num) { <br> if (typeof num !== ¬´number¬ª) { <br> throw new TypeError("'" + num + "' is not number"); <br>  } <br><br> if (!this.limitsSet) { <br> this.maxCalls = null; <br> this.limitsSet = true; <br>  } <br><br> this.minCalls = num; <br><br> return this; <br>  }, <br><br> atMost: function atMost(num) { <br> if (typeof num !== ¬´number¬ª) { <br> throw new TypeError("'" + num + "' is not number"); <br>  } <br><br> if (!this.limitsSet) { <br> this.minCalls = null; <br> this.limitsSet = true; <br>  } <br><br> this.maxCalls = num; <br><br> return this; <br>  }, <br><br> never: function never() { <br> return this.exactly(0); <br>  }, <br><br> once: function once() { <br> return this.exactly(1); <br>  }, <br><br> twice: function twice() { <br> return this.exactly(2); <br>  }, <br><br> thrice: function thrice() { <br> return this.exactly(3); <br>  }, <br><br> exactly: function exactly(num) { <br> if (typeof num !== ¬´number¬ª) { <br> throw new TypeError("'" + num + "' is not a number"); <br>  } <br><br> this.atLeast(num); <br> return this.atMost(num); <br>  }, <br><br> met: function met() { <br> return !this.failed &amp;&amp; receivedMinCalls(this); <br>  }, <br><br> verifyCallAllowed: function verifyCallAllowed(thisValue, args) { <br> if (receivedMaxCalls(this)) { <br> this.failed = true; <br> sinon.expectation.fail(this.method + " already called " + times(this.maxCalls)); <br>  } <br><br> if (¬´expectedThis¬ª in this &amp;&amp; this.expectedThis !== thisValue) { <br> sinon.expectation.fail(this.method + " called with " + thisValue + " as thisValue, expected " + <br> this.expectedThis); <br>  } <br><br> if (!(¬´expectedArguments¬ª in this)) { <br>  return; <br>  } <br><br> if (!args) { <br> sinon.expectation.fail(this.method + " received no arguments, expected " + <br> sinon.format(this.expectedArguments)); <br>  } <br><br> if (args.length &lt; this.expectedArguments.length) { <br> sinon.expectation.fail(this.method + " received too few arguments (" + sinon.format(args) + <br> "), expected " + sinon.format(this.expectedArguments)); <br>  } <br><br> if (this.expectsExactArgCount &amp;&amp; <br> args.length !== this.expectedArguments.length) { <br> sinon.expectation.fail(this.method + " received too many arguments (" + sinon.format(args) + <br> "), expected " + sinon.format(this.expectedArguments)); <br>  } <br><br> for (var i = 0, l = this.expectedArguments.length; i &lt; l; i += 1) { <br><br> if (!verifyMatcher(this.expectedArguments[i], args[i])) { <br> sinon.expectation.fail(this.method + " received wrong arguments " + sinon.format(args) + <br> ", didn't match " + this.expectedArguments.toString()); <br>  } <br><br> if (!sinon.deepEqual(this.expectedArguments[i], args[i])) { <br> sinon.expectation.fail(this.method + " received wrong arguments " + sinon.format(args) + <br> ", expected " + sinon.format(this.expectedArguments)); <br>  } <br>  } <br>  }, <br><br> allowsCall: function allowsCall(thisValue, args) { <br> if (this.met() &amp;&amp; receivedMaxCalls(this)) { <br>  return false; <br>  } <br><br> if (¬´expectedThis¬ª in this &amp;&amp; this.expectedThis !== thisValue) { <br>  return false; <br>  } <br><br> if (!(¬´expectedArguments¬ª in this)) { <br>  return true; <br>  } <br><br> args = args || []; <br><br> if (args.length &lt; this.expectedArguments.length) { <br>  return false; <br>  } <br><br> if (this.expectsExactArgCount &amp;&amp; <br> args.length !== this.expectedArguments.length) { <br>  return false; <br>  } <br><br> for (var i = 0, l = this.expectedArguments.length; i &lt; l; i += 1) { <br> if (!verifyMatcher(this.expectedArguments[i], args[i])) { <br>  return false; <br>  } <br><br> if (!sinon.deepEqual(this.expectedArguments[i], args[i])) { <br>  return false; <br>  } <br>  } <br><br>  return true; <br>  }, <br><br> withArgs: function withArgs() { <br> this.expectedArguments = slice.call(arguments); <br> return this; <br>  }, <br><br> withExactArgs: function withExactArgs() { <br> this.withArgs.apply(this, arguments); <br> this.expectsExactArgCount = true; <br> return this; <br>  }, <br><br> on: function on(thisValue) { <br> this.expectedThis = thisValue; <br> return this; <br>  }, <br><br> toString: function () { <br> var args = (this.expectedArguments || []).slice(); <br><br> if (!this.expectsExactArgCount) { <br> push.call(args, "[...]"); <br>  } <br><br> var callStr = sinon.spyCall.toString.call({ <br> proxy: this.method || ¬´anonymous mock expectation¬ª, <br> args: args <br>  }); <br><br> var message = callStr.replace(", [...", "[, ...") + " " + <br> expectedCallCountInWords(this); <br><br> if (this.met()) { <br> return ¬´Expectation met: ¬ª + message; <br>  } <br><br> return ¬´Expected ¬ª + message + " (" + <br> callCountInWords(this.callCount) + ")"; <br>  }, <br><br> verify: function verify() { <br> if (!this.met()) { <br> sinon.expectation.fail(this.toString()); <br>  } else { <br> sinon.expectation.pass(this.toString()); <br>  } <br><br>  return true; <br>  }, <br><br> pass: function pass(message) { <br> sinon.assert.pass(message); <br>  }, <br><br> fail: function fail(message) { <br> var exception = new Error(message); <br> exception.name = ¬´ExpectationError¬ª; <br><br> throw exception; <br>  } <br>  }; <br><br> sinon.mock = mock; <br> return mock; <br>  } <br><br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var isAMD = typeof define === ¬´function¬ª &amp;&amp; typeof define.amd === ¬´object¬ª &amp;&amp; define.amd; <br><br> function loadDependencies(require, exports, module) { <br> var sinon = require("./util/core"); <br> require("./times_in_words"); <br> require("./call"); <br> require("./extend"); <br> require("./match"); <br> require("./spy"); <br> require("./stub"); <br> require("./format"); <br><br> module.exports = makeApi(sinon); <br>  } <br><br> if (isAMD) { <br> define(loadDependencies); <br>  return; <br>  } <br><br> if (isNode) { <br> loadDependencies(require, module.exports, module); <br>  return; <br>  } <br><br> if (sinonGlobal) { <br> makeApi(sinonGlobal); <br>  } <br> }( <br> typeof sinon === ¬´object¬ª &amp;&amp; sinon // eslint-disable-line no-undef <br> )); <br><br> /** <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> util/core.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> spy.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> stub.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> mock.js <br> */ <br> /** <br> * Collections of stubs, spies and mocks. <br>  * <br> * <a href="https://habrahabr.ru/users/author/" class="user_link">author</a> Christian Johansen (christian@cjohansen.no) <br> * @license BSD <br>  * <br> * Copyright ¬© 2010-2013 Christian Johansen <br> */ <br> (function (sinonGlobal) { <br><br> var push = [].push; <br> var hasOwnProperty = Object.prototype.hasOwnProperty; <br><br> function getFakes(fakeCollection) { <br> if (!fakeCollection.fakes) { <br> fakeCollection.fakes = []; <br>  } <br><br> return fakeCollection.fakes; <br>  } <br><br> function each(fakeCollection, method) { <br> var fakes = getFakes(fakeCollection); <br><br> for (var i = 0, l = fakes.length; i &lt; l; i += 1) { <br> if (typeof fakes[i][method] === ¬´function¬ª) { <br> fakes[i][method](); <br>  } <br>  } <br>  } <br><br> function compact(fakeCollection) { <br> var fakes = getFakes(fakeCollection); <br> var i = 0; <br> while (i &lt; fakes.length) { <br> fakes.splice(i, 1); <br>  } <br>  } <br><br> function makeApi(sinon) { <br> var collection = { <br> verify: function resolve() { <br> each(this, ¬´verify¬ª); <br>  }, <br><br> restore: function restore() { <br> each(this, ¬´restore¬ª); <br> compact(this); <br>  }, <br><br> reset: function restore() { <br> each(this, ¬´reset¬ª); <br>  }, <br><br> verifyAndRestore: function verifyAndRestore() { <br> var exception; <br><br>  try { <br> this.verify(); <br>  } catch (e) { <br> exception = e; <br>  } <br><br> this.restore(); <br><br> if (exception) { <br> throw exception; <br>  } <br>  }, <br><br> add: function add(fake) { <br> push.call(getFakes(this), fake); <br> return fake; <br>  }, <br><br> spy: function spy() { <br> return this.add(sinon.spy.apply(sinon, arguments)); <br>  }, <br><br> stub: function stub(object, property, value) { <br> if (property) { <br> var original = object[property]; <br><br> if (typeof original !== ¬´function¬ª) { <br> if (!hasOwnProperty.call(object, property)) { <br> throw new TypeError(¬´Cannot stub non-existent own property ¬ª + property); <br>  } <br><br> object[property] = value; <br><br> return this.add({ <br> restore: function () { <br> object[property] = original; <br>  } <br>  }); <br>  } <br>  } <br> if (!property &amp;&amp; !!object &amp;&amp; typeof object === ¬´object¬ª) { <br> var stubbedObj = sinon.stub.apply(sinon, arguments); <br><br> for (var prop in stubbedObj) { <br> if (typeof stubbedObj[prop] === ¬´function¬ª) { <br> this.add(stubbedObj[prop]); <br>  } <br>  } <br><br> return stubbedObj; <br>  } <br><br> return this.add(sinon.stub.apply(sinon, arguments)); <br>  }, <br><br> mock: function mock() { <br> return this.add(sinon.mock.apply(sinon, arguments)); <br>  }, <br><br> inject: function inject(obj) { <br> var col = this; <br><br> obj.spy = function () { <br> return col.spy.apply(col, arguments); <br>  }; <br><br> obj.stub = function () { <br> return col.stub.apply(col, arguments); <br>  }; <br><br> obj.mock = function () { <br> return col.mock.apply(col, arguments); <br>  }; <br><br> return obj; <br>  } <br>  }; <br><br> sinon.collection = collection; <br> return collection; <br>  } <br><br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var isAMD = typeof define === ¬´function¬ª &amp;&amp; typeof define.amd === ¬´object¬ª &amp;&amp; define.amd; <br><br> function loadDependencies(require, exports, module) { <br> var sinon = require("./util/core"); <br> require("./mock"); <br> require("./spy"); <br> require("./stub"); <br> module.exports = makeApi(sinon); <br>  } <br><br> if (isAMD) { <br> define(loadDependencies); <br>  return; <br>  } <br><br> if (isNode) { <br> loadDependencies(require, module.exports, module); <br>  return; <br>  } <br><br> if (sinonGlobal) { <br> makeApi(sinonGlobal); <br>  } <br> }( <br> typeof sinon === ¬´object¬ª &amp;&amp; sinon // eslint-disable-line no-undef <br> )); <br><br> /** <br> * Fake timer API <br> * setTimeout <br> * setInterval <br> * clearTimeout <br> * clearInterval <br> * tick <br> * reset <br> * Date <br>  * <br> * Inspired by jsUnitMockTimeOut from JsUnit <br>  * <br> * <a href="https://habrahabr.ru/users/author/" class="user_link">author</a> Christian Johansen (christian@cjohansen.no) <br> * @license BSD <br>  * <br> * Copyright ¬© 2010-2013 Christian Johansen <br> */ <br> (function () { <br><br> function makeApi(s, lol) { <br> /*global lolex */ <br> var llx = typeof lolex !== ¬´undefined¬ª? lolex: lol; <br><br> s.useFakeTimers = function () { <br> var now; <br> var methods = Array.prototype.slice.call(arguments); <br><br> if (typeof methods[0] === ¬´string¬ª) { <br> now = 0; <br>  } else { <br> now = methods.shift(); <br>  } <br><br> var clock = llx.install(now || 0, methods); <br> clock.restore = clock.uninstall; <br> return clock; <br>  }; <br><br> s.clock = { <br> create: function (now) { <br> return llx.createClock(now); <br>  } <br>  }; <br><br> s.timers = { <br> setTimeout: setTimeout, <br> clearTimeout: clearTimeout, <br> setImmediate: (typeof setImmediate !== ¬´undefined¬ª? setImmediate: undefined), <br> clearImmediate: (typeof clearImmediate !== ¬´undefined¬ª? clearImmediate: undefined), <br> setInterval: setInterval, <br> clearInterval: clearInterval, <br> Date: Date <br>  }; <br>  } <br><br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var isAMD = typeof define === ¬´function¬ª &amp;&amp; typeof define.amd === ¬´object¬ª &amp;&amp; define.amd; <br><br> function loadDependencies(require, epxorts, module, lolex) { <br> var core = require("./core"); <br> makeApi(core, lolex); <br> module.exports = core; <br>  } <br><br> if (isAMD) { <br> define(loadDependencies); <br> } else if (isNode) { <br> loadDependencies(require, module.exports, module, require(¬´lolex¬ª)); <br>  } else { <br> makeApi(sinon); // eslint-disable-line no-undef <br>  } <br> }()); <br><br> /** <br> * Minimal Event interface implementation <br>  * <br> * Original implementation by Sven Fuchs: <a href="https://gist.github.com/995028">gist.github.com/995028</a> <br> * Modifications and tests by Christian Johansen. <br>  * <br> * <a href="https://habrahabr.ru/users/author/" class="user_link">author</a> Sven Fuchs (svenfuchs@artweb-design.de) <br> * <a href="https://habrahabr.ru/users/author/" class="user_link">author</a> Christian Johansen (christian@cjohansen.no) <br> * @license BSD <br>  * <br> * Copyright ¬© 2011 Sven Fuchs, Christian Johansen <br> */ <br> if (typeof sinon === ¬´undefined¬ª) { <br> this.sinon = {}; <br>  } <br><br> (function () { <br><br> var push = [].push; <br><br> function makeApi(sinon) { <br> sinon.Event = function Event(type, bubbles, cancelable, target) { <br> this.initEvent(type, bubbles, cancelable, target); <br>  }; <br><br> sinon.Event.prototype = { <br> initEvent: function (type, bubbles, cancelable, target) { <br> this.type = type; <br> this.bubbles = bubbles; <br> this.cancelable = cancelable; <br> this.target = target; <br>  }, <br><br> stopPropagation: function () {}, <br><br> preventDefault: function () { <br> this.defaultPrevented = true; <br>  } <br>  }; <br><br> sinon.ProgressEvent = function ProgressEvent(type, progressEventRaw, target) { <br> this.initEvent(type, false, false, target); <br> this.loaded = progressEventRaw.loaded || null; <br> this.total = progressEventRaw.total || null; <br> this.lengthComputable = !!progressEventRaw.total; <br>  }; <br><br> sinon.ProgressEvent.prototype = new sinon.Event(); <br><br> sinon.ProgressEvent.prototype.constructor = sinon.ProgressEvent; <br><br> sinon.CustomEvent = function CustomEvent(type, customData, target) { <br> this.initEvent(type, false, false, target); <br> this.detail = customData.detail || null; <br>  }; <br><br> sinon.CustomEvent.prototype = new sinon.Event(); <br><br> sinon.CustomEvent.prototype.constructor = sinon.CustomEvent; <br><br> sinon.EventTarget = { <br> addEventListener: function addEventListener(event, listener) { <br> this.eventListeners = this.eventListeners || {}; <br> this.eventListeners[event] = this.eventListeners[event] || []; <br> push.call(this.eventListeners[event], listener); <br>  }, <br><br> removeEventListener: function removeEventListener(event, listener) { <br> var listeners = this.eventListeners &amp;&amp; this.eventListeners[event] || []; <br><br> for (var i = 0, l = listeners.length; i &lt; l; ++i) { <br> if (listeners[i] === listener) { <br> return listeners.splice(i, 1); <br>  } <br>  } <br>  }, <br><br> dispatchEvent: function dispatchEvent(event) { <br> var type = event.type; <br> var listeners = this.eventListeners &amp;&amp; this.eventListeners[type] || []; <br><br> for (var i = 0; i &lt; listeners.length; i++) { <br> if (typeof listeners[i] === ¬´function¬ª) { <br> listeners[i].call(this, event); <br>  } else { <br> listeners[i].handleEvent(event); <br>  } <br>  } <br><br> return !!event.defaultPrevented; <br>  } <br>  }; <br>  } <br><br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var isAMD = typeof define === ¬´function¬ª &amp;&amp; typeof define.amd === ¬´object¬ª &amp;&amp; define.amd; <br><br> function loadDependencies(require) { <br> var sinon = require("./core"); <br> makeApi(sinon); <br>  } <br><br> if (isAMD) { <br> define(loadDependencies); <br> } else if (isNode) { <br> loadDependencies(require); <br>  } else { <br> makeApi(sinon); // eslint-disable-line no-undef <br>  } <br> }()); <br><br> /** <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> util/core.js <br> */ <br> /** <br> * Logs errors <br>  * <br> * <a href="https://habrahabr.ru/users/author/" class="user_link">author</a> Christian Johansen (christian@cjohansen.no) <br> * @license BSD <br>  * <br> * Copyright ¬© 2010-2014 Christian Johansen <br> */ <br> (function (sinonGlobal) { <br><br> // cache a reference to setTimeout, so that our reference won't be stubbed out <br> // when using fake timers and errors will still get logged <br> // <a href="https://github.com/cjohansen/Sinon.JS/issues/381">github.com/cjohansen/Sinon.JS/issues/381</a> <br> var realSetTimeout = setTimeout; <br><br> function makeApi(sinon) { <br><br> function log() {} <br><br> function logError(label, err) { <br> var msg = label + " threw exception: "; <br><br> function throwLoggedError() { <br> err.message = msg + err.message; <br> throw err; <br>  } <br><br> sinon.log(msg + "[" + err.name + "] " + err.message); <br><br> if (err.stack) { <br> sinon.log(err.stack); <br>  } <br><br> if (logError.useImmediateExceptions) { <br> throwLoggedError(); <br>  } else { <br> logError.setTimeout(throwLoggedError, 0); <br>  } <br>  } <br><br> // When set to true, any errors logged will be thrown immediately; <br> // If set to false, the errors will be thrown in separate execution frame. <br> logError.useImmediateExceptions = false; <br><br> // wrap realSetTimeout with something we can stub in tests <br> logError.setTimeout = function (func, timeout) { <br> realSetTimeout(func, timeout); <br>  }; <br><br> var exports = {}; <br> exports.log = sinon.log = log; <br> exports.logError = sinon.logError = logError; <br><br> return exports; <br>  } <br><br> function loadDependencies(require, exports, module) { <br> var sinon = require("./util/core"); <br> module.exports = makeApi(sinon); <br>  } <br><br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var isAMD = typeof define === ¬´function¬ª &amp;&amp; typeof define.amd === ¬´object¬ª &amp;&amp; define.amd; <br><br> if (isAMD) { <br> define(loadDependencies); <br>  return; <br>  } <br><br> if (isNode) { <br> loadDependencies(require, module.exports, module); <br>  return; <br>  } <br><br> if (sinonGlobal) { <br> makeApi(sinonGlobal); <br>  } <br> }( <br> typeof sinon === ¬´object¬ª &amp;&amp; sinon // eslint-disable-line no-undef <br> )); <br><br> /** <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> core.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> ../extend.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> event.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> ../log_error.js <br> */ <br> /** <br> * Fake XDomainRequest object <br> */ <br> if (typeof sinon === ¬´undefined¬ª) { <br> this.sinon = {}; <br>  } <br><br> // wrapper for global <br> (function (global) { <br><br> var xdr = { XDomainRequest: global.XDomainRequest }; <br> xdr.GlobalXDomainRequest = global.XDomainRequest; <br> xdr.supportsXDR = typeof xdr.GlobalXDomainRequest !== ¬´undefined¬ª; <br> xdr.workingXDR = xdr.supportsXDR? xdr.GlobalXDomainRequest: false; <br><br> function makeApi(sinon) { <br> sinon.xdr = xdr; <br><br> function FakeXDomainRequest() { <br> this.readyState = FakeXDomainRequest.UNSENT; <br> this.requestBody = null; <br> this.requestHeaders = {}; <br> this.status = 0; <br> this.timeout = null; <br><br> if (typeof FakeXDomainRequest.onCreate === ¬´function¬ª) { <br> FakeXDomainRequest.onCreate(this); <br>  } <br>  } <br><br> function verifyState(x) { <br> if (x.readyState !== FakeXDomainRequest.OPENED) { <br> throw new Error(¬´INVALID_STATE_ERR¬ª); <br>  } <br><br> if (x.sendFlag) { <br> throw new Error(¬´INVALID_STATE_ERR¬ª); <br>  } <br>  } <br><br> function verifyRequestSent(x) { <br> if (x.readyState === FakeXDomainRequest.UNSENT) { <br> throw new Error(¬´Request not sent¬ª); <br>  } <br> if (x.readyState === FakeXDomainRequest.DONE) { <br> throw new Error(¬´Request done¬ª); <br>  } <br>  } <br><br> function verifyResponseBodyType(body) { <br> if (typeof body !== ¬´string¬ª) { <br> var error = new Error(¬´Attempted to respond to fake XDomainRequest with ¬ª + <br> body + ", which is not a string."); <br> error.name = ¬´InvalidBodyException¬ª; <br> throw error; <br>  } <br>  } <br><br> sinon.extend(FakeXDomainRequest.prototype, sinon.EventTarget, { <br> open: function open(method, url) { <br> this.method = method; <br> this.url = url; <br><br> this.responseText = null; <br> this.sendFlag = false; <br><br> this.readyStateChange(FakeXDomainRequest.OPENED); <br>  }, <br><br> readyStateChange: function readyStateChange(state) { <br> this.readyState = state; <br> var eventName = ""; <br> switch (this.readyState) { <br> case FakeXDomainRequest.UNSENT: <br>  break; <br> case FakeXDomainRequest.OPENED: <br>  break; <br> case FakeXDomainRequest.LOADING: <br> if (this.sendFlag) { <br> //raise the progress event <br> eventName = ¬´onprogress¬ª; <br>  } <br>  break; <br> case FakeXDomainRequest.DONE: <br> if (this.isTimeout) { <br> eventName = ¬´ontimeout¬ª; <br> } else if (this.errorFlag || (this.status &lt; 200 || this.status &gt; 299)) { <br> eventName = ¬´onerror¬ª; <br>  } else { <br> eventName = ¬´onload¬ª; <br>  } <br>  break; <br>  } <br><br> // raising event (if defined) <br> if (eventName) { <br> if (typeof this[eventName] === ¬´function¬ª) { <br>  try { <br> this[eventName](); <br>  } catch (e) { <br> sinon.logError(¬´Fake XHR ¬ª + eventName + " handler", e); <br>  } <br>  } <br>  } <br>  }, <br><br> send: function send(data) { <br> verifyState(this); <br><br> if (!/^(get|head)$/i.test(this.method)) { <br> this.requestBody = data; <br>  } <br> this.requestHeaders[¬´Content-Type¬ª] = ¬´text/plain;charset=utf-8¬ª; <br><br> this.errorFlag = false; <br> this.sendFlag = true; <br> this.readyStateChange(FakeXDomainRequest.OPENED); <br><br> if (typeof this.onSend === ¬´function¬ª) { <br> this.onSend(this); <br>  } <br>  }, <br><br> abort: function abort() { <br> this.aborted = true; <br> this.responseText = null; <br> this.errorFlag = true; <br><br> if (this.readyState &gt; sinon.FakeXDomainRequest.UNSENT &amp;&amp; this.sendFlag) { <br> this.readyStateChange(sinon.FakeXDomainRequest.DONE); <br> this.sendFlag = false; <br>  } <br>  }, <br><br> setResponseBody: function setResponseBody(body) { <br> verifyRequestSent(this); <br> verifyResponseBodyType(body); <br><br> var chunkSize = this.chunkSize || 10; <br> var index = 0; <br> this.responseText = ""; <br><br> do { <br> this.readyStateChange(FakeXDomainRequest.LOADING); <br> this.responseText += body.substring(index, index + chunkSize); <br> index += chunkSize; <br> } while (index &lt; body.length); <br><br> this.readyStateChange(FakeXDomainRequest.DONE); <br>  }, <br><br> respond: function respond(status, contentType, body) { <br> // content-type ignored, since XDomainRequest does not carry this <br> // we keep the same syntax for respond(...) as for FakeXMLHttpRequest to ease <br> // test integration across browsers <br> this.status = typeof status === ¬´number¬ª? status: 200; <br> this.setResponseBody(body || ""); <br>  }, <br><br> simulatetimeout: function simulatetimeout() { <br> this.status = 0; <br> this.isTimeout = true; <br> // Access to this should actually throw an error <br> this.responseText = undefined; <br> this.readyStateChange(FakeXDomainRequest.DONE); <br>  } <br>  }); <br><br> sinon.extend(FakeXDomainRequest, { <br> UNSENT: 0, <br> OPENED: 1, <br> LOADING: 3, <br> DONE: 4 <br>  }); <br><br> sinon.useFakeXDomainRequest = function useFakeXDomainRequest() { <br> sinon.FakeXDomainRequest.restore = function restore(keepOnCreate) { <br> if (xdr.supportsXDR) { <br> global.XDomainRequest = xdr.GlobalXDomainRequest; <br>  } <br><br> delete sinon.FakeXDomainRequest.restore; <br><br> if (keepOnCreate !== true) { <br> delete sinon.FakeXDomainRequest.onCreate; <br>  } <br>  }; <br> if (xdr.supportsXDR) { <br> global.XDomainRequest = sinon.FakeXDomainRequest; <br>  } <br> return sinon.FakeXDomainRequest; <br>  }; <br><br> sinon.FakeXDomainRequest = FakeXDomainRequest; <br>  } <br><br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var isAMD = typeof define === ¬´function¬ª &amp;&amp; typeof define.amd === ¬´object¬ª &amp;&amp; define.amd; <br><br> function loadDependencies(require, exports, module) { <br> var sinon = require("./core"); <br> require("../extend"); <br> require("./event"); <br> require("../log_error"); <br> makeApi(sinon); <br> module.exports = sinon; <br>  } <br><br> if (isAMD) { <br> define(loadDependencies); <br> } else if (isNode) { <br> loadDependencies(require, module.exports, module); <br>  } else { <br> makeApi(sinon); // eslint-disable-line no-undef <br>  } <br> })(typeof global !== ¬´undefined¬ª? global: self); <br><br> /** <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> core.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> ../extend.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> event.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> ../log_error.js <br> */ <br> /** <br> * Fake XMLHttpRequest object <br>  * <br> * <a href="https://habrahabr.ru/users/author/" class="user_link">author</a> Christian Johansen (christian@cjohansen.no) <br> * @license BSD <br>  * <br> * Copyright ¬© 2010-2013 Christian Johansen <br> */ <br> (function (sinonGlobal, global) { <br><br> function getWorkingXHR(globalScope) { <br> var supportsXHR = typeof globalScope.XMLHttpRequest !== ¬´undefined¬ª; <br> if (supportsXHR) { <br> return globalScope.XMLHttpRequest; <br>  } <br><br> var supportsActiveX = typeof globalScope.ActiveXObject !== ¬´undefined¬ª; <br> if (supportsActiveX) { <br> return function () { <br> return new globalScope.ActiveXObject(¬´MSXML2.XMLHTTP.3.0¬ª); <br>  }; <br>  } <br><br>  return false; <br>  } <br><br> var supportsProgress = typeof ProgressEvent !== ¬´undefined¬ª; <br> var supportsCustomEvent = typeof CustomEvent !== ¬´undefined¬ª; <br> var supportsFormData = typeof FormData !== ¬´undefined¬ª; <br> var supportsArrayBuffer = typeof ArrayBuffer !== ¬´undefined¬ª; <br> var supportsBlob = typeof Blob === ¬´function¬ª; <br> var sinonXhr = { XMLHttpRequest: global.XMLHttpRequest }; <br> sinonXhr.GlobalXMLHttpRequest = global.XMLHttpRequest; <br> sinonXhr.GlobalActiveXObject = global.ActiveXObject; <br> sinonXhr.supportsActiveX = typeof sinonXhr.GlobalActiveXObject !== ¬´undefined¬ª; <br> sinonXhr.supportsXHR = typeof sinonXhr.GlobalXMLHttpRequest !== ¬´undefined¬ª; <br> sinonXhr.workingXHR = getWorkingXHR(global); <br> sinonXhr.supportsCORS = sinonXhr.supportsXHR &amp;&amp; ¬´withCredentials¬ª in (new sinonXhr.GlobalXMLHttpRequest()); <br><br> var unsafeHeaders = { <br> ¬´Accept-Charset¬ª: true, <br> ¬´Accept-Encoding¬ª: true, <br> Connection: true, <br> ¬´Content-Length¬ª: true, <br> Cookie: true, <br> Cookie2: true, <br> ¬´Content-Transfer-Encoding¬ª: true, <br> Date: true, <br> Expect: true, <br> Host: true, <br> ¬´Keep-Alive¬ª: true, <br> Referer: true, <br> TE: true, <br> Trailer: true, <br> ¬´Transfer-Encoding¬ª: true, <br> Upgrade: true, <br> ¬´User-Agent¬ª: true, <br> Via: true <br>  }; <br><br> // An upload object is created for each <br> // FakeXMLHttpRequest and allows upload <br> // events to be simulated using uploadProgress <br> // and uploadError. <br> function UploadProgress() { <br> this.eventListeners = { <br> progress: [], <br> load: [], <br> abort: [], <br> error: [] <br>  }; <br>  } <br><br> UploadProgress.prototype.addEventListener = function addEventListener(event, listener) { <br> this.eventListeners[event].push(listener); <br>  }; <br><br> UploadProgress.prototype.removeEventListener = function removeEventListener(event, listener) { <br> var listeners = this.eventListeners[event] || []; <br><br> for (var i = 0, l = listeners.length; i &lt; l; ++i) { <br> if (listeners[i] === listener) { <br> return listeners.splice(i, 1); <br>  } <br>  } <br>  }; <br><br> UploadProgress.prototype.dispatchEvent = function dispatchEvent(event) { <br> var listeners = this.eventListeners[event.type] || []; <br><br> for (var i = 0, listener; (listener = listeners[i]) != null; i++) { <br> listener(event); <br>  } <br>  }; <br><br> // Note that for FakeXMLHttpRequest to work pre ES5 <br> // we lose some of the alignment with the spec. <br> // To ensure as close a match as possible, <br> // set responseType before calling open, send or respond; <br> function FakeXMLHttpRequest() { <br> this.readyState = FakeXMLHttpRequest.UNSENT; <br> this.requestHeaders = {}; <br> this.requestBody = null; <br> this.status = 0; <br> this.statusText = ""; <br> this.upload = new UploadProgress(); <br> this.responseType = ""; <br> this.response = ""; <br> if (sinonXhr.supportsCORS) { <br> this.withCredentials = false; <br>  } <br><br> var xhr = this; <br> var events = [¬´loadstart¬ª, ¬´load¬ª, ¬´abort¬ª, ¬´loadend¬ª]; <br><br> function addEventListener(eventName) { <br> xhr.addEventListener(eventName, function (event) { <br> var listener = xhr[¬´on¬ª + eventName]; <br><br> if (listener &amp;&amp; typeof listener === ¬´function¬ª) { <br> listener.call(this, event); <br>  } <br>  }); <br>  } <br><br> for (var i = events.length ‚Äî 1; i &gt;= 0; i--) { <br> addEventListener(events[i]); <br>  } <br><br> if (typeof FakeXMLHttpRequest.onCreate === ¬´function¬ª) { <br> FakeXMLHttpRequest.onCreate(this); <br>  } <br>  } <br><br> function verifyState(xhr) { <br> if (xhr.readyState !== FakeXMLHttpRequest.OPENED) { <br> throw new Error(¬´INVALID_STATE_ERR¬ª); <br>  } <br><br> if (xhr.sendFlag) { <br> throw new Error(¬´INVALID_STATE_ERR¬ª); <br>  } <br>  } <br><br> function getHeader(headers, header) { <br> header = header.toLowerCase(); <br><br> for (var h in headers) { <br> if (h.toLowerCase() === header) { <br> return h; <br>  } <br>  } <br><br> return null; <br>  } <br><br> // filtering to enable a white-list version of Sinon FakeXhr, <br> // where whitelisted requests are passed through to real XHR <br> function each(collection, callback) { <br> if (!collection) { <br>  return; <br>  } <br><br> for (var i = 0, l = collection.length; i &lt; l; i += 1) { <br> callback(collection[i]); <br>  } <br>  } <br> function some(collection, callback) { <br> for (var index = 0; index &lt; collection.length; index++) { <br> if (callback(collection[index]) === true) { <br>  return true; <br>  } <br>  } <br>  return false; <br>  } <br> // largest arity in XHR is 5 ‚Äî XHR#open <br> var apply = function (obj, method, args) { <br> switch (args.length) { <br> case 0: return obj[method](); <br> case 1: return obj[method](args[0]); <br> case 2: return obj[method](args[0], args[1]); <br> case 3: return obj[method](args[0], args[1], args[2]); <br> case 4: return obj[method](args[0], args[1], args[2], args[3]); <br> case 5: return obj[method](args[0], args[1], args[2], args[3], args[4]); <br>  } <br>  }; <br><br> FakeXMLHttpRequest.filters = []; <br> FakeXMLHttpRequest.addFilter = function addFilter(fn) { <br> this.filters.push(fn); <br>  }; <br> var IE6Re = /MSIE 6/; <br> FakeXMLHttpRequest.defake = function defake(fakeXhr, xhrArgs) { <br> var xhr = new sinonXhr.workingXHR(); // eslint-disable-line new-cap <br><br> each([ <br> ¬´open¬ª, <br> ¬´setRequestHeader¬ª, <br> ¬´send¬ª, <br> ¬´abort¬ª, <br> ¬´getResponseHeader¬ª, <br> ¬´getAllResponseHeaders¬ª, <br> ¬´addEventListener¬ª, <br> ¬´overrideMimeType¬ª, <br> ¬´removeEventListener¬ª <br> ], function (method) { <br> fakeXhr[method] = function () { <br> return apply(xhr, method, arguments); <br>  }; <br>  }); <br><br> var copyAttrs = function (args) { <br> each(args, function (attr) { <br>  try { <br> fakeXhr[attr] = xhr[attr]; <br>  } catch (e) { <br> if (!IE6Re.test(navigator.userAgent)) { <br> throw e; <br>  } <br>  } <br>  }); <br>  }; <br><br> var stateChange = function stateChange() { <br> fakeXhr.readyState = xhr.readyState; <br> if (xhr.readyState &gt;= FakeXMLHttpRequest.HEADERS_RECEIVED) { <br> copyAttrs([¬´status¬ª, ¬´statusText¬ª]); <br>  } <br> if (xhr.readyState &gt;= FakeXMLHttpRequest.LOADING) { <br> copyAttrs([¬´responseText¬ª, ¬´response¬ª]); <br>  } <br> if (xhr.readyState === FakeXMLHttpRequest.DONE) { <br> copyAttrs([¬´responseXML¬ª]); <br>  } <br> if (fakeXhr.onreadystatechange) { <br> fakeXhr.onreadystatechange.call(fakeXhr, { target: fakeXhr }); <br>  } <br>  }; <br><br> if (xhr.addEventListener) { <br> for (var event in fakeXhr.eventListeners) { <br> if (fakeXhr.eventListeners.hasOwnProperty(event)) { <br><br> /*eslint-disable no-loop-func*/ <br> each(fakeXhr.eventListeners[event], function (handler) { <br> xhr.addEventListener(event, handler); <br>  }); <br> /*eslint-enable no-loop-func*/ <br>  } <br>  } <br> xhr.addEventListener(¬´readystatechange¬ª, stateChange); <br>  } else { <br> xhr.onreadystatechange = stateChange; <br>  } <br> apply(xhr, ¬´open¬ª, xhrArgs); <br>  }; <br> FakeXMLHttpRequest.useFilters = false; <br><br> function verifyRequestOpened(xhr) { <br> if (xhr.readyState !== FakeXMLHttpRequest.OPENED) { <br> throw new Error(¬´INVALID_STATE_ERR ‚Äî ¬ª + xhr.readyState); <br>  } <br>  } <br><br> function verifyRequestSent(xhr) { <br> if (xhr.readyState === FakeXMLHttpRequest.DONE) { <br> throw new Error(¬´Request done¬ª); <br>  } <br>  } <br><br> function verifyHeadersReceived(xhr) { <br> if (xhr.async &amp;&amp; xhr.readyState !== FakeXMLHttpRequest.HEADERS_RECEIVED) { <br> throw new Error(¬´No headers received¬ª); <br>  } <br>  } <br><br> function verifyResponseBodyType(body) { <br> if (typeof body !== ¬´string¬ª) { <br> var error = new Error(¬´Attempted to respond to fake XMLHttpRequest with ¬ª + <br> body + ", which is not a string."); <br> error.name = ¬´InvalidBodyException¬ª; <br> throw error; <br>  } <br>  } <br><br> function convertToArrayBuffer(body) { <br> var buffer = new ArrayBuffer(body.length); <br> var view = new Uint8Array(buffer); <br> for (var i = 0; i &lt; body.length; i++) { <br> var charCode = body.charCodeAt(i); <br> if (charCode &gt;= 256) { <br> throw new TypeError(¬´arraybuffer or blob responseTypes require binary string, ¬ª + <br> ¬´invalid character ¬ª + body[i] + " found."); <br>  } <br> view[i] = charCode; <br>  } <br> return buffer; <br>  } <br><br> function isXmlContentType(contentType) { <br> return !contentType || /(text\/xml)|(application\/xml)|(\+xml)/.test(contentType); <br>  } <br><br> function convertResponseBody(responseType, contentType, body) { <br> if (responseType === "" || responseType === ¬´text¬ª) { <br> return body; <br> } else if (supportsArrayBuffer &amp;&amp; responseType === ¬´arraybuffer¬ª) { <br> return convertToArrayBuffer(body); <br> } else if (responseType === ¬´json¬ª) { <br>  try { <br> return JSON.parse(body); <br>  } catch (e) { <br> // Return parsing failure as null <br> return null; <br>  } <br> } else if (supportsBlob &amp;&amp; responseType === ¬´blob¬ª) { <br> var blobOptions = {}; <br> if (contentType) { <br> blobOptions.type = contentType; <br>  } <br> return new Blob([convertToArrayBuffer(body)], blobOptions); <br> } else if (responseType === ¬´document¬ª) { <br> if (isXmlContentType(contentType)) { <br> return FakeXMLHttpRequest.parseXML(body); <br>  } <br> return null; <br>  } <br> throw new Error(¬´Invalid responseType ¬ª + responseType); <br>  } <br><br> function clearResponse(xhr) { <br> if (xhr.responseType === "" || xhr.responseType === ¬´text¬ª) { <br> xhr.response = xhr.responseText = ""; <br>  } else { <br> xhr.response = xhr.responseText = null; <br>  } <br> xhr.responseXML = null; <br>  } <br><br> FakeXMLHttpRequest.parseXML = function parseXML(text) { <br> // Treat empty string as parsing failure <br> if (text !== "") { <br>  try { <br> if (typeof DOMParser !== ¬´undefined¬ª) { <br> var parser = new DOMParser(); <br> return parser.parseFromString(text, ¬´text/xml¬ª); <br>  } <br> var xmlDoc = new window.ActiveXObject(¬´Microsoft.XMLDOM¬ª); <br> xmlDoc.async = ¬´false¬ª; <br> xmlDoc.loadXML(text); <br> return xmlDoc; <br>  } catch (e) { <br> // Unable to parse XML ‚Äî no biggie <br>  } <br>  } <br><br> return null; <br>  }; <br><br> FakeXMLHttpRequest.statusCodes = { <br> 100: ¬´Continue¬ª, <br> 101: ¬´Switching Protocols¬ª, <br> 200: ¬´OK¬ª, <br> 201: ¬´Created¬ª, <br> 202: ¬´Accepted¬ª, <br> 203: ¬´Non-Authoritative Information¬ª, <br> 204: ¬´No Content¬ª, <br> 205: ¬´Reset Content¬ª, <br> 206: ¬´Partial Content¬ª, <br> 207: ¬´Multi-Status¬ª, <br> 300: ¬´Multiple Choice¬ª, <br> 301: ¬´Moved Permanently¬ª, <br> 302: ¬´Found¬ª, <br> 303: ¬´See Other¬ª, <br> 304: ¬´Not Modified¬ª, <br> 305: ¬´Use Proxy¬ª, <br> 307: ¬´Temporary Redirect¬ª, <br> 400: ¬´Bad Request¬ª, <br> 401: ¬´Unauthorized¬ª, <br> 402: ¬´Payment Required¬ª, <br> 403: ¬´Forbidden¬ª, <br> 404: ¬´Not Found¬ª, <br> 405: ¬´Method Not Allowed¬ª, <br> 406: ¬´Not Acceptable¬ª, <br> 407: ¬´Proxy Authentication Required¬ª, <br> 408: ¬´Request Timeout¬ª, <br> 409: ¬´Conflict¬ª, <br> 410: ¬´Gone¬ª, <br> 411: ¬´Length Required¬ª, <br> 412: ¬´Precondition Failed¬ª, <br> 413: ¬´Request Entity Too Large¬ª, <br> 414: ¬´Request-URI Too Long¬ª, <br> 415: ¬´Unsupported Media Type¬ª, <br> 416: ¬´Requested Range Not Satisfiable¬ª, <br> 417: ¬´Expectation Failed¬ª, <br> 422: ¬´Unprocessable Entity¬ª, <br> 500: ¬´Internal Server Error¬ª, <br> 501: ¬´Not Implemented¬ª, <br> 502: ¬´Bad Gateway¬ª, <br> 503: ¬´Service Unavailable¬ª, <br> 504: ¬´Gateway Timeout¬ª, <br> 505: ¬´HTTP Version Not Supported¬ª <br>  }; <br><br> function makeApi(sinon) { <br> sinon.xhr = sinonXhr; <br><br> sinon.extend(FakeXMLHttpRequest.prototype, sinon.EventTarget, { <br> async: true, <br><br> open: function open(method, url, async, username, password) { <br> this.method = method; <br> this.url = url; <br> this.async = typeof async === ¬´boolean¬ª? async: true; <br> this.username = username; <br> this.password = password; <br> clearResponse(this); <br> this.requestHeaders = {}; <br> this.sendFlag = false; <br><br> if (FakeXMLHttpRequest.useFilters === true) { <br> var xhrArgs = arguments; <br> var defake = some(FakeXMLHttpRequest.filters, function (filter) { <br> return filter.apply(this, xhrArgs); <br>  }); <br> if (defake) { <br> return FakeXMLHttpRequest.defake(this, arguments); <br>  } <br>  } <br> this.readyStateChange(FakeXMLHttpRequest.OPENED); <br>  }, <br><br> readyStateChange: function readyStateChange(state) { <br> this.readyState = state; <br><br> var readyStateChangeEvent = new sinon.Event(¬´readystatechange¬ª, false, false, this); <br><br> if (typeof this.onreadystatechange === ¬´function¬ª) { <br>  try { <br> this.onreadystatechange(readyStateChangeEvent); <br>  } catch (e) { <br> sinon.logError(¬´Fake XHR onreadystatechange handler¬ª, e); <br>  } <br>  } <br><br> switch (this.readyState) { <br> case FakeXMLHttpRequest.DONE: <br> if (supportsProgress) { <br> this.upload.dispatchEvent(new sinon.ProgressEvent(¬´progress¬ª, {loaded: 100, total: 100})); <br> this.dispatchEvent(new sinon.ProgressEvent(¬´progress¬ª, {loaded: 100, total: 100})); <br>  } <br> this.upload.dispatchEvent(new sinon.Event(¬´load¬ª, false, false, this)); <br> this.dispatchEvent(new sinon.Event(¬´load¬ª, false, false, this)); <br> this.dispatchEvent(new sinon.Event(¬´loadend¬ª, false, false, this)); <br>  break; <br>  } <br><br> this.dispatchEvent(readyStateChangeEvent); <br>  }, <br><br> setRequestHeader: function setRequestHeader(header, value) { <br> verifyState(this); <br><br> if (unsafeHeaders[header] || /^(Sec-|Proxy-)/.test(header)) { <br> throw new Error(¬´Refused to set unsafe header \¬ª" + header + "\""); <br>  } <br><br> if (this.requestHeaders[header]) { <br> this.requestHeaders[header] += "," + value; <br>  } else { <br> this.requestHeaders[header] = value; <br>  } <br>  }, <br><br> // Helps testing <br> setResponseHeaders: function setResponseHeaders(headers) { <br> verifyRequestOpened(this); <br> this.responseHeaders = {}; <br><br> for (var header in headers) { <br> if (headers.hasOwnProperty(header)) { <br> this.responseHeaders[header] = headers[header]; <br>  } <br>  } <br><br> if (this.async) { <br> this.readyStateChange(FakeXMLHttpRequest.HEADERS_RECEIVED); <br>  } else { <br> this.readyState = FakeXMLHttpRequest.HEADERS_RECEIVED; <br>  } <br>  }, <br><br> // Currently treats ALL data as a DOMString (ie no Document) <br> send: function send(data) { <br> verifyState(this); <br><br> if (!/^(get|head)$/i.test(this.method)) { <br> var contentType = getHeader(this.requestHeaders, ¬´Content-Type¬ª); <br> if (this.requestHeaders[contentType]) { <br> var value = this.requestHeaders[contentType].split(";"); <br> this.requestHeaders[contentType] = value[0] + ";charset=utf-8"; <br> } else if (supportsFormData &amp;&amp; !(data instanceof FormData)) { <br> this.requestHeaders[¬´Content-Type¬ª] = ¬´text/plain;charset=utf-8¬ª; <br>  } <br><br> this.requestBody = data; <br>  } <br><br> this.errorFlag = false; <br> this.sendFlag = this.async; <br> clearResponse(this); <br> this.readyStateChange(FakeXMLHttpRequest.OPENED); <br><br> if (typeof this.onSend === ¬´function¬ª) { <br> this.onSend(this); <br>  } <br><br> this.dispatchEvent(new sinon.Event(¬´loadstart¬ª, false, false, this)); <br>  }, <br><br> abort: function abort() { <br> this.aborted = true; <br> clearResponse(this); <br> this.errorFlag = true; <br> this.requestHeaders = {}; <br> this.responseHeaders = {}; <br><br> if (this.readyState &gt; FakeXMLHttpRequest.UNSENT &amp;&amp; this.sendFlag) { <br> this.readyStateChange(FakeXMLHttpRequest.DONE); <br> this.sendFlag = false; <br>  } <br><br> this.readyState = FakeXMLHttpRequest.UNSENT; <br><br> this.dispatchEvent(new sinon.Event(¬´abort¬ª, false, false, this)); <br><br> this.upload.dispatchEvent(new sinon.Event(¬´abort¬ª, false, false, this)); <br><br> if (typeof this.onerror === ¬´function¬ª) { <br> this.onerror(); <br>  } <br>  }, <br><br> getResponseHeader: function getResponseHeader(header) { <br> if (this.readyState &lt; FakeXMLHttpRequest.HEADERS_RECEIVED) { <br> return null; <br>  } <br><br> if (/^Set-Cookie2?$/i.test(header)) { <br> return null; <br>  } <br><br> header = getHeader(this.responseHeaders, header); <br><br> return this.responseHeaders[header] || null; <br>  }, <br><br> getAllResponseHeaders: function getAllResponseHeaders() { <br> if (this.readyState &lt; FakeXMLHttpRequest.HEADERS_RECEIVED) { <br> return ""; <br>  } <br><br> var headers = ""; <br><br> for (var header in this.responseHeaders) { <br> if (this.responseHeaders.hasOwnProperty(header) &amp;&amp; <br> !/^Set-Cookie2?$/i.test(header)) { <br> headers += header + ": " + this.responseHeaders[header] + "\r\n"; <br>  } <br>  } <br><br> return headers; <br>  }, <br><br> setResponseBody: function setResponseBody(body) { <br> verifyRequestSent(this); <br> verifyHeadersReceived(this); <br> verifyResponseBodyType(body); <br> var contentType = this.getResponseHeader(¬´Content-Type¬ª); <br><br> var isTextResponse = this.responseType === "" || this.responseType === ¬´text¬ª; <br> clearResponse(this); <br> if (this.async) { <br> var chunkSize = this.chunkSize || 10; <br> var index = 0; <br><br> do { <br> this.readyStateChange(FakeXMLHttpRequest.LOADING); <br><br> if (isTextResponse) { <br> this.responseText = this.response += body.substring(index, index + chunkSize); <br>  } <br> index += chunkSize; <br> } while (index &lt; body.length); <br>  } <br><br> this.response = convertResponseBody(this.responseType, contentType, body); <br> if (isTextResponse) { <br> this.responseText = this.response; <br>  } <br><br> if (this.responseType === ¬´document¬ª) { <br> this.responseXML = this.response; <br> } else if (this.responseType === "" &amp;&amp; isXmlContentType(contentType)) { <br> this.responseXML = FakeXMLHttpRequest.parseXML(this.responseText); <br>  } <br> this.readyStateChange(FakeXMLHttpRequest.DONE); <br>  }, <br><br> respond: function respond(status, headers, body) { <br> this.status = typeof status === ¬´number¬ª? status: 200; <br> this.statusText = FakeXMLHttpRequest.statusCodes[this.status]; <br> this.setResponseHeaders(headers || {}); <br> this.setResponseBody(body || ""); <br>  }, <br><br> uploadProgress: function uploadProgress(progressEventRaw) { <br> if (supportsProgress) { <br> this.upload.dispatchEvent(new sinon.ProgressEvent(¬´progress¬ª, progressEventRaw)); <br>  } <br>  }, <br><br> downloadProgress: function downloadProgress(progressEventRaw) { <br> if (supportsProgress) { <br> this.dispatchEvent(new sinon.ProgressEvent(¬´progress¬ª, progressEventRaw)); <br>  } <br>  }, <br><br> uploadError: function uploadError(error) { <br> if (supportsCustomEvent) { <br> this.upload.dispatchEvent(new sinon.CustomEvent(¬´error¬ª, {detail: error})); <br>  } <br>  } <br>  }); <br><br> sinon.extend(FakeXMLHttpRequest, { <br> UNSENT: 0, <br> OPENED: 1, <br> HEADERS_RECEIVED: 2, <br> LOADING: 3, <br> DONE: 4 <br>  }); <br><br> sinon.useFakeXMLHttpRequest = function () { <br> FakeXMLHttpRequest.restore = function restore(keepOnCreate) { <br> if (sinonXhr.supportsXHR) { <br> global.XMLHttpRequest = sinonXhr.GlobalXMLHttpRequest; <br>  } <br><br> if (sinonXhr.supportsActiveX) { <br> global.ActiveXObject = sinonXhr.GlobalActiveXObject; <br>  } <br><br> delete FakeXMLHttpRequest.restore; <br><br> if (keepOnCreate !== true) { <br> delete FakeXMLHttpRequest.onCreate; <br>  } <br>  }; <br> if (sinonXhr.supportsXHR) { <br> global.XMLHttpRequest = FakeXMLHttpRequest; <br>  } <br><br> if (sinonXhr.supportsActiveX) { <br> global.ActiveXObject = function ActiveXObject(objId) { <br> if (objId === ¬´Microsoft.XMLHTTP¬ª || /^Msxml2\.XMLHTTP/i.test(objId)) { <br><br> return new FakeXMLHttpRequest(); <br>  } <br><br> return new sinonXhr.GlobalActiveXObject(objId); <br>  }; <br>  } <br><br> return FakeXMLHttpRequest; <br>  }; <br><br> sinon.FakeXMLHttpRequest = FakeXMLHttpRequest; <br>  } <br><br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var isAMD = typeof define === ¬´function¬ª &amp;&amp; typeof define.amd === ¬´object¬ª &amp;&amp; define.amd; <br><br> function loadDependencies(require, exports, module) { <br> var sinon = require("./core"); <br> require("../extend"); <br> require("./event"); <br> require("../log_error"); <br> makeApi(sinon); <br> module.exports = sinon; <br>  } <br><br> if (isAMD) { <br> define(loadDependencies); <br>  return; <br>  } <br><br> if (isNode) { <br> loadDependencies(require, module.exports, module); <br>  return; <br>  } <br><br> if (sinonGlobal) { <br> makeApi(sinonGlobal); <br>  } <br> }( <br> typeof sinon === ¬´object¬ª &amp;&amp; sinon, // eslint-disable-line no-undef <br> typeof global !== ¬´undefined¬ª? global: self <br> )); <br><br> /** <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> fake_xdomain_request.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> fake_xml_http_request.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> ../format.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> ../log_error.js <br> */ <br> /** <br> * The Sinon ¬´server¬ª mimics a web server that receives requests from <br> * sinon.FakeXMLHttpRequest and provides an API to respond to those requests, <br> * both synchronously and asynchronously. To respond synchronuously, canned <br> * answers have to be provided upfront. <br>  * <br> * <a href="https://habrahabr.ru/users/author/" class="user_link">author</a> Christian Johansen (christian@cjohansen.no) <br> * @license BSD <br>  * <br> * Copyright ¬© 2010-2013 Christian Johansen <br> */ <br> (function () { <br><br> var push = [].push; <br><br> function responseArray(handler) { <br> var response = handler; <br><br> if (Object.prototype.toString.call(handler) !== "[object Array]") { <br> response = [200, {}, handler]; <br>  } <br><br> if (typeof response[2] !== ¬´string¬ª) { <br> throw new TypeError(¬´Fake server response body should be string, but was ¬ª + <br> typeof response[2]); <br>  } <br><br> return response; <br>  } <br><br> var wloc = typeof window !== ¬´undefined¬ª? window.location: {}; <br> var rCurrLoc = new RegExp("^" + wloc.protocol + "//" + wloc.host); <br><br> function matchOne(response, reqMethod, reqUrl) { <br> var rmeth = response.method; <br> var matchMethod = !rmeth || rmeth.toLowerCase() === reqMethod.toLowerCase(); <br> var url = response.url; <br> var matchUrl = !url || url === reqUrl || (typeof url.test === ¬´function¬ª &amp;&amp; url.test(reqUrl)); <br><br> return matchMethod &amp;&amp; matchUrl; <br>  } <br><br> function match(response, request) { <br> var requestUrl = request.url; <br><br> if (!/^https?:\/\//.test(requestUrl) || rCurrLoc.test(requestUrl)) { <br> requestUrl = requestUrl.replace(rCurrLoc, ""); <br>  } <br><br> if (matchOne(response, this.getHTTPMethod(request), requestUrl)) { <br> if (typeof response.response === ¬´function¬ª) { <br> var ru = response.url; <br> var args = [request].concat(ru &amp;&amp; typeof ru.exec === ¬´function¬ª? ru.exec(requestUrl).slice(1): []); <br> return response.response.apply(response, args); <br>  } <br><br>  return true; <br>  } <br><br>  return false; <br>  } <br><br> function makeApi(sinon) { <br> sinon.fakeServer = { <br> create: function (config) { <br> var server = sinon.create(this); <br> server.configure(config); <br> if (!sinon.xhr.supportsCORS) { <br> this.xhr = sinon.useFakeXDomainRequest(); <br>  } else { <br> this.xhr = sinon.useFakeXMLHttpRequest(); <br>  } <br> server.requests = []; <br><br> this.xhr.onCreate = function (xhrObj) { <br> server.addRequest(xhrObj); <br>  }; <br><br> return server; <br>  }, <br> configure: function (config) { <br> var whitelist = { <br> ¬´autoRespond¬ª: true, <br> ¬´autoRespondAfter¬ª: true, <br> ¬´respondImmediately¬ª: true, <br> ¬´fakeHTTPMethods¬ª: true <br>  }; <br> var setting; <br><br> config = config || {}; <br> for (setting in config) { <br> if (whitelist.hasOwnProperty(setting) &amp;&amp; config.hasOwnProperty(setting)) { <br> this[setting] = config[setting]; <br>  } <br>  } <br>  }, <br> addRequest: function addRequest(xhrObj) { <br> var server = this; <br> push.call(this.requests, xhrObj); <br><br> xhrObj.onSend = function () { <br> server.handleRequest(this); <br><br> if (server.respondImmediately) { <br> server.respond(); <br> } else if (server.autoRespond &amp;&amp; !server.responding) { <br> setTimeout(function () { <br> server.responding = false; <br> server.respond(); <br> }, server.autoRespondAfter || 10); <br><br> server.responding = true; <br>  } <br>  }; <br>  }, <br><br> getHTTPMethod: function getHTTPMethod(request) { <br> if (this.fakeHTTPMethods &amp;&amp; /post/i.test(request.method)) { <br> var matches = (request.requestBody || "").match(/_method=([^\b;]+)/); <br> return matches? matches[1]: request.method; <br>  } <br><br> return request.method; <br>  }, <br><br> handleRequest: function handleRequest(xhr) { <br> if (xhr.async) { <br> if (!this.queue) { <br> this.queue = []; <br>  } <br><br> push.call(this.queue, xhr); <br>  } else { <br> this.processRequest(xhr); <br>  } <br>  }, <br><br> log: function log(response, request) { <br> var str; <br><br> str = ¬´Request:\n¬ª + sinon.format(request) + "\n\n"; <br> str += ¬´Response:\n¬ª + sinon.format(response) + "\n\n"; <br><br> sinon.log(str); <br>  }, <br><br> respondWith: function respondWith(method, url, body) { <br> if (arguments.length === 1 &amp;&amp; typeof method !== ¬´function¬ª) { <br> this.response = responseArray(method); <br>  return; <br>  } <br><br> if (!this.responses) { <br> this.responses = []; <br>  } <br><br> if (arguments.length === 1) { <br> body = method; <br> url = method = null; <br>  } <br><br> if (arguments.length === 2) { <br> body = url; <br> url = method; <br> method = null; <br>  } <br><br> push.call(this.responses, { <br> method: method, <br> url: url, <br> response: typeof body === ¬´function¬ª? body: responseArray(body) <br>  }); <br>  }, <br><br> respond: function respond() { <br> if (arguments.length &gt; 0) { <br> this.respondWith.apply(this, arguments); <br>  } <br><br> var queue = this.queue || []; <br> var requests = queue.splice(0, queue.length); <br><br> for (var i = 0; i &lt; requests.length; i++) { <br> this.processRequest(requests[i]); <br>  } <br>  }, <br><br> processRequest: function processRequest(request) { <br>  try { <br> if (request.aborted) { <br>  return; <br>  } <br><br> var response = this.response || [404, {}, ""]; <br><br> if (this.responses) { <br> for (var l = this.responses.length, i = l ‚Äî 1; i &gt;= 0; i--) { <br> if (match.call(this, this.responses[i], request)) { <br> response = this.responses[i].response; <br>  break; <br>  } <br>  } <br>  } <br><br> if (request.readyState !== 4) { <br> this.log(response, request); <br><br> request.respond(response[0], response[1], response[2]); <br>  } <br>  } catch (e) { <br> sinon.logError(¬´Fake server request processing¬ª, e); <br>  } <br>  }, <br><br> restore: function restore() { <br> return this.xhr.restore &amp;&amp; this.xhr.restore.apply(this.xhr, arguments); <br>  } <br>  }; <br>  } <br><br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var isAMD = typeof define === ¬´function¬ª &amp;&amp; typeof define.amd === ¬´object¬ª &amp;&amp; define.amd; <br><br> function loadDependencies(require, exports, module) { <br> var sinon = require("./core"); <br> require("./fake_xdomain_request"); <br> require("./fake_xml_http_request"); <br> require("../format"); <br> makeApi(sinon); <br> module.exports = sinon; <br>  } <br><br> if (isAMD) { <br> define(loadDependencies); <br> } else if (isNode) { <br> loadDependencies(require, module.exports, module); <br>  } else { <br> makeApi(sinon); // eslint-disable-line no-undef <br>  } <br> }()); <br><br> /** <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> fake_server.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> fake_timers.js <br> */ <br> /** <br> * Add-on for sinon.fakeServer that automatically handles a fake timer along with <br> * the FakeXMLHttpRequest. The direct inspiration for this add-on is jQuery <br> * 1.3.x, which does not use xhr object's onreadystatehandler at all ‚Äî instead, <br> * it polls the object for completion with setInterval. Dispite the direct <br> * motivation, there is nothing jQuery-specific in this file, so it can be used <br> * in any environment where the ajax implementation depends on setInterval or <br> * setTimeout. <br>  * <br> * <a href="https://habrahabr.ru/users/author/" class="user_link">author</a> Christian Johansen (christian@cjohansen.no) <br> * @license BSD <br>  * <br> * Copyright ¬© 2010-2013 Christian Johansen <br> */ <br> (function () { <br><br> function makeApi(sinon) { <br> function Server() {} <br> Server.prototype = sinon.fakeServer; <br><br> sinon.fakeServerWithClock = new Server(); <br><br> sinon.fakeServerWithClock.addRequest = function addRequest(xhr) { <br> if (xhr.async) { <br> if (typeof setTimeout.clock === ¬´object¬ª) { <br> this.clock = setTimeout.clock; <br>  } else { <br> this.clock = sinon.useFakeTimers(); <br> this.resetClock = true; <br>  } <br><br> if (!this.longestTimeout) { <br> var clockSetTimeout = this.clock.setTimeout; <br> var clockSetInterval = this.clock.setInterval; <br> var server = this; <br><br> this.clock.setTimeout = function (fn, timeout) { <br> server.longestTimeout = Math.max(timeout, server.longestTimeout || 0); <br><br> return clockSetTimeout.apply(this, arguments); <br>  }; <br><br> this.clock.setInterval = function (fn, timeout) { <br> server.longestTimeout = Math.max(timeout, server.longestTimeout || 0); <br><br> return clockSetInterval.apply(this, arguments); <br>  }; <br>  } <br>  } <br><br> return sinon.fakeServer.addRequest.call(this, xhr); <br>  }; <br><br> sinon.fakeServerWithClock.respond = function respond() { <br> var returnVal = sinon.fakeServer.respond.apply(this, arguments); <br><br> if (this.clock) { <br> this.clock.tick(this.longestTimeout || 0); <br> this.longestTimeout = 0; <br><br> if (this.resetClock) { <br> this.clock.restore(); <br> this.resetClock = false; <br>  } <br>  } <br><br> return returnVal; <br>  }; <br><br> sinon.fakeServerWithClock.restore = function restore() { <br> if (this.clock) { <br> this.clock.restore(); <br>  } <br><br> return sinon.fakeServer.restore.apply(this, arguments); <br>  }; <br>  } <br><br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var isAMD = typeof define === ¬´function¬ª &amp;&amp; typeof define.amd === ¬´object¬ª &amp;&amp; define.amd; <br><br> function loadDependencies(require) { <br> var sinon = require("./core"); <br> require("./fake_server"); <br> require("./fake_timers"); <br> makeApi(sinon); <br>  } <br><br> if (isAMD) { <br> define(loadDependencies); <br> } else if (isNode) { <br> loadDependencies(require); <br>  } else { <br> makeApi(sinon); // eslint-disable-line no-undef <br>  } <br> }()); <br><br> /** <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> util/core.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> extend.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> collection.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> util/fake_timers.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> util/fake_server_with_clock.js <br> */ <br> /** <br> * Manages fake collections as well as fake utilities such as Sinon's <br> * timers and fake XHR implementation in one convenient object. <br>  * <br> * <a href="https://habrahabr.ru/users/author/" class="user_link">author</a> Christian Johansen (christian@cjohansen.no) <br> * @license BSD <br>  * <br> * Copyright ¬© 2010-2013 Christian Johansen <br> */ <br> (function (sinonGlobal) { <br><br> function makeApi(sinon) { <br> var push = [].push; <br><br> function exposeValue(sandbox, config, key, value) { <br> if (!value) { <br>  return; <br>  } <br><br> if (config.injectInto &amp;&amp; !(key in config.injectInto)) { <br> config.injectInto[key] = value; <br> sandbox.injectedKeys.push(key); <br>  } else { <br> push.call(sandbox.args, value); <br>  } <br>  } <br><br> function prepareSandboxFromConfig(config) { <br> var sandbox = sinon.create(sinon.sandbox); <br><br> if (config.useFakeServer) { <br> if (typeof config.useFakeServer === ¬´object¬ª) { <br> sandbox.serverPrototype = config.useFakeServer; <br>  } <br><br> sandbox.useFakeServer(); <br>  } <br><br> if (config.useFakeTimers) { <br> if (typeof config.useFakeTimers === ¬´object¬ª) { <br> sandbox.useFakeTimers.apply(sandbox, config.useFakeTimers); <br>  } else { <br> sandbox.useFakeTimers(); <br>  } <br>  } <br><br> return sandbox; <br>  } <br><br> sinon.sandbox = sinon.extend(sinon.create(sinon.collection), { <br> useFakeTimers: function useFakeTimers() { <br> this.clock = sinon.useFakeTimers.apply(sinon, arguments); <br><br> return this.add(this.clock); <br>  }, <br><br> serverPrototype: sinon.fakeServer, <br><br> useFakeServer: function useFakeServer() { <br> var proto = this.serverPrototype || sinon.fakeServer; <br><br> if (!proto || !proto.create) { <br> return null; <br>  } <br><br> this.server = proto.create(); <br> return this.add(this.server); <br>  }, <br><br> inject: function (obj) { <br> sinon.collection.inject.call(this, obj); <br><br> if (this.clock) { <br> obj.clock = this.clock; <br>  } <br><br> if (this.server) { <br> obj.server = this.server; <br> obj.requests = this.server.requests; <br>  } <br><br> obj.match = sinon.match; <br><br> return obj; <br>  }, <br><br> restore: function () { <br> sinon.collection.restore.apply(this, arguments); <br> this.restoreContext(); <br>  }, <br><br> restoreContext: function () { <br> if (this.injectedKeys) { <br> for (var i = 0, j = this.injectedKeys.length; i &lt; j; i++) { <br> delete this.injectInto[this.injectedKeys[i]]; <br>  } <br> this.injectedKeys = []; <br>  } <br>  }, <br><br> create: function (config) { <br> if (!config) { <br> return sinon.create(sinon.sandbox); <br>  } <br><br> var sandbox = prepareSandboxFromConfig(config); <br> sandbox.args = sandbox.args || []; <br> sandbox.injectedKeys = []; <br> sandbox.injectInto = config.injectInto; <br> var prop, <br> value; <br> var exposed = sandbox.inject({}); <br><br> if (config.properties) { <br> for (var i = 0, l = config.properties.length; i &lt; l; i++) { <br> prop = config.properties[i]; <br> value = exposed[prop] || prop === ¬´sandbox¬ª &amp;&amp; sandbox; <br> exposeValue(sandbox, config, prop, value); <br>  } <br>  } else { <br> exposeValue(sandbox, config, ¬´sandbox¬ª, value); <br>  } <br><br> return sandbox; <br>  }, <br><br> match: sinon.match <br>  }); <br><br> sinon.sandbox.useFakeXMLHttpRequest = sinon.sandbox.useFakeServer; <br><br> return sinon.sandbox; <br>  } <br><br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var isAMD = typeof define === ¬´function¬ª &amp;&amp; typeof define.amd === ¬´object¬ª &amp;&amp; define.amd; <br><br> function loadDependencies(require, exports, module) { <br> var sinon = require("./util/core"); <br> require("./extend"); <br> require("./util/fake_server_with_clock"); <br> require("./util/fake_timers"); <br> require("./collection"); <br> module.exports = makeApi(sinon); <br>  } <br><br> if (isAMD) { <br> define(loadDependencies); <br>  return; <br>  } <br><br> if (isNode) { <br> loadDependencies(require, module.exports, module); <br>  return; <br>  } <br><br> if (sinonGlobal) { <br> makeApi(sinonGlobal); <br>  } <br> }( <br> typeof sinon === ¬´object¬ª &amp;&amp; sinon // eslint-disable-line no-undef <br> )); <br><br> /** <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> util/core.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> sandbox.js <br> */ <br> /** <br> * Test function, sandboxes fakes <br>  * <br> * <a href="https://habrahabr.ru/users/author/" class="user_link">author</a> Christian Johansen (christian@cjohansen.no) <br> * @license BSD <br>  * <br> * Copyright ¬© 2010-2013 Christian Johansen <br> */ <br> (function (sinonGlobal) { <br><br> function makeApi(sinon) { <br> var slice = Array.prototype.slice; <br><br> function test(callback) { <br> var type = typeof callback; <br><br> if (type !== ¬´function¬ª) { <br> throw new TypeError(¬´sinon.test needs to wrap a test function, got ¬ª + type); <br>  } <br><br> function sinonSandboxedTest() { <br> var config = sinon.getConfig(sinon.config); <br> config.injectInto = config.injectIntoThis &amp;&amp; this || config.injectInto; <br> var sandbox = sinon.sandbox.create(config); <br> var args = slice.call(arguments); <br> var oldDone = args.length &amp;&amp; args[args.length ‚Äî 1]; <br> var exception, result; <br><br> if (typeof oldDone === ¬´function¬ª) { <br> args[args.length ‚Äî 1] = function sinonDone(res) { <br> if (res) { <br> sandbox.restore(); <br>  } else { <br> sandbox.verifyAndRestore(); <br>  } <br> oldDone(res); <br>  }; <br>  } <br><br>  try { <br> result = callback.apply(this, args.concat(sandbox.args)); <br>  } catch (e) { <br> exception = e; <br>  } <br><br> if (typeof oldDone !== ¬´function¬ª) { <br> if (typeof exception !== ¬´undefined¬ª) { <br> sandbox.restore(); <br> throw exception; <br>  } else { <br> sandbox.verifyAndRestore(); <br>  } <br>  } <br><br> return result; <br>  } <br><br> if (callback.length) { <br> return function sinonAsyncSandboxedTest(done) { // eslint-disable-line no-unused-vars <br> return sinonSandboxedTest.apply(this, arguments); <br>  }; <br>  } <br><br> return sinonSandboxedTest; <br>  } <br><br> test.config = { <br> injectIntoThis: true, <br> injectInto: null, <br> properties: [¬´spy¬ª, ¬´stub¬ª, ¬´mock¬ª, ¬´clock¬ª, ¬´server¬ª, ¬´requests¬ª], <br> useFakeTimers: true, <br> useFakeServer: true <br>  }; <br><br> sinon.test = test; <br> return test; <br>  } <br><br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var isAMD = typeof define === ¬´function¬ª &amp;&amp; typeof define.amd === ¬´object¬ª &amp;&amp; define.amd; <br><br> function loadDependencies(require, exports, module) { <br> var core = require("./util/core"); <br> require("./sandbox"); <br> module.exports = makeApi(core); <br>  } <br><br> if (isAMD) { <br> define(loadDependencies); <br> } else if (isNode) { <br> loadDependencies(require, module.exports, module); <br> } else if (sinonGlobal) { <br> makeApi(sinonGlobal); <br>  } <br> }(typeof sinon === ¬´object¬ª &amp;&amp; sinon || null)); // eslint-disable-line no-undef <br><br> /** <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> util/core.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> test.js <br> */ <br> /** <br> * Test case, sandboxes all test functions <br>  * <br> * <a href="https://habrahabr.ru/users/author/" class="user_link">author</a> Christian Johansen (christian@cjohansen.no) <br> * @license BSD <br>  * <br> * Copyright ¬© 2010-2013 Christian Johansen <br> */ <br> (function (sinonGlobal) { <br><br> function createTest(property, setUp, tearDown) { <br> return function () { <br> if (setUp) { <br> setUp.apply(this, arguments); <br>  } <br><br> var exception, result; <br><br>  try { <br> result = property.apply(this, arguments); <br>  } catch (e) { <br> exception = e; <br>  } <br><br> if (tearDown) { <br> tearDown.apply(this, arguments); <br>  } <br><br> if (exception) { <br> throw exception; <br>  } <br><br> return result; <br>  }; <br>  } <br><br> function makeApi(sinon) { <br> function testCase(tests, prefix) { <br> if (!tests || typeof tests !== ¬´object¬ª) { <br> throw new TypeError(¬´sinon.testCase needs an object with test functions¬ª); <br>  } <br><br> prefix = prefix || ¬´test¬ª; <br> var rPrefix = new RegExp("^" + prefix); <br> var methods = {}; <br> var setUp = tests.setUp; <br> var tearDown = tests.tearDown; <br> var testName, <br> property, <br> method; <br><br> for (testName in tests) { <br> if (tests.hasOwnProperty(testName) &amp;&amp; !/^(setUp|tearDown)$/.test(testName)) { <br> property = tests[testName]; <br><br> if (typeof property === ¬´function¬ª &amp;&amp; rPrefix.test(testName)) { <br> method = property; <br><br> if (setUp || tearDown) { <br> method = createTest(property, setUp, tearDown); <br>  } <br><br> methods[testName] = sinon.test(method); <br>  } else { <br> methods[testName] = tests[testName]; <br>  } <br>  } <br>  } <br><br> return methods; <br>  } <br><br> sinon.testCase = testCase; <br> return testCase; <br>  } <br><br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var isAMD = typeof define === ¬´function¬ª &amp;&amp; typeof define.amd === ¬´object¬ª &amp;&amp; define.amd; <br><br> function loadDependencies(require, exports, module) { <br> var core = require("./util/core"); <br> require("./test"); <br> module.exports = makeApi(core); <br>  } <br><br> if (isAMD) { <br> define(loadDependencies); <br>  return; <br>  } <br><br> if (isNode) { <br> loadDependencies(require, module.exports, module); <br>  return; <br>  } <br><br> if (sinonGlobal) { <br> makeApi(sinonGlobal); <br>  } <br> }( <br> typeof sinon === ¬´object¬ª &amp;&amp; sinon // eslint-disable-line no-undef <br> )); <br><br> /** <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> times_in_words.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> util/core.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> match.js <br> * <a href="https://habrahabr.ru/users/depend/" class="user_link">depend</a> format.js <br> */ <br> /** <br> * Assertions matching the test spy retrieval interface. <br>  * <br> * <a href="https://habrahabr.ru/users/author/" class="user_link">author</a> Christian Johansen (christian@cjohansen.no) <br> * @license BSD <br>  * <br> * Copyright ¬© 2010-2013 Christian Johansen <br> */ <br> (function (sinonGlobal, global) { <br><br> var slice = Array.prototype.slice; <br><br> function makeApi(sinon) { <br> var assert; <br><br> function verifyIsStub() { <br> var method; <br><br> for (var i = 0, l = arguments.length; i &lt; l; ++i) { <br> method = arguments[i]; <br><br> if (!method) { <br> assert.fail(¬´fake is not a spy¬ª); <br>  } <br><br> if (method.proxy &amp;&amp; method.proxy.isSinonProxy) { <br> verifyIsStub(method.proxy); <br>  } else { <br> if (typeof method !== ¬´function¬ª) { <br> assert.fail(method + " is not a function"); <br>  } <br><br> if (typeof method.getCall !== ¬´function¬ª) { <br> assert.fail(method + " is not stubbed"); <br>  } <br>  } <br><br>  } <br>  } <br><br> function failAssertion(object, msg) { <br> object = object || global; <br> var failMethod = object.fail || assert.fail; <br> failMethod.call(object, msg); <br>  } <br><br> function mirrorPropAsAssertion(name, method, message) { <br> if (arguments.length === 2) { <br> message = method; <br> method = name; <br>  } <br><br> assert[name] = function (fake) { <br> verifyIsStub(fake); <br><br> var args = slice.call(arguments, 1); <br> var failed = false; <br><br> if (typeof method === ¬´function¬ª) { <br> failed = !method(fake); <br>  } else { <br> failed = typeof fake[method] === ¬´function¬ª? <br> !fake[method].apply(fake, args): !fake[method]; <br>  } <br><br> if (failed) { <br> failAssertion(this, (fake.printf || fake.proxy.printf).apply(fake, [message].concat(args))); <br>  } else { <br> assert.pass(name); <br>  } <br>  }; <br>  } <br><br> function exposedName(prefix, prop) { <br> return !prefix || /^fail/.test(prop)? prop: <br> prefix + prop.slice(0, 1).toUpperCase() + prop.slice(1); <br>  } <br><br> assert = { <br> failException: ¬´AssertError¬ª, <br><br> fail: function fail(message) { <br> var error = new Error(message); <br> error.name = this.failException || assert.failException; <br><br> throw error; <br>  }, <br><br> pass: function pass() {}, <br><br> callOrder: function assertCallOrder() { <br> verifyIsStub.apply(null, arguments); <br> var expected = ""; <br> var actual = ""; <br><br> if (!sinon.calledInOrder(arguments)) { <br>  try { <br> expected = [].join.call(arguments, ", "); <br> var calls = slice.call(arguments); <br> var i = calls.length; <br> while (i) { <br> if (!calls[--i].called) { <br> calls.splice(i, 1); <br>  } <br>  } <br> actual = sinon.orderByFirstCall(calls).join(", "); <br>  } catch (e) { <br> // If this fails, we'll just fall back to the blank string <br>  } <br><br> failAssertion(this, ¬´expected ¬ª + expected + " to be " + <br> ¬´called in order but were called as ¬ª + actual); <br>  } else { <br> assert.pass(¬´callOrder¬ª); <br>  } <br>  }, <br><br> callCount: function assertCallCount(method, count) { <br> verifyIsStub(method); <br><br> if (method.callCount !== count) { <br> var msg = ¬´expected %n to be called ¬ª + sinon.timesInWords(count) + <br> " but was called %c%C"; <br> failAssertion(this, method.printf(msg)); <br>  } else { <br> assert.pass(¬´callCount¬ª); <br>  } <br>  }, <br><br> expose: function expose(target, options) { <br> if (!target) { <br> throw new TypeError(¬´target is null or undefined¬ª); <br>  } <br><br> var o = options || {}; <br> var prefix = typeof o.prefix === ¬´undefined¬ª &amp;&amp; ¬´assert¬ª || o.prefix; <br> var includeFail = typeof o.includeFail === ¬´undefined¬ª || !!o.includeFail; <br><br> for (var method in this) { <br> if (method !== ¬´expose¬ª &amp;&amp; (includeFail || !/^(fail)/.test(method))) { <br> target[exposedName(prefix, method)] = this[method]; <br>  } <br>  } <br><br> return target; <br>  }, <br><br> match: function match(actual, expectation) { <br> var matcher = sinon.match(expectation); <br> if (matcher.test(actual)) { <br> assert.pass(¬´match¬ª); <br>  } else { <br> var formatted = [ <br> ¬´expected value to match¬ª, <br> " expected = " + sinon.format(expectation), <br> " actual = " + sinon.format(actual) <br> ]; <br><br> failAssertion(this, formatted.join("\n")); <br>  } <br>  } <br>  }; <br><br> mirrorPropAsAssertion(¬´called¬ª, ¬´expected %n to have been called at least once but was never called¬ª); <br> mirrorPropAsAssertion(¬´notCalled¬ª, function (spy) { <br> return !spy.called; <br> }, ¬´expected %n to not have been called but was called %c%C¬ª); <br> mirrorPropAsAssertion(¬´calledOnce¬ª, ¬´expected %n to be called once but was called %c%C¬ª); <br> mirrorPropAsAssertion(¬´calledTwice¬ª, ¬´expected %n to be called twice but was called %c%C¬ª); <br> mirrorPropAsAssertion(¬´calledThrice¬ª, ¬´expected %n to be called thrice but was called %c%C¬ª); <br> mirrorPropAsAssertion(¬´calledOn¬ª, ¬´expected %n to be called with %1 as this but was called with %t¬ª); <br> mirrorPropAsAssertion( <br> ¬´alwaysCalledOn¬ª, <br> ¬´expected %n to always be called with %1 as this but was called with %t¬ª <br>  ); <br> mirrorPropAsAssertion(¬´calledWithNew¬ª, ¬´expected %n to be called with new¬ª); <br> mirrorPropAsAssertion(¬´alwaysCalledWithNew¬ª, ¬´expected %n to always be called with new¬ª); <br> mirrorPropAsAssertion(¬´calledWith¬ª, ¬´expected %n to be called with arguments %*%C¬ª); <br> mirrorPropAsAssertion(¬´calledWithMatch¬ª, ¬´expected %n to be called with match %*%C¬ª); <br> mirrorPropAsAssertion(¬´alwaysCalledWith¬ª, ¬´expected %n to always be called with arguments %*%C¬ª); <br> mirrorPropAsAssertion(¬´alwaysCalledWithMatch¬ª, ¬´expected %n to always be called with match %*%C¬ª); <br> mirrorPropAsAssertion(¬´calledWithExactly¬ª, ¬´expected %n to be called with exact arguments %*%C¬ª); <br> mirrorPropAsAssertion(¬´alwaysCalledWithExactly¬ª, ¬´expected %n to always be called with exact arguments %*%C¬ª); <br> mirrorPropAsAssertion(¬´neverCalledWith¬ª, ¬´expected %n to never be called with arguments %*%C¬ª); <br> mirrorPropAsAssertion(¬´neverCalledWithMatch¬ª, ¬´expected %n to never be called with match %*%C¬ª); <br> mirrorPropAsAssertion(¬´threw¬ª, "%n did not throw exception%C"); <br> mirrorPropAsAssertion(¬´alwaysThrew¬ª, "%n did not always throw exception%C"); <br><br> sinon.assert = assert; <br> return assert; <br>  } <br><br> var isNode = typeof module !== ¬´undefined¬ª &amp;&amp; module.exports &amp;&amp; typeof require === ¬´function¬ª; <br> var isAMD = typeof define === ¬´function¬ª &amp;&amp; typeof define.amd === ¬´object¬ª &amp;&amp; define.amd; <br><br> function loadDependencies(require, exports, module) { <br> var sinon = require("./util/core"); <br> require("./match"); <br> require("./format"); <br> module.exports = makeApi(sinon); <br>  } <br><br> if (isAMD) { <br> define(loadDependencies); <br>  return; <br>  } <br><br> if (isNode) { <br> loadDependencies(require, module.exports, module); <br>  return; <br>  } <br><br> if (sinonGlobal) { <br> makeApi(sinonGlobal); <br>  } <br> }( <br> typeof sinon === ¬´object¬ª &amp;&amp; sinon, // eslint-disable-line no-undef <br> typeof global !== ¬´undefined¬ª? global: self <br> )); <br><br> return sinon; <br> })); <br><br></div></div><br>   <a href="http://sinonjs.org/docs/"></a> . </div></div></div><p>Source: <a href="https://habr.com/ru/post/274317/">https://habr.com/ru/post/274317/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274307/index.html">Video of the best reports of the JPoint 2015 Java Conference - Part 1</a></li>
<li><a href="../274309/index.html">New Year's gift from the Russian hoster low-cost</a></li>
<li><a href="../274311/index.html">Materials from Azov Developers Meetup 2015</a></li>
<li><a href="../274313/index.html">Compare incomparable: json in PostgreSQL vs Mysql vs Mongodb</a></li>
<li><a href="../274315/index.html">JOIN the dark side of the SQL</a></li>
<li><a href="../274319/index.html">How to migrate to Oracle Java Cloud in 1.5 hours?</a></li>
<li><a href="../274321/index.html">We are looking for errors in MonoDevelop</a></li>
<li><a href="../274323/index.html">An example of the implementation of methods for processing and recognition of images on Android</a></li>
<li><a href="../274325/index.html">Mobile Applications and PA-DSS</a></li>
<li><a href="../274327/index.html">Useful add-ons to ReSharper</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>