<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unity Empowerment</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this post I will show an example of how you can extend the standard features of the Unity IoC container. I will show how an object is created in Un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unity Empowerment</h1><div class="post__text post__text-html js-mediator-article">  In this post I will show an example of how you can extend the standard features of the <a href="http://msdn.microsoft.com/en-us/library/cc468366.aspx">Unity</a> IoC container.  I will show how an object is created in Unity "from the inside".  I'll tell you about Unity Extensions, Strategies &amp; Policies. <br><br>  Suppose there is a Persistence component in our application that is responsible for saving objects.  It is described by the IPersistence interface and has implementations - FilePersistence, DbPersistence, WsPersistence, InMemoryPersistence. <br><br>  In the classic version, at the beginning of the application, we register the desired implementation in Unity and then, by calling Resolve for IPersistence, we always get it. <br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">IUnityContainer uc = <font color="#0000ff">new</font> UnityContainer(); <br> <br> uc.RegisterType&lt;IPersistence, FilePersistence&gt;(); <br> IPersistence p = uc.Resolve&lt;IPersistence&gt;(); <br> p.Add(obj);</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But what to do if the necessary implementation can change during the operation of the application.  For example, is it specified in a config file, or should the network be unavailable, should FilePersistence be automatically used? <br><a name="habracut"></a><br>  Unity has the ability to register dependencies by name.  Example: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">uc.RegisterType&lt;IPersistence, InMemoryPersistence&gt;( <font color="#A31515">"none"</font> ); <br> uc.RegisterType&lt;IPersistence, FilePersistence&gt;( <font color="#A31515">"file"</font> ); <br> uc.RegisterType&lt;IPersistence, DbPersistence&gt;( <font color="#A31515">"db"</font> ); <br> uc.RegisterType&lt;IPersistence, WsPersistence&gt;( <font color="#A31515">"ws"</font> ); <br> <br> IPersistence p = uc.Resolve&lt;IPersistence&gt;( <font color="#A31515">"file"</font> ); <font color="#008000">//  file .</font> <br> IPersistence p = uc.Resolve&lt;IPersistence&gt;( <font color="#A31515">"db"</font> );  //  db.</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  It remains to ensure that when receiving an implementation without a name, Unity will somehow determine which implementation we need. <br>  Let us have a delegate that we pass to Unity, which defines the desired implementation name. <br>  Example: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">uc.SetNameResolver&lt;IPersistence&gt;(GetPersistenceImplementationName); <br> IPersistence p = uc.Resolve&lt;IPersistence&gt;();  //     ,    GetPersistenceImplementationName</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  There is no standard way in Unity for this.  But we will solve the problem by writing our own extension. <br><br><h4>  Unity extensions </h4><br>  The Unity extension is a class inherited from UnityContainerExtension.  It has the extension context (ExtensionContext) and the virtual methods Initialize () and Remove () (respectively, are called when the extension is initialized and deleted). <br>  Extensions are added through the methods of the AddNewExtension and AddExtension container, removed through RemoveAllExtensions. <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">public</font> <font color="#0000ff">class</font> NameResolverExtension : UnityContainerExtension <br> { <br> <font color="#0000ff">protected</font> <font color="#0000ff">override</font> <font color="#0000ff">void</font> Initialize() <br> { <br> } <br> <br> <font color="#0000ff">protected</font> <font color="#0000ff">override</font> <font color="#0000ff">void</font> Remove() <br> { <br> } <br> <br> <font color="#0000ff">public</font> NameResolverExtension() <br> : <font color="#0000ff">base</font> () <br> { <br> } <br> } <br> <br> uc.AddNewExtension&lt;NameResolverExtension&gt;();</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  For an extension to be configured, it must implement the configurator interface inherited from IUnityContainerExtensionConfigurator.  Configuring occurs through the method of container Configure. <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">//     </font> <br> <font color="#0000ff">public</font> <font color="#0000ff">delegate</font> <font color="#0000ff">string</font> NameResolverDelegate(Type typeToBuild); <br> <br> <font color="#008000">// -</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">interface</font> INameResolverExtensionConfigurator : IUnityContainerExtensionConfigurator <br> { <br> INameResolverExtensionConfigurator RegisterDelegatedName&lt;TTypeToBuild&gt;( <br> NameResolverDelegate resolver); <br> } <br> <br> <font color="#0000ff">static</font> <font color="#0000ff">private</font> <font color="#0000ff">string</font> GetPersistenceImplementationName(Type typeToBuild) <br> { <br> <font color="#008000">//        ...</font> <br> <font color="#0000ff">return</font> <font color="#A31515">"db"</font> ; <br> } <br> <br> uc.Configure&lt;INameResolverExtensionConfigurator&gt;() <br> .RegisterDelegatedName&lt;IPersistence&gt;(GetPersistenceImplementationName);</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br><h4>  Strategy </h4><br>  Each registered type in Unity has its own build key (buildKey).  It consists of a registered type and the name under which it was registered. <br><br>  The Unity Resolve process is implemented using strategies. <br>  Strategy is a class that implements the IBuilderStrategy interface.  It has four methods: PreBuildUp, PostBuildUp, PreTearDown, PostTearDown. <br>  When calling Resolve: <br><ol><li>  A list of registered strategies is created; </li><li>  The build-key of the required type and the context of construction (BuilderContext) are formed; </li><li>  The context is sequentially processed by strategies until one of them sets the BuildComplete flag to true. </li></ol><br>  In Unity, there are 4 predefined strategies that are invoked for each Resolve: <br><ul><li>  BuildKeyMappingStrategy.  Replaces the build key in the context of the type being searched for with the implementation key.  In fact, all the resolving is happening here; </li><li>  LifetimeStrategy.  Checks the presence of the implementation in the Lifetime Manager; </li><li>  ArrayResolutionStrategy.  Resolving array dependencies </li><li>  BuildPlanStrategy.  Creating an instance of the implementation (if it has not yet been created) and automatically resolving its dependencies. </li></ul><br><br>  We will write our strategist, which will replace in the build key an empty name for the desired implementation. <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">internal</font> <font color="#0000ff">class</font> ResolveNameBuilderStrategy : BuilderStrategy <br> { <br> <font color="#0000ff">private</font> NamedTypeBuildKey ReplaceBuildKeyName(IBuilderContext context, NamedTypeBuildKey buildKey) <br> { <br> } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">override</font> <font color="#0000ff">void</font> PreBuildUp(IBuilderContext context) <br> { <br> <font color="#0000ff">if</font> (context.BuildKey <font color="#0000ff">is</font> NamedTypeBuildKey) <br> context.BuildKey = ReplaceBuildKeyName(context, (NamedTypeBuildKey)(context.BuildKey)); <br> } <br> <br> <font color="#0000ff">public</font> ResolveNameBuilderStrategy() <br> : <font color="#0000ff">base</font> () <br> { <br> } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  Because  Since the search key implementation is searched for in the BuildKeyMappingStrategy strategy, we need to register our strategy so that it is executed before BuildKeyMappingStrategy.  Strategies are sorted according to the stage that was specified during registration. <br>  In total there are 7 stages - Setup, TypeMapping, Lifetime, PreCreation, Creation, Initialization, PostInitialization.  BuildKeyMappingStrategy is registered at the TypeMapping stage, which means we will register our strategy at Setup.  Registration will take place in the Initialize method of our extension. <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">public</font> <font color="#0000ff">class</font> NameResolverExtension : UnityContainerExtension, INameResolverExtensionConfigurator <br> { <br> <font color="#0000ff">protected</font> <font color="#0000ff">override</font> <font color="#0000ff">void</font> Initialize() <br> { <br> Context.Strategies.AddNew&lt;ResolveNameBuilderStrategy&gt;(UnityBuildStage.Setup); <br> } <br> <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br><h4>  Policies </h4><br>  Another important mechanism in Unity is policy. <br>  A policy is an interface inherited from IBuilderPolicy and a class that implements it. <br>  In the policy interface, you can define methods for any action.  IBuilderPolicy itself is empty. <br>  The strategy can obtain from the BuilderContext a policy for a given type using a build key. <br>  Create your own policy to get the new name for the build-key. <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">internal</font> <font color="#0000ff">interface</font> IResolveNamePolicy : IBuilderPolicy <br> { <br> <font color="#0000ff">string</font> ResolveName(NamedTypeBuildKey buildKey); <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  We use it in our strategy. <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">internal</font> <font color="#0000ff">class</font> ResolveNameBuilderStrategy : BuilderStrategy <br> { <br> <font color="#0000ff">private</font> NamedTypeBuildKey ReplaceBuildKeyName( <br> IBuilderContext context, NamedTypeBuildKey buildKey) <br> { <br> IResolveNamePolicy policy = context.Policies.Get&lt;IResolveNamePolicy&gt;(buildKey); <br> <br> <font color="#0000ff">if</font> (policy != <font color="#0000ff">null</font> ) <br> <font color="#0000ff">return</font> <font color="#0000ff">new</font> NamedTypeBuildKey(buildKey.Type, policy.ResolveName(buildKey)); <br> <br> <font color="#0000ff">return</font> buildKey; <br> } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  You can add strategies in the extension through context.  A policy is added for a specific key, or as a default policy. <br>  We implement the policy of getting the name through the delegate: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">internal</font> <font color="#0000ff">class</font> ResolveNamePolicyDelegated : IResolveNamePolicy <br> { <br> <font color="#0000ff">protected</font> <font color="#0000ff">readonly</font> NameResolverDelegate Resolver; <br> <br> <font color="#0000ff">public</font> ResolveNamePolicyDelegated(NameResolverDelegate resolver) <br> : <font color="#0000ff">base</font> () <br> { <br> Resolver = resolver; <br> } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">string</font> ResolveName(NamedTypeBuildKey buildKey) <br> { <br> <font color="#0000ff">return</font> Resolver(buildKey.Type); <br> } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  For the policy interface, the IResolveNamePolicy can be somewhat implemented, for example, through a delegate, through an interface, through a call to a config. <br><br>  We will add a policy for a specific build-key when configuring our extension. <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">public</font> <font color="#0000ff">class</font> NameResolverExtension : UnityContainerExtension, INameResolverExtensionConfigurator <br> { <br> <font color="#0000ff">public</font> INameResolverExtensionConfigurator RegisterDelegatedName&lt;TTypeToBuild&gt;(NameResolverDelegate resolver) <br> { <br> Context.Policies.Set&lt;IResolveNamePolicy&gt;( <br> <font color="#0000ff">new</font> ResolveNamePolicyDelegated(resolver), <br> NamedTypeBuildKey.Make&lt;TTypeToBuild&gt;()); <br> <br> <font color="#0000ff">return</font> <font color="#0000ff">this</font> ; <br> } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br><h4>  Result </h4><br>  Our extension is ready. <br>  Now we can do this: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">IUnityContainer uc = <font color="#0000ff">new</font> UnityContainer(); <br> <br> uc.RegisterType&lt;IPersistence, InMemoryPersistence&gt;( <font color="#A31515">"none"</font> ); <br> uc.RegisterType&lt;IPersistence, FilePersistence&gt;( <font color="#A31515">"file"</font> ); <br> uc.RegisterType&lt;IPersistence, DbPersistence&gt;( <font color="#A31515">"db"</font> ); <br> uc.RegisterType&lt;IPersistence, WsPersistence&gt;( <font color="#A31515">"ws"</font> ); <br> <br> uc.AddNewExtension&lt;NameResolverExtension&gt;(); <br> uc.Configure&lt;INameResolverExtensionConfigurator&gt;().RegisterDelegatedName&lt;IPersistence&gt;(GetPersistenceImplementationName); <br> <br> IPersistence p = uc.Resolve&lt;IPersistence&gt;(); <br> p.Add( <font color="#0000ff">new</font> Object()); //    ,    GetPersistenceImplementationName</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  You can create a class helper for IUnityContainer so that you can write ‚ÄúSetNameResolver‚Äù as you would like in the beginning. <br><br>  Now when calling Resolve: <br><ul><li>  The first is our strategy; </li><li>  It gets the policy for the desired build key; </li><li>  If a policy exists for this build-key, then the build-key is replaced in the context with a key with the name from the policy; </li><li>  Further, Resolve works in the same way as before, but it creates an object not for an unnamed key, but for a key with a new name. </li></ul><br>  The source code is <a href="http://code.google.com/p/anks2dev/source/browse/">here.</a> </div><p>Source: <a href="https://habr.com/ru/post/92549/">https://habr.com/ru/post/92549/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../92536/index.html">Publisher Snowball became part of the "1C-SoftKlab"</a></li>
<li><a href="../92538/index.html">Linux InstallFest 10.04 Workshop Topics in Nizhny Novgorod</a></li>
<li><a href="../92539/index.html">Steve Jobs: patent pool going to overtake Theora</a></li>
<li><a href="../92540/index.html">8bit Killer: an eight-bit face FPS</a></li>
<li><a href="../92547/index.html">Released official twitter client for android</a></li>
<li><a href="../92553/index.html">Zon-e-weg: sunny road</a></li>
<li><a href="../92556/index.html">22 examples of incredible ideas and designs</a></li>
<li><a href="../92557/index.html">The company Alpinestars created a safety cushion for the motorcyclist</a></li>
<li><a href="../92558/index.html">Wikistream - Worldwide audio guide based on Wikipedia articles.</a></li>
<li><a href="../92559/index.html">The robot is balancing on the ball</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>