<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Continuous integration in Yandex</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Maintaining a huge code base while ensuring high performance for a large number of developers is a serious challenge. Over the past 5 years, Yandex ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Continuous integration in Yandex</h1><div class="post__text post__text-html js-mediator-article"><p>  Maintaining a huge code base while ensuring high performance for a large number of developers is a serious challenge.  Over the past 5 years, Yandex has been developing a special system of continuous integration.  In this article, we‚Äôll tell you about the scale of the Yandex code base, about transferring development to a single repository with a trunk-based approach to development, about what tasks a continuous integration system should solve in order to work effectively in such conditions. </p><br><img src="https://habrastorage.org/webt/wb/mt/xc/wbmtxcvurtd6cdv1aomjrtcyfw8.png"><br><p>  Many years ago in Yandex there were no special rules in the development of services: each department could use any languages, any technologies, any deployment systems.  And as practice has shown, such freedom did not always help to move forward faster.  At that time, there were often several in-house or open-source developments for solving the same problems.  With the growth of the company, this ecosystem worked worse.  At the same time, we wanted to remain one big Yandex, and not be divided into many independent companies, because it gives a lot of advantages: many people do some similar tasks, the results of their work can be reused.  Starting from a variety of data structures, such as distributed hash tables and lock-free queues, and ending with a lot of different specialized code that we have written for 20 years. </p><a name="habracut"></a><br><p>  Many tasks that we solve do not solve in the open-source world.  There is no MapReduce that works well on our volumes (5000+ servers) and our tasks, there is no task tracker that can handle all of our tens of millions of tickets.  This is attractive in Yandex - you can do really big things. </p><br><p>  But we have a serious drop in efficiency when we solve the same tasks anew, rework ready-made solutions, making it difficult to integrate between components.  It is good and convenient to do everything just for yourself in your own corner, you can not think about others for the time being.  But as soon as the service becomes quite noticeable, it will have dependencies.  It only seems that different services are weakly dependent on each other, in fact - there are a lot of connections between different parts of the company.  Many services are available through the application Yandex / Browser /, etc., or embedded in each other.  For example, <a href="https://habr.com/company/yandex/blog/339638/">Alice</a> appears in the Browser, with the help of Alice you can order a taxi.  We all use common components: <a href="https://habr.com/company/yandex/blog/311104/">YT</a> , <a href="https://habr.com/company/yandex/blog/312430/">YQL</a> , <a href="https://habr.com/company/yandex/blog/351016/">Nirvana</a> . </p><br><p>  The old development model had significant problems.  Due to the presence of many repositories, it‚Äôs difficult for an ordinary developer, especially for a beginner, to find out: </p><br><ul><li>  where is the component? </li><li>  how it works: there is no opportunity to "take and read" </li><li>  Who is developing and supporting it now? </li><li>  How to start using it? </li></ul><br><p>  As a result, there was a problem of mutual use of components.  The components almost could not use other components, because they represented "black boxes" for each other.  This had a negative effect on the company, since the components were not only not re-used, but often did not improve.  Many components were duplicated, the amount of code that had to be maintained was greatly increased.  We generally moved slower than we could. </p><br><h3 id="edinyy-repozitoriy-i-infrastruktura">  Single repository and infrastructure </h3><br><p>  5 years ago we started a project to transfer development to a single repository, with common systems for building, testing, deploying and monitoring. </p><br><p>  The main goal we wanted to achieve is to remove interference that prevents the integration of someone else's code.  The system should provide easy access to ready-made working code, a clear scheme for its connection and use, collection: projects are always collected (and pass tests). </p><br><p>  As a result of the project, a single stack of infrastructure technologies emerged for the company: source code storage, code review system, build system, continuous integration system, deployment, monitoring. </p><br><p>  Now most of the source code of Yandex projects is stored in a single repository, or is in the process of moving to it: </p><br><ul><li>  More than 2000 developers work on projects. </li><li>  over 50,000 projects and libraries. </li><li>  repository size exceeds 25 GB. </li><li>  more than 3,000,000 commits have already been made to the repository. </li></ul><br><p>  Benefits for the company: </p><br><ul><li>  Any project from the repository gets ready infrastructure: <br><ul><li>  a system for viewing and navigating through the source code and a code-review system. </li><li>  build system and distributed build.  This is a separate large topic, and we will definitely reveal it in the following articles. </li><li>  continuous integration system. </li><li>  deployment, integration with the monitoring system. </li></ul></li><li>  code sharing, active team interaction. </li><li>  all code is shared, you can come to another project and make the changes you need there.  This is especially important in a large company, because the other team, from which you need something, may not have the resources.  With the common code, you have the opportunity to do some of the work yourself and ‚Äúhelp it happen‚Äù to the changes you need. </li><li>  There is an opportunity to conduct global refactoring.  You do not need to maintain old versions of your API or library, you can change them and change the places where they are used in other projects. </li><li>  the code becomes less ‚Äúdiverse‚Äù.  You have a set of ways to solve problems, and there is no need to add another way that does roughly the same thing, but with a few differences. </li><li>  In the project next to you, most likely, there will be no completely exotic languages ‚Äã‚Äãand libraries. </li></ul><br><p>  It should also be understood that this development model has drawbacks that need to be taken into account: </p><br><ul><li>  a common repository requires a separate special infrastructure. </li><li>  the library you need may not be in the repository, but it is in open-source.  There are costs to add and update it.  It strongly depends on the language and the library, somewhere almost free, somewhere very expensive. </li><li>  you need to constantly work on the health of the code.  This includes at least the fight against unnecessary dependencies and the "dead" code. </li></ul><br><p>  Our approach to a common repository imposes general rules that everyone should follow.  In the case of using a single repository, restrictions are imposed on the languages ‚Äã‚Äãused, libraries, deployment methods.  But in the next project everything will be the same or very similar to yours, and you can even fix something there. </p><br><p>  To the model of the general repository, all large companies.  The monolithic repository is a large and well studied and discussed topic, so now we will not go into it much.  If you would like to learn more, then at the end of the article you will find several useful links that reveal this topic in more detail. </p><br><h3 id="usloviya-v-kotoryh-rabotaet-sistema-nepreryvnoy-integracii">  Conditions in which the continuous integration system operates </h3><br><p>  Development is conducted on the model Trunk based development.  Most users work with HEAD or the most recent copy of the repository obtained from the main branch called trunk, which is being developed.  Committing changes to the repository are performed sequentially.  Immediately after the commit, the new code is visible and can be used by all developers.  Development in separate branches is not welcome, although branches can be used for releases. </p><br><p>  Projects depend on the source code.  Projects and libraries form a complex dependency graph.  And that means that changes made in one project potentially affect the rest of the repository. </p><br><p>  A large stream of commits goes to the repository: </p><br><ul><li>  more than 2000 commits per day. </li><li>  up to 10 changes per minute during peak hours. </li></ul><br><p>  The codebase contains more than 500,000 build targets and tests. </p><br><p>  Without a special system of continuous integration in such conditions it would be very difficult to move quickly forward. </p><br><h3 id="sistema-nepreryvnoy-integracii">  Continuous integration system </h3><br><p>  The system of continuous integration launches assemblies and tests for each change: </p><br><ul><li>  Precommit checks.  Allowing you to check the code before the commit and avoid breaking tests on the trunk.  Assemblies and tests run on top of HEAD.  Currently, precommit checks are run voluntarily.  For particularly important projects pre-commit checks are required. </li><li>  Postcommit checks after committing to the repository. </li></ul><br><p>  Builds and tests run in parallel on large clusters of hundreds of servers.  Builds and tests run on different platforms.  Under the main platform (linux), all projects are collected and all tests are run, and under the other platforms, a subset set up by users. </p><br><p>  After receiving and analyzing the results of the builds and the test run, the user receives feedback, for example, if changes break any tests. </p><br><img src="https://habrastorage.org/webt/kr/7s/re/kr7srek9pwwq-88vz8b3orjmtqc.png"><br><br><p>  In case of detection of new breakdowns of the assembly or tests, we send a notification to test owners and the author of changes.  The system also stores and displays the results of checks in a special interface.  The web interface of the integration system displays the progress and the result of the test with a breakdown by test type.  The screen with the results of verification now may look like this: </p><br><img src="https://habrastorage.org/webt/c_/p-/p3/c_p-p3pb17bzgmefh0-su2gmrnc.png"><br><br><h3 id="osobennosti-i-vozmozhnosti-sistemy-nepreryvnoy-integracii">  Features and capabilities of the continuous integration system </h3><br><p>  Solving various problems faced by developers and testers, we developed our system of continuous integration.  The system is already solving many problems, but there is still much to be improved. </p><br><h4 id="tipy-i-razmery-testov">  Types and sizes of tests </h4><br><p>  There are several types of targets that a continuous integration system can launch: </p><br><ul><li>  configure.  The configuration step performed by the build system.  The configuration includes the analysis of the configuration files of the build system, the definition of dependencies between projects and the parameters of the build and run tests. </li><li>  build.  Build libraries and projects. </li><li>  style.  At this stage, it is checked that the code style meets the specified requirements. </li><li>  test.  Tests are divided into stages according to their timeout for operation time and requirements for computing resources. <br><ul><li>  small.  &lt;1 min </li><li>  medium.  &lt;10 min </li><li>  large.  &gt; 10 min.  In addition, there may be special requirements for computing resources. </li><li>  extra large.  This is a special type of test.  Such tests are characterized by a set of the following characteristics: long operating time, large consumption of resources, large amount of input data, they may require special access and most importantly support complex test scripts described below.  There are much fewer such tests than other types of tests, but they are very important. </li></ul></li></ul><br><h4 id="chastota-zapuska-testov-i-binarnyy-poisk-polomok">  Test run frequency and binary breakdown search </h4><br><p>  Huge resources are allocated for testing in Yandex - hundreds of powerful servers.  But even with a large number of resources, we can not run all the tests for each change affecting them.  But at the same time it is very important for us to always help the developer to localize the place where the test breaks, especially in such a large repository. </p><br><p>  How we act.  For every change for all affected projects, builds, style checks, and tests with small and medium sizes are run.  The rest of the tests are run not on every affecting commit, but at some intervals, if there are commits that affect the tests.  In some cases, users can control the startup frequency, in other cases, the startup frequency is set by the system.  If a test breakdown is detected, the process of searching for a test commit commit is started.  The less frequently the test is run, the longer we will look for breaking commit after detecting a breakdown. </p><br><img width="700" src="https://habrastorage.org/webt/1b/7r/hg/1b7rhgcpvzuuqnkue2cmn8yytam.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>  When running precommit checks, we also run only assemblies and light tests.  Further, the user can manually initiate the launch of heavy tests by selecting from the list provided by the system of affected tests. </p><br><h4 id="obnaruzhenie-migayuschih-testov">  Flashing Test Detection </h4><br><p>  Flashing tests are such tests, the result of the launch (Passed / Failed) of which on the same code may depend on various factors.  The causes of the flashing tests can be different: sleep in the test code, errors when working with multithreading, infrastructure problems (inaccessibility of any systems), etc.  Flashing tests present a serious problem: </p><br><ul><li>  This leads to the fact that the system of continuous integration spam false notifications about breakdowns of tests. </li><li>  Pollute the results of checks.  It becomes more difficult to decide on the success of the test results. </li><li> Delay product releases. </li><li>  Difficult to detect.  Tests may flash very rarely. <br>  Developers can ignore flashing tests when analyzing test results.  Sometimes incorrect. <br>  It is impossible to completely eliminate the flashing tests, it must be taken into account in the system of continuous integration. </li></ul><br><p>  At the moment, for every check we run all the tests twice to detect flashing tests.  We also take into account complaints from users (notification recipients).  If we detect blinking, we mark the test with a special flag (muted) and inform the test owner.  After this, only test owners will receive notification of test breakdowns.  Next, we continue to run the test in the normal mode, while analyzing the history of its launches.  If the test does not blink in a specific time window, the automation may decide that the test has stopped flashing and you can reset the flag. </p><br><p>  Our current algorithm is quite simple and many improvements are planned in this place.  First of all, we want to use much more useful signals. </p><br><h4 id="avtomaticheskoe-obnovlenie-vhodnyh-dannyh-testov">  Automatic update of test input </h4><br><p>  When testing the most complex Yandex systems, in addition to other testing methods, testing using <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D1%2581%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BF%25D0%25BE_%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D1%2582%25D0%25B5%25D0%25B3%25D0%25B8%25D0%25B8_%25D1%2587%25D1%2591%25D1%2580%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE_%25D1%258F%25D1%2589%25D0%25B8%25D0%25BA%25D0%25B0">black box strategy</a> + <a href="https://en.wikipedia.org/wiki/Data-driven_testing%2520data-driven">data-driven testing is</a> often used.  To ensure good coverage, such tests require a large set of input data.  Data can be selected from production clusters.  But there is a problem with the fact that the data quickly become obsolete.  The world does not stand still, our systems are constantly evolving.  Outdated test data over time will not provide good test coverage, and then completely lead to breakage of the test due to the fact that programs begin to use new data that are not in the outdated test data. </p><br><p>  In order for the data not to become outdated, the continuous integration system is able to update it automatically.  How it works. </p><br><ol><li>  Test data is stored in a special resource repository. </li><li>  The test contains metadata describing the required input data. </li><li>  The correspondence between the required test input data and the resources is stored in the continuous integration system. </li><li>  The developer provides regular delivery of fresh data to the storage of resources. </li><li>  The continuous integration system searches for new versions of test data in the resource repository and switches input data. </li></ol><br><p>  It is important to update the data in such a way that false testing will not occur.  You cannot just take and, starting from a certain commit, start using new data, since  in the event of a breakdown of the test, it will be unclear who is to blame - commit or new data.  This will also make diff tests unresponsive (described below). </p><br><img width="600" src="https://habrastorage.org/webt/yz/xq/ew/yzxqew6kgfu-irgksx-mbgejtz8.png"><br><p>  Therefore, we make it so that there is some small interval of commits, on which the test is launched from both the old and the new versions of the input data. </p><br><img width="700" src="https://habrastorage.org/webt/r1/zr/j8/r1zrj8e-kxo8bmnd0evq6tgzktg.png"><br><br><h4 id="diff-testy">  Diff tests </h4><br><p>  Diff tests we call a special type of <a href="https://en.wikipedia.org/wiki/Data-driven_testing">data-driven tests</a> that differ from the generally accepted approach in that the test does not have a reference result, but at the same time we need to find in which commits the test changed its behavior. </p><br><p>  The standard approach to data-driven testing is as follows.  The test has a benchmark result when you first run the test.  The benchmark result can be stored in the repository next to the test.  Subsequent runs of the test should lead to the same result. </p><br><img width="600" src="https://habrastorage.org/webt/gj/bq/gx/gjbqgx1rtrgb1lwxhih01ojki3k.png"><br><p>  If the result is different from the reference, the developer must decide whether the change is expected or error.  If the change is expected, the developer should update the reference result while fixing the changes in the repository. </p><br><p>  There are difficulties when using this approach in a large repository with large flows of commits: </p><br><ol><li>  There can be many tests and the tests can be very hard.  The developer does not have the opportunity to run all the affected tests in the working environment. </li><li>  After making changes, the test may break if the reference result was not updated simultaneously with making changes to the code.  Then another developer can make changes to the same component and the test result will change again.  We get the imposition of one error on another.  With such problems it is very difficult to understand, it takes time from the developers. </li></ol><br><p>  What we do.  Diff tests consist of 2 parts: </p><br><ul><li>  Check component. <br><ul><li>  We start the test and save the result to the resource storage. </li><li>  Do not compare the result with the reference. </li><li>  We can catch some of the errors, for example, the program does not start / does not end, crashes, the program does not respond.  The result can also be validated: the presence of any fields in the response, etc. </li></ul></li><li>  Diff component. <br><ul><li>  We compare the results obtained on different launches and build diff.  In the simplest case, this is a function that takes 2 parameters and returns a diff. </li><li>  The appearance of the diff depends on the test, but it must be understandable for someone who will look at the diff.  Usually diff is an html file. </li></ul></li></ul><br><p>  The launch of check and diff components is controlled by a continuous integration system. </p><br><img width="600" src="https://habrastorage.org/webt/jp/g2/2z/jpg22zjvje4rqvytyy8-qlrf-yo.png"><br><br><p>  If the continuous integration system detects a diff, then a binary search is first performed on the commit that caused the change.  After receiving a notification from the developer, it is possible to examine the diff and decide what to do next: recognize the diff as expected (for this you need to perform a special action) or repair / "roll back" your changes. </p><br><h3 id="prodolzhenie-sleduet">  To be continued </h3><br><p>  In the <a href="https://habr.com/company/yandex/blog/429956/">next article</a> we will tell about how the system of continuous integration is arranged. </p><br><h3 id="ssylki">  Links </h3><br><p>  Monolithic repository, Trunk-based development </p><br><ul><li>  <a href="https://en.wikipedia.org/wiki/Monorepo">Monorepo - Wikipedia</a> </li><li>  <a href="https://trunkbaseddevelopment.com/">https://trunkbaseddevelopment.com</a> </li></ul><br><p>  Data-driven testing </p><br><ul><li>  <a href="https://en.wikipedia.org/wiki/Data-driven_testing">Data-driven testing - Wikipedia</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/428972/">https://habr.com/ru/post/428972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../428954/index.html">How we shot ourselves in the foot and tried to figure out exactly what</a></li>
<li><a href="../428956/index.html">Drones on the ISS</a></li>
<li><a href="../428960/index.html">Rome Club Report 2018, Chapter 1.5: The Climate Challenge</a></li>
<li><a href="../428962/index.html">Relokatsiya in Luxoft: how is life left</a></li>
<li><a href="../428964/index.html">SSD vulnerabilities with hardware encryption allow attackers to easily circumvent defensive measures</a></li>
<li><a href="../428974/index.html">Interesting at the exhibition Interlight 2018</a></li>
<li><a href="../428976/index.html">An anthill or a fortress? Building a house for the price of an apartment. Part 2: Heating</a></li>
<li><a href="../428980/index.html">Offline JavaScript Broker</a></li>
<li><a href="../428982/index.html">How to write on D under ARM</a></li>
<li><a href="../428984/index.html">Julia and phase portraits of dynamic systems</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>