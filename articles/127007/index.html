<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Acceleration of parallel computing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The main purpose of the creation and development of numerous types of parallel machines, which we discussed in the last article, is speed. Supercomput...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Acceleration of parallel computing</h1><div class="post__text post__text-html js-mediator-article">  The main purpose of the creation and development of numerous types of parallel machines, which we discussed in the <a href="http://habrahabr.ru/blogs/hi/126930/">last</a> article, is speed.  Supercomputers and multiprocessing systems can and should do everything faster!  Let's try to calculate how much faster. <br><br>  It is logical to think that if one processor performs work in n seconds, then four processors will spend n / 4 seconds.  The concept of ‚Äúspeedup factor‚Äù is the ratio of time that a single processor spends to do a job to the time that a multiprocessor system spends on the same job. <br><br>  S (p) = T <sub>s</sub> / T <sub>p</sub> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For the calculation it is important to use the most optimal T <sub>s</sub> , that is, the best possible non-parallel algorithm. <br><br>  Now the bad news: this acceleration has a limit.  It is called Amdahl's Law (Amdal's Law) and here it‚Äôs the essence: this is how a task looks on an ordinary uniprocessor system: <br><br><img src="http://hexlet.ru/uploads/images/00/00/01/2010/10/18/484f28.png"><br><br><a name="habracut"></a><br><br>  The entire execution time, T <sub>s</sub> , which is already familiar to us, consists of the part that can be distributed into several processors (parallelized) - (1-f) T <sub>s</sub> , and the part that cannot be parallelized (serial) - fT <sub>s</sub> . <br><br>  How will the scheme of the same task look for multiple processors? <br><br><img src="http://hexlet.ru/uploads/images/00/00/01/2010/10/18/b2055b.png"><br><br>  Now the total execution time Tp consists of serial time and the maximum of those that we have divided into several processors (they all run at the same time, but you need to wait for the slowest).  For simplicity, assume that they all take the same time. <br><br>  The acceleration factor is calculated by the formula: <br><br><img src="http://hexlet.ru/uploads/images/00/00/01/2010/10/18/62cca9.png"><br><br>  That is, it all depends on which piece of the program we can parallelize (f in percent means the number of the serial code).  If f = 0%, that is, absolutely all code is parallelized (which is practically impossible), then the more processors we use, the faster the task will be completed and the ratio will be linear: we want 10 times faster - we use ten processors, we want a million times faster - we buy a million processors.  But it is worth leaving 5% of the serial code, and 95% parallelizing, then the acceleration factor will be equal to 20 and higher can not jump.  Even if we buy a million more processors to that million, the program will still run 20 times faster.  Here is how this sad fact looks on the graph with examples of different percentages f: <br><br><img src="http://hexlet.ru/uploads/images/00/00/01/2010/10/18/b8b8bc.png"><br><br>  It turns out that the most important thing about the effectiveness of parallel code is a good design of the algorithm itself.  Every detail can greatly affect the extensibility: if the algorithm now normally uses the resources of a quad-core processor, then it will probably not be able to use more than 8 cores normally, and then in a year it will be necessary to write the program again - because instead of the number of transistors, the number of cores now increases every six months! <br><br>  To write a good parallel algorithm, you need to understand the essence of the problem and think about how it can be divided into separate independent (ideally) parts, so that all of them are executed in parallel on different processors.  Let's look at an example of a rather capacious task of multiplying the matrix A by the vector b.  The result will be written in the vector y, which is identical in size to the vector b.  To get the first value of the vector y, you need to multiply the first row of the matrix by the vector b to get the second value of y ‚Äî the second row by b, and so on.  It turns out that each element of the vector y can be considered independently of the others, that is, in parallel. <br><br><img src="http://hexlet.ru/uploads/images/00/00/01/2010/10/18/61cf3b.png"><br><br>  The size of each such task is the same - all A lines are the same size (for now we don‚Äôt touch such details as the density of the matrix - perhaps there are a lot of zeros in it, but suppose that this doesn‚Äôt have a strong effect on the execution time).  There are no dependencies between tasks, and all tasks use the same b. <br><br>  Another example is a database query: <br><br>  <b>MODEL = ‚ÄúCIVIC‚Äù AND YEAR = 2001 AND (COLOR = ‚ÄùGREEN‚Äù OR COLOR = ‚ÄùWHITE‚Äù);</b> <br><br>  The query is trying to get all the green or white Civic 2001 from this database: <br><br><img src="http://hexlet.ru/uploads/images/00/00/01/2010/10/18/9ee3c4.png"><br><br>  This task can be decomposed into three parts: one processor will form the table of all Tsivik 2001, another processor will form the table of all white and green machines (these two queries can go in parallel), after which the result of the join of these two tables will be the answer. <br><br><img src="http://hexlet.ru/uploads/images/00/00/01/2010/10/18/0acbd6.png"><br><br>  You can change the structure of the request, which can affect the parallelization <br><br><img src="http://hexlet.ru/uploads/images/00/00/01/2010/10/18/ac597a.png"><br><br>  The division of the task into parts for the subsequent distribution of these parts into different processors is called decomposition.  The multiplication of a matrix by a vector is an example of decomposition of the result of the problem: the result (vector y) was divided into several independent parts and each was calculated separately from the other.  The same can be done with matrix multiplication: <br><br><img src="http://hexlet.ru/uploads/images/00/00/01/2010/10/18/4990a7.png"><br><br><h4>  Our first parallel program </h4><br><br>  To write our first parallel program, we will use Cilk.  It is a programming language that is essentially C with convenient tools for parallelizing and synchronizing tasks.  Cilk was developed at MIT in 1994, was free and free, but by 2006 it became commercialized, began to support C ++, and a year ago was bought with giblets by Intel, which, of course, is beneficial to have a good programming language for multicore systems : after all, they also produce such systems.  I'm not sure how to get a compiler for free, our university has an academic version for students (Cilk developer is a good friend of the professor), so please excuse me if you cannot find it.  But I think it is worth searching, because Cilk is terribly simple and convenient!  Do not compare with Pthreads.  All we need to know to start programming are three keywords: <b>cilk</b> , <b>spawn,</b> and <b>sync</b> . <br><br>  It is best to start with an example, so here's your favorite recursive task for everyone - the Fibonacci numbers - in C: <br><br><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y; x = fib (n<span class="hljs-number"><span class="hljs-number">-1</span></span>); y = fib (n<span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x+y); } }</code> </pre> <br><br>  And here is the same program on Cilk: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">cilk </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y; x = <span class="hljs-function"><span class="hljs-function">spawn </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-1</span></span></span></span></span><span class="hljs-function">)</span></span>; y = <span class="hljs-function"><span class="hljs-function">spawn </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-2</span></span></span></span></span><span class="hljs-function">)</span></span>; sync; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x+y); } }</code> </pre><br><br>  Notice the difference?  ,) <br><br>  The <b>cilk</b> keyword is used to specify a function.  The most important are the words spawn and sync.  <b>Spawn</b> is placed before calling the function that we want to run on another kernel, while <b>sync</b> waits for all the functions called by spawn to finish.  That is the line <br><br>  <b>x = spawn fib (n-1);</b> <br><br>  runs on another kernel, and immediately runs the line <b>y = spawn fib (n-2)</b> .  Before returning the result ( <b>return (x + y)</b> ) you need to wait until the end of the execution, otherwise there will be no valid values ‚Äã‚Äãin the variables x and y.  This makes the sync command - as the name implies. <br><br>  Is it easy? <br><br>  Such a program will badly load a lot of cores!  Here is the scheme of this algorithm for n = 4: <br><br><img src="http://hexlet.ru/uploads/images/00/00/01/2010/10/18/0a520c.png"><br><br>  The code highlighting colors correspond to the colors of the graph nodes.  Each graph level is executed simultaneously, that is, the first call for n = 4 calls two functions - for 3 and 2, they in turn - for 2 and 1 and for 1 and 0, respectively. <br><br><img src="http://hexlet.ru/uploads/images/00/00/01/2010/10/18/555a59.png"><br><br>  Here is the <a href="">source code for</a> this program: <br><br>  In the next article we will talk about how the scalability of parallel algorithms is calculated, what types of shelling exist and which is used in cilk, and also touch on sorting and parallel dynamic programming. </div><p>Source: <a href="https://habr.com/ru/post/127007/">https://habr.com/ru/post/127007/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../126998/index.html">Good company conflict management</a></li>
<li><a href="../127002/index.html">What is better for you: mailto or form of sending a message from the site?</a></li>
<li><a href="../127004/index.html">Russian Wiki Encyclopedia "Tradition" now contains 27,000 articles</a></li>
<li><a href="../127005/index.html">Creating a horizontal scroll with gradient and arrows</a></li>
<li><a href="../127006/index.html">Short URLs on Google Maps</a></li>
<li><a href="../127008/index.html">300 thousand cubs to learn English</a></li>
<li><a href="../127009/index.html">Control of DB structure change</a></li>
<li><a href="../127013/index.html">Depth of software as the ability to solve unplanned tasks</a></li>
<li><a href="../127014/index.html">Improving HTML5 canvas performance</a></li>
<li><a href="../127016/index.html">Pagodabox - hosting PHP projects</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>