<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unlimited nesting and URL section tree</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, we will consider one of the possible approaches to the generation of a full path to a partition, which can have unlimited nesting in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unlimited nesting and URL section tree</h1><div class="post__text post__text-html js-mediator-article"> In this article, we will consider one of the possible approaches to the generation of a full path to a partition, which can have unlimited nesting in other sections, as well as quickly obtain the desired partition from a given path. <br><br>  Imagine that we are programming an online store in which there should be a tree of various sections, and also there should be "pleasant" links to sections that would include all subsections.  Example: <code>http://example.com/catalog/category/sub-category</code> . <br><a name="habracut"></a><br><h2>  Sections </h2><br>  The most obvious option is to create a link to the parent through the <code>parent_id</code> attribute and the <code>parent</code> relation. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Category</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;belongsTo(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::class); } }</code> </pre> <br>  Also, our model has an attribute <code>slug</code> - a stub that reflects the section in the URL.  It can be generated from the name, or specified by the user manually.  Most importantly, the stub must pass the <code>alphadash</code> validation <code>alphadash</code> (that is, consist of letters, numbers, and signs, <code>_</code> ), and also be unique within the parent section.  For the latter, it is enough to create a unique index in the database <code>(parent_id, slug)</code> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To get a link to the section, you need to pull out all his parents sequentially.  The URL generation function looks like this: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUrl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $url = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;slug; $category = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($category = $category-&gt;parent) { $url = $category-&gt;slug.<span class="hljs-string"><span class="hljs-string">'/'</span></span>.$url; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'catalog/'</span></span>.$url; }</code> </pre> <br>  The larger the section has ancestors, the more requests to the database will be executed.  But this is only part of the problem.  How to create a route to the section?  Let's try this: <br><br><pre> <code class="php hljs">$router-&gt;get(<span class="hljs-string"><span class="hljs-string">'catalog/{category}'</span></span>, ...);</code> </pre> <br>  Feed the browser link <code>http://example.com/catalog/category</code> .  The route will work.  Now this link: <code>http://example.com/catalog/category/sub-category</code> .  The route will no longer work, because  backslash is a parameter delimiter.  Hmm, then add another parameter and make it optional: <br><br><pre> <code class="php hljs">$router-&gt;get(<span class="hljs-string"><span class="hljs-string">'catalog/{category}/{subcategory?}'</span></span>, ...);</code> </pre> <br>  This route will already work, but if you add another subsection to the URL, then nothing will work.  And the problem is that the number of such subsections is not limited. <br><br>  Further, in order to pull out the necessary section from the database, you must first find the section with the <code>category</code> identifier, then, if specified, the <code>subcategory</code> subsection, etc.  All this causes inconvenience and server load, the number of requests is proportional to the number of subsections. <br><br><h3>  Optimization </h3><br>  The extension for laravel <a href="https://github.com/lazychaser/laravel-nestedset">kalnoy / nestedset</a> will help us greatly reduce the number of requests.  It is designed to simplify work with trees. <br><br><h3>  Installation </h3><br>  Installation is very simple.  First you need to install the extension through composer: <br><br><pre> <code class="hljs perl">composer <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> kalnoy/nestedset</code> </pre> <br>  The model will need two additional attributes that need to be added to the new migration: <br><br><pre> <code class="php hljs">Schema::table(<span class="hljs-string"><span class="hljs-string">'categories'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Blueprint $table)</span></span></span><span class="hljs-function"> </span></span>{ $table-&gt;unsignedInteger(<span class="hljs-string"><span class="hljs-string">'_lft'</span></span>); $table-&gt;unsignedInteger(<span class="hljs-string"><span class="hljs-string">'_rgt'</span></span>); });</code> </pre> <br>  Now you only need to delete the old <code>parent</code> and <code>children</code> relations, if they have been set, and also add a trait <code>Kalnoy\Nestedset\NodeTrait</code> .  After the upgrade, our model looks like this: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Category</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Kalnoy</span></span>\<span class="hljs-title"><span class="hljs-title">Nestedset</span></span>\<span class="hljs-title"><span class="hljs-title">NodeTrait</span></span>; }</code> </pre> <br>  However, the <code>_lft</code> and <code>_rgt</code> not filled in, so that everything <code>_rgt</code> , the final touch remains: <br><br><pre> <code class="php hljs">Category::fixTree();</code> </pre> <br>  This code will " <code>parent_id</code> " the tree based on the <code>parent_id</code> attribute. <br><br><h3>  Simplified Generation </h3><br>  The process of generating a URL looks like this: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUrl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     $slugs = $this-&gt;ancestors()-&gt;lists('slug'); //     $slugs[] = $this-&gt;slug; //     return 'catalog/'.implode('/', $slugs); }</span></span></code> </pre> <br>  Much easier, right?  No matter how many descendants of this section, they will all be received in one request.  But with the routes is not so simple.  Still it is not possible to get a chain of sections for one request. <br><br><h3>  Routes </h3><br>  Task number 1.  How to set a route to a section with all its ancestors in the link? <br><br>  Task number 2.  How to get all the way to the desired section in one request? <br><br><h4>  Description of the route </h4><br>  The answer to the first task is to <em>use the entire path as a route parameter</em> . <br><br><pre> <code class="php hljs">$router-&gt;get(<span class="hljs-string"><span class="hljs-string">'catalog/{path}'</span></span>, <span class="hljs-string"><span class="hljs-string">'CategoriesController@show'</span></span>) -&gt;where(<span class="hljs-string"><span class="hljs-string">'path'</span></span>, <span class="hljs-string"><span class="hljs-string">'[a-zA-Z0-9/_-]+'</span></span>);</code> </pre> <br>  We simply indicate that the <code>{path}</code> parameter can contain not only the usual string, but also a backslash.  Thus, this parameter immediately captures the entire path that follows the control word <code>catalog</code> . <br><br>  Now in the controller at the input we get only one parameter, but we can break it into all subsections: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($path)</span></span></span><span class="hljs-function"> </span></span>{ $path = explode(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, $path); }</code> </pre> <br>  However, this did not simplify the task of obtaining the section specified in the link. <br><br><h4>  Bundle path with section </h4><br>  So how to optimize this process?  <em>Store the full path for each section in the database</em> . <br><br>  Suppose there is such a simple tree: <br><br><pre> <code class="hljs vbscript">- Category -- <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> category --- <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sub</span></span> category</code> </pre> <br>  These sections will correspond to the following ways: <br><br><pre> <code class="hljs vbscript">- category -- category/<span class="hljs-keyword"><span class="hljs-keyword">sub</span></span>-category --- category/<span class="hljs-keyword"><span class="hljs-keyword">sub</span></span>-category/<span class="hljs-keyword"><span class="hljs-keyword">sub</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sub</span></span>-category</code> </pre> <br>  Then the desired category can be obtained very simply: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($path)</span></span></span><span class="hljs-function"> </span></span>{ $category = Category::where(<span class="hljs-string"><span class="hljs-string">'path'</span></span>, <span class="hljs-string"><span class="hljs-string">'='</span></span>, $path)-&gt;firstOrFail(); }</code> </pre> <br>  Now we save in the database what we previously generated for the link, and the generation of the link is now much simpler: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   public function generatePath() { $slugs = $this-&gt;ancestors()-&gt;lists('slug'); $slugs[] = $this-&gt;slug; $this-&gt;path = implode('/', $slugs); return $this; } //   public function getUrl() { return 'catalog/'.$this-&gt;path; }</span></span></code> </pre> <br>  If you look at the list of paths in the example, you can see that the path for each model is <code>-/-</code> .  Therefore, the path generation can be further optimized: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generatePath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $slug = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;slug; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;path = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;isRoot() ? $slug : <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;parent-&gt;path.<span class="hljs-string"><span class="hljs-string">'/'</span></span>.$slug; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>; }</code> </pre> <br>  The following problem remains.  When the stub of one section is updated, or the section changes the parent, the links of all its descendants must be updated.  The algorithm is simple: get all descendants and generate a new path for them.  The following is a method for updating descendants: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateDescendantsPaths</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       $descendants = $this-&gt;descendants()-&gt;defaultOrder()-&gt;get(); //     parent  children $descendants-&gt;push($this)-&gt;linkNodes()-&gt;pop(); foreach ($descendants as $model) { $model-&gt;generatePath()-&gt;save(); } }</span></span></code> </pre> <br>  Consider in more detail. <br><br>  In the first line we get all descendants (for one request).  <code>defaultOrder</code> here applies tree sorting.  Its meaning is that in the list each section will stand <em>after its ancestor</em> .  The path construction algorithm uses the parent, so it is necessary that the parent update its path before the path of any of its descendants is updated. <br><br>  The second line looks a bit strange.  Its meaning is that it fills the <code>parent</code> relationship, which is used in the path generation algorithm.  If you do not use this optimization, each <code>generatePath</code> call will execute a query to get the value of the <code>parent</code> relationship.  In this case, <code>linkNodes</code> works with the collection of sections and does not make any queries to the database.  Therefore, for this to work for the immediate children of the current section, you need to add it to the collection.  We add the current section, we connect all sections among themselves and we remove it. <br><br>  Well, at the end of the passage through all descendants and updating their paths. <br><br>  It remains only to decide when to call this method.  For this great event: <br><br><ol><li>  Before saving the model, check if the <code>slug</code> or <code>parent_id</code> attributes have changed.  If changed, we call the <code>generatePath</code> method; <br><br></li><li>  After the model has been successfully saved, we check if the <code>path</code> attribute has changed, and if it has changed, call the <code>updateDescendantsPaths</code> method. </li></ol><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">boot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>::saving(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self $model)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($model-&gt;isDirty(<span class="hljs-string"><span class="hljs-string">'slug'</span></span>, <span class="hljs-string"><span class="hljs-string">'parent_id'</span></span>)) { $model-&gt;generatePath(); } }); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>::saved(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self $model)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     ,      // , ..      static $updating = false; if ( ! $updating &amp;&amp; $model-&gt;isDirty('path')) { $updating = true; $model-&gt;updateDescendantsPaths(); $updating = false; } }); }</span></span></code> </pre> <br><h3>  results </h3><br>  The advantages of this approach: <br><br><ul><li>  Instant generation of section links </li><li>  Quickly get a section along the way </li></ul><br>  Disadvantages: <br><br><ul><li>  Paths are stored in the database, which slightly increases the size of the table. </li><li>  Changing the stub of one section entails updating the paths of all descendants </li></ul><br>  In fact, the advantages outweigh the disadvantages very much in view of the fact that you need to generate links and get sections more often than update the stubs;  and space overrun is miserable. <br><br><h2>  Products </h2><br>  Consider approaches to generating links to products that would include the path to the section.  For example: <code>http://example.com/catalog/category/sub-catagory/product</code> .  The main problem here is to form the correct route. <br><br>  <em>The product, as well as the section, has a stub, which can be specified manually or generated based on the name.</em>  <em>It is important that this stub must be unique within the section in order to avoid conflicts.</em>  <em>It is best to create a unique index in the database <code>(category_id, slug)</code> .</em> <br><br>  Let's try the easiest option and consider the following routes: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//    $router-&gt;get('catalog/{path}', function ($path) { return 'category = '.$path; })-&gt;where('path', '[a-zA-Z0-9\-/_]+'); //    $router-&gt;get('catalog/{category}/{product}', function ($category, $product) { return 'category = '.$category.'&lt;br&gt;product = '.$product; })-&gt;where('category', '[a-zA-Z0-9\-/_]+');</span></span></code> </pre> <br>  The first route should already be familiar - this is the route of the section output.  The second route is practically the same, only one more parameter was added to the end, which should point to a specific product in this section.  If you try to enter the above example in the browser line, we get the following: <br><br><pre> <code class="hljs perl">category = category/<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">category</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">product</span></span></span></span></code> </pre> <br>  The first route worked;  not exactly what was expected to get.  This is because the first route will work for any line that starts with the <code>catalog</code> keyword.  Need to swap routes.  Then we get: <br><br><pre> <code class="hljs perl">category = category/<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">category</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">product</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">product</span></span></span></span></code> </pre> <br>  Fine!  This is better, but not all.  Let's try this URL: <code>http://example.com/catalog/category/sub-category</code> .  We get the following: <br><br><pre> <code class="hljs perl">category = category product = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">category</span></span></span></span></code> </pre> <br>  Now only route to the goods is triggered.  It is necessary to unambiguously separate the cap of the goods from the section cap.  For this you can use any prefix / postfix.  For example, to add a numeric identifier to the end or to the beginning of a product stub: <br><br> <code>http://example.com/catalog/category/sub-category/123-product</code> <br> <br>  It remains only to add a limit on the parameter <code>{product}</code> : <br><br><pre> <code class="php hljs">$router-&gt;get(...)-&gt;where(<span class="hljs-string"><span class="hljs-string">'product'</span></span>, <span class="hljs-string"><span class="hljs-string">'[0-9]+-[a-zA-Z0-9_-]+'</span></span>);</code> </pre> <br>  In this case, the generation of a product stub looks like this: <br><br><pre> <code class="php hljs">$product-&gt;slug = $product-&gt;id.<span class="hljs-string"><span class="hljs-string">'-'</span></span>.str_slug($product-&gt;name);</code> </pre> <br>  Link generation: <br><br><pre> <code class="php hljs">$url = <span class="hljs-string"><span class="hljs-string">'catalog/'</span></span>.$product-&gt;category-&gt;path.<span class="hljs-string"><span class="hljs-string">'/'</span></span>.$product-&gt;slug;</code> </pre> <br>  Receipt of goods in the controller: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($categoryPath, $productSlug)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      $category = Category::where('path', '=', $categoryPath)-&gt;firstOrFail(); //          $product = $category-&gt;products() -&gt;where('slug', '=', $productSlug) -&gt;firstOrFail(); }</span></span></code> </pre> <br>  Here, however, a condition arises: the stubs of sections should not begin with a number.  Otherwise, the route to the goods will work, instead of the route to the section. <br><br>  You can use any static prefix, for example <code>p-</code> : <br><br> <code>http://example.com/catalog/category/sub-category/p-product</code> <br> <br><pre> <code class="php hljs">$router-&gt;get(<span class="hljs-string"><span class="hljs-string">'catalog/{category}/p-{product}'</span></span>, ...);</code> </pre> <br><pre> <code class="php hljs">$product-&gt;slug = str_slug($product-&gt;name);</code> </pre> <br><pre> <code class="php hljs">$url = <span class="hljs-string"><span class="hljs-string">'catalog/'</span></span>.$product-&gt;category-&gt;path.<span class="hljs-string"><span class="hljs-string">'/p-'</span></span>.$product-&gt;slug;</code> </pre> <br>  The controller code remains as in the previous case. <br><br>  The last option is the most difficult.  Its essence is to keep links to sections and products in a separate table. <br><br>  The model looks like this: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Url</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   public function model() { return $this-&gt;morphTo(); } }</span></span></code> </pre> <br>  With this approach, only one route is sufficient: <br><br><pre> <code class="php hljs">$router-&gt;get(<span class="hljs-string"><span class="hljs-string">'catalog/{path}'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($path)</span></span></span><span class="hljs-function"> </span></span>{ $url = Url::findOrFail($path); <span class="hljs-comment"><span class="hljs-comment">//     $model = $url-&gt;model; if ($model instanceof Product) { return $this-&gt;renderProduct($model); } return $this-&gt;renderCategory($model); }) -&gt;where('path', '[a-zA-Z0-9\-/_]+');</span></span></code> </pre> <br>  The <code>Url</code> model has a polymorphic relationship with other models and stores full paths on them.  What it gives: <br><br><ul><li>  No prefix / postfix for product </li><li>  You can store previous versions of the URL and redirect to new ones, i.e.  SEO does not suffer when changing the page address </li><li>  Not necessarily limited to sections / merchandise, you can store any other resource. </li></ul><br>  This approach is described quite arbitrarily as food for thought.  Perhaps it will even pull on a separate extension. <br><br><h2>  findings </h2><br>  In this article, we reviewed the main expansion options for the <code>kalnoy/nestedset</code> , as well as approaches to forming links to sections and products in the case where the nesting depth of sections is not limited. <br><br>  As a result, a method was obtained that allows you to generate links without making queries to the database, as well as receive sections by reference in one request. <br><br>  As an alternative to storing paths in the database, you can use the caching of generated links.  Then there is no need to update the links and just reset the cache. <br></div><p>Source: <a href="https://habr.com/ru/post/279233/">https://habr.com/ru/post/279233/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279223/index.html">Disaster-resistant IaaS, as well as replication and backups</a></li>
<li><a href="../279225/index.html">VCloud Tools: IT GRAD Experience</a></li>
<li><a href="../279227/index.html">PCI DSS Certification: What it is and what it is eaten with</a></li>
<li><a href="../279229/index.html">Few of the containers</a></li>
<li><a href="../279231/index.html">The story of the development of Cosmos on Unity</a></li>
<li><a href="../279237/index.html">Stack of mean. Usage example</a></li>
<li><a href="../279239/index.html">VM VmWare Workstation performance on a separate hard disk</a></li>
<li><a href="../279241/index.html">Vanivar Bush: ‚ÄúAs We May Think‚Äù (As We May Think)</a></li>
<li><a href="../279243/index.html">Adobe Experience Design CC released (formerly Project Comet)</a></li>
<li><a href="../279245/index.html">Intelligent active noise canceling server cabinet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>