<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Overview of the static analyzer CppCat</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Most recently, a new static C ++ code analysis tool CppCat was presented at Habr√©. Its authors have long and in detail told about their previous proje...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Overview of the static analyzer CppCat</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/623/7c8/89e/6237c889e47b1fea8c029838465f5213.jpg" align="right">  Most recently, a new static C ++ code analysis tool <a href="http://habrahabr.ru/company/pvs-studio/blog/208920/">CppCat was</a> presented at Habr√©.  Its authors have long and in detail told about their previous project (PVS-Studio) in Habr√©.  I had a twofold attitude towards him - on the one hand, of course, static analysis is needed.  With him is better than without him.  On the other hand, PVS-Studio was frightened by its scale, such ‚Äúenterprise‚Äù, and also by the price.  I well imagined how a person in a 50-person project team can buy it, but what a single-person or a 5-person team can do in a single developer ‚Äî I did not understand.  I remember that I once <a href="http://habrahabr.ru/company/pvs-studio/blog/196312/">suggested</a> that the authors deploy ‚ÄúPVS as a service‚Äù in the cloud and sell access to it in time.  But they went their own way and made a cut-down version for relatively little money (such a budget is quite realistic to ‚Äúbreak through‚Äù or even buy just for yourself). <br><br>  Let's see if the game is worth the candle. <br><a name="habracut"></a><br><br>  The first thing that I don‚Äôt like at once during installation is the lack of integration with Visual Studio 2005 \ 2008.  No, I understand that the old versions of the studio had a completely different API for extensions and maybe additional efforts are needed to support it, but the C ++ language is not at all young, many of the projects I meet still live on VS2008 and nobody does not plan to migrate them, if necessary, about a dozen lines of edits per quarter.  So, to work with legacy, a full-fledged PVS-Studio is still needed.  Well, OK. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The minimalism in integration with Visual Studio pleases: a menu for a couple of points, one toolbar - nothing superfluous.  The ‚ÄúEnable Analysis on Build‚Äù checkbox is turned on by default.  What for?  It seems to me more logical not to slow down the speed of each build, but to make an analysis of the entire project, for example, before committing to the repository.  You can make yourself a reminder on the pre-commit svn \ git clients hook that it would be nice to check the new code with a static analyzer. <br><br>  For the objectivity of the tests, I chose three projects: <br><ul><li>  <a href="http://notepad-plus-plus.org/">Notepad ++</a> (which I <a href="http://habrahabr.ru/company/infopulse/blog/185144/">consider to be a</a> sample of bad code) </li><li>  <a href="http://zeromq.org/">ZeroMQ</a> (which I consider to be a sample of good code) </li><li>  One of my old work projects was written by me many years ago, surely there are a lot of silly mistakes in it. </li></ul><br><br>  Notepad ++ and ZeroMQ were chosen because I had little experience in developing both - literally a couple of patches here and there, but at least I don‚Äôt have to figure out how to compile and test (I knew exactly about the possibility of building under VS2010). <br><br><h4>  Notepad ++ </h4><br>  86 files in the project, 2 minutes for a full scan.  48 reports of suspicious code from CppCat (an average of 0.55 messages per file) <br><br><div class="spoiler">  <b class="spoiler_title">A common mistake - in an attempt to transfer bytes, the logical 'and' and bitwise 'and' are confused.</b> <div class="spoiler_text"><pre><code class="cpp hljs">ToAscii(wParam,(lParam &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) &amp;&amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>,keys,&amp;dwReturnedValue,<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// V560. A part of conditional expression is always true/false.</span></span></code> </pre> </div></div><br><br><div class="spoiler">  <b class="spoiler_title">Check of unsigned type for negativity</b> <div class="spoiler_text"><pre> <code class="cpp hljs">WPARAM wParam ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(wParam&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// V547. Expression is always true/false.</span></span></code> </pre></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Potential addressing of an array cell with index '-1'</b> <div class="spoiler_text"><pre> <code class="cpp hljs">j=lstrlen(BGHS[SelfIndex].editstring); BGHS[SelfIndex].editstring[j<span class="hljs-number"><span class="hljs-number">-1</span></span>]=<span class="hljs-number"><span class="hljs-number">0x00</span></span>; <span class="hljs-comment"><span class="hljs-comment">// V557. Array overrun is possible.</span></span></code> </pre><br>  It‚Äôs not at all a fact that this is a mistake - it‚Äôs possible to check the string for emptiness before that, but it seems to me better not to hope for a chance. <br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Double assignment</b>  <b class="spoiler_title">One thing is clearly superfluous.</b> <div class="spoiler_text"><pre> <code class="cpp hljs">lpcs = &amp;cs; lpcs = (LPCREATESTRUCT)lParam; <span class="hljs-comment"><span class="hljs-comment">// V519. The 'x' variable is assigned values twice successively. Perhaps this is a mistake.</span></span></code> </pre></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Nonsense in building conditions.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(MATCH) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> returnvalue+MAX_GRIDS; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!MATCH)) <span class="hljs-comment"><span class="hljs-comment">// V560. A part of conditional expression is always true/false. { return -1; }</span></span></code> </pre></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Incorrect check for correctly allocated memory</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *source = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[docLength]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-comment"><span class="hljs-comment">// V668. There is no sense in testing the pointer against null, as the memory was allocated using the 'new' operator. The exception will be generated in the case of memory allocation error. return;</span></span></code> </pre><br>  According to my personal statistics - the most common error in any code in C ++ (this project occurs 24 times).  Roots to C memory allocation functions that returned NULL on error.  But when using the new operator in C ++, in order to check ‚Äúdid the available memory run out?‚Äù, You need to catch the exception std :: bad_alloc, and not check the result for NULL. <br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Extra paranoia</b> <div class="spoiler_text"><pre> <code class="cpp hljs">TCHAR intStr[<span class="hljs-number"><span class="hljs-number">5</span></span>]; ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!intStr) <span class="hljs-comment"><span class="hljs-comment">// V600. Consider inspecting the condition. The 'Foo' pointer is always not equal to NULL.</span></span></code> </pre><br>  If in the program it comes to the fact that the pointer to a locally declared array of five characters becomes NULL - something went so bad that it was better to just fall. <br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Double check of the same condition</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(openFound.success &amp;&amp; (styleAt == SCE_H_DOUBLESTRING || styleAt == SCE_H_DOUBLESTRING) &amp;&amp; searchStartPoint &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  They tried to find quotes (double and single), but in fact double check doubles.  Kopipasta with a plan to replace the second check on SCE_H_SINGLESTRING, which was forgotten in the process.  One of the most useful bugs found is really a bug in the XML parser, and not just an ‚Äúimprovement tip‚Äù. <br></div></div><br><br><h5>  False (in my opinion) operation </h5><br>  Two consecutive if blocks with the same condition <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Setup GUI if (!_beforeSpecialView.isPostIt) // V581. The conditional expressions of the 'if' operators situated alongside each other are identical. { ... } //Set old style if not fullscreen if (!_beforeSpecialView.isPostIt) { ... }</span></span></code> </pre><br><br>  Here I disagree with CppCat.  Who knows why the programmer decided to write like this?  The code is valid, it works well.  It can not be a mistake "forgot to remove!", Because otherwise there would have been "else."  Just a design code. <br><br>  A few errors of "Priority of the '&amp;&amp;' operation is higher than that of the '||  operation <br><pre> <code class="cpp hljs">printPage = (!(_pdlg.Flags &amp; PD_PAGENUMS) || (pageNum &gt;= _pdlg.nFromPage) &amp;&amp; (pageNum &lt;= _pdlg.nToPage));</code> </pre><br><br>  CppCat stubbornly believes that programmers do not know the priorities of operations.  In this case, both by meaning and by hyphenation, it is clear that the programmer knew what he was doing.  Of course, ‚Äúexplicit is better than implicit,‚Äù but there are no mistakes here. <br><br>  The analyzer does not assume that meaningless code can make sense with other compilation keys. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unicodeSupported) ::DispatchMessageW(&amp;msg); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">// V523. The 'then' statement is equivalent to the 'else' statement ::DispatchMessage(&amp;msg);</span></span></code> </pre><br><br>  This is because "#define DispatchMessage DispatchMessageW" is previously written.  But after all, what's the matter - this replacement is enabled by conditional compilation macros.  In this case, the code really does not make sense, but if the project is compiled with other keys, then DispatchMessage will point to DispatchMessageA, which means the code will make sense. <br>  I, of course, find fault with it: it‚Äôs unfair to require the static analyzer to guess ‚Äúwhat else compilation options could there be‚Äù.  But from the programmer to think about it does not hurt. <br><br>  <b>Output by Notepad ++</b> <br>  Of the 48 error messages in my opinion, about 38 really deserve attention and some changes in the code.  Of these, 30 places are obvious bugs, and 8 are useful, but optional stylistic edits.  I regard 10 messages from CppCat as false in the context of code logic.  Overall, not bad. <br><br><h4>  ZeroMq </h4><br>  72 files, 1 minute per analysis. <br><br>  Exactly 1 found suspicious place.  And in fact - false. <br><br><pre> <code class="cpp hljs">rc = pipe_-&gt;write (&amp;probe_msg_); <span class="hljs-comment"><span class="hljs-comment">// zmq_assert (rc) is not applicable here, since it is not a bug. pipe_-&gt;flush (); rc = probe_msg_.close (); // V519. The 'x' variable is assigned values twice successively. Perhaps this is a mistake.</span></span></code> </pre><br><br>  The analyzer is upset by the fact that the poor rc value is not needed by anyone between its first and second assignment.  Yes, not necessary.  But: <br><ol><li>  It is convenient to set breakpoint when debugging and see what it is equal to. </li><li>  There is a comment indicating what was here before (or could be) the rc check.  He also says that this check is definitely not needed. </li></ol><br><br>  The analyzer is not obliged, of course, to read the comments, and therefore does not know why everything is ok here. <br><br>  <b>Conclusions on ZeroMq</b> <br>  Not a single useful message about a suspicious place in the code.  Well, I said from the very beginning that I had a very high opinion about the code of this library. <br><br><h4>  My project </h4><br>  420 files (in 8 subprojects), 9 minutes for analysis, 99 warnings.  On average, it is 0.23 warnings per file. <br><br><div class="spoiler">  <b class="spoiler_title">Stupid mistake in using type std :: list</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CHttpDownloaderBase::GetResponseHeader(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; strHeaderName, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;&amp; listValues) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { listValues.empty(); <span class="hljs-comment"><span class="hljs-comment">// V530. The return value of function 'Foo' is required to be utilized. ...</span></span></code> </pre><br>  The confusion is due to the fact that in some frameworks the empty method of the container type actually clears the container.  But for std :: list, this is just a void check.  Need to replace with clear () <br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Check pointer after the first use</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xml_attr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">xml_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* xml, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *attr)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name = xml-&gt;name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (! xml || ! xml-&gt;attr) <span class="hljs-comment"><span class="hljs-comment">// V595. The pointer was utilized before it was verified against nullptr. return NULL;</span></span></code> </pre></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Undefined behavior</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*(n = ++s + <span class="hljs-built_in"><span class="hljs-built_in">strspn</span></span>(s, XML_WS))) <span class="hljs-comment"><span class="hljs-comment">// V567. Undefined behavior. The variable is modified while being used twice between sequence points. {...}</span></span></code> </pre><br>  In fact, on the C ++ compiler from VS2010 this code works as intended.  But formally, yes, the standard says "indefinite behavior."  Better fix. <br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Notorious operations priorities</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!text[++r] == <span class="hljs-string"><span class="hljs-string">'\\'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// V562. It's odd to compare a bool type value with a value of N. { break; } if (!text[++r] == 'u') // V562. It's odd to compare a bool type value with a value of N. { break; }</span></span></code> </pre><br>  It's simple, the operator "!"  <a href="http://ru.cppreference.com/w/cpp/language/operator_precedence">has higher priority</a> than "==" <br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Pointer arithmetic</b> <div class="spoiler_text"><pre> <code class="cpp hljs">TCHAR *ch = path + lstrlen(path) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// V532. Consider inspecting the statement of '*pointer++' pattern. Probably meant: '(*pointer)++'. while (*ch &amp;&amp; *ch != '\\') *ch--;</span></span></code> </pre><br>  The assumption of CppCat that I might have wanted to change the value on the pointer ‚Äî wrong, I wanted to change the pointer itself.  But there is no less benefit from this message - it indicates an extra operation of taking a value by the pointer - "*".  It is not used here, which means you can just write "ch--" <br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Extra condition</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*p1 != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; *p1 == _T(<span class="hljs-string"><span class="hljs-string">' '</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// V590. Consider inspecting this expression. The expression is excessive or contains a misprint. p1++;</span></span></code> </pre><br>  It's simple - if you compare p1 with a space, then the first check is not needed. <br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Excess operation</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> m_dwInPartPos = <span class="hljs-number"><span class="hljs-number">0</span></span>; m_pcOutData = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; ... m_dwInPartPos = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// V519. The 'x' variable is assigned values twice successively.</span></span></code> </pre></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Not that enum</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == eRT_unk) <span class="hljs-comment"><span class="hljs-comment">// V556. The values of different enum types are compared. return false;</span></span></code> </pre><br>  One of the biggest afflictions of C ++ (well, at least before the <a href="http://www.cprogramming.com/c%2B%2B11/c%2B%2B11-nullptr-strongly-typed-enum-class.html">enum classes</a> appears in the new standard) is that enum is actually not a separate entity, but a set of numbers.  Having eRt_unk in one enum, and in the second - eResourceUnknown, I was just lucky that they both were equal to 0. The error was in the code for years, although everything was pure luck and it worked. <br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">So where do without the classics of the genre: = instead of == in comparison</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scheme == ZLIB_COMPRESSION) out.push(boost::iostreams::zlib_compressor()); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scheme = GZIP_COMPRESSION) out.push(boost::iostreams::gzip_compressor()); <span class="hljs-comment"><span class="hljs-comment">// V559. Suspicious assignment inside the condition expression of 'if/while/for' operator.</span></span></code> </pre><br>  Well, what can I say - a stupid mistake, no excuses. <br></div></div><br><br><h5>  False alarms </h5><br><br><h6>  Array bounds </h6><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = lstrlen(szLogDir); TCHAR ch = szLogDir[len<span class="hljs-number"><span class="hljs-number">-1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// V557. Array overrun is possible.</span></span></code> </pre><br>  Indeed, the variable len is not checked for "&gt; 0", but just above the code, the szLogDir string itself is checked for non-emptiness.  The second check will not add reliability. <br><br><h5>  Suspicious failures </h5><br>  I found such a piece in my code: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_packets[i] != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> m_packets[i];</code> </pre><br><br>  CppCat did not say anything about it, although, in my opinion, PVS-Studio in such cases said that deleting NULL is safe. <br><br>  <b>Conclusion on my project</b> <br>  Of the 99 warnings, about 65 were in the case, the distribution of bugs and simply "improving" code is somewhere around 50/50. <br><br><h4>  findings </h4><br><h5>  pros </h5><br><ul><li>  Simplicity </li><li>  Price </li><li>  Finds real bugs </li></ul><br><h5>  Minuses </h5><br><ul><li>  Lack of integration with VS2005 \ VS2008 </li><li>  A certain percentage of false positives </li></ul><br><br><h5>  It could be a minus, but no! </h5><br><h6>  Lack of support for 64-bit checks. </h6><br>  I have never understood why the developers of PVS-Studio have always focused on them so much.  Under Windows x64, 32-bit program assemblies work, and accordingly, the issue of creating a 64-bit version becomes more common either when you need to write a driver, or when a program needs more than 3 GB of RAM.  In my statistics it is about 10-15% of projects. <br><br><h6>  Lack of integration with MsBuild, etc. </h6><br>  It seems logical for me to check the code manually, before committing to the repository.  Not with every build (slow), not on the build server (not interactive), but like this.  Time is running out a lot, before colleagues do not disgrace - it is convenient. <br><br><h5>  Could be a plus, but no! </h5><br><h6>  Austerity in the settings </h6><br>  CppCat turned out very severe.  Not enough flexibility: you can exclude from the scan files, folders, a specific line of the file.  But how to exclude part of the file?  How to disable checking for a specific error or class of errors?  And if not also globally, but for part of the files?  This is either impossible, or I have read little documentation. <br><br><h4>  Wishlist </h4><br><h5>  Hotel 1 </h5><br>  It would be cool to be able to store information about warnings excluded from checking not in the comments to the code, but somewhere in an external file that could be excluded from the commit in the repository.  Not all colleagues can use the same static analysis tool, and reading comments like "// - V: is_test_ok &amp; =: 501" in the code and can be annoyed by their purpose. <br><br><h5>  Hotel 2 </h5><br>  It would be nice to add the item ‚ÄúCopy‚Äù to the context menu of the warning, well, hot key Ctrl + V.  It would be very convenient to copy-paste these warnings into the text of the comment to the commit to the repository.  Now you can, of course, open the documentation and copy the title from there - but there the text is generalized, and the test results indicate specific lines in the code, the names of the variables are convenient and understandable. <br><br><h4>  Final conclusions </h4><br>  What is good about CppCat is the simplicity of calculating whether a purchase tool is worth it.  Let's take the average salary of the average C ++ programmer in a vacuum from a review recently <a href="http://www.luxoft-personnel.ru/press/research/itanalysisrussia/">run</a> on Habr√©: 80,000 rubles ($ 2,370).  So 1 hour of his work costs about $ 14.  I think you will agree that finding and correcting a bug similar to the one described above (and even if you do not know exactly what you are looking for) is at least an hour of work.  The cost of CppCat is $ 250.  It's like 17 hours of work.  If in your project you plan to spend on bugfixing for more than 17 hours (and what, are there projects where you plan less?), Then the purchase is justified. <br><br>  In general, thanks to the authors of CppCat for taking care of small projects and individual developers.  I hope for the implementation of "hotelok" and integration with VS2008. </div><p>Source: <a href="https://habr.com/ru/post/209984/">https://habr.com/ru/post/209984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../209970/index.html">SELinux - description and features of working with the system. Part 2</a></li>
<li><a href="../209972/index.html">How I started working on Odesk and Elance</a></li>
<li><a href="../209974/index.html">Vkontakte presented SDK for Android</a></li>
<li><a href="../209976/index.html">Cooper Journal: Your flat design is convenient for only one of us.</a></li>
<li><a href="../209982/index.html">Gartner Report: PaaS Market Leaders for Enterprise Applications</a></li>
<li><a href="../209986/index.html">University timetable s01e03: season finale</a></li>
<li><a href="../209990/index.html">Creating a tweak on the example of the Phone application. Yes, it will be a plus!</a></li>
<li><a href="../209994/index.html">Gravity Beads</a></li>
<li><a href="../209996/index.html">What are the topics of letters working by the sweat</a></li>
<li><a href="../209998/index.html">Do electric cars dream of cars?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>