<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>.NET development: nine questions for adults</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=".NET becomes truly cross-platform: after a long wait, the release date of ASP.NET Core is finally announced, JetBrains is preparing an alternative to ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>.NET development: nine questions for adults</h1><div class="post__text post__text-html js-mediator-article">  .NET becomes truly cross-platform: after a long wait, the release date of ASP.NET Core is finally announced, JetBrains is preparing an alternative to Visual Studio based on ReSharper and IDEA, Microsoft acquired Xamarin, made the Xamarin Community free, and Mono transferred to the MIT license and finally, Windows Server 2016 will receive support for Windows containers in Docker. <br><br>  With new opportunities we face new challenges: <br><ul><li>  How will the same code work under .NET Core and Mono, on Windows and Linux, in a docker container? </li><li>  Should I switch to .NET Core now and how to get the most out of the new platform? </li><li>  What are the prospects for Mono and Xamarin? </li><li>  What changes have occurred "under the hood". NET with the transition to Roslyn and. NET Core? </li></ul><br>  In just three weeks, at the <a href="http://dotnext.ru/spb/">DotNext</a> conference in St. Petersburg, 20 speakers will <a href="http://dotnext.ru/spb/">give</a> presentations on the present and future of the .NET platform, on optimizing performance and multithreading, on the internal structure of the .NET platform and the CLR, on profiling and debugging the .NET code. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/8f3/c88/9ab/8f3c889ab9d24c53a440c47c3fd77f5c.jpg"></div><br>  In the meantime, we asked four of them to share their experiences and opinions about future changes in the world of .NET.  Our questions were answered: <br><br><ul><li>  The world's leading .NET platform performance expert, <a href="https://mvp.microsoft.com/en-us/PublicProfile/4025213">eight-time</a> Microsoft MVP, the author of the excellent .NET performance book Pro .NET Performance, <b>Sasha Goldstein</b> ; </li><li>  The main developer of the protocol for reactive multiprocess communication in Rider <b>Dmitry Ivanov</b> from JetBrains; </li><li>  Another Rider developer from JetBrains, .NET MVP, Ph.D., silver winner of ACM ICPC, postdoc at the Weizmann Institute of Science <b>Andrei Akinshin</b> ; </li><li>  CTO Promarket and <b>Nikita Tsukanov,</b> an expert in Mono and Linux. </li></ul><a name="habracut"></a><br><blockquote><h2><img src="https://habrastorage.org/files/c10/684/f78/c10684f7823f4d2faa4cded4ad981071.png">  What has changed in .NET with the transition to Roslyn? </h2></blockquote><br><img src="https://habrastorage.org/files/535/efe/112/535efe11293a4c6ca87796ceb6143178.jpg" align="left" height="150">  <b>Sasha Goldstein</b> <br>  For Microsoft, Roslyn is a project of immense importance.  Almost everyone in the C # team has been working on it for seven years, and probably they couldn‚Äôt release it for a very long time.  And now he is on github in open-source and the whole process of language changes is before his eyes.  On the one hand, many people came up with strange ideas to add constructions from other languages ‚Äã‚Äãto C #, on the other hand, the whole process takes place openly and in two hours you can answer any question to three people who write the compiler.  For the community, it's very cool. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/9a0/922/6e9/9a09226e950a4534bd9da7958f09b537.jpg" align="right" height="150">  <b>Andrey Akinshin</b> <br>  Overall I like Roslyn very much.  As a compiler, it is better than the old one: it compiles many code sections more competently and more successfully in terms of performance.  But if we are talking about compiling C # code, then I‚Äôm more interested in the next step: JIT compilation.  Not so long ago, Microsoft introduced a new 64-bit JIT compiler called RyuJIT. <br><br>  One of its main objectives is to reduce JIT compilation time.  We give the user a very quick start, but because of this we can‚Äôt do cool optimizations, so the code itself runs slower than it could, and sometimes even slower than the old JIT.  At the same time, RyuJIT is able to use SSE and AVX instructions well, which allows, with due diligence, to implement highly effective programs using the power of one C # without referring to native code. <br><br>  In terms of performance, it seems to me, Microsoft is betting on another technology that is now actively developing: .NET Native.  While it is still in a very raw state, but it looks promising. <br><br><img src="https://habrastorage.org/files/3a2/e5c/b3f/3a2e5cb3f238454ab7d5c385b99aae57.png" align="left" height="150">  <b>Nikita Tsukanov</b> <br>  The main feature of Roslyn is that Microsoft can now add new features with acceptable speed.  There used to be one compiler for the build, the other for the studio.  Now this is not - there is only one compiler left and it is written in C #. <br><br><img src="https://habrastorage.org/files/eac/615/b82/eac615b8289e4f9fbcf74a0f39f56eb5.png" align="right" height="150">  <b>Dmitry Ivanov</b> <br>  From the point of view of the API, it has certainly become better, but there are problems with performance and excess memory, and they are far from being resolved.  Now we cannot open huge projects in Visual Studio 2015 together with ReSharper, because there is not enough memory. <br><br><blockquote><h2><img src="https://habrastorage.org/files/c10/684/f78/c10684f7823f4d2faa4cded4ad981071.png">  Can you compare Mono with .NET Core?  What are the perspectives of both? </h2></blockquote><br>  <b>Sasha Goldstein</b> <br>  Mono moves to MIT license.  So Microsoft will be able to copy pieces of Mono to CoreFx and use them.  It seems to me that Mono should slowly fade away.  Mono will have some niches on which .NET Core will not work yet.  But Mono's runtime itself is so-so: GC only recently switched to Generational GC, JIT doesn't work very well.  And the framework itself, which they wrote in many cases is not production-ready: there are a lot of bugs, bugs are detected and not repaired for a long time.  Almost all my clients who used Mono in production faced problems.  This does not mean that in the end the system did not work at all, but this is not the level of quality we are used to in .NET. <br><br>  But with .NET Core, too, everything is not smooth.  The project was supposed to end in January, then in March, just a few days ago, they said that it would be ready at the end of June.  API, project model, half the code is constantly changing. <br><br>  Last week, one of the clients with a project on ASP.NET MVC 6 asked how I thought it was necessary to repair the code every two weeks or it was better to backport to ASP.NET MVC 5 and wait.  The question is not simple. <br><br>  <b>Andrey Akinshin</b> <br>  .NET Core is certainly a very interesting project, a big step forward, but today it is still raw.  Let's not forget that many libraries have not yet come out under it or are in RC.  Plus, Microsoft constantly renames something, every day everything changes, some bugs are repaired, others are added.  For two years, a new project system was developed and promoted on the basis of project.json files, and just recently it was thrown into the dustbin and decided to return to the good old csproj.  Such situations discourage a desire in the foreseeable future to try to transfer the production system to the .NET Core. <br><br>  Mono has been in development for over 15 years.  This is an adult, solid runtime, which runs a lot of production-code.  For example, I am working on a project Rider (cross-platform .NET IDE) in JetBrains.  Backend Rider (this is R # in its pure form) was launched under Mono, and under .NET Core it‚Äôs not really possible to launch.  It works quite well: a healthy application from hundreds of projects and very nontrivial logic, with all the features of .NET and all this under * nix starts up normally.  There are, of course, their own problems, but they are completely resolved in working order.  And about the transition to .NET Core: you need to wait for this new cross-platform runtime to become more stable. <br><br>  <b>Nikita Tsukanov</b> <br>  Mono is a fairly mature environment, and .NET Core is still in beta and by the number of available libraries. NET Core is definitely losing.  For example, in .NET Core there is currently no support for System.Drawing, and in Mono it appeared in the 2000th shaggy year. <br><br>  Regarding the performance and quality of the .NET Framework coverage, Mono actively brings to itself those pieces that Microsoft opens.  Given that Microsoft acquired Xamarin, the process should go even faster.  At some point, Mono will become an add-on over .NET Core, but for now it makes sense to use Mono. <br><br>  <b>Dmitry Ivanov</b> <br>  We probably almost all have an opinion that Mono at some point will drop.  At one time, Oracle also said that it would merge the HotSpot JVM with JRockit, but in the end it dropped the last one. <br><br>  So, probably, it is worth waiting a bit, and switching from Mono to .NET Core.  We in Rider work a lot with Mono and see that there are a lot of errors and the code is much lower quality than in the .NET Framework. <br><br><blockquote><h2><img src="https://habrastorage.org/files/c10/684/f78/c10684f7823f4d2faa4cded4ad981071.png">  Do you often have to come up with something unique and unique in the field of high-performance solutions or do you have good ready-made libraries? </h2></blockquote><br>  <b>Andrey Akinshin</b> <br>  I believe that there is no silver bullet, there are no universal libraries that suit everyone.  It is necessary to select a solution for your task.  If you work with a database, there are databases that work faster than others on certain indicators; if you work with graphics, there are various good libraries for rendering 2D / 3D, but each is good for its own spectrum of tasks.  It must be remembered that each project is unique in its own way.  Most often, some solutions are suitable for some solutions, for others - others. <br><br>  A very popular mistake: a person has heard that the ABC library is good, it takes and uses it, without thinking about what tasks it is intended for, on what scenarios it behaves quickly ... <br><br>  An important point: many people bother with performance and spend a lot of time optimizing non-essential sections of code.  There will be some speed increase from this, but no one can notice it.  When we want to improve performance, we need to conduct research, do benchmarks, and profile. <br><br>  <b>Dmitry Ivanov</b> <br>  Even within one .NET-team, we have several solutions for interprocess communication, so yes, we have to often.  Now, high-performance solutions usually mean some kind of server load. <br><br>  If we talk about performance problems on one machine, it is also constantly being solved, because, let's say, we quickly go beyond the framework of the idiomatic C # code.  Pretty quickly, you have to switch from a large number of references to arrays, so go to unsafe.  Without this, it simply does not work.  And we do our protocol in the Rider Framework with an eye on high performance. <br><br><blockquote><h2><img src="https://habrastorage.org/files/c10/684/f78/c10684f7823f4d2faa4cded4ad981071.png">  What is the main difficulty of multithreaded programming on .NET?  What is the main challenge? </h2></blockquote><br>  <b>Sasha Goldstein</b> <br>  Many developers find it difficult to imagine what exactly is happening in a multi-threaded program, that memory accesses can be moved, what to synchronize, on the other hand, if there is a lot of synchronization, bottlenecks appear.  There are many tools for this, but you need to know and be able to use them. <br><br>  Many developers do not have access to multiprocessor systems.  When the same code is executed not on Core i7, but on the server, at least with 64 processors, completely different problems appear.  Some small lock, which took 2% of the time, suddenly starts to occupy 50%, there are problems with the memory bandwidth (the memory system is not able to respond to requests quickly enough), not efficient use of the cache.  .NET-developers most often do not even face such tasks. <br><br>  <b>Andrey Akinshin</b> <br>  I think that the complexity of multithreaded programming on .NET is the same as on any other platform.  You need to understand well how a multi-threaded world works.  As for the synchronization primitives and concurrent data structures, everything is fine with .NET.  Plus in C # 5 appeared async / await, which allow you to write multi-threaded code in a beautiful and understandable. <br><br>  <b>Nikita Tsukanov</b> <br>  There is no way to prevent one stream from being able to access data that is in the possession of another.  In Rust, for this purpose, a more or less normal system was made (destructive assignment).  In .NET there is no such thing and without it is very hard: it may happen that when we transfer something from one stream to another, due to carelessness or other reasons, something superfluous may pass to another stream.  And with ‚Äúthis superfluous‚Äù they can start working, although the stream owner knows nothing about this.  In this case, competitive write requests occur where no one knows.  As the project grows, it becomes more and more difficult to track and deal with it. <br><br>  <b>Dmitry Ivanov</b> <br>  Good question.  I have been programming multithreaded for so many years and telling people how to do it, but I haven't figured it out myself.  Probably, the main challenge arises at the top level - to come up with a model that is successfully suited for a large development team and a large product and get everyone to follow it and hope that you will never rest against the limitations of this model. <br><br>  The Roslyn team decided to use the transactional model of multi-threaded interaction, and they came up against Memory Wall.  We are faced with pessimistic locks and a read / write lock-model facing a long time not releasing the read lock and not a smooth taiping. <br><br>  There is no silver bullet; even new-minded actors do not save: Hello World works well for them, but in reality everything is more complicated. <br><br><blockquote><h2><img src="https://habrastorage.org/files/c10/684/f78/c10684f7823f4d2faa4cded4ad981071.png">  Do low-level details need to be understood in order to write high-performance code or do modern frameworks eliminate this need? </h2></blockquote><br>  <b>Sasha Goldstein</b> <br>  Do not save, you need.  The only question is how much is needed.  Do I have to be able to read an assembler, understand the memory model, how does the processor work?  Standard tip - understand at least one level below the one you work at.  If you are working on .NET you should understand how the OS works, Runtime, GC, Framework.  Without it, even if you find a problem, you will not know how to fix it. <br><br>  <b>Andrey Akinshin</b> <br>  Depends on what tasks the programmer solves.  90% of the time, until there is a task to squeeze the maximum out of the machine, the programmer should think about the code to be reliable, readable, without bugs.  In the remaining 10% of cases, when problems have arisen (or we guess that problems will clearly arise), and we try to solve them, then yes, you need to know how everything happens inside. <br><br>  Many people try to solve performance problems without understanding what is happening in this life: they do wrong benchmarks, crookedly profile, write strange code, which only slows down everything and spend a lot of working time on it.  To successfully cope with these 10% performance-critical cases, you need to know a lot about how things work inside. <br><br>  <b>Nikita Tsukanov</b> <br>  The problem of abstractions is that they have a tendency to flow, so the team needs one person who understands how everything works inside.  Roughly with a man who knows math well.  Traditional low-level problems are memory leaks, exceptions in the native code, heap corruption. <br><br>  <b>Dmitry Ivanov</b> <br>  In my opinion, any .NET-engineer, should at least understand how the processor and processor caches work, be a little bit aware of how branch prediction works and understand why sequential access to an array and a disk always works faster than parallel. <br><br><blockquote><h2><img src="https://habrastorage.org/files/c10/684/f78/c10684f7823f4d2faa4cded4ad981071.png">  What to do if "slows down"?  What are the first 2-3 steps? </h2></blockquote><br>  <b>Sasha Goldstein</b> <br>  No need to guess.  You need to run the tool and get information about what is happening in the process.  Look at the memory, CPU, how many threads, what they do.  Now there are a lot of free utilities.  After that there are a bunch of methods.  My favorite is USE (utilization, saturation, errors).  He came up with Brandon Greg (Brendan Gregg) - an expert on performance in Linux.  Utilization means that we have to determine for each resource (CPU, memory, disk ...) how much it is used.  Saturation means that for all these resources we must determine if there is an over subscription, for example, whether we read 30 files from one disk at a time.  Errors - the number of errors in the program.  After that, you can optimize something: we will add processors or code to improve.  This is in general. <br><br>  <b>Andrey Akinshin</b> <br>  The first thing you need to do is poprofilirti and understand what exactly slows down.  A very common mistake is optimization without profiling.  After we have found a bottleneck, the second step is to ask yourself the question: ‚Äúwhy does this section of the code slow down‚Äù?  Here, sometimes you need to have really a lot of knowledge: you need to guess what factors are really important and check only them, otherwise the programmer risks spending a lot of time on the unnecessary work.  And the third step is to fix the problem and carefully check that the program really works faster now (and also that during the optimization nothing broke off). <br><br>  <b>Dmitry Ivanov</b> <br>  The classics recommend taking a profiler, find the bottlenecks and fix them.  But when you have already done this several times, there are no more open bottlenecks and the program cannot be accelerated several times, having fixed a couple of lines.  Sometimes in these cases it is necessary to reconsider the approach, for example, to insert by code Asserts, which make sure that the operations are completed in the allotted time.  And to force each member of the team to correct performance-asserts falling in his area of ‚Äã‚Äãresponsibility.  It is also useful to look at memory traffic and start a fight with it.  Maybe even go to unsafe. <br><br><blockquote><h2><img src="https://habrastorage.org/files/c10/684/f78/c10684f7823f4d2faa4cded4ad981071.png">  What tools are your favorites when searching for Performance-problems? </h2></blockquote><br>  <b>Sasha Goldstein</b> <br>  On Windows, you need to start with Performance Counters.  After that depends on the situation.  A lot of problems can be solved only with PerfView, but it has big problems with visualization.  Visual Studio Profiler is not bad at all, by the way, it has a standalone version.  dotMemory or .NET Memory Profiler‚Äì for memory profiling. <br><br>  <b>Andrey Akinshin</b> <br>  I am the maintainer of the <a href="https://github.com/PerfDotNet/BenchmarkDotNet">BenchmarkDotNet</a> utility.  The latest versions of this library already behave quite consistently and provide ample opportunities for benchmarking.  Alas, many people from the Internet are constantly trying to make their own self-made benchmarks based on Stopwatch and a couple of cycles.  At the same time, they are surrounded at every step by problems that they are unaware of and which are capable of completely spoiling the conclusions from the experiment being conducted.  But this is only part of the trouble: after all, you can miraculously pass by all the rakes and in this particular situation write the correct code, which really measures something useful.  But only every second novice performance engineer launches his benchmarks in DEBUG, because this configuration is selected by default in the studio. <br><br>  Whether it is worth explaining that it can completely spoil the carried-out measurements.  BenchmarkDotNet scolds the user for the debug configuration and the debugger attached in large red letters, complies with the general benchmarking methodology, makes a warm-up, runs each method in different processes several times, allows you to compare different environments, counts the statistics, etc.  A community has now gathered around the project, and the library is becoming a convenient and popular tool for a number of performance studies. <br><br>  As a profiling, I can recommend the products of the company JetBrains: dotMemory and dotTrace.  I often use them, and I really, really like them. <br><br>  <b>Dmitry Ivanov</b> <br>  All our tools: dotTrace, dotMemory.  Almost for everything is enough.  Sometimes you need to look at sys internals utilities. <br><br><blockquote><h2><img src="https://habrastorage.org/files/c10/684/f78/c10684f7823f4d2faa4cded4ad981071.png">  What advise you to read and look at the topic. NET Performance? </h2></blockquote><br>  <b>Sasha Goldstein</b> <br>  There are a lot of materials online, there are my courses on pluralsight, quite a lot of information can be found in the old blogs of Microsoft developers (Rico Mariani, Chris Brue, Vance Morisson).  About books: there is my book <a href="http://www.amazon.com/Pro-NET-Performance-Optimize-Applications/dp/1430244585/ref%3Dsr_1_1%3Fie%3DUTF8%26qid%3D1463134394%26sr%3D8-1%26keywords%3DPro%2B.NET%2BPerformance">Pro .NET Performance</a> , there is a newer book - <a href="http://www.amazon.com/Writing-High-Performance-NET-Code-Watson/dp/0990583430/ref%3Dsr_1_1%3Fie%3DUTF8%26qid%3D1463134437%26sr%3D8-1%26keywords%3DHigh%2BPerformance%2B.NET%2BApplications">Ben Watson ‚ÄúHigh Performance. NET Applications‚Äù</a> .  Also quite interesting written.  Plus, you need to know something and understand about the device .NET.  There is a classic book <a href="http://www.amazon.com/CLR-via-4th-Developer-Reference/dp/0735667454/ref%3Dsr_1_1%3Fie%3DUTF8%26qid%3D1463134483%26sr%3D8-1%26keywords%3DCLR%2Bvia%2BC%2523">CLR via C #</a> .  It is a bit out of date, but some points are simply not mentioned anywhere else, for example, how exceptions and delegates work. <br><br>  <b>Andrey Akinshin</b> <br>  I would go from top to bottom and would not go to the CPU level (as some try to do), if there is no basic knowledge of algorithms, data structures and the platform with which you work.  In .NET you can read the same Richter, to understand how the base classes work and what they are good for.  It is extremely important to understand the device runtime: how does GC work, how do classes differ from structures, what does the JIT compiler look like, etc. <br><br>  Further, it would be good to understand how modern iron works, in particular, Intel processors (at least in general terms).  In this regard, there are many resources on the Internet, but this is often not very simple reading: you cannot read a book in the evening and figure out the details of the CPU device. <br><br>  However, a person who does not specialize in performance, but who works in an enterprise does not need this.  I advise such people to pump the general erudition and broaden their horizons.  In this regard, it is very cool to go to such conferences as DotNext.  I myself love to watch reports on areas that I do not professionally deal with.  In any case, I don‚Äôt have time to thoroughly study all areas of programming, but at least I will have a general idea and will be able to talk on relevant topics with other programmers.  If I have to solve problems related to a new area for me, I will know which sides to start looking at and what to google. <br><br>  <b>Dmitry Ivanov</b> <br>  Go to the report of Sasha Goldstein :) Read his book, and then be sure to work on tasks that require optimization of performance, otherwise the brain simply discards the information as unnecessary. <br><br><blockquote><h2><img src="https://habrastorage.org/files/c10/684/f78/c10684f7823f4d2faa4cded4ad981071.png">  What are you going to talk about on DotNext in St. Petersburg? </h2></blockquote><br>  <b>Sasha Goldstein</b> <br>  I have two reports: about the tool for profiling and about the memory model.  In the <a href="http://dotnext.ru/spb/talks/goldshtein/">first,</a> we will use PerfView.  I have some code samples with performance-problems that we will analyze.  PerfView is a frontend for ETW technology.  About her, by the way, there is another <a href="http://dotnext.ru/spb/talks/shchegrikovich/">report</a> on DotNext.  ETW is a technology with which you can collect logs.  Many components of Windows, .NET, CLR, ASP.NET are written to this log.  And write these logs with very high speed.  PerfView is an effective analysis of ETW: CPU logs, execution time, database access, allocation profiling. <br><br>  <a href="http://dotnext.ru/spb/talks/goldshtein2/">The second report</a> is about memory models.  Memory Model is a ‚Äúscary‚Äù name for all memory operations in all high-level languages.  If the program works in one thread, everything is simple, and if there are many threads, the situation changes.  Writing and reading may not go in the order we specified; the compiler can optimize a part of the memory accesses in general.  The same with processors.  And when the port is made from Intel to ARM, which in all iPhones, androids, or Power PC, which in all cars, a lot of things stop working, because the processor allows itself more. <br><br>  I am going to show several theoretical and practical examples when Intel is working correctly, but on an iPhone it breaks or, when switching from one thread to several, it breaks on Intel, although almost no one, looking at this code, can say that there is any that problem.  After we analyze the subtleties of the Memory Model, we turn to examples of how to build the correct multithreaded code with the correct synchronization. <br><br>  <b>Andrey Akinshin</b> <br>  I will talk about arithmetic.  Many times I have seen how programmers make annoying mistakes in simple arithmetic expressions, make bugs that are then searched for weeks (why does the matte part work incorrectly there?) - simply because they don‚Äôt understand how the numbers with floating point. <br><br>  Even fewer people think about the performance of arithmetic and what simplest metamorphosis can be accomplished with a mathematical formula that would make it work faster. <br><br>  For example, a CPU can parallelize commands that even run in one thread at the hardware level, but for good parallelization you need good code that you need to write correctly.  If we have found a bottleneck and need to optimize the calculations, then it makes sense to apply additional knowledge and conjure a little over the code. <br><br>  <b>Nikita Tsukanov</b> <br>  I plan to talk about Docker as an element of development infrastructure and deployment.  How to quickly and effectively deploy microservices and manage them.  I will also tell you how to run Windows Server Core in Docker. <br><br>  <b>Dmitry Ivanov</b> <br>  Rider is a hybrid of Idea and ReSharper.  We use a common reactive model.  Idea exposes some parameters, R # responds to it and exposes the necessary data for drawing, and this process can be repeated several times. <br><br>  The Rider Framework is a library for reactive interaction between Java and .NET and a model generator from DSL in target languages.  DSL is written in Kotlin, because Kotlin allows for some groovy-style meta-programming, thanks to its syntactic features.  The report will be live-demo. <br><br>  I think my report will be of interest to those who want to bring their application out-of-process and / or are interested in reactive frameworks and the use of a reactive model for a desktop application. <br><br><hr><br>  If you have questions for the <a href="http://dotnext.ru/spb/talks/">speakers</a> , you want to get a dose of hard-core .NET and find out how and how many times the weather changes in St. Petersburg, we are waiting for you on June 3 at the <b><a href="http://dotnext.ru/spb/">DotNext 2016 Piter</a></b> conference. </div><p>Source: <a href="https://habr.com/ru/post/283516/">https://habr.com/ru/post/283516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../283504/index.html">Features of testing technology C / R in Linux</a></li>
<li><a href="../283508/index.html">Introducing the new Intel RealSense SR300 Camera</a></li>
<li><a href="../283510/index.html">Report from Moscow Atlassian Meetup April 20</a></li>
<li><a href="../283512/index.html">How does cross-device advertising work: the complexity and prospects of technology development</a></li>
<li><a href="../283514/index.html">Bushido Mobius: Member Path</a></li>
<li><a href="../283518/index.html">Data on the frontend: a step towards future applications</a></li>
<li><a href="../283520/index.html">JPoint 2016: Faster, higher, more productive</a></li>
<li><a href="../283522/index.html">Multiple dispatch in C #</a></li>
<li><a href="../283526/index.html">35 useful tips for Ludum Dare members</a></li>
<li><a href="../283528/index.html">What makes a programmer a good programmer?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>