<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CGLayout - new automatic layout system in iOS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi Habr! 
 I want to introduce my latest open-source development - CGLayout - the second markup system in iOS after Autolayout, based on restrictions....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>CGLayout - new automatic layout system in iOS</h1><div class="post__text post__text-html js-mediator-article"><p> Hi Habr! <br>  I want to introduce my latest open-source development - <code>CGLayout</code> - the second markup system in iOS after Autolayout, based on restrictions. </p><br><div style="text-align:center;"><img width="300" src="https://habrastorage.org/web/63f/4fe/db9/63f4fedb9a014b1aa1800f2d738eb6c3.png"></div><br><p>  "The next autoloout system ... why? For what?"  - probably you thought. <br>  Indeed, the iOS community has already created quite a few layout libraries, but none have become a truly mass alternative to the manual layout, not to mention Autolayout. </p><br><p>  <code>CGLayout</code> works with abstract entities, which allows you to simultaneously use UIView, CALayer and <code>not rendered</code> objects for building markup.  It also has a single coordinate space, which allows you to build relationships between elements located at different levels of the hierarchy.  Able to work in the background stream, easily cached, easily expanded and much, much more. </p><br><p>  <code>CGLayout</code> functional product that has good prospects for developing into a big project. </p><a name="habracut"></a><br><p>  But initially the goal was commonplace, as usual, just to simplify your life for yourself. <br>  Everyone sometimes has to write a manual layout, either because of the poor Autolayout performance, or because of complex logic.  Therefore, some extensions were constantly written (a la setFrameThatFits, etc.) </p><br><p>  In the process of implementing such extensions, ideas of a more complex order arise, but due to lack of time, as usual, all this remains within the framework of the recording in Trello and there is an eternity hanging there. <br>  But when you finally got to the realization and you do not see the horizon, it delays you, and it is already unrealistic to stop.  Still, I hope the time was not wasted, and my decision will make life easier for someone, if not with the functionality of the framework, then with example code. </p><br><p>  In addition to the story of my decision, I will try to analyze and compare other frameworks, so I think it will not be boring. </p><br><h2 id="sravnenie">  Comparison </h2><br><h3 id="funkcionalnost">  Functionality </h3><br><table><thead><tr><th>  Requirements </th><th>  FlexLayout </th><th>  <abbr title="Asyncdisplaykit">ASDK</abbr> (Texture) </th><th>  LayoutKit </th><th>  Autolayout </th><th>  CGLayout </th></tr></thead><tbody><tr><td>  Performance </td><td>  + </td><td>  + </td><td>  + </td><td>  - </td><td>  + </td></tr><tr><td>  Cacheability </td><td>  + </td><td>  + </td><td>  + </td><td>  <abbr title="Caching is implemented inside the box. Therefore, it can not be used for their own purposes.">+ -</abbr> </td><td>  + </td></tr><tr><td>  Multithreading </td><td>  - </td><td>  + </td><td>  + </td><td>  - </td><td>  + </td></tr><tr><td>  Cross-hierarchy layout </td><td>  - </td><td>  - </td><td>  - </td><td>  + </td><td>  + </td></tr><tr><td>  Support for CALayer and 'not rendered' view </td><td>  - </td><td>  + </td><td>  - </td><td>  - </td><td>  + </td></tr><tr><td>  Extensibility </td><td>  - </td><td>  + </td><td>  + </td><td>  - </td><td>  + </td></tr><tr><td>  Testability </td><td>  + </td><td>  + </td><td>  + </td><td>  + </td><td>  + </td></tr><tr><td>  Declarative </td><td>  + </td><td>  + </td><td>  + </td><td>  + </td><td>  + </td></tr></tbody></table><br><p>  Some indicators may be subjective, because  I have not used these frameworks in production.  If I'm wrong, please correct me. </p><br><h3 id="proizvoditelnost">  Performance </h3><br><p>  For testing we used <a href="https://github.com/lucdion/LayoutFrameworkBenchmark">LayoutFrameworkBenchmark</a> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/web/b72/6e4/6bb/b726e46bbfd541bf9ecfd1b5e34b3743.png"></div><br><p>  AsyncDisplayKit was not added to the chart due to the fact that it was not enabled by the benchmark developer, and ASDK does layout in the background, which is not entirely fair for performance measurements.  Alternatively, see the Pinterest app.  The performance is really impressive there. </p><br><h2 id="analiz">  Analysis </h2><br><p>  There are already a lot of information about many frameworks, I will only share my opinion.  I will speak mainly about the negative aspects, because they are immediately noticeable, and the advantages are described in the framework pages. </p><br><h4 id="layoutkit">  LayoutKit </h4><br><p>  <a href="https://github.com/linkedin/LayoutKit">Github</a> 25 issues </p><br><p>  Not very flexible, requires writing a large amount of code, and a fairly large inclusion of the programmer in the implementation.  I did not find information about using LayoutKit in any other applications besides LinkedIn itself. <br>  Still, it is believed that LayoutKit did not reach its goal, the ribbon in LinkedIn application still slows down. </p><br><p>  Features: </p><br><ul><li>  For each non-standard markup, you need to create a subclass with the implementation of this layout. </li><li>  The core of the system is engaged in the creation of a view and their reuse.  All I twist in a cache that can break referential integrity when using an external link to the view.  And in principle, the view is not available through the public interface. </li><li>  Layout blocks (such as LabelLayout) duplicate a lot of information about the view.  When they are initialized, you need to set default values ‚Äã‚Äã(text, etc.) </li><li>  There is no flexibility in creating relative dependencies between elements. </li></ul><br><h4 id="flexlayout-aka-yogakit">  FlexLayout (aka YogaKit) </h4><br><p>  <a href="https://github.com/lucdion/FlexLayout">Github</a> 65 issues <br>  <a href="https://www.appsight.io/sdk/574513">Appsight</a> </p><br><p>  Provides the ability to do only layout'om.  No other buns, no chips. <br>  Features: </p><br><ul><li>  There is no way to cache the layout.  You can only get the size. </li><li>  Not native implementation.  API is more suitable for cross-platform developers, web developers. </li><li>  Problems with changing the screen size - you have to manually change the size of the layout object and do a recalculation. </li><li>  It requires the creation of extra views when organizing layout-blocks. </li></ul><br><h4 id="asyncdisplaykit-texture">  AsyncDisplayKit (Texture) </h4><br><p>  <a href="https://github.com/texturegroup/texture">Github</a> 200 issues <br>  <a href="https://www.appsight.io/sdk/asyncdisplaykit">Appsight</a> </p><br><p>  Facebook went by creating a thread-safe abstraction of a higher level.  What caused the need to implement the entire stack of UIKit tools.  Heavy library, if you decide to use it, then it will be impossible to abandon it.  But still this is still the most competent and advanced open-source solution. <br>  Features: </p><br><ul><li>  Not compatible with other layout-frameworks, except for the built-in Yoga. </li><li>  Requires the use of ASDisplayNode subclasses.  Essentially excluding working with UIKit.  Having decided to work with ASDK, you can forget about other tools, get used to writing instead of UI ..., AS .... </li><li>  Own implementation of a large number of UIKit mechanisms, which can lead to code obsolescence and large discrepancies with Apple‚Äôs implementation, non-Apple release bugs. </li><li>  Dear support. </li><li>  Little information related to problem solving.  A search on StackOverflow with the string "AsyncDisplayKit" finds 181 matches (for comparison, "UIKit" - 66,550). </li></ul><br><h4 id="cglayout">  CGLayout </h4><br><ul><li>  Use both at the UIView level, and at the CALayer level.  You can combine and limit the view on the position of the layer and vice versa.  Ability to use <code>not rendered</code> objects. </li><li>  Reuse layout specifications for different objects. </li><li>  The ability to create cross-hierarchy dependencies. </li><li>  Strong typing. </li><li>  Cache markup through getting snapshots. </li><li>  Creating custom constraints independent of the environment.  For example, the string limit for the label. </li><li>  Support for layout guides and easy creation of placeholders for view. </li><li>  Supports any available layout (direct, background, cached). </li><li>  Easy integration with UIKit. </li><li>  Easily expandable. </li></ul><br><p>  Current restrictions: </p><br><ul><li>  The programmer needs to think about the sequence when defining the layout and applying constraints. </li><li>  Calculating the UIView markup using the <code>layer</code> property leads to undefined behavior, since the <code>frame</code> in UIView changes implicitly and side effects (such as drawRect, layoutSubviews) are not called.  At the same time, the UIView <code>layer</code> can be used as a restriction for another layer. </li><li>  If you get a snapshot for a frame that is different from the current <code>bounds</code> value in the superview and there are restrictions based on the superview, it can lead to an unexpected result. </li><li>  So far, not very adapted to complex layout with probabilistic limitations. </li><li>  The calculation of the markup with constraints between UIView and CALayer is slow due to the need to convert coordinates with my implementation. </li></ul><br><p>  What is not yet implemented: </p><br><ol><li>  RTL support. </li><li>  Behavior when removing a view from the hierarchy. </li><li>  Support macOS, tvOS. </li><li>  Trait collection support. </li><li>  There are no convenient constructions for marking reused I twist. </li><li>  Dynamic change of the current layout-configuration. </li></ol><br><h1 id="realizaciya-cglayout">  CGLayout implementation </h1><br><p>  <code>CGLayout</code> built on the modern principles of the Swift language. <br>  The implementation of markup management in CGLayout is based on three basic protocols: <code>RectBasedLayout</code> , <code>RectBasedConstraint</code> , <code>LayoutItem</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Terms</b> <div class="spoiler_text"><p>  I will call all entities implementing <code>LayoutItem</code> layout-elements, all other entities are just layout-entities. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Legend</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/309/2ce/6fe/3092ce6fefa0477b9dc2f9fa2b8d0cc0.png"></div></div><br><h3 id="osnovnaya-razmetka">  Main markup </h3><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RectBasedLayout</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">layout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rect: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">inout</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CGRect, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> source: CGRect)</span></span></span></span> }</code> </pre> <br><p>  <code>RectBasedLayout</code> - declares the behavior for changing the markup and defines one method for this, with the possibility of orientation relative to the available space. </p><br><p>  The <code>Layout</code> structure implementing the <code>RectBasedLayout</code> protocol defines complete and sufficient markup for the layout element, i.e.  positioning and dimensions. <br>  Accordingly, the <code>Layout</code> is divided into two elements: alignment <code>Layout.Alignment</code> and filling <code>Layout.Filling</code> .  They in turn consist of horizontal and vertical layouts.  All components implement <code>RectBasedLayout</code> .  That allows you to use layout elements of different levels of complexity for implementing markup.  All entity layouts can easily be extended by your implementations. </p><br><div class="spoiler">  <b class="spoiler_title">Composite Layout Structure:</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/837/aa0/02e/837aa002e22a4ac99ad3837cc10d4102.png"></div></div><br><h3 id="ogranicheniya">  Restrictions </h3><br><p>  All restrictions implement <code>RectBasedConstraint</code> .  If the <code>RectBasedLayout</code> entities define the markup in the available space, then the <code>RectBasedConstraint</code> entities <code>RectBasedConstraint</code> the available space. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RectBasedConstraint</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constrain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sourceRect: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">inout</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CGRect, by rect: CGRect)</span></span></span></span> }</code> </pre> <br><p>  <code>LayoutAnchor</code> contains specific constraints (side, size, etc.) that have abstracted behavior from the environment. <br>  Currently, the main limiters are implemented. </p><br><div class="spoiler">  <b class="spoiler_title">LayoutAnchor Composite Layout:</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/54f/36c/fcc/54f36cfcc1384220952c52ea902e0ad3.png"></div></div><br><h3 id="layout-constraints">  Layout constraints </h3><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LayoutConstraintProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RectBasedConstraint</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isIndependent: <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">layoutItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">is</span></span></span></span><span class="hljs-function"><span class="hljs-params"> object: AnyObject)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constrainRect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> currentSpace: CGRect, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> coordinateSpace: LayoutItem)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGRect</span></span> }</code> </pre> <br><p>  Determine the dependence on the layout element or content (text, picture, etc.).  They are self-contained constraints that contain all the information about the source of the constraint and the constraints used. <br>  <code>LayoutConstraint</code> is a constraint associated with a layout element with a specific set of constraints. <br>  <code>AdjustLayoutConstraint</code> - the constraint associated with the layout element contains size-based constraints.  Available for layout-elements that support the <code>AdjustableLayoutItem</code> protocol. </p><br><h3 id="layout-elementy">  Layout elements </h3><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LayoutItem</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LayoutCoordinateSpace</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> frame: <span class="hljs-type"><span class="hljs-type">CGRect</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bounds: <span class="hljs-type"><span class="hljs-type">CGRect</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> superItem: <span class="hljs-type"><span class="hljs-type">LayoutItem?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } }</code> </pre> <br><p>  It is implemented by classes such as UIView, CALayer, and also <code>not rendered</code> classes.  You can also implement other classes, such as stack view. </p><br><p>  In the framework, there is an implementation of LayoutGuide.  This is an analogue of UILayoutGuide from UIKit, but with the possibility of a layout-element factory.  That allows you to use LayoutGuide as a placeholder, which is quite important in light of the latest design solutions.  In particular, the ViewPlaceholder class was created for these purposes.  It implements the same boot view pattern as a UIViewController.  Therefore, working with him will be very familiar. </p><br><p>  For elements that can calculate their size, the following protocol is declared: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AdjustableLayoutItem</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LayoutItem</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sizeThatFits</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size: CGSize)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGSize</span></span> }</code> </pre> <br><p>  By default, it is implemented only by UIView. </p><br><h3 id="layout-coordinate-space">  Layout coordinate space </h3><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LayoutCoordinateSpace</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(point: CGPoint, to item: LayoutItem)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGPoint</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(point: CGPoint, from item: LayoutItem)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGPoint</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rect: CGRect, to item: LayoutItem)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGRect</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rect: CGRect, from item: LayoutItem)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGRect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bounds: <span class="hljs-type"><span class="hljs-type">CGRect</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> frame: <span class="hljs-type"><span class="hljs-type">CGRect</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } }</code> </pre> <br><p>  The layout system has an integrated coordinate system represented in the form of the <code>LayoutCoordinateSpace</code> protocol. </p><br><p>  It creates a single interface for all layout-elements, while using the basic implementations of each type (UIView, CALayer, UICoordinateSpace + own implementation for cross-conversion). </p><br><h3 id="layout-bloki">  Layout blocks </h3><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LayoutBlockProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentSnapshot: <span class="hljs-type"><span class="hljs-type">LayoutSnapshotProtocol</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">layout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">snapshot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sourceRect: CGRect)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">LayoutSnapshotProtocol</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(snapshot: LayoutSnapshotProtocol)</span></span></span></span> }</code> </pre> <br><p>  Layout-block is a complete and independent unit of the layout.  It defines methods for performing markup, getting / applying snapshot. </p><br><p>  <code>LayoutBlock</code> encapsulates a layout element, its main layout and constraints that implement the LayoutConstraintProtocol. </p><br><p>  The process of updating markup begins with determining the available space using constraints.  It should be borne in mind that the system still solves problems with conflict restrictions and does not prioritize them at all, therefore, one should carefully consider the application of restrictions.  So in general, size-based restrictions (AdjustLayoutConstraint) should be set after position-based restrictions.  The source space is the super space (bounds).  Each constraint changes the available space (cuts, displaces, stretches, etc.).  After the constraints have completed, the resulting space is transferred to the <code>Layout</code> , where the actual markup for the element is calculated. </p><br><p>  <code>LayoutScheme</code> is a block that combines other layout blocks and determines the correct sequence to perform the markup. </p><br><h3 id="layout-snapshot">  Layout snapshot </h3><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LayoutSnapshotProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> snapshotFrame: <span class="hljs-type"><span class="hljs-type">CGRect</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> childSnapshots: [<span class="hljs-type"><span class="hljs-type">LayoutSnapshotProtocol</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } }</code> </pre> <br><p>  <code>LayoutSnapshot</code> is a snapshot presented as a set of frames, preserving the hierarchy of layout elements. </p><br><h3 id="extended">  Extended </h3><br><p>  All extensible elements implement the Extended protocol. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Extended</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">Conformed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> base: Conformed)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Self</span></span> }</code> </pre> <br><p>  Thus, when extending the functionality, you can use the type already defined in <code>CGLayout</code> to build a strongly typed interface. </p><br><h3 id="primer-ispolzovaniya">  Usage example </h3><br><p>  CGLayout is almost the same as manual layout in the sense of building a sequence of frame actualization.  When implementing the markup in CGLayout, the programmer must remember that all restrictions must start with actual frames before starting work, otherwise the result will be unexpected. </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> leftLimit = LayoutAnchor.Left.limit(<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>: .outer) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> topLimit = LayoutAnchor.Top.limit(<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>: .inner) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> heightEqual = LayoutAnchor.Size.height() ... <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> layoutScheme = LayoutScheme(blocks: [ distanceLabel.layoutBlock(with: Layout(x: .center(), y: .bottom(<span class="hljs-number"><span class="hljs-number">50</span></span>), width: .<span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span>(<span class="hljs-number"><span class="hljs-number">70</span></span>), height: .<span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>))), separator1Layer.layoutBlock(with: Layout(alignment: separator1Align, filling: separatorSize), constraints: [distanceLabel.layoutConstraint(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: [leftLimit, topLimit, heightEqual])]) ... ]) ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLayoutSubviews</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { super.viewDidLayoutSubviews() layoutScheme.layout() }</code> </pre> <br><p>  In this example, the separator uses <code>distanceLabel</code> restrictions after the position of this label is determined. </p><br><h1 id="itogi">  Results </h1><br><p>  Autolayout is still the main layout tool due to its stability, good API and powerful support.  But third-party solutions can help solve particular problems, because of their narrow focus or flexibility. </p><br><p>  <code>CGLayout</code> has a not quite familiar logic for describing the layout process, and therefore requires getting used to. <br>  There is still a lot of work to do, but it is a matter of time, while it is already clear that it has a number of advantages that should allow it to occupy its niche in the field of similar systems.  The framework has not yet been tested in production, and you have the opportunity to try it out.  The framework is covered with tests, so big problems should not arise. </p><br><p>  I hope for your active participation in the further development of the framework. </p><br><p>  <a href="https://github.com/k-o-d-e-n/CGLayout">Github repository</a> </p><br><p>  And in the end I would like to ask the habra users: <br>  What are your requirements for layout-systems? <br>  What do you don‚Äôt like most when building your layout? </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/338540/">https://habr.com/ru/post/338540/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338526/index.html">Broadcast from the gamedev conference 4C in St. Petersburg. Second day</a></li>
<li><a href="../338528/index.html">What conferences work and how to go there</a></li>
<li><a href="../338532/index.html">CIS Benchmarks: best practices, guidelines and recommendations for information security</a></li>
<li><a href="../338536/index.html">Automation to collect data on the growth of tables and files of all MS SQL Server databases</a></li>
<li><a href="../338538/index.html">MikroTik - several addresses and several different MAC on one interface</a></li>
<li><a href="../338542/index.html">How does Microsoft try to send mobile mail to itself?</a></li>
<li><a href="../338544/index.html">Creating a sound effects synthesizer from retro games</a></li>
<li><a href="../338548/index.html">How to distinguish birds from flowers. Or flowers from birds</a></li>
<li><a href="../338550/index.html">MVP recommendation system for GitHub weekly</a></li>
<li><a href="../338554/index.html">Visualization of election results in Moscow on a map in Jupyter Notebook</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>