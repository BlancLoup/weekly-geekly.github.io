<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>(Without) dangerous copy elision</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Already a year in my free time I have been drinking something like a mixture of Maven and Spring for C ++. An important part of it is a self-writing s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>(Without) dangerous copy elision</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/de5/c8f/807/de5c8f807c0752f44222ea52faa0ee5c.png"><br><br>  Already a year in my free time I have been drinking something like a mixture of Maven and Spring for C ++.  An important part of it is a self-writing system of <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D0%25BC%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2583%25D0%25BA%25D0%25B0%25D0%25B7%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C">smart pointers</a> .  Why do I need all this - a separate issue.  In this article I want to briefly describe how a seemingly useful feature of C ++ made me doubt the common sense of the Standard. <br><br>  <b>Edited:</b> <br>  I apologize to the Habrasoobshchestvo and Standard.  Literally the next day after sending the article, I realized a gross mistake in my thoughts.  It is better to read the end of the article right away ... and, yes, to <i>copy elision</i> , it turns out that the article is only indirectly relevant. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h3>  1. The problem </h3><br>  Smart pointers for the project were made last summer. <br><br><div class="spoiler">  <b class="spoiler_title">Selected index code and explanations</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_Type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_Holding, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_Access&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DReference</span></span></span><span class="hljs-class"> {</span></span> . . . IDSharedMemoryHolder *_holder; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IDSharedMemoryHolder *inHolder)</span></span></span><span class="hljs-function"> </span></span>{ . . . } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ . . . } . . . ~DReference() { release(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_OtherType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_OtherHolding, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_OtherAccess&gt; DReference( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DReference&lt;T_OtherType, T_OtherHolding, T_OtherAccess&gt; &amp; inLReference) : _holder(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>), _holding(), _access() { retain(inLReference._holder); } . . . }</code> </pre> <br>  We have strategy structures that implement the object storage logic and the object access logic.  We pass their types as template arguments to the smart pointer class.  <i>IDSharedMemoryHolder</i> - object memory access interface.  By calling the <i>retain ()</i> function, the smart pointer begins to own the object (for strong reference <i>++ ref_count</i> ).  By calling <i>release (), the</i> pointer frees the object (for strong reference, <i>--ref_count</i> and deleting an object if <i>ref_count == 0</i> ). <br><br>  <i>I deliberately omitted here the things related to dereferencing and with retain on calls from operators.</i>  <i>The described problem does not concern these moments.</i> <br></div></div><br>  The work of smart pointers was checked by a series of simple tests: ‚Äúthey created an object associated with the pointer ‚Äî assigned a pointer to the pointer ‚Äî looked at the reatin / release to pass correctly‚Äù.  Tests (which now seems very strange) passed.  I translated the code for smart pointers in early January and ... yes, then everything also worked. <br><br>  The problems started a month ago when it was discovered that the memory controlled by smart pointers was deleted ahead of time. <br><br>  Let me explain with a specific example: <br><br><pre> <code class="cpp hljs">DStrongReference&lt;DPlugIn&gt; DPlugInManager::createPlugIn( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DPlugInDescriptor &amp;inDescriptor) { . . . DStrongReference&lt;DPlugIn&gt; thePlugInReference = internalCreatePlugIn(inDescriptor); . . . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> thePlugInReference; } ... DStrongReference&lt;DPlugIn&gt; DPlugInManager::internalCreatePlugIn( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DPlugInDescriptor &amp;inDescriptor) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (IDPlugInStorage *thePlugInStorage : _storages) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (thePlugInStorage-&gt;getPlugInStatus(inDescriptor)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> thePlugInStorage-&gt;createPlugIn(inDescriptor); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DStrongReference&lt;DPlugIn&gt;(); } ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DPlugInStorageImpl</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IDPlugInStorage { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~DPlugInStorageImpl() { } <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> DStrongReference&lt;DPlugIn&gt; createPlugIn( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DPlugInDescriptor &amp;inDescriptor); };</code> </pre><br>  When the <i>DPlugInStorageImpl :: createPlugIn (...)</i> method was called, an object was created that was returned via <i>DStrongReference</i> , after which this smart pointer was returned via the <i>DPlugInManager :: internalCreatePlugIn (...)</i> method to the calling context - the <i>DPlugInManager :: createPlugIn method (...)</i> . <br><br>  So, when the smart pointer returned to the <i>DPlugInManager :: createPlugIn (...)</i> <i>method</i> , <i>thePlugInReference</i> pointed to the remote object.  Obviously, it was the wrong number of retain / release-calls.  Having spent a lot of nerves with debugger in Eclipse (by the way - it is terrible), I spat, and solved the problem in a simple way - I used a log.  I put the output on the calls to the retain and release methods, launched the program ... What did I expect to see?  Here is something (pseudocode): <br><br>  <i>DPlugInStorageImpl :: createPlugIn (...) =&gt; RETAIN</i> <i><br></i>  <i>DPlugInManager :: internalCreatePlugIn (...), return createPlugIn =&gt; RETAIN</i> <i><br></i>  <i>DPlugInStorageImpl :: createPlugIn (...), ~ DStrongReference () =&gt; RELEASE</i> <i><br></i>  <i>DPlugInManager :: createPlugIn (...), thePlugInReference = internalCreatePlugIn (...) =&gt; RETAIN</i> <i><br></i>  <i>DPlugInManager :: internalCreatePlugIn (...), ~ DStrongReference () =&gt; RELEASE</i> <br><br>  Total: <i>ref_count = 1</i> for <i>thePlugInReference</i> .  Everything had to be clear. <br><br>  What I actually saw made me do this (0_0) and spend the next <s>hour and a half</s> five minutes doing all sorts of clean-ups, recompiling, rechecking optimization settings, trying to flush stdout, and so on. <br><br>  <i>DPlugInStorageImpl :: createPlugIn (...) =&gt; RETAIN</i> <i><br></i>  <i>DPlugInManager :: internalCreatePlugIn (...), ~ DStrongReference () =&gt; RELEASE</i> <br><br>  Desperate to solve the problem in the combat code and already suspecting something extremely wrong, I created a small test project. <br><br><h3>  2. Test </h3><br>  Test code: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;stdio.h&gt; class TestClass { private: int _state; public: TestClass(int inState) : _state(inState) { std::cout &lt;&lt; "State based: " &lt;&lt; inState &lt;&lt; std::endl; } TestClass() : _state(1) { std::cout &lt;&lt; "Default" &lt;&lt; std::endl; } TestClass(const TestClass &amp;inObject0) : _state(2) { std::cout &lt;&lt; "Const Copy" &lt;&lt; std::endl; } TestClass(TestClass &amp;inObject0) : _state(3) { std::cout &lt;&lt; "Copy" &lt;&lt; std::endl; } TestClass(const TestClass &amp;&amp;inObject0) : _state(4) { std::cout &lt;&lt; "Const Move" &lt;&lt; std::endl; } TestClass(TestClass &amp;&amp;inObject0) : _state(5) { std::cout &lt;&lt; "Move" &lt;&lt; std::endl; } ~TestClass() { std::cout &lt;&lt; "Destroy" &lt;&lt; std::endl; } void call() { std::cout &lt;&lt; "Call " &lt;&lt; _state &lt;&lt; std::endl; } }; /////////////////////////////////////////////////////////////////////////////// int main() { TestClass theTestObject = TestClass(); theTestObject.call(); fflush(stdout); return 0; }</span></span></span></span></code> </pre><br>  Expected Result: <br><br>  <i>Default</i> <i><br></i>  <i>Const Copy</i> <i><br></i>  <i>Call 1</i> <i><br></i>  <i>Destroy</i> <br><br>  The real result: <br><br>  <i>Default</i> <i><br></i>  <i>Call 1</i> <i><br></i>  <i>Destroy</i> <br><br>  That is, copy-designer was not called.  And only then did I do what had to be done right away.  Googled and found out about <a href="http://en.cppreference.com/w/cpp/language/copy_elision">copy_elision</a> . <br><br><h3>  3. The terrible truth </h3><br>  In a nutshell - any C ++ compiler can, without warning and without any flags, ignore the call to the copy constructor and instead, for example, directly copy the full state of the object.  At the same time, it is impossible to perform any logic in the process of such copying <s>without hacks</s> .  Here it is explicitly stated in the Notes section: " <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25B8%25D1%258F">Elizia</a> copying is the only allowed type of optimization that can have observable side effects", <i>"Copy elision is the only</i> possible side effect. <i>"</i> <br><br>  Optimization is, of course, excellent ... But what if I <i>need</i> to perform some logic in the copy constructor.  For example, for smart pointers?  And that it is still incomprehensible to me, why it was impossible to allow such an optimization to be carried out with <i>-o1</i> if there is no logic in the body of the copy constructor? .. Until now, this is not clear to me. <br><br><h3>  4. Decision </h3><br>  I found two ways to force the compiler to execute logic at the time of constructing class objects: <br><br>  1) Through compilation flags.  Bad way.  Compiler-dependent.  For example, for g ++ you need to set the <i>-fno-elide-constructors</i> flag, and this will either affect the whole project (which is awful), or you have to use the compiler flags settings in the appropriate places push / pop, which clutters the code and makes it less readable (especially with taking into account what you have to do for each compiler). <br><br>  2) Via the <a href="http://en.cppreference.com/w/cpp/language/explicit">explicit</a> keyword.  This is also a bad way, but in my opinion, this is better than using compilation flags. <br>  The explicit qualifier is needed to prevent implicit instantiation of a class through the casting syntax.  That is, in order that instead of <i>MyInt theMyInt = 1,</i> it was necessary to write <i>MyInt theMyInt = MyInt (1)</i> . <br>  If we put this word in front of the copy constructor, we will get a rather amusing ban on implicit type casting - a ban on casting to its type. <br><br>  So for example, the following <br><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;stdio.h&gt; class TestClass { private: int _state; public: TestClass(int inState) : _state(inState) { std::cout &lt;&lt; "State based: " &lt;&lt; inState &lt;&lt; std::endl; } TestClass() : _state(1) { std::cout &lt;&lt; "Default" &lt;&lt; std::endl; } explicit TestClass(const TestClass &amp;inObject0) : _state(2) { std::cout &lt;&lt; "Const Copy" &lt;&lt; std::endl; } } ~TestClass() { std::cout &lt;&lt; "Destroy" &lt;&lt; std::endl; } void call() { std::cout &lt;&lt; "Call " &lt;&lt; _state &lt;&lt; std::endl; } }; /////////////////////////////////////////////////////////////////////////////// int main() { TestClass theTestObject = TestClass(); theTestObject.call(); fflush(stdout); return 0; }</span></span></span></span></code> </pre><br></div></div><br>  I (g ++ 4.6.1) caused an error: <br><br>  <i>error: no matching function for call to 'TestClass :: TestClass (TestClass)'</i> <br><br>  What is even funnier, because of the C ++ syntax, like this: TestClass theTestObject (TestClass ()) won't work either, because this will be considered a declaration of a function pointer and will cause an error: <br><br>  <i>error: request for member 'call' in 'theTestObject', which is of non-class type 'TestClass (TestClass (*) ())'</i> <br><br>  Thus, instead of forcing the compiler to execute the copy constructor, we are forbidden to call this constructor. <br><br>  Fortunately for me, this decision came up.  The fact is that by disabling the copy constructor, I forced the compiler to use the specification of the template constructor with the same template arguments as the current class.  That is, it was not ‚Äúcasting an object to its type,‚Äù but it was ‚Äúcasting to a type that has the same template arguments,‚Äù which generates another method, but replaces the copy constructor. <br><br><div class="spoiler">  <b class="spoiler_title">That's what happened</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_Type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_Holding, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_Access&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DReference</span></span></span><span class="hljs-class"> {</span></span> . . . IDSharedMemoryHolder *_holder; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IDSharedMemoryHolder *inHolder)</span></span></span><span class="hljs-function"> </span></span>{ . . . } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ . . . } . . . ~DReference() { release(); } <span class="hljs-comment"><span class="hljs-comment">//NB: Workaround for Copy elision explicit DReference( const OwnType &amp;inLReference) : _holder(NULL), _holding(), _access() { // Call for some magic cases retain(inLReference._holder); } template&lt;typename T_OtherType, typename T_OtherHolding, typename T_OtherAccess&gt; DReference( const DReference&lt;T_OtherType, T_OtherHolding, T_OtherAccess&gt; &amp; inLReference) : _holder(NULL), _holding(), _access() { retain(inLReference._holder); } . . . }</span></span></code> </pre><br></div></div><br><br>  For a test example, an analogue of this crutch would look like this: <br><br><div class="spoiler">  <b class="spoiler_title">Test code and short explanation</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;stdio.h&gt; class TestClass { private: int _state; public: TestClass(int inState) : _state(inState) { std::cout &lt;&lt; "State based: " &lt;&lt; inState &lt;&lt; std::endl; } TestClass() : _state(1) { std::cout &lt;&lt; "Default" &lt;&lt; std::endl; } explicit TestClass(const TestClass &amp;inObject0) : _state(2) { std::cout &lt;&lt; "Const Copy" &lt;&lt; std::endl; } template&lt;typename T&gt; TestClass(const T &amp;inObject0) : _state(13) { std::cout &lt;&lt; "Template Copy" &lt;&lt; std::endl; } ~TestClass() { std::cout &lt;&lt; "Destroy" &lt;&lt; std::endl; } void call() { std::cout &lt;&lt; "Call " &lt;&lt; _state &lt;&lt; std::endl; } }; /////////////////////////////////////////////////////////////////////////////// int main() { TestClass theTestObject = TestClass(); theTestObject.call(); fflush(stdout); return 0; }</span></span></span></span></code> </pre><br><br>  The same trick.  The specification of the template that replaces the copy constructor ... This shows that this is a bad decision, because we out of place used templates.  If anyone knows how best - accomplish your goal. <br></div></div><br><br><h3>  Instead of conclusion </h3><br>  When I talked about <i>copy elision to</i> several acquaintances who had been in C ++ and C-++ development for about three years, they <s>also did this (0_0)</s> just as much as mine.  Meanwhile, this optimization can generate behavior that is strange from the programmer‚Äôs point of view and cause errors when writing C ++ applications. <br><br>  I hope this article will be useful to someone and save someone's time. <br><br>  <i>PS: Write about the missteps I have noticed - I will rule.</i> <br><br><h2>  <i>Edited:</i> </h2><br><br>  Commenting on the right, I generally misunderstood the problem.  Thanks to everyone, especially <a href="http://habrahabr.ru/users/monnoroch/" class="user_link">Monnoroch</a> for identifying logical errors in the article. <br><br>  Having written the following test code, I got the correct output: <br><br><div class="spoiler">  <b class="spoiler_title">Template class with copy constructor and output</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////// #include &lt;iostream&gt; /////////////////////////////////////////////////////////////////////////////// template&lt;typename T_Type&gt; class TestTemplateClass { private: typedef TestTemplateClass&lt;T_Type&gt; OwnType; T_Type _state; public: TestTemplateClass() : _state() { std::cout &lt;&lt; "Default constructor" &lt;&lt; std::endl; } TestTemplateClass(int inState) : _state(inState) { std::cout &lt;&lt; "State constructor" &lt;&lt; std::endl; } TestTemplateClass(const OwnType &amp;inValue) { std::cout &lt;&lt; "Copy constructor" &lt;&lt; std::endl; } template&lt;typename T_OtherType&gt; TestTemplateClass(const TestTemplateClass&lt;T_OtherType&gt; &amp;inValue) { std::cout &lt;&lt; "Template-copy constructor" &lt;&lt; std::endl; } template&lt;typename T_OtherType&gt; void operator = (const TestTemplateClass&lt;T_OtherType&gt; &amp;inValue) { std::cout &lt;&lt; "Operator" &lt;&lt; std::endl; } ~TestTemplateClass() { std::cout &lt;&lt; "Destructor" &lt;&lt; std::endl; } }; /////////////////////////////////////////////////////////////////////////////// TestTemplateClass&lt;int&gt; createFunction() { return TestTemplateClass&lt;int&gt;(); } /////////////////////////////////////////////////////////////////////////////// int main() { TestTemplateClass&lt;int&gt; theReference = createFunction(); std::cout &lt;&lt; "Finished" &lt;&lt; std::endl; return 0; } ///////////////////////////////////////////////////////////////////////////////</span></span></code> </pre><br><br>  Output: <br><pre> <code class="cpp hljs">Default constructor Copy constructor Destructor Copy constructor Destructor Finished Destructor</code> </pre><br></div></div><br><br>  That is, indeed, the problem was not in <i>copy elision</i> and no hacks are needed. <br><br>  The real mistake turned out to be banal.  Now I am ashamed of the fact that I undertook to write an article without checking everything properly. <br>  The fact is that smart pointers take three template arguments: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_Type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_Holding, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_Access&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DReference</span></span></span><span class="hljs-class"> {</span></span> . . .</code> </pre><br><br><ol><li>  T_Type is an object type that is controlled by a smart pointer system. </li><li>  T_Holding - memory ownership strategy. </li><li>  T_Access is a memory access strategy. </li></ol><br><br>  Such an implementation of smart pointers allows for flexible customization of their behavior, but at the same time makes it cumbersome to use (especially given the fact that strategies are also template classes). <br><br>  Example of a strong pointer declaration: <br><br><pre> <code class="cpp hljs">DReference&lt;MyType, DReferenceStrongHolding&lt;MyType&gt;, DReferenceCachingAccess&lt; MyType &gt; &gt; theReference;</code> </pre><br><br>  To avoid code clutter, I wanted to use the C ++ 11 standard feature - <a href="http://en.cppreference.com/w/cpp/language/type_alias">template-alias</a> .  But as it turned out, g ++ 4.6.1 <a href="https://gcc.gnu.org/projects/cxx0x.html">does not support them</a> .  Of course, when you write your home pet-project, it‚Äôs too lazy to tinker with the environment setup, so I decided to do another workaround and get rid of the argument using inheritance: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_Type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DStrongReference</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DReference&lt; T_Type, DReferenceStrongHolding&lt;MyType&gt;, DReferenceCachingAccess&lt; MyType &gt; &gt; { . . .</code> </pre><br><br>  At the same time, it was necessary to define a bunch of constructors for <i>DStrongReference</i> , which are <i>called</i> from themselves by the corresponding constructors of the base <i>DReference</i> class - after all, constructors are not inherited.  And, of course, I missed the copy designer ... In general, the only advice I can give after all these adventures is that you need to be very careful when using templates in order not to get into such a stupid situation that I got into. <br><br>  PS: Here is a test that uses inheritance to replace template-alias (thanks to <a href="http://habrahabr.ru/users/toshic/" class="user_link">ToSHiC</a> for a <a href="http://habrahabr.ru/users/toshic/" class="user_link">good</a> advice to pass <i>this</i> to output): <br><br><div class="spoiler">  <b class="spoiler_title">Test imitation of template-alias</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////// #include &lt;iostream&gt; /////////////////////////////////////////////////////////////////////////////// template&lt;typename T_Type, typename T_Strategy&gt; class TestTemplateClass { private: typedef TestTemplateClass&lt;T_Type, T_Strategy&gt; OwnType; T_Type _state; T_Strategy _strategy; public: TestTemplateClass() : _state(), _strategy() { std::cout &lt;&lt; "Default constructor: " &lt;&lt; this &lt;&lt; std::endl; } TestTemplateClass(int inState) : _state(inState), _strategy() { std::cout &lt;&lt; "State constructor: " &lt;&lt; this &lt;&lt; std::endl; } TestTemplateClass(const OwnType &amp;inValue) : _state(), _strategy() { std::cout &lt;&lt; "Copy constructor: " &lt;&lt; this &lt;&lt; " from " &lt;&lt; &amp;inValue &lt;&lt; std::endl; } template&lt;typename T_OtherType, typename T_OtherStrategy&gt; TestTemplateClass( const TestTemplateClass&lt;T_OtherType, T_OtherStrategy&gt; &amp;inValue) : _state(), _strategy() { std::cout &lt;&lt; "Template-copy constructor: " &lt;&lt; this &lt;&lt; std::endl; } void operator = (const OwnType &amp;inValue) { std::cout &lt;&lt; "Assigning: " &lt;&lt; this &lt;&lt; " from " &lt;&lt; inValue &lt;&lt; std::endl; } template&lt;typename T_OtherType, typename T_OtherStrategy&gt; void operator = ( const TestTemplateClass&lt;T_OtherType, T_OtherStrategy&gt; &amp;inValue) { std::cout &lt;&lt; "Assigning: " &lt;&lt; this &lt;&lt; " from " &lt;&lt; &amp;inValue &lt;&lt; std::endl; } ~TestTemplateClass() { std::cout &lt;&lt; "Destructor: " &lt;&lt; this &lt;&lt; std::endl; } }; /////////////////////////////////////////////////////////////////////////////// template&lt;typename T_Type&gt; class TestTemplateClassIntStrategy : public TestTemplateClass&lt;T_Type, int&gt; { private: //- Types typedef TestTemplateClassIntStrategy&lt;T_Type&gt; OwnType; typedef TestTemplateClass&lt;T_Type, int&gt; ParentType; public: TestTemplateClassIntStrategy() : ParentType() { } TestTemplateClassIntStrategy(int inState) : ParentType(inState) { } TestTemplateClassIntStrategy(const OwnType &amp;inValue) : ParentType(inValue) { } template&lt;typename T_OtherType, typename T_OtherStrategy&gt; TestTemplateClassIntStrategy( const TestTemplateClass&lt;T_OtherType, T_OtherStrategy&gt; &amp;inValue) : ParentType(inValue) { } //- Operators void operator = (const OwnType &amp;inValue) { ParentType::operator =(inValue); } template&lt;typename T_OtherType, typename T_OtherStrategy&gt; void operator = ( const TestTemplateClass&lt;T_OtherType, T_OtherStrategy&gt; &amp;inValue) { ParentType::operator =(inValue); } }; /////////////////////////////////////////////////////////////////////////////// TestTemplateClassIntStrategy&lt;int&gt; createFunction() { return TestTemplateClassIntStrategy&lt;int&gt;(); } int main() { TestTemplateClassIntStrategy&lt;int&gt; theReference = createFunction(); std::cout &lt;&lt; "Finished" &lt;&lt; std::endl; return 0; }</span></span></code> </pre><br><br>  Output: <br><pre> <code class="cpp hljs">Default constructor: <span class="hljs-number"><span class="hljs-number">0x28fed8</span></span> Copy constructor: <span class="hljs-number"><span class="hljs-number">0x28ff08</span></span> from <span class="hljs-number"><span class="hljs-number">0x28fed8</span></span> Destructor: <span class="hljs-number"><span class="hljs-number">0x28fed8</span></span> Copy constructor: <span class="hljs-number"><span class="hljs-number">0x28ff00</span></span> from <span class="hljs-number"><span class="hljs-number">0x28ff08</span></span> Destructor: <span class="hljs-number"><span class="hljs-number">0x28ff08</span></span> Finished Destructor: <span class="hljs-number"><span class="hljs-number">0x28ff00</span></span></code> </pre><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Call the assignment operator</b> <div class="spoiler_text"><pre> <code class="cpp hljs">. . . <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TestTemplateClassIntStrategy&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; theReference; theReference = createFunction(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Finished"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br><pre> <code class="cpp hljs">Default constructor: <span class="hljs-number"><span class="hljs-number">0x28ff00</span></span> Default constructor: <span class="hljs-number"><span class="hljs-number">0x28fed8</span></span> Copy constructor: <span class="hljs-number"><span class="hljs-number">0x28ff08</span></span> from <span class="hljs-number"><span class="hljs-number">0x28fed8</span></span> Destructor: <span class="hljs-number"><span class="hljs-number">0x28fed8</span></span> Assigning: <span class="hljs-number"><span class="hljs-number">0x28ff00</span></span> from <span class="hljs-number"><span class="hljs-number">0x28ff08</span></span> Destructor: <span class="hljs-number"><span class="hljs-number">0x28ff08</span></span> Finished Destructor: <span class="hljs-number"><span class="hljs-number">0x28ff00</span></span></code> </pre><br></div></div><br><br>  An important disadvantage of this method: if you define a strong-pointer and a weak-pointer in this way, they will be completely different types (not even associated with one template class) and will not leave them to assign one directly to another at the time of initialization. <br><br>  <i>&lt;Edited # 2&gt;</i> <br><br>  Again, hurried to say something.  I understood at night.  It will come out after all ... These classes have one common patterned ancestor. <br>  That is, if the template constructor from an arbitrary <i>DReference</i> is described in the successor (which imitates template-alias), everything will be fine in the following code: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">DStrongReference&lt;Type&gt; theStrongReference; <span class="hljs-comment"><span class="hljs-comment">//           .  : // // template&lt;typename Type, typename Owning, typename Holding&gt; // DWeakReference::DWeakReference(const DReference&lt;Type, Owning, Holding&gt; &amp;ref) : Parent(ref) { } // //       ,  DStrongReference  DReference. // DWeakReference&lt;Type&gt; theWeakReference = theStrongReference;</span></span></code> </pre><br></div></div><br><br>  Test code for two classes organized this way: <br><br><div class="spoiler">  <b class="spoiler_title">template-alias through inheritance: two pseudo-alias</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//============================================================================ // Name : demiurg_application_example.cpp // Author : // Version : // Copyright : Your copyright notice // Description : Hello World in C++, Ansi-style //============================================================================ /////////////////////////////////////////////////////////////////////////////// #include &lt;iostream&gt; /////////////////////////////////////////////////////////////////////////////// template&lt;typename T_Type, typename T_Strategy&gt; class TestTemplateClass { private: typedef TestTemplateClass&lt;T_Type, T_Strategy&gt; OwnType; T_Type _state; T_Strategy _strategy; public: TestTemplateClass() : _state(), _strategy() { std::cout &lt;&lt; "Default constructor: " &lt;&lt; this &lt;&lt; std::endl; } TestTemplateClass(int inState) : _state(inState), _strategy() { std::cout &lt;&lt; "State constructor: " &lt;&lt; this &lt;&lt; std::endl; } TestTemplateClass(const OwnType &amp;inValue) : _state(), _strategy() { std::cout &lt;&lt; "Copy constructor: " &lt;&lt; this &lt;&lt; " from " &lt;&lt; &amp;inValue &lt;&lt; std::endl; } template&lt;typename T_OtherType, typename T_OtherStrategy&gt; TestTemplateClass( const TestTemplateClass&lt;T_OtherType, T_OtherStrategy&gt; &amp;inValue) : _state(), _strategy() { std::cout &lt;&lt; "Template-copy constructor: " &lt;&lt; this &lt;&lt; std::endl; } void operator = (const OwnType &amp;inValue) { std::cout &lt;&lt; "Assigning: " &lt;&lt; this &lt;&lt; " from " &lt;&lt; &amp;inValue &lt;&lt; std::endl; } template&lt;typename T_OtherType, typename T_OtherStrategy&gt; void operator = ( const TestTemplateClass&lt;T_OtherType, T_OtherStrategy&gt; &amp;inValue) { std::cout &lt;&lt; "Assigning: " &lt;&lt; this &lt;&lt; " from " &lt;&lt; &amp;inValue &lt;&lt; std::endl; } ~TestTemplateClass() { std::cout &lt;&lt; "Destructor: " &lt;&lt; this &lt;&lt; std::endl; } }; /////////////////////////////////////////////////////////////////////////////// //- Integer strategy template&lt;typename T_Type&gt; class TestTemplateClassIntStrategy : public TestTemplateClass&lt;T_Type, int&gt; { private: //- Types typedef TestTemplateClassIntStrategy&lt;T_Type&gt; OwnType; typedef TestTemplateClass&lt;T_Type, int&gt; ParentType; public: TestTemplateClassIntStrategy() : ParentType() { } TestTemplateClassIntStrategy(int inState) : ParentType(inState) { } TestTemplateClassIntStrategy(const OwnType &amp;inValue) : ParentType(inValue) { } template&lt;typename T_OtherType, typename T_OtherStrategy&gt; TestTemplateClassIntStrategy( const TestTemplateClass&lt;T_OtherType, T_OtherStrategy&gt; &amp;inValue) : ParentType(inValue) { } //- Operators void operator = (const OwnType &amp;inValue) { ParentType::operator =(inValue); } template&lt;typename T_OtherType, typename T_OtherStrategy&gt; void operator = ( const TestTemplateClass&lt;T_OtherType, T_OtherStrategy&gt; &amp;inValue) { ParentType::operator =(inValue); } }; //- Boolean strategy template&lt;typename T_Type&gt; class TestTemplateClassBoolStrategy : public TestTemplateClass&lt;T_Type, bool&gt; { private: //- Types typedef TestTemplateClassBoolStrategy&lt;T_Type&gt; OwnType; typedef TestTemplateClass&lt;T_Type, bool&gt; ParentType; public: TestTemplateClassBoolStrategy() : ParentType() { } TestTemplateClassBoolStrategy(int inState) : ParentType(inState) { } TestTemplateClassBoolStrategy(const OwnType &amp;inValue) : ParentType(inValue) { } template&lt;typename T_OtherType, typename T_OtherStrategy&gt; TestTemplateClassBoolStrategy( const TestTemplateClass&lt;T_OtherType, T_OtherStrategy&gt; &amp;inValue) : ParentType(inValue) { } //- Operators void operator = (const OwnType &amp;inValue) { ParentType::operator =(inValue); } template&lt;typename T_OtherType, typename T_OtherStrategy&gt; void operator = ( const TestTemplateClass&lt;T_OtherType, T_OtherStrategy&gt; &amp;inValue) { ParentType::operator =(inValue); } }; /////////////////////////////////////////////////////////////////////////////// TestTemplateClassBoolStrategy&lt;int&gt; createFunction() { return TestTemplateClassBoolStrategy&lt;int&gt;(); } int main() { TestTemplateClassIntStrategy&lt;int&gt; theReference; theReference = createFunction(); std::cout &lt;&lt; "Finished" &lt;&lt; std::endl; return 0; }</span></span></code> </pre><br><br>  Output: <br><pre> <code class="cpp hljs">Default constructor: <span class="hljs-number"><span class="hljs-number">0x28fed8</span></span> Copy constructor: <span class="hljs-number"><span class="hljs-number">0x28ff08</span></span> from <span class="hljs-number"><span class="hljs-number">0x28fed8</span></span> Destructor: <span class="hljs-number"><span class="hljs-number">0x28fed8</span></span> Copy constructor: <span class="hljs-number"><span class="hljs-number">0x28ff00</span></span> from <span class="hljs-number"><span class="hljs-number">0x28ff08</span></span> Destructor: <span class="hljs-number"><span class="hljs-number">0x28ff08</span></span> Finished Destructor: <span class="hljs-number"><span class="hljs-number">0x28ff00</span></span></code> </pre><br></div></div><br><br>  In general, everything works <br><br>  <i>&lt;/ Edited number 2&gt;</i> <br><br>  Thanks <a href="http://habrahabr.ru/users/1eqinfinity/" class="user_link">1eqinfinity</a> , <a href="http://habrahabr.ru/users/torvald3d/" class="user_link">Torvald3d</a> for pointing spelling errors. </div><p>Source: <a href="https://habr.com/ru/post/252885/">https://habr.com/ru/post/252885/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../252871/index.html">Calculate the circumference</a></li>
<li><a href="../252875/index.html">Hello from Microsoft: KB3002657 breaks ntlmssp on Windows 2003</a></li>
<li><a href="../252877/index.html">We read the correspondence of Ubank customers with support</a></li>
<li><a href="../252881/index.html">Admin tales: chasing the fragmentation of tunnels in the overlay network</a></li>
<li><a href="../252883/index.html">Creating APK x86 and ARM APK packages using the Intel¬Æ and GNU gcc compiler</a></li>
<li><a href="../252889/index.html">What is WMS?</a></li>
<li><a href="../252893/index.html">Timing for amateur car racing</a></li>
<li><a href="../252895/index.html">Material Design. Was there a boy?</a></li>
<li><a href="../252897/index.html">Creating games without Canvas</a></li>
<li><a href="../252903/index.html">Android A few words about MVP + rxJava</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>