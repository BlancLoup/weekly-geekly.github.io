<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Smart or virtual hardware drivers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The first article about the drivers was really quite introductory, and I thought that it was impossible not to supplement it with a story about how th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Smart or virtual hardware drivers</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://habrahabr.ru/post/282564/">The first article about the drivers</a> was really quite introductory, and I thought that it was impossible not to supplement it with a story about how the drivers of more modern devices are arranged. <br><br>  To begin with, we introduce the definition of bus master: a device capable of being not only a slave, but also a master on a computer bus.  That is, not only to respond to I / O transactions initiated by the processor, but also to initiate them independently ‚Äî on their own initiative to ‚Äúwalk‚Äù into memory. <br><br>  The history of such devices is rooted in the concept of DMA: as early as the time of the microprocessor progenitor, the 8080 microprocessor (KR5080IK80), it was understood that it would be good to unload the processor from the routine operation of drag-and-drop between devices in-in and memory. <br><a name="habracut"></a><br>  The DMA controller (Direct Memory Access) was external to the I / O device subsystem that had to be explicitly programmed ‚Äî set the type of operation (write to memory, read from memory, copy memory, memory), memory address (s), and so on. Actually, I‚Äôm completely unfair writing about it in the past tense - all of this quite exists now, for example, in microcontrollers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Already in DMA mode, the driver‚Äôs operation looks essentially different - the driver is required not to perform I / O, but to prepare the settings for the device, activate it, wait for the interruption after I / O is completed, and check the success of the operation.  Everything said in the previous article is also true for DMA devices, but in addition to the above, the driver must understand the scheme of interaction between the device and the DMA controller, and sometimes explicitly allocate and configure the controller: if in old devices the I / O port was fixed to the DMA controller , now in many cases it is possible to complete the routing or select the DMA channel from 2-4 options. <br><br>  Separately, it should be noted that the initiation of the next I / O transaction itself can be automatic (DMA lupit as fast as possible), automatic with tempo adjustment (so as not to eat the entire bus bandwidth) or upon an event. <br><br>  In this case, an event in the developed systems may be an interruption, simply a change in the state of the microcontroller's leg, or another event may be the source of the event.  For example, a timer.  This allows you to pair together the DAC, DMA engine and timer so that the next byte feed to the DAC will occur at the specified (timer) frequency.  There are other options for the aggregation of devices, for example, the inclusion of one DMA channel at the end of another.  Without attracting the attention of the processor. <br><br>  It is also relevant to say that DMA controllers sometimes are able to explicitly match a pair of channels to ensure continuity of data flow at the end of one channel, the second one is triggered and an interrupt is generated, through which the processor loads the first channel again - this can be vital for the same DAC. <br><br>  Back from the world of controllers in the "adult" cars.  Most modern I / O subsystems are no longer based on external DMA, but have its counterpart right inside. <br><br>  These are devices with the master bus mode, bus master. <br><br>  It is easiest to imagine them as devices that have an in-built, personal and optimally arranged DMA controller. <br><br>  Typically, such devices are controlled through a tree of descriptors in memory: the device has a special register in which the processor places the address of the structure in memory, which contains the task for the controller.  Or, more often, an array or a list of structures with such tasks.  The controller independently reads the tasks from the memory and executes them step by step.  The task, as a rule, consists of the operation identifier, the address in the memory, where to get the data and the additional parameters necessary to perform the operation.  For example: {write to disk, disk address, memory buffer address}.  This is how modern controllers of everything are arranged: disk, USB, network interface. <br><br>  In addition to the structure of the descriptors for such a device, more tools are needed for the exchange of events: the processor must be able to inform that it has changed or added descriptors, and the device ‚Äî that has completed the I / O partially or completely.  The second is executed, of course, through interrupts, and for the first, a register is often used (the doorbell is a doorbell), into which the processor ‚Äúknocks‚Äù to draw the device‚Äôs attention to changes. <br><br>  At the same time there is a danger of changing exactly what the device is processing now, which imposes additional restrictions on the structure of the driver. <br><br>  Separately in this series are virtio devices.  They appeared as a consequence of the victorious procession of hypervisors around the world.  Traditionally, the hypervisor offered the guest OS some set of virtual devices that copied this or that popular physical device.  Known network card or disk controller.  But to emulate an ‚Äúiron‚Äù device is hard, inconvenient, and dreary ‚Äî often, you have to maintain properties that are completely unnecessary in the virtual world, while for the purposes of virtualization, the structure of a real iron device is usually not optimal. <br><br>  This led the authors to design virtual devices that will never (never say ¬© 007) be implemented in hardware and are needed solely for communication between the hypervisor and the guest OS.  They are designed so that for a large number of devices of different types it is possible to implement a common uniform infrastructure, both in the core of the guest OS and in the hypervisor. <br><br>  ( <a href="">View implementation</a> ) <br><br>  In essence, the virtio driver is a packet transport with requests and responses between the guest OS and the hypervisor.  Package contents are specific to the type of driver and its mode.  For example, for a network card, this is the address of the ethernet packet, and for a disk, the scatter-gather descriptor indicating the type of disk operation and the address on the disk. <br><br>  In the virtio drivers, the kernel fills the package and asks the generic vitio driver to "transfer" it to the device.  Now until the device ‚Äútransmits‚Äù the packet back, it is impossible to touch it.  Conversely, if the device is able to do input on the external initiative, it needs to transfer several empty (prepared for reading) packets ‚Äî as data arrives (for example, incoming network messages), the packets will be filled and sent back to the kernel of the guest OS. <br><br>  In addition, the virtio standard supports the ability for the kernel and device to agree on a mode of operation and supported functions in a standard way.  For example, the virtio network driver may or may not be able to read and insert in the sent IP packets a checksum. <br><br>  It is easy to see that the virtio standard describes a fairly typical generalized bus master device driver: we send a request to the device with an address in memory and I / O request parameters, the rest is asynchronous. <br><br>  Against the background of the above, talking about DPC is no longer so relevant, but once a discussion has arisen in the comments, I will give a brief description. <br><br>  In some operating systems (Phantom ‚Äúsketched‚Äù it with NT, from where they sketched - I don‚Äôt know) there is full support for running code inside ‚Äúlight‚Äù threads - Deferred Procedure Call.  This allows you to reduce the time the driver is in the interrupt: the interrupt handler only captures the event and, as a maximum, reads the status from the device - one register.  The rest is done in the DPC, which is quickly activated and completes the job. <br><br>  Frankly, there is not much point in this - it's easier to run its own high-priority thread in the driver and do input-output from it.  However, there may be options.  You can select a DPC priority group and always guarantee their priority is higher than that of the thread.  It is possible to provide super-fast sheduling and transfer the processor directly to the output from the interrupt that this DPC requested, thus reducing latency. <br><br>  Separately, we note that from the DPC can be a lot of what is not possible in the interrupt.  What exactly - depends on the OS.  In the Phantom inside the DPC everything is possible, including falling asleep for a month.  Sin, but - it is possible.  NT, EMNIP, nevertheless, somehow restricts the rights of the DPC (that is, these are not ordinary threads), but I don‚Äôt remember the details. <br><br>  With this, I feel that I have fulfilled my duty towards the drivers.  :) <br><br>  Since May 1 you, albeit belatedly.  :) </div><p>Source: <a href="https://habr.com/ru/post/282930/">https://habr.com/ru/post/282930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282916/index.html">IMAPSync. Transfer mail between servers</a></li>
<li><a href="../282918/index.html">Performance Indicators: KVM vs. Xen</a></li>
<li><a href="../282922/index.html">Work with WAV files using PHP</a></li>
<li><a href="../282924/index.html">Test Gradle Plugins Correctly</a></li>
<li><a href="../282926/index.html">About Modbus and Intel Edison Protocol</a></li>
<li><a href="../282932/index.html">About the usefulness of indexes by expressions</a></li>
<li><a href="../282934/index.html">Easy Hack: Java application</a></li>
<li><a href="../282936/index.html">Efficient Rails - a new book on optimizing the development of Rails applications</a></li>
<li><a href="../282938/index.html">Redmine: Migration from MySQL to PostgreSQL 9.5</a></li>
<li><a href="../282940/index.html">How to write an IO monad in C # (not) without the help of a parallel universe and time machine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>