<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Feature selection methods</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a review, compilation from several sources, a full list of which I will give at the end. Feature selection is an important component o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Feature selection methods</h1><div class="post__text post__text-html js-mediator-article">  This article is a review, compilation from several sources, a full list of which I will give at the end.  Feature selection is an important component of machine learning.  Therefore, I wanted to better understand its various methods.  I got great pleasure from searching for information, reading articles, watching lectures.  And I want to share these materials with you.  I tried to write an article so that it required minimal knowledge in the field and was accessible to beginners. <br><a name="habracut"></a><br><br>  In the text everywhere there is a speech about training with the teacher.  The data set for training a model is called a training set.  Independent variables are called features, I call the dependent variable the target variable.  I assume that these words are familiar to the reader. <br><br><h3>  Feature selection </h3><br>  Why the selection of features is generally necessary.  There are two main reasons.  Firstly, if there are a lot of features, then the classifier's operation time increases.  If the goal is to test several classifiers in order to select the best one, then the time required for the calculations can be simply tremendous.  In addition, the data (training set) can no longer fit into the RAM, then you have to modify the algorithms of the classifiers.  Even one line of the set may no longer fit, although this is already a rare case. <br>  The main reason is still the second - with an increase in the number of features, the accuracy of prediction often decreases.  Especially if there are a lot of garbage features in the data (little correlated with the target variable).  This phenomenon is called <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2583%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">overfitting</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Feature selection methods fall into three categories: filter methods, wrapper methods and embedded methods.  <i>The first category I will call ‚Äúfiltering methods‚Äù, the last one - ‚Äúbuilt-in methods‚Äù, and for the second I don‚Äôt have an adequate translation (I‚Äôll listen to the suggestions).</i> <br><br><h3>  Filtering methods </h3><br>  They are based on statistical methods and, as a rule, treat each feature independently.  Allow to evaluate and rank features by importance, for which the degree of correlation of this feature with the target variable is taken.  Consider a few examples. <br><br><h4>  Informaition gain </h4><br>  One example of filtering methods is informaition gain.  It is closely related to the concept of information entropy.  Formula entropy is quite simple: <br><div style="text-align:center;"><img src="http://tex.s2cms.ru/svg/H(X)%3D-%5Csum_%7Bx_%7Bi%7D%5Cin%20X%7Dp(x_%7Bi%7D)*log_%7B2%7D(p(x_%7Bi%7D))" alt="H (X) = - \ sum_ {x_ {i} \ in X} p (x_ {i}) * log_ {2} (p (x_ {i}))"></div><br>  Where, p (x <sub>i</sub> ) is the probability that the variable X will take the value x <sub>i</sub> .  Under our conditions, this probability is counted as the number of records (examples) in which X = x <sub>i</sub> divided by the total number of records. <br>  To better understand the meaning of this measure, two simple examples can be presented.  First, tossing a coin, in which the falling of an eagle and tails are equally probable.  In this case, the entropy calculated by the formula will be equal to 1. If the coin always falls solely upwards with an eagle, then the entropy will be equal to 0. In other words, high entropy speaks of a uniform distribution, low - of some more interesting. <br>  To calculate the correlation between variables, we need to define a few more measures.  The first one is specific conditional entropy: <br><div style="text-align:center;"><img src="http://tex.s2cms.ru/svg/H(Y%7CX%3Dx_%7Bi%7D)" alt="H (Y | X = x_ {i})"></div>  - entropy H (Y) calculated only for those records for which X = x <sub>i</sub> . <br>  Relative entropy (conditional entropy) is considered as: <br><div style="text-align:center;"><img src="http://tex.s2cms.ru/svg/H(Y%7CX)%3D%5Csum_%7Bx_%7Bi%7D%5Cin%20X%7Dp(x_%7Bi%7D)*H(Y%7CX%3Dx_%7Bi%7D)" alt="H (Y | X) = \ sum_ {x_ {i} \ in X} p (x_ {i}) * H (Y | X = x_ {i})"></div><br>  Such an interesting value is not in itself, but its difference with the usual entropy of the feature Y. That is,  how would a measure of how much more ordered Y becomes for us, if we know the values ‚Äã‚Äãof X. Or, to put it simply, is there a correlation between the values ‚Äã‚Äãof X and Y, and how big is it?  This is indicated by the magnitude of information gain: <br><div style="text-align:center;"><img src="http://tex.s2cms.ru/svg/IG(Y%7CX)%3DH(Y)-H(Y%7CX)" alt="IG (Y | X) = H (Y) -H (Y | X)"></div><br>  The larger the IG parameter, the stronger the correlation.  Thus, we can easily calculate the information gain for all features and throw out those that have little effect on the target variable.  Thereby, firstly, by reducing the time for calculating the model, and, secondly, by reducing the risk of retraining. <br><br><div class="spoiler">  <b class="spoiler_title">Confusion with Mutual information and Information gain</b> <div class="spoiler_text">  In <a href="https://en.wikipedia.org/wiki/Mutual_information">Wikipedia, the</a> formula indicated above is called mutual informaition, and <a href="https://en.wikipedia.org/wiki/Information_gain_in_decision_trees">informaition gain is</a> used as a synonym for ‚ÄúKullback ‚Äì Leibler distance‚Äù.  But in most cases, information gain and mutual information are still used as different names for the same.  Therefore, the formula above can meet you under any of these names.  I will call this measure informaition gain simply because I am so used to it. <br></div></div><br><br><h4>  Chi-square </h4><br>  Consider another popular feature filtering method, called the chi-square test.  In order to understand it you will need to recall a couple of formulas from the theory of probability.  The first of these is the formula for the probability of intersection (multiplication) of events.  Those.  the probability that both events A and B will occur: <br><div style="text-align:center;"><img src="http://tex.s2cms.ru/svg/P(A%5Ccap%20B)%3DP(A%2FB)*P(B)" alt="P (A \ cap B) = P (A / B) * P (B)"></div><br>  Where P (A / B) is the probability that event A will occur if B has already arrived.  If these events are independent (the onset of one of them does not affect the probability of the onset of the other), then: <br><div style="text-align:center;"><img src="http://tex.s2cms.ru/svg/P(A%5Ccap%20B)%3DP(A)*P(B)" alt="P (A \ cap B) = P (A) * P (B)"></div><br>  Based on this formula, we can calculate the expected probability of the occurrence of both events A and B at the same time, if we assume that they are independent.  And then calculate how much reality is different from our expectations.  The chi-square formula looks like this: <br><div style="text-align:center;"><img src="http://tex.s2cms.ru/svg/%5Cchi%5E%7B2%7D%3D%5Csum%20%5Cfrac%7B(observed%20-%20expected)%5E%7B2%7D%7D%7Bexpected%7D" alt="\ chi ^ {2} = \ sum \ frac {(observed - expected) ^ {2}} {expected}"></div><br>  Consider its use by example.  Suppose we want to investigate the effect of some influence on the occurrence of a particular disease.  The table with the statistics we have is as follows: <br><table><tbody><tr><td colspan="4">  <b>Disease</b> </td></tr><tr><td>  <b>Impact</b> </td><td>  there is </td><td>  Not </td><td>  Total </td></tr><tr><td>  It was </td><td>  37 </td><td>  13 </td><td>  50 </td></tr><tr><td>  Did not have </td><td>  17 </td><td>  53 </td><td>  70 </td></tr><tr><td>  Total </td><td>  54 </td><td>  66 </td><td>  120 </td></tr></tbody></table><br>  Where the cell at the intersection of the first row and first column represents the number of exposed and diseased;  the first row and second column - the number of exposed, but not sick, etc. <br>  Calculate the expected value for the first cell (those exposed and ill): <br><div style="text-align:center;"><img src="http://tex.s2cms.ru/svg/expected%20%3D%20%5Cfrac%7B50%7D%7B120%7D*%5Cfrac%7B54%7D%7B120%7D*120" alt="expected = \ frac {50} {120} * \ frac {54} {120} * 120"></div><br>  Similarly for other cells.  And by the formula we calculate chi-square (in this case it is equal to 29.1). <br>  Thus, for independent events, the chi-square parameter will be zero (or a number close to it).  But in order to understand exactly what the probability of getting such a picture for two independent events, another concept is introduced - the degree of freedom.  It is defined as: <br>  (# values ‚Äã‚Äãof variable1 - 1) * (# values ‚Äã‚Äãof variable_2_1 - 1) <br>  Where # variable_values1 is the number of values ‚Äã‚Äãthat variable 1 can take (for our case, the degree of freedom = 1). <br>  In order to have a chi-square value and the degree of freedom one could estimate the probability, there are special tables (like this one ( <a href="https://www.easycalculation.com/statistics/chisquare-table.php">https://www.easycalculation.com/statistics/chisquare-table.php</a> )). <br><br>  We got some insight into how the algorithm works.  But, of course, in reality, it will not be necessary either to write this algorithm independently, much less to read the statistics manually.  The scikit-learn library for python makes it possible not to think about the implementation details: <br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> nltk <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> WordNetLemmatizer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.feature_selection <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> chi2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.feature_selection <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SelectKBest select = SelectKBest(chi2, k=<span class="hljs-number"><span class="hljs-number">50</span></span>) X_new = select.fit_transform(train_data_features, train[<span class="hljs-string"><span class="hljs-string">"sentiment"</span></span>])</code> </pre> <br><br>  In my last <a href="http://habrahabr.ru/post/263399/">article,</a> you can find an example of the effectiveness of using chi-square statistics for solving the NLP problem. <br><br><h4>  mRmR </h4><br>  Separately, I want to briefly discuss a more complex filtering method, which takes into account not only the correlation between features and the target variable, but also feature redundancy - mRmR (minimum redundancy with maximum relevance).  The method tries to maximize the following expression: <br><div style="text-align:center;"><img src="http://tex.s2cms.ru/svg/max%5B%5Cfrac%7B1%7D%7BS%7D%5Csum_%7Bx_%7Bi%7D%5Cin%20S%7D%20IG(Y%7Cx_%7Bi%7D)%20-%20%5Cfrac%7B1%7D%7BS%5E%7B2%7D%7D%5Csum_%7Bx_%7Bi%7D%2Cx_%7Bj%7D%5Cin%20S%7D%20IG(x_%7Bi%7D%7Cx_%7Bj%7D)%5D" alt="max [\ frac {1} {S} \ sum_ {x_ {i} \ in S} IG (Y | x_ {i}) - \ frac {1} {S ^ {2}} \ sum_ {x_ {i} , x_ {j} \ in S} IG (x_ {i} | x_ {j})]"></div><br>  Where the first term is responsible for maximizing the correlation between the selected feature set S and the target variable Y (similar to the informaition gain method), and the second for minimizing the correlations between the features.  The feature set thus obtained is not only relevant, but the features in this set minimally repeat each other.  In this method, features are added to the set one by one with a selection of the optimal one at each step. <br><br><h4>  Pros and cons of filtering methods </h4><br>  What is this class of methods good for?  They have a low computation cost, which depends linearly on the total number of features.  They are much faster in both wrapper and embedded methods.  In addition, they work well even when the number of features we have exceeds the number of examples in the training set (the methods of other categories cannot always boast). <br><br>  What are their disadvantages?  They view each feature in isolation.  Because of this, to find the top N most correlated features generally does not mean to get a subset on which the prediction accuracy will be the highest.  Consider a simple example. <br><br>  Suppose there is a certain array of features, among which are X1 and X2.  The target variable depends on them as: <br><div style="text-align:center;"><img src="http://tex.s2cms.ru/svg/Y%3DX_%7B1%7D%20%5Coplus%20X_%7B2%7D" alt="Y = X_ {1} \ oplus X_ {2}"></div><br>  (logical XOR function) <br>  The truth table will look like this (if anyone has forgotten): <br><table><tbody><tr><th>  X1 </th><th>  X2 </th><th>  Y </th></tr><tr><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  0 </td><td>  one </td><td>  one </td></tr><tr><td>  one </td><td>  0 </td><td>  one </td></tr><tr><td>  one </td><td>  one </td><td>  0 </td></tr></tbody></table><br>  Looking at this table, we will construct a table with statistics for the variable X1 and calculate its correlation with the variable Y (for X2 it will be similar) using the chi-square formula. <br><table><tbody><tr><th colspan="4">  Y </th></tr><tr><td>  X1 </td><td>  one </td><td>  0 </td><td>  Total </td></tr><tr><td>  one </td><td>  one </td><td>  one </td><td>  2 </td></tr><tr><td>  0 </td><td>  one </td><td>  one </td><td>  2 </td></tr><tr><td>  Total </td><td>  2 </td><td>  2 </td><td>  four </td></tr></tbody></table><br>  It is easy to calculate that the chi-square will be equal to 0, that is, it will not show any correlation between the features and the target variable. <br><br>  The example is exaggerated, but it shows well that the filtering methods are not able to catch the joint influence of several features on the target variable. <br><br><h3>  Wrapper methods </h3><br>  The essence of this category of methods is that the classifier runs on different subsets of the features of the original training set.  Then a subset of features with the best parameters on the training set is selected.  And then it is tested on a test set (the test set does not participate in the process of choosing the optimal subset). <br><br>  There are two approaches in this class of methods ‚Äî forward selection methods and backwards selection features.  The first ones start from an empty subset, where various features are gradually added (to select the optimal addition at each step).  In the second case, the method starts with a subset equal to the original feature set, and features are gradually removed from it, with the recalculation of the classifier each time. <br><br>  One example of such methods is recursive feature elimination.  As the name implies, it refers to the algorithms of gradual exclusion of features from the general pool.  On python, the implementation of this algorithm is in the scikit-learn library.  This method requires you to choose a classifier by which features will be evaluated, for example, linear regression: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.feature_selection <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> RFE <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.linear_model <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> LinearRegression data= load_data() X = data[<span class="hljs-string"><span class="hljs-string">"data"</span></span>] Y = data[<span class="hljs-string"><span class="hljs-string">"target"</span></span>] lr = LinearRegression() <span class="hljs-comment"><span class="hljs-comment">#select 5 the most informative features rfe = RFE(lr, 5) selector = rfe.fit(X,Y)</span></span></code> </pre><br>  Although the elimination method better tracks the relationship between features, it is much more expensive computationally.  However, all wrapper methods require much more computation than filtering methods.  Moreover, in the case of a large number of features and a small size of the training set, these methods have the danger of retraining. <br><br><h3>  Embedded methods </h3><br>  And finally, the built-in methods, which allow not to separate the selection of features and training of the classifier, but select within the model calculation process.  In addition, these algorithms require less computation than wrapper methods (although more than filtering methods). <br><br>  The main method from this category is regularization.  There are various varieties of it, but the basic principle is common.  If we consider the work of the classifier without regularization, then it consists in building such a model that would be the best way to predict all points of the training set. <br>  For example, if the classification algorithm is linear regression, then the polynomial coefficients are selected, which approximates the relationship between the features and the target variable.  The mean square error ( <a href="https://en.wikipedia.org/wiki/Root-mean-square_deviation">RMSE</a> ) serves as an assessment of the quality of the selected coefficients.  Those.  the parameters are chosen so that the total deviation (more precisely, the total square of deviations) for the points predicted by the classifier from the real points is minimal. <br>  The idea of ‚Äã‚Äãregularization is to construct an algorithm that minimizes not only the error, but also the number of variables used. <br><br><h4>  Tikhonov's regularization method (ridge regression) </h4><br>  Consider all the same on the example of linear regression.  If the test set contains the matrix of features A and the vector of the target variable b, then we are looking for a solution in the form Ax = b.  In the process of the algorithm, the following expression is minimized: <br><div style="text-align:center;"><img src="http://tex.s2cms.ru/svg/%5Cleft%20%5C%7C%20Ax-y%20%5Cright%20%5C%7C%5E%7B2%7D%2B%5Calpha%20%5Cleft%20%5C%7C%20x%20%5Cright%20%5C%7C%5E%7B2%7D" alt="\ left \ | Ax-y \ right \ | ^ {2} + \ alpha \ left \ | x \ right \ | ^ {2}"></div><br>  Where the first term is just the root-mean-square error, and the second is the regularizing operator (the sum of the squares of all coefficients multiplied by alpha).  In the course of the algorithm's operation, the sizes of the coefficients will be proportional to the importance of the corresponding variables, and those variables that give the smallest contribution to eliminating the error will be near-zero. <br>  A few words about the alpha parameter.  It allows you to customize the contribution of the regularizing operator to the total amount.  With it, we can specify the priority - the accuracy of the model or the minimum number of variables used. <br><br>  If we want to use linear regression with Tikhonov's regularization, then there is no need to reinvent the wheel.  The scikit-learn library has a model called <a href="http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Ridge.html">Ridge regression</a> , which includes this type of regularization. <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.linear_model <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Ridge data= load_data() X = data[<span class="hljs-string"><span class="hljs-string">"data"</span></span>] y = data[<span class="hljs-string"><span class="hljs-string">"target"</span></span>] clf = Ridge(alpha=<span class="hljs-number"><span class="hljs-number">1.0</span></span>) clf.fit(X, y)</code> </pre><br>  Note the ability to manually adjust the alpha setting. <br><br><h4>  Lasso </h4><br>  It is similar to the previous one except for the difference in the regularizing operator.  It is not a sum of squares, but a sum of modules of coefficients.  Despite the small differences, properties differ.  If in a ridge as alpha grows, all coefficients get values ‚Äã‚Äãall closer to zero, but usually they still do not vanish.  That in LASSO with increasing alpha, more and more coefficients become zero and completely stop contributing to the model.  Thus, we get a really selection of features.  More significant features will keep their coefficients non-zero, less significant features will be reset.  You can hear more about these properties and look at the graphics (and learn about Elastic Net for one, which I will not dwell on) for example in this <a href="https://youtu.be/ipb2MhSRGdw">lecture</a> . <br><br>  Using this method with the scikit-learn library is also identical to the previous method.  Only Ridge is replaced by <a href="http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Lasso.html">Lasso</a> . <br><br>  Thus, regularization is a kind of penalty for the excessive complexity of the model, which allows you to protect yourself from overtraining if there are garbage features among them.  You should not think that regularization happens only in linear models, and for boosting and for neural networks there are own regularization methods. <br>  From the drawbacks of regularization, we can note the fact that the model is built on the entire array of features, which means that it does not speed up the classifier‚Äôs work.  But in general, this method is better able to catch the interdependencies of variables than filtering methods. <br><br><h3>  Finally </h3><br>  I will not write here conclusions about the criteria for choosing one method or another in a particular situation.  In most cases, it will be easier and more convenient to refer to the built-in methods.  If visibility is needed - filtering methods can provide it.  The rest, I think, is a matter of practice. <br><br>  I would be glad to hear comments.  If, in your opinion, there is an inaccuracy in the text, something is missing, something is incomprehensible, you want to share your practical observations - write. <br><br><h3>  Links </h3><br>  <a href="http://stats.stackexchange.com/questions/13389/information-gain-mutual-information-and-related-measures">stats.stackexchange.com/questions/13389/information-gain-mutual-information-and-related-measures</a> <br>  <a href="https://www.coursera.org/course/mmds">www.coursera.org/course/mmds</a> <br>  <a href="http://www.cs.binghamton.edu/~lyu/publications/Gulgezen-etal09ECML.pdf">www.cs.binghamton.edu/~lyu/publications/Gulgezen-etal09ECML.pdf</a> <br>  <a href="http://habrahabr.ru/company/mailru/blog/254897/">habrahabr.ru/company/mailru/blog/254897</a> <br>  <a href="http://machinelearningmastery.com/an-introduction-to-feature-selection/">machinelearningmastery.com/an-introduction-to-feature-selection</a> <br>  <a href="http://ocw.jhsph.edu/courses/fundepiii/pdfs/lecture17.pdf">ocw.jhsph.edu/courses/fundepiii/pdfs/lecture17.pdf</a> <br>  <a href="http://blog.datadive.net/selecting-good-features-part-iv-stability-selection-rfe-and-everything-side-by-side/">blog.datadive.net/selecting-good-features-part-iv-stability-selection-rfe-and-everything-side-by-side</a> <br>  <a href="http://ai.stanford.edu/~ronnyk/wrappersPrint.pdf">ai.stanford.edu/~ronnyk/wrappersPrint.pdf</a> <br>  <a href="http://www.math.kent.edu/~reichel/publications/modtikh.pdf">www.math.kent.edu/~reichel/publications/modtikh.pdf</a> <br>  <a href="http://scikit-learn.org/stable/modules/linear_model.html">scikit-learn.org/stable/modules/linear_model.html</a> </div><p>Source: <a href="https://habr.com/ru/post/264915/">https://habr.com/ru/post/264915/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../264905/index.html">Top Story is authorized to state: do not be afraid of mobile development</a></li>
<li><a href="../264907/index.html">Lessons in FluentNHibernate c ASP.NET MVC and SQL Server. Part 1</a></li>
<li><a href="../264909/index.html">Facebook's Fresco Library</a></li>
<li><a href="../264911/index.html">Office as Platform issue 4: Uber, PayPal, Boomerang and Evernote as examples of new type applications</a></li>
<li><a href="../264913/index.html">Where in the ZX Spectrum System Monitor? Mystery PC Duet</a></li>
<li><a href="../264919/index.html">Java bytecode "Hello world"</a></li>
<li><a href="../264921/index.html">What problems do we face when introducing and operating Microsoft Exchange and how to solve them effectively?</a></li>
<li><a href="../264923/index.html">Joint editing. Part 1</a></li>
<li><a href="../264927/index.html">Automate MS SQL backup configuration using .NET application</a></li>
<li><a href="../264929/index.html">What can SED outside the office: the automation of the treasury</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>