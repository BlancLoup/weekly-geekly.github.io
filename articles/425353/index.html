<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The whole truth about the RTOS. Article # 13. Task data structures and unsupported API calls</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this third and final article on tasks, I will look at the Nucleus SE data structures and describe the RTOS API calls that are not implemented in th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The whole truth about the RTOS. Article # 13. Task data structures and unsupported API calls</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/a2/hi/au/a2hiaum17nhh6_ibldqgahpgaxo.jpeg"><br><br>  In this third and final article on tasks, I will look at the Nucleus SE data structures and describe the RTOS API calls that are not implemented in the Nucleus SE, and also talk about other compatibility issues. <br><a name="habracut"></a><br>  Previous articles in the series: <br>  <a href="https://habr.com/post/424713/">Article # 12.</a>  <a href="https://habr.com/post/424713/">Task Services</a> <br>  <a href="https://habr.com/post/424481/">Article # 11.</a>  <a href="https://habr.com/post/424481/">Tasks: configuration and introduction to the API</a> <br>  <a href="https://habr.com/post/423967/">Article # 10.</a>  <a href="https://habr.com/post/423967/">Scheduler: additional features and context preservation</a> <br>  <a href="https://habr.com/post/422615/">Article # 9.</a>  <a href="https://habr.com/post/422615/">Scheduler: implementation</a> <br>  <a href="https://habr.com/post/422617/">Article # 8.</a>  <a href="https://habr.com/post/422617/">Nucleus SE: Inside and Deployment</a> <br>  <a href="https://habr.com/post/418601/">Article # 7.</a>  <a href="https://habr.com/post/418601/">Nucleus SE: introduction</a> <br>  <a href="https://habr.com/post/418677/">Article # 6.</a>  <a href="https://habr.com/post/418677/">Other RTOS services</a> <br>  <a href="https://habr.com/post/415429/">Article # 5.</a>  <a href="https://habr.com/post/415429/">Interaction between tasks and synchronization</a> <br>  <a href="https://habr.com/post/415427/">Article # 4.</a>  <a href="https://habr.com/post/415427/">Tasks, context switching and interrupts</a> <br>  <a href="https://habr.com/post/415329/">Article # 3.</a>  <a href="https://habr.com/post/415329/">Tasks and planning</a> <br>  <a href="https://habr.com/post/414093/">Article # 2.</a>  <a href="https://habr.com/post/414093/">RTOS: Structure and Real Time</a> <a href="https://habr.com/post/414093/"><br></a>  <a href="https://habr.com/post/414093/">Article # 1.</a>  <a href="https://habr.com/post/414093/">RTOS: introduction.</a> <a href="https://habr.com/post/414093/"><br></a> <br><h2>  Data structures </h2><br>  Tasks use different data structures (both in RAM and ROM), which, like other Nucleus SE objects, is a set of tables whose size corresponds to the number of selected tasks and parameters. <br><br>  I strongly recommend that application code refer to these data structures using API functions, rather than directly.  This avoids unwanted side effects, incompatibility with future versions of the Nucleus SE, and also simplifies porting the application to the Nucleus RTOS.  For a better understanding of the work of the service call code and the debugging process, below is a detailed description of the data structures. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Kernel data structures hosted in RAM </h3><br>  These data structures include: <br><br>  <b>NUSE_Task_Context [] []</b> is a two-dimensional array of the type <b>ADDR</b> , it has one line for each task.  The number of columns depends on the controller architecture and is determined by the symbol <b>NUSE_REGISTERS</b> , which is defined in <b>nuse_types.h</b> .  This array is used by the scheduler to save the context of each task and was described in detail in the ‚ÄúSaving Context‚Äù section of Article # 10.  It is not created if the RTC scheduler is used. <br>  <b>NUSE_Task_Signal_Flags []</b> is an array of type <b>U8</b> , created when signals are turned on, and contains 8 signal flags for each task.  Signals will be discussed in one of the following articles. <br>  <b>NUSE_Task_Timeout_Counter []</b> is an array of type <b>U16</b> , consists of subtractive counters for each task, and is created if the API call <b>NUSE_Task_Sleep () is</b> activated. <br>  <b>NUSE_Task_Status []</b> is an array of type U8, contains the status of each task - <b>NUSE_READY</b> or the status of suspension.  It is created only if task suspension is activated. <br>  <b>NUSE_Task_Blocking_Return []</b> is an array of type U8, created if the blocking of API calls is activated.  It contains the return code that will be used after blocking API calls.  It usually contains <b>NUSE_SUCCESS</b> or code indicating that the object was dropped (for example, <b>NUSE_MAILBOX_WAS_RESET</b> ). <br>  <b>NUSE_Task_Schedule_Count []</b> is an array of type <b>U16</b> , contains the counter of each task and is created only if the scheduler count has been activated. <br><br>  <b>NUSE_Task_Context [] [] is</b> initialized mainly with zeros, except for the entries corresponding to the status register (SR), the program counter (PC) and the stack pointer (SP), which are assigned initial values ‚Äã‚Äã(see in the ROM ‚Äùbelow), and all other data structures <b>NUSE_Init_Task ()</b> assigns zeros when running the Nucleus SE.  One of the following articles will contain a complete list of Nucleus SE starting procedures with their descriptions. <br><br>  Below are the definitions of the data structures that are contained in the nuse_init.c file. <br><br><img src="https://habrastorage.org/webt/fj/hr/le/fjhrlehn7si_hkt5lnnyk6dosno.jpeg"><br><br><h3>  User data in RAM </h3><br>  The user must define each task stack (if not using the RTC scheduler).  These should be <b>ADDR</b> arrays, which are typically defined in <b>nuse_config.c</b> .  Addresses and stack sizes should be placed in task entries <b>NUSE_Task_Stack_Base []</b> and <b>NUSE_Task_Stack_Size [],</b> respectively (see. Data in ROM). <br><br><h3>  ROM data </h3><br>  The ROM contains from one to four data structures related to the tasks.  The exact amount depends on the selected parameters: <br><br>  <b>NUSE_Task_Start_Address []</b> is an array of type <b>ADDR</b> , having one entry for each task, which is a pointer to the entry point to the code for the task. <br>  <b>NUSE_Task_Stack_Base []</b> is an array of the type <b>ADDR</b> , having one entry for each task, which is a pointer to the base address of the stack for the task.  This array is created if any scheduler other than RTC is used. <br>  <b>NUSE_Task_Stack_Size []</b> is an array of type <b>U16</b> , having one entry for each task, which shows the stack size for the task (in words).  This array is created if any scheduler other than RTC is used. <br>  <b>NUSE_Task_Initial_State []</b> is an array of type <b>U8</b> , which has one entry for each task, which shows the initial state of the task.  May be <b>NUSE_READY</b> or <b>NUSE_PURE_SUSPEND</b> .  This array is created if support for the initial state of the task is selected. <br><br>  These data structures are declared and initialized (static) in <b>nuse_config.c</b> : <br><br><img src="https://habrastorage.org/webt/2g/pp/bu/2gppbu3zs8wc0gipo3kggntvxek.jpeg"><br><br><h3>  Memory capacity for storing task data (Task Data Footprint) </h3><br>  Like all Nucleus SE core objects, the amount of memory required to store data is predictable. <br><br>  ROM size (in bytes) required for all application tasks: <br>  <b>NUSE_TASK_NUMBER * sizeof (ADDR)</b> <br><br>  Plus, if any planner other than RTC is selected: <br>  <b>NUSE_TASK_NUMBER * (sizeof (ADDR) +2)</b> <br><br>  Plus, if support for the initial state of the task is selected: <br>  <b>NUSE_TASK_NUMBER</b> <br><br>  For storing data in RAM, the amount of memory (in bytes) is determined by the selected parameters, and it can be zero if none of the parameters are selected. <br>  If a scheduler other than RTC is selected: <br>  <b>NUSE_TASK_NUMBER * NUSE REGISTER * sizeof (ADDR)</b> <br><br>  Plus, if signal support is selected: <br>  <b>NUSE_TASK_NUMBER</b> <br><br>  Plus, if the NUSE_Task_Sleep () API call is activated: <br>  <b>NUSE_TASK_NUMBER * 2</b> <br><br>  Plus, if task suspension is activated: <br>  <b>NUSE_TASK_NUMBER</b> <br><br>  Plus, if API call blocking is activated: <br>  <b>NUSE_TASK_NUMBER</b> <br><br>  Plus, if the scheduler counter is activated: <br>  <b>NUSE_TASK_NUMBER * 2</b> <br><br><h2>  Non-implemented Nucleus SE API calls </h2><br>  Below are seven API calls that are in the Nucleus RTOS, not implemented in the Nucleus SE. <br><br><h3>  Create Task </h3><br>  This API call creates an application task.  In Nucleus SE, this function is not necessary, since tasks are created statically. <br><br>  Call prototype: <br><br>  <b>STATUS NU_Create_Task (NU_TASK * task, CHAR * name, VOID (* task_entry)) (UNSIGNED, VOID *), UNSIGNED argc, VOID * argv, VOID * stack_address, UNSIGNED stack_size, OPTION priority, UNSIGNED time_shtshir, OP_ priority, UNSIGNED</b> <br><br>  Options: <br><br>  <b>task</b> - a pointer to a user task management block, can be used as a descriptor / reference ("handle") of a task in other API calls; <br>  <b>name</b> - pointers to the name of the task, a 7-character string with a terminating zero; <br>  <b>task_entry</b> - specifies the input function for the task; <br>  <b>argc</b> is a <b>UNSIGNED</b> data element that can be used to transfer initial information to a task; <br>  <b>argv</b> is a pointer that can be used to pass information to a task; <br>  <b>stack_address</b> - sets the initial memory sector for the task stack; <br>  <b>stack_size</b> - indicates the number of bytes in the stack; <br>  <b>priority</b> - indicates the priority value of the task: from 0 to 255, where lower numbers correspond to the highest priority; <br>  <b>time_slice</b> - indicates the maximum number of time <b>slices</b> that can pass when performing this task.  A value of ‚Äú0‚Äù disables time slicing for this task; <br>  <b>preempt</b> - indicates whether the task is being <b>repressed</b> or not.  May have values <b>NU_PREEMPT</b> and <b>NU_NO_PREEMPT</b> ; <br>  <b>auto_start</b> - shows the initial state of the task.  <b>NU_START</b> means that the task is ready for execution, and <b>NU_NO_START</b> - that the task is suspended. <br><br>  Return value: <br><br>  <b>NU_SUCCESS</b> indicates a successful completion of the service; <br>  <b>NU_INVALID_TASK</b> - indicates that the pointer to the task control block is zero ( <b>NULL</b> ); <br>  <b>NU_INVALID_ENTRY</b> - indicates that the pointer to the input function of the task is zero ( <b>NULL</b> ); <br>  <b>NU_INVALID_MEMORY</b> - indicates that the memory sector assigned by the stack_address parameter is zero ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - indicates that the specified stack size is insufficient; <br>  <b>NU_INVALID_PREEMPT</b> - indicates that the <b>preempt</b> parameter <b>is</b> set incorrectly; <br>  <b>NU_INVALID_START</b> - indicates that the <b>auto_start</b> parameter is incorrect. <br><br><h3>  Delete Task </h3><br>  This API call removes the previously created application task, which should have the status of <i>Finished</i> (terminated) or <i>Terminated</i> (complete suspension).  This call is also not necessary in Nucleus SE, since tasks are created statically and cannot be deleted. <br><br>  Call prototype: <br><br>  <b>STATUS NU_Delete_Task (NU_TASK * task);</b> <br><br>  Options: <br><br>  <b>task</b> - pointer to task control block <br><br>  Return value: <br><br>  <b>NU_SUCCESS</b> indicates a successful completion of the service; <br>  <b>NU_INVALID_TASK</b> - indicates that the pointer to the task is set incorrectly; <br>  <b>NU_INVALID_DELETE</b> - indicates that the task is not in the ‚ÄúFinished‚Äù or ‚ÄúTerminated‚Äù state. <br><br><h3>  Get task pointers (Get Task Pointers) </h3><br>  This API call makes a sequential list of pointers to all tasks in the system.  It is not needed in the Nucleus SE, since tasks are identified using a simple index, not a pointer. <br><br>  Call prototype: <br><br>  <b>UNSIGNED NU_Task_Pointers (NU_TASK ** pointer_list, UNSIGNED maximum_pointers);</b> <br><br>  Options: <br><br>  <b>pointer_list</b> is a pointer to an array of pointers <b>NU_TASK</b> .  This array will be filled with pointers to the tasks installed in the system; <br>  <b>maximum_pointers</b> - the maximum number of pointers that can be placed in an array. <br><br>  Return value: <br><br>  The number of <b>NU_TASK</b> pointers placed in the array. <br><br><h3>  Change Task Priority </h3><br>  This API call assigns a new priority to the task.  It is not required in Nucleus SE, as task priorities are constant. <br><br>  Call prototype: <br><br>  <b>OPTION NU_Change_Priority (NU_TASK * task, OPTION new_priority);</b> <br><br>  Options: <br><br>  <b>task</b> - a pointer to the task management block; <br>  <b>new_priority</b> - sets the priority from 0 to 255. <br><br>  Return value: <br>  The previous task priority value. <br><br><h3>  Change Task Preemption Algorithm </h3><br>  This API call reverses the order of the executing task.  In Nucleus SE, it is not needed, since a simpler scheduling algorithm is used. <br><br>  Call prototype: <br>  <b>OPTION NU_Change_Preemption (OPTION preempt);</b> <br><br>  Options: <br>  <b>preempt</b> is a new extrusion algorithm that accepts <b>NU_PREEMPT</b> or <b>NU_NO_PREEMPT values</b> <br><br>  Return value: <br>  The previous algorithm for crowding out the task. <br><br><h3>  Change Task Time Slice (Change Task Time Slice) </h3><br>  This API call changes the time slot of a specific task.  In the Nucleus SE, it is not necessary, since the time quanta of the tasks are fixed. <br><br>  Call prototype: <br>  <b>UNSIGNED NU_Change_Time_Slice (NU_TASK * task, UNSIGNED time_slice);</b> <br><br>  Options: <br>  <b>task</b> - a pointer to the task management block; <br>  <b>time_slice</b> - the maximum number of time <b>slices</b> that can pass when performing this task, the zero value of this field disables the time slicing for this task. <br><br>  Return value: <br>  The previous value of the time quantum of the problem. <br><br><h3>  Terminate Task </h3><br>  This API call completes a specific task.  This is not necessary in the Nucleus SE, as the <i>Terminated</i> state is not supported. <br><br>  Call prototype: <br>  <b>STATUS NU_Terminate_Task (NU_TASK * task);</b> <br><br>  Options: <br>  <b>task</b> - a pointer to the task control block. <br><br>  Return value: <br>  <b>NU_SUCCESS</b> indicates a successful completion of the service; <br>  <b>NU_INVALID_TASK</b> - indicates that the task pointer is set incorrectly. <br><br><h2>  Nucleus RTOS Compatibility </h2><br>  When developing the Nucleus SE, one of the main tasks was to ensure a high level of code compatibility with Nucleus RTOS.  Tasks are no exception, and, from the user's point of view, they are implemented in much the same way as in the Nucleus RTOS.  There are some incompatible areas where I came to the conclusion that such incompatibility would be acceptable, given that the final code is easier to understand and can use memory more efficiently.  However, besides these incompatibilities, the other Nucleus RTOS API calls can be almost directly used as Nucleus SE calls.  One of the following articles will contain more detailed information on the transition from Nucleus RTOS to Nucleus SE <br><br><h3>  Object IDs </h3><br>  In Nucleus RTOS, all objects are described by a data structure (control units) that have a specific type.  A pointer to this control unit serves as an identifier for the task.  In Nucleus SE, I decided that a different approach was needed to use memory efficiently.  All kernel objects are described by a set of tables in RAM and / or ROM.  The size of these tables is determined by the number of object types.  The identifier of a particular object is the index in these tables.  Therefore, I have defined <b>NUSE_TASK</b> as equivalent to <b>U8</b> .  A variable of this type (not a pointer) serves as a task identifier.  This is a small incompatibility that is easy to figure out if the code is ported from or to Nucleus RTOS.  Object identifiers are usually stored and transmitted unchanged. <br><br>  Nucleus RTOS also supports task naming.  These names are used only when debugging.  I excluded them from the Nucleus SE to save memory. <br><br><h3>  Task states </h3><br>  In Nucleus, RTOS tasks can be in one of several states: <i>Executing</i> , <i>Ready</i> , <i>Suspended</i> (which leads to uncertainty: the task is in standby mode or blocked by an API call), <i>Terminated</i> or Finished. <br><br>  Nucleus SE also supports <i>Executing</i> and <i>Ready</i> states.  All three <i>Suspended</i> options are supported optionally.  <i>Terminated</i> and Finished are not supported.  No API calls to complete tasks.  The external task function should never return a value either explicitly or implicitly (this will lead to a <i>Finished</i> state in the Nucleus RTOS). <br><br><h3>  Unrealized API calls </h3><br>  Nucleus RTOS supports 16 task calls.  Of these, 7 are not implemented in the Nucleus SE.  Their description, as well as the reason for their exclusion, is described above. <br><br>  In the next article, we‚Äôll start looking at RTOS memory management. <br><br>  <b>About the author:</b> Colin Walls has been working in the electronics industry for more than thirty years, spending a significant amount of time on embedded software.  He is now an embedded software engineer in Mentor Embedded (a division of Mentor Graphics).  Colin Walls often speaks at conferences and seminars, author of numerous technical articles and two books on embedded software.  Lives in the UK.  <a href="http://blogs.mentor.com/colinwalls">Colin's</a> professional <a href="http://blogs.mentor.com/colinwalls">blog</a> , e-mail: colin_walls@mentor.com. </div><p>Source: <a href="https://habr.com/ru/post/425353/">https://habr.com/ru/post/425353/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425343/index.html">25 useful tools Kubernetes: deployment and management</a></li>
<li><a href="../425345/index.html">Simplify titles: 802.11ax is getting Wi-Fi 6</a></li>
<li><a href="../425347/index.html">Dumping Mask: Myth or Reality</a></li>
<li><a href="../425349/index.html">Positive Hack Days 9 Forum will take place on May 21 and 22 at Crocus Expo</a></li>
<li><a href="../425351/index.html">Programmers do their own jobs</a></li>
<li><a href="../425355/index.html">ICO-projects security rating</a></li>
<li><a href="../425357/index.html">How we put together a 12-story technology stack and weren‚Äôt crazy</a></li>
<li><a href="../425359/index.html">The Chinese used a microchip to control American computers.</a></li>
<li><a href="../425361/index.html">Content blocking, chromium browser extension</a></li>
<li><a href="../425363/index.html">Tips for student programmers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>