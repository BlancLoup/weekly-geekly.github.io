<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What is waiting for us in Swift 4?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table of contents 


1. One-way ranges 
2. Strings 
3. Private ads are visible in extensions of the same file. 
4. Smart keys of the way 
5. Archiving...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What is waiting for us in Swift 4?</h1><div class="post__text post__text-html js-mediator-article"><p>  Table of contents </p><br><ol><li>  <a href="https://habr.com/ru/post/329580/">One-way ranges</a> </li><li>  <a href="https://habr.com/ru/post/329580/">Strings</a> </li><li>  <a href="https://habr.com/ru/post/329580/">Private ads are visible in extensions of the same file.</a> </li><li>  <a href="https://habr.com/ru/post/329580/">Smart keys of the way</a> </li><li>  <a href="https://habr.com/ru/post/329580/">Archiving and serialization</a> </li><li>  <a href="https://habr.com/ru/post/329580/">Dictionary and Set Improvements</a> </li><li>  <a href="https://habr.com/ru/post/329580/">MutableCollection.swapAt method</a> </li><li>  <a href="https://habr.com/ru/post/329580/">reduce with inout support</a> </li><li>  <a href="https://habr.com/ru/post/329580/">Generics in subscripts</a> </li><li>  <a href="https://habr.com/ru/post/329580/">Bridge for NSNumber</a> </li><li>  <a href="https://habr.com/ru/post/329580/">Instances of classes and subtypes</a> </li></ol><a name="habracut"></a><br><h1 id="kak-eto-vse-zapustit-u-sebya">  How to start it all at home? </h1><br><ol><li>  <a href="https://swift.org/download/">Download the latest Swift 4 snapshot from the site.</a> </li><li>  Run installer </li><li>  Go to <em>Xcode&gt; Toolchains&gt; Manage Toolchains</em> and select snepshot </li></ol><br><p><img src="https://habrastorage.org/web/18b/161/204/18b161204c8347209c880759cbf9fedd.png"></p><br><h1 id="odnostoronnie-diapazony">  One-way ranges </h1><br><p> <a href="">SE-0172</a> adds a new <code>RangeExpression</code> protocol and a set of prefix / postfix operators to define one-way ranges, in which either the lower or upper limit is not defined. </p><br><h3 id="beskonechnye-posledovatelnosti">  Infinite sequences </h3><br><p>  You can use a one-way sequence to create an infinite sequence.  This is a more flexible replacement for <code>enumerated()</code> , if you do not want the numbering to start from scratch: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> letters = [<span class="hljs-string"><span class="hljs-string">"a"</span></span>,<span class="hljs-string"><span class="hljs-string">"b"</span></span>,<span class="hljs-string"><span class="hljs-string">"c"</span></span>,<span class="hljs-string"><span class="hljs-string">"d"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numberedLetters = <span class="hljs-built_in"><span class="hljs-built_in">zip</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>..., letters) <span class="hljs-type"><span class="hljs-type">Array</span></span>(numberedLetters)</code> </pre> <br><h3 id="sabskripty-v-kollekciyah">  Subscripts in collections </h3><br><p>  When a one-way sequence is used in a subscript of a collection, then <code>startIndex</code> or <code>endIndex</code> independently ‚Äúfill‚Äù the missing upper or lower limit in the collection, respectively. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>] numbers[<span class="hljs-number"><span class="hljs-number">5</span></span>...] <span class="hljs-comment"><span class="hljs-comment">//  numbers[5..&lt;numbers.endIndex]</span></span></code> </pre> <br><h3 id="sravnenie-patternov">  Pattern Comparison </h3><br><p>  Pattern comparisons are when a one-way sequence is used in the pattern comparison construct, for example, in <code>case</code> or <code>switch</code> .  <em>Note that the compiler cannot yet determine that the <code>switch</code> is superfluous here</em> . </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> value { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>...: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"greater than zero"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"zero"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ..&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"less than zero"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"unreachable"</span></span>) }</code> </pre> <br><h1 id="stroki">  Strings </h1><br><h3 id="mnogostrochnye-strokovye-literaly">  Multiline String Literals </h3><br><p>  <a href="">SE-0168</a> introduces simple syntax for multi-line string literals ( <code>"""</code> ). In multi-line literals, you do not need to escape single quotes, which means that formats like JSON and HTML can be inserted into them without any escaping. The closing literal defines How many spaces will be removed from the beginning of each line. </p><br><pre> <code class="hljs python">let multilineString = <span class="hljs-string"><span class="hljs-string">""" This is a multi-line string. You don't have to escape "quotes" in here. The position of the closing delimiter controls whitespace stripping. """</span></span> print(multilineString)</code> </pre> <br><p>  To see the output of <code>print</code> , you can display the console by clicking ( <em>View&gt; Debug Area&gt; Activate Console</em> ). </p><br><h3 id="stroka-teper-opyat-kollekciya">  Row now again collection </h3><br><p>  <a href="">SE-0163</a> is the first part of the revised string model for Swift 4. The biggest change is that now the string is a collection (as it was in Swift 1.x), that is, the <code>String.CharacterView</code> functionality <code>String.CharacterView</code> been minimized to its parent type.  (Other views, <code>UnicodeScalarView</code> , <code>UTF8View</code> , and <code>UTF16View</code> , are still present.) </p><br><p>  <em>Please note that SE-0163 is not fully implemented yet, and there will be more stringent changes in the future.</em> </p><br><pre> <code class="hljs lua">let greeting = <span class="hljs-string"><span class="hljs-string">"Hello, !"</span></span> //      .characters greeting.count <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> greeting { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>) }</code> </pre> <br><h3 id="substring--novyy-tip-dlya-slaysov-strok">  Substring - a new type for slice strings </h3><br><p>  String slice instances are now a <code>Substring</code> type.  Both <code>String</code> and <code>Substring</code> implement the <code>StringProtocol</code> protocol.  Almost all APIs for strings live in the <code>StringProtocol</code> , so the <code>String</code> and <code>StringProtocol</code> mostly behave the same. </p><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">let</span></span> comma = greeting.index(<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>: <span class="hljs-string"><span class="hljs-string">","</span></span>)! <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> substring = greeting[..&lt;comma] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">of</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">substring</span></span></span><span class="hljs-class">) // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">API</span></span></span><span class="hljs-class">  </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">    </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Substring</span></span></span><span class="hljs-class"> print(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">substring</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">uppercased</span></span></span><span class="hljs-class">())</span></span></code> </pre> <br><h3 id="unicode-9">  Unicode 9 </h3><br><p>  Swift 4 will support Unicode 9, fixed problems with proper clustering of graphs for modern emoji.  Everything below is now a single character: </p><br><pre> <code class="hljs pgsql">"".count // person + skin tone "‚Äç‚Äç‚Äç".count // <span class="hljs-keyword"><span class="hljs-keyword">family</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> four members "\u{200D}\u{200D}\u{200D}".count // <span class="hljs-keyword"><span class="hljs-keyword">family</span></span> + skin tones "‚Äç".count // person + skin tone + profession</code> </pre> <br><p>  <em>Habraparser ate all Emoji, with them <a href="https://gist.github.com/JiLiZART/c0bfe8280fc0802ac634c68880e756a8">look here</a></em> </p><br><h3 id="svoystvo-characterunicodescalars">  Property <code>Character.unicodeScalars</code> </h3><br><p>  You can now access <code>Character</code> points directly without turning them into a string ( <a href="">SE-0178</a> ). </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>: <span class="hljs-type"><span class="hljs-type">Character</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-type"><span class="hljs-type">Array</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.unicodeScalars)</code> </pre> <br><h1 id="privatnye-obyavleniya-vidimy-v-ekstenshenah-togo-zhe-fayla">  Private ads are visible in extensions of the same file. </h1><br><p>  <a href="">SE-0169</a> modifies the access control rules so that private announcements are now visible in extensions of the parent type in the same file.  This allows you to split your type definition into several extensions and still use private access for most ‚Äúprivate‚Äù things, reducing the need to use the <code>fileprivate</code> access <code>fileprivate</code> . </p><br><pre> <code class="hljs pgsql">struct SortedArray&lt;Element: Comparable&gt; { private var <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>: [Element] = [] init(unsorted: [Element]) { storage = unsorted.sorted() } } <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> SortedArray { mutating func <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(_ element: Element) { // <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.append(element) <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.sort() } } let <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> = SortedArray(unsorted: [<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>]) // <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> __   (   fileprivate) //<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> // error: <span class="hljs-string"><span class="hljs-string">'storage'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> inaccessible due <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-string"><span class="hljs-string">'private'</span></span> protection <span class="hljs-keyword"><span class="hljs-keyword">level</span></span></code> </pre> <br><h1 id="umnye-klyuchi-puti">  Smart keys of the way </h1><br><p>  Probably one of the main features of Swift 4 is the new key path model described in <a href="">SE-0161</a> .  Unlike the string keys of the path in Cocoa, in Swift the keys of the path are strongly typed. </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Book</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> authors: [<span class="hljs-type"><span class="hljs-type">Person</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> primaryAuthor: <span class="hljs-type"><span class="hljs-type">Person</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> authors.first! } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> abelson = <span class="hljs-type"><span class="hljs-type">Person</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Harold Abelson"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sussman = <span class="hljs-type"><span class="hljs-type">Person</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Gerald Jay Sussman"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sicp = <span class="hljs-type"><span class="hljs-type">Book</span></span>(title: <span class="hljs-string"><span class="hljs-string">"Structure and Interpretation of Computer Programs"</span></span>, authors: [abelson, sussman])</code> </pre> <br><p>  Path keys can be specified starting from the root type and down to any combination of properties and names. </p><br><p>  Writing the path key begins with backslash: <code>\Book.title</code> .  Any type in Swift accepts <code>[keyPath: ‚Ä¶]</code> - subscript to get or set the value for the desired path key. </p><br><pre> <code class="hljs tex">sicp[keyPath: <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Book</span></span></span></span>.title] //        sicp[keyPath: <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Book</span></span></span></span>.primaryAuthor.name]</code> </pre> <br><p>  Path keys are a <code>KeyPath</code> object that can be stored and manipulated.  For example, you can add additional segments to the key path to go further. </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> authorKeyPath = \Book.<span class="hljs-function"><span class="hljs-function">primaryAuthor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">of: authorKeyPath</span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">let</span></span></span><span class="hljs-function"> nameKeyPath</span></span> = authorKeyPath.appending(path: \.name) <span class="hljs-comment"><span class="hljs-comment">//          sicp[keyPath: nameKeyPath]</span></span></code> </pre> <br><h3 id="sabskripty-v-klyuchah-putey">  Subscripts in path keys </h3><br><p>  Subscript notation can also be used in path keys.  Quite a convenient way to work with collections, arrays or dictionaries.  This functionality is not yet implemented in the current snapshot. </p><br><pre> <code class="hljs pgsql">//sicp[keyPath: \Book.authors[<span class="hljs-number"><span class="hljs-number">0</span></span>].name] // <span class="hljs-type"><span class="hljs-type">INTERNAL</span></span> ERROR: feature <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> implemented: non-property key <span class="hljs-type"><span class="hljs-type">path</span></span> component</code> </pre> <br><h1 id="arhivirovanie-i-serializaciya">  Archiving and serialization </h1><br><p>  <a href="">SE-0166: Swift Archival &amp; Serialization</a> defines how types in Swift (classes, structures, and enums) will serialize and archive themselves.  Types can make themselves (expanded) archived by implementing the <code>Codable</code> protocol. </p><br><p>  In most cases, implementing the <code>Codable</code> protocol is all that is required.  The compiler can generate the rest of the implementation itself only if all members of the type implement <code>Codable</code> .  You can also override the standard behavior, if you need to change how it is, the type serializes itself.  There are many nuances in this topic - be sure to read the proposal for further details. </p><br><pre> <code class="hljs pgsql">//     (   )   Codable struct Card: Codable { enum Suit: String, Codable { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> clubs, spades, hearts, diamonds } enum Rank: <span class="hljs-type"><span class="hljs-type">Int</span></span>, Codable { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ace = <span class="hljs-number"><span class="hljs-number">1</span></span>, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king } var suit: Suit var rank: Rank } let hand = [Card(suit: .clubs, rank: .ace), Card(suit: .hearts, rank: .queen)]</code> </pre> <br><h3 id="kodirovanie">  Coding </h3><br><p>  When you have a value that implements <code>Codable</code> , you need to pass it on to the encoder in order to archive it. </p><br><p>  You can write your own encoders and decoders that use the infrastructure from <code>Codable</code> , but Swift will be supplied built-in for JSON ( <code>JSONEncoder</code> and <code>JSONDecoder</code> ) and for the property list ( <code>PropertyListEncoder</code> and <code>PropertyListDecoder</code> ).  They are defined in <a href="">SE-0167</a> .  <code>NSKeyedArchiver</code> will also support all <code>Codable</code> types. </p><br><pre> <code class="hljs haskell"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation var encoder = JSONEncoder() //   JSONEncoder    encoder.dataEncodingStrategy encoder.dateEncodingStrategy encoder.nonConformingFloatEncodingStrategy encoder.outputFormatting encoder.userInfo let jsonData = try encoder.encode(<span class="hljs-title"><span class="hljs-title">hand</span></span>) String(<span class="hljs-title"><span class="hljs-title">data</span></span>: <span class="hljs-title"><span class="hljs-title">jsonData</span></span>, <span class="hljs-title"><span class="hljs-title">encoding</span></span>: .<span class="hljs-title"><span class="hljs-title">utf8</span></span>)</code> </pre> <br><h3 id="dekodirovanie">  Decoding </h3><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> decoder = <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> decoded = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> decoder.decode([<span class="hljs-type"><span class="hljs-type">Card</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, from: jsonData)</code> </pre> <br><h1 id="uluchsheniya-v-dictionary-i-set">  <code>Dictionary</code> and <code>Set</code> Improvements </h1><br><p>  <a href="">SE-0165</a> adds several improvements for <code>Dictionary</code> and <code>Set</code> . </p><br><h3 id="inicializator-prinimayuschiy-posledovatelnost">  Sequence initializer </h3><br><p>  Creating a dictionary from a sequence of key-value pairs. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> names = [<span class="hljs-string"><span class="hljs-string">"Cagney"</span></span>, <span class="hljs-string"><span class="hljs-string">"Lacey"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bensen"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dict = <span class="hljs-type"><span class="hljs-type">Dictionary</span></span>(uniqueKeysWithValues: <span class="hljs-built_in"><span class="hljs-built_in">zip</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>..., names)) dict[<span class="hljs-number"><span class="hljs-number">2</span></span>]</code> </pre> <br><h3 id="inicializator-sliyaniya-i-metod-sliyaniya">  Merge initializer and merge method </h3><br><p>  Now you can determine how duplicate keys will be processed when a dictionary is created from a sequence or a sequence is merged into the current dictionary. </p><br><pre> <code class="hljs pgsql">let duplicates = [("a", <span class="hljs-number"><span class="hljs-number">1</span></span>), ("b", <span class="hljs-number"><span class="hljs-number">2</span></span>), ("a", <span class="hljs-number"><span class="hljs-number">3</span></span>), ("b", <span class="hljs-number"><span class="hljs-number">4</span></span>)] let letters = <span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>(duplicates, uniquingKeysWith: { (first, _) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> first }) letters let defaults = ["foo": <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, "bar": <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, "baz": <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>] var <span class="hljs-keyword"><span class="hljs-keyword">options</span></span> = ["foo": <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, "bar": <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>] //      : error: generic parameter <span class="hljs-string"><span class="hljs-string">'S'</span></span> could <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> be inferred //       https://bugs.swift.org/browse/SR<span class="hljs-number"><span class="hljs-number">-922</span></span> //<span class="hljs-keyword"><span class="hljs-keyword">options</span></span>.merge(defaults) { (<span class="hljs-built_in"><span class="hljs-built_in">old</span></span>, _) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">old</span></span> }</code> </pre> <br><h3 id="sabskript-so-znacheniem-po-umolchaniyu">  Subscript with default </h3><br><p>  You can define a default value for non-existing keys as a subscript argument, making the return type not optional. </p><br><pre> <code class="hljs objectivec">dict[<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-string"><span class="hljs-string">"(unknown)"</span></span>] <span class="hljs-comment"><span class="hljs-comment">//      </span></span></code> </pre> <br><p>  This is especially important when you need to mutate a value via subscript: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> source = <span class="hljs-string"><span class="hljs-string">"how now brown cow"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> frequencies: [<span class="hljs-type"><span class="hljs-type">Character</span></span>: <span class="hljs-type"><span class="hljs-type">Int</span></span>] = [:] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> source { frequencies[<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span> } frequencies</code> </pre> <br><h3 id="specifichnye-dlya-slovarya-map-i-filter">  Dictionary-specific <code>map</code> and <code>filter</code> </h3><br><p>  <code>filter</code> returns a <code>Dictionary</code> and not an <code>Array</code> .  Similarly, the new <code>mapValues</code> method transforms values <code>mapValues</code> preserving its structure. </p><br><pre> <code class="hljs pgsql">let filtered = dict.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span> { <span class="hljs-meta"><span class="hljs-meta">$0</span></span>.key % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>: filtered) let mapped = dict.mapValues { <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.uppercased() } mapped</code> </pre> <br><p>  <code>Set.filter</code> also returns a <code>Set</code> and not an <code>Array</code> . </p><br><pre> <code class="hljs pgsql">let <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] let filteredSet = <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span> { <span class="hljs-meta"><span class="hljs-meta">$0</span></span> % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>: filteredSet)</code> </pre> <br><h3 id="gruppirovka-posledovatelnosti">  Sequence grouping </h3><br><p>  Grouping a sequence of values ‚Äã‚Äãinto bouquets.  break the words in the list by their first letter. </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contacts = [<span class="hljs-string"><span class="hljs-string">"Julia"</span></span>, <span class="hljs-string"><span class="hljs-string">"Susan"</span></span>, <span class="hljs-string"><span class="hljs-string">"John"</span></span>, <span class="hljs-string"><span class="hljs-string">"Alice"</span></span>, <span class="hljs-string"><span class="hljs-string">"Alex"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> grouped = Dictionary(grouping: contacts, <span class="hljs-keyword"><span class="hljs-keyword">by</span></span>: { $<span class="hljs-number"><span class="hljs-number">0.f</span></span>irst! }) grouped</code> </pre> <br><h1 id="metod-mutablecollectionswapat">  <code>MutableCollection.swapAt</code> method </h1><br><p>  <a href="">SE-0173</a> introduces a new method for exchanging two items in a collection.  Unlike the existing <code>swap(_:_:)</code> , the <code>swapAt(_:_:)</code> method <code>swapAt(_:_:)</code> accepts indices of the elements that need to be exchanged, and not the elements themselves (through <code>inout</code> arguments). </p><br><p>  The reason for adding this method is that exchanging with two <code>inout</code> arguments is incompatible. <br>  with the new rules of access to the memory <a href="">SE-0176</a> .  The existing <code>swap(_:_:)</code> function <code>swap(_:_:)</code> will no longer work for the exchange of two elements of the same collection. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] numbers.swapAt(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Will be illegal in Swift 4 (not implemented yet) swap(&amp;numbers[3], &amp;numbers[4]) numbers</span></span></code> </pre> <br><h1 id="reduce-s-podderzhkoy-inout">  <code>reduce</code> with <code>inout</code> support </h1><br><p>  <a href="">SE-0171</a> adds a variant of the <code>reduce</code> method in which the result is passed as <code>inout</code> to the <code>combine</code> function.  This can be a significant acceleration for algorithms that use <code>reduce</code> to incrementally build sequences, by eliminating copying and intermediate results. </p><br><p>  SE-0171 not yet implemented </p><br><pre> <code class="hljs perl">//     extension Sequence where Iterator.Element: Equatable { func uni<span class="hljs-string"><span class="hljs-string">q()</span></span> -&gt; [Iterator.Element] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reduce(into: []) { (result: inout [Iterator.Element], element) in <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> result.last != element { result.append(element) } } } } [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>].uni<span class="hljs-string"><span class="hljs-string">q()</span></span></code> </pre> <br><h1 id="generiki-v-sabskriptah">  Generics in subscripts </h1><br><p>  As represented in <a href="">SE-0148</a> , subscript can now accept and return arguments in the form of generics. </p><br><p>  A canonical example is the type that represents <code>JSON</code> data: you can define a subscript with generic so that the context of the calling code can determine the expected return type. </p><br><pre> <code class="hljs pgsql">struct <span class="hljs-type"><span class="hljs-type">JSON</span></span> { fileprivate var <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>: [String:<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>] init(<span class="hljs-keyword"><span class="hljs-keyword">dictionary</span></span>: [String:<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>]) { self.storage = <span class="hljs-keyword"><span class="hljs-keyword">dictionary</span></span> } subscript&lt;T&gt;(key: String) -&gt; T? { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>[key] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? T } } let <span class="hljs-type"><span class="hljs-type">json</span></span> = <span class="hljs-type"><span class="hljs-type">JSON</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">dictionary</span></span>: [ "name": "Berlin", "country": "de", "population": <span class="hljs-number"><span class="hljs-number">3</span></span>_500_500 ]) //     <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">Int</span></span> let population: <span class="hljs-type"><span class="hljs-type">Int</span></span>? = <span class="hljs-type"><span class="hljs-type">json</span></span>["population"]</code> </pre> <br><p>  Another example is a subscript in a <code>Collection</code> that takes a sequence of indices and returns an array of values ‚Äã‚Äãof these indices. </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">subscript</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Indices</span></span>: <span class="hljs-type"><span class="hljs-type">Sequence</span></span>&gt;(<span class="hljs-built_in"><span class="hljs-built_in">indices</span></span> <span class="hljs-built_in"><span class="hljs-built_in">indices</span></span>: <span class="hljs-type"><span class="hljs-type">Indices</span></span>) -&gt; [<span class="hljs-type"><span class="hljs-type">Iterator</span></span>.<span class="hljs-type"><span class="hljs-type">Element</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">Indices</span></span>.<span class="hljs-type"><span class="hljs-type">Iterator</span></span>.<span class="hljs-type"><span class="hljs-type">Element</span></span> == <span class="hljs-type"><span class="hljs-type">Index</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result: [<span class="hljs-type"><span class="hljs-type">Element</span></span>] = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">indices</span></span> { result.append(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>[index]) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> words = <span class="hljs-string"><span class="hljs-string">"Lorem ipsum dolor sit amet"</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">split</span></span>(separator: <span class="hljs-string"><span class="hljs-string">" "</span></span>) words[<span class="hljs-built_in"><span class="hljs-built_in">indices</span></span>: [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>]]</code> </pre> <br><h1 id="mostik-dlya-nsnumber">  Bridge for <code>NSNumber</code> </h1><br><p>  <a href="">SE-0170</a> corrects some dangerous behavior with a bridge between the numeric type in Swift and <code>NSNumber</code> . </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation let n = NSNumber(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: UInt32(<span class="hljs-number"><span class="hljs-number">543</span></span>)) let v = n <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">Int8</span></span> // nil <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Swift <span class="hljs-number"><span class="hljs-number">4.</span></span> This would be <span class="hljs-number"><span class="hljs-number">31</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Swift <span class="hljs-number"><span class="hljs-number">3</span></span> (try it!).</code> </pre> <br><h1 id="ekzemplyary-klassov-i-podtipov">  Instances of classes and subtypes </h1><br><p>  Now you can write the equivalent of Objective-C <code>UIViewController &lt;SomeProtocol&gt; *</code> code in Swift, <br>  for example, declare a variable with a specific type and link it to one or several protocols simultaneously ( <a href="">SE-0156</a> ).  <code>let variable: SomeClass &amp; SomeProtocol1 &amp; SomeProtocol2</code> </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Cocoa protocol HeaderView {} <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ViewController: NSViewController { let <span class="hljs-keyword"><span class="hljs-keyword">header</span></span>: NSView &amp; HeaderView init(<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>: NSView &amp; HeaderView) { self.<span class="hljs-keyword"><span class="hljs-keyword">header</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">header</span></span> super.init(nibName: nil, bundle: nil)! } required init(coder decoder: NSCoder) { fatalError("not implemented") } } //    NSView     // ViewController(<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>: NSView()) // error: argument <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'NSView'</span></span> does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> conform <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> expected <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'NSView &amp; HeaderView'</span></span> //    NSView ()      <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> NSImageView: HeaderView {} ViewController(<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>: NSImageView()) // </code> </pre> </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/329580/">https://habr.com/ru/post/329580/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329570/index.html">Security Week 21: BlueDoom protects against WannaCry, crypto-fiber threatens medical equipment, subtitles - new attack vector</a></li>
<li><a href="../329572/index.html">Experience of transition from Waterfall to RUP methodology for the implementation of large IT projects</a></li>
<li><a href="../329574/index.html">Smart IDReader SDK - how to add recognition in an iOS application in 5 minutes - now on Github</a></li>
<li><a href="../329576/index.html">Modeling designs. Requirements for the modeler</a></li>
<li><a href="../329578/index.html">Three cycles in the Lorenz attractor</a></li>
<li><a href="../329582/index.html">Creating a web application on Go in 2017</a></li>
<li><a href="../329584/index.html">Creating a web application on Go in 2017. Part 2</a></li>
<li><a href="../329592/index.html">learnopengl. Lesson 2.1 - Colors</a></li>
<li><a href="../329594/index.html">Is there too much text in your game?</a></li>
<li><a href="../329596/index.html">A bit of reverse-engineering USB flash on the SK6211 controller</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>