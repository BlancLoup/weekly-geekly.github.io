<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C # for AS3 developers. Part 4: Abstract Classes and Functions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of the article From AS3 to C #, Part 4: Abstract Classes and Functions 

 In this article, we will finally begin to understand the nuances...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C # for AS3 developers. Part 4: Abstract Classes and Functions</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/29c/b3e/6f6/29cb3e6f6df90840babecade2674654e.png" alt="image"><br><br>  <i>Translation of the article <a href="http://jacksondunstan.com/articles/2720">From AS3 to C #, Part 4: Abstract Classes and Functions</a></i> <br><br>  In this article, we will finally begin to understand the nuances of C #, which have no analogues in AS3.  And first we will look at abstract classes and functions.  In AS3, it was necessary to come up with workarounds so that they work correctly at runtime (run-time).  But C # provides the ability to make them work at the compile-time (compile-time), and today we will analyze these methods. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Static initializers</b> <br><br>  But, before that, I would like to talk about one feature of the AS3 classes, which I forgot to talk about in previous articles: static initializers (static initializers), also known as class initializers, class constructors, or static constructors.  This is a function that will be called automatically when static class fields need to be initialized.  Here is how it looked in AS3: <br><br><pre><code class="actionscript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> NEXT_ID:int; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id:int; <span class="hljs-comment"><span class="hljs-comment">// static initializer: { NEXT_ID = 1; } // instance constructor function Person() { id = NEXT_ID++; } }</span></span></code> </pre> <br><br>  Static initializers are not often used, because  we have the ability to declare and initialize fields at the same time.  For example: <br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> NEXT_ID:int = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><br>  But, they can be useful if you need to implement a more complex logic of application behavior.  In any case, here's how it can be implemented in C #: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Person</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NextID; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-comment"><span class="hljs-comment">// static initializer: static Person() { NextID = 1; } // instance constructor Person() { id = NextID++; } }</span></span></code> </pre><br><br>  Static initializers in C # are called ‚Äústatic constructors‚Äù and work by analogy with ordinary constructors, but not for individual instances of classes, but for the entire class.  The syntax for such constructors is the same as usual, but the static keyword is added at the beginning of the constructor declaration.  These constructors cannot have access modifiers (private, public, etc.) and they cannot accept incoming parameters. <br><br>  <b>Abstract classes</b> <br><br>  Now, let's talk about abstract classes: these are classes that cannot be instantiated directly.  To create an instance of an abstract class, you will need to create a non-abstract class that will inherit from the abstract, and instantiate this non-abstract class.  By default, in AS3 there is no such functionality at the compilation stage, but, there is a rather popular way to get around this limitation: <br><br><pre> <code class="actionscript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExtrudedShape</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> depth:int; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> HIDDEN_KEY:Object = {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExtrudedShape</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ABSTRACT:Object, depth:int)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ABSTRACT != HIDDEN_KEY) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentError(<span class="hljs-string"><span class="hljs-string">"ExtrudedShape is an abstract class"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.depth = depth; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: int </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: int </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> depth * area; } }</code> </pre><br><br>  In this case, creating an ExtrudedShape directly is still possible, and such code will be compiled: <br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shape:ExtrudedShape = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExtrudedShape(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre><br><br>  But at the execution stage, the check of the first argument will work, which will lead to the appearance of the error ArgumentError, and the ExtrudedShape instance will not be created.  This will happen because classes not inherited from ExtrudedShape will not have access to the protected HIDDEN_KEY constant, but at the same time, classes derived from ExtrudedShape will be able to access this variable for transmission to the parent constructor: <br><br><pre> <code class="actionscript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExtrudedCircle</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExtrudedShape</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExtrudedCircle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(depth:int)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(HIDDEN_KEY, depth); } }</code> </pre><br><br>  This is a fairly effective way to implement abstract classes at the playback stage, but C # provides the ability to do all the work at the compilation stage: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExtrudedShape</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> depth { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } ExtrudedShape(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> depth) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.depth = depth; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Area { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Volume { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> depth * Area; } } }</code> </pre><br><br>  Note the use of the abstract keyword at the beginning of the class.  It means that the compiler should not allow the creation of this class directly.  This approach does not require additional code or ‚Äúworkarounds‚Äù that are required in AS3 (derived classes do not need to use HIDDEN_KEY, and their initialization and declaration looks exactly the same as other classes): <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExtrudedCircle</span></span> : <span class="hljs-title"><span class="hljs-title">ExtrudedShape</span></span> { ExtrudedCircle(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> depth) : <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>(depth) { } }</code> </pre><br><br>  <b>Abstract functions</b> <br><br>  Abstract functions are used in cases where it is necessary to indicate that the implementation of a particular function must be redefined in a child class.  And again, in AS3 there is no possibility to implement this at the compilation stage, but, as in the case of abstract classes, there is a way to get around this restriction: <br><br><pre> <code class="actionscript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExtrudedShape</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> depth:int; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> HIDDEN_KEY:Object = {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExtrudedShape</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ABSTRACT:Object, depth:int)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ABSTRACT != HIDDEN_KEY) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentError(<span class="hljs-string"><span class="hljs-string">"ExtrudedShape is an abstract class"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.depth = depth; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: int </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">"'get area' is an abstract function"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: int </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> depth * area; } }</code> </pre><br><br>  In this example, the ExtrudedShape class does not implement the functionality of the get area function, since it does not know anything about it.  In this version, calling the ExtrudedShape class get area function will cause an error.  This approach allows to realize abstract functions at the stage of reproduction, but not at the stage of compilation.  For example, the following code will successfully compile without implementing the get area function: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExtrudedCircle</span></span> <span class="hljs-title"><span class="hljs-title">extends</span></span> <span class="hljs-title"><span class="hljs-title">ExtrudedShape</span></span> { }</code> </pre><br><br>  Instead, in C # we can simply use the abstract keyword: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExtrudedShape</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> depth { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } ExtrudedShape(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> depth) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.depth = depth; } <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Area { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Volume { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> depth * Area; } } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExtrudedCircle</span></span> : <span class="hljs-title"><span class="hljs-title">ExtrudedShape</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> area; <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Area { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> area; } } }</code> </pre><br><br>  The same keyword will be used for normal functions (not the getter / setter): <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameEntity</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TakeDamage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> damage</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Enemy</span></span> : <span class="hljs-title"><span class="hljs-title">GameEntity</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> health; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TakeDamage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> damage</span></span></span><span class="hljs-function">)</span></span> { health -= damage; } }</code> </pre><br><br>  Today we discussed abstract classes and functions, as well as static initializers.  To consolidate, let's compare the features of the implementation of this functionality in C # and AS3: <br><br><table><tbody><tr><td><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">// // C# // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">// // Abstract class abstract class GameEntity { private static int NextID; protected int health; int id; static GameEntity() { NextID = 1; } GameEntity(int health) { this.health = health; this.id = NextID++; } // Abstract property bool Friendly { abstract get; } // Abstract function abstract void TakeDamage(int amount) { } } // Non-abstract ("concrete") class class Enemy : GameEntity { Enemy(int health) : base(health) { } // Implemented abstract property override bool Friendly { get { return false; } } // Implemented abstract function override void TakeDamage(int amount) { health -= amount; } }</span></span></code> </pre><br></td><td><pre> <code class="actionscript hljs"><span class="hljs-comment"><span class="hljs-comment">///////// // AS3 // ///////// // Abstract class - only enforced at run-time class GameEntity { private static var NEXT_ID:int; protected static const HIDDEN_KEY:Object = {}; protected var health:int; var id:int; // Static initializer { NEXT_ID = 1; } function GameEntity(ABSTRACT:Object, health:int) { if (ABSTRACT != HIDDEN_KEY) { throw new ArgumentError("GameEntity is abstract"); } this.health = health; this.id = NEXT_ID++; } // Abstract property/getter - only enforced at run-time function get friendly(): Boolean { throw new Error("'get friendly' is abstract"); return false; } // Abstract function - only enforced at run-time function takeDamage(amount:int): void { throw new Error("takeDamage is abstract"); } } // Non-abstract ("concrete") class class Enemy extends GameEntity { function Enemy(health:int) { super(HIDDEN_KEY, health); } // Implemented abstract property override function get friendly(): Boolean { return false; } // Implemented abstract function override function takeDamage(amount:int): void { health -= amount; } }</span></span></code> </pre><br></td></tr></tbody></table><br><br>  In the next article we will talk about destructors, tricks when working with constructor overload and much more. <br><br>  Stay with us! </div><p>Source: <a href="https://habr.com/ru/post/249045/">https://habr.com/ru/post/249045/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../249029/index.html">Xcode 6 Objective-C Modernization Tool</a></li>
<li><a href="../249031/index.html">The synapse ensemble is a structural unit of the neural network</a></li>
<li><a href="../249037/index.html">Scan and index pages in multiple languages</a></li>
<li><a href="../249039/index.html">How I implemented multilingualism on the site and in the project</a></li>
<li><a href="../249041/index.html">YouTube abandoned Flash in favor of HTML5 by default.</a></li>
<li><a href="../249047/index.html">Sass-architecture of your project</a></li>
<li><a href="../249051/index.html">Do not use MediaPlayer and MediaMetadataRetriever in Android</a></li>
<li><a href="../249053/index.html">How virtual reality came to the project on Unity</a></li>
<li><a href="../249055/index.html">Universal way to monitor Asterisk using Zabbix</a></li>
<li><a href="../249057/index.html">What should be said instead of ‚Äúfool himself!‚Äù Or 4 stories about the power of one question</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>