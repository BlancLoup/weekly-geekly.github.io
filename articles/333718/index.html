<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a GLSL smoke shader</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[The smoke on the KDPV is somewhat more complicated than that obtained in the tutorial.] 

 Smoke has always been surrounded by a halo of mystery. It'...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a GLSL smoke shader</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/fa8/0b1/3d4/fa80b13d4bf9dc4cd5dbe9d8f58e22d5.jpg" alt="image"><br>  <i>[The smoke on the KDPV is somewhat more complicated than that obtained in the tutorial.]</i> <br><br>  Smoke has always been surrounded by a halo of mystery.  It's nice to look at him, but it's hard to model.  Like many other physical phenomena, smoke is a chaotic system that is very difficult to predict.  The simulation state is highly dependent on the interaction between the individual particles. <br><br>  That is why it is so difficult to process it in a video processor: the smoke can be divided into the behavior of a single particle, repeated millions of times in different places. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this tutorial, I will talk in detail about creating a smoke shader from scratch and teach you some useful shader design techniques so that you can expand your arsenal and create your own effects. <br><a name="habracut"></a><br><h2>  What we learn </h2><br>  Here is the final result we will strive for: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/tutsplus/embed/preview/vLmxpb" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  We implement the algorithm described in the <a href="http://www.dgp.toronto.edu/people/stam/reality/Research/pdf/GDC03.pdf" rel="external">work of Jos Stam on the dynamics of liquids in games in real time</a> .  In addition, we learn how to <em>render into texture</em> , this technique is also called <em>frame buffers</em> .  It is very useful in programming shaders, because it allows you to create many effects. <br><br><h2>  Training </h2><br>  The examples and code implementations of this tutorial use JavaScript and <a href="http://threejs.org/" rel="external">ThreeJS</a> , but you can use it on any platform with shader support.  (If you are unfamiliar with the basics of programming, then you should study <a href="https://habrahabr.ru/post/333002/">this tutorial</a> .) <br><br>  All code samples are stored on CodePen, but they can also be found in <a href="https://github.com/OmarShehata/Beginners-Guide-to-Shaders" rel="external">the GitHub repository</a> linked to the article (there it may be easier to read the code). <br><br><h2>  Theory and Foundations </h2><br>  The algorithm from the work of Jos Stam gives priority to speed and visual quality to the detriment of physical accuracy, this is what we need in games. <br><br>  This job may seem much more difficult than it actually is, especially if you are not familiar with differential equations.  However, the meaning of the technique is summarized in this figure: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8d8/0cb/9c3/8d80cb9c362b0f7ecd5f1c64d4b26b4f.png"><br>  <i>Thanks to scattering, each cell exchanges its density with its neighbors.</i> <br><br>  This is all that is needed to create a realistic looking smoke effect: the value in each cell at each iteration ‚Äúdissipates‚Äù into all its neighboring cells.  This principle is not always clear immediately, if you want to experiment with an example, you can <a href="http://codepen.io/tutsplus/full/RrVpxd/">explore the interactive demo</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be5/b0e/8ef/be5b0e8ef8f879330e4bf2d604f734b8.png"><br>  <a href="http://codepen.io/tutsplus/full/RrVpxd/">View an interactive demo on CodePen</a> . <br><br>  When you click on any cell, it is assigned the value <code>100</code> .  You see how each cell gradually transfers its value to its neighbors.  The easiest way to see this is by clicking <strong>Next</strong> to view individual frames.  Toggle <strong>Display Mode</strong> to see how it will look when these numbers correspond to color values. <br><br>  The above demo runs on the central processor, the loop goes through each cell.  Here‚Äôs what this cycle looks like: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//W =     //H =   //f =  / //     newGrid,    ,       for(var r=1; r&lt;W-1; r++){ for(var c=1; c&lt;H-1; c++){ newGrid[r][c] += f * ( gridData[r-1][c] + gridData[r+1][c] + gridData[r][c-1] + gridData[r][c+1] - 4 * gridData[r][c] ); } }</span></span></code> </pre> <br>  This code snippet is the basis of the algorithm.  Each cell receives a part of the values ‚Äã‚Äãof the four neighboring cells minus its own value, where <code>f</code> is a coefficient less than 1. We multiply the current value of the cell by 4 so that it dissipates from high to low values. <br><br>  To make this clear, consider the following situation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/912/255/a35/912255a35d52037c49db3d039eb8c492.png"><br><br>  Take a <strong>cell in the middle</strong> (at position <code>[1,1]</code> in the grid) and apply the above scattering equation.  Suppose that <code>f</code> is <code>0.1</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">0.1</span></span> * (<span class="hljs-number"><span class="hljs-number">100</span></span>+<span class="hljs-number"><span class="hljs-number">100</span></span>+<span class="hljs-number"><span class="hljs-number">100</span></span>+<span class="hljs-number"><span class="hljs-number">100</span></span><span class="hljs-number"><span class="hljs-number">-4</span></span>*<span class="hljs-number"><span class="hljs-number">100</span></span>) = <span class="hljs-number"><span class="hljs-number">0.1</span></span> * (<span class="hljs-number"><span class="hljs-number">400</span></span><span class="hljs-number"><span class="hljs-number">-400</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  No scattering occurs because all cells have the same values! <br><br>  Then consider the <em>cell in the upper left corner</em> (we assume that the values ‚Äã‚Äãof all the cells outside the grid shown are <code>0</code> ): <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">0.1</span></span> * (<span class="hljs-number"><span class="hljs-number">100</span></span>+<span class="hljs-number"><span class="hljs-number">100</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">-4</span></span>*<span class="hljs-number"><span class="hljs-number">0</span></span>) = <span class="hljs-number"><span class="hljs-number">0.1</span></span> * (<span class="hljs-number"><span class="hljs-number">200</span></span>) = <span class="hljs-number"><span class="hljs-number">20</span></span></code> </pre> <br>  So, now we have a net <em>gain of</em> 20!  Let's look at the last case.  After one time step (after applying this formula to all cells), our grid will look like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/75e/091/f08/75e091f08116693753fd6b11d154f50f.png"><br><br>  Let's look again at the scatter in the <em>middle cell</em> : <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">0.1</span></span> * (<span class="hljs-number"><span class="hljs-number">70</span></span>+<span class="hljs-number"><span class="hljs-number">70</span></span>+<span class="hljs-number"><span class="hljs-number">70</span></span>+<span class="hljs-number"><span class="hljs-number">70</span></span><span class="hljs-number"><span class="hljs-number">-4</span></span>*<span class="hljs-number"><span class="hljs-number">100</span></span>) = <span class="hljs-number"><span class="hljs-number">0.1</span></span> * (<span class="hljs-number"><span class="hljs-number">280</span></span> - <span class="hljs-number"><span class="hljs-number">400</span></span>) = <span class="hljs-number"><span class="hljs-number">-12</span></span></code> </pre> <br>  We got a net <em>decrease</em> of 12!  Therefore, the values ‚Äã‚Äãalways change from large to small. <br><br>  Now, if we want more realism, we need to reduce the size of the cells (which can be done in the demo), but at a certain stage everything will start to slow down a lot, because we have to consistently pass through each cell.  Our goal is to write this algorithm in a shader that can use the power of a video processor to process all cells (like pixels) simultaneously and in parallel. <br><br>  So, to summarize: our common technique is that each pixel, each frame loses some of its color value and passes it to neighboring pixels.  Sounds easy, right?  Let's implement this system and see what happens! <br><br><h2>  Implementation </h2><br>  We start with a basic shader that draws the entire screen.  To make sure that it works, we will try to paint over the screen with a solid black color (or any other).  Here‚Äôs what the scheme I use in Javascript looks like. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/tutsplus/embed/preview/GomWya" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Click the buttons at the top to see the HTML, CSS and JS code. <br><br>  Our shader is simple: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">uniform</span></span> vec2 res; <span class="hljs-attribute"><span class="hljs-attribute">void</span></span> main() { <span class="hljs-attribute"><span class="hljs-attribute">vec2</span></span> pixel = gl_FragCoord.xy / res.xy; <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  <code>res</code> and <code>pixel</code> tell us the coordinates of the current pixel.  We pass the screen sizes to <code>res</code> as a uniform variable.  (While we do not use them, but soon they will be useful.) <br><br><h3>  Step 1: Move Values ‚Äã‚ÄãBetween Pixels </h3><br>  I repeat once again what we want to implement: <br><br><blockquote>  <em>Our common technique is that each pixel each frame loses a part of its color value and transmits it to neighboring pixels.</em> </blockquote><br>  In this formulation, the implementation of the shader is <em>impossible</em> .  Do you understand why?  Remember, the only thing that a shader can do is return the color value of the current pixel being processed.  That is, we need to reformulate the task in such a way that the solution affects only the current pixel.  We can say: <br><br><blockquote>  Each pixel should <strong>get a</strong> little color of its neighbors and lose a little of its own. </blockquote><br>  Now this solution can be implemented.  However, if you try to do this, then we will come across a fundamental problem ... <br><br>  Consider a simpler case.  Suppose we need a shader, gradually repainting the image in red.  You can write the following shader: <br><br><pre> <code class="hljs cs">uniform vec2 res; uniform sampler2D texture; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { vec2 pixel = gl_FragCoord.xy / res.xy; gl_FragColor = texture2D( tex, pixel );<span class="hljs-comment"><span class="hljs-comment">//     gl_FragColor.r += 0.01;//    }</span></span></code> </pre> <br>  It can be expected that each frame of the red component of each pixel will increase by <code>0.01</code> .  Instead, we get a static image, in which all the pixels are just a little redder than at the beginning.  The red component of each pixel will increase only once, despite the fact that the shader is executed every frame. <br><br>  Do you understand why this happens? <br><br><h4>  Problem </h4><br>  The problem is that any operation that we perform with a shader is transmitted to the screen, and then disappears forever.  Now our process looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e8d/7ba/1a3/e8d7ba1a357c4cdee6b702a66d876769.png"><br><br>  We pass in uniform variables and texture to the shader, it makes the pixels a little redder, draws them on the screen, and then it starts all over again.  <em>Everything we draw in the shader is cleared by the next draw step.</em> <br><br>  We need something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ac3/27d/717/ac327d71763d30c1dedc8d78308fa6b4.png"><br><br>  Instead of direct rendering onto the screen, we can draw pixels into the texture, and then draw <em>that texture</em> on the screen.  The screen will display the same image, except that we can now send the output as input.  So you can get shaders that accumulate or distribute values, rather than just dropping each frame.  This is what is called ‚Äúframe buffer focus.‚Äù <br><br><h4>  Focus with frame buffer </h4><br>  Common technology will be the same for all platforms.  Go <em>‚Äúrender to texture‚Äù</em> for any language or tool you are using and learn the implementation details.  You can also see how to use <em>frame buffer objects</em> , which are just another name for rendering to a buffer instead of a screen. <br><br>  In ThreeJS, the analogue of this function is <a href="http://threejs.org/docs/" rel="external">WebGLRenderTarget</a> .  That is what we will use as an intermediate texture for rendering.  However, there is a small obstacle: <em>you can not read and render in one texture at the same time</em> .  The easiest way around this limitation is to use two textures. <br><br>  Let A and B be the two textures we created.  Then the method will be as follows: <br><br><ol><li>  We transfer A through a shader, we render in B. </li><li>  Render B to the screen. </li><li>  Pass B through the shader, render it in A. </li><li>  Render A to the screen. </li><li>  Repeat 1. </li></ol><br>  A shorter code will be as follows: <br><br><ol><li>  We transfer A through a shader, we render in B. </li><li>  Render B to the screen. </li><li>  Change A and B <em>(that is, variable A now contains the texture found in B, and vice versa).</em> </li><li>  Repeat 1. </li></ol><br>  That's all.  Here is the implementation of this algorithm in ThreeJS: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/tutsplus/embed/preview/gPWmoN" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  The new shader code is in the <strong>HTML</strong> tab. <br><br>  We still see the black screen from which we started.  The shader is also not too different: <br><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> vec2 res; <span class="hljs-comment"><span class="hljs-comment">//     uniform sampler2D bufferTexture; //   void main() { vec2 pixel = gl_FragCoord.xy / res.xy; gl_FragColor = texture2D( bufferTexture, pixel ); }</span></span></code> </pre> <br>  In addition, now we have added this line ( <a href="http://codepen.io/tutsplus/pen/gPWmoN">test!</a> ): <br><br><pre> <code class="hljs">gl_FragColor.r += 0.01;</code> </pre> <br>  You will see that the screen gradually turns red.  This is a rather important step, so we can briefly dwell on it and compare it with how the algorithm worked initially. <br><br>  <strong>Task:</strong> What happens if we <code>gl_FragColor.r += pixel.x;</code>  in the frame buffer example, unlike the original example?  Think a little about why the results are different, and why they are just like that. <br><br><h3>  Step 2: get the smoke source </h3><br>  Before we make everything move, we need to find a way to create smoke.  The simplest way is to manually fill in an arbitrary area in the shader with white. <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/         float dist = distance(gl_FragCoord.xy, res.xy/</span></span><span class="hljs-number"><span class="hljs-number">2.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(dist &lt; <span class="hljs-number"><span class="hljs-number">15.0</span></span>){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-number"><span class="hljs-number">15</span></span>  gl_FragColor.rgb = vec3(<span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  If we want to check the correctness of the frame buffer, we can try to <em>add</em> to the color value, and not just assign it.  You will see that the circle is gradually becoming whiter. <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/         float dist = distance(gl_FragCoord.xy, res.xy/</span></span><span class="hljs-number"><span class="hljs-number">2.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(dist &lt; <span class="hljs-number"><span class="hljs-number">15.0</span></span>){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-number"><span class="hljs-number">15</span></span>  gl_FragColor.rgb += <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">01</span></span>; }</code> </pre> <br>  Another way is to replace this fixed point with the position of the mouse.  We can pass the third value indicating whether the mouse button is down.  This way we can create smoke by pressing the left key.  Here is the implementation of this feature: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/tutsplus/embed/preview/PZmpEM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Click to create smoke. <br><br>  This is what our shader looks like: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/     uniform vec2 res; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   uniform sampler2D bufferTexture; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ x,y -  . z -  /</span></span> uniform vec3 smokeSource; void main() { vec2 pixel = gl_FragCoord.xy / res.xy; gl_FragColor = texture2D( bufferTexture, pixel ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         float dist = distance(smokeSource.xy,gl_FragCoord.xy); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(smokeSource.z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; dist &lt; <span class="hljs-number"><span class="hljs-number">15.0</span></span>){ gl_FragColor.rgb += smokeSource.z; } }</code> </pre> <br>  <strong>Task:</strong> do not forget that branching (conditional transitions) are usually expensive in shaders.  Can you rewrite the shader without using the if construct?  (The solution is in CodePen.) <br><br>  If you do not understand, then in the <a href="https://habrahabr.ru/post/333002/">previous tutorial</a> there is a detailed explanation of using the mouse in shaders (in the part about lighting). <br><br><h3>  Step 3: Dissipate Smoke </h3><br>  Now the simple, but the most interesting part!  We put everything together, we finally had to tell the shader: <em>each pixel should</em> receive <em>some of the color from its neighbors, and lose some of its own.</em> <br><br>  It expresses something like this: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/   float xPixel = 1.0/res</span></span>.x; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    float yPixel = <span class="hljs-number"><span class="hljs-number">1.0</span></span>/res.y; vec4 rightColor = texture2D(bufferTexture,vec2(pixel.x+xPixel,pixel.y)); vec4 leftColor = texture2D(bufferTexture,vec2(pixel.x-xPixel,pixel.y)); vec4 upColor = texture2D(bufferTexture,vec2(pixel.x,pixel.y+yPixel)); vec4 downColor = texture2D(bufferTexture,vec2(pixel.x,pixel.y-yPixel)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   gl_FragColor.rgb += <span class="hljs-number"><span class="hljs-number">14.0</span></span> * <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">016</span></span> * ( leftColor.rgb + rightColor.rgb + downColor.rgb + upColor.rgb - <span class="hljs-number"><span class="hljs-number">4.0</span></span> * gl_FragColor.rgb );</code> </pre> <br>  The <code>f</code> coefficient remains the same.  In this case, we have a time step ( <code>0.016</code> , that is, 1/60, because the program runs at 60 fps), and I picked up different numbers until I stopped at a value of <code>14</code> , which looks good.  Here is the result: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/tutsplus/embed/preview/OMmpQL" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h4>  Oh, oh, it's all stuck! </h4><br>  This is the same scattering equation that we used in the demo for the CPU, but our simulation stops!  What is the reason? <br><br>  It turns out that textures (like all numbers in a computer) have limited accuracy.  At some point, the coefficient we subtract becomes too small and rounds to 0, so the simulation stops.  To fix this, we need to check that it does not fall below any minimum value: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> factor = <span class="hljs-number"><span class="hljs-number">14.0</span></span> * <span class="hljs-number"><span class="hljs-number">0.016</span></span> * (leftColor.r + rightColor.r + downColor.r + upColor.r - <span class="hljs-number"><span class="hljs-number">4.0</span></span> * gl_FragColor.r); //       <span class="hljs-type"><span class="hljs-type">float</span></span> minimum = <span class="hljs-number"><span class="hljs-number">0.003</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (factor &gt;= -minimum &amp;&amp; factor &lt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>) factor = -minimum; gl_FragColor.rgb += factor;</code> </pre> <br>  I use the component <code>r</code> instead of <code>rgb</code> to get the coefficient, because it is easier to work with individual numbers and because all the components still have the same values ‚Äã‚Äã(because the smoke is white). <br><br>  Through trial and error, I found that a good threshold is <code>0.003</code> , at which the program does not stop.  My only concern is the coefficient with a negative value in order to guarantee its constant decrease.  By adding this fix, we get the following: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/tutsplus/embed/preview/BjRWYa" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Step 4: Smoke Up </h3><br>  But it still doesn‚Äôt look like smoke.  If we want it to go up, and not in all directions, we need to add weights.  If the lower pixels always influence more than other directions, then the pixels will seem to rise up. <br><br>  Experimenting with the coefficients, we can choose what looks very decent in this equation: <br><br><pre> <code class="hljs markdown">//   float factor = 8.0 <span class="hljs-bullet"><span class="hljs-bullet">* 0.016 *</span></span> ( leftColor.r + rightColor.r + downColor.r <span class="hljs-bullet"><span class="hljs-bullet">* 3.0 + upColor.r - 6.0 *</span></span> gl_FragColor.r );</code> </pre> <br>  And this is what a shader looks like: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/tutsplus/embed/preview/OMmpwJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h4>  Note on the scattering equation </h4><br>  I just played with the coefficients so that the rising smoke looked beautiful.  You can make him move in any other direction. <br><br>  It is important to add that it is very simple to ‚Äúblow up‚Äù the simulation.  (Try <a href="http://codepen.io/tutsplus/pen/OMmpwJ">changing the</a> value of <code>6.0</code> to <code>5.0</code> and see what happens.)  Obviously, this is due to the fact that cells gain more than they lose. <br><br>  This equation is actually referred to in my work as the ‚Äúpoor dispersion‚Äù model.  There is another equation in the work that is more stable, but it is not very convenient for us, mainly because it needs to write to the grid from which we read.  In other words, we need to read and write one texture at a time. <br><br>  What we have is enough for our purposes, but if you are interested, you can study the explanation in the paper.  In addition, another equation is implemented in <a href="http://codepen.io/tutsplus/full/RrVpxd/">an interactive demo for the CPU</a> , see the <code>diffuse_advanced()</code> function. <br><br><h4>  Minor fix </h4><br>  You may have noticed that when creating smoke at the bottom of the screen, it gets stuck there.  This is because the pixels on the bottom line try to get values ‚Äã‚Äãfrom the nonexistent pixels below them. <br><br>  To fix this, we will let the bottom pixels find <code>0</code> below them: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//    //        if(pixel.y &lt;= yPixel){ downColor.rgb = vec3(0.0); }</span></span></code> </pre> <br>  In the demo for the CPU, I coped with this by simply making sure that the lower cells do not dissipate.  You can also manually set all cells beyond <code>0</code> .  (The grid in the demo for the CPU goes out in one direction and one column in all directions, that is, we never see the boundaries) <br><br><h2>  Speed ‚Äã‚Äãgrid </h2><br>  Congratulations!  Now you have a ready smoke shader!  In the end, I would like to briefly describe the velocity field mentioned in the paper. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b4/e1d/c72/3b4e1dc72f41e44900c6f880cd52c8fa.jpg"><br>  <i>The transfer (advection) stage moves the density along a static velocity field.</i> <br><br>  Smoke is not obliged to dissipate equally upwards or in any other direction, it may follow a general pattern, for example, the one shown in the figure.  You can implement this by sending another texture in which the color values ‚Äã‚Äãrepresent the direction in which the smoke should move at the current point.  This is similar to using a normal map to indicate the direction of each pixel in the lighting tutorial. <br><br>  In fact, the speed texture also does not have to be static!  You can use frame buffer focus to change speeds in real time.  I will not talk about this in the tutorial, but this feature has great potential for research. <br><br><h2>  Conclusion </h2><br>  The most important thing to learn from this tutorial: the ability to render into texture instead of a screen is a very useful technique. <br><br><h4>  What can frame buffers be useful for? </h4><br>  They are often used for <em>post-processing</em> in games.  If you want to apply a color filter, instead of using it with each object, you can render all the objects into a texture to fit the screen, and then apply a shader to this texture and draw it on the screen. <br><br>  Another use case is the implementation of shaders that require <em>multiple passes.</em>  <em>for example blur</em> .  Usually, the image is passed through a shader, blurred along the x axis, and then passed through again to blur the y axis. <br><br>  The last example is <em>deferred rendering</em> , which we discussed in the <a href="https://habrahabr.ru/post/333002/">previous tutorial</a> .  This is an easy way to efficiently add multiple light sources to the scene.  The great thing about this is that the calculation of lighting no longer depends on the number of light sources. <br><br><h4>  Do not be afraid of technical articles. </h4><br>  Much more details can be found in the work I have cited.  It requires familiarity with linear algebra, but let it not hurt you to analyze and try to implement the system.  The essence of it is quite simple to implement (after some adjustment of the coefficients). <br><br>  I hope that you learned a little more about shaders and the article turned out to be useful. </div><p>Source: <a href="https://habr.com/ru/post/333718/">https://habr.com/ru/post/333718/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../333708/index.html">3D Blockchain. Face Proof (PoF)</a></li>
<li><a href="../333710/index.html">K-sort: a new algorithm that exceeds the pyramid when n <= 7 000 000</a></li>
<li><a href="../333712/index.html">What's new in Swift 4.0</a></li>
<li><a href="../333714/index.html">We do applications with search on Go</a></li>
<li><a href="../333716/index.html">Creating Angular 2+ components with the ability to switch themes</a></li>
<li><a href="../333722/index.html">Current activity around MIPSfpga and not only</a></li>
<li><a href="../333724/index.html">Currency exchange: fix the course for offline online. VTB24 experience</a></li>
<li><a href="../333728/index.html">Wolfram Summer School 2017: the story of the participant</a></li>
<li><a href="../333730/index.html">Step-by-step manual how to bring in equipment on which there is no notification of FSB</a></li>
<li><a href="../333732/index.html">IT Infrastructure Audit - How to Be a Newbie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>