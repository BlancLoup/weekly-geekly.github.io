<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>RecyclerView at max speed: parsing libraries</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ilya Nekrasov, Mahtalitet , KODE android developer 
 For two and a half years in the android development, I managed to work on completely different pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>RecyclerView at max speed: parsing libraries</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/02/i_/cl/02i_cl7q71uldgrkijpim0a0agk.jpeg"></p><br><p><img src="https://habrastorage.org/webt/np/kh/rc/npkhrc7elthbz0riiye9ri5zu1g.png" align="left">  <strong>Ilya Nekrasov, <a href="https://habr.com/users/mahtalitet/" class="user_link">Mahtalitet</a> , <a href="https://habr.com/users/mahtalitet/" class="user_link">KODE</a> android developer</strong> <br>  <em>For two and a half years in the android development, I managed to work on completely different projects: from the social network for motorists and the Latvian bank to the federal bonus system and the third airline carrier.</em>  <em>Anyway, in each of these projects I came across tasks that required finding non-classical solutions when implementing lists using the RecyclerView class.</em> <em><br></em>  <em>This article - the fruit of preparing for the performance at DevFest Kaliningrad'18, as well as communication with colleagues - will be especially useful for novice developers and those who have used only one of the existing libraries.</em> </p><br><p>  To begin with, let's dig a little into the essence of the issue and the source of pain, namely, the expansion of the functional in developing the application and the complication of the used lists. </p><a name="habracut"></a><br><h2 id="glava-pervaya-v-kotoroy-zakazchik-mechtaet-o-prilozhenii-a-my--o-chetkih-trebovaniyah">  Chapter One, in which the customer dreams of an application, and we - on clear requirements </h2><br><p><img src="https://habrastorage.org/webt/fi/wb/vs/fiwbvsaeyquagqloswybveolmaq.gif" align="right">  Let's imagine a situation when a customer who wants a mobile application for a shop selling rubber ducks addresses the studio. </p><br><p>  The project is developing rapidly, new ideas arise regularly and are not decorated in a long-term roadmap. </p><br><p>  First, the customer asks us to show a list of existing products and with a click to issue an application for delivery.  You don‚Äôt need to go far for a decision: we use the classic set from <strong>RecyclerView</strong> , a simple self-written adapter for it and an <strong>Activity</strong> . </p><br><p>  For the adapter, we use homogeneous data, one <strong>ViewHolder</strong> and simple logic of binding. </p><br><div class="spoiler">  <b class="spoiler_title">Adapter with ducks</b> <div class="spoiler_text"><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DucksClassicAdapter</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: List&lt;Duck&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> onDuckClickAction: (Duck) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> ) : RecyclerView.Adapter&lt;DucksClassicAdapter.ViewHolder&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreateViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parent: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ViewGroup</span></span></span></span><span class="hljs-function"><span class="hljs-params">, viewType: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ViewHolder { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rubberDuckView = LayoutInflater.from(parent.context).inflate(R.layout.item_rubber_duck, parent, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ViewHolder(rubberDuckView) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBindViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(holder: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ViewHolder</span></span></span></span><span class="hljs-function"><span class="hljs-params">, position: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> duck = <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>[position] holder.divider.isVisible = position != <span class="hljs-number"><span class="hljs-number">0</span></span> holder.rubberDuckImage.apply { Picasso.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() .load(duck.icon) .config(Bitmap.Config.ARGB_4444) .fit() .centerCrop() .noFade() .placeholder(R.drawable.duck_stub) .into(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } holder.clicksHolder.setOnClickListener { onDuckClickAction.invoke(duck) } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getItemCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.count() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewHolder</span></span></span></span>(view: View) : RecyclerView.ViewHolder(view) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rubberDuckImage: ImageView = view.findViewById(R.id.rubberDuckImage) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clicksHolder: View = view.findViewById(R.id.clicksHolder) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> divider: View = view.findViewById(R.id.divider) } }</code> </pre> </div></div><br><p><br><br><img src="https://habrastorage.org/webt/kh/bn/x3/khbnx3_a59poubdcheopd3e5ax4.gif" align="left">  Over time, the customer has an idea to add another category of goods to the rubber ducks, which means that they will have to add a new data model and a new layout.  But the most important thing is that the adapter will have another <strong>ViewType</strong> , with which you can determine which ViewHolder to use for a specific list item. </p><br><p>  After that, headings are added to categories, in which each category can be collapsed and expanded to simplify the orientation of users in the store.  This is plus another <strong>ViewType</strong> and <strong>ViewHolder</strong> for headers.  In addition, it is necessary to complicate the adapter, since it is necessary to keep a list of open groups and use it to check the need to hide and display an item by clicking on the title. </p><br><div class="spoiler">  <b class="spoiler_title">Adapter with everything</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DucksClassicAdapter</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> onDuckClickAction: (Pair&lt;Duck, <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> onSlipperClickAction: (Duck) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> onAdvertClickAction: (Advert) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> ) : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: List&lt;Duck&gt; = emptyList() <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(value) { field = value internalData = <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.groupBy { it.javaClass.kotlin } .flatMap { groupedDucks -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> titleRes = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (groupedDucks.key) { DuckSlipper::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slippers</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RubberDuck</span></span></span><span class="hljs-class">:</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">:class -&gt; R.string.rubber_ducks else -&gt; R.string.mixed_ducks } groupedDucks.value.let { listOf</span></span></span></span>(FakeDuck(titleRes, it)).plus(it) } } .toMutableList() duckCountsAdapters = internalData.map { duck -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rubberDuck = (duck <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? RubberDuck) DucksCountAdapter( <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = (<span class="hljs-number"><span class="hljs-number">1</span></span>..(rubberDuck?.count ?: <span class="hljs-number"><span class="hljs-number">1</span></span>)).map { count -&gt; duck to count }, onCountClickAction = { onDuckClickAction.invoke(it) } ) } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> advert = DuckMockData.adverts.orEmpty().shuffled().first() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> internalData: MutableList&lt;Duck&gt; = mutableListOf() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> duckCountsAdapters: List&lt;DucksCountAdapter&gt; = emptyList() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> collapsedHeaders: MutableSet&lt;Duck&gt; = hashSetOf() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreateViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parent: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ViewGroup</span></span></span></span><span class="hljs-function"><span class="hljs-params">, viewType: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: RecyclerView.ViewHolder { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (viewType) { VIEW_TYPE_RUBBER_DUCK -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> view = parent.context.inflate(R.layout.item_rubber_duck, parent) DuckViewHolder(view) } VIEW_TYPE_SLIPPER_DUCK -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> view = parent.context.inflate(R.layout.item_duck_slipper, parent) SlipperViewHolder(view) } VIEW_TYPE_HEADER -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> view = parent.context.inflate(R.layout.item_header, parent) HeaderViewHolder(view) } VIEW_TYPE_ADVERT -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> view = parent.context.inflate(R.layout.item_advert, parent) AdvertViewHolder(view) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> UnsupportedOperationException(<span class="hljs-string"><span class="hljs-string">"view type </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$viewType</span></span></span><span class="hljs-string"> without ViewHolder"</span></span>) } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBindViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(holder: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RecyclerView</span></span></span></span><span class="hljs-function"><span class="hljs-params">.</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ViewHolder</span></span></span></span><span class="hljs-function"><span class="hljs-params">, position: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (holder) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> HeaderViewHolder -&gt; bindHeaderViewHolder(holder, position) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> DuckViewHolder -&gt; bindDuckViewHolder(holder, position) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> SlipperViewHolder -&gt; bindSlipperViewHolder(holder, position) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> AdvertViewHolder -&gt; bindAdvertViewHolder(holder) } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindAdvertViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(holder: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AdvertViewHolder</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { holder.advertImage.showIcon(advert.icon) holder.advertTagline.text = advert.tagline holder.itemView.setOnClickListener { onAdvertClickAction.invoke(advert) } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindHeaderViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(holder: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">HeaderViewHolder</span></span></span></span><span class="hljs-function"><span class="hljs-params">, position: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> item = getItem(position) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> FakeDuck holder.clicksHolder.setOnClickListener { changeCollapseState(item, position) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> arrowRes = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collapsedHeaders.contains(item)) R.drawable.ic_keyboard_arrow_up_black_24dp <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> R.drawable.ic_keyboard_arrow_down_black_24dp holder.arrow.setImageResource(arrowRes) holder.title.setText(item.titleRes) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changeCollapseState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(item: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">FakeDuck</span></span></span></span><span class="hljs-function"><span class="hljs-params">, position: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isCollapsed = collapsedHeaders.contains(item) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isCollapsed) { collapsedHeaders.remove(item) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { collapsedHeaders.add(item) } <span class="hljs-comment"><span class="hljs-comment">// 1 to add items after header val startPosition = position + 1 if (isCollapsed) { internalData.addAll(startPosition - ADVERTS_COUNT, item.items) notifyItemRangeInserted(startPosition, item.items.count()) } else { internalData.removeAll(item.items) notifyItemRangeRemoved(startPosition, item.items.count()) } notifyItemChanged(position) } @SuppressLint("SetTextI18n") private fun bindSlipperViewHolder(holder: SlipperViewHolder, position: Int) { val slipper = getItem(position) as DuckSlipper holder.duckSlipperImage.showIcon(slipper.icon) holder.duckSlipperSize.text = ": ${slipper.size}" holder.clicksHolder.setOnClickListener { onSlipperClickAction.invoke(slipper) } } private fun bindDuckViewHolder(holder: DuckViewHolder, position: Int) { val duck = getItem(position) as RubberDuck holder.rubberDuckImage.showIcon(duck.icon) holder.rubberDuckCounts.adapter = duckCountsAdapters[position - ADVERTS_COUNT] val context = holder.itemView.context holder.rubberDuckCounts.layoutManager = LinearLayoutManager(context, HORIZONTAL, false) } override fun getItemViewType(position: Int): Int { if (position == 0) return VIEW_TYPE_ADVERT return when (getItem(position)) { is FakeDuck -&gt; VIEW_TYPE_HEADER is RubberDuck -&gt; VIEW_TYPE_RUBBER_DUCK is DuckSlipper -&gt; VIEW_TYPE_SLIPPER_DUCK else -&gt; throw UnsupportedOperationException("unknown type for $position position") } } private fun getItem(position: Int) = internalData[position - ADVERTS_COUNT] override fun getItemCount() = internalData.count() + ADVERTS_COUNT class DuckViewHolder(view: View) : RecyclerView.ViewHolder(view) { val rubberDuckImage: ImageView = view.findViewById(R.id.rubberDuckImage) val rubberDuckCounts: RecyclerView = view.findViewById(R.id.rubberDuckCounts) } class SlipperViewHolder(view: View) : RecyclerView.ViewHolder(view) { val duckSlipperImage: ImageView = view.findViewById(R.id.duckSlipperImage) val duckSlipperSize: TextView = view.findViewById(R.id.duckSlipperSize) val clicksHolder: View = view.findViewById(R.id.clicksHolder) } class HeaderViewHolder(view: View) : RecyclerView.ViewHolder(view) { val title: TextView = view.findViewById(R.id.headerTitle) val arrow: ImageView = view.findViewById(R.id.headerArrow) val clicksHolder: View = view.findViewById(R.id.clicksHolder) } class AdvertViewHolder(view: View) : RecyclerView.ViewHolder(view) { val advertTagline: TextView = view.findViewById(R.id.advertTagline) val advertImage: ImageView = view.findViewById(R.id.advertImage) } } private class FakeDuck( val titleRes: Int, val items: List&lt;Duck&gt; ) : Duck private fun ImageView.showIcon(icon: String, placeHolderRes: Int = R.drawable.duck_stub) { Picasso.get() .load(icon) .config(Bitmap.Config.ARGB_4444) .fit() .centerCrop() .noFade() .placeholder(placeHolderRes) .into(this) } private class DucksCountAdapter( private val data: List&lt;Pair&lt;Duck, Int&gt;&gt;, private val onCountClickAction: (Pair&lt;Duck, Int&gt;) -&gt; Unit ) : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() { override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder { val view = parent.context.inflate(R.layout.item_duck_count, parent) return CountViewHolder(view) } override fun getItemCount() = data.count() override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) { (holder as CountViewHolder).count.apply { val item = data[position] text = item.second.toString() setOnClickListener { onCountClickAction.invoke(item) } } } class CountViewHolder(view: View) : RecyclerView.ViewHolder(view) { val count: TextView = view.findViewById(R.id.count) } }</span></span></code> </pre> </div></div><br><p>  I think you catch the essence - such a jumble reminds a little of a healthy development.  And more and more new requirements from the customer are ahead: to fix the advertising banner at the top of the list, to realize the possibility of choosing the number of ordered ducks.  Only these tasks will eventually turn into successive adapters, which will again have to be written from scratch. </p><br><blockquote>  The process of developing a classic adapter in <a href="">githab</a> history </blockquote><br><h3 id="itogi">  Results </h3><br><p>  In fact, the picture is not at all encouraging: individual adapters have to be sharpened for specific cases.  We all understand that there are dozens or even hundreds of such screen lists in a real application.  And they do not contain information about ducks, but more complex data.  Yes, and their design is much more complicated. </p><br><h3 id="chto-ne-tak-s-nashimi-adapterami">  What is wrong with our adapters? </h3><br><ul><li>  obviously, they are difficult to reuse; </li><li>  inside there is a business logic and over time it becomes more and more; </li><li>  difficult to maintain and expand; </li><li>  high risk of errors when updating data; </li><li>  non-obvious design. </li></ul><br><h2 id="glava-vtoraya-v-kotoroy-vse-moglo-byt-inache">  Chapter Two, in which everything could be different </h2><br><p>  Imagine the development of the application for years ahead is unrealistic, and meaningless.  After a couple of such dances with a tambourine as in the last chapter and writing dozens of adapters, anyone will have the question ‚ÄúMaybe there are other solutions?‚Äù. </p><br><p><img src="https://habrastorage.org/webt/ct/6d/fx/ct6dfxsshhko-jfqycyqekpoqdu.jpeg"></p><br><p>  Having protested Github, we find out that the first <strong>AdapterDelegates</strong> library appeared in 2015, and a year later, <strong>Groupie</strong> and <strong>Epoxy</strong> added to the arsenal of developers - they all help make life easier, but each has its own specifics and pitfalls. </p><br><blockquote>  There are several other similar libraries (for example, FastAdapter), but neither I nor my colleagues worked with them, so we will not discuss them in the article. </blockquote><p>  Before comparing libraries, we briefly analyze the above case with an online store, provided the <strong>AdapterDelegates</strong> is used - from the libraries being parsed it is the easiest from the point of view of internal implementation and use (however, it is not completely advanced, so much has to be written by hand). </p><br><p>  The library does not completely save us from the adapter, but it will be formed from blocks (bricks), which we can safely add to the list or remove from it and change their places. </p><br><div class="spoiler">  <b class="spoiler_title">Block Adapter</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DucksDelegatesAdapter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ListDelegationAdapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List&lt;DisplayableItem</span></span></span><span class="hljs-class">&gt;&gt;</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { delegatesManager.addDelegate(RubberDuckDelegate()) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(items: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">DisplayableItem</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.items = items notifyDataSetChanged() } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RubberDuckDelegate</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AbsListItemAdapterDelegate</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RubberDuckItem, DisplayableItem, RubberDuckDelegate.ViewHolder</span></span></span><span class="hljs-class">&gt;</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isForViewType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(item: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">DisplayableItem</span></span></span></span><span class="hljs-function"><span class="hljs-params">, items: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">DisplayableItem</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, position: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> RubberDuckItem } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreateViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parent: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ViewGroup</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ViewHolder { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> item = parent.context.inflate(R.layout.item_rubber_duck, parent, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ViewHolder(item) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBindViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(item: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RubberDuckItem</span></span></span></span><span class="hljs-function"><span class="hljs-params">, viewHolder: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ViewHolder</span></span></span></span><span class="hljs-function"><span class="hljs-params">, payloads: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { viewHolder.apply { rubberDuckImage.showIcon(item.icon) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewHolder</span></span></span></span>(itemView: View) : RecyclerView.ViewHolder(itemView) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rubberDuckImage: ImageView = itemView.findViewById(R.id.rubberDuckImage) } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Using Adapter Activity</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DucksDelegatesActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ducksList: RecyclerView <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) setContentView(R.layout.activity_ducks_delegates) ducksList = findViewById(R.id.duckList) ducksList.apply { layoutManager = LinearLayoutManager(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-symbol"><span class="hljs-symbol">@DucksDelegatesActivity</span></span>) adapter = createAdapter().apply { showData() } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAdapter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: DucksDelegatesAdapter { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DucksDelegatesAdapter() } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> DucksDelegatesAdapter.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { setData(getRubberDucks()) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRubberDucks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;DisplayableItem&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DuckMockData.ducks.orEmpty().map { RubberDuckItem(it.icon) } } }</code> </pre> </div></div><br><p>  Already from the first task we see the difference: we have an adapter class that is inherited from the library.  And in addition - the very brick, which is called the <strong>delegate</strong> and from which we also inherit and implement part of the logic we need.  Next we add a delegate to the <strong>manager</strong> - this is also a library class.  And the last thing to do is create an adapter and fill it with data. </p><br><p>  To implement the second category of store and headers, we will write a couple of delegates, and the animation comes from the <strong>DiffUtil</strong> class. </p><br><p>  Here I‚Äôll mark a brief but categorical conclusion: the use of even this library solves all the listed problems that arose when the application became more complex in a case with an online store, but without the drawbacks anywhere, and more about them. </p><br><blockquote>  Adapter development process with AdapterDelegates in <a href="">github</a> history </blockquote><br><h2 id="glava-tretya-v-kotoroy-razrabotchik-snimaet-rozovye-ochki-sravniv-biblioteki">  Chapter Three, in which the developer removes rose-colored glasses by comparing libraries </h2><br><p>  Immerse more in the functionality and operation of each of the libraries.  I somehow applied all three libraries on our projects, depending on the tasks and complexity of the application. </p><br><h3 id="adapterdelegateshttpsgithubcomsockeqweadapterdelegates">  <a href="https://github.com/sockeqwe/AdapterDelegates">AdapterDelegates</a> </h3><br><p><img src="https://habrastorage.org/webt/u9/9q/up/u99quph_ecf1su3ggudei9au6eg.gif" align="left">  We use this library in the application of one of the largest Russian airlines.  We needed to replace the simple pay list with a list with groups and a large number of different parameters. </p><br><p>  Simplified scheme of the library looks like this: <img src="https://habrastorage.org/webt/w6/mw/4s/w6mw4shsbgr6ndkpbwvhsyuvayo.jpeg"></p><br><p>  The main class is <strong>DelegateAdapter</strong> , the various ‚Äúbricks‚Äù are the ‚Äúdelegates‚Äù who are responsible for displaying a particular data type and, of course, the list itself. </p><br><h4 id="plyusy">  Pros: </h4><br><ul><li>  ease of immersion; </li><li>  easy to reuse adapters; </li><li>  few methods and classes; </li><li>  no reflection, code generation and databing. </li></ul><br><h4 id="minusy">  Minuses: </h4><br><ul><li>  you need to implement the logic yourself, for example <del>  update items via DiffUti </del>  l (since version 3.1.0, you can use the AsyncListDifferDelegationAdapter adapter); </li><li>  redundant code. </li></ul><br><blockquote>  In general, this library solves all the main difficulties in expanding the functionality of the application and is suitable for those who have not used the library before.  But I don‚Äôt recommend to dwell only on it. </blockquote><br><h3 id="groupiehttpsgithubcomlisawraygroupie">  <a href="https://github.com/lisawray/groupie">Groupie</a> </h3><br><p><img src="https://habrastorage.org/webt/wm/ke/5w/wmke5wd9rsxtqknnr_jsdhn6m_s.gif" align="left">  <strong>Groupie</strong> , created a few years ago by <strong>Lisa Wray</strong> , we often use, including completely using it, we wrote an application for one Latvian bank. </p><br><p>  In order to use this library, first of all you need to <strong>understand the dependencies</strong> .  In addition to the main one, you can use several options to choose from: </p><br><ul><li>  expansion for <a href="https://kotlinlang.org/docs/tutorials/android-plugin.html">Kotlin Android Extensions</a> ; </li><li>  extension for <a href="https://developer.android.com/topic/libraries/data-binding/">Android Data Binding</a> ; </li><li>  both. </li></ul><br><p>  We stop at one and write the necessary dependencies. </p><br><p>  Using the example of an online store with ducks, we need to create an <strong>Item</strong> inherited from the library class, specify the layout, and implement the binding via Kotlin syntenty.  If you compare it with the amount of code that you had to write with the <strong>AdapterDelegates</strong> , it‚Äôs just heaven and earth. </p><br><p>  All that remains is to set the RecyclerView <strong>GroupieAdapter</strong> as an adapter, and put matched items into it. </p><br><p><img src="https://habrastorage.org/webt/3z/q9/wi/3zq9wiax9tufogfr6fx9cwipobe.jpeg"></p><br><p>  It is seen that the scheme of work is more and more difficult.  Here, in addition to simple items, you can use whole sections - groups of items and other classes. </p><br><h4 id="plyusy-1">  Pros: </h4><br><ul><li>  clear interface, although api makes you think; </li><li>  availability of boxed solutions; </li><li>  breakdown into groups of elements; </li><li>  the choice between the usual option, Kotlin Extensions and DataBinding; </li><li>  Embedding ItemDecoration and animation. </li></ul><br><h4 id="minusy-1">  Minuses: </h4><br><ul><li>  incomplete wiki; </li><li>  poor support by the maintainer and the community; </li><li>  small bugs that had to be circumvented in the first version; </li><li>  diffing in main thread (for now); </li><li>  no support for AndroidX (at the moment, but you need to keep track of the repository). </li></ul><br><p>  It is important that <strong>Groupie,</strong> with all its drawbacks, is able to easily replace <strong>AdapterDelegates</strong> , especially if you plan to make folding first-level lists, and do not want to write a lot of boilerplate. </p><br><blockquote>  <a href="https://github.com/appKODE/recyclerview_adapters/tree/groupie/app/src/main/kotlin/ru/rinekri/devfest2018">Implementing</a> a duck list using Groupie </blockquote><br><h3 id="epoxyhttpsgithubcomairbnbepoxy">  <a href="https://github.com/airbnb/epoxy">Epoxy</a> </h3><br><p><img src="https://habrastorage.org/webt/te/fg/tt/tefgttnpx4qijjlckdpxtuqpucq.gif" align="left">  The last library that we started to use relatively recently is <strong>Epoxy</strong> , developed by the guys from <strong>Airbnb</strong> .  The library is complex, but it allows you to solve a whole task load.  Airbnb programmers themselves use it to render screens directly from the server.  We <strong>Epoxy</strong> handy on one of the most recent projects - an application for the bank in Yekaterinburg. </p><br><p>  To develop screens, we had to work with different types of data, a huge number of lists.  And one of the screens was really endless.  And <strong>Epoxy</strong> helped us all with this. </p><br><p>  The principle of the library as a whole is similar to the two previous ones, except that instead of the adapter, the EpoxyController is used to build the list, which allows you to define the adapter structure declaratively. </p><br><p><img src="https://habrastorage.org/webt/im/rk/rl/imrkrl2d6nnnoolqijk-_ubvkmg.jpeg"></p><br><p>  To achieve this, the library is built on code generation.  How it works - with all the nuances well described in the <a href="https://github.com/airbnb/epoxy/wiki">wiki</a> and reflected in the <a href="https://github.com/airbnb/epoxy/tree/master/epoxy-sample">samples</a> . </p><br><h4 id="plyusy-2">  Pros: </h4><br><ul><li>  list models generated from ordinary View, with the possibility of reuse in simple screens; </li><li>  declarative description of the screens; </li><li>  DataBinding at max speeds - generates models directly from layout files; </li><li>  just displaying from the blocks not only lists, but also complex screens; </li><li>  General ViewPool on Activity; </li><li>  asynchronous diffing out of the box (AsyncEpoxyController); </li><li>  No need to mess with horizontal lists. </li></ul><br><h4 id="minusy-2">  Minuses: </h4><br><ul><li>  a heap of classes, processors, annotations; </li><li>  difficult dive from scratch; </li><li>  uses ButterKnife plugin to generate R2 files in modules; </li><li>  it is very difficult to understand how to work with Callbacks correctly (we ourselves have not understood yet); </li><li>  There are problems that need to be circumvented: for example, a crash with the same id. </li></ul><br><blockquote>  <a href="https://github.com/appKODE/recyclerview_adapters/tree/epoxy/app/src/main/kotlin/ru/rinekri/devfest2018">Implementing a</a> list of ducks using Epoxy </blockquote><br><h2 id="itogi-1">  Results </h2><br><p>  The main thing that I wanted to convey: you should not put up with the complexity that appears when you need to make complex lists and constantly have to redo them.  And this happens very often.  And in principle, when they are implemented, if the project only starts, or you are engaged in its refactoring. </p><br><p>  The reality is that you shouldn‚Äôt complicate the logic once again, thinking that there‚Äôs enough of some kind of own abstractions.  They are not long enough. But working with them is not only not enjoyable, it also remains a temptation to transfer part of the logic to the UI-part, which should not be there.  There are tools that will help avoid most problems, and they need to be used. </p><br><blockquote>  I understand that for many experienced (and not only) developers, this is either obvious, or they may not agree with me.  But I consider it important to re-emphasize this. </blockquote><br><h2 id="tak-a-chto-vybrat-to">  So, what to choose? </h2><br><p>  It is rather difficult to advise on one library, because the choice depends on many factors: from personal preferences to ideology on the project. </p><br><p>  I would do the following: </p><br><ol><li>  If you are just starting your way in development, try starting <strong>on a small project</strong> with <strong>AdapterDelegates</strong> - this is the simplest library - you won't need much knowledge.  Understand how to work with it and why it is more convenient than writing adapters yourself. </li><li>  <strong>Groupie is</strong> suitable for those who have already played enough with the AdapterDelegates and are tired of writing a bunch of boilerplate, or for <strong>everyone else</strong> who wants to start right from the middle.  And do not forget about the presence of <strong>folding groups out of the box</strong> - this is also a good argument in its favor. </li><li>  Well, and <strong>Epoxy</strong> - for those who are faced with a truly complex project, with a huge amount of data, so that the complexity of the library will be less of a problem.  At first, it will be hard, but then the implementation of the lists will seem like a damn.  An important argument in favor of Epoxy can be the presence of <strong>DataBinding</strong> and <strong>MVVM</strong> on the project - it is literally created for this, given the possibility of generating models from the corresponding layouts. </li></ol><br><p>  If you have any questions, you can look at the <a href="https://github.com/appKODE/recyclerview_adapters">link</a> to once again see the code of our application with the ducks. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/428525/">https://habr.com/ru/post/428525/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../428513/index.html">500 laser pointers in one place</a></li>
<li><a href="../428515/index.html">Top 3D Shop: how we have changed over the year - the results of 2018</a></li>
<li><a href="../428517/index.html">GraphQL - API in a new way</a></li>
<li><a href="../428521/index.html">Why on GitHub there are no friends. About Robbie Barrat, Obvious and Copyright</a></li>
<li><a href="../428523/index.html">ShadowCloud - universal cloud client</a></li>
<li><a href="../428526/index.html">Google tax: 180 ¬∞ reversal</a></li>
<li><a href="../428528/index.html">Why revolutionaries like spicy food, or How chili got to China</a></li>
<li><a href="../428530/index.html">The results of the investigation of the accident "Union MS-10"</a></li>
<li><a href="../428532/index.html">HyperloopTT plans to launch the first Hyperloop branch in the 3rd quarter of 2019</a></li>
<li><a href="../428534/index.html">3D drilling machine and PCAD to G-Code drilling card converter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>