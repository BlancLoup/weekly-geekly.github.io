<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PHP extension. Writing a simple array with Traversable and ArrayAccess</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I propose using the example of a simple array to consider exactly how the internal interfaces Traversable and ArrayAccess work. 

 Im...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PHP extension. Writing a simple array with Traversable and ArrayAccess</h1><div class="post__text post__text-html js-mediator-article">  In this article, I propose using the example of a simple array to consider exactly how the internal interfaces Traversable and ArrayAccess work. <br><br>  Immediately I will give a list of resources, which will be many links later in the text. <br><ul><li>  <a href="http://lxr.php.net/">lxr.php.net</a> - Convenient search by source code php; </li><li>  <a href="http://www.phpinternalsbook.com/">phpinternalsbook</a> - A useful resource for php internals.  Specifically, we are interested in the section by <a href="http://www.phpinternalsbook.com/classes_objects.html">class</a> ; </li><li>  <a href="https://php.net/manual/ru/internals2.php">PHP Core Guide</a> . </li></ul><br>  And about the platform: I wrote code for ubuntu, so for other linux distributions (and OS X) you need a minimum of changes (change apt-get).  If you want to write under Windows, then you will have to search for information on other Internet ( <s>no one writes code on windows anyway</s> ). <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  We collect PHP </h3><br>  To get started, let's build a debug version of PHP.  You can, of course, write an extension with the regular version, but after a couple of debug-flags, PHP becomes much more talkative. <br><br>  Open the console, go to the directory where we are going to pull PHP source files (for example ~ / dev / c /) and take the php code from the git repository. <br><pre><code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> http://git.php.net/repository/php-src.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> php-src</code> </pre> <br>  Switch to a fresh branch. <br><pre> <code class="bash hljs">git checkout PHP-5.6</code> </pre><br>  Install the necessary programs for building PHP (most likely you already have them). <br><pre> <code class="bash hljs">sudo apt-get install build-essential autoconf automake libtool</code> </pre><br>  Now it remains to install bison.  In ubuntu from version 14, bison comes version 3 and higher, which PHP does not digest.  We need version 2.7. <br><pre> <code class="bash hljs">wget http://launchpadlibrarian.net/140087283/libbison-dev_2.7.1.dfsg-1_amd64.deb wget http://launchpadlibrarian.net/140087282/bison_2.7.1.dfsg-1_amd64.deb sudo dpkg -i libbison-dev_2.7.1.dfsg-1_amd64.deb sudo dpkg -i bison_2.7.1.dfsg-1_amd64.deb</code> </pre><br><br>  Since we will build a version without default extensions, we do not need libxml2.  Otherwise, you will need to install libxml2-dev. <br><pre> <code class="bash hljs">sudo apt-get install libxml2-dev</code> </pre><br>  Configure indicates that we need a debug-version, without extensions.  In the parameter --prefix we specify the directory in which PHP will be installed. <br><pre> <code class="bash hljs">./buildconf ./configure --<span class="hljs-built_in"><span class="hljs-built_in">disable</span></span>-all --<span class="hljs-built_in"><span class="hljs-built_in">enable</span></span>-debug --prefix=<span class="hljs-variable"><span class="hljs-variable">$HOME</span></span>/dev/bin/php make &amp;&amp; make install</code> </pre><br><br>  Oke, PHP is ready.  We will run the newest php with the -v flag and make sure that we have collected what we need and where we need it (and then you never know). <br><pre> <code class="bash hljs">~/dev/bin/php/bin/php -v</code> </pre><br><br><h3>  We collect expansion </h3><br>  The ‚Äúskeleton‚Äù of the extension can be quickly generated using <b>ext_skel</b> , which is located in the PHP source directory.  We‚Äôll give up ext_skel, because besides the useful .gitignore it craps us with hundreds of unnecessary comments into files.  And .gitignore can be taken <a href="https://raw.githubusercontent.com/ArenSH/php_jco/master/.gitignore">here</a> . <br><br>  If you really want ext_skel, then you need to run it with the following parameters: the name of the extension is specified in - extraname, and the path to the skeleton folder in - skel. <br><pre> <code class="bash hljs">~/dev/c/php-src/ext/ext_skel --extname=jco --skel=<span class="hljs-variable"><span class="hljs-variable">$HOME</span></span>/dev/c/php-src/ext/skeleton/</code> </pre><br><br>  One way or another, you should have a directory with the following files. <br><pre> <code class="bash hljs">jco/ .gitignore config.m4 config.w32 jco.c php_jco.h</code> </pre><br><br>  Open config.m4 and write: <br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-string"><span class="hljs-string">"$PHP_JCO"</span></span> = <span class="hljs-string"><span class="hljs-string">"yes"</span></span>; then AC_DEFINE(HAVE_JCO, <span class="hljs-number"><span class="hljs-number">1</span></span>, [Whether you have Jco]) PHP_NEW_EXTENSION(jco, jco.c, $ext_shared) fi</code> </pre><br>  Everything further in config.m4 we will touch only the line with PHP_NEW_EXTENSION, adding new files there. <br><br>  Now let's write the main header file of our extension: php_jco.h.  It must be called php_% extension name% .h <br><pre> <code class="hljs smalltalk"><span class="hljs-symbol"><span class="hljs-symbol">#ifndef</span></span> <span class="hljs-type"><span class="hljs-type">PHP_JCO_H</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> <span class="hljs-type"><span class="hljs-type">PHP_JCO_H</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> extern zend_module_entry jco_module_entry; <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> phpext_jco_ptr &amp;jco_module_entry //   - ,     . <span class="hljs-symbol"><span class="hljs-symbol">#ifdef</span></span> <span class="hljs-type"><span class="hljs-type">ZTS</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> <span class="hljs-comment"><span class="hljs-comment">"TSRM.h"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#endif</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#endif</span></span></code> </pre><br>  In this file, we declare a variable of type <a href="">zend_module_entry</a> with information about our extension.  The name of the variable <i>should be</i> % extension name% _module_entry. <br><br>  Open jco.c and write the following to it. <br><div class="spoiler">  <b class="spoiler_title">jco.c</b> <div class="spoiler_text"><pre> <code class="hljs smalltalk"><span class="hljs-symbol"><span class="hljs-symbol">#ifdef</span></span> <span class="hljs-type"><span class="hljs-type">HAVE_CONFIG_H</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> <span class="hljs-comment"><span class="hljs-comment">"config.h"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#endif</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> <span class="hljs-comment"><span class="hljs-comment">"php.h"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> <span class="hljs-comment"><span class="hljs-comment">"php_jco.h"</span></span> //    <span class="hljs-type"><span class="hljs-type">PHP_FUNCTION</span></span>(hello_from_jco) { //   ,       . <span class="hljs-type"><span class="hljs-type">RETURN_STRING</span></span>(<span class="hljs-comment"><span class="hljs-comment">"JCO ENABLED! YEY!"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); } //  <span class="hljs-type"><span class="hljs-type">PHP</span></span>    ,      . const zend_function_entry jco_functions[] = { <span class="hljs-type"><span class="hljs-type">PHP_FE</span></span>(hello_from_jco, <span class="hljs-type"><span class="hljs-type">NULL</span></span>) <span class="hljs-type"><span class="hljs-type">PHP_FE_END</span></span> }; //  ,  php       <span class="hljs-type"><span class="hljs-type">PHP_MINIT_FUNCTION</span></span>(jco_init) { return <span class="hljs-type"><span class="hljs-type">SUCCESS</span></span>; } zend_module_entry jco_module_entry = { <span class="hljs-type"><span class="hljs-type">STANDARD_MODULE_HEADER</span></span>, <span class="hljs-comment"><span class="hljs-comment">"jco"</span></span>, //   jco_functions, <span class="hljs-type"><span class="hljs-type">PHP_MINIT</span></span>(jco_init), <span class="hljs-type"><span class="hljs-type">NULL</span></span>, // <span class="hljs-type"><span class="hljs-type">MSHUTDOWN</span></span> <span class="hljs-type"><span class="hljs-type">NULL</span></span>, // <span class="hljs-type"><span class="hljs-type">RINIT</span></span> <span class="hljs-type"><span class="hljs-type">NULL</span></span>, // <span class="hljs-type"><span class="hljs-type">RSHUTDOWN</span></span> <span class="hljs-type"><span class="hljs-type">NULL</span></span>, // <span class="hljs-type"><span class="hljs-type">MINFO</span></span> <span class="hljs-comment"><span class="hljs-comment">"0.1"</span></span>, //  <span class="hljs-type"><span class="hljs-type">STANDARD_MODULE_PROPERTIES</span></span> }; <span class="hljs-symbol"><span class="hljs-symbol">#ifdef</span></span> <span class="hljs-type"><span class="hljs-type">COMPILE_DL_JCO</span></span> <span class="hljs-type"><span class="hljs-type">ZEND_GET_MODULE</span></span>(jco) <span class="hljs-symbol"><span class="hljs-symbol">#endif</span></span></code> </pre><br></div></div><br>  The main thing here is the definition of a variable with information about our module, in which we specified the table of functions, the start function and other necessary data (or did not specify, replacing with NULL).  And <a href="">ZEND_GET_MODULE</a> simply creates the get_module function for our library, which returns the variable jco_module_entry; <br><br>  Great, now we are ready to build our extension.  Let's run phpize, which will make us configs for the config collector for the extension assembler (we need to go deeper!) <br><pre> <code class="bash hljs">~/dev/bin/php/bin/phpize</code> </pre><br>  And collect the extension.  In the parameter - with-php-config specify the path to the file php-config of the debug-version of PHP compiled by us <br><pre> <code class="bash hljs">./configure --with-php-config=<span class="hljs-variable"><span class="hljs-variable">$HOME</span></span>/dev/bin/php/bin/php-config make &amp;&amp; make install</code> </pre><br>  If everything is assembled without errors, then run php with the extension (if not, we are correct and still run). <br><pre> <code class="bash hljs">~/dev/bin/php/bin/php -dextension=jco.so --r <span class="hljs-string"><span class="hljs-string">"hello_from_jco();"</span></span> JCO ENABLED! YEY!</code> </pre><br><br><h3>  Briefly about zval and functions </h3><br>  Before we move on to the classes, we‚Äôll briefly review what PHP offers for working with functions and variables. <br><br>  To declare a function, use the PHP_FUNCTION, PHP_NAMED_FUNCTION, or PHP_METHOD macros.  They differ only in the name of the function obtained. <br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> prefix_name(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ht, zval *return_value, zval **return_value_ptr, zval *this_ptr, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> return_value_used <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ***tsrm_ls)</code> </pre><br>  Where <br><ul><li>  ht - the number of arguments with which the function is called </li><li>  return_value - pointer to the variable to which the result is written </li><li>  return_value_ptr - pointer to a pointer to the returned variable, (in case you need to return the result by reference) </li><li>  this_ptr - pointer to the object if the method is called </li><li>  return_value_is_used - a flag indicating whether the returned variable is used further </li><li>  tsrm_ls - Thread Safe Resourse Manager Local Storage!  Pointer to variable flow </li></ul><br><br>  Function arguments are defined using the ZEND_ARG_INFO_ * macros. <br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ , _,   ,    ZEND_BEGIN_ARG_INFO_EX(arginfo_construct, 0, 0, 1) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ,   ZEND_ARG_INFO(0, var1) ZEND_ARG_INFO(0, var2) ZEND_END_ARG_INFO() /</span></span>*    static const zend_arg_info arginfo_construct[] = { { NULL, <span class="hljs-number"><span class="hljs-number">0</span></span>, NULL, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"var1"</span></span>, sizeof(<span class="hljs-string"><span class="hljs-string">"var1"</span></span>)-<span class="hljs-number"><span class="hljs-number">1</span></span>, NULL, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"var2"</span></span>, sizeof(<span class="hljs-string"><span class="hljs-string">"var2"</span></span>)-<span class="hljs-number"><span class="hljs-number">1</span></span>, NULL, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, } *<span class="hljs-regexp"><span class="hljs-regexp">/</span></span></code> </pre><br>  <a href="">ZEND_BEGIN_ARG_INFO_EX</a> , <a href="">ZEND_ARG_INFO</a> and ZEND_END_ARG_INFO will result in an array of <a href="">zend_arg_info</a> structures.  Moreover, the first element of the array is <a href="">cast</a> to the type <a href="">zend_internal_function_info</a> .  The number and types of fields they have the same, only the names differ. <br><br>  The following functions, using macos PHP_FE, PHP_ME, PHP_ME_MAPPING, are listed in the table of module / class functions by elements of type <a href="">zend_function_entry</a> . <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_function_entry</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *fname; <span class="hljs-comment"><span class="hljs-comment">//     PHP void (*handler)(INTERNAL_FUNCTION_PARAMETERS); //   const struct _zend_arg_info *arg_info; //    zend_uint num_args; //   ( ,    arg_info) zend_uint flags; //   } zend_function_entry</span></span></code> </pre><br>  When registering a module, the functions are entered into the global function table (function_table).  When registering a class - in the table of class functions. <br><br>  To get the arguments, use the function <a href="">zend_parse_parameters</a> , which is called with the following parameters. <br><ul><li>  num_args - the number of arguments </li><li>  tsrm_ls - described above </li><li>  type_spec - the string in which the argument types are specified </li><li>  ... - then lists the pointers to variables in which the resulting arguments will be written </li></ul><br>  You can read about zend_parse_parameters <a href="http://php.net/manual/en/internals2.funcs.php">here</a> . <br><br>  To work with variables, PHP uses <a href="">zval</a> , which stores the value itself in <a href="">zvalue_value</a> , its type, reference count, and flag indicating that the interchange is used by reference. <br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_zval_struct</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">/* Variable information */</span></span> zvalue_value value; <span class="hljs-comment"><span class="hljs-comment">/* value */</span></span> zend_uint refcount__gc; zend_uchar <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* active type */</span></span> zend_uchar is_ref__gc; };</code> </pre><br>  To allocate memory for zval, use <a href="">ALLOC_ZVAL</a> (just allocates memory), <a href="">MAKE_STD_ZVAL</a> (ALLOC_ZVAL + initialization of values) and others. <br><br>  This should be done because instead of zval ALLOC_ZVAL will allocate memory for <a href="">_zval_gc_info</a> , which additionally stores information for searching for circular references. <br><br>  To remove zval, use the <a href="">zval_ptr_dtor</a> function.  Unlike <a href="">zval_dtor</a> , zval_ptr_dtor first decreases the reference count and removes zval only if the counter becomes zero. <br><br>  It is also worth considering that zvalue_value stores pointers for all values ‚Äã‚Äãthat are more complex than numbers.  And therefore, if you have two zval references to the same line in memory, then when you delete one of them, the second one will already refer to the incorrect memory location. <br><br>  Read more about zval You can read in <a href="http://www.phpinternalsbook.com/zvals.html">phpintenralsbook</a> .  And about circular references in <a href="http://php.net/manual/ru/features.gc.collecting-cycles.php">the PHP manual</a> . <br><br><h3>  Classes </h3><br>  Let's return to our expansion and add the first class.  Create a file jco_darray.h and write the following there. <br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> PHP_JCO_DARRAY_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PHP_JCO_DARRAY_H 1 extern zend_class_entry *jco_darray_ce; void jco_darray_init(TSRMLS_D); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Here we announced the jco_darray_ce variable of the zend_class_entry type for the class and the function for initialization. <br><br>  Now create the jco_darray.c file. <br><div class="spoiler">  <b class="spoiler_title">jco_darray.c</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"php.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jco_darray.h"</span></span></span><span class="hljs-meta"> zend_class_entry *jco_darray_ce; PHP_METHOD(jco_darray, sayHello) { RETURN_STRING(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Hello from darray!"</span></span></span><span class="hljs-meta">, 1); } const zend_function_entry jco_darray_functions[] = { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  ,  , arginfo,  PHP_ME(jco_darray, sayHello, NULL, ZEND_ACC_PUBLIC) PHP_FE_END }; void jco_darray_init(TSRMLS_D) { zend_class_entry tmp_ce; INIT_CLASS_ENTRY(tmp_ce, "JCO\\DArray", jco_darray_functions); jco_darray_ce = zend_register_internal_class(&amp;tmp_ce TSRMLS_CC); return; }</span></span></span></span></code> </pre><br></div></div><br>  Here only the jco_darray_init function is interesting.  First we create a temporary structure for our tmp_ce class and fill it with <a href="">INIT_CLASS_ENTRY</a> .  The second macro parameter specifies the class name that is available from PHP, <i>including the namespace</i> . <br><br>  We use the function <a href="">zend_register_internal_class</a> , which registers our class in the class table (class_table). <br><br>  Now we add a call to the jco_darray_init function to the jco_init function (jco.h file). <br><pre> <code class="hljs kotlin">PHP_MINIT_FUNCTION(jco_init) { jco_darray_init(TSRMLS_C); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; }</code> </pre><br>  And add a new jco_darray.c file in config.m4 (the list of files is specified WITHOUT commas). <br><pre> <code class="cmake hljs">PHP_NEW_EXTENSION(jco, jco.c jco_darray.c, $ext_shared)</code> </pre><br>  Since we changed config.m4, we need to run phpize again <br><pre> <code class="bash hljs">~/dev/bin/php/bin/phpize --clean ~/dev/bin/php/bin/phpize ./configure --with-php-config=<span class="hljs-variable"><span class="hljs-variable">$HOME</span></span>/dev/bin/php/bin/php-config make &amp;&amp; make install</code> </pre><br>  Let's make a php script to test our extension (let's call it original: jco.php) <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $darray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \JCO\DArray(); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $darray-&gt;sayHello() . PHP_EOL; <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre><br>  And run the script with our extension <br><pre> <code class="bash hljs">~/dev/bin/php/bin/php -dextension=jco.so jco.php</code> </pre><br><br><h3>  D for Dynamic </h3><br>  With a class that only knows how to say ‚ÄúHello‚Äù, you will not get far.  Especially if it was conceived as an array.  Time to take and write this array. <br><br>  Create the ds directory and add the darray.h file there, in which we will declare the structure and functions for our array. <br><div class="spoiler">  <b class="spoiler_title">ds / drray.h</b> <div class="spoiler_text"><pre> <code class="hljs smalltalk"><span class="hljs-symbol"><span class="hljs-symbol">#ifndef</span></span> <span class="hljs-type"><span class="hljs-type">PHP_JCO_DS_DARRAY_H</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> <span class="hljs-type"><span class="hljs-type">PHP_JCO_DS_DARRAY_H</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> <span class="hljs-comment"><span class="hljs-comment">"php.h"</span></span> typedef struct jco_ds_darray { size_t count; //  <span class="hljs-type"><span class="hljs-type">NULL</span></span>  size_t length; //    size_t min_length; //    size_t capacity; //  -      void *elements; //   (zval) } jco_ds_darray; jco_ds_darray *jco_ds_darray_create(size_t size, size_t capacity); void jco_ds_darray_destroy(jco_ds_darray *array); <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> jco_ds_darray_length(array) ((array)-&gt;length) <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> jco_ds_darray_min_length(array) ((array)-&gt;min_length) <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> jco_ds_darray_capacity(array) ((array)-&gt;capacity) <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> jco_ds_darray_count(array) ((array)-&gt;count) <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> jco_ds_darray_first(array) ((zval *)(array)-&gt;elements) <span class="hljs-symbol"><span class="hljs-symbol">#endif</span></span></code> </pre><br></div></div><br>  Now in the ds / darray.c file we define the functions declared above.  For now, this is only creating and deleting a structure. <br><div class="spoiler">  <b class="spoiler_title">ds / darray.c</b> <div class="spoiler_text"><pre> <code class="hljs vbscript">#include <span class="hljs-string"><span class="hljs-string">"ds/darray.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"php.h"</span></span> jco_ds_darray *jco_ds_darray_create(size_t size, size_t capacity) { jco_ds_darray *<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> = emalloc(sizeof(jco_ds_darray)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>) { return <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>-&gt;count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>-&gt;length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>-&gt;min_length = size; <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>-&gt;capacity = capacity; <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>-&gt;elements = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; return <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; } void jco_ds_darray_destroy(jco_ds_darray *<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>) { return; } efree(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>); }</code> </pre><br></div></div><br>  We have a class, we have an array, and we need to somehow bind them.  To do this, let's clarify how php works with objects. <br><br>  To store objects in variables (which are zval), the structure is zend_object_value, which has the following fields. <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_object_value</span></span></span><span class="hljs-class"> {</span></span> zend_object_handle handle; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> zend_object_handlers *handlers; } zend_object_value;</code> </pre><br><ul><li>  handlers - a structure with pointers to functions that php calls when we do something with an object (read a property, call a method, etc.).  We'll talk more about <a href="">zend_object_handlers</a> later. <br></li><li>  A handle is a regular int, ‚Äúid‚Äù of an object in the object_store object storage.  When creating an object, php places the <a href="">zend_object</a> structure in the object_store and returns an integer handle to us.  In this case, <a href="">if the class has a function create_object</a> , then to create a zend_object, it is called.  You can read more about all this in the <a href="http://www.phpinternalsbook.com/classes_objects/custom_object_storage.html">php internals book.</a> </li></ul><br>  So, all we need is to give our structure, which expands the zend_object.  To do this, we write our own function create_object and a function to free the memory allocated for the structure.  Add them after the jco_darray_ce declaration. <br><div class="spoiler">  <b class="spoiler_title">jco_darray.c</b> <div class="spoiler_text"><pre> <code class="hljs cpp">zend_object_handlers jco_darray_handlers; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jco_darray</span></span></span><span class="hljs-class"> {</span></span> zend_object <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>; jco_ds_darray *<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; } jco_darray; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jco_darray_free_object_storage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(jco_darray *intern TSRMLS_DC)</span></span></span><span class="hljs-function"> </span></span>{ zend_object_std_dtor(&amp;intern-&gt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span> TSRMLS_CC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intern-&gt;<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>) { jco_ds_darray_destroy(intern-&gt;<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>); } efree(intern); } <span class="hljs-function"><span class="hljs-function">zend_object_value </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jco_darray_create_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(zend_class_entry *class_type TSRMLS_DC)</span></span></span><span class="hljs-function"> </span></span>{ zend_object_value retval; jco_darray *intern = emalloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(jco_darray)); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(intern, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(jco_darray)); <span class="hljs-comment"><span class="hljs-comment">// :         zend_object_std_init(&amp;intern-&gt;std, class_type TSRMLS_CC); //     object_properties_init(&amp;intern-&gt;std, class_type); //      (object_store) retval.handle = zend_objects_store_put( intern, (zend_objects_store_dtor_t) zend_objects_destroy_object, //    (zend_objects_free_object_storage_t) jco_darray_free_object_storage, //      NULL //  ,    TSRMLS_CC ); //     -   retval.handlers = &amp;jco_darray_handlers; return retval; }</span></span></code> </pre><br></div></div><br>  <a href="">zend_objects_store_put</a> takes three functions: <br><ul><li>  dtor ( <a href="">zend_objects_destroy_object</a> ) - object destructor, which is called when the object reference count becomes 0, or at the end of the script.  The destructor is also responsible for executing custom code (__destruct).  In this case, in a specific case, php may omit the call to the destructor (for example, if an exception was thrown when another __destruct was called or an exit () was called) <br></li><li>  free_storage ( <a href="">zend_objects_free_object_storage</a> ) is a function that frees memory allocated for an object (zend_object).  It is always called: either when the object reference count becomes 0, or when the script ends. <br></li><li>  clone is a function that is called when an object is copied.  It is ignored by default, and in order to use it, you must explicitly specify the <a href="">zend_objects_store_clone_obj</a> function by the copy handler.  It is much easier to just take and use your own function immediately.  Therefore, in 99% of the cases in clone, we simply pass NULL. <br></li></ul><br><br>  Add the following lines to the jco_darray_init function <br><pre> <code class="hljs objectivec"> <span class="hljs-comment"><span class="hljs-comment">//     zend_object jco_darray_ce-&gt;create_object = jco_darray_create_object; //     memcpy(&amp;jco_darray_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers));</span></span></code> </pre><br>  And where is the array?  And we will create an array in the constructor. <br><div class="spoiler">  <b class="spoiler_title">jco_darray.c</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">PHP_METHOD(jco_darray, __construct) { jco_darray *intern; long size = <span class="hljs-number"><span class="hljs-number">0</span></span>; long capacity = <span class="hljs-number"><span class="hljs-number">0</span></span>; zend_error_handling error_handling; //   ,          zend_replace_error_handling(EH_THROW, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, &amp;error_handling TSRMLS_CC); //      (l - long),  -    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ll", &amp;size, &amp;capacity) == FAILURE) { zend_restore_error_handling(&amp;error_handling TSRMLS_CC); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } //     zend_restore_error_handling(&amp;error_handling TSRMLS_CC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { zend_throw_exception(<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, "Array size must be positive", <span class="hljs-number"><span class="hljs-number">0</span></span> TSRMLS_CC); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (capacity &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { zend_throw_exception(<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, "Array capacity must be positive or 0", <span class="hljs-number"><span class="hljs-number">0</span></span> TSRMLS_CC); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } //    handle intern = zend_object_store_get_object(getThis() TSRMLS_CC); intern-&gt;<span class="hljs-keyword"><span class="hljs-keyword">array</span></span> = jco_ds_darray_create((size_t)size, (size_t)capacity); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!intern-&gt;<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>) { zend_throw_exception(<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, "Failed to allocate array", <span class="hljs-number"><span class="hljs-number">0</span></span> TSRMLS_CC); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre><br></div></div><br>  Add __construct to the table of functions. <br><pre> <code class="hljs objectivec">ZEND_BEGIN_ARG_INFO_EX(arginfo_construct, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   ,   ZEND_ARG_INFO(0, size) ZEND_ARG_INFO(0, capacity) ZEND_END_ARG_INFO() const zend_function_entry jco_darray_functions[] = { PHP_ME(jco_darray, __construct, arginfo_construct, ZEND_ACC_PUBLIC) PHP_ME(jco_darray, sayHello, arginfo_void, ZEND_ACC_PUBLIC) PHP_FE_END };</span></span></code> </pre><br><br>  Time to build an extension and make sure everything compiles fine.  Run phpize to catch config.m4 changes (I promise, this is the last time) <br><pre> <code class="bash hljs">~/dev/bin/php/bin/phpize --clean ~/dev/bin/php/bin/phpize ./configure --with-php-config=<span class="hljs-variable"><span class="hljs-variable">$HOME</span></span>/dev/bin/php/bin/php-config make &amp;&amp; make install</code> </pre><br>  And run the test script <br><pre> <code class="bash hljs">~/dev/bin/php/bin/php -dextension=jco.so jco.php</code> </pre><br><br><h3>  ArrayAccess </h3><br>  In the ds / darray.h file, we add declarations of functions for working with an array: get, set, unset (and clone at the same time). <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-function">jco_ds_darray *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jco_ds_darray_create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> capacity)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">jco_ds_darray *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jco_ds_darray_clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(jco_ds_darray *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jco_ds_darray_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(jco_ds_darray *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">zval *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jco_ds_darray_get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(jco_ds_darray *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">zval *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jco_ds_darray_set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(jco_ds_darray *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, zval *value)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jco_ds_darray_unset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(jco_ds_darray *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span>;</code> </pre><br>  And write these functions <br><div class="spoiler">  <b class="spoiler_title">ds / darray.s</b> <div class="spoiler_text"><pre> <code class="hljs erlang-repl"> #include <span class="hljs-string"><span class="hljs-string">"ds/darray.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"php.h"</span></span> #define ELEM_SIZE (sizeof(zval)) //     . //   index,     capacity , //     index-  static inline int _jco_ds_darray_expand(jco_ds_darray *array, size_t index) { if (array &amp;&amp; array-&gt;capacity &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { size_t capacity = array-&gt;capacity; size_t max_elements = array-&gt;length; size_t expand_count; if (index) { expand_count = ((index + <span class="hljs-number"><span class="hljs-number">1</span></span>) / capacity) * capacity + capacity; } else { expand_count = (max_elements + capacity); } zval *elements; if (max_elements == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !array-&gt;elements) { elements = (zval *)emalloc(ELEM_SIZE * expand_count); } else { elements = (zval *)erealloc((void *)array-&gt;elements, ELEM_SIZE * expand_count); } if (elements) { zval *ptr = (elements + max_elements); memset(ptr, <span class="hljs-number"><span class="hljs-number">0</span></span>, array-&gt;capacity * ELEM_SIZE); array-&gt;length = expand_count; array-&gt;elements = elements; return <span class="hljs-number"><span class="hljs-number">1</span></span>; } return <span class="hljs-number"><span class="hljs-number">0</span></span>; } return <span class="hljs-number"><span class="hljs-number">0</span></span>; } jco_ds_darray *jco_ds_darray_create(size_t size, size_t capacity) { jco_ds_darray *array = emalloc(sizeof(jco_ds_darray)); if (!array) { return NULL; } array-&gt;length = <span class="hljs-number"><span class="hljs-number">0</span></span>; array-&gt;min_length = size; array-&gt;capacity = size; array-&gt;count = <span class="hljs-number"><span class="hljs-number">0</span></span>; array-&gt;elements = NULL; if (size &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !_jco_ds_darray_expand(array, <span class="hljs-number"><span class="hljs-number">0</span></span>)) { efree(array); return NULL; } array-&gt;length = size; array-&gt;capacity = capacity; return array; } void jco_ds_darray_destroy(jco_ds_darray *array) { if (!array) { return; } if (array-&gt;length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { zval *elem = (zval *)array-&gt;elements; while (array-&gt;length--) { if (elem != NULL &amp;&amp; Z_REFCOUNT_P(elem) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { zval_dtor(elem); } elem++; } } if (array-&gt;elements) { efree(array-&gt;elements); } efree(array); } jco_ds_darray *jco_ds_darray_clone(jco_ds_darray *array) { if (!array) { return NULL; } jco_ds_darray *new_array = emalloc(sizeof(jco_ds_darray)); if (!new_array) { return NULL; } new_array-&gt;count = array-&gt;count; new_array-&gt;length = array-&gt;length; new_array-&gt;min_length = array-&gt;min_length; new_array-&gt;capacity = array-&gt;capacity; new_array-&gt;elements = (zval *)emalloc(ELEM_SIZE * array-&gt;length); if (!new_array-&gt;elements) { efree(new_array); return NULL; } memcpy(new_array-&gt;elements, array-&gt;elements, ELEM_SIZE * array-&gt;length); //memcpy    zval`,         //        zval_copy_ctor size_t index; for (index = <span class="hljs-number"><span class="hljs-number">0</span></span>; index &lt; array-&gt;length; index++) { zval *elem = (zval *)new_array-&gt;elements + index; if (elem != NULL &amp;&amp; Z_REFCOUNT_P(elem) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { zval_copy_ctor(elem); } } return new_array; } zval *jco_ds_darray_get(jco_ds_darray *array, size_t index) { if (!array || array-&gt;length &lt; (index + <span class="hljs-number"><span class="hljs-number">1</span></span>)) { return NULL; } zval *elem = (zval *)(array-&gt;elements) + index; if (!elem || Z_TYPE_P(elem) == IS_NULL) { return NULL; } //   ,  is_ref__gc = <span class="hljs-number"><span class="hljs-number">0</span></span> Z_UNSET_ISREF_P(elem); return elem; } void jco_ds_darray_unset(jco_ds_darray *array, size_t index) { if (!array || array-&gt;length &lt; (index + <span class="hljs-number"><span class="hljs-number">1</span></span>)) { return; } zval *elem = (zval *)array-&gt;elements + index; if (elem != NULL &amp;&amp; Z_REFCOUNT_P(elem) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { if (Z_TYPE_P(elem) != IS_NULL) { array-&gt;count--; } zval_dtor(elem); *elem = (zval) {<span class="hljs-number"><span class="hljs-number">0</span></span>}; } } zval *jco_ds_darray_set(jco_ds_darray *array, size_t index, zval *value) { if (!array) { return; } if ((index + <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt; array-&gt;length) { if (array-&gt;capacity == <span class="hljs-number"><span class="hljs-number">0</span></span>) { return NULL; } if (!_jco_ds_darray_expand(array, index)) { return NULL; } } zval *elem = (zval *)array-&gt;elements + index; int prev_is_not_null = <span class="hljs-number"><span class="hljs-number">0</span></span>; if (Z_REFCOUNT_P(elem) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; Z_TYPE_P(elem)) { zval_dtor(elem); prev_is_not_null = <span class="hljs-number"><span class="hljs-number">1</span></span>; } elem-&gt;value = value-&gt;value; elem-&gt;type = value-&gt;type; elem-&gt;refcount__gc = <span class="hljs-number"><span class="hljs-number">1</span></span>; elem-&gt;is_ref__gc = <span class="hljs-number"><span class="hljs-number">0</span></span>; zval_copy_ctor(elem); if (prev_is_not_null &amp;&amp; Z_TYPE_P(elem) == IS_NULL) { array-&gt;count--; } else if (!prev_is_not_null &amp;&amp; Z_TYPE_P(elem) != IS_NULL) { array-&gt;count++; } return elem; }</code> </pre><br></div></div><br>  As you can see, in jco_ds_darray_set ALLOC_ZVAL we did not use, but used previously allocated memory.  In our case, it is important for us that the array of elements is continuous in memory.  In addition, we will not give the array elements directly into the user code, so the GC will be superfluous.  Accordingly, for deletion, we use zval_dtor instead of zval_ptr_dtor. <br><br>  Now, using new functions, we implement the ArrayAccess interface. <br><div class="spoiler">  <b class="spoiler_title">jco_darray.c</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"> PHP_METHOD(jco_darray, count) { jco_darray *intern; long count; intern = zend_object_store_get_object(getThis() TSRMLS_CC); count = (long)jco_ds_darray_count(intern-&gt;<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>); ZVAL_LONG(return_value, count); } PHP_METHOD(jco_darray, length) { jco_darray *intern; long length; intern = zend_object_store_get_object(getThis() TSRMLS_CC); length = (long) jco_ds_darray_length(intern-&gt;<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>); ZVAL_LONG(return_value, length); } PHP_METHOD(jco_darray, offsetSet) { jco_darray *intern; zval *val; long <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "lz", &amp;<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>, &amp;val) == FAILURE) { zend_throw_exception(<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, "Failed to parse arguments", <span class="hljs-number"><span class="hljs-number">0</span></span> TSRMLS_CC); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } intern = zend_object_store_get_object(getThis() TSRMLS_CC); jco_ds_darray_set(intern-&gt;<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>, (size_t)<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>, val); } PHP_METHOD(jco_darray, offsetUnset) { jco_darray *intern; long <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &amp;<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) == FAILURE) { zend_throw_exception(<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, "Invalid index passed", <span class="hljs-number"><span class="hljs-number">0</span></span> TSRMLS_CC); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } intern = zend_object_store_get_object(getThis() TSRMLS_CC); jco_ds_darray_unset(intern-&gt;<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>, (size_t)<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>); } PHP_METHOD(jco_darray, offsetGet) { jco_darray *intern; long <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &amp;<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) == FAILURE) { zend_throw_exception(<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, "Invalid index passed", <span class="hljs-number"><span class="hljs-number">0</span></span> TSRMLS_CC); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } intern = zend_object_store_get_object(getThis() TSRMLS_CC); zval *val = jco_ds_darray_get(intern-&gt;<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>, (size_t)<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val) { //, ,  zval_copy_ctor,  zval_ptr_dtor ZVAL_ZVAL(return_value, val, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ZVAL_NULL(return_value); } } PHP_METHOD(jco_darray, offsetExists) { jco_darray *intern; long <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &amp;<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) == FAILURE) { zend_throw_exception(<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, "Invalid index passed", <span class="hljs-number"><span class="hljs-number">0</span></span> TSRMLS_CC); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } intern = zend_object_store_get_object(getThis() TSRMLS_CC); zval *val = jco_ds_darray_get(intern-&gt;<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>, (size_t)<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val) { ZVAL_TRUE(return_value); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ZVAL_FALSE(return_value); } }</code> </pre><br></div></div><br><br>  Add functions to the class function table. <br><div class="spoiler">  <b class="spoiler_title">jco_darray.c</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">ZEND_BEGIN_ARG_INFO_EX(arginfo_jco_darray_offset, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) ZEND_ARG_INFO(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>) ZEND_END_ARG_INFO() ZEND_BEGIN_ARG_INFO_EX(arginfo_jco_darray_offset_value, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) ZEND_ARG_INFO(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>) ZEND_ARG_INFO(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) ZEND_END_ARG_INFO() const zend_function_entry jco_darray_functions[] = { PHP_ME(jco_darray, __construct, arginfo_construct, ZEND_ACC_PUBLIC) PHP_ME(jco_darray, offsetSet, arginfo_jco_darray_offset_value, ZEND_ACC_PUBLIC) PHP_ME(jco_darray, offsetGet, arginfo_jco_darray_offset, ZEND_ACC_PUBLIC) PHP_ME(jco_darray, offsetUnset, arginfo_jco_darray_offset, ZEND_ACC_PUBLIC) PHP_ME(jco_darray, offsetExists, arginfo_jco_darray_offset, ZEND_ACC_PUBLIC) PHP_ME(jco_darray, count, arginfo_void, ZEND_ACC_PUBLIC) PHP_ME(jco_darray, length, arginfo_void, ZEND_ACC_PUBLIC) PHP_FE_END };</code> </pre><br></div></div><br><br> ,  php      ArrayAccess <br><pre> <code class="hljs lisp"> zend_class_implements(<span class="hljs-name"><span class="hljs-name">jco_darray_ce</span></span> TSRMLS_CC, <span class="hljs-number"><span class="hljs-number">1</span></span>, zend_ce_arrayaccess)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>     ‚Äî     class_entry   . <br><br> zend_ce_arrayaccess    zend_interfaces.h (  zend_ce_traversable, zend_ce_aggregate, zend_ce_iterator  zend_ce_serializable),       jco_darray.c <br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"php.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"zend_interfaces.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jco_darray.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ds/darray.h"</span></span></span></span></code> </pre><br>             <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> ini_set(<span class="hljs-string"><span class="hljs-string">"memory_limit"</span></span>, <span class="hljs-string"><span class="hljs-string">"512M"</span></span>); $data = range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">500000</span></span>); $t1 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $m1 = memory_get_usage(); $jar = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \JCO\DArray(<span class="hljs-number"><span class="hljs-number">500000</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($data <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $index =&gt; &amp;$val) { $jar[$index] = $val * <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"JCO\Darray"</span></span> . PHP_EOL; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"TIME: "</span></span> . (microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) - $t1) . PHP_EOL; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"MEMORY: "</span></span> . ((memory_get_usage() - $m1)/<span class="hljs-number"><span class="hljs-number">1048576</span></span>) . PHP_EOL; gc_collect_cycles(); $t1 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $m1 = memory_get_usage(); $ar = []; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($data <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $index =&gt; &amp;$val) { $ar[$index] = $val * <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"AR"</span></span> . PHP_EOL; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"TIME: "</span></span> . (microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) - $t1) . PHP_EOL; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"MEMORY: "</span></span> . ((memory_get_usage() - $m1)/<span class="hljs-number"><span class="hljs-number">1048576</span></span>) . PHP_EOL; gc_collect_cycles(); <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre><br><br> C   php c   <br><pre> <code class="bash hljs"> make &amp;&amp; make install</code> </pre><br><pre> <code class="bash hljs">~/dev/bin/php/bin/php -dextension=jco.so jco.php JCO\Darray TIME: 0.43633484840393 MEMORY: 11.44548034668 Array TIME: 0.3345410823822 MEMORY: 137.51664733887</code> </pre><br><br> ‚Ä¶        php! <br><br><h3> Object Handlers </h3><br>  ,      .     <a href="">object_handlers</a> ,   . <br><pre> <code class="hljs objectivec">ZEND_API zend_object_handlers std_object_handlers = { zend_objects_store_add_ref, <span class="hljs-comment"><span class="hljs-comment">/* add_ref */</span></span> zend_objects_store_del_ref, <span class="hljs-comment"><span class="hljs-comment">/* del_ref */</span></span> zend_objects_clone_obj, <span class="hljs-comment"><span class="hljs-comment">/* clone_obj */</span></span> zend_std_read_property, <span class="hljs-comment"><span class="hljs-comment">/* read_property */</span></span> zend_std_write_property, <span class="hljs-comment"><span class="hljs-comment">/* write_property */</span></span> zend_std_read_dimension, <span class="hljs-comment"><span class="hljs-comment">/* read_dimension */</span></span> zend_std_write_dimension, <span class="hljs-comment"><span class="hljs-comment">/* write_dimension */</span></span> zend_std_get_property_ptr_ptr, <span class="hljs-comment"><span class="hljs-comment">/* get_property_ptr_ptr */</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* get */</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* set */</span></span> zend_std_has_property, <span class="hljs-comment"><span class="hljs-comment">/* has_property */</span></span> zend_std_unset_property, <span class="hljs-comment"><span class="hljs-comment">/* unset_property */</span></span> zend_std_has_dimension, <span class="hljs-comment"><span class="hljs-comment">/* has_dimension */</span></span> zend_std_unset_dimension, <span class="hljs-comment"><span class="hljs-comment">/* unset_dimension */</span></span> zend_std_get_properties, <span class="hljs-comment"><span class="hljs-comment">/* get_properties */</span></span> zend_std_get_method, <span class="hljs-comment"><span class="hljs-comment">/* get_method */</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* call_method */</span></span> zend_std_get_constructor, <span class="hljs-comment"><span class="hljs-comment">/* get_constructor */</span></span> zend_std_object_get_class, <span class="hljs-comment"><span class="hljs-comment">/* get_class_entry */</span></span> zend_std_object_get_class_name, <span class="hljs-comment"><span class="hljs-comment">/* get_class_name */</span></span> zend_std_compare_objects, <span class="hljs-comment"><span class="hljs-comment">/* compare_objects */</span></span> zend_std_cast_object_tostring, <span class="hljs-comment"><span class="hljs-comment">/* cast_object */</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* count_elements */</span></span> zend_std_get_debug_info, <span class="hljs-comment"><span class="hljs-comment">/* get_debug_info */</span></span> zend_std_get_closure, <span class="hljs-comment"><span class="hljs-comment">/* get_closure */</span></span> zend_std_get_gc, <span class="hljs-comment"><span class="hljs-comment">/* get_gc */</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* do_operation */</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* compare */</span></span> };</code> </pre><br><br>  ,       ,   : read_dimension, write_dimension, has_dimension  unset_dimension. <br><br>     <a href="">zend_std_read_dimension</a> ,  ,        ArrayAccess     offsetGet.   php ,   ,   (!) . <br><br>  :    (  count  clone). <br><div class="spoiler"> <b class="spoiler_title">jco_darray.c</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">// ,   zval  long static <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> long zval_to_long(zval *zv) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Z_TYPE_P(zv) == IS_LONG) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Z_LVAL_P(zv); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { zval tmp = *zv; zval_copy_ctor(&amp;tmp); convert_to_long(&amp;tmp); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Z_LVAL(tmp); } } static zend_object_value jco_darray_clone(zval *<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> TSRMLS_DC) { jco_darray *old_object = zend_object_store_get_object(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> TSRMLS_CC); zend_object_value new_object_val = jco_darray_create_object(Z_OBJCE_P(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>) TSRMLS_CC); jco_darray *new_object = zend_object_store_get_object_by_handle(new_object_val.handle TSRMLS_CC); //   zend_objects_clone_members( &amp;new_object-&gt;std, new_object_val, &amp;old_object-&gt;std, Z_OBJ_HANDLE_P(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>) TSRMLS_CC ); new_object-&gt;<span class="hljs-keyword"><span class="hljs-keyword">array</span></span> = jco_ds_darray_clone(old_object-&gt;<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!new_object-&gt;<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>) { zend_throw_exception(<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, "Failed to clone jco_darray", <span class="hljs-number"><span class="hljs-number">0</span></span> TSRMLS_CC); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new_object_val; } static zval *jco_darray_read_dimension(zval *<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>, zval *zv_offset, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TSRMLS_DC) { jco_darray *intern = zend_object_store_get_object(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> TSRMLS_CC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intern-&gt;std.ce-&gt;parent) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zend_get_std_object_handlers()-&gt;read_dimension(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>, zv_offset, <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TSRMLS_CC); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!zv_offset) { zend_throw_exception(<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, "Cannot append to a jco_darray", <span class="hljs-number"><span class="hljs-number">0</span></span> TSRMLS_CC); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; } long <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = zval_to_long(zv_offset); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> &gt; jco_ds_darray_length(intern-&gt;<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>)) { zend_throw_exception(<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, "Offset out of range", <span class="hljs-number"><span class="hljs-number">0</span></span> TSRMLS_CC); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; } zval *return_value; zval *<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = jco_ds_darray_get(intern-&gt;<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> != BP_VAR_R &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> != BP_WAR_RW) { return_value = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Z_SET_ISREF_P(return_value); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MAKE_STD_ZVAL(return_value); ZVAL_ZVAL(return_value, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); Z_DELREF_P(return_value); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MAKE_STD_ZVAL(return_value); ZVAL_NULL(return_value); Z_DELREF_P(return_value); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> return_value; } static <span class="hljs-type"><span class="hljs-type">void</span></span> jco_darray_write_dimension(zval *<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>, zval *zv_offset, zval *<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> TSRMLS_DC) { jco_darray *intern = zend_object_store_get_object(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> TSRMLS_CC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intern-&gt;std.ce-&gt;parent) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zend_get_std_object_handlers()-&gt;write_dimension(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>, zv_offset, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> TSRMLS_CC); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!zv_offset) { zend_throw_exception(<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, "Cannot append to a jco_darray", <span class="hljs-number"><span class="hljs-number">0</span></span> TSRMLS_CC); } long <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = zval_to_long(zv_offset); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { zend_throw_exception(<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, "Offset out of range", <span class="hljs-number"><span class="hljs-number">0</span></span> TSRMLS_CC); } zval *saved_val = jco_ds_darray_set(intern-&gt;<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>, (size_t)<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (saved_val == <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>) { zend_throw_exception(<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, "Error occured during dimension write", <span class="hljs-number"><span class="hljs-number">0</span></span> TSRMLS_CC); } } static <span class="hljs-type"><span class="hljs-type">int</span></span> jco_darray_has_dimension(zval *<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>, zval *zv_offset, <span class="hljs-type"><span class="hljs-type">int</span></span> check_empty TSRMLS_DC) { jco_darray *intern = zend_object_store_get_object(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> TSRMLS_CC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intern-&gt;std.ce-&gt;parent) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zend_get_std_object_handlers()-&gt;has_dimension(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>, zv_offset, check_empty TSRMLS_CC); } long <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = zval_to_long(zv_offset); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> &gt; jco_ds_darray_length(intern-&gt;<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } zval *<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = jco_ds_darray_get(intern-&gt;<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> == <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (check_empty) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zend_is_true(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Z_TYPE_P(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) != IS_NULL; } } static <span class="hljs-type"><span class="hljs-type">void</span></span> jco_darray_unset_dimension(zval *<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>, zval *zv_offset TSRMLS_DC) { jco_darray *intern = zend_object_store_get_object(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> TSRMLS_CC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intern-&gt;std.ce-&gt;parent) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zend_get_std_object_handlers()-&gt;unset_dimension(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>, zv_offset TSRMLS_CC); } long <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = zval_to_long(zv_offset); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> &gt; jco_ds_darray_length(intern-&gt;<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>)) { zend_throw_exception(<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, "Offset out of range", <span class="hljs-number"><span class="hljs-number">0</span></span> TSRMLS_CC); } jco_ds_darray_unset(intern-&gt;<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>); } <span class="hljs-type"><span class="hljs-type">int</span></span> jco_darray_count_elements(zval *<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>, long *count TSRMLS_DC) { jco_darray *intern = zend_object_store_get_object(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> TSRMLS_CC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intern-&gt;std.ce-&gt;parent) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zend_get_std_object_handlers()-&gt;count_elements(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>, count TSRMLS_CC); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intern &amp;&amp; intern-&gt;<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>) { *count = (long)jco_ds_darray_count(intern-&gt;<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { *count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FAILURE; } }</code> </pre><br></div></div><br><br>    jco_darray_read_dimension,      type.  ,       ,     BP_VAR_R, BP_VAR_W, BP_VAR_RW, BP_VAR_IS  BP_VAR_UNSET. <br><pre> <code class="php hljs">$var[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//   read_dimension BP_VAR_R $var[0][1] = 1; // [0] - read_dimension BP_VAR_W,  [1] - write_dimension isset($var[0][1]); // [0] - read_dimension BP_VAR_IS, [1] - has_dimension</span></span></code> </pre><br>    type      ,               .      BP_VAR_W      ,        ,  zval-&gt;is_ref__gc = 1 (  ). <br><br>       (intern-&gt;std.ce-&gt;parent).     -        ArrayAccess. <br><br>  php     ,   jco_darray_init   <br><pre> <code class="hljs"> jco_darray_handlers.has_dimension = jco_darray_has_dimension; jco_darray_handlers.read_dimension = jco_darray_read_dimension; jco_darray_handlers.write_dimension = jco_darray_write_dimension; jco_darray_handlers.unset_dimension = jco_darray_unset_dimension; jco_darray_handlers.count_elements = jco_darray_count_elements; jco_darray_handlers.clone_obj = jco_darray_clone;</code> </pre><br><br> C   php c   <br><pre> <code class="bash hljs"> make &amp;&amp; make install</code> </pre><br><pre> <code class="bash hljs">~/dev/bin/php/bin/php -dextension=jco.so jco.php JCO\Darray TIME: 0.18597507476807 MEMORY: 11.44548034668 Array TIME: 0.33455300331116 MEMORY: 137.51664733887</code> </pre><br><br>     ,        . ! <br><br><h3> Traversable </h3><br><br>      ,    .  object_handlers    ,    zend_class_entry    get_iterator   <a href="">iterator_funcs</a> . <br><br> get_iterator  <a href="">zend_object_iterator</a> ,     (  foreach). <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_object_iterator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *data; <span class="hljs-comment"><span class="hljs-comment">//   .   zend_object_iterator_funcs *funcs; //        ulong index; //  .      };</span></span></code> </pre><br><br> iterator_funcs,   ,     : ,    Iterator  IteratorAggregate.  zf_* ‚Äî (?)   php .  funcs    _zend_object_iterator.   ,     -        iterator_funcs. <br><br>   jco_darray.c    jco_darray     ,   . <br><pre> <code class="hljs ruby">typedef struct _jco_darray_iterator_data { zval *object_zval; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  php  (,        ) jco_darray *object; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   zend_object size_t offset; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   zval *current; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   } jco_darray_iterator_data;</code> </pre><br><br>    get_iterator.  jco_darray.c   count_elements   jco_darray_get_iterator. <br><pre> <code class="hljs pgsql">//by_ref - ,      . zend_object_iterator *jco_darray_get_iterator(zend_class_entry *ce, zval *<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> by_ref TSRMLS_DC) { zend_object_iterator *iter; jco_darray_iterator_data *iter_data; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (by_ref) { zend_throw_exception(<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, "UPS, no by reference iteration!", <span class="hljs-number"><span class="hljs-number">0</span></span> TSRMLS_CC); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; } iter = emalloc(sizeof(zend_object_iterator)); iter-&gt;funcs = &amp;jco_darray_iterator_funcs; iter_data = emalloc(sizeof(jco_darray_iterator_data)); iter_data-&gt;object_zval = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>; Z_ADDREF_P(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>); iter_data-&gt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> = zend_object_store_get_object(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> TSRMLS_CC); iter_data-&gt;<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; iter_data-&gt;<span class="hljs-keyword"><span class="hljs-keyword">current</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; iter-&gt;data = iter_data; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iter; }</code> </pre><br><br>   .     ,     get_iterator. <br><div class="spoiler"> <b class="spoiler_title">jco_darray.c</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">static <span class="hljs-type"><span class="hljs-type">void</span></span> jco_darray_iterator_dtor(zend_object_iterator *intern TSRMLS_DC) { jco_darray_iterator_data *data = (jco_darray_iterator_data *)intern-&gt;data; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data-&gt;<span class="hljs-keyword"><span class="hljs-keyword">current</span></span> != <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>) { zval_ptr_dtor(&amp;data-&gt;<span class="hljs-keyword"><span class="hljs-keyword">current</span></span>); } zval_ptr_dtor((zval **)&amp;data-&gt;object_zval); efree(data); efree(intern); } static <span class="hljs-type"><span class="hljs-type">int</span></span> jco_darray_iterator_valid(zend_object_iterator *intern TSRMLS_DC) { jco_darray_iterator_data *data = (jco_darray_iterator_data *)intern-&gt;data; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jco_ds_darray_length(data-&gt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>-&gt;<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>) &gt; data-&gt;<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> ? SUCCESS : FAILURE; } // static <span class="hljs-type"><span class="hljs-type">void</span></span> jco_darray_iterator_get_current_data(zend_object_iterator *intern, zval ***data TSRMLS_DC) { jco_darray_iterator_data *iter_data = (jco_darray_iterator_data *)intern-&gt;data; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iter_data-&gt;<span class="hljs-keyword"><span class="hljs-keyword">current</span></span> != <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>) { zval_ptr_dtor(&amp;iter_data-&gt;<span class="hljs-keyword"><span class="hljs-keyword">current</span></span>); iter_data-&gt;<span class="hljs-keyword"><span class="hljs-keyword">current</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iter_data-&gt;<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> &lt; jco_ds_darray_length(iter_data-&gt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>-&gt;<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>)) { zval *<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = jco_ds_darray_get(iter_data-&gt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>-&gt;<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>, iter_data-&gt;<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> != <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>) { MAKE_STD_ZVAL(iter_data-&gt;<span class="hljs-keyword"><span class="hljs-keyword">current</span></span>); ZVAL_ZVAL(iter_data-&gt;<span class="hljs-keyword"><span class="hljs-keyword">current</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); *data = &amp;iter_data-&gt;<span class="hljs-keyword"><span class="hljs-keyword">current</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { *data = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { *data = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; } } #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ZEND_MODULE_API_NO &gt;= <span class="hljs-number"><span class="hljs-number">20121212</span></span> //  php <span class="hljs-number"><span class="hljs-number">5.5</span></span>+ static <span class="hljs-type"><span class="hljs-type">void</span></span> jco_darray_iterator_get_current_key(zend_object_iterator *intern, zval *key TSRMLS_DC) { jco_darray_iterator_data *data = (jco_darray_iterator_data *) intern-&gt;data; ZVAL_LONG(key, data-&gt;<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>); } #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> //             //   HASH_KEY_IS_STRING, HASH_KEY_IS_LONG  HASH_KEY_NON_EXISTANT static <span class="hljs-type"><span class="hljs-type">int</span></span> jco_darray_iterator_get_current_key(zend_object_iterator *intern, <span class="hljs-type"><span class="hljs-type">char</span></span> **str_key, uint *str_key_len, ulong *int_key TSRMLS_DC) { jco_darray_iterator_data *data = (jco_darray_iterator_data *) intern-&gt;data; *int_key = (ulong) data-&gt;<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HASH_KEY_IS_LONG; } #endif static <span class="hljs-type"><span class="hljs-type">void</span></span> jco_darray_iterator_move_forward(zend_object_iterator *intern TSRMLS_DC) { jco_darray_iterator_data *data = (jco_darray_iterator_data *) intern-&gt;data; data-&gt;<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>++; } static <span class="hljs-type"><span class="hljs-type">void</span></span> jco_darray_iterator_rewind(zend_object_iterator *intern TSRMLS_DC) { jco_darray_iterator_data *data = (jco_darray_iterator_data *) intern-&gt;data; data-&gt;<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; data-&gt;<span class="hljs-keyword"><span class="hljs-keyword">current</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; } static zend_object_iterator_funcs jco_darray_iterator_funcs = { jco_darray_iterator_dtor, jco_darray_iterator_valid, jco_darray_iterator_get_current_data, jco_darray_iterator_get_current_key, jco_darray_iterator_move_forward, jco_darray_iterator_rewind, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> };</code> </pre><br></div></div><br><br>    jco_darray_init     get_iterator. <br><pre> <code class="hljs erlang-repl"> jco_darray_ce-&gt;get_iterator = jco_darray_get_iterator; jco_darray_ce-&gt;iterator_funcs.funcs = &amp;jco_darray_iterator_funcs;</code> </pre><br><br>     foreach <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($jar <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $val) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(($val % <span class="hljs-number"><span class="hljs-number">100000</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $val . PHP_EOL; } }</code> </pre><br><br> C   php c   <br><pre> <code class="bash hljs"> make &amp;&amp; make install</code> </pre><br><pre> <code class="bash hljs">~/dev/bin/php/bin/php -dextension=jco.so jco.php</code> </pre><br><br><h3>  Conclusion </h3><br>  ,  , .    Traversable  ArrayAccess     ,      ,     PHP.    ,        <a href="http://www.phpinternalsbook.com/classes_objects/serialization.html"></a> php internals book. <br><br>   ,    phpng    (   <a href="https://nikic.github.io/2014/12/22/PHPs-new-hashtable-implementation.html"> </a> ),     ,    ,  . <br><br>   <a href="https://github.com/ArenSH/php_jco">github-</a> . <br><br>  ,  .   . <br><br><img src="https://habrastorage.org/files/cee/55a/9db/cee55a9dbbc540a48d1e88a1887fb0e1.png"></div><p>Source: <a href="https://habr.com/ru/post/260983/">https://habr.com/ru/post/260983/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../260973/index.html">How to control the availability of keywords on the site</a></li>
<li><a href="../260975/index.html">The importance of the output serialization API</a></li>
<li><a href="../260977/index.html">Software-defined WAN: well-made electrical tape?</a></li>
<li><a href="../260979/index.html">STC Metrotek: how it was. Part One (2004-2006)</a></li>
<li><a href="../260981/index.html">Visualization of results in R: first steps</a></li>
<li><a href="../260985/index.html">RAD using multidimensional table processor</a></li>
<li><a href="../260987/index.html">Go away HTML, go away</a></li>
<li><a href="../260989/index.html">Messenger spam: is the law broken?</a></li>
<li><a href="../260991/index.html">Getting rid of "historical causes" in cmd.exe</a></li>
<li><a href="../260993/index.html">Solving sparse SLAEs of large dimensions using ManagedCuda in .NET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>