<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About seals, dogs, machine learning and deep learning</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúIn 1997, Deep Blue beat Kasparov to chess. 
 In 2011, Watson furnished the champions Jeopardy. 
 Will your algorithm in 2013 distinguish Bobby from F...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About seals, dogs, machine learning and deep learning</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/51c/7d3/fb1/51c7d3fb1958283da755d50d0e21bfea.jpg" alt="image"><br><blockquote>  <i>‚ÄúIn 1997, Deep Blue beat Kasparov to chess.</i> <i><br></i>  <i>In 2011, Watson furnished the champions Jeopardy.</i> <i><br></i>  <i>Will your algorithm in 2013 distinguish Bobby from Fluffy? ‚Äù</i> </blockquote><br><br>  This picture and the preface are from <a href="https://www.kaggle.com/c/dogs-vs-cats">Challenge</a> on Kaggle, which took place last fall.  Looking ahead, the last question is quite possible to answer ‚Äúyes‚Äù - a dozen leaders coped with the task by 98.8%, which is surprisingly impressive. <br><br>  And yet - where does such a question come from?  Why were classification problems that a four-year-old child easily solves for a long time (and still remain) too tough for programs?  Why is it more difficult to recognize objects of the world than to play chess?  What is deep learning and why are <a href="http://www.nytimes.com/2012/06/26/technology/in-a-big-network-of-computers-evidence-of-machine-learning.html%3Fpagewanted%3Dall%26_r%3D0">seals</a> in the publications about it with frightening consistency?  Let's talk about it. <br><a name="habracut"></a><br><h3>  What does it mean to recognize? </h3><br>  Suppose that we have two categories and many, many pictures that need to be decomposed into two groups corresponding to the stack.  How are we going to do this?  The wonderful answer to this question is that no one knows for sure, but the generally accepted approach is this: we will look for some ‚Äúinteresting‚Äù pieces of data in pictures that will be found only in one of the categories.  Such pieces of data are called <b>features</b> , and the approach itself is <b>feature detection</b> .  There are quite convincing arguments in favor of the fact that the biological brain works somehow - the first thing, of course, is the famous experiment of <a href="http://cns-alumni.bu.edu/~slehar/webstuff/pcave/hubel.html">Hyubel and Wiesel</a> on feline (again) visual cortex cells. <br><div class="spoiler">  <b class="spoiler_title">About terms</b> <div class="spoiler_text">  In the domestic literature about machine learning, instead of feature, they write a ‚Äúsign‚Äù, which, in my opinion, sounds like something vague.  Here I will say ‚Äúfeature‚Äù, may the Russian language mock me. </div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We never know in advance which parts of our image can be used as good features.  In their role can be anything, fragments of the image, shape, size or color.  A feature can easily not even be present in the picture itself, but can be expressed in a parameter obtained in some way from the source data - for example, after using the <a href="http://en.wikipedia.org/wiki/Edge_detection">border filter</a> .  Ok, let's look at a couple of examples with increasing complexity: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/833/6f0/911/8336f0911c0bd7a8ea3bee87363ab5e7.png"><br><br>  Suppose we want to make a Google car that could distinguish right turns from the left and turn the steering wheel accordingly.  The rule for finding a good feature can be thought up almost on the fingers: we cut off the upper half of the picture, select a section of a certain shade (asphalt), apply some logarithmic curve to the left.  If all the asphalt fit under the curve - then we have a turn to the right, otherwise - to the left.  You can score a few curves in case of turns of different curvature - and, of course, a different set of shades of asphalt, including a dry and wet state.  True, on dirt roads, our feature will be useless. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/738/445/13b/73844513bb0c3519bc551cd48f1cc0c9.png"><br><br>  An example from dataset handwritten numbers MNIST - this picture, probably, was seen by anyone who is at least a little familiar with machine learning.  Each digit has characteristic geometric elements that define what this digit is - a curl at the bottom of the two, a slash across the entire field of the unit, two docked circles of the figure eight, etc.  We can create a set of filters for ourselves that will highlight these essential elements, then apply these filters to our image in turn, and who will show the best result - most likely, this is the correct answer. <br><div class="spoiler">  <b class="spoiler_title">These filters will look, for example, like this</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/2ab/9f9/49f/2ab9f949fdaaf69802f64373d82c8c27.png"><br>  Picture from Joffrey Hinton <a href="https://www.coursera.org/course/neuralnets">'s</a> course <a href="https://www.coursera.org/course/neuralnets">‚ÄúNeural networks for machine learning‚Äù</a> <br>  By the way, pay attention to the numbers 7 and 9 - they have no lower part.  The fact is that the sevens and nines are the same, and do not carry any useful information for recognition - so the neural network that developed these features ignored this element.  Usually, to obtain such feature filters, we just use ordinary single-layer neural networks or something similar. <br></div></div><br><br>  Ok, closer to the subject.  How about this? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/610/483/6cd/6104836cd41524c4529ac2b19ac82cd7.png"><br><br>  There are a lot of differences between these two pictures - the eyes diverge.  The level of brightness, color, or here, for example, a funny coincidence - at the left picture white color prevails in the left part, and at the right one - in the right part.  But we need to choose not any, but precisely those that will uniquely identify cats or dogs.  That is, for example, the following two pictures should be recognized as belonging to the same category: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d7e/0f2/432/d7e0f24328deb77ca97300e02a2afef8.png"><br><br>  If you look at them for a long time and carefully and try to understand what is in common between them, then only the shape of the ears comes to mind - they are more or less the same, just tilted to the right.  But this is also a coincidence - you can easily imagine (and find examples from the same data set) a photograph in which the cat looks in the wrong direction, tilts its head, or is generally captured from behind.  The rest is all different.  The scale, color and length of hair, eyes, posture, background ... Nothing at all in common - and nevertheless, a small device in your head is able to accurately and accurately relate these two pictures to one category, and two ones that are higher - to different .  I don‚Äôt know how you are, but sometimes I admire that such a powerful device is very close to each of us, only reach out - and yet, we still cannot understand how it works. <br><br><h3>  Five-minute optimism (and theory) </h3><br>  Okay.  But still, if you try to ask a naive question - how do cats visually differ from dogs?  We can easily start the list - size, fluffiness, mustache, paw shape, presence of characteristic postures that they can take ... Or, for example, cats <a href="http://youtu.be/kcIfuBUYv38%3Ft%3D40m">have no eyebrows</a> .  The problem is that all these distinctive features are not expressed in the language of pixels.  We cannot put them into the algorithm until we have previously explained to him what these eyebrows are and where they should be located - or what the legs are and where they grow from.  Moreover, we, in general, are doing all these recognition algorithms in order to understand that we have a cat - a creature to which the concepts of "whiskers", "paws" and "tail" are applicable - and before that we don‚Äôt even we can say with reasonable confidence where the photo ends in a wallpaper or sofa, and the cat begins.  The circle is closed. <br><br>  But some conclusion from here can still be done.  When we formulated features in the previous examples, we proceeded from the possible variability of the object.  The turn of the road can only be left or right - there are no other options (except for going straight, of course, but there is nothing to do there), plus the standards of road construction guarantee us that the turn will be quite smooth, and not at a right angle.  Therefore, we construct our feature so that it allows different curvature of the turn, a certain set of shades of the road surface, and this is where the possible variability ends.  The following example: the number "1" can be written in different handwriting, and all the options will be different from each other - but it must necessarily have a straight vertical (or oblique) bar, otherwise it will cease to be one.  When we prepare our feature filter, we leave the classifier room for variability - and if you look at the picture under the spoiler again, you can see that the active part of the filter for the unit is a thick band that allows you to draw a line with a different slope and with a permissible sharp angle at the top. <br><br>  In the case of cats, the ‚Äúspace for maneuvering‚Äù of our objects becomes immeasurably huge.  In the picture there can be cats of different breeds, large and small, on any background that one can think of, some object can partially block them, and of course, they can take a hundred thousand different poses - and we have not mentioned the broadcast ( moving the object in the picture to the side), rotation and scaling - the eternal headache of all classifiers.  It seems an impossible task to create a flat filter similar to the previous one, which could take into account all these changes - let's try to mentally combine thousands of different forms in one picture, and we will get a shapeless filter spot that will respond positively to everything.  Hence, the required features should be some kind of more complex structure.  What is not yet clear, but it should be able to take into account all these possible changes in itself. <br><br>  This ‚Äúso far incomprehensible‚Äù lasted for quite a long time - most of the history of machine learning.  But suddenly at some point people understood about the world around them a fascinating idea.  It sounds like this: <br>  <b>All things consist of other, smaller and more elementary things.</b> <br><br>  When I say ‚Äúall things‚Äù, I mean literally anything, anything that we can learn.  First of all, since this post about vision is, of course, the objects of the surrounding world depicted in the pictures.  Any visible object, we continue the idea, can be represented as a composition of some stable elements, and those in turn consist of geometric shapes, and those are a combination of lines and angles arranged in a specific order.  Like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae4/88a/f2c/ae488af2cc919f6be7781abadd2d7255.png"><br>  <i>(for some reason I did not find a good informative picture, so this is cut out from the <a href="http://www.youtube.com/watch%3Fv%3Dn1ViNeWhC24">speech of</a> Andrew Un (the founder of Coursera) about deep learning</i> <br><br>  By the way, within the framework of naive reflections, we can say that our speech and natural language (which have also been considered as questions of artificial intelligence for a long time) is a structural hierarchy, where letters are formed into words, words into phrases, and these, in turn, into sentences and text - and that when we meet with a new word, we don‚Äôt have to re-learn all the letters in it, and we don‚Äôt perceive unfamiliar texts at all as something that requires special memorization and learning.  If you look at the history, you can find many approaches that, to one degree or another (and mostly, much more scientifically based), expressed this idea: <br><br>  1. Already mentioned, Hubel and Wiesel, in their experiment in 1959, found cells in the visual cortex of the brain that respond to certain characters on the screen ‚Äî and they also discovered the existence of other cells ‚Äúhigher‚Äù, which, in turn, respond to certain stable combinations signals from cells of the first level.  Based on this, they assumed the existence of a whole hierarchy of similar detector cells. <br><div class="spoiler">  <b class="spoiler_title">a great piece of video from the experiment</b> <div class="spoiler_text">  ... where it is <a href="http://www.youtube.com/watch%3Fv%3DIOHayh06LJ4">demonstrated</a> how they almost accidentally discovered the necessary feature that made the neuron react ‚Äî by moving the sample a little further than the usual, so that the edge of the glass fell into the chamber.  Sensitive people watch carefully, in the presence of bullying animals. <br></div></div><br>  2. Somewhere in the millennial area among machine-learning specialists, the term <b>deep learning</b> itself appears as applied to neural networks that have more than one layer of neurons, but many - and which, thus, can be trained in several levels of features.  Such an architecture has quite strictly justified advantages - the more levels in the network, the more complex functions it can express.  Immediately, there is a problem with how to train such networks ‚Äî the previously used backpropagation algorithm works poorly with a large number of layers.  Several different models for this purpose appear - autoencoders, limited Boltzmann machines, etc. <br>  3. Jeff Hawkins, in his book On Intelligence in 2004, writes that a hierarchical approach rules and the future lies with it.  He was already a bit late for the beginning of the ball, but I cannot fail to mention him - in the book this idea is derived from completely everyday things and simple language, by a person who was far enough from machine learning and generally said that all these neural networks of yours are bad idea.  Read the book, it is very inspiring. <br><br><h3>  A bit about the codes </h3><br>  So, we have a hypothesis.  Instead of stuffing 1024x768 equal pixels into the learning algorithm and watching it slowly suffocating from lack of memory and inability to understand which pixels are important for recognition, we want to extract some hierarchical structure from the picture, which will consist of different levels.  At the first level, we expect to see some very basic, structurally simple elements of the picture - its building bricks: borders, strokes, segments.  Higher - stable combinations of features of the first level (for example, corners), even higher - features combined from the previous ones (geometric shapes, etc.).  Actually, the question is - where to get such a structure for a separate image? <br><br>  Let‚Äôs talk about codes a bit as an abstract question. <br><br>  When we want to present an object from the real world in a computer, we use some set of rules to translate this object, bit by bit, into a digital form.  The letter, for example, is mapped bytes (in ASCII), and the picture is divided into many small pixels, and each of them is expressed by a set of numbers that convey brightness and color information.  There are a lot of color representation models, and although, generally speaking, it doesn‚Äôt matter what kind of training to use - for simplicity, for now let's imagine a black and white world, where one pixel is represented by a number from 0 to 1, expressing its brightness - from black to white. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ae/a62/6b9/7aea626b9653e9108154c49784a38f0a.png"><br><br>  What is wrong with this view?  Each pixel here is independent, it transmits only a small part of the information about the resulting image.  On the one hand, it is pleasant and beneficial when we need to save a picture somewhere or transfer it over the network, because it takes up less space, on the other hand, it is inconvenient for recognition.  In our case, we see here an oblique stroke (slightly curved) at the bottom of the image - it is difficult to guess from here, but this is a detail of the outline of the nose from the photo of the face.  So, in this case, the pixels that make up this stroke are important to us, the border between black and white is important - and the subtle play of light in shades of light gray at the top of the square is completely unimportant, and you shouldn‚Äôt even spend computing resources on it .  But in this view we have to deal with all the pixels at once - each of them is no better than the other. <br>  Let's imagine another code now.  We decompose this square into a linear sum of other such squares, each of which is multiplied by a coefficient.  You can imagine how we take a lot of plates of dark glass with different transparency, and on each plate different strokes are drawn - vertical, horizontal, different.  We put these plates stacked on each other, and adjust the transparency so that we get something similar to our drawing - not perfect, but sufficient for recognition purposes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e7/9cd/aa7/3e79cdaa77fe500ab4a4922cca67a297.png"><br><br>  Our new code consists of functional elements - each of them now says something about the presence of a separate meaningful component in the original square.  We see a coefficient of 0.01 for a component with a vertical stroke ‚Äî and we understand that there is little ‚Äúverticality‚Äù in the sample (but a lot of ‚Äúoblique stroke‚Äù ‚Äîsee the first coefficient).  If we independently select the components of this new code, its dictionary, then we can expect that there will be few non-zero coefficients ‚Äî such a code is called <b>sparse</b> . <br>  The useful properties of this view can be seen in the example of one of the applications called <b>denoising autoencoder</b> .  If you take an image, break it up into small squares of size, say, 10x10, and select the appropriate code for each piece - then we can with impressive efficiency then clean this image from random noise and distortion by translating the noisy image into code and restoring it (for example, find, for example, <a href="http://scikit-learn.org/stable/auto_examples/decomposition/plot_image_denoising.html">here</a> ).  This shows that the code is insensitive to random noise, and retains those parts of the image that we need to perceive the object - so we believe that the noise after the restoration has become ‚Äúless‚Äù. <br><br>  The downside of this approach is that the new code is heavier - depending on the number of components, the former 10x10 pixel square can weigh in much more.  To estimate the scale, there is <a href="http://en.wikipedia.org/wiki/Neural_coding">evidence</a> that the human visual cortex encodes 14x14 pixels (196 dimension) using approximately 100,000 neurons. <br><br>  And we suddenly got the first level of the hierarchy - it just consists of the dictionary elements of this code, which, as we can now see, are strokes and borders.  It remains from somewhere to take this very dictionary. <br><br><h3>  Five minute practice </h3><br>  We will use the scikit-learn package - a library for machine learning to SciPy (Python).  And specifically, the class (surprise) MiniBatchDictionaryLearning.  MiniBatch - because the algorithm will not be above the entire dataset at once, but alternately over small, randomly selected data bursts.  The process is simple and takes ten lines of code: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.decomposition <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MiniBatchDictionaryLearning <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.feature_extraction.image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> extract_patches_2d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> preprocessing <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.misc <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lena lena = lena() / <span class="hljs-number"><span class="hljs-number">256.0</span></span> <span class="hljs-comment"><span class="hljs-comment">#   data = extract_patches_2d(lena, (10, 10), max_patches=1000) #    10x10 -   data = preprocessing.scale(data.reshape(data.shape[0], -1)) # rescaling -    ,      1 learning = MiniBatchDictionaryLearning(n_components=49) features = learning.fit(data).components_</span></span></code> </pre> <br><br>  If you draw what lies in the features, you get something like the following: <br><div class="spoiler">  <b class="spoiler_title">Output via pylab</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pylab <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pl <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, feature <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(features): pl.subplot(<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, i + <span class="hljs-number"><span class="hljs-number">1</span></span>) pl.imshow(feature.reshape(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>), cmap=pl.cm.gray_r, interpolation=<span class="hljs-string"><span class="hljs-string">'nearest'</span></span>) pl.xticks(()) pl.yticks(()) pl.show()</code> </pre><br></div></div><br><img src="https://habrastorage.org/getpro/habr/post_images/ae5/14d/f5e/ae514df5e0ed5944c67bd2bdecfdb11e.png"><br><br>  Here you can briefly stop and remember why we all did it initially.  We wanted to get a set of fairly independent from each other "building blocks", from which the imaged object is formed.  To achieve this, we cut many, many small square pieces, drove them through an algorithm, and got that all these square pieces can be represented with a sufficient degree of reliability for recognition as a composition of these components.  Since at the level of 10x10 pixels (although, of course, it depends on the resolution of the picture), we encounter only edges and borders, we get them as a result, all of them are necessarily different. <br>  We can use this encoded representation as a detector.  In order to understand whether a randomly selected piece of a picture is an edge or a border, we take it and ask scikit to find the equivalent code, like this: <br><br><pre> <code class="python hljs">patch = lena[<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>] code = learning.transform(patch)</code> </pre><br><br>  If any one of the code components has a sufficiently large coefficient compared to the others, then we know that this signals from the presence of a corresponding vertical, horizontal or some other stroke.  If all components are about the same, it means that in this place in the picture there is a solid background or noise, which is of no interest to us. <br><br>  But we want to move on.  To do this, you need a few more conversions. <br>  So, any fragment of 10x10 size can now be expressed by a sequence of 49 numbers, each of which will mean the transparency coefficient for the corresponding component in the picture above.  And now we take these 49 numbers and write them in the form of a square 7x7 matrix - and draw what we have. <br>  And the following came out (two examples for clarity): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7d7/aba/f7b/7d7abaf7ba547adcb92304d29e16b1d5.png"><br><br>  On the left - a fragment of the original image.  On the right is its coded representation, where each pixel is the level of the presence of the corresponding component in the code (the lighter, the stronger).  It can be noted that the first fragment (upper) does not have a clearly pronounced stroke, and its code looks like a mixture of everything in a weak pale gray intensity, while the second clearly has one component - and the rest are all zero. <br><br>  Now, to teach the second level of hierarchy, take a larger fragment from the original image (so that several small ones are placed in it - say, 30x30), cut it into small fragments and present each of them in a coded version.  Then we dock it back together, and on this data we will train another DictionaryLearning.  The logic is simple - if our initial idea is correct, then the adjacent edges and boundaries should also be formed into stable and repetitive combinations. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/531/2d8/469/5312d846973da10b89e74c86a448d422.png"><br><br>  What happened as a result of an example does not seem to be something meaningful at first glance, but this is only by sight.  For example, what happens in the second level of the hierarchy that was trained on human faces. <br><br><div class="spoiler">  <b class="spoiler_title">a lot of pictures somehow</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/cbb/a27/00d/cbba2700d26420ea2e258c80924da085.png"><br>  Here, however, the fragment size was chosen more - 25x25 instead of 10x10.  One of the unpleasant features of this approach is the need to adjust the size of the ‚Äúminimum sense unit‚Äù yourself. <br></div></div><br><br>  Some difficulties arise in order to draw the resulting ‚Äúdictionary‚Äù, because the second level is trained on the <i>code of the</i> first, and its components will look like a motley crochet of dots from the figure above.  To do this, we need to take another step down - to break these components into parts again, and ‚Äúdecode‚Äù them using the first level, but here we will not consider this process in detail. <br><br>  And then the levels are increased as long as it is necessary, on exactly the same principle.  Here, for example, the third.  And here we already see something interesting: <br><img src="https://habrastorage.org/getpro/habr/post_images/239/0d7/68d/2390d768d6c5d09ffa6487a152108238.png"><br><br>  Each face here - feature size 160x160.  We have several of the most common locations - front, half a turn to the right and left, plus different skin colors.  Moreover, each feature has two more layers below itself, which, firstly, allow you to quickly test test images for validity, and secondly, they give an additional amount of freedom ‚Äî the outlines and borders can deviate from ideal lines, but as long as they remain within features of their level, they have the opportunity to signal their presence upward. <br>  Not bad. <br><br><h3>  And what - everything, we won? </h3><br>  Obviously not.  In fact, if you run the same script with which I draw all these sets, on the desired dataset about cats and dogs, the picture will be extremely depressing - level by level we will return about the same features, depicting slightly curved borders. <br><div class="spoiler">  <b class="spoiler_title">ok that's exactly the last</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/a50/1bf/879/a501bf87986f48cba905452055e9d080.png"><br>  It turned out to catch one dog's face, but this is pure coincidence - because a similar silhouette was encountered in the sample, say, two times.  If you run the script again, it may not appear. <br></div></div><br><br>  Our approach suffers because of the same thing that we criticized conventional feed-forward neural networks.  In the process of learning, DictionaryLearning tries to search for some common places, structural components of selected fragments of a picture.  In the case of faces, everything worked out for us, because they are more or less similar to each other - elongated oval shapes with a certain number of deviations (and several levels of the hierarchy give us more freedom in this regard).  In the case of cats, it is no longer possible, because in all the datasets one can hardly find two similar silhouettes.  The algorithm does not find anything in common between the pictures in the test sample - excluding the first levels, where we still deal with strokes and borders.  Fail  Again a dead end.  <s>Spent</s> <br><br><h3>  Ideas for the future </h3><br>  Actually, if you think about it, sampling with a large number of different seals is good in that it covers a variety of breeds, poses, sizes and colors, but it may not be too successful for learning even our intellect.  In the end, we learn more by the method of repeated repetitions and observation of an object, rather than by quickly looking through all its possible variations.  To learn how to play the piano, we have to constantly play scales - and it would be nice if it would be enough for this to listen to a thousand classic pieces.  So, the idea number one is to get away from the diversity in the sample and concentrate on one object in the same scene, but, say, in different positions. <br><br>  The idea number two comes from the first, and has already been voiced by many, including the one mentioned by Jeff Hawkins, to try to gain from time.  In the end, the variety of forms and postures that we see in one object, we see in time - and we can, for a start, group consecutively incoming pictures, assuming that they contain the same cat, just every time several new posture.  This means that we, at least, will have to drastically change the training set, and arm ourselves with YouTube videos found at the request of ‚Äúkitty wakes up‚Äù.  But about this - in the next series. <br><br><h3>  Look at the code </h3><br>  ... can be on a <a href="https://github.com/rocknrollnerd/deep_hierarchy">githaba</a> .  Run through python train.py myimage.jpg (you can also specify a folder with pictures), plus additional settings - the number of levels, the size of the fragments, etc.  Requires scipy, scikit-learn and matplotlib. <br><br><h3>  Useful links and what else you can read about intro deep learning </h3><br><br><ul><li>  <a href="http://www.datarobot.com/blog/a-primer-on-deep-learning/">A Primer on Deep Learning</a> - an informative post with a history of the question, a brief introduction and much more beautiful pictures. </li><li>  <a href="http://ufldl.stanford.edu/wiki/index.php/UFLDL_Tutorial">UFLDL Tutorial</a> - a tutorial from the already mentioned Andrew Ng from Stanford - to get your hands dirty.  There is literally everything to get acquainted with how it works - introduction, process math, parallels with feed-forward networks, illustrated examples and exercises in Matlab / Octave. </li><li>  <a href="http://neuralnetworksanddeeplearning.com/">The free online book Neural Networks and Deep Learning</a> - unfortunately, is not yet finished.  Describes the basics in a fairly popular form, starting with perceptrons, models of neurons, etc. </li><li>  <a href="http://www.youtube.com/watch%3Fv%3DvShMxxqtDDs">Geoffrey Hinton talks about new generations of neural networks</a> </li><li>  <a href="http://www.youtube.com/watch%3Fv%3D4y43qwS8fl4">The last talk with Hawkins</a> , where he briefly expounds about the same as in his book, but more concretely.  The fact that an intelligent algorithm should be able to know that the known properties of the human brain tell us about this, what neural networks do not suit us, and what is useful for sparse coding. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/226347/">https://habr.com/ru/post/226347/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../226337/index.html">Let's play evolution? Genetic Algorithms in a Screensaver</a></li>
<li><a href="../226339/index.html">How to assemble an electric bike in seven days</a></li>
<li><a href="../226341/index.html">We sit, do not touch anyone, we repair old headphones</a></li>
<li><a href="../226343/index.html">Gamification or gamification</a></li>
<li><a href="../226345/index.html">Recover Apple Key Aluminum after Fluid</a></li>
<li><a href="../226351/index.html">As we built the first prototype</a></li>
<li><a href="../226355/index.html">Master or work?</a></li>
<li><a href="../226357/index.html">Implementation of cloud data backup based on Android Backup Service</a></li>
<li><a href="../226359/index.html">Sharp Infrared Range Finder</a></li>
<li><a href="../226361/index.html">Create Shaman Tambourines</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>