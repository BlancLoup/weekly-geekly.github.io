<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Path to http / 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: here is a brief overview of the HTTP protocol and its history - from version 0.9 to version 2. 


 HTTP is a web threading protoc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Path to http / 2</h1><div class="post__text post__text-html js-mediator-article"><p>  <em>From the translator: here is a brief overview of the HTTP protocol and its history - from version 0.9 to version 2.</em> </p><br><p>  HTTP is a web threading protocol.  Every web developer is obliged to know it.  Understanding how HTTP works will help you make better web applications. </p><br><p>  In this article we will discuss what HTTP is, and how it became exactly as we see it today. </p><a name="habracut"></a><br><h2>  What is HTTP? </h2><br><p>  So, to begin with, what is HTTP?  HTTP is an application layer protocol implemented on top of the TCP / IP protocol.  HTTP defines how the client and server interact with each other, how content is requested and transmitted over the Internet.  By the application layer protocol, I understand that this is just an abstraction that standardizes how network nodes (clients and servers) interact with each other.  HTTP itself depends on the TCP / IP protocol, which allows sending and sending requests between the client and the server.  The default is TCP port 80, but others can be used.  HTTPS, for example, uses port 443. </p><br><h2>  HTTP / 0.9 - the first standard (1991) </h2><br><p>  The first documented version of HTTP was <a href="https://www.w3.org/Protocols/HTTP/AsImplemented.html">HTTP / 0.9</a> , released in 1991.  It was the simplest protocol in the world, with a single method - GET.  If the client needed to receive any page on the server, he made a request: </p><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> /<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>.html</code> </pre> <br><p>  And from the server came about this answer: </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">response</span></span> body) (<span class="hljs-name"><span class="hljs-name">connection</span></span> closed)</code> </pre> <br><p>  That's all.  The server receives the request, sends the HTML in response, and as soon as all the content is transferred, closes the connection.  There are no headers in HTTP / 0.9, the only method is GET, and the answer comes in HTML. </p><br><p>  So, HTTP / 0.9 was the first step in all further history. </p><br><h2>  HTTP / 1.0 - 1996 </h2><br><p>  Unlike HTTP / 0.9, which is designed only for HTML responses, HTTP / 1.0 handles other formats as well: images, videos, text, and other types of content.  New methods have been added (such as POST and HEAD).  The request / response format has changed.  HTTP headers were added to requests and responses.  Added status codes to distinguish between different server responses.  Introduced support for encodings.  Added composite data types (multi-part types), authorization, caching, various content encodings and much more. </p><br><p>  Here is what a simple HTTP / 1.0 request and response looked like: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> / HTTP/<span class="hljs-number"><span class="hljs-number">1.0</span></span> Host: kamranahmed.<span class="hljs-keyword"><span class="hljs-keyword">info</span></span> <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>-Agent: Mozilla/<span class="hljs-number"><span class="hljs-number">5.0</span></span> (Macintosh; Intel Mac OS X <span class="hljs-number"><span class="hljs-number">10</span></span>_10_5) Accept: *<span class="hljs-comment"><span class="hljs-comment">/*</span></span></code> </pre> <br><p>  In addition to the request, the client sent personal information, the required type of response, etc.  In HTTP / 0.9, the client would not send such information, since the headers simply did not exist. </p><br><p>  An example of a response to a similar request: </p><br><pre> <code class="hljs pgsql">HTTP/<span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> OK Content-<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>: <span class="hljs-type"><span class="hljs-type">text</span></span>/plain Content-Length: <span class="hljs-number"><span class="hljs-number">137582</span></span> Expires: Thu, <span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-type"><span class="hljs-type">Dec</span></span> <span class="hljs-number"><span class="hljs-number">1997</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span> GMT Last-Modified: Wed, <span class="hljs-number"><span class="hljs-number">5</span></span> August <span class="hljs-number"><span class="hljs-number">1996</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">55</span></span>:<span class="hljs-number"><span class="hljs-number">28</span></span> GMT <span class="hljs-keyword"><span class="hljs-keyword">Server</span></span>: Apache <span class="hljs-number"><span class="hljs-number">0.84</span></span> (response body) (<span class="hljs-keyword"><span class="hljs-keyword">connection</span></span> closed)</code> </pre> <br><p>  The beginning of the response is HTTP / 1.0 (HTTP and version number), then the status code is 200, then the description of the status code. </p><br><p>  In the new version, the request and response headers were encoded in ASCII (HTTP / 0.9 was all encoded in ASCII), but the response body could be of any content type ‚Äî image, video, HTML, plain text, etc. Now the server could send any the type of content to the client, so the phrase ‚ÄúHyper Text‚Äù in the abbreviation of HTTP has become a distortion.  HMTP, or Hypermedia Transfer Protocol, would probably become a more appropriate name, but by that time everyone was accustomed to HTTP. </p><br><p>  One of the main disadvantages of HTTP / 1.0 is that you cannot send multiple requests during the same connection.  If the client needs to get something from the server, it needs to open a new TCP connection, and as soon as the request is completed, the connection will be closed.  For each subsequent request, you need to create a new connection. </p><br><p>  Why is that bad?  Let's assume that you open a page containing 10 images, 5 style files and 5 javascript files.  In total, when requesting this page you need to get 20 resources - and this means that the server will have to create 20 separate connections.  This number of connections significantly affects performance, as each new TCP connection requires a ‚Äútriple handshake‚Äù followed by a <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25B4%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2581%25D1%2582%25D0%25B0%25D1%2580%25D1%2582">slow start</a> . </p><br><h3>  Triple handshake </h3><br><p>  "Triple handshake" is an exchange of a sequence of packets between the client and the server, allowing you to establish a TCP connection to start data transfer. </p><br><ul><li>  <strong>SYN</strong> - The client generates a random number, for example, <strong>x</strong> , and sends it to the server. </li><li>  <strong>SYN ACK</strong> - The server confirms this request by sending back an ACK packet consisting of a random number selected by the server (say, <strong>y</strong> ) and the number <strong>x + 1</strong> , where <strong>x</strong> is the number received from the client. </li><li>  <strong>ACK</strong> - the client increases the number of y received from the server and sends <strong>y + 1</strong> to the server. </li></ul><br><p>  <em>Translator's note</em> : <strong>SYN</strong> - synchronization of sequence numbers, ( <em>eng.</em> Synchronize sequence numbers).  <strong>ACK</strong> - the ‚ÄúConfirmation Number‚Äù field is enabled ( <em>English</em> Acknowledgment field is significant). </p><br><p><img src="https://habrastorage.org/files/72b/219/8de/72b2198de7324f919133e0df008a8873.jpg" alt="Establish TCP connection"></p><br><p>  Only after the completion of the triple handshake begins the transfer of data between the client and the server.  It is worth noting that the client can send data immediately after sending the last ACK packet, but the server still expects an ACK packet to complete the request. </p><br><p>  Nevertheless, some HTTP / 1.0 implementations tried to overcome this problem by adding a new Connection: keep-alive header that would tell the server "Hey, buddy, don't close this connection, it will still come in handy for us."  However, this possibility was not widespread, so the problem remained relevant. </p><br><p>  In addition to the fact that HTTP is a connectionless protocol, it also does not provide state support.  In other words, the server does not store information about the client, so each request has to include all the information the server needs, regardless of past requests.  And this only adds fuel to the fire: in addition to the huge number of connections that the client opens, he also sends repeated data, overloading the network unnecessarily. </p><br><h2>  HTTP / 1.1 - 1999 </h2><br><p>  Three years have passed since the days of HTTP / 1.0, and in 1999 a new version of the protocol was released - HTTP / 1.1, including many improvements: </p><br><ul><li>  <strong>New HTTP methods</strong> - PUT, PATCH, HEAD, OPTIONS, DELETE. </li><li>  <strong>Identification of hosts.</strong>  In HTTP / 1.0, the Host header was optional, and HTTP / 1.1 made it so. </li><li>  <strong>Permanent connections.</strong>  As mentioned above, in HTTP / 1.0 one connection processed only one request and then immediately closed after that, which caused serious performance problems and problems with delays.  Permanent connections appeared in HTTP / 1.1, i.e.  connections that did not close by default, while remaining open to multiple consecutive requests.  To close the connection, it was necessary to add the Connection: close header when prompted.  Clients typically sent this header in the last request to the server to safely close the connection. </li><li>  <strong>Streaming data,</strong> in which the client can send multiple requests to the server within a connection without waiting for responses, and the server sends responses in the same sequence in which requests are received.  But, you might ask, how does a client know when one answer ends and another begins?  To resolve this task, a Content-Length header is set, with which the client determines where one response ends and the next one can be expected. </li></ul><br><p>  Note that in order to experience the benefits of persistent connections or streaming data, the Content-Length header must be available in the response.  This will allow the client to understand when the transfer is complete and it will be possible to send the next request (in the case of normal sequential requests) or start waiting for the next answer (in the case of streaming). <br>  But there were still problems with this approach.  What if the data is dynamic and the server cannot find out the length of the content before sending it?  It turns out, in this case, we can not use permanent connections?  To solve this problem, HTTP / 1.1 introduced <a href="https://ru.wikipedia.org/wiki/Chunked_transfer_encoding">cunked encoding</a> ‚Äî a mechanism for breaking up information into small parts (chunks) and their transmission. </p><br><ul><li>  <strong>Chunked Transfers,</strong> if the content is built dynamically and the server cannot determine the <em>Content-Length</em> at the beginning of the transfer, it begins to send the content in parts one after another, and add a <em>Content-Length</em> to each transmitted part.  When all parts are sent, an empty packet is sent with the <em>Content-Length</em> header set to 0, signaling to the client that the transfer is complete.  To tell the client that the transfer will be done in parts, the server adds a <em>Transfer-Encoding</em> header <em>: chunked</em> . </li><li>  Unlike <a href="https://en.wikipedia.org/wiki/Basic_access_authentication">basic authentication</a> in HTTP / 1.0, <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B0%25D0%25B9%25D0%25B4%25D0%25B6%25D0%25B5%25D1%2581%25D1%2582-%25D0%25B0%25D1%2583%25D1%2582%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2584%25D0%25B8%25D0%25BA%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">digest authentication</a> and <a href="http://wiki.squid-cache.org/Features/Authentication">proxy authentication</a> have been added to HTTP / 1.1. </li><li>  <strong>Caching</strong> </li><li>  <strong>Byte</strong> ranges. </li><li>  <strong>Encodings</strong> </li><li>  <a href="https://en.wikipedia.org/wiki/Content_negotiation">Content negotiation</a> . </li><li>  <strong>Client cookies</strong> . </li><li>  <strong>Improved compression support</strong> . </li><li>  Other... </li></ul><br><p>  HTTP / 1.1 features are a separate topic for conversation, and in this article I will not linger on it for a long time.  You can find a huge amount of materials on this topic.  I recommend reading <a href="http://www.ra.ethz.ch/cdstore/www8/data/2136/pdf/pd1.pdf">Key differences between HTTP / 1.0 and HTTP / 1.1</a> and, for superheroes, a reference to the <a href="https://tools.ietf.org/html/rfc2616">RFC</a> . </p><br><p>  HTTP / 1.1 appeared in 1999 and has been a standard for many years.  And, although it was much better than its predecessor, it eventually began to become obsolete.  The web is constantly growing and changing, and every day the loading of web pages requires more resources.  Today, a standard web page has to open more than 30 connections.  You will say: "But ... because ... in HTTP / 1.1 there are persistent connections ...".  However, the fact is that HTTP / 1.1 supports only one external connection at a time.  HTTP / 1.1 tried to fix this by streaming data, but this did not completely solve the problem.  There was a problem of blocking the beginning of the queue ( <em>head-of-line blocking</em> ) - when a slow or large request blocked all subsequent ones (after all, they were executed in the order of the queue).  To overcome these HTTP / 1.1 flaws, developers have devised workarounds.  An example of this is the sprites encoded in CSS images, the concatenation of CSS and JS files, <a href="https://www.maxcdn.com/one/visual-glossary/domain-sharding-2/">domain sharding</a> and others. </p><br><h2>  SPDY - 2009 </h2><br><p>  Google went further and began experimenting with alternative protocols, setting a goal to make the web faster and improve security by reducing the time it takes to delay web pages.  In 2009, they introduced the SPDY protocol. </p><br><p>  It seemed that if we continue to increase the network bandwidth, it will increase its performance.  However, it turned out that from a certain point on throughput growth ceases to affect performance.  On the other hand, if you operate with a delay value, that is, reduce the response time, the performance gain will be constant.  That was the main idea of ‚Äã‚ÄãSPDY. </p><br><blockquote>  It should be clarified what the difference is: the delay time is a value that indicates how long the data transmission from the sender to the receiver will take (in milliseconds), and the throughput capacity is the amount of data transmitted per second (bits per second). </blockquote><p>  SPDY included multiplexing, compression, prioritization, security, etc ... I do not want to dive into the story about SPDY, because in the next section we will examine the typical HTTP / 2 properties, and HTTP / 2 learned a lot from SPDY. </p><br><p>  SPDY did not try to replace HTTP with itself.  It was a transitional level above HTTP that existed at the application level and modified the request before sending it over the wires.  He began to become the standard de facto, and most browsers began to support it. </p><br><p>  In 2015, Google decided that there should not be two competing standards, and combined SPDY with HTTP, giving rise to HTTP / 2. </p><br><h2>  HTTP / 2 - 2015 </h2><br><p>  I think you have already seen that we need a new version of the HTTP protocol.  HTTP / 2 was designed to transport content with low latency.  The main differences from HTTP / 1.1: </p><br><ul><li>  binary instead of text </li><li>  multiplexing - sending several asynchronous HTTP requests over a single TCP connection </li><li>  HPACK header compression </li><li>  Server Push - multiple responses to one request </li><li>  prioritize requests </li><li>  security </li></ul><br><p><img src="https://habrastorage.org/files/de6/b82/71b/de6b8271b5cd46c6aa5e90638bb5399a.png" alt="HTTP / 2"></p><br><h3>  1. Binary protocol </h3><br><p>  HTTP / 2 tries to solve the increased delay problem that existed in HTTP / 1.x by switching to a binary format.  Binary messages are faster sorted automatically, but, unlike HTTP / 1.x, they are not convenient for people to read.  The main components of HTTP / 2 are frames (Frames) and streams (Streams). </p><br><h4>  Frames and threads. </h4><br><p>  Now HTTP messages consist of one or more frames.  For metadata, the HEADERS frame is used, for basic data, the DATA frame is used, and there are other types of frames (RST_STREAM, SETTINGS, PRIORITY, etc.) that can be found in <a href="http2-spec/">the HTTP / 2 specification</a> . </p><br><p>  Each HTTP / 2 request and response receives a unique stream identifier and is divided into frames.  Frames are simply binary parts of the data.  The frame collection is called a stream.  Each frame contains a stream identifier indicating which thread it belongs to, and each frame contains a common header.  Also, besides the fact that the stream identifier is unique, it is worth mentioning that each client request uses odd id, and the response from the server is even. </p><br><p>  In addition to HEADERS and DATA, RST_STREAM is also worth mentioning - a special type of frame used to interrupt threads.  The client can send this frame to the server, signaling that it no longer needs this stream.  In HTTP / 1.1, the only way to stop the server from sending responses was to close the connection, which increased the delay time, because you had to open a new connection for any further requests.  And in HTTP / 2, the client can send RST_STREAM and stop receiving a certain stream.  At the same time, the connection will remain open, which allows other threads to work. </p><br><h3>  2. Multiplexing </h3><br><p>  Since HTTP / 2 is a binary protocol that uses frames and threads for requests and responses, as mentioned above, all streams are sent on a single TCP connection, without creating additional ones.  The server, in turn, responds in a similar asynchronous manner.  This means that the response has no order, and the client uses the flow identifier to figure out which flow a particular packet belongs to.  This solves the problem of blocking the beginning of the queue ( <em>head-of-line blocking</em> ) - the client does not have to stand idle while waiting for the processing of a long request, because the rest of the requests can be processed while waiting. </p><br><h3>  3. HPACK header compression </h3><br><p>  This was part of a separate RFC specifically aimed at optimizing the headers being sent.  It was based on the fact that if we constantly access the server from the same client, a huge amount of duplicate data is sent in the headers time after time.  And sometimes cookies are added to this, inflating the size of the headers, which reduces network bandwidth and increases latency.  To solve this problem, header compression appeared in HTTP / 2. </p><br><p><img src="https://habrastorage.org/files/02e/77e/8cd/02e77e8cdcda4be9b42ad854d39002b3.png" alt="header table"></p><br><p>  Unlike requests and responses, headers are not compressed into gzip or similar formats.  For compression, a different mechanism is used ‚Äî literal values ‚Äã‚Äãare compressed using <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25B4_%25D0%25A5%25D0%25B0%25D1%2584%25D1%2584%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0">the Huffman algorithm</a> , and the client and server support a single header table.  Duplicate headers (for example, the user agent) are omitted upon repeated requests and refer to their position in the header table. </p><br><p>  Since we are talking about headers, let me add that they do not differ from HTTP / 1.1, except that several pseudo-headings have been added, such as: method,: scheme,: host,: path, and others. </p><br><h3>  4. Server Push </h3><br><p>  Server push is another awesome HTTP / 2 feature.  The server, knowing that the client is going to request a specific resource, can send it without waiting for the request.  For example, when it will be useful: the browser loads the web page, it parses it and finds what other content needs to be downloaded from the server, and then sends the corresponding requests. </p><br><p>  Server push allows the server to reduce the number of additional requests.  If he knows that the client is going to request data, he immediately sends it.  The server sends a special frame PUSH_PROMISE, telling the client: ‚ÄúHey, buddy, now I‚Äôll send you this resource.  You don‚Äôt need to be bothered again. ‚ÄùThe PUSH_PROMISE frame is associated with the thread that caused the push to be sent, and contains the thread identifier on which the server sends the desired resource. </p><br><h3>  5. Prioritize requests </h3><br><p>  The client can assign priority to the stream by adding priority information to the HEADERS frame, which opens the stream.  At any other time, the client can send a PRIORITY frame that changes the priority of the stream. </p><br><p>  If no priority information is specified, the server processes the request asynchronously, i.e.  without any order.  If a priority is assigned, then, based on the priority information, the server decides how much resources are allocated for processing a stream. </p><br><h3>  6. Security </h3><br><p>  Whether security (transmission over the TLS protocol) should be mandatory for HTTP / 2 or not should have developed an extensive discussion.  In the end, it was decided not to make this mandatory.  However, most browser manufacturers have stated that they will support HTTP / 2 only when it will be used over TLS.  Thus, although the specification does not require encryption for HTTP / 2, it will still be mandatory by default.  At the same time, HTTP / 2, implemented on top of TLS, imposes some restrictions: TLS version 1.2 or higher is required, there are restrictions on the minimum key size, ephemeral keys are required, and so on. </p><br><h2>  Conclusion </h2><br><p>  HTTP / 2 is already here, and has already <a href="&amp;xid=17259,15700022,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhj0v_48t_EcUeGKvoA84OUgGXerlQ#search=">bypassed SPDY in support</a> , which is gradually growing.  For anyone interested in learning more, here is a <a href="http2-spec/">link to the specification</a> and a <a href="http2demo.io/">link to a demo</a> showing the advantages of the HTTP / 2 speed. </p><br><p>  HTTP / 2 has a lot to offer to increase performance, and it seems like a good time to start using it. </p><br><hr><br><p>  <em>Original: <a href="http-in-depth/">Journey to HTTP / 2</a> by Kamran Ahmed.</em> </p><br><p>  <em>Translation: <a href="https://github.com/aalexeev239/">Andrei Alekseev</a> , edited by Anatoly Tutov, <a href="https://habrahabr.ru/users/jabher/" class="user_link">Jabher</a> , Igor Pelekhan, Natalya Yorkina, Timofey Marinin, Chaika Chursina, Yana Kriklivaya.</em> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/308846/">https://habr.com/ru/post/308846/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308828/index.html">Bitcoin - money for everyone</a></li>
<li><a href="../308830/index.html">How four-hour support turns into weekly, and some features of HP, IBM, Dell paid service</a></li>
<li><a href="../308840/index.html">Alternative Technologies for High Availability</a></li>
<li><a href="../308842/index.html">In September, the European Union will force the largest IT companies to live in justice</a></li>
<li><a href="../308844/index.html">Veeam Announces New Solutions and Features</a></li>
<li><a href="../308850/index.html">Towards 5G</a></li>
<li><a href="../308852/index.html">Apple Special Event at Rambler & Co</a></li>
<li><a href="../308856/index.html">DiffHTML.js - DOM Patching Utility</a></li>
<li><a href="../308858/index.html">Annual Conference of Free Software Developers and Users OSDN Conference</a></li>
<li><a href="../308860/index.html">Taming USB / IP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>