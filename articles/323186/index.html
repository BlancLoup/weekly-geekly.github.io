<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Metaregular expressions on D</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I ran through the hubs and did not find anything written at the same time in the "D" and "Abnormal Programming" hubs. There can be a completely false ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Metaregular expressions on D</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/8ee/596/c21/8ee596c2154846f99da7a9e8ccf6213d.png" align="left">  I ran through the hubs and did not find anything written at the same time in the "D" and "Abnormal Programming" hubs.  There can be a completely false idea that only normal people write to D, or even worse, that knowledge of D automatically makes a normal person out of any programmer.  I hasten to refute. </p><br><p>  Although I myself, strictly speaking, am not a D programmer, I don‚Äôt have a single industrial project, but occasionally I‚Äôm happy to dig into someone else‚Äôs code for picking up delicious zest.  I also write small utilities for myself, most often for processing text data, what is usually done in scripting languages, the benefit of D offers a very weak set of tools for working with strings. <br>  Well, where there are word processors, there are regular expressions, as without them.  And here D is again at its best, its ease of use and ease of use for its regular expression library approaches Perl.  But in Perl, regulars are part of the syntax, it can be said that the language itself is built largely around them, and in D it is a completely independent module - std.regex from the standard library written by Dmitry Olshansky.  Another great thing is that the expression parser can be built at compile time (of course, if the expression itself is specified by a literal), and of course I could not help but see how it works inside. <br>  And here that, understanding in details at me <del>  hat flew off </del>  there was a thought, but is it possible to call one regular expression from within another?  Do not insert a literal (as trivially you can do in Perl for example), but directly call the compiled code of one expression from the inside of another.  Enough in my opinion a stupid idea that it was worth playing with it. <br>  So what do we want?  Something like this (for now this is pseudocode): </p><br><pre><code class="hljs vbscript"><span class="hljs-built_in"><span class="hljs-built_in">INT</span></span>=<span class="hljs-built_in"><span class="hljs-built_in">regexp</span></span>(<span class="hljs-string"><span class="hljs-string">"\d+"</span></span>); LIST=<span class="hljs-built_in"><span class="hljs-built_in">regexp</span></span>(<span class="hljs-string"><span class="hljs-string">"INT(,INT)*"</span></span>);</code> </pre> <a name="habracut"></a><br><p>  Since the post is designed for a wide audience of abnormal programmers, not only those who are familiar with D, I probably will first describe those language constructs that we will use. </p><br><div class="spoiler">  <b class="spoiler_title">spoiler</b> <div class="spoiler_text"><p>  I myself prefer to have a cheat sheet before my eyes, just like a first grader who has learned a quatrain to a lesson. </p></div></div><br><p>  In general, D offers the broadest choice of basic programming and metaprogramming techniques, but we will try to limit ourselves to the minimum necessary set, but we will try to deal with each in detail.  For those who are interested, I highly recommend reading the wonderful article <a href="http://dlang.org/templates-revisited.html">Templates Revisited</a> written by the author of the language, it is dedicated to templates as a whole, but as an example just shows the compile-time regular expression parser which I took as a basis.  Yes, of course I wrote my little parser for experiments, far from complete and not entirely correct, but ideally suited as a guinea pig. <br>  So: </p><br><h4 id="vychisleniya-vremeni-kompilyacii">  compile time calculations. </h4><br><p>  With this, everything is simple, roughly speaking any expression that can be calculated at compile time will be calculated.  The second fundamental construct is <em>static if (...)</em> , is checked at compile time (or is not compiled at all), and incredibly simplifies metaprogramming. </p><br><h4 id="shablony">  templates </h4><br><p>  In D, the templates of both functions and classes are declared using an additional set of parameters: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T x </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">,</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">)  {</span></span> T x; U y; }</code> </pre> <br><p>  and called as </p><br><pre> <code class="hljs lisp"> f!(<span class="hljs-name"><span class="hljs-name">int</span></span>)(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)<span class="hljs-comment"><span class="hljs-comment">; A!(int,string) a;</span></span></code> </pre> <br><p>  A template parameter can also be roughly speaking anything, including floating and string literals and <em>any characters</em> .  However, the <em>template</em> keyword is also saved and creates <em>parameterized namespace's</em> which we will use extensively: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">X</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T x=<span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h4 id="mixin">  mixin </h4><br><p>  This construct inserts a literal directly into the code: <code>mixin("static int x=0;");</code>  also useful. </p><br><h4 id="operacii-so-strokami">  string operations </h4><br><p>  There are a million of them, but we really only need <em>slicing</em> : <code>"ABCDEFGH"[2..4] == "CDE";</code>  Note that the above example is also computed at compile time. </p><br><h4 id="alias">  alias </h4><br><p>  This means just a synonym, but with the widest range of applications, especially in the parameters of the templates (the very <em>any symbol</em> mentioned) </p><br><h4 id="znamenityy-_eponymous-trick_">  famous <em>eponymous trick</em> </h4><br><p>  I will deliberately <strong>not</strong> use it, because at first the newcomers slightly blow the roof from it.  In the end, it is nothing more than syntactic sugar, and you can always do without it. </p><br><h3 id="vot-sobstvenno-i-ves-nash-instrumentariy-perehodim-k-parseru">  That's actually all of our tools, go to the parser. </h3><br><p>  View from above: </p><br><pre> <code class="hljs pgsql"><span class="hljs-number"><span class="hljs-number">1.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> regex(string re) <span class="hljs-number"><span class="hljs-number">2.</span></span> { <span class="hljs-number"><span class="hljs-number">3.</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(re.length) { <span class="hljs-number"><span class="hljs-number">4.</span></span> // parse escaped <span class="hljs-keyword"><span class="hljs-keyword">sequences</span></span> <span class="hljs-number"><span class="hljs-number">5.</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(re[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'\\'</span></span>) { <span class="hljs-number"><span class="hljs-number">6.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> atom=compile_escape!re; <span class="hljs-number"><span class="hljs-number">7.</span></span> <span class="hljs-number"><span class="hljs-number">8.</span></span> // parse <span class="hljs-type"><span class="hljs-type">character</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-number"><span class="hljs-number">9.</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(re[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'['</span></span>) { <span class="hljs-number"><span class="hljs-number">10.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> atom=compile_class!re; <span class="hljs-number"><span class="hljs-number">11.</span></span> <span class="hljs-number"><span class="hljs-number">12.</span></span> // parse atom <span class="hljs-number"><span class="hljs-number">13.</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(re[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'('</span></span>) { <span class="hljs-number"><span class="hljs-number">14.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> atom=compile_atom!re; <span class="hljs-number"><span class="hljs-number">15.</span></span> <span class="hljs-number"><span class="hljs-number">16.</span></span> // parse dot <span class="hljs-number"><span class="hljs-number">17.</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(re[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'.'</span></span>) { <span class="hljs-number"><span class="hljs-number">18.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> atom=compile_anychar!re; <span class="hljs-number"><span class="hljs-number">19.</span></span> <span class="hljs-number"><span class="hljs-number">20.</span></span> // parse regular literals <span class="hljs-number"><span class="hljs-number">21</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-number"><span class="hljs-number">22.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> atom=compile_char!re; <span class="hljs-number"><span class="hljs-number">23.</span></span> } <span class="hljs-number"><span class="hljs-number">24.</span></span> <span class="hljs-number"><span class="hljs-number">25.</span></span> // parse predicate (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>) *+? <span class="hljs-number"><span class="hljs-number">26.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> pred=compile_pred!(atom, re[atom.skip..$]); <span class="hljs-number"><span class="hljs-number">27.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> result=both_of!(pred, regex!(re[pred.skip..$])); <span class="hljs-number"><span class="hljs-number">28.</span></span> <span class="hljs-number"><span class="hljs-number">29.</span></span> // <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> result <span class="hljs-number"><span class="hljs-number">30.</span></span> static const size_t skip=result.skip; <span class="hljs-number"><span class="hljs-number">31.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> match=result.match; <span class="hljs-number"><span class="hljs-number">32.</span></span> <span class="hljs-number"><span class="hljs-number">33.</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-number"><span class="hljs-number">34.</span></span> static const size_t skip=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">35.</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> regular expression <span class="hljs-number"><span class="hljs-number">36.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> match=test_empty!(re); <span class="hljs-number"><span class="hljs-number">37.</span></span> } <span class="hljs-number"><span class="hljs-number">38.</span></span> }</code> </pre> <br><p>  First, what is it?  Not a function, not a class, a template in its pure form, just a piece of code parameterized by a literal.  However, the <em>alias</em> on him is regularly taken. <br>  The second thing to notice is that from all this abundance of code only one small branch is compiled (pay attention to the <em>static if</em> cascade) <br>  Return Values?  There are two of them (pp. 30-31 and 34-36): <br> <code>static const size_t skip;</code>  - shows how many characters from the regular expression we used. <br> <code>alias match;</code>  Is <em>something</em> ( <em>alias</em> ) that can be called as a function with the <em>string</em> parameter. <br>  Well, it is proposed to use it like this: </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> myRe=regex!<span class="hljs-string"><span class="hljs-string">"A?[az]+\d*"</span></span>; auto result=myRe.<span class="hljs-keyword"><span class="hljs-keyword">match</span></span>(some_string);</code> </pre> <br><p>  Looking ahead, I will say that the return value is a structure of two elements: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Match { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _success; <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> length; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T : </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span></span><span class="hljs-function">)(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _success; } }</code> </pre> <br><p>  the first shows whether the string satisfies the regular expression, and the second shows the length of the passed substring.  Although now, at the time of compilation, we are deeply on the drum. </p><br><h4 id="proydemsya-teper-po-vetochkam-udobnee-nachinat-snizu">  Let's walk now along the branches, it is more convenient to start from the bottom: </h4><br><p>  If the regular expression is empty <em>(re.length == 0) (p. 33)</em> , we return the reference to the function that returns always <em>true</em> , that is, <em>Match (true, 0)</em> .  This is the successful end of the parsing. <br>  If the regular expression is not empty (page 3), we first choose a subparser from the <i>compile <em>XXX</em></i> set <i>depending on the first character: service</i> \. [(_ Or any other character. The subparser has the same interface as the top level parser - defines constants inside itself) <em>skip</em> and <em>match</em> and in the last (simplest, p. 22) branch returns <em>skip = 1</em> and a link to the function that checks the first characters of two lines for equality, like this: </p><br><pre> <code class="hljs lua">template compile_char(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> re) { static const size_t skip=<span class="hljs-number"><span class="hljs-number">1</span></span>; alias <span class="hljs-built_in"><span class="hljs-built_in">match</span></span>=test_char!re; } // <span class="hljs-built_in"><span class="hljs-built_in">match</span></span> single character Match test_char(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> re)(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s) { static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(re.length) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(s.length &amp;&amp; s[<span class="hljs-number"><span class="hljs-number">0</span></span>] == re[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Match(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Match(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><p>  The second construction here is a regular template function that will be called during execution. <br>  The rest of the subparsers are not much more complicated and similarly arranged, but what happens after the parser is selected?  Then a predicate can go, one of <em>? * +</em> , Or not, so the selected subparser is passed to another parser: <i>compile_pred (page 26)</i> : </p><br><pre> <code class="hljs pgsql">// modify previous (term) regex <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> one <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> *+? predicates, <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">none</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> compile_pred(<span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> term, string re) { static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(re.length) { static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(re[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'*'</span></span>) { static const size_t skip=term.skip+<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> match=zero_or_more!term; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(re[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'+'</span></span>) { static const size_t skip=term.skip+<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> match=one_or_more!term; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(re[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'?'</span></span>) { static const size_t skip=term.skip+<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> match=zero_or_one!term; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> predicate, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> term static const size_t skip=term.skip; <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> match=term.match; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> predicate, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> regex, <span class="hljs-keyword"><span class="hljs-keyword">also</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> term static const size_t skip=term.skip; <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> match=term.match; } } // conditionally match the expression, <span class="hljs-keyword"><span class="hljs-keyword">always</span></span> match but matched length may be different Match zero_or_one(<span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> term)(string s) { Match r=term.match(s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r? r : Match(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><p>  Here, according to the already run-in scenario, depending on the predicate, <em>skip is</em> incremented by one and the <em>match</em> function is set to one of the _zero_or_more (*), zero_or_one (?) Or one_or <em>more (+)</em> template functions, I gave one of them for example.  Or, if the predicate is absent, both of these values ‚Äã‚Äãare taken unchanged from the atomic parser. </p><br><h4 id="kak-vsegda-s-shablonami-v-konce-dolzhna-byt-rekursiya">  As always with patterns, there must be a recursion at the end. </h4><br><p>  Returning to the main parser, we got the complete expression for the subparser with the predicate and now finally pass it to the last subparser, which calls both parsers in turn and calculates the total length (page 27): </p><br><pre> <code class="hljs lua"> alias result=both_of!(pred, regex!(re[pred.skip..$])); static const size_t skip=result.skip; alias <span class="hljs-built_in"><span class="hljs-built_in">match</span></span>=result.<span class="hljs-built_in"><span class="hljs-built_in">match</span></span>; ... // <span class="hljs-built_in"><span class="hljs-built_in">match</span></span> both expressions template both_of(alias re1, alias re2) { static const size_t skip=re1.skip+re2.skip; alias <span class="hljs-built_in"><span class="hljs-built_in">match</span></span>=test_join!(re1,re2); } // <span class="hljs-built_in"><span class="hljs-built_in">match</span></span> both of expressions, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> matched length Match test_join(alias re1, alias re2)(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s) { auto m1=re1.<span class="hljs-built_in"><span class="hljs-built_in">match</span></span>(s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m1) { auto m2=re2.<span class="hljs-built_in"><span class="hljs-built_in">match</span></span>(s[m1.length..$]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Match(m1 &amp;&amp; m2, m1.length+m2.length); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m1; }</code> </pre> <br><p>  Note that the second parameter for the sub_parser <i>both_of the</i> main parser passes itself, but with the trimmed regular expression <em>regex! (re [pred.skip .. $])</em> , the first characters already used by the subparser are cut off.  Thus, the regular expression will be recursively passed to the end, a chain of <i>sample</i> functions such as <i>test_char, test_space, test_range, one_or_more</i> , etc. will be built, and we will return to what we started with - an empty expression for which the <i>test_empty</i> function is <i>always</i> returned <i>that</i> returns <em>(true, 0)</em> . <br>  Parsing is over. </p><br><p>  Before going to the essence of the post, I want to give another auxiliary template (it has already been used in parsing the expressions "[]" and "()").  As it is easy to understand, it recursively calculates the length of a string to a given character.  Soon it will be useful to us: </p><br><pre> <code class="hljs pgsql">// misc., <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> literal up the <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> terminator <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> extract_until(string s, <span class="hljs-type"><span class="hljs-type">char</span></span> terminator) { static <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(s.length, "missing terminator"); static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(s[<span class="hljs-number"><span class="hljs-number">0</span></span>] == terminator) { static const length=<span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { static const length=<span class="hljs-number"><span class="hljs-number">1</span></span>+extract_until!(s[<span class="hljs-number"><span class="hljs-number">1.</span></span>.$], terminator).length; } }</code> </pre> <br><h3 id="nakonec-my-doshli-do-suti">  Finally we got to the bottom </h3><br><p>  So, we built a model parser that understands the <em>\ s \ d \ w \ x</em> constructions <em>.</em>  <em>[az] (AB) * +?</em>  it is now quite easy to add one more branch to it.  If anyone noticed, along with other missing expressions, I was too lazy to build processing the predicate {n, m}.  Since it‚Äôs a sin not to use such beautiful brackets, I usurp them to express <em>{SUBEXPR}</em> .  See, first add a branch to the main parser: </p><br><pre> <code class="hljs pgsql"> // parse meta expression } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(re[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'{'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> atom=compile_meta!re;</code> </pre> <br><p>  Now we add a subparser for it, surprisingly simple: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compile_meta</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> re)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> skip=<span class="hljs-number"><span class="hljs-number">2</span></span>+extract_until!(re[<span class="hljs-number"><span class="hljs-number">1.</span></span>.$], <span class="hljs-string"><span class="hljs-string">'}'</span></span>).length; mixin(<span class="hljs-string"><span class="hljs-string">"alias match="</span></span>~re[<span class="hljs-number"><span class="hljs-number">1.</span></span>.skip<span class="hljs-number"><span class="hljs-number">-1</span></span>]~<span class="hljs-string"><span class="hljs-string">".match;"</span></span>); }</code> </pre> <br><p>  the first line calculates the length of the subexpression up to the closing bracket, and the second uses <em>mixin</em> to insert the following link into the code: <code>alias match=SUBEXPR.match;</code>  .  And it's all!  It starts to work. <br>  Now we can finally write: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> NUM=regex!"\\d+"; <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> <span class="hljs-type"><span class="hljs-type">INT</span></span>=regex!"[+-]?{NUM}"; <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> LIST=regex!"{INT}(,{INT})*"; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(NUM.match("1234") == Match(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, "1234".length)); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(<span class="hljs-type"><span class="hljs-type">INT</span></span>.match("-12") == Match(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, "-12".length)); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(LIST.match("1,+2,-3,4") == Match(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, "1,+2,-3,4".length));</code> </pre> <br><p>  Just some buffalo turned out. </p><br><h3 id="i-tut-mne-podumalos-">  And then I thought ... </h3><br><p>  If I were a character in a Hollywood film, a sort of crazy genius, I would, according to the laws of the genre, must have missed something, some trifle that would have destroyed my evil plans at the end. <br>  And just thought how here it is - the <strong>cyclic dependence of the modules</strong> .  The fact is that this all works fine inside a single file, and if I tried to isolate this code into a separate library or module, nothing would have happened.  In the example above, the <em>NUM</em> and <em>INT</em> characters defined in user-code should be exported down to the metare module level, which is obviously impossible.  But nothing, someday, in any language, someone will suggest a way around <del>  and then I will finally conquer this world </del>  . <br>  Thank you all, I hope it was fun. <br>  As usual, if anyone needs it - a <a href="https://github.com/sdegtiarev/metare">link to the code</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/323186/">https://habr.com/ru/post/323186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323172/index.html">Our servers and hacker attack on US Democrats: the continuation of the story</a></li>
<li><a href="../323176/index.html">Deploying multi-user WebRTC broadcasts from a webcam via a server in 3 minutes</a></li>
<li><a href="../323178/index.html">FixPrice Agile or SCRUM via F‚Ä¶ ira</a></li>
<li><a href="../323180/index.html">Internationalization (i18n) in Angular 2</a></li>
<li><a href="../323182/index.html">Copyleft at risk: does Github lose GPL compatibility?</a></li>
<li><a href="../323188/index.html">Programmers can not write algorithms without help: once again about the interview</a></li>
<li><a href="../323192/index.html">Z-order vs R-tree, optimization and 3D</a></li>
<li><a href="../323194/index.html">What are the authors of ‚ÄúHello World?‚Äù Silent</a></li>
<li><a href="../323198/index.html">Dagaz: From simple to complex</a></li>
<li><a href="../323200/index.html">Power BI Embedded, IoT and machine learning for processing brain thermograms</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>