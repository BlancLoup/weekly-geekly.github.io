<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Inside the super-fast CSS engine: Quantum CSS (aka Stylo)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I present to you the translation of the article Inside a super fast CSS engine: Quantum CSS (aka Stylo) by Lin Clark . 


 You may have hear...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Inside the super-fast CSS engine: Quantum CSS (aka Stylo)</h1><div class="post__text post__text-html js-mediator-article"><p>  Hi, Habr!  I present to you the translation of the article <a href="https://hacks.mozilla.org/2017/08/inside-a-super-fast-css-engine-quantum-css-aka-stylo/">Inside a super fast CSS engine: Quantum CSS (aka Stylo)</a> by <a href="https://code-cartoons.com/">Lin Clark</a> . </p><br><p>  You may have heard of Project Quantum ... This is a project to significantly rework the insides of Firefox to speed up the browser.  In parts, we introduce the developments of our experimental browser Servo and significantly improve the other elements of the engine. </p><br><p>  The project was compared with the replacement of the aircraft engine on the fly.  We make changes to the Firefox component by component, so we can evaluate their effect in the next release of the browser immediately upon readiness. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/155/e27/db5/155e27db5bf840a4460657cdf4858a01.png" alt="image"></a> </p><br><p>  <em>Note</em>  <em>translator: under the cut a lot of illustrations.</em>  <em>All of them are clickable (for viewing in higher resolution).</em>  <em>If you stumble on inaccuracies of translation and other errors - I will be grateful if you report this in the comments or in a personal.</em> </p><a name="habracut"></a><br><p> And the first major component from Servo - the new CSS engine Quantum CSS (formerly known as Stylo) - is now available for testing in the nightly build of Firefox <em>(note the translator: in the comments suggested that already in stable 55 is)</em> .  The option <code>layout.css.servo.enabled</code> in <code>about:config</code> is responsible for its inclusion. </p><br><p>  The new engine embodies the best innovations from other browsers. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/9d3/b53/742/9d3b53742e0b56ff33d93d429a767d62.png" alt="image"></a> </p><br><p>  Quantum CSS takes advantage of modern hardware by parallelizing the work between all processor cores, which gives acceleration up to 2, 4 or even 18 times. </p><br><p>  In addition, it combines modern optimizations from other browsers, so even without parallelization, it is very fast. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/46f/f3d/6c3/46ff3d6c391af620f6f6cb609f560be1.png" alt="image"></a> </p><br><p>  But what exactly does the CSS engine do?  First, let's look at what the CSS engine as a whole is and what its place is in the browser, and then we analyze how Quantum CSS accelerates the whole thing. </p><br><h2 id="chto-takoe-css-dvizhok">  What is a CSS engine? </h2><br><p>  The CSS engine is part of the browser's rendering engine.  The rendering engine accepts HTML and CSS files of the site and turns them into pixels on the screen. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/53e/128/08c/53e12808c8f7455b7e81af026a5aa619.png" alt="image"></a> </p><br><p>  Each browser has a rendering engine.  Chrome has Blink, Edge has EdgeHTML, Safari has WebKit, and Firefox has Gecko. </p><br><p>  To digest files into pixels, they all do about the same thing: </p><br><p>  1) Parsing files to browser-friendly objects, including the DOM.  At this point, the DOM knows about the structure of the page, knows about the parent relationship between elements, but does not know how these elements should look. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/f3c/4cd/eaa/f3c4cdeaaa34597961176b27f88f6854.png" alt="image"></a> </p><br><p>  2) Determination of the appearance of elements.  For each DOM node, the CSS engine determines which CSS rules to apply.  Then it determines the value for each CSS property.  Styles each node in the DOM tree, attaching calculated styles. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d06/918/2e6/d069182e632e05b7ef6a1730e105ed7d.png" alt="image"></a> </p><br><p>  3) Determining the size and position for each node.  For everything that needs to be displayed on the screen, boxes are created.  They represent not only DOM nodes, but also what can be inside them.  For example, lines of text. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/136/f03/015/136f030158df3b90974470ddffca184e.png" alt="image"></a> </p><br><p>  4) Drawing blocks.  It can occur on several layers.  I imagine this as old, hand-drawn animations on several sheets of translucent paper.  This allows you to change one layer, without the need to redraw others. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/c9f/965/333/c9f965333fe1fcd96fee72eb4fed66f1.png" alt="image"></a> </p><br><p>  5) Combining layers into one image, having previously applied to them the necessary properties of the composer (for example, transformations).  This is how to take a picture of layers combined together.  Further this image will be displayed on the screen. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/da1/53c/5b2/da153c5b2b51660e14460d1903bb9eb7.png" alt="image"></a> </p><br><p>  That is, before the start of rendering styles at the input of the CSS engine there is: </p><br><ul><li>  Dom tree </li><li>  List of style rules </li></ul><br><p>  And so, it alternately defines styles for each DOM node, one by one.  A value is assigned to each CSS property, even if it is not specified in the style sheets. </p><br><p>  I imagine this as filling out a form where all fields are required.  You need to fill out a form for each DOM node. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/8d2/0e5/6b8/8d20e56b8752138d8f925e691c58cc35.png" alt="image"></a> </p><br><p>  To do this, the CSS engine has to do two things: </p><br><ul><li>  Select the rules that should be applied to the node (selector matching, selector matching) </li><li>  Fill all missing values ‚Äã‚Äãwith standard values ‚Äã‚Äãor inherit parent values ‚Äã‚Äã(cascading, the cascade) </li></ul><br><h3 id="sopostavlenie-selektorov">  Mapping selectors </h3><br><p>  To begin with, we select all the rules applicable to the node in the list.  Since there may be several suitable rules, several definitions of the same property are possible. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/c95/900/442/c959004425f0426af80870b9a0311ed8.png" alt="image"></a> </p><br><p>  In addition, the browser itself adds some standard styles (user agent style sheets).  So how does the CSS engine determine which value to use? </p><br><p>  This is where the specificity rule comes to the rescue.  The CSS engine creates a table of definitions, which is then sorted into different columns. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/aff/da9/781/affda9781d987dfba21fe9f8619a5e9e.png" alt="image"></a> </p><br><p>  The rule with the most concrete wins.  Based on such a table, the CSS engine inserts all the values ‚Äã‚Äãspecified in it into the form. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/126/04f/8db/12604f8db375960a9084135ef359441d.png" alt="image"></a> </p><br><p>  The rest is calculated by cascading. </p><br><h3 id="kaskadirovanie">  Cascading </h3><br><p>  Cascading simplifies writing and maintaining CSS.  Thanks to him, you can set the <code>color</code> property of the <code>body</code> , and know that the text color in the elements <code>p</code> , <code>span</code> , <code>li</code> will be the same (unless you override it yourself). </p><br><p>  The CSS engine checks for blank fields in the form.  If the property is inherited by default, the CSS engine climbs through the tree and checks if the property is set to this property of the parent element.  If none of the ancestors defines the value, or it is not inherited, then the default value is set. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/8a4/868/a41/8a4868a414dd5adf866d96288e467cc9.png" alt="image"></a> </p><br><p>  So now all the styles for a given DOM node are calculated, the form is filled. </p><br><h3 id="primechanie-sovmestnoe-ispolzovanie-struktur-stiley">  Note: Sharing Style Structures </h3><br><p>  The described form is slightly simplified.  CSS has hundreds of properties.  If the CSS engine retained the value of each property for each DOM node, it would quickly use all the available memory. </p><br><p>  Instead, engines typically use the style struct sharing mechanism.  They store values ‚Äã‚Äãthat are commonly used together (for example, font properties) in another object called ‚Äústyle structure‚Äù.  Further, instead of storing all the properties in a single object, the objects of the calculated styles contain only a pointer.  For each category of properties, there is a pointer to the style structure with the desired values. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b60/1d4/d5c/b601d4d5c91590ce6550d3089574e5c9.png" alt="image"></a> </p><br><p>  It saves both memory and time.  Nodes with similar styles can simply point to the same style structures for common properties.  And since many properties are inherited, a parent can share its structure with any child nodes that do not override their own values. </p><br><h2 id="tak-kak-zhe-my-vse-eto-uskoryaem">  So how do we all accelerate it? </h2><br><p>  This is a non-optimized style calculation process. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/c57/416/d6d/c57416d6d0b27c795af454d8b85f81f9.png" alt="image"></a> </p><br><p>  There is a lot of work done.  And not only at the time of the first page load.  And again and again, in the course of the interaction with the page, when you hover the cursor on the elements or change the DOM, styles are recalculated. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/c58/785/f8f/c58785f8ff2dd2d91da1f135e1201a89.png" alt="image"></a> </p><br><p>  This means that the computation of CSS styles is an excellent candidate for optimization ... And over the past 20 years, browsers have retested many different optimization strategies.  Quantum CSS is trying to combine the best of them to create a new super-fast engine. </p><br><p>  Let's take a look at how this all works together. </p><br><h3 id="rasparallelivanie">  Paralleling </h3><br><p>  The Servo project (from which Quantum CSS came out) is an experimental browser that tries to parallelize everything in the process of drawing a web page.  What does it mean? </p><br><p>  You can compare the computer with the brain.  There is an element responsible for thinking (ALU).  Near it is located something like a short-term memory (registers), the latter are grouped together on a central processor.  In addition, there is a long-term memory (RAM). </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/7f6/ff8/02d/7f6ff802d64e8d83f938c97815b5cd94.png" alt="image"></a> </p><br><p>  Early computers could think only one thought at a time.  But over the past decades, processors have changed; now they have several ALUs and registers grouped into cores.  So now processors can think several thoughts at the same time - in parallel. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/390/ddd/efa/390dddefa2576875a6a42063fdf7bfa0.png" alt="image"></a> </p><br><p>  Quantum CSS takes advantage of these advantages by separating the computation of styles for different DOM nodes across different cores. </p><br><p>  It may seem that it is easy ... Just divide the branches of a tree and process them on different cores.  In fact, everything is much more complicated for several reasons.  The first reason is that DOM-trees are often uneven.  That is, some cores will receive significantly more work than others. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/254/1e3/145/2541e3145ca46765fd3e7d896877ee46.png" alt="image"></a> </p><br><p>  To distribute work more evenly Quantum CSS uses a technique called work stealing.  When a DOM node is processed, the program takes its direct children and divides them into one or more work units.  These units of work are queued. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4c6/942/2b8/4c69422b88d4e178e0ae9efe69e87946.png" alt="image"></a> </p><br><p>  When a core has completed all the work in its turn, it can look for work in other queues.  Thus, we evenly distribute the work without the need for a preliminary assessment with a walk through the whole tree. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4ae/668/3b6/4ae6683b6a042f428692d27af7a39d95.png" alt="image"></a> </p><br><p>  In most browsers it will be difficult to implement this correctly.  Parallelism is obviously a difficult task, and the CSS engine is quite complex in itself.  It is also located between the other two most difficult parts of the rendering engine - DOM and markup.  In general, it is easy to make a mistake, and paralleling can lead to fairly difficult to isolate bugs called data races.  I describe these bugs in more detail in <a href="https://hacks.mozilla.org/2017/06/avoiding-race-conditions-in-sharedarraybuffers-with-atomics/">another article</a> (there is also a <a href="https://medium.com/devschacht/avoiding-race-conditions-in-sharedarraybuffers-with-atomics-8de5323aad63">translation into Russian</a> ). </p><br><p>  If you accept edits from hundreds of thousands of contributors, how can you apply concurrency without fear?  For this we have <a href="http://rust-lang.org/">Rust</a> . </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/1d3/dd9/254/1d3dd9254d10f56ae6ce521a2ea1ada5.png" alt="image"></a> </p><br><p>  Rust allows you to statically verify that there is no data race.  That is, you avoid hard-to-catch bugs, preventing them from entering your code initially.  The compiler will simply not allow you to do this.  I will write more about this in future articles.  You can also watch the <a href="https://www.youtube.com/watch%3Fv%3DcNeIOt8ZdAY">introductory video about concurrency in Rust</a> or this <a href="https://www.youtube.com/watch%3Fv%3Dgof_OEv71Aw">more detailed conversation about the ‚Äújob theft‚Äù</a> . </p><br><p>  All this greatly simplifies the matter.  Now almost nothing stops you from realizing the calculation of CSS styles effectively in parallel.  This means that we can get closer to linear acceleration.  If your processor is 4-core, then parallelization will give an increase in speed of almost 4 times. </p><br><h3 id="uskorenie-pereraschyota-s-pomoschyu-dereva-pravil">  Acceleration of recalculation using the rule tree </h3><br><p>  For each DOM node, the CSS engine must go through all the rules and perform a selector mapping.  For most nodes, the corresponding selectors will most likely not change very often.  For example, if a user hovers the mouse over an element, the corresponding rules may change.  We need to recalculate styles for all its descendants in order to handle the inheritance of properties.  But the rules corresponding to these descendants probably will not change. </p><br><p>  It would be nice to remember which rules correspond to these descendants, so that you don‚Äôt have to match the selectors again ... And the rule tree from previous versions of Firefox does just that. </p><br><p>  The CSS engine selects the selectors corresponding to the element, and then sorts them by specificity.  The result is a linked list of rules. </p><br><p>  This list is added to the tree. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/3e8/7f2/69c/3e87f269c4648733edaf2b416d31921d.png" alt="image"></a> </p><br><p>  The CSS engine tries to minimize the number of branches in the tree, re-using them when possible. </p><br><p>  If the majority of selectors in the list coincide with the existing branch, it will follow it.  But it can reach the point where the next rule in the list does not match the rule from the existing branch.  Only in this case a new branch is created. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/c63/953/302/c63953302d89f8ee2765657d853d45b9.png" alt="image"></a> </p><br><p>  The DOM node will receive a pointer to the rule that was added last (in our example, <code>div#warning</code> ).  It is the most specific. </p><br><p>  When recalculating styles, the engine performs a quick check to see if a change in the rules of the parent element can affect the rules of the children.  If not, for all descendants, the engine can simply use a pointer to the corresponding rule in the tree.  That is, completely skip the mapping of selectors and sorting. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/293/c21/9fb/293c219fb22ed9ea653e1d59e7cc41ce.png" alt="image"></a> </p><br><p>  And so, it helps save time when recalculating styles, but the initial calculation is still laborious.  If there are 10,000 nodes, then it is necessary to do a mapping of selectors 10,000 times.  But there is a way to speed it up. </p><br><h3 id="uskorenie-nachalnogo-renderinga-pri-pomoschi-obschego-kesha-stiley">  Accelerate Initial Rendering with Shared Style Cache </h3><br><p>  Imagine a page with thousands of nodes.  Many of them will follow the same rules.  For example, imagine a long Wikipedia page ... Main content paragraphs should have absolutely identical style rules and absolutely identical calculated styles. </p><br><p>  Without optimizations, the CSS engine must match selectors and calculate styles for each paragraph separately.  But if there was a way to prove that the styles for all paragraphs are the same, the engine could simply do this work once, and simply point to the same calculated style from each node. </p><br><p>  This is what makes the general rules cache, inspired by Safari and Chrome.  After processing the element, the calculated style is placed in the cache.  Further, before starting the calculation of the styles of the next element, several checks are performed to check whether it is possible to use something from the cache. </p><br><p>  The checks are as follows: </p><br><ul><li>  Do 2 nodes have the same ID, classes, etc.  If so, they will follow the same rules. </li><li>  Do they have the same value for everything that is not based on selectors (for example, inline styles).  If so, the above rules will not be redefined, or they will be redefined equally for both. </li><li>  Whether parents of both indicate the same object of the calculated styles.  If so, then the inherited values ‚Äã‚Äãwill also be the same. </li></ul><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/a3f/c4f/8ba/a3fc4f8baf340e565ecfaccd5e7e5e87.png" alt="image"></a> </p><br><p>  These checks were implemented in earlier versions of the common styles cache from the very beginning.  But there are many small situations in which styles do not match.  For example, if the CSS rule uses the <code>:first-child</code> selector, the styles of the two paragraphs may not be the same, even if the above checks state the opposite. </p><br><p>  WebKit and Blink in such situations give up and do not use a common cache of styles.  And the more sites using these modern selectors, the less benefit this optimization becomes, so the Blink team recently removed it altogether.  But it turns out that there is an opportunity to keep up with all these updates and with a common style cache. </p><br><p>  In Quantum CSS, we collect all those strange selectors and check if they apply to the DOM node.  Then we save the result of this check as units and zeros for each such selector.  If two elements have an identical set of ones and zeros, we know that they exactly match. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/170/b30/f03/170b30f039f7d9fd21e6dd3f14512fae.png" alt="image"></a> </p><br><p>  If the DOM node can use styles that have already been calculated, in fact almost all work is skipped.  Pages often have many nodes with the same style, so a common style cache saves memory and really speeds up work. </p><br><p> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/1bc/349/646/1bc349646ffa30437a1450bdc1547138.png" alt="image"></a> </p><br><h2 id="vyvod">  Conclusion </h2><br><p>  This is the first major technology transfer from Servo to Firefox.  We have learned a lot about how to bring modern, high-performance code on Rust into the core of Firefox. </p><br><p>  We are very pleased that a large piece of Project Quantum is ready for beta use.  We will be grateful if you try it and, in case of errors, <a href="http%253A%252F%252F%26bug_ignored%3D0%26bug_severity%3Dnormal%26bug_status%3DNEW%26cf_fx_iteration%3D---%26cf_fx_points%3D---%26component%3DCSS%2520Parsing%2520and%2520Computation%26contenttypemethod%3Dautodetect%26contenttypeselection%3Dtext%252Fplain%26defined_groups%3D1%26flag_type-203%3DX%26flag_type-37%3DX%26flag_type-4%3DX%26flag_type-41%3DX%26flag_type-5%3DX%26flag_type-607%3DX%26flag_type-721%3DX%26flag_type-737%3DX%26flag_type-781%3DX%26flag_type-787%3DX%26flag_type-799%3DX%26flag_type-800%3DX%26flag_type-803%3DX%26flag_type-835%3DX%26flag_type-846%3DX%26flag_type-855%3DX%26flag_type-863%3DX%26flag_type-864%3DX%26flag_type-914%3DX%26flag_type-916%3DX%26form_name%3Denter_bug%26keywords%3Dnightly-community%252C%2520%26maketemplate%3DRemember%2520values%2520as%2520bookmarkable%2520template%26op_sys%3DUnspecified%26priority%3D--%26product%3DCore%26rep_platform%3DUnspecified%26short_desc%3DStylo%253A%2520%26target_milestone%3D---%26version%3DTrunk">report them</a> . </p><br><h2 id="o-lin-klark">  Oh Lin Clark </h2><br><p>  Lin is an engineer on the Mozilla Developer Relations team.  It works with JavaScript, WebAssembly, Rust and Servo.  And also draws <a href="http://code-cartoons.com/">code cartoons</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/336722/">https://habr.com/ru/post/336722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336710/index.html">Chrome DevTools Tricks</a></li>
<li><a href="../336714/index.html">Unity 2017: an overview of new features</a></li>
<li><a href="../336716/index.html">We sculpt a toolbar on PyQt, export data to Excel and HTML</a></li>
<li><a href="../336718/index.html">Interview with Herbert Lin (CISAC): ‚ÄúCyber ‚Äã‚Äãsecurity is an endless battle‚Äù</a></li>
<li><a href="../336720/index.html">How to lead introverts without harm to health</a></li>
<li><a href="../336724/index.html">35-kilobyte post-nuclear caravan</a></li>
<li><a href="../336726/index.html">How well are your SSH sessions secured?</a></li>
<li><a href="../336728/index.html">ARCore: Augmented Reality on Android</a></li>
<li><a href="../336730/index.html">Google Titan - New Chip Details Revealed</a></li>
<li><a href="../336732/index.html">Source Ripper and AST Spring Boot Tree</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>