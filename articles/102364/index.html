<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cartesian tree: Part 3. Cartesian tree by implicit key</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table of Contents (for now) 
 Part 1. Description, operation, application. 
 Part 2. Valuable information in the tree and multiple operations with it....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cartesian tree: Part 3. Cartesian tree by implicit key</h1><div class="post__text post__text-html js-mediator-article"><h4>  Table of Contents (for now) </h4><br>  <a href="http://habrahabr.ru/blogs/algorithm/101818/">Part 1. Description, operation, application.</a> <br>  <a href="http://habrahabr.ru/blogs/algorithm/102006/">Part 2. Valuable information in the tree and multiple operations with it.</a> <br>  <b>Part 3. The Cartesian tree by implicit key.</b> <br>  <em>To be continued ...</em> <br><br><h4>  Very strong witchcraft </h4><br>  After all the heaps of opportunities that the Cartesian tree gave us in the previous two parts, today I will do something strange and blasphemous with it.  Nevertheless, this action will allow to consider a tree in a completely new incarnation - as a kind of improved and powerful array with additional features.  I will show you how to work with it, I will show that all operations with the data from the second part are also saved for the modified tree, and then I will cite several new and useful ones. <br><br>  Recall the structure of the deramids.  It contains the key <strong>x</strong> , for which the deramid is a search tree, the random key <strong>y</strong> , for which the deramid is a heap, and also, perhaps, some user information <strong>c</strong> (cost).  Let's do the impossible and consider the deramid ... without the x keys.  That is, we will have a tree in which the x key is not present at all, and the y keys are random.  Accordingly, why it is needed is generally incomprehensible :) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In fact, this structure is regarded as a Cartesian tree, in which the keys x are still somewhere, but we are not informed.  However, they swear that the condition of a binary search tree is fulfilled for them.  Then you can imagine that these unknown X's are numbers from 0 to <nobr>N-1</nobr> and <em>implicitly</em> arrange them according to the tree structure: <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/habraeffect/81/57/815702b5f5d49c63c470caa3c21f2def.png"></div><br>  It turns out that in the tree it is as if the keys at the vertices are not marked, but the vertices themselves are numbered.  Moreover, they are numbered in the in-order bypass order already familiar with the previous part.  A tree with clearly numbered vertices can be viewed as an array, in which the index is the same implicit key, and the content is user information <code>c</code> .  The games are needed only for balancing, these are internal details of the data structure that are not needed by the user.  X <em>really is</em> not, in principle, they do not need to be stored. <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/habraeffect/fd/70/fd703b2ff9679b5a8c2ec8fa195e0765.png"></div><br>  Unlike the last part, this array does not automatically acquire any properties, like sorting.  After all, we have no structural restrictions on information, and it can be stored in the peaks at any time. <br><a name="habracut"></a><br><h4>  Main applications </h4><br>  Now we should talk about why such an interpretation is generally needed. <br>  For example, have you ever wanted to merge two arrays?  That is, simply assign one of them to the end of the other, while not copying all the elements of the second in O (N) in the loop.  With the Cartesian tree using an implicit key, you have such an opportunity: after all, nobody took away the Merge operation from us. <br><br>  Stop-stop-stop, but Merge was written for an explicit Cartesian tree.  So its algorithm will have to be reworked here?  Not really.  Look again at its code. <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Treap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Merge</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Treap L, Treap R</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (L == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> R; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (R == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Ly &gt; Ry) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newR = Merge(L.Right, R); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Treap(Lx, Ly, L.Left, newR); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newL = Merge(L, R.Left); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Treap(Rx, Ry, newL, R.Right); } }</code> </pre><br>  The Merge operation, as you remember, relies on the fact that all the keys of the left input tree <strong>L</strong> do not exceed the keys of the right input tree <strong>R.</strong>  Assuming that this condition is met, it produces a merge, disregarding the keys in principle: during the execution of the algorithm, only priorities are compared. <br><br>  It turns out that the Merge operation we cheat here in the most arrogant way: she expects that she will be given trees with ordered keys, and we slip trees without keys at all :) However, the assumption that there are clear keys in the trees, and they are ordered, will force her to merge trees so that the L keys will turn out to be in a tree structure in some sense earlier than the R keys - because the condition of the search tree must be satisfied.  That is: if in the tree L there were N elements, and in the tree R, respectively, M elements, then after merging the elements of the tree R will automatically acquire implicit numbers from N to <nobr>N + M-1</nobr> .  According to the tree structure, the Merge operation will automatically distribute them appropriately, and the priorities that it takes into account will perform ‚Äúquasi-balancing‚Äù.  Thus, we kind of attributed the ‚Äúarray‚Äù R to the ‚Äúarray‚Äù L. <br><br>  As for the sources, we only need to create a new data type <code>ImplicitTreap</code> without the <code>x</code> key, and for it the corresponding private constructor.  All Merge code will remain the same.  Of course, this is taking into account that here is the version without calculating multiple queries - the functions of ‚Äúrestoring justice‚Äù and ‚Äúpushing promises‚Äù, implemented in the second part, will also remain in the Merge in their old places. <br><br>  For complete clarity, I will take two random implicit Cartesian trees and give them in the figure along with the result of the merge.  Priorities are chosen randomly, so the actual structure of both trees and the result can be very different.  But it does not matter - the structure of the array, i.e.  the order of the elements <code>c</code> is always preserved. <br>  The orange arrow is the path to the recursion in Merge. <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/habraeffect/cf/8b/cf8b8e429de5665df093699c8b79b49f.png"></div><br><br>  Now it's time to Split.  It‚Äôs not so easy to fool it anymore: the Split operation, on the contrary, is not interested in priorities, it only compares the keys.  We'll have to think about how she will compare vertices in an implicit tree.  Although in fact the problem lies higher: what does the Split operation do in general in the new data structure?  Previously, she cut the tree by key, but here we don‚Äôt have the keys, which need to be cut. <br><br>  There are no keys, however there is their implicit representation - array indices.  Thus, the essence of cutting has changed somewhat: we want to split a tree into two so that exactly <strong>x <sub>0</sub></strong> elements are in the left, and all the others are in the right.  In the ‚Äúmassive‚Äù interpretation, this means the separation of x0 elements from the array from the beginning into a new array. <br><br>  How to perform a new Split operation?  It considers, as before, two cases: the root <strong>T</strong> appears in the left result <strong>L</strong> or in the right <strong>R.</strong>  In the left one it will be if its index in the array is less than x <sub>0</sub> , otherwise in the right one.  And what is the index of the top of the tree in the array?  We already know how to work with it from the second part: it is enough to store the <em>sizes of subtrees</em> in the tree tops.  Then the selection process is easily restored. <br><br>  Let <strong>S <sub>L</sub></strong> be the size of the left subtree ( <code>T.Left.Size</code> ). <br>  If <nobr>S <sub>L</sub> +1 ‚â§ x <sub>0</sub></nobr> , then the root will be in the left result.  So you need to recursively cut the right subtree.  But cut by another key, by <nobr>x <sub>0</sub> -S <sub>L</sub> -1</nobr> , because <nobr>S <sub>L</sub> +1</nobr> element has already fallen into the desired left result. <br>  If <nobr>S <sub>L</sub> +1&gt; x <sub>0</sub></nobr> , then the root will be in the right result.  Now you need to recursively cut the left subtree.  This case is not quite symmetric, as before: we cut the subtree with the same key x <sub>0</sub> , because at this recursion step we split the elements into the right result, not the left result. <br><br>  In the figure, a Cartesian tree with subtree dimensions is taken and split by <nobr>x <sub>0</sub> = 6</nobr> . <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/habraeffect/c2/63/c26337f62aa8b674046e9dd9771eb139.png"></div><br>  The source code of the new Split, along with the new class procurement - without a key and with another private designer. <br>  Split I give again so far without multiple operations - the reader can restore these lines on their own, they have not gone from their old places.  But we must not forget about the recalculation of the sizes of subtrees. <br><pre> <code class="hljs pgsql">private <span class="hljs-type"><span class="hljs-type">int</span></span> y; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Cost</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> ImplicitTreap Left; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> ImplicitTreap Right; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> Size = <span class="hljs-number"><span class="hljs-number">1</span></span>; private ImplicitTreap(<span class="hljs-type"><span class="hljs-type">int</span></span> y, <span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>, ImplicitTreap left = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, ImplicitTreap right = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { this.y = y; this.<span class="hljs-keyword"><span class="hljs-keyword">Cost</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>; this.Left = left; this.Right = right; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">int</span></span> SizeOf(ImplicitTreap treap) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> treap == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : treap.Size; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Recalc() { Size = SizeOf(Left) + SizeOf(Right) + <span class="hljs-number"><span class="hljs-number">1</span></span>; } //    -  Split <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Split(<span class="hljs-type"><span class="hljs-type">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> ImplicitTreap L, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> ImplicitTreap R) { ImplicitTreap newTree = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> curIndex = SizeOf(Left) + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (curIndex &lt;= x) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Right == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) R = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Right.Split(x - curIndex, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> newTree, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> R); L = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ImplicitTreap(y, <span class="hljs-keyword"><span class="hljs-keyword">Cost</span></span>, Left, newTree); L.Recalc(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Left == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) L = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Left.Split(x, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> L, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> newTree); R = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ImplicitTreap(y, <span class="hljs-keyword"><span class="hljs-keyword">Cost</span></span>, newTree, Right); R.Recalc(); } }</code> </pre><br>  Now, after we wrote for the array Split and Merge, working in logarithmic time, it is time to apply them somewhere.  Let's play around with the array. <br><br><h4>  Array games </h4><br><h5>  Insert </h5><br>  Focus ‚Ññ1 - we insert the element inside the array to the required position <strong>Pos</strong> for O (log <sub>2</sub> N), and not for O (N), as usual. <br><br>  In principle, we are already able to do this with ordinary Cartesian trees, only now the index has become in place of the key.  And the rest of the procedure has not changed. <br><br>  ‚Ä¢ Cut the array <nobr>T [0;</nobr>  <nobr>N)</nobr> at index Pos on arrays <nobr>L [0;</nobr>  <nobr>Pos)</nobr> and <nobr>R [Pos;</nobr>  <nobr>N)</nobr> . <br>  ‚Ä¢ Make an array-tree of the inserted element from one vertex. <br>  ‚Ä¢ We assign the created array to the right to the left result L, and to both of them the right result R. <br>  ‚Ä¢ Received array <nobr>T '[0;</nobr>  <nobr>N + 1)</nobr> , in which the required element stands in the Pos position, and the remaining right side is shifted. <br><br>  The source code for the insert has not changed at all. <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ImplicitTreap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elemCost</span></span></span><span class="hljs-function">)</span></span> { ImplicitTreap l, r; Split(pos, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> l, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> r); ImplicitTreap m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImplicitTreap(rand.Next(), elemCost); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Merge(Merge(l, m), r); }</code> </pre><br><br><h5>  Deletion </h5><br>  Focus ‚Ññ2 - we will cut out from the array the element standing at this position <strong>Pos</strong> . <br><br>  Again, the procedure is the same as with ordinary Cartesian trees. <br><br>  ‚Ä¢ Cut the array <nobr>T [0;</nobr>  <nobr>N)</nobr> at index Pos on arrays <nobr>L [0;</nobr>  <nobr>Pos)</nobr> and <nobr>R [Pos;</nobr>  <nobr>N)</nobr> . <br>  ‚Ä¢ The right-hand result R is cut by index 1 (one!).  Get the array <nobr>M [Pos;</nobr>  <nobr>Pos + 1)</nobr> from one element (previously standing at Pos position), and the array <nobr>R '[Pos + 1;</nobr>  <nobr>N)</nobr> . <br>  ‚Ä¢ Merge arrays L and R '. <br><br>  Source code removal: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ImplicitTreap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Remove</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pos</span></span></span><span class="hljs-function">)</span></span> { ImplicitTreap l, m, r; Split(pos, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> l, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> r); r.Split(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> m, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> r); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Merge(l, r); }</code> </pre><br><br><h5>  Multiple segment queries </h5><br>  Focus number 3: for O (log <sub>2</sub> N), you can also perform all the same multiple queries on sublotting an array (sum / maximum / minimum / presence or number of labels, etc.). <br><br>  The structure of the tree does not change from the last part: at the top we store the parameter corresponding to the desired value calculated for the whole subsegment.  At the end of the Merge and Split, the same <code>Recalc()</code> call is <code>Recalc()</code> , recalculating the value of the value at the vertex based on the calculated parameters in its descendants. <br><br>  Request for segment <nobr>[A;</nobr>  <nobr>B)</nobr> uses the standard method: cut the required segment from the array (not forgetting that after the first cut, the desired index in the right result decreased!) And return the value of the parameter stored in its root. <br>  Source code - as an example, for the maximum. <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> MaxTreeCost; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CostOf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ImplicitTreap treap</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> treap == <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>.NegativeInfinity : treap.MaxTreeCost; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recalc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Size = SizeOf(Left) + SizeOf(Right) + <span class="hljs-number"><span class="hljs-number">1</span></span>; MaxTreeCost = Math.Max(Cost, Math.Max(CostOf(Left), CostOf(Right))); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MaxCostOn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> A, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> B</span></span></span><span class="hljs-function">)</span></span> { ImplicitTreap l, m, r; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Split(A, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> l, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> r); r.Split(B - A, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> m, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> r); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CostOf(m); }</code> </pre><br><br><h5>  Multiple operations on the segment </h5><br>  Focus ‚Ññ4: now, in O (log <sub>2</sub> N), we will perform the operations from the second part on array plots, adding a constant, painting, setting to a single value, etc. <br><br>  Having workers Merge and Split, implementation of the postponed calculations in the Cartesian tree does not change at all.  The basic principle of operation is the same: before performing any ‚Äúpush promise‚Äù operation to descendants.  If you additionally need to support multiple requests from the previous section, after the operation is completed, it is necessary to ‚Äúrestore justice‚Äù. <br><br>  To perform an operation on a segment, you first need to cut this segment from the tree with two calls of Split, and then insert it again with two calls of Merge. <br>  For the lazy, I cite the full source code for the addition, along with the new Merge / Split implementations (they differ by as many as 1-2 lines), and also with the push function <code>Push</code> : <br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">void</span></span> Push(ImplicitTreap treap) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (treap == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; treap.<span class="hljs-keyword"><span class="hljs-keyword">Cost</span></span> += treap.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (treap.Left != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) treap.Left.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span> += treap.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (treap.Right != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) treap.Right.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span> += treap.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>; treap.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Recalc() { Size = SizeOf(Left) + SizeOf(Right) + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static ImplicitTreap Merge(ImplicitTreap L, ImplicitTreap R) { // ! Push( L ); Push( R ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (L == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> R; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (R == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L; ImplicitTreap answer; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Ly &gt; Ry) { var newR = Merge(L.Right, R); answer = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ImplicitTreap(Ly, L.<span class="hljs-keyword"><span class="hljs-keyword">Cost</span></span>, L.Left, newR); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { var newL = Merge(L, R.Left); answer = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ImplicitTreap(Ry, R.<span class="hljs-keyword"><span class="hljs-keyword">Cost</span></span>, newL, R.Right); } answer.Recalc(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> answer; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Split(<span class="hljs-type"><span class="hljs-type">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> ImplicitTreap L, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> ImplicitTreap R) { Push(this); // ! ImplicitTreap newTree = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> curIndex = SizeOf(Left) + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (curIndex &lt;= x) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Right == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) R = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Right.Split(x - curIndex, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> newTree, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> R); L = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ImplicitTreap(y, <span class="hljs-keyword"><span class="hljs-keyword">Cost</span></span>, Left, newTree); L.Recalc(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Left == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) L = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Left.Split(x, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> L, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> newTree); R = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ImplicitTreap(y, <span class="hljs-keyword"><span class="hljs-keyword">Cost</span></span>, newTree, Right); R.Recalc(); } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> ImplicitTreap IncCostOn(<span class="hljs-type"><span class="hljs-type">int</span></span> A, <span class="hljs-type"><span class="hljs-type">int</span></span> B, <span class="hljs-type"><span class="hljs-type">double</span></span> Delta) { ImplicitTreap l, m, r; this.Split(A, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> l, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> r); r.Split(B - A, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> m, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> r); m.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span> += Delta; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Merge(Merge(l, m), r); }</code> </pre><br><br>  A small digression about allowed operations: <br><blockquote>  In fact, the recursive tree structure and deferred calculations allow to implement any operation of a monoid.  <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BE%25D0%25BD%25D0%25BE%25D0%25B8%25D0%25B4">A monoid</a> is a set with a binary operation ‚ó¶ defined on it, which has the following properties: <br>  ‚Ä¢ Associativity - for any elements a, b, c we have <nobr>(a ‚ó¶ b) ‚ó¶ c = a (b c)</nobr> . <br>  ‚Ä¢ The existence of a neutral element - in the set there is an element e such that for any element a there is a <nobr>a e = e ‚ó¶ a = a</nobr> . <br>  Then for such an operation it is possible to realize <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE_%25D0%25BE%25D1%2582%25D1%2580%25D0%25B5%25D0%25B7%25D0%25BA%25D0%25BE%25D0%25B2">a segment tree</a> , and for similar reasons - a Cartesian tree. <br></blockquote><br><br><h5>  Array flip </h5><br>  The focus number 5 is a subsection reversal, that is, rearrangement of its elements in the reverse order. <br><br>  And on this place I will stop a little more in detail.  The array reversal is not a monoidal operation ‚Äî frankly speaking, it is not a binary operation on any set at all ‚Äî but nonetheless.  The uniqueness of this task is that you can think of a push function for it.  And since there is an opportunity to push through the operation, it means that you can implement it as deferred. <br><br>  So, we will store in each vertex a boolean value - an inverted bit.  This will be a deferred promise that "this segment of the array needs to be expanded in the future."  Then, assuming that we are able to push this bit to the descendants with a peculiar version of the <code>Push</code> function, the tree always remains in its current form - before any access to the array elements (search), as well as at the beginning of the Merge and Split, the pushing is performed.  It remains to figure out how to make this "fulfillment of the promise." <br><br>  Suppose that at some vertex <strong>T</strong> there is a promise to turn the subsegment around.  To begin to actually perform it, it is enough to do the following: <br>  ‚Ä¢ Remove the promise at the current top: <br><pre>  T.Reversed = false; </pre>  ‚Ä¢ Swap his left and right sons. <br><pre>  temp = T.Left;
   T.Left = T.Right;
   T.Right = temp; </pre>  ‚Ä¢ Change promise among descendants.  Please note: do not set to true (we do not know whether this bit was still in the descendants!), But to change.  To do this, use the operation ^. <br><pre>  T.Left.Reversed ^ = true;
   T.Right.Reversed ^ = true; </pre><br>  Indeed, what is ‚Äúactually flip the array‚Äù?  Take two pieces of this array (subtrees), swap them in reality, and <em>promise to</em> turn these two subarrays in the future.  It is easy to see that when all promises are fulfilled to a single, the elements of the original array will turn upside down. <br><br>  Notice - such a machination cannot be done with ordinary Cartesian trees, since we violate the property of the search tree - the keys in the right subtree turn out to be less than the keys in the left one.  But since there are no keys in the implicit Cartesian tree at all, and for indices the property is always observed, nothing breaks in the tree. <br><br>  The user function of turning the segment works on the same principle as any other operation: cut the required segment, set the promise in its root, and paste the segment back.  Here is the source code for the push and turn functions: <br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span> Reversed; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">void</span></span> Push(ImplicitTreap treap) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (treap == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; //    -   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!treap.Reversed) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; var <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span> = treap.Left; treap.Left = treap.Right; treap.Right = <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span>; treap.Reversed = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (treap.Left != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) treap.Left.Reversed ^= <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (treap.Right != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) treap.Right.Reversed ^= <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> ImplicitTreap Reverse(<span class="hljs-type"><span class="hljs-type">int</span></span> A, <span class="hljs-type"><span class="hljs-type">int</span></span> B) { ImplicitTreap l, m, r; this.Split(A, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> l, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> r); r.Split(B - A, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> m, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> r); m.Reversed ^= <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Merge(Merge(l, m), r); }</code> </pre><br><br>  Now you can solve the classic assignment at interviews in a fundamentally new way :) <br><br><h5>  Cyclic Array Shift </h5><br>  Focus ‚Ññ6: cyclic shift.  The essence of this operation, for those who do not know, is easier to explain in the figure. <br><div style="text-align:center;"><img src="http://habrastorage.org/storage/habraeffect/47/40/4740157b8c137e192daaada02d833758.png"></div><br>  Of course, a cyclic shift can always be performed in O (N), but by implementing an array as an implicit Cartesian tree, you can shift it in O (log <sub>2</sub> N).  The shift procedure to the left by <strong>K is</strong> trivial: we cut the tree by the index K, and glue it in the reverse order.  The shift to the right is symmetrical, only you need to cut by the index <nobr>NK</nobr> . <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ImplicitTreap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShiftLeft</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> K</span></span></span><span class="hljs-function">)</span></span> { ImplicitTreap l, r; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Split(K, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> l, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> r); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Merge(r, l); }</code> </pre><br><br>  Again: the operation is unique to Cartesian trees by an implicit key, since it is unacceptable to glue the two results of Split, whether they are ordinary Cartesian trees: after all, Merge expects ordered trees from us, and we feed him the arguments in the wrong order. <br><br><h4>  Summary </h4><br>  The Cartesian tree with an implicit key is a simple representation of an array in the form of a tree, which allows a lot of operations to be performed with it and with its subarrays in logarithmic time.  In this case, the memory is still spent O (N).  Of course, using the O-notation, I‚Äôve a bit of a crush here, because in real life, the actual memory occupied by the tree is important, and the Cartesian tree is famous for its overhead.  Judge for yourself: N for information, N for priorities, 2N for references to descendants, N for subtree sizes is the cost of living, and if you add multiple queries, you will get N for each operation.  You can improve your life a little by <a href="http://habrahabr.ru/blogs/algorithm/102006/">creating priorities from information</a> , but this is, firstly, a drop in the ocean (only minus N), and secondly, it is fraught with consequences from a security point of view: if someone finds out the function that you use priorities, he will be potentially able to give you new entries to create in a malicious order, to greatly unbalance the Cartesian tree.  In the end, it is possible that all your data will slow down noticeably - although such cases, of course, are few and require remarkable work.  You can get rid of the danger by using different primes P for different vertices of the tree ... but this is a topic for separate scientific research.  For me personally, the possibility of a Cartesian tree and the simplicity of its code are advantages that exceed the problem of high memory consumption.  Although, of course, the program is different. <br><br>  Of interesting facts: in Western literature, articles and the Internet, I did not manage to find a single mention of the Cartesian tree using an implicit key.  Of course, no one knows how it should be called in English terminology - however, questions on the forums and StackOverflow also led to nothing.  In the Russian practice of sports programming ACM ICPC, this structure was used for the first time in 2000, invented by Kitten Computing team member Nikolay Durov - a numerous winner of international competitions (however, Runet knows his <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D1%2583%25D1%2580%25D0%25BE%25D0%25B2,_%25D0%259F%25D0%25B0%25D0%25B2%25D0%25B5%25D0%25BB_%25D0%2592%25D0%25B0%25D0%25BB%25D0%25B5%25D1%2580%25D1%258C%25D0%25B5%25D0%25B2%25D0%25B8%25D1%2587">brother Pavel more</a> , as well as their joint <a href="http://vkontakte.ru/">creation</a> ). <br><br>  I finish this compulsory Cartesian program.  Most likely, there will be at least one or two parts later - about alternative implementations of tree operations, and about its functional implementation - however, the three already written in principle make up enough ammunition for the full use of deramids in life.  Thanks to all who honestly wade through the lines of this tutorial with me :) I hope you were interested. </div><p>Source: <a href="https://habr.com/ru/post/102364/">https://habr.com/ru/post/102364/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../102357/index.html">Intellectual board SmartBoard 690</a></li>
<li><a href="../102360/index.html">How it was: Intel Summer School 2010 to the equator</a></li>
<li><a href="../102361/index.html">New digg (from the creators of digg.com) [+ distribution of invites]</a></li>
<li><a href="../102362/index.html">Install FAR in Ubuntu using Wine</a></li>
<li><a href="../102363/index.html">PI Design: Learning from the mistakes of others</a></li>
<li><a href="../102365/index.html">Talismans and Ubuntu wallpaper versions</a></li>
<li><a href="../102367/index.html">Methods of applying the algorithm for finding the maximum flow in the network</a></li>
<li><a href="../102369/index.html">Booot CMS is a free store engine.</a></li>
<li><a href="../102372/index.html">Mission MESSENGER</a></li>
<li><a href="../102373/index.html">Tabs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>