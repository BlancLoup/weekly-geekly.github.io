<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Capture filters for network analyzers (tcpdump, Wireshark, Paketyzer)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Capture Filters 
 Traffic analyzers are a useful and effective tool in the life of a network administrator, they allow you to ‚Äúsee‚Äù what is actuall...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Capture filters for network analyzers (tcpdump, Wireshark, Paketyzer)</h1><div class="post__text post__text-html js-mediator-article"><h4>  <b>1. Capture Filters</b> </h4><br>  Traffic analyzers are a useful and effective tool in the life of a network administrator, they allow you to ‚Äúsee‚Äù what is actually transmitted on the network, which makes it easier to diagnose various problems or to study the principles of operation of various protocols and technologies. <br>  However, quite a lot of various data blocks are often transmitted in the network, and if you force to display everything that passes through the network interface, it is difficult to select what is really needed. <br>  To solve this problem, filters are implemented in traffic analyzers, which are divided into two types: capture filters and display filters.  Today we will talk about the first type of filters - about capture filters. <br>  <b>Capture Filters is a type of filter that allows you to limit frame capture to only those that are necessary for analysis, thus reducing the load on computer computing resources, as well as simplifying the process of analyzing traffic.</b> <br><a name="habracut"></a><br><h4>  <b>2. Capture Filters Syntax</b> </h4><br>  The capture filter expression consists of a set of special primitives, which are built from the so-called classifiers and object identifiers (addresses, names of network objects, port numbers). <br><blockquote>  <b>Note</b> : all classifiers are case-sensitive and must be written in small letters only. </blockquote><br>  Let's deal with them in more detail. <br>  Classifiers can be of the following types: <br><ul><li>  <b>type</b> - object type <br><ul><li>  <b>host</b> - the node (the default type, if the type is not specified, it is assumed that this is the host) </li><li>  <b>net</b> - network </li><li>  <b>port</b> </li></ul><br></li></ul><br><blockquote>  <b>For example</b> : <br>  <b>host 192.168.0.1</b> - traffic capture in which IP 192.168.0.1 is used as the address (sender or recipient) <br>  <b>net 172.16.0.0/16</b> - traffic capture in which the IP from the network 172.16.0.0/16 is set as the address (the sender or the receiver) (more precisely, it is in the range from 172.16.0.0 to 172.16.255.255), while just a search filter matching addresses, it does not matter what the mask is configured on the interface, and you should not be embarrassed that 172.16.0.0 by mask / 16 is the network number, we absolutely do not know which mask is configured on the interface, and formally, such a node address is valid. <br>  <b>port 80</b> - traffic capture in which there is data belonging to port 80 (udp or tcp) <br>  <b>10.0.0.1</b> - traffic capture in which IP 10.0.0.1 is specified as the address (sender or recipient), the host classifier is not specified, but it is assumed by default. </blockquote><br><ul><li>  <b>dir</b> - direction relative to the object (direction) <br><ul><li>  <b>src</b> - the object is the sender </li><li>  <b>dst</b> - the object is the recipient </li></ul><br></li></ul><br><blockquote>  <b>For example</b> : <br>  <b>src host 192.168.0.1</b> - traffic capturing in which IP 192.168.0.1 is set as the sender (not the receiver) address <br>  <b>dst net 172.16.0.0/16</b> - traffic capture in which the IP from the network 172.16.0.0/16 is set as the recipient's address (not the sender) (more precisely, it is in the range from 172.16.0.0 to 172.16.255.255). </blockquote><br><ul><li>  <b>proto</b> - interaction protocol <br><ul><li>  <b>ether</b> - basic Ethernet networking technology, usually indicates that the filter uses the hardware MAC address </li><li>  <b>ip</b> - IPv4 protocol </li><li>  <b>ip6</b> - IPv6 protocol </li><li>  <b>arp</b> - ARP protocol </li><li>  <b>tcp</b> - TCP protocol </li><li>  <b>udp</b> - UDP protocol </li><li>  if the protocol is not specified, it is considered that all traffic that is compatible with the type of object should be captured </li></ul><br></li></ul><br><blockquote>  <b>For example</b> : <br>  <b>src ether host 00: 11: 22: 33: 44: 55</b> ‚Äî traffic capture in which <b>00: 11: 22: 33: 44: 55</b> is used as the sender's MAC address. <br>  <b>ip icmp</b> - capture ICMP packets. <br>  <b>tcp port 80</b> - traffic capture in which there is data belonging to TCP port 80 </blockquote><br>  In addition to object identifiers and classifiers, filters can contain the keywords <b>gateway</b> , <b>broadcast</b> , <b>multicast</b> , <b>less</b> , <b>greater,</b> as well as arithmetic expressions. <br><blockquote>  <b>For example</b> : <br>  <b>ip multicast</b> - capture of ip packets containing addresses from class D. <br>  <b>less 1000</b> - frame capture, in which the size is less than 1000 bytes. </blockquote><br>  A bunch of several conditions can occur using logical operations: <br><ul><li>  ‚ÄúAnd‚Äù - and (&amp;&amp;) </li><li>  "OR" - or (||) </li><li>  "NOT" - not (!) - inversion of value </li></ul><br>  The priority of these operations is as follows: <br><ul><li>  inversion operation has the highest priority </li><li>  then the logical "and" </li><li>  the lowest priority has operation "OR". </li></ul><br>  As in ordinary mathematical expressions, the priority can be changed using round brackets (), in which actions are performed first. <br><blockquote>  <b>For example</b> : <br>  <b>net 192.168.0.0/24 and tcp port 21</b> ‚Äî captures the traffic belonging to the network (range) 192.168.0.0/24 (or the sender or receiver) and sends data using the TCP protocol and uses port 21. <br>  <b>host 192.168.0.1 or host 192.168.0.221</b> - capturing traffic belonging to either host 192.168.0.1 or host 192.168.0.221 (and it‚Äôs not important who is the sender, who is the receiver, and just enough of one of the two conditions addresses present in the frame) <br>  <b>host 192.168.0.1 or host 192.168.0.2 and tcp port 22</b> ‚Äî capture either any traffic belonging to host 192.168.0.1 or TCP protocol traffic and using port 22 owned by the host 192.168.0.2. <br>  <b>(host 192.168.0.1 or host 192.168.0.2) and tcp port 22</b> ‚Äî captures TCP traffic using port 22 owned by host 192.168.0.1 or host 192.168.0.2 (either of them, or both). <br>  <b>(host 192.168.0.1 || host 192.168.0.1) &amp;&amp; not tcp port 22</b> ‚Äî capture any traffic except TCP traffic and using port 22 owned by host 192.168.0.1 or host 192.168.0.2 (either of them, or both). </blockquote><br>  If there are several identical duplicate classifiers in the filter, then to shorten the record, you can not write them. <br><blockquote>  <b>For example</b> : <br>  <b>net 192.168.0.0/24 and (tcp port 21 or tcp port 20 or tcp port 25 or tcp port 80 or tcp port 110)</b> <br>  can be reduced to <br>  <b>net 192.168.0.0/24 and (tcp port 21 or 20 or 25 or 80 or 110)</b> </blockquote><br><blockquote>  <b>Attention</b> : <br>  The expression excluding packages in which there are addresses 1.1.1.1 and 1.1.1.2: <br>  <b>not (host 1.1.1.1 and host 1.1.1.2)</b> <br>  Can be cut as: <br>  <b>not (host 1.1.1.1 and 1.1.1.2)</b> <br>  But not like: <br>  <b>not host 1.1.1.1 and 1.1.1.2</b> - in this case, the packets will be shown in which there is no first address and there is a second one. <br>  And not so <br>  <b>not (host 1.1.1.1 or 1.1.1.2)</b> - in this case, packets in which there is at least one of the specified two addresses will be excluded. </blockquote><br>  A list of basic primitives that can be used to write capture filters is shown in Table 2-1. <br><br>  Table 2-1.  A list of basic primitives that can be used to write capture filters. <br><table><tbody><tr><td>  Primitive </td><td>  Description </td></tr><tr><td>  dst host ip_address </td><td>  Capture frames in which the IPv4 / IPv6 header field contains the specified node address </td></tr><tr><td>  src host ip_address </td><td>  Capture frames in which the source address of the IPv4 / IPv6 header contains the specified node address </td></tr><tr><td>  host ip_address </td><td>  Capture frames in which the IPv4 / IPv6 header contains the specified node address in the source or destination address field. <br>  Equivalent to the filter: <br>  ether proto ip and host ip_address <br></td></tr><tr><td>  ether dst mac_address </td><td>  Capture frames in which in the field of the recipient address of the link layer header contains the specified MAC address of the node </td></tr><tr><td>  ether src mac_address </td><td>  Capture frames in which in the field of the sender address of the link layer header contains the specified MAC address of the node </td></tr><tr><td>  ether host mac_address </td><td>  Capture frames in which in the address field of the sender or recipient of the link level header contains the specified MAC address of the node </td></tr><tr><td>  dst net network </td><td>  Capture frames in which the IPv4 / IPv6 header field in the destination address field contains the specified address belonging to the range of the specified class network </td></tr><tr><td>  src net network </td><td>  Capture frames in which the source address of the IPv4 / IPv6 header contains the specified address belonging to the range of the specified class network </td></tr><tr><td>  net network </td><td>  Selects all IPv4 / IPv6 packets containing addresses from the specified network in the sender or recipient field </td></tr><tr><td>  net network mask </td><td>  Capture frames in which the IPv4 / IPv6 header field contains the specified address in the specified network range in the source or destination address field. </td></tr><tr><td>  net network / mask_length </td><td>  Capture frames in which the IPv4 / IPv6 header field contains the specified address in the specified network range in the source or destination address field. </td></tr><tr><td>  dst port port </td><td>  Capture frames in which the destination port of the UDP or TCP header contains the specified port number </td></tr><tr><td>  src port port </td><td>  Capture frames in which the sending port of the UDP or TCP header contains the specified port number </td></tr><tr><td>  port port </td><td>  Capture frames in which the sending port of the UDP or TCP header contains the specified port number </td></tr><tr><td>  less length </td><td>  Capture frames that are no larger than the specified value. </td></tr><tr><td>  greater length </td><td>  Capture frames whose size is not less than the specified value </td></tr><tr><td>  ip proto protocol </td><td>  Capture frames in which the Protocol field of the IPv4 header contains the identifier of the specified protocol.  In this case, you can specify not only the numerical values ‚Äã‚Äãof the protocols, but also their standard names (icmp, igmp, igrp, pim, ah, esp, vrrp, udp, tcp, and others).  However, it should be borne in mind that tcp, udp and icmp are also used as keywords, so a backslash character (‚Äú\‚Äù) should be prevented before these character identifiers. </td></tr><tr><td>  ip6 proto protocol </td><td>  Capture frames in which the Protocol field of the IPv4 header contains the identifier of the specified protocol.  In this case, you can specify not only the numerical values ‚Äã‚Äãof the protocols, but also their standard names (icmp6, igmp, igrp, pim, ah, esp, vrrp, udp, tcp, and others).  However, it should be taken into account that tcp, udp and icmp6 are also used as keywords, therefore, a backslash character ("\") should be prevented before these character identifiers. </td></tr><tr><td>  ether broadcast </td><td>  Capture all Ethernet broadcast frames.  The ether keyword may be omitted. </td></tr><tr><td>  ip broadcast </td><td>  Capture frames containing broadcast addresses in the IPv4 packet header.  It also uses a subnet mask for the interface that is used to capture packets to determine if the address is a broadcast.  Also captures packets sent to a limited broadcast address. </td></tr><tr><td>  ether multicast </td><td>  Capture all Ethernet multicast frames.  The ether keyword may be omitted. </td></tr><tr><td>  ip multicast </td><td>  Capture frames containing multicast addresses in the IPv4 packet header </td></tr><tr><td>  ip6 multicast </td><td>  Capture frames containing multicast addresses in the IPv6 packet header </td></tr><tr><td>  ether proto protocol_type </td><td>  Capture Ethernet frames with the specified protocol type.  The protocol can be specified by number or name (ip, ip6, arp, rarp, atalk, aarp, decnet, sca, lat, mopdl, moprc, iso, stp, ipx, netbeui) </td></tr><tr><td>  ip, ip6, arp, rarp, atalk, aarp, decnet, iso, stp, ipx, netbeui, tcp, udp, icmp </td><td>  Capture frames transmitting data of the specified protocol.  Used as abbreviations for: <br>  ether proto protocol <br></td></tr><tr><td>  vlan [vlan_id] </td><td>  Capture frames in accordance with IEEE 802.1Q.  If the vlan_id number is indicated, then only frames belonging to the specified VLAN are captured. </td></tr></tbody></table><br><br><h4>  <b>3. Advanced examples of capture filters</b> </h4><br>  In addition to simple indications of addresses and protocols, more sophisticated constructions can be used in capture filters, allowing for a more subtle analysis of headers. <br>  For this, expressions returning a logical value of the following format are used: <br><blockquote>  <b>expression</b> operation <b>expression</b> </blockquote><br>  In which the <b>expression</b> can be constants, the results of arithmetic (+, -, *, /) or binary bitwise operations (&amp; - ‚ÄúAND‚Äù, | - ‚ÄúOR‚Äù, &lt;&lt; - left shift, &gt;&gt; - right shift), operator length <b>offset</b> , data or frame header fields.  As an operation, the characters ‚Äú&gt;‚Äù (more), ‚Äú&lt;‚Äù (less), ‚Äú&gt; =‚Äù (more than), ‚Äú&lt;=‚Äù (less than), ‚Äú=‚Äù (equal), ‚Äú! =‚Äù (not equal).  Thus, it is possible to check for coincidence or non-coincidence of certain fields or frame bytes with the required values, compare various header fields to each other, and also perform some arithmetic and logical operations on them and compare the results of these operations with certain values. <br>  The simplest example of using an advanced filter is ‚Äú <b>5 = 3 + 1</b> ‚Äù, where ‚Äú <b>5</b> ‚Äù and ‚Äú <b>3 + 1</b> ‚Äù are expression, and ‚Äú <b>=</b> ‚Äù is an operation.  As a result of calculating this string, a logical value will be returned, <b>false</b> in this case. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A <b>proto</b> [ <i>offset</i> : <i>size</i> ] primitive is used to get data or frame headers. <br><blockquote>  <b>Attention</b> : square brackets in this case is an element of syntax, not a sign of an optional field. </blockquote><br>  The <b>proto</b> parameter contains the name of the protocol, from the header of which you need to select certain data (ether, fddi, tr, wlan, ppp, slip, link, ip, arp, rarp, tcp, udp, icmp, ip6 and others). <br>  The <b>offset</b> parameter indicates the offset in bytes relative to the beginning of the header of the specified protocol, the numbering of bytes starts from zero: <b>ip [0]</b> is the first byte from the beginning of the IP packet, <b>tcp [1]</b> is the second byte from the beginning of the TCP segment, <b>ether [3]</b> is the fourth byte from the start of the Ethernet frame. <br>  The <b>size</b> parameter indicates the number of bytes to be taken, starting from the byte specified in the <b>offset</b> , the <b>size</b> field is optional, and if it is missing, it is considered that it is necessary to take 1 byte: <b>ip [2: 2]</b> is the third and the fourth byte from the beginning of the IP packet, <b>tcp [4]</b> - the fifth byte from the beginning of the TCP segment, <b>ether [6-6]</b> - bytes from the seventh to the twelfth, from the beginning of the Ethernet frame. <br>  If the <b>offset</b> field is set to a negative value, then the bytes of the previous header will be selected, reaching the protocol header specified in the <b>proto</b> parameter.  But this will necessarily require the presence in the frame of the protocol header specified in the proto primitive.  Thus, filters <b>ether [11] = 0x37</b> (take the 12th byte of the Ethernet frame and compare it with the value 0x37) and <b>ip [-3] = 0x37</b> (take the 3rd byte from the end of the header before the IP header and compare its value with 0x37) are not identical.  The first will skip all frames in which the sender's MAC address ends at 37, while the second will also require the presence of the IP protocol, and frames that do not contain the IP protocol, for example, ARP frames, will not be captured. <br><blockquote> <b>For example</b> : <br>  The <b>ip [1: 1]</b> and <b>ip [1]</b> expressions will <b>produce</b> the same result ‚Äî the second byte of the IPv4 header will be selected <br>  The <b>tcp [8: 2]</b> expression will select the ninth and tenth bytes (Source Port field) of the TCP header. <br>  The <b>ip [-3] = 0x37 expression</b> will select all IPv4 packets whose MAC address of the sender ends with ‚Äú0x37‚Äù. </blockquote><br>  It should be noted that when selecting data using the <b>proto</b> [ <i>offset</i> : <i>size</i> ] construct for the TCP and UDP protocols, the fragmentation of IP packets is taken into account.  As a result, <b>tcp [0]</b> will always mean the first byte of the TCP header, and will never result in the selection of the first byte of data packets that are sending the first fragment from the fragment chain. <br>  For some protocols, certain fields and offset values ‚Äã‚Äãcan be specified not only by numbers, but also by names.  For example, ICMP supports the <b>icmptype</b> parameter, which can be <b>icmp-echoreply</b> , <b>icmp-unreach</b> , <b>icmp-sourcequench</b> , <b>icmp-redirect</b> , <b>icmp-echo</b> , <b>icmp-routeradvert</b> , <b>icmp-routersolicit</b> , <b>icmp-timxceed</b> , <b>icmp-paramprob</b> , <b>icmp -tstamp</b> , <b>icmp-tstam-preply</b> , <b>icmp-ireq</b> , <b>icmp-ireqreply</b> , <b>icmp-maskreq</b> , <b>icmp-maskreply</b> .  You can use the <b>tcpflags</b> parameter identifiers <b>tcp-fin</b> , <b>tcp-syn</b> , <b>tcp-rst</b> , <b>tcp-push</b> , <b>tcp-ack,</b> and <b>tcp-urg to analyze TCP flags</b> . <br><blockquote>  <b>For example</b> : <br>  The expression <b>tcp [tcpflags] &amp; (tcp-syn | tcp-fin)! = 0</b> selects all frames containing TCP segments in which the session is opened or completed. <br>  The expression i <b>cmp [icmptype]! = Icmp-echo and icmp [icmptype]! = Icmp-echoreply</b> selects all frames containing the ICMP protocol, except for echo requests and echo responses. </blockquote><br>  There may be situations in which it is necessary to analyze only a fraction of the bits of a particular byte.  To solve these problems, the bit operation ‚ÄúAND‚Äù (&amp;) is used.  With its help, you can save only certain bits of a byte, and the rest to zero. <br>  For example, we need to allocate only those frames that are transmitted on the data link layer to broadcast or group frames.  We know that we can determine the type of MAC address by its high byte: <br><table><tbody><tr><td>  Address Type </td><td>  The high byte value in the 16th system </td><td>  The value of the high byte in the 2nd system </td></tr><tr><td>  Directed \ Unicast </td><td>  00 </td><td>  0000000 <font color="blue">0</font> </td></tr><tr><td>  Group \ Multicast </td><td>  01 </td><td>  0000000 <font color="blue">1</font> </td></tr><tr><td>  Administratively assigned \ Admin ID </td><td>  01 </td><td>  0000001 <font color="blue">0</font> </td></tr><tr><td>  Broadcast \ Broadcast </td><td>  FF </td><td>  1111111 <font color="blue">1</font> </td></tr></tbody></table><br>  Based on this information, it can be concluded that in the broadcast or multicast addresses the low-order bit of the high byte of the address is one, and in the remaining ones - zero.  If we take the high byte of the address, clear all its bits except the youngest, and the value of the byte becomes equal to one, then this address was either broadcast, or group, if the value of the byte becomes zero, then this address was either directional or administrative given.  As a result, to perform this test, you need to use the following expression: <b>ether [0] &amp; 1 = 1</b> , where <b>ether [0]</b> - gets the value of the first byte of the Ethernet header, and <b>&amp; 1</b> - the logical bit operation ‚ÄúAND‚Äù, which resets all the bits of this byte, except the youngest , " <b>= 1</b> " - check the result for a match with the unit. <br>  Let us examine one more example in more detail. <br>  We need to get the contents of the Type Of Service (ToS) field of the IPv4 header.  To do this, referring to RFC-791, we will see that this field is a single-byte field, and the second byte of the header: <br><blockquote><pre> 3.1.  Internet Header Format
   It follows:
     0 1 2 3   
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 3 5 6 7 8 9 0 1 
    + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + + + + + + + - + - + - + - + - + - + - +
    | Version |  IHL | Type of Service |  Total Length |
    + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + + + + + + + - + - + - + - + - + - + - +
    |  Identification | Flags |  Fragment Offset |
    + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + + + + + + + - + - + - + - + - + - + - +
    |  Time to Live |  Protocol |  Header Checksum |
    + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + + + + + + + - + - + - + - + - + - + - +
    |  Source Address |
    + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + + + + + + + - + - + - + - + - + - + - +
    |  Destination Address |
    + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + + + + + + + - + - + - + - + - + - + - +
    |  Options |  Padding |
    + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + + + + + + + - + - + - + - + - + - + - +
</pre></blockquote><br>  In order to get its value, we need to use the following primitive: <br>  <b>ip [1: 1]</b> - get one byte of the IP header starting from byte number 1 (the numbering of bytes starts from zero). <br>  Now we can build filters based on the contents of this field. <br>  If we want to display all frames containing an IPv4 header, in which the ToS field is zero, you need to write the following: <b>ip [1: 1] = 0</b> . <br>  If we want to display all frames containing an IPv4 header, in which the ToS field is not equal to zero, write the following: <b>ip [1: 1]! = 0</b> . <br>  But you can go further, according to RFC-791, the ToS field is a composite field and has the following structure: <br><blockquote><pre>          0 1 2 3 4 5 6 7
       + ----- + ----- + ----- + ----- + ----- + ----- + ----- + ----- +
       |  |  |  |  |  |  |
       |  PRECEDENCE |  D |  T |  R |  0 |  0 |
       |  |  |  |  |  |  |
       + ----- + ----- + ----- + ----- + ----- + ----- + ----- + ----- +
       Bits 0-2: Precedence.
       Bit 3: 0 = Normal Delay, 1 = Low Delay.
       Bits 4: 0 = Normal Throughput, 1 = High Throughput.
       Bits 5: 0 = Normal Reliability, 1 = High Reliability.
       Bit 6-7: Reserved for Future Use.
</pre></blockquote><br>  The first three bits - preference, the fourth describes the requirements for delays, the fifth describes the requirements for bandwidth, the sixth describes the requirements for reliability of the communication line, the seventh and eighth - are reserved for future use. <br>  If we look at newer standards (RFC1349), the value of the seventh bit has already been determined - the price requirements are ‚ÄúCost‚Äù (monetary value). <br>  So, let's say we want to determine if there are frames on the network in which the seventh bit of the ToS field is set in the IPv4 header.  How to do it?  To solve this problem, we need to remember (or learn: D) the binary system of calculus.  In a byte, each bit has its own weight, which starts from one and increases, from right to left, each time multiplying by two. <br><blockquote><pre>          0 1 2 3 4 5 6 7
       + ----- + ----- + ----- + ----- + ----- + ----- + ----- + ----- +
       |  |  |  |  |  |  |
       |  PRECEDENCE |  D |  T |  R |  C |  0 |
       |  0 0 0 |  0 |  0 |  0 |  1 |  0 |
       |  |  |  |  |  |  |
       + ----- + ----- + ----- + ----- + ----- + ----- + ----- + ----- +
         128 64 32 16 8 4 2 1
</pre></blockquote><br>  It turns out that the weight of the bit of interest is equal to 2. <br>  What if we compare the value of the ToS field with the two? <br>  <b>ip [1: 1] = 2</b> <br>  Will we get an answer to the question, is there a bit of interest in this header?  On the one hand, yes, but on the other hand, no. <br>  For example, if we have in the ToS field, in addition to the ‚ÄúCost‚Äù bit, there are also other bits set to one?  Let's say it will be the bit responsible for the bandwidth requirements - ‚ÄúThroughput‚Äù. <br><blockquote><pre>          0 1 2 3 4 5 6 7
       + ----- + ----- + ----- + ----- + ----- + ----- + ----- + ----- +
       |  |  |  |  |  |  |
       |  PRECEDENCE |  D |  T |  R |  C |  0 |
       |  0 0 0 |  0 |  1 |  0 |  1 |  0 |
       |  |  |  |  |  |  |
       + ----- + ----- + ----- + ----- + ----- + ----- + ----- + ----- +
         128 64 32 16 8 4 2 1
</pre></blockquote><br>  As a result, the value of this byte will no longer be 2, but 10, and a simple comparison cannot be answered to the question whether a certain bit is set in the field of interest. <br>  What prevents us from getting the answer that interests us?  We are hampered by the value of others, perhaps also set in unit bits.  Accordingly, it is necessary to get rid of them.  To solve this problem, we use the operation of a bitwise logical ‚ÄúAND‚Äù (sometimes called logical multiplication), denoted by the symbol ‚Äú <b>&amp;</b> ‚Äù.  As you know, in the logical operation "And" the output will be only one when both the first operand and the second operand are equal to one.  Accordingly, if we produce a bitwise multiplication of the value of the ToS field by a special mask in which only the bit that is in the position of the bit of interest in the ToS field will be set to one, we will exclude all other bits from the result: <br><blockquote><pre> ToS field: 00001010 = 10
 Mask: 00000010 = 2
 Result: 00000010 = 2
</pre></blockquote><br><br>  Whatever the value of the remaining bits, if you overlay this mask, only the value of the field of interest will fall into the result.  Even if we set all the bits to one, it will not affect the result: <br><blockquote><pre> ToS field: 11111111 = 255
 Mask: 00000010 = 2
 Result: 00000010 = 2
</pre></blockquote><br>  And only if the bit of interest to us is zero, as a result of the imposition of the mask will also be zero. <br><blockquote><pre> ToS field: 11111101 = 253
 Mask: 00000010 = 1
 Result: 00000000 = 0
</pre></blockquote><br>  Thus, if the bit of interest to us is equal to one, as a result of masking, we get the weight of this bit, if it is zero, then we get zero. <br>  Based on this, to solve this problem we need to apply the following filter: <br>  <b>ip [1: 1] &amp; 2 = 2</b> <br><br>  It will take the value of the second byte, impose on it the mask ‚Äúcutting out‚Äù the value of a certain bit and compare the result with the weight of this bit. <br><br>  We can give another example based on the analysis of the Type Of Service field of the IP header: we need to see all the frames where the Precedence bits (preference) in the IPv4 header in the ToS field is not zero.  For this, we apply a mask, in which the ones we select the bits that are responsible for Precedence: <br><blockquote><pre> ToS field: 10111101 = 189
 Mask: 11,100,000 = 224
 Result: 10,100,000 = 160
</pre></blockquote><br>  The result is not zero, and this suggests that the Precedence field is also non-zero. <br><br><blockquote><pre> ToS field: 00011111 = 31
 Mask: 11,100,000 = 224
 Result: 00000000 = 0
</pre></blockquote><br>  The result is zero, and this indicates that the Precedence field is also zero. <br><br>  As a result, checking for a non-zero value of the ToS field in the IPv4 header will look like this: <br>  <b>ip [1: 1] &amp; 224! = 0</b> <br>  or the same, but using the hexadecimal option: <br>  <b>ip [1: 1] &amp; 0xe0! = 0</b> <br><br>  Consider an example with a different protocol.  Take the TCP protocol. <br>  For example, we need to capture all frames that transmit TCP segments with options.  In order to understand what needs to be looked for and where to go to RFC-793. <br><blockquote><pre>   TCP Header Format
     0 1 2 3   
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 3 5 6 7 8 9 0 1 
    + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + + + + + + + - + - + - + - + - + - + - +
    |  Source Port |  Destination Port |
    + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + + + + + + + - + - + - + - + - + - + - +
    |  Sequence Number |
    + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + + + + + + + - + - + - + - + - + - + - +
    |  Acknowledgment Number |
    + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + + + + + + + - + - + - + - + - + - + - +
    |  Data |  | U | A | P | R | S | F |  |
    |  Offset |  Reserved | R | C | S | S | Y | I |  Window |
    |  |  | G | K | H | T | N | N |  |
    + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + + + + + + + - + - + - + - + - + - + - +<font></font>
<font></font>
    |  Checksum |  Urgent Pointer |
    + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + + + + + + + - + - + - + - + - + - + - +
    |  Options |  Padding |
    + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + + + + + + + - + - + - + - + - + - + - +
    |  data |
    + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + + + + + + + - + - + - + - + - + - + - +
</pre></blockquote><br>  To determine whether there is an option in the segment, the ‚ÄúData Offset‚Äù field is used, it is shown in the four-byte word length of the header.  The minimum length of a TCP segment header is 20 bytes, which is 5 four-byte words.  Accordingly, if there are options in the TCP segment header, the value of this field will be greater than 5. <br>  In order to get the value of this field it is necessary to use the primitive <b>tcp [12: 1]</b> .  True, given the fact that the minimum piece that we can take is one byte, and we need only 4 bits, we will have to think a little. <br>  Applying the primitive <b>tcp [12: 1]</b> we got the following piece of the header: <br><blockquote><pre>    + - + - + - + - + - + - + - + -
    |  Data |           
    |  Offset |  Reserved  
    |  |           
    + - + - + - + - + - + - + - + -
</pre></blockquote><br>  If the ‚ÄúData Offset‚Äù field were in the lower part of a byte, then the number ‚Äú5‚Äù in binary representation would look like this: <br><blockquote><pre>         128 64 32 16 8 4 2 1
          0 0 0 0 0 1 0 1 = 5
</pre></blockquote><br>  But the bits we are interested in are not in the left, lower, but in the right, higher part of it, therefore, to obtain a decimal equivalent, we transfer them to the right side of a byte: <br><blockquote><pre>         128 64 32 16 8 4 2 1
           0 1 0 1 0 0 0 0 = 80 (0x50 in hex)
</pre></blockquote><br>  To select the most significant bits, you must apply a mask: <br><blockquote><pre> Field Data Offset: 01010000 = 80
 Mask: 11110000 = 240
 Result: 01010000 = 80
</pre></blockquote><br>  If there are options in the header, then the ‚ÄúData Offset‚Äù value will be greater than 5. For example, if there is one eight-byte option in the header, the value of this field will be 7 (5 four-byte words of the fixed part of the header, and 2 four-byte option words): <br><blockquote><pre>         128 64 32 16 8 4 2 1
          0 0 0 0 0 1 1 1 = 7
</pre></blockquote><br>  Transferring the corresponding bits in the upper part we get: <br><blockquote><pre>         128 64 32 16 8 4 2 1
           0 1 1 1 0 0 0 0 = 112 (0x70 in hex)
</pre></blockquote><br>  Select the upper bits by applying the mask: <br><blockquote><pre> Field Data Offset: 01110000 = 112
 Mask: 11110000 = 240
 Result: 01110000 = 112
</pre></blockquote><br>  Thus, it turns out that if the result is a value greater than 80, then there are options in the TCP header.  In principle, the mask could not be superimposed, since the extra bits are still backup, and should always be zero, but you never know what can change, and in order not to rewrite the filter, if suddenly the standard changes, we better cut them off. <br>  The resulting filter, which shows those TCP segments in which the TCP header is longer than 5 four-byte words, is as follows: <br>  <b>tcp [12: 1] &amp; 240! = 80</b> <br>  or <br>  <b>tcp [12: 1] &amp; 240&gt; 80</b> <br>  or <br>  <b>tcp [12: 1] &amp; 0xf0&gt; 80</b> <br>  Also let's consider the possibility of working with TCP flags.  They can be distinguished by the same method using a mask, but you can also use character classifiers, which were cited above. <br>  For example, in order to capture frames containing segments with SYN or FIN flags, you need to write the following filter: <br>  <b>tcp [tcpflags] &amp; (tcp-syn | tcp-fin)! = 0</b> <br>  I think it is quite readable and does not require special explanations. <br>  The implementation of a similar task through bits and masks would lead to the following filter format: <br>  <b>tcp [13: 1] &amp; 2! = 0 or tcp [13: 1] &amp; 1! = 0</b> <br>  In order to consolidate the understanding of the topic, try to independently figure out how this filter option will work. <br><blockquote>  <b>For example</b> : <br>  The expression <b>ether [0] &amp; 1! = 0</b> selects all broadcast frames. <br>  The expression <b>ether [0] &amp; 1 = 0 and ip [16]&gt; = 244</b> selects all broadcast or multicast IP packets that do not use a broadcast or multicast MAC address in the data link layer. <br>  The expression <b>ip [0] &amp; 0xf = 5</b> will select all IP packets with no options. <br>  The <b>ip [6: 2] expression &amp; 0x1fff = 0</b> will select all non-fragmented IP packets, and the first fragments of fragmented packets. <br>  The expression <b>ip [-3] &amp; 0xff = 0x37</b> will select all IP packets whose MAC address of the sender ends with ‚Äú0x37‚Äù. </blockquote><br>  Another interesting set of bit operations is bit shift operations.  These operations are denoted by the symbols ‚Äúa pair of arrows‚Äù: ‚Äú&lt;&lt;‚Äù is a shift to the left and ‚Äú&gt;&gt;‚Äù is a shift to the right. <br>  How do they work? <br>  Take an arbitrary byte, for simplicity, take a unit, and write its value in binary numbering system: <br><blockquote><pre>         128 64 32 16 8 4 2 1
           0 0 0 0 0 0 1 = 1
</pre></blockquote><br>  Now we perform a bit shift to the left, shifting the values ‚Äã‚Äãof all bits by one position, and delivering zero to the least-significant free bit: <br><blockquote><pre>         128 64 32 16 8 4 2 1
          0 0 0 0 0 0 1 &lt;&lt;
</pre></blockquote><br><blockquote><pre>         128 64 32 16 8 4 2 1
          0 0 0 0 0 0 1 0 = 2
</pre></blockquote><br>  As a result, the value of the byte became equal to two, that is, doubled.  And once again apply this operation: <br><blockquote><pre>         128 64 32 16 8 4 2 1
          0 0 0 0 0 1 0 &lt;&lt;
</pre></blockquote><br><blockquote><pre>         128 64 32 16 8 4 2 1
          0 0 0 0 0 1 0 0 = 4
</pre></blockquote><br>  As a result, the value of the byte became equal to four, that is, again doubled.  Thus, we can conclude that the operation of the bit shift to the left is equivalent to multiplying the value of a byte by two (as we work with the binary system of calculus). <br>  Let's check the validity of this rule on a more complex number, for example, 100. We write it in binary form: <br><blockquote><pre>         128 64 32 16 8 4 2 1
           0 1 1 0 0 1 0 0 = 100
</pre></blockquote><br>  And now we perform the left shift operation: <br><blockquote><pre>         128 64 32 16 8 4 2 1
          1 1 0 0 1 0 0 &lt;&lt;
</pre></blockquote><br><blockquote><pre>         128 64 32 16 8 4 2 1
          1 1 0 0 1 0 0 0 = 200
</pre></blockquote><br>  As a result, the value of the byte was equal to 200 - doubled. <br>  Accordingly, we can immediately conclude that a bitwise shift to the right is equivalent to dividing a number by two. <br>  For example, the number 240: <br><blockquote><pre>         128 64 32 16 8 4 2 1
           1 1 1 1 0 0 0 0 = 240
</pre></blockquote><br>  Perform a right shift operation: <br><blockquote><pre>         128 64 32 16 8 4 2 1
          &gt;&gt; 1 1 1 1 0 0 0
</pre></blockquote><br><blockquote><pre>         128 64 32 16 8 4 2 1
          0 1 1 1 1 0 0 0 = 120
</pre></blockquote><br>  The value of the byte became equal to 120 - decreased twice. <br>  How can we use this operation?  Let's remember that the IHL (Internet Header Length) field of the IP header indicates the length of the header not in bytes, but in four-byte words, and to check whether the package contains options, we used the following operation: <br>  <b>ip [0] &amp; 0xf = 5</b> <br>  That is, it was not compared with a real value, but with a value divided into four (20 bytes are 5 four-byte words).  If for some reason it is more convenient to work with the header length in bytes (for example, if you need to subtract this value from the total packet length), then it must be multiplied by 4. In order to multiply the number by 4, it must be doubled by two , that is, perform a bit-shift left operation twice, and then compare with the required long IP header in bytes: <br>  <b>ip [0] &lt;&lt; 2 = 20</b> <br><br>  And of course, all this can be combined into multiple sets of rules: <br>  <b>(icmp [icmptype]! = icmp-echo and icmp [icmptype]! = icmp-echoreply) or (udp and udp port not 67 and ip [16] &lt;224) or (tcp [0: 2] &lt;1024 and tcp [ 2: 2] &lt;1024)</b> <br>  With this filter, the program will capture only those frames that fit one of the three descriptions: <br><ul><li>  Contain ICMP messages other than echo and echoreply (used by the ping utility) </li><li>  UDP datagrams are transmitted, except for those that use port 67 as the sender's port or receiver's port, and other than those that are sent to the multicast addresses and the limited broadcast address </li><li>  Transmit TCP segments in which both the port of the sender and the port of the receiver are in the range of ‚ÄúWell Known Ports‚Äù </li></ul><br><br><h4>  <b>4. Task for self-test: D</b> </h4><br>  To consolidate work with complex capture filters, try to understand what this filter describes and how it works: <br>  <b>tcp port 80 and (ip [2: 2] - ip [0] &amp; 0xf &lt;&lt; 2 - tcp [12] &amp; 0xf0 &gt;&gt; 2! = 0)</b> <br><blockquote>  <b>Note</b> : <br>  This is one of the standard examples, and if necessary, you can easily check yourself by using the Internet search, but still try to make an effort and deal with it yourself. </blockquote><br>  Successful sniffing) </div><p>Source: <a href="https://habr.com/ru/post/211042/">https://habr.com/ru/post/211042/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../211028/index.html">Browser game "Cyberset" - continued</a></li>
<li><a href="../211030/index.html">Google enters into a contract with the sea driver</a></li>
<li><a href="../211032/index.html">How to create a web page. Part 2 - Bootstrap</a></li>
<li><a href="../211034/index.html">The hardware paravirtualization mode will be available in the Xen 4.4 hypervisor and the Linux 3.14 kernel.</a></li>
<li><a href="../211040/index.html">Sometimes free lunches do happen.</a></li>
<li><a href="../211044/index.html">Welcome to Moscow PM 06/02</a></li>
<li><a href="../211046/index.html">Curiosity explores the way through the sand dunes</a></li>
<li><a href="../211050/index.html">Chef for 21 days. Part Three Chef and AWS</a></li>
<li><a href="../211052/index.html">20-gram ornithopter with stereoscopic vision independently bends around obstacles</a></li>
<li><a href="../211054/index.html">Imperceptible complexity of rocket technology. Part 3: types of liquid fuels, geometrical dimensions, transportation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>