<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Table interface: fast / uncomfortable - slow / convenient</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are questions that, it would seem, can not be resolved. Too often we meet with them in everyday life. But look carefully - and it turns out, no,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Table interface: fast / uncomfortable - slow / convenient</h1><div class="post__text post__text-html js-mediator-article">  There are questions that, it would seem, can not be resolved.  Too often we meet with them in everyday life.  But look carefully - and it turns out, no, not resolved.  Everybody does differently.  And not always good.  One such issue is the interaction of the user interface of working with the table and the database management system (DBMS). <br><br><img src="https://habrastorage.org/files/4b1/f52/8e3/4b1f528e38914ba49c2754e763d835e4.png"><br><br>  The requirements are clear.  The data should be displayed quickly, create a minimum load on the DBMS and work with them should be convenient for the user.  Solutions seem to be all there too.  But all the same, even in very successful projects, technologies have been used that suggest that the developers decided to come up with the ‚Äúbest‚Äù solution again. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I would like to consider modern approaches to solving this problem and consider whether there is a better option.  And, if not, when that is better to use. <a name="habracut"></a><br><br><h2>  Question 1. What is the fastest way to work with a table? </h2><br>  The fastest operation in the database is getting the record by the values ‚Äã‚Äãof the indexed fields, for example, the following query instantly returns the next record in an ordered set. <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sortField <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> sortField &gt; [ ] <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  where <i>sortField</i> is a field (set of fields) by which the data set is ordered.  Typically, such a set of fields includes the primary key, so that the order of entries is always the same. <br><br>  Hereinafter, I intentionally simplify the look of queries in order to improve readability.  It is clear that in real life for a set of fields the request will look more cumbersome. <br><br>  Thus, the fastest way to display data is to load them in sequence as you scroll.  Naturally, in this case, we do not know in advance when the scrolling will reach the end and display the slider, based on the currently loaded records. <br><br>  In this case, either page-by-page display can be used, such as, for example, in search engines, on Yandex.Market or Google mail, or ‚Äúendless scrolling‚Äù, such as on VKontakte.  There are combinations of these approaches, but the principle of working with a database is one. <br><br>  In the case of paginated viewing, the user is immediately displayed the first page and it is determined whether there is a next one (the next item in the sorted data set is checked)  Sometimes there is a check for the following pages.  In the case of an infinite scroll, it is assumed that there are only loaded records in the table.  As you scroll, additional entries are loaded (if any) and the position of the slider in the scroll bar is adjusted.  In any case, there is a sequential reading of records. <br><br>  For the user, the work is quite logical.  It sets some sorting and sorting conditions for records.  Further, it usually requires only the upper entries.  If the user decided to see what's next, he may well do it by scrolling through several pages.  So we, for example, work with search results in search engines. <br><br>  However, there are drawbacks. <br><br>  1. When working with tables (especially not very large), using the scroll bar to navigate through all the records is extremely convenient.  In this case, this opportunity is lost.  Experience shows that most of the tables the user works with do not contain many records. <br><br>  2. There is no possibility to go to the record.  Suppose, when working with my record library, I want to find some song that (I know) someone uploaded right after ‚ÄúQueen.  The Show Must Go On.  If I enter in the selection conditions ‚ÄúQueen.  The Show Must Go On ‚Äù, the song I need will not be displayed.  I will certainly see ‚ÄúQueen.‚Äù  The Show Must Go On ‚Äù, but I don‚Äôt know what was downloaded before or after it.  The only option in this case is to scroll through all the entries to the required and see what‚Äôs next.  A similar problem happens when using the mail server when you need to find a letter in the vicinity of a given one.  First you have to find this most specific letter, look at the date, and then set another filter by date. <br><br>  3. All downloaded data must be kept in memory. <br><br>  4. If the user selected a record and left it for other operations, then when returning to the table interface, to restore the old view, you will have to reload all records from the very first one. <br><br>  How serious these inconveniences are is to judge system analysts and, ultimately, users.  In different cases, these inconveniences manifest themselves in different ways. <br><br>  However, overcoming these inconveniences in any case suggests that it is necessary to somehow estimate the total number of records that fall within the sampling range, and to ensure a transition over them.  Those.  you must immediately show the correct position of the slider on the full scroll bar. <br><br>  Again, there are two options: a page view and the so-called ‚Äúlive‚Äù (live) view.  In the latter case, the records are loaded at the time of scrolling.  In this case, records that are outside the visible range are forgotten. <br><br>  To return the required records in most DBMSs, the offset keyword is currently provided, which returns entries with an offset by sorted population.  For all those who suffered from the performance of the DBMS, the next question immediately arises. <br><br><h2>  Question 2. Can the offset keyword be used? </h2><br>  The answer is no. <br><br>  For many, this answer will seem obvious, for example, for those who have read the PostgreSQL manual ( <a href="http://www.postgresql.org/docs/9.4/static/queries-limit.html">http://www.postgresql.org/docs/9.4/static/queries-limit.html</a> ): ‚ÄúStrings that are skipped using OFFSET should all equal to the server side;  therefore, working with large values ‚Äã‚Äãof the OFFSET parameter may be ineffective. ‚Äù <br><br>  But in reality, this is not the obvious answer. <br><br>  Contrary to well-established beliefs, offset works fairly quickly if the table is correctly indexed and the statistics are updated. <br><br>  Yes, many have tried unsuccessfully to use offset on large tables.  It was even worse for those who tried to use the row_number function in MS SQL Server.  There are two good articles on this topic.  They are dedicated to MS SQL Server ( <a href="http://sqlperformance.com/2015/01/t-sql-queries/pagination-with-offset-fetch">http://sqlperformance.com/2015/01/t-sql-queries/pagination-with-offset-fetch</a> ) and My SQL ( <a href="https://explainextended.com/2009/10/23/mysql-order-by-limit-performance-late-row-lookups">https://explainextended.com/2009/10/23/ mysql-order-by-limit-performance-late-row-lookups</a> ).  The point is that offset should not be applied immediately to the sample: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> attr1, clusteredField <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span>;</code> </pre> <br>  and indirectly through the field on which the clustered index is built <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> clusteredField <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> clusteredField <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> attr1, clusteredField <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br>  Here it is assumed that a clustered index is built across the <i>clusteredField</i> field and all standard recommendations are applied, for example, not to make the <i>clusteredField</i> field of the ‚Äúunique identifier‚Äù type. <br><br>  Analysis of this query shows that the processor usage, the number of reads and the total time approximately correspond to the operation of counting the number of records to the required one.  This is not surprising, the operation algorithm when using both <i>offset</i> and <i>count is</i> about the same.  The only difference is that queries with <i>count</i> are simpler and the query optimizer is less likely to create an inadequate execution plan. <br><br>  Worse is another: queries that use both <i>count</i> and <i>offset</i> , being fast, are not instantaneous.  Counting is counting.  Let even statistics be used.  Those.  on large tables, the user will in any case expect some, perhaps very uncomfortable, time before receiving the necessary entries. <br><br>  Can I get rid of it?  Yes.  The algorithm is given in the article <a href="https://habrahabr.ru/post/278773">https://habrahabr.ru/post/278773</a> . <br><br>  Simply put, the search for records is not by number, but by the field values ‚Äã‚Äãspecified for sorting (hereinafter referred to as sorting fields). <br><br>  For example, if the first last name in a sorted phone directory is Andreev (A is the first letter), and the last is Yakovlev (I am the 33rd letter), then if the user moved the slider to the middle, then most likely you need to show something with the letter P ( 17th letter). <br><br>  After the user instantly displays the records with the letter P (instantly, since the search is performed on the index), you can start the counting operation and after some time move the slider to where it should be.  For the user, this will not be an inconvenience.  He is already working with the required entries. <br><br>  At the same time, you can accumulate a so-called ‚Äúinterpolation‚Äù table, which contains pairs: the last name is the real position of the slider.  The next time you move the slider, you can take into account the actual position of the letter P. <br><br>  If several points of the interpolation table are calculated in advance, then a rebound, if any, is minimal and inconspicuous to the user. <br><br>  You will say that several operations with counting the number of records are a lot.  This is not true.  Several points can be calculated in one query of the following form: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) ,<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> attr1 &lt; <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) ,<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> attr1 &lt; <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>;</code> </pre><br>  The cost of this request will be slightly higher than just: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>;</code> </pre> <br>  Indeed, all calculations in this case are done within a single index scan. <br><br>  Of course, if in our directory one Andreev, one Yakovlev, and all the other persons ‚Äî it just so happens ‚Äî have a last name starting with ‚ÄúP‚Äù (but we do not know this in advance), then a query on all letters of the alphabet will not help, you still need there will be the following iterations in order to ‚Äúexpand‚Äù a set of records on ‚ÄúP‚Äù.  But this is a rare case that will not affect the performance on average. <br><br>  The described method allows you to instantly display the required records to the user.  Thus, the usability becomes significantly higher than when using offset.  The load on the DBMS is no different.  The only disadvantage is the rebound of the engine, which in reality is minimal. <br><br>  A more serious disadvantage is the complicated implementation.  But such problems of the end user should not worry.  High-level developers, frankly, too.  That's why development frameworks are needed to solve such problems for developers. <br><br>  Naturally, using the approach in which the user sees the entire scroll bar at once, in any implementation, involves the use of slow operations (no matter using the keywords <i>count</i> or <i>offset</i> ), which load the DBMS.  But you still have to pay for the convenience.  In this case, pay not so much.  If a table displays many fields, then often the resources expended to count records, even in large sets, are less than a sample. <br><br>  Moreover, it is necessary to evaluate not the entire data set, but only the part that falls into the user's sample.  For example, if there are 10 million records in a table, but more than 1 million records cannot be included in the sampling conditions, then it is necessary to take exactly 1 million records for the evaluation. <br><br>  We experimented on data from the Federal Address System (FIAS).  This is over a million entries. <br><br>  The experiment was very simple.  We implemented two options for working with the database: (1) fast - with sequential data loading) and (2) convenient - in which the full scroll bar and the correct slider position are shown to the user.  During the initial display, the 1st method actually works several times faster.  However, after we scrolled through several pages of records, it turned out that the load on the DBMS in both cases is quite comparable.  I deliberately do not give exact figures in order not to complicate the article.  In addition, it is clear that, even with similar operations, the DBMS operation may work differently.  Therefore, it is the estimated values ‚Äã‚Äãthat are important: ‚Äúslightly more resources‚Äù, ‚Äúsignificantly more resources‚Äù, ‚Äúapproximately the same‚Äù, etc.  In this case, it‚Äôs about ‚Äúslightly more resources‚Äù. <br><br>  In conclusion, I would like to confess that at the beginning of the article, while pointing out the shortcomings of the sequential loading method, an important detail was not indicated.  If we supplement this method with pieces of the algorithm for displaying records based on the values ‚Äã‚Äãof sorting fields, some of the drawbacks can be removed. <br><br>  It should take into account the following. <br><br><ol><li>  The user will still not have a scroll bar, on the basis of which you can estimate both the number of entries and the place of the currently displayed entries.  Those.  still be uncomfortable. </li><li>  If we enable the transition to the remote records, then in any case we load the DBMS, i.e.  In one way or another, we lose the main advantage of the method of sequential data loading. </li></ol><br>  Thus, we have two poles (let's call them less radically than in the title of the article): (1) very quickly / satisfactorily convenient, (2) very convenient / fairly quickly.  There are options between these poles, but in this case it does not make sense to look for them. <br><br><h2>  findings </h2><br><ol><li>  The use of scrolling, in which the user immediately sees the position of the slider, even on large amounts of data (millions of records in the sample) when positioning by the values ‚Äã‚Äãof the sorting fields, ensures quick and convenient work with the table with an acceptable penalty on the performance of the database management server. </li><li>  The use of solutions that ensure consistent data download is justified only if the search is carried out in huge amounts of data: archives of letters, music library, etc. </li><li>  The use of the keyword <i>offset is</i> impractical because the method of displaying records is worse than searching records by the values ‚Äã‚Äãof sorting fields, gives the same convenience in terms of navigation and does not give any performance advantages. </li></ol><br>  PS In Microsoft Dynamics NAV, in versions prior to 2013, when working with tables, the full scroll bar was displayed, the records for display were searched for by the values ‚Äã‚Äãof sorting fields.  Starting from version 2013, an algorithm is used in which data is loaded sequentially.  One gets the feeling that Microsoft sacrificed the convenience of 99% of users in order to expand the use of NAV by 1%. <br><br>  It remains to hope that Microsoft will not refuse from 3d in favor of 2d on Xbox.  More demanding users. </div><p>Source: <a href="https://habr.com/ru/post/280157/">https://habr.com/ru/post/280157/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../280147/index.html">Oracle has released an emergency update for java</a></li>
<li><a href="../280149/index.html">Documents for the protection of personal data. Fighting with freeloaders</a></li>
<li><a href="../280151/index.html">Extreme developer: how to relax programmers Veeam</a></li>
<li><a href="../280153/index.html">3.2 Event handling</a></li>
<li><a href="../280155/index.html">The market for mobile and web development goes to the regions and to the West</a></li>
<li><a href="../280159/index.html">‚ÄúSatellite / Maps‚Äù in a new style</a></li>
<li><a href="../280161/index.html">RUVDS and Huawei start working together</a></li>
<li><a href="../280163/index.html">LenovoDev launches Multi-Touch Multi-Hack - a hackathon for developers with a prize fund of $ 25,000</a></li>
<li><a href="../280165/index.html">Meet the big brother of hyperconvergent systems</a></li>
<li><a href="../280169/index.html">11 unexpected features of programming languages</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>