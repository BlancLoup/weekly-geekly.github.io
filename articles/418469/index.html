<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>When not to use STL algorithms. Example with sets</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comrades, good evening! You have so nicely disassembled the first edition of the book ‚Äú C ++ 17 STL. Standard Template Library ‚Äù and continue to analy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>When not to use STL algorithms. Example with sets</h1><div class="post__text post__text-html js-mediator-article"> Comrades, good evening!  You have so nicely <a href="https://www.piter.com/collection/all/product/s17-stl-standartnaya-biblioteka-shablonov">disassembled</a> the first edition of the book ‚Äú <a href="https://habr.com/company/piter/blog/353404/">C ++ 17 STL. Standard Template Library</a> ‚Äù and continue to analyze the second one, so that we finally decided to present here an alternative point of view.  The author of today's article is Ivan ƒåukiƒá, whose writer also owns the book <a href="https://www.manning.com/books/functional-programming-in-cplusplus">Functional Programming in C ++</a> , which is being prepared for release by the publishing house Manning.  We offer to evaluate his skeptical thoughts, code and calculations. <br><a name="habracut"></a><br>  <b>Preamble</b> <br><br>  I wanted to call this post ‚ÄúOn the perversity of STL-algorithms‚Äù to test my own skills for provoking clicks.  But then I decided that it was better to write an article for the target audience, and not to write such a post, where those who wish to argue about my blatant theses will fly. <br><br>  Thus, I can assume that you are interested in algorithms, their complexity and want to write the most perfect code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Algorithms</b> <br><br>  In today's professional community, C ++ schnick is often advised: to make your program safer, faster, more expressive, etc.  - use algorithms from the standard library.  I also try to popularize this advice in my books, speeches, seminars ... wherever there is a suitable audience. <br><br>  Of course, it is absolutely true that if we are forced to write a <code>for</code> loop to solve the task before us, we first need to think about whether the existing algorithms of the standard library (or boost) are suitable for this, and not act blindly. <br><br>  We still need to know how these algorithms are implemented, what requirements and guarantees are associated with them, what their spatial and temporal complexity. <br><br>  Usually, if we are faced with a task that exactly meets the requirements of the STL algorithm and can be applied directly, it is this algorithm that will be the most effective solution. <br><br>  The problem may arise if we need to prepare the data in any way before applying the algorithm. <br><br>  <b>Intersection of many</b> <br><br>  Suppose we are writing a tool for C ++ developers that would give hints about replacing default capture options (talking about <code>[=]</code> and <code>[&amp;]</code> ) in lambda expressions, and explicitly display a list of captured variables. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::partition(begin(elements), end(elements), [=] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> element) { ^~~ -  -  ,   [threshold] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element &gt; threshold; });</code> </pre> <br>  When parsing a file, we need a collection in which variables from the current and adjacent scopes would be stored.  As soon as we encounter a default lambda expression, we will need to see which variables are used there. <br><br>  As a result, we have two sets: in one there will be variables from the surrounding scopes, and in the other, variables used in the body of a lambda expression. <br><br>  The list of capture options that we are going to propose for replacement should be the intersection of these two sets (lambda expressions can use global variables that are not required to be captured, and not all variables from surrounding scopes will be used in lambda expressions). <br><br>  And, if we need an intersection, then we can use the <code>std::set_intersection</code> . <br><br>  This algorithm is quite beautiful in its simplicity.  It accepts two sorted collections and in parallel passes them from beginning to end: <br><br><ul><li>  If the actual item in the first collection is equal to the actual item in the second collection, it is added to the result, which the algorithm simply moves to the next item in both collections; </li><li>  If the actual item in the first collection is less than the actual item in the second collection, then the algorithm simply skips the current item in the first collection; </li><li>  If the actual item in the first collection is more than the actual item in the second collection, then the algorithm simply skips the current item in the second collection; </li></ul><br>  At each iteration, at least one element (from the first or from the second input collection) is skipped - therefore, the complexity of the algorithm will be linear - <code>O(m + n)</code> , where <code>m</code> is the number of elements in the first collection, and <code>n</code> is the number of elements in the second collection . <br><br>  Simple and effective.  Until the input collections are sorted. <br><br>  <b>Sorting</b> <br><br>  Here's the problem: what if the collections are not pre-ordered? <br><br>  In the previous example, it would be wise to store variables from the surrounding scopes in a glass-like structure, where the parser could simply add new elements, enter the new scope, and delete the variables of the current scope as soon as it leaves. <br><br>  Thus, the variables will not be sorted by name, and we will not be able to directly use <code>std::set_intersection</code> for operations on them.  Similarly, if we track variables in the body of a lambda expression, then we, most likely, will not be able to save them in sorted form either. <br><br>  Since <code>std::set_intersection</code> works only with sorted collections, many projects have the following principle: first sort the collections, and then call the algorithm <code>std::set_intersection</code> . <br><br>  If we forget that the sorting of the stack of variables in our example completely devaluates the entire proc of the stack we defined, the intersection algorithm for unsorted collections will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt2, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OutputIt&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unordered_intersection_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(first1, last1); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(first2, last2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::set_intersection(first1, last1, first2, last2, dest); }</code> </pre> <br>  What is the complexity of this whole algorithm?  It takes quasilinear time to sort, so the total complexity of this approach is <code>O(n log n + m log m + n + m)</code> . <br><br>  <b>Sort the smaller</b> <br><br>  Is it possible to do without sorting? <br><br>  If both collections are not sorted, then we will have to bypass the second collection about each item from the first ‚Äî to decide whether to include it in the result set.  Although this approach is quite common in real projects, it is even worse than the previous one - its complexity is <code>O(n * m)</code> . <br><br>  Instead of sorting everything in a row, or not sorting anything, recall Zen and choose the Third Way ‚Äî sort only one collection. <br><br>  If only one collection is sorted, then we can enumerate all the values ‚Äã‚Äãfrom the unsorted collection one by one and check for each value whether it is in the sorted collection.  For this, use binary search. <br><br>  In this case, the time complexity will be <code>O(n log n)</code> for sorting the first collection and <code>O (m log n)</code> for sorting and checking.  The overall complexity will be <code>O((n + m) log n)</code> . <br><br>  If we decided to sort the second collection, rather than the first, then the complexity would be <code>O((n + m) log m)</code> . <br><br>  To achieve maximum efficiency, we always sort the collection in which there are fewer elements, ensuring that the final complexity of our algorithm is <br>  <code>((m + n) log (min(m, n))</code> . <br><br>  The implementation will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt2, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OutputIt&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unordered_intersection_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size1 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::distance(first1, last1); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::distance(first2, last2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size1 &gt; size2) { unordered_intersection_2(first2, last2, first1, last1, dest); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(first1, last1); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy_if(first2, last2, dest, [&amp;] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::binary_search(first1, last1, FWD(value)); }); }</code> </pre> <br>  In our example with capture lists in lambda expressions, a collection of variables present in a lambda expression is usually subjected to sorting, since it is likely to be smaller than the collection of all variables from all surrounding scopes. <br><br>  <b>Hashing</b> <br><br>  The final option is to build <code>std::unordered_set</code> (implementation of a hash-based unordered set) from a smaller collection, rather than sorting it.  In this case, the complexity of the search operations will average <code>O(1)</code> , but it will take time to build <code>std::unordered_set</code> .  The complexity of the construction can be from <code>O(n)</code> to <code>O(n*n)</code> , and this is a potential problem. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt2, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OutputIt&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unordered_intersection_3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size1 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::distance(first1, last1); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::distance(first2, last2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size1 &gt; size2) { unordered_intersection_3(first2, last2, first1, last1, dest); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; test_set(first1, last1); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy_if(first2, last2, dest, [&amp;] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test_set.count(FWD(value)); }); }</code> </pre> <br>  The hashing approach fully benefits when it is necessary to calculate the intersections of several sets with a single predetermined small set.  That is, we have the set <code>A</code> , the sets <code>B‚ÇÅ</code> , <code>B‚ÇÇ‚Ä¶</code> and we want to calculate <code>A ‚à© B‚ÇÅ, A ‚à© B‚ÇÇ‚Ä¶</code> <br><br>  In this case, you can ignore the complexity of the <code>std::unordered_set</code> construction, and the complexity of calculating each intersection will be linear - <code>O(m)</code> , where <code>m</code> is the number of elements in the second collection. <br><br>  <b>Control</b> <br><br>  Of course, it is always useful to check the complexity of the algorithm, but in such cases it is also reasonable to test different approaches using checkpoints.  Especially when choosing from the last two options, where we compare binary search and hash-based sets. <br>  My simplest test showed that the first option, where you have to sort both collections, is always the slowest. <br><br>  Sorting a smaller collection wins a little at <code>std::unordered_set</code> , but not particularly. <br><br>  Both the second and third approaches are slightly faster than the first in the case when there is an equal number of elements in both collections, and much faster (up to six times), when the number of elements in one collection is about 1000 times more than in the second. </div><p>Source: <a href="https://habr.com/ru/post/418469/">https://habr.com/ru/post/418469/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418455/index.html">Open webinar "Specialist" at the helm ": first experience and mistakes"</a></li>
<li><a href="../418459/index.html">Development of LVDS scaler with two DisplayPort interfaces</a></li>
<li><a href="../418463/index.html">Working with data in Angular</a></li>
<li><a href="../418465/index.html">A new version of Specter attack was discovered with the ability to remotely receive data over the network.</a></li>
<li><a href="../418467/index.html">Marking Arts Developer Rankings</a></li>
<li><a href="../418475/index.html">Windows 10 uses machine learning technology to determine the possibility of an update.</a></li>
<li><a href="../418479/index.html">Conference DEFCON 23. How I lost my second eye, or further research in the field of data destruction. Part 2</a></li>
<li><a href="../418481/index.html">Living in Israel - some IT related moments</a></li>
<li><a href="../418483/index.html">How to compress bootloader for STM8 to size 8 bytes in flash memory</a></li>
<li><a href="../418485/index.html">Breaking Bad 3 - Place a cross over Dark Forester</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>