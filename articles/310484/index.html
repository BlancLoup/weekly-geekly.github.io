<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compress mobile graphics to ETC1 format and open utility</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With the development of free-to-play mobile games, new graphics are regularly added along with new features. Part of it is included in the distributio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compress mobile graphics to ETC1 format and open utility</h1><div class="post__text post__text-html js-mediator-article">  With the development of free-to-play mobile games, new graphics are regularly added along with new features.  Part of it is included in the distribution, part is downloaded during the game.  To enable the application to run on devices with a small amount of RAM, developers use <a href="https://habrahabr.ru/company/intel/blog/276089/">hardware-compressed textures</a> . <br><br> <a href="https://habrahabr.ru/company/playrix/blog/310484/"><img src="https://habrastorage.org/getpro/habr/post_images/d35/b77/b2c/d35b77b2c69087fc79f55bd429f4b059.jpg"></a> <br><br>  <a href="http://www.khronos.org/registry/gles/extensions/OES/OES_compressed_ETC1_RGB8_texture.txt">The ETC1 format is</a> obligatory for support on all Android devices with OpenGL ES 2.0 and is a good starting point for optimizing the consumed RAM.  Compared with the PNG, JPEG, WebP formats, the ETC1 textures are loaded without intensive calculations using regular memory copying.  The performance of the game is also improved due to the smaller size of the texture data sent from slow to fast memory. <br><a name="habracut"></a><br>  On any device with OpenGL ES 3.0, it is possible to use textures in the ETC1 format, which is a subset of the improved <a href="http://www.jacobstrom.com/publications/StromPetterssonGH07.pdf">ETC2 format</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Using ETC1 Compressed Textures </h2><br>  The ETC1 format contains only RGB color components, so it is suitable for opaque backgrounds that are recommended to be drawn with Alpha-blending disabled. <br><br>  What to do with transparent graphics?  For it, we use two ETC1 textures (hereinafter - 2xETC1): <br><br>  - in the first texture we store the original RGB; <br>  - in the second texture we store the original alpha (hereinafter - A), copying it into the RGB components. <br><br>  Then in the 2xETC1 pixel shader, we restore the colors in this way: <br><br><pre><code class="hljs pgsql">uniform sampler2D u_Sampler; uniform sampler2D u_SamplerAlpha; <span class="hljs-type"><span class="hljs-type">varying</span></span> vec2 v_TexCoords; <span class="hljs-type"><span class="hljs-type">varying</span></span> vec4 v_Color; <span class="hljs-type"><span class="hljs-type">void</span></span> main() {    vec4 sample = texture2D(u_Sampler, v_TexCoords);    sample.a = texture2D(u_SamplerAlpha, v_TexCoords).r;    gl_FragColor = sample * v_Color; }</code> </pre> <br><h2>  Features of the preparation of atlases before compression in ETC1 format </h2><br>  The ETC1 format uses independent 4x4 pixel blocks, so it is desirable to align the position of the elements placed in the atlas by 4 pixels to prevent different elements from entering the common block. <br><br>  All elements when placed in the atlas slightly increase in area, because they need an additional protective frame with a thickness of 1-2 pixels.  This is due to the fractional rendering coordinates (with the smooth movement of sprites) and with bilinear texture filtering.  The mathematical justification for the causes of what is happening deserves a separate article. <br><br>  In the case of <a href="https://habrahabr.ru/company/playrix/blog/306554/">polygonal atlases, the</a> elements are divorced to an acceptable distance.  All 4x4 ETC1 blocks consist of a pair of 2x4 or 4x2 stripes, so even a distance of 2 pixels can have a good insulating effect. <br><br><h2>  How can you compress quality in ETC1 format? </h2><br>  There is a <a href="https://bitbucket.org/wolfpld/etcpak/wiki/Home">choice</a> among free utilities: <br><br>  - <a href="https://medium.com/%40duhroach/building-a-blazing-fast-etc2-compressor-307f3e9aad99">ETC2Comp</a> ; <br>  - <a href="http://malideveloper.arm.com/resources/tools/mali-gpu-texture-compression-tool/">Mali GPU Texture Compression Tool</a> ; <br>  - <a href="https://community.imgtec.com/developers/powervr/tools/pvrtextool/">PVRTexTool</a> ; <br>  - <a href="https://code.google.com/archive/p/rg-etc1/">rg-etc1</a> . <br><br>  For high-quality graphics compression, you have to set a perceptual metric that takes into account perceptual features, as well as choose the slowest modes best and slow.  Having once tried to compress the texture 2048x2048 qualitatively, you understand that this is a long process ... Perhaps that is why many developers are limited to fast medium and fast alternatives.  Is it possible to do better? <br><br>  The history of creating <a href="https://github.com/Playrix/playrix-public">EtcCompress</a> from scratch by one of Playrix‚Äôs programmers began in January 2014, when the final graphics compression in ETC1 format exceeded the three-hour trip to visit. <br><br><h2>  Ideas quality compression format ETC1 </h2><br>  The ETC1 format is a format with independent blocks.  Therefore, we use the classical approach of compressing individual blocks, which is well parallelized.  Of course, you can try to improve the docking of the blocks, considering the sets of blocks, but in this case you will need information about belonging to the elements of the atlas and the computational complexity of the problem increases dramatically. <br><br>  The <a href="https://kornel.ski/dssim">dssim</a> utility is suitable for comparing compression results. <br><br><img src="https://lh5.googleusercontent.com/k9YQLcDvFjDetEAwv4-tmjp_7ABDhVgesv_JK9ut_htoljFekT9MntVWmt81nktcq9sN6GAOHOVSMZznKh4H5X_ZGIzu5mxAf2Icyu3fruS-XfRl-DJYk9a9un8HvDFv6doHMejR" align="left">  For each block, you will have to go through all 4 possible encoding modes to find the best CompressBlockColor function in the code: <br><br>  - two 2x4 strips, each having its own 4-bit base color, in the code calls CompressBlockColor44 (..., 0); <br>  - two 4x2 strips, each with its own 4-bit base color, in the code calls CompressBlockColor44 (..., 1); <br>  - two 2x4 stripes, the first one having a basic 5-bit color, the second one differing from the first color in the 3-bit range, in the code there are CompressBlockColor53 calls (..., 2); <br>  - two 4x2 stripes, the first one having a basic 5-bit color, the second one differing in the base color from the first one in the 3-bit range, in the code, calls to CompressBlockColor53 (..., 3). <br><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/6ea/651/a2f/6ea651a2f9dcafe44ec7841dd89a9c03.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/b29/dde/e5e/b29ddee5e1c0e99f8ab32966762122bb.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/4bb/93d/719/4bb93d71902082a2f7e924ed1792007f.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/307/576/66c/30757666c6f65e8172b200827310828b.png"></td></tr><tr><td>  2x4, 444 + 444 </td><td>  4x2, 444 + 444 </td><td>  2x4, 555 + 333 </td><td>  4x2, 555 + 333 </td></tr></tbody></table><br><img src="https://lh5.googleusercontent.com/k9YQLcDvFjDetEAwv4-tmjp_7ABDhVgesv_JK9ut_htoljFekT9MntVWmt81nktcq9sN6GAOHOVSMZznKh4H5X_ZGIzu5mxAf2Icyu3fruS-XfRl-DJYk9a9un8HvDFv6doHMejR" align="left">  Speaking of an error, many utilities use the classic <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B8%25D0%25BA%25D0%25BE%25D0%25B2%25D0%25BE%25D0%25B5_%25D0%25BE%25D1%2582%25D0%25BD%25D0%25BE%25D1%2588%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25B3%25D0%25BD%25D0%25B0%25D0%25BB%25D0%25B0_%25D0%25BA_%25D1%2588%25D1%2583%25D0%25BC%25D1%2583">PSNR</a> .  We also use this metric.  Choose weights from the <a href="http://www.brucelindbloom.com/index.html%3FWorkingSpaceInfo.html">table</a> . <br><br><pre> <code class="hljs markdown">PixelError = 0.715158 <span class="hljs-bullet"><span class="hljs-bullet">* (dstG - srcG)^2 + 0.212656 *</span></span> (dstR - srcR)^2 + 0.072186 * (dstB - srcB)^2</code> </pre> <br>  We turn to the integer values ‚Äã‚Äãby multiplying the coefficients by 1000 and rounding.  Then the initial 4x4 block error will be <code>kUnknownError  = (255^2) * 1000 * 16 + 1</code> , where <code>255</code> is the maximum error of the color component, <code>1000</code> is a fixed amount of weights, 16 is the number of pixels.  This error fits into <code>int32_t</code> .  It can be noted that integer quadration is close in meaning to accounting for <a href="https://habrahabr.ru/post/304210/">gamma 2.2</a> . <br><br>  PSNR has weak points.  For example, encoding a fill color <code>c0</code> choosing from the palette <code>c1 = c0 - d</code> and <code>c2 = c0 + d</code> introduces the same error <code>d^2</code> .  This means a random choice between <code>c1</code> and <code>c2</code> involving all sorts of checkers. <br><br>  To improve the result, the final calculation in the block will be <a href="https://habrahabr.ru/post/126848/">performed</a> by <a href="https://habrahabr.ru/post/126848/">SSIM</a> .  In the code, this is done in the ComputeTableColor function using SSIM_INIT, SSIM_UPDATE, SSIM_CLOSE, SSIM_OTHER, SSIM_FINAL macros.  The idea is that for all solutions with the best PSNR (in the found encoding mode), the solution with the highest SSIM is chosen. <br><br><img src="https://lh5.googleusercontent.com/k9YQLcDvFjDetEAwv4-tmjp_7ABDhVgesv_JK9ut_htoljFekT9MntVWmt81nktcq9sN6GAOHOVSMZznKh4H5X_ZGIzu5mxAf2Icyu3fruS-XfRl-DJYk9a9un8HvDFv6doHMejR" align="left">  For each block coding mode, you will have to go through all possible combinations of basic colors.  In the case of independent base colors, the CompressBlockColor44 function performs independent compression of strips with two calls to GuessColor4. <br><br>  The GuessColor4 function iterates over the deviations and the base color component: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = <span class="hljs-number"><span class="hljs-number">0</span></span>; q &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; q++)   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c0 = <span class="hljs-number"><span class="hljs-number">0</span></span>; c0 &lt; c0_count; c0++) <span class="hljs-comment"><span class="hljs-comment">// G, c0_count &lt;= 16       for (int c1 = 0; c1 &lt; c1_count; c1++) // R, c1_count &lt;= 16           for (int c2 = 0; c2 &lt; c2_count; c2++) // B, c2_count &lt;= 16               ComputeErrorGRB(c, q);</span></span></code> </pre> <br>  In the case of dependent base colors, the algorithmic complexity increases due to the double nesting of the loops of the strips.  The CompressBlockColor53 function performs enumeration overruns. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> qa = <span class="hljs-number"><span class="hljs-number">0</span></span>; qa &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; qa++)   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> qb = <span class="hljs-number"><span class="hljs-number">0</span></span>; qb &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; qb++)       AdjustColors53(qa, qb);</code> </pre> <br>  The AdjustColors53 function iterates through the components of two basic colors: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a0 = <span class="hljs-number"><span class="hljs-number">0</span></span>; a0 &lt; a0_count; a0++) <span class="hljs-comment"><span class="hljs-comment">// G, a0_count &lt;= 32   for (int a1 = 0; a1 &lt; a1_count; a1++) // R, a1_count &lt;= 32       for (int a2 = 0; a2 &lt; a2_count; a2++) // B, a2_count &lt;= 32           ComputeErrorGRB(a, qa);           for (int d0 = Ld0; d0 &lt;= Hd0; d0++) // G, d0_count &lt;= 8               for (int d1 = Ld1; d1 &lt;= Hd1; d1++) // R, d1_count &lt;= 8                   for (int d2 = Ld2; d2 &lt;= Hd2; d2++) // B, d2_count &lt;= 8                       b = a + d;                       ComputeErrorGRB(b, qb);</span></span></code> </pre> <br>  The presented exhaustive search is not faster than the best compression modes of similar utilities, but this is our complete exhaustive search, which will be greatly accelerated further. <br><br><img src="https://lh5.googleusercontent.com/k9YQLcDvFjDetEAwv4-tmjp_7ABDhVgesv_JK9ut_htoljFekT9MntVWmt81nktcq9sN6GAOHOVSMZznKh4H5X_ZGIzu5mxAf2Icyu3fruS-XfRl-DJYk9a9un8HvDFv6doHMejR" align="left">  In the case of 2xETC1 graphics, fully transparent pixels in the general case can have an arbitrary RGB color, which will be multiplied by zero alpha. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b57/518/187/b5751818711a44cc89efdf522dee29ac.png"></div><br>  We can ignore the insignificant pixels, so let's filter them at the very beginning, in the code, these are the calls to FilterPixelsColor.  On the other hand, not every transparent pixel is insignificant, we recall at least a protective frame of 1-2 pixels and the <a href="http://doom2d.org/forum/viewtopic.php%3Ff%3D16%26t%3D180">effect of bleaching borders</a> . <br><br>  Therefore, we will make a stencil in which zero means an insignificant pixel, and a positive value will show a significant pixel.  The stencil is created on the basis of channel A by applying a stroke, usually 1 or 2 pixels in size, in the code this is the OutlineAlpha function. <br><br>  As practice has shown, when using a stencil, the compressed borders of objects are improved, and the invisible blocks quickly take on a well-packaged zip black color.  It is the idea of ‚Äã‚Äãthe stencil that gives a noticeable gain in quality in comparison with separate compression of RGB and A, including the listed utilities. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/441/ee4/efc/441ee4efc350433c900e874a4492e07f.png"></div><br>  Thus, 2xETC1 compression can be represented by the following steps, implemented in the EtcMainWithArgs function: <br><br>  1) compress channel A to ETC1 format; <br>  2) unpack the compressed channel A back; <br>  3) make the stroke visible, where A&gt; 0, getting a stencil; <br>  4) compress the RGB channels in the ETC1 format, taking into account the stencil. <br><br><h2>  Ideas for speeding up quality compression in ETC1 format </h2><br>  In order for the utility to find its use, besides the quality of the result, the time of work is also important.  The considered partial block compression algorithm is worthy of a quick initial heuristic estimate and useful cut-offs during work, including those based on greedy algorithms. <br><br><img src="https://lh6.googleusercontent.com/gDVLUkDR5XTM8OkYfo5IKbs1Acp6OA5dxxdC8fDKO1XZsRmR1oiDs659Rt6k0j6aDE2vtLJt4koNqzsNSzFQNhNu_WAcePNe9Z09A7Q3-29Z6sd5aXMLeFrFEEvkjWwjVWNLO5ze" align="left">  For a format with independent blocks, incremental compression is easily implemented.  For example, when the previous compression results are saved. <br><br>  In this case, the packer tries to read the output file, unpack it and calculate the existing error; this will be the initial solution.  If there is no file, then the initial solution is taken from zeros.  In the code, this is LoadEtc1, CompressBlockColor, MeasureHalfColor. <br><br>  Subsequent steps should attempt to improve the existing solution with algorithms of increasing complexity.  Therefore, first, fast CompressBlockColor44 is called, and only then slow CompressBlockColor53.  Such a chain construction in the future will allow the integration of compression into the ETC2 format. <br><br><img src="https://lh6.googleusercontent.com/gDVLUkDR5XTM8OkYfo5IKbs1Acp6OA5dxxdC8fDKO1XZsRmR1oiDs659Rt6k0j6aDE2vtLJt4koNqzsNSzFQNhNu_WAcePNe9Z09A7Q3-29Z6sd5aXMLeFrFEEvkjWwjVWNLO5ze" align="left">  Before the beginning of the search by nested loops, it makes sense to find a solution in the context of color components.  The fact is that the best solution cannot have an error smaller than the total error of the best solutions for each of the components G, R, B. Often, the resulting error will be significantly larger, which characterizes the nonlinearity and complexity of the ETC1 algorithm. <br><br>  Solutions in terms of color components are represented by GuessStateColor and AdjustStateColor structures.  For each value from the deviation table g_table, the errors of the Half bars are calculated and stored in the fields node0, node1, node2.  And in GuessStateColor indexes [0x00..0x0F] store the calculated errors for all possible base colors g_colors4, and the index [0x10] is the best solution.  For AdjustStateColor, the best solution is stored in the [0x20] index, all possible base colors are taken from g_colors5. <br><br>  The error calculation for the color components is performed by the ComputeLevel, GuessLevels, AdjustLevels functions based on the g_errors4, g_errors5 tables previously calculated by the InitLevelErrors function. <br><br><img src="https://lh6.googleusercontent.com/gDVLUkDR5XTM8OkYfo5IKbs1Acp6OA5dxxdC8fDKO1XZsRmR1oiDs659Rt6k0j6aDE2vtLJt4koNqzsNSzFQNhNu_WAcePNe9Z09A7Q3-29Z6sd5aXMLeFrFEEvkjWwjVWNLO5ze" align="left">  It is worthwhile to search through the color components in ascending order of the error introduced by them; for this, the node0, node1, node2 fields are sorted by the functions SortNodes10 and SortNodes20. <br><br>  To speed up the sorting itself, sorting networks are used, calculated on the thematic <a href="http://pages.ripco.net/~jgamble/nw.html">site</a> . <br><br>  Before performing the sorting, it makes sense to discard large errors that exceed the solution found.  At the same time, the number of elements in the node0, node1, node2 fields significantly decreases, which significantly speeds up the sorting and further search. <br><br><img src="https://lh6.googleusercontent.com/gDVLUkDR5XTM8OkYfo5IKbs1Acp6OA5dxxdC8fDKO1XZsRmR1oiDs659Rt6k0j6aDE2vtLJt4koNqzsNSzFQNhNu_WAcePNe9Z09A7Q3-29Z6sd5aXMLeFrFEEvkjWwjVWNLO5ze" align="left">  You can try to cut off the third nested loop by color components G, R, B by finding the best solution for the current G, R with the ComputeErrorGR function, which is 2 times faster than the ComputeErrorGRB function.  This, by the way, is a hot spot in the profiler. <br><br><img src="https://lh6.googleusercontent.com/gDVLUkDR5XTM8OkYfo5IKbs1Acp6OA5dxxdC8fDKO1XZsRmR1oiDs659Rt6k0j6aDE2vtLJt4koNqzsNSzFQNhNu_WAcePNe9Z09A7Q3-29Z6sd5aXMLeFrFEEvkjWwjVWNLO5ze" align="left">  In the dependent base color mode, good acceleration gives the search for the best solution for each half, because the error found often exceeds the optimistic forecast for the color components and at the same time is a cut-off criterion. <br><br>  Walk and Bottom are doing this. <br><br><img src="https://lh6.googleusercontent.com/gDVLUkDR5XTM8OkYfo5IKbs1Acp6OA5dxxdC8fDKO1XZsRmR1oiDs659Rt6k0j6aDE2vtLJt4koNqzsNSzFQNhNu_WAcePNe9Z09A7Q3-29Z6sd5aXMLeFrFEEvkjWwjVWNLO5ze" align="left">  The 64 calls of the AdjustColors53 function can result in repeated calls of the ComputeErrorGR and ComputeErrorGRB functions with the same basic color parameters, so we will cache the results of the calls.  In turn, to quickly initialize the cache, you can use lazy calculations on the third color component. <br><br>  In the AdjustStateColor structure, the ErrorsG, ErrorsGR fields and the ErrorsGRB field, which are cleared by LazyGR, provide significant performance gains. <br><br><img src="https://lh6.googleusercontent.com/gDVLUkDR5XTM8OkYfo5IKbs1Acp6OA5dxxdC8fDKO1XZsRmR1oiDs659Rt6k0j6aDE2vtLJt4koNqzsNSzFQNhNu_WAcePNe9Z09A7Q3-29Z6sd5aXMLeFrFEEvkjWwjVWNLO5ze" align="left">  After various algorithmic improvements, it is time to use SIMD, in this case the solution was published on the integer SSE4.1.  Data of one pixel is stored as int32x4_t. <br><br>  The _mm_adds_epu8 and _mm_subs_epu8 commands are convenient for calculating a four-color palette from the base color and deviations. <br><br>  In the functions ComputeErrorGRB and ComputeErrorGR, partially deployed cycles, optimized by the _mm_madd_epi16 command, are used first, since in most cases its capacity is sufficient.  In the case of large errors, the second cycle works on the ‚Äúslow‚Äù _mm_mullo_epi32 commands. <br><br>  The ComputeLevel function calculates an error for four basic color values ‚Äã‚Äãat once. <br><br><img src="https://lh6.googleusercontent.com/gDVLUkDR5XTM8OkYfo5IKbs1Acp6OA5dxxdC8fDKO1XZsRmR1oiDs659Rt6k0j6aDE2vtLJt4koNqzsNSzFQNhNu_WAcePNe9Z09A7Q3-29Z6sd5aXMLeFrFEEvkjWwjVWNLO5ze" align="left">  To compress one channel A, you can simplify the resulting RGB compression code.  There will be noticeably fewer nested loops and better performance. <br><br><h2>  Results achieved </h2><br>  The described approaches allow to reduce the requirements for RAM in Android versions of games due to the use of compressed textures in the ETC1 hardware format. <br><br>  In the scripts for the formation of atlases and the compression utility itself, attention is paid to the issues of preventing artifacts and improving the quality of compressed graphics. <br><br>  Surprisingly, together with the improved quality of compressed graphics, we managed to accelerate compression itself!  In our <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.playrix.gardenscapes">Gardenscapes</a> project <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.playrix.gardenscapes">, the</a> compression of atlases to the ETC1 format on an Intel Core i7 6700 processor takes 24 seconds.  This is faster than the generation of atlases themselves and several times faster than the previous compression utility in fast mode.  The proposed incremental compression occurs in 19 seconds. <br><br>  In conclusion, I will give an example of compressing the <a href="">8192x8192 RGB</a> texture presented by the <a href="https://github.com/Playrix/playrix-public">EtcCompress</a> utility under Win64 on an Intel Core i7 6700 processor: <br><br><pre> <code class="hljs pgsql">x:\&gt;EtcCompress <span class="hljs-keyword"><span class="hljs-keyword">Usage</span></span>: EtcCompress [/retina] src [dst_color] [dst_alpha] [/<span class="hljs-keyword"><span class="hljs-keyword">debug</span></span> result.png] x:\&gt;EtcCompress <span class="hljs-number"><span class="hljs-number">8192.</span></span>png <span class="hljs-number"><span class="hljs-number">1.</span></span>etc /<span class="hljs-keyword"><span class="hljs-keyword">debug</span></span> <span class="hljs-number"><span class="hljs-number">1.</span></span>png Loaded <span class="hljs-number"><span class="hljs-number">8192.</span></span>png Image <span class="hljs-number"><span class="hljs-number">8192</span></span>x8192, Texture <span class="hljs-number"><span class="hljs-number">8192</span></span>x8192 Compressed <span class="hljs-number"><span class="hljs-number">4194304</span></span> blocks, elapsed <span class="hljs-number"><span class="hljs-number">10988</span></span> ms, <span class="hljs-number"><span class="hljs-number">381716</span></span> bps Saved <span class="hljs-number"><span class="hljs-number">1.</span></span>etc Texture RGB wPSNR = <span class="hljs-number"><span class="hljs-number">42.796053</span></span>, wSSIM_4x2 = <span class="hljs-number"><span class="hljs-number">0.97524678</span></span> Saved <span class="hljs-number"><span class="hljs-number">1.</span></span>png x:\&gt;EtcCompress <span class="hljs-number"><span class="hljs-number">8192.</span></span>png <span class="hljs-number"><span class="hljs-number">1.</span></span>etc /<span class="hljs-keyword"><span class="hljs-keyword">debug</span></span> <span class="hljs-number"><span class="hljs-number">2.</span></span>png Loaded <span class="hljs-number"><span class="hljs-number">8192.</span></span>png Image <span class="hljs-number"><span class="hljs-number">8192</span></span>x8192, Texture <span class="hljs-number"><span class="hljs-number">8192</span></span>x8192 Loaded <span class="hljs-number"><span class="hljs-number">1.</span></span>etc Compressed <span class="hljs-number"><span class="hljs-number">4194304</span></span> blocks, elapsed <span class="hljs-number"><span class="hljs-number">6487</span></span> ms, <span class="hljs-number"><span class="hljs-number">646570</span></span> bps Saved <span class="hljs-number"><span class="hljs-number">1.</span></span>etc Texture RGB wPSNR = <span class="hljs-number"><span class="hljs-number">42.796053</span></span>, wSSIM_4x2 = <span class="hljs-number"><span class="hljs-number">0.97524678</span></span> Saved <span class="hljs-number"><span class="hljs-number">2.</span></span>png x:\&gt;fc /b <span class="hljs-number"><span class="hljs-number">1.</span></span>png <span class="hljs-number"><span class="hljs-number">2.</span></span>png   <span class="hljs-number"><span class="hljs-number">1.</span></span>png  <span class="hljs-number"><span class="hljs-number">2.</span></span>png FC:   </code> </pre> <br>  We hope that the utility will help to quickly and efficiently compress mobile graphics. </div><p>Source: <a href="https://habr.com/ru/post/310484/">https://habr.com/ru/post/310484/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../310472/index.html">You do not have enough speed R? We are looking for hidden reserves</a></li>
<li><a href="../310474/index.html">16 myths about CRM-systems</a></li>
<li><a href="../310478/index.html">Stable version of Android Studio 2.2 released</a></li>
<li><a href="../310480/index.html">Why does the network of mobile operators sometimes ‚Äúfall‚Äù?</a></li>
<li><a href="../310482/index.html">Another type of XSS attack on the site</a></li>
<li><a href="../310486/index.html">We make a startup simply and technologically. Eddystone Beacon</a></li>
<li><a href="../310488/index.html">Do Tango robots dance</a></li>
<li><a href="../310490/index.html">Using SuiteCRM EntryPoints</a></li>
<li><a href="../310492/index.html">Vladislav Kochetkov, President of FINAM Holding: ‚ÄúWe are better able to teach than aggressively sell‚Äù</a></li>
<li><a href="../310494/index.html">CIKM Cup 2016 - an international competition in the field of Data Science</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>