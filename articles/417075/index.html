<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CSS Paint API</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="According to the author of the material, the translation of which we publish today, CSS Paint API is an incredibly interesting technology. Moreover, w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>CSS Paint API</h1><div class="post__text post__text-html js-mediator-article">  According to the author of the material, the translation of which we publish today, <a href="https://drafts.css-houdini.org/css-paint-api-1/">CSS Paint API</a> is an incredibly interesting technology.  Moreover, we are talking not only about its current capabilities, but also about the phenomena it represents, and that its appearance marks the beginning of quite remarkable changes in the world of CSS.  Here we will talk about the CSS Paint API and the reasons for its appearance, tell you how to use it. <br><br> <a href="https://habr.com/company/ruvds/blog/417075/"><img src="https://habrastorage.org/webt/6c/1q/yu/6c1qyuo29pmcjmojwwou8qb034g.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">What is the CSS Paint API?</font> </h2><br>  The API in question is just a small part of the new set of specifications that are being worked on as part of the CSS Houdini project.  If you briefly describe this project, then its essence boils down to the fact that it gives developers low-level access to the internal mechanisms of CSS. <br><br>  The API Paint API allows you to call the <code>paint()</code> function in situations where, under normal conditions, work would be carried out, for example, with a certain value describing an image.  A typical example of this is the <code>background-image</code> property, when working with which you can use the <code>url()</code> function to send a link to the image file to the system: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">area</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background-image</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">url</span></span>(<span class="hljs-string"><span class="hljs-string">'assets/myimage.jpg'</span></span>); }</code> </pre> <br>  The API Paint API allows you to call, instead of a similar function, the <code>paint()</code> function, and pass it a so-called worklet, described by JavaScript.  A worklet can be perceived as a kind of code fragment that allows the developer to programmatically draw almost anything he wants.  And, since we are talking about JavaScript, the image can be made dynamic.  By itself, this API is very similar to the HTML5 Canvas API and now we‚Äôll talk about how it all works. <br><br><h2>  <font color="#3AC1EF">CSS Paint API Features</font> </h2><br>  If you now have the feeling that all this sounds good, but it looks difficult, and you think that you are quite comfortable with using ordinary images, keep in mind that regular images do not lose their relevance with the advent of the new technology.  To use them, just as it was always done, is perfectly normal.  The fact that something new, and probably promising, is on the horizon does not mean that everyone should immediately use this new to solve all existing problems.  However, ordinary images are static.  The new API attracts the idea of ‚Äã‚Äãcreating dynamic images. <br><br>  Consider the <a href="https://css-tricks.com/snippets/css/css-linear-gradient/">linear-gradient</a> CSS function.  Stuck is very powerful.  Take a look, for example, on <a href="https://css-tricks.com/drawing-images-with-css-gradients/">this</a> .  But can you imagine how much easier it would be to achieve the same effect created by the overlay of layers, if you would not have to use a lot of background images?  However, it's not just that.  If you delve into the CSS Paint API, you can figure out how these images are created during program execution, which can be very useful (actually, we plan to do this here). <br><br>  What about the <a href="https://css-tricks.com/snippets/css/css-conic-gradient/">conic-gradient</a> CSS function?  It can be said, is not yet supported by browsers without a polyfill.  Using the new API allows you to create conical gradients, adjust their parameters, which are not particularly different from what is in the specification.  All this means that in practice, using the new API, you can create your own native polyfills.  And this is just wonderful. <br><br>  Do not forget that all this is part of a larger group of possibilities, known as CSS Houdini.  <a href="https://github.com/w3c/css-houdini-drafts/wiki">This is</a> what is written in the project documentation: ‚ÄúThe goal of CSS-TAG Houdini Task Force (CSS Houdini) is to jointly develop mechanisms that break the veils of mystery from technologies of styling web pages and building their layouts.‚Äù <br><br>  Sounds good, right?  And, in fact, these new mechanisms are aimed at allowing developers to extend the functionality of CSS itself, giving them more advanced style management tools, cross-browser support and the ability to create polyfills. <br><br>  The process of standardization of new technologies may take some time.  First, a new CSS feature is offered.  Further - the specification is written, there are other processes.  As a result, browser manufacturers implement new specifications.  And, since developers often cannot wait to begin using new features as soon as possible, they have to take into account the fact that older browsers may not support innovations, and that if a certain specification is not yet fully implemented, it may, in the course of its development, seriously change.  Perhaps nothing to talk about the typical nuances of the implementation of different technologies in different browsers.  The Houdini project can go quite far in mitigating these problems, allowing us to develop browser-based functionality on our own, use it and quietly wait for the implementation of certain capabilities by browser manufacturers to appear.  Here are a couple of materials on this topic.  <a href="https://www.smashingmagazine.com/2016/03/houdini-maybe-the-most-exciting-development-in-css-youve-never-heard-of/">The first is</a> dedicated to the strengths of Houdini, and the <a href="https://css-tricks.com/what-houdini-means-for-animating-transforms/">second</a> - to use the capabilities of this project to create complex animation. <br><br><h2>  <font color="#3AC1EF">API support for Paint Paint browsers</font> </h2><br>  Can I use the CSS Paint API today?  We can give a positive answer to this question, although it should be noted that far from all browsers support this technology.  In order to get information about the support of this API, you can use the resource <a href="https://caniuse.com/">caniuse.com</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55a/42a/4ea/55a42a4ea1ccc056652c9a7b463f8097.png"></div><br>  <i><font color="#999999">API support for Paint Paint with various browsers (July 2018)</font></i> <br><br>  As you can see, this API only supports Chrome for now.  But be that as it may, let's talk about how to use it.  We will look at the software constructs needed to make the new API work.  This includes new CSS features and some pretty recent JavaScript mechanisms.  Our example will be divided into three steps. <br><br><h2>  <font color="#3AC1EF">Step # 1: CSS</font> </h2><br>  Recall that the formation of the image when using the API CSS Paint responsible vorklety - fragments of JS-code.  Therefore, we first need to give the name of the workpiece and call it in CSS.  <code>awesomePattern</code> call it <code>awesomePattern</code> .  As a result, the CSS code will look like this: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">section</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background-image</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">url</span></span>(<span class="hljs-string"><span class="hljs-string">'fallback.png'</span></span>); <span class="hljs-attribute"><span class="hljs-attribute">background-image</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">paint</span></span>(awesomePattern); };</code> </pre> <br>  The preliminary preparations have been completed, but until the rest of our example is ready, all this will not work. <br><br><h2>  <font color="#3AC1EF">Step 2: JavaScript</font> </h2><br>  Now we need to describe the workbench using JS.  Here it is shown how, in the main script, loading another script that implements the functionality we need. <br><br><pre> <code class="hljs cs">CSS.paintWorklet.addModule(<span class="hljs-string"><span class="hljs-string">'patternWorklet.js'</span></span>);</code> </pre> <br>  At this stage, again, nothing happens, since the most interesting is hidden in the <code>patternWorklet.js</code> file. <br><br>  In the <code>patternWorklet.js</code> file <code>patternWorklet.js</code> we need to register the worclet class: <br><br><pre> <code class="hljs lisp">registerPaint('awesomePattern', Shape)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Here we call the <code>registerPaint()</code> function and pass to it what we consider to be a worklet, in this case it's <code>awesomePattern</code> .  In addition, we pass this function a reference to the class that we will write, in this case, <code>Shape</code> .  This command must be added after the declaration of the corresponding class.  When declaring and using classes, you cannot rely on something like a mechanism for lifting function declarations.  Before you can use a class, you must declare it. <br><br>  Next, we are going to use the ECMAScript 2015 class declaration syntax and write a class that will draw the background image.  Since now this class is registered as a class of the vorklet, we can use in it some special mechanisms that will be available in it automatically. <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> { paint(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">geom</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">properties</span></span></span><span class="hljs-class">) {   ctx.strokeStyle = 'white';   ctx.lineWidth = 4;   ctx.beginPath();   ctx.arc( 200, 200, 50, 0, 2*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Math</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PI</span></span></span><span class="hljs-class">);   ctx.stroke();   ctx.closePath(); } }</span></span></code> </pre> <br>  The <code>paint()</code> callback has <code>ctx</code> , <code>geom</code> and <code>properties</code> options.  The <code>ctx</code> parameter is the same as the 2D rendering context that can be obtained from the <code>&lt;canvas&gt;</code> .  Well, it's almost the same.  The fact is that the <code>&lt;canvas&gt;</code> allows you to read pixel data, but the CSS Paint API does not allow this.  Despite the differences, using <code>ctx</code> , we can use the same methods for displaying graphic objects that are used when working with the <code>&lt;canvas&gt;</code> .  In this example, using the <code>arc()</code> function, we draw a circle. <br><br>  The first two values ‚Äã‚Äãpassed to the <code>arc()</code> function are the X and Y coordinates of the center of the circle, in pixels, relative to the origin of coordinates, located in the upper left corner of the element.  However, I want the circle to be in the center of the element.  To solve this problem, we need the <code>geom</code> parameter.  It gives access to the <code>PaintSize</code> object, which is a description of the image parameters.  In particular, referring to it, we can read the parameters of <code>width</code> and <code>height</code> , and this is exactly what we need in order to center the circle. <br><br>  As a result, we come to this code: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> { paint(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">geom</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">properties</span></span></span><span class="hljs-class">) {     let x = geom.width/2;   let y = geom.height/2;   ctx.strokeStyle = 'white';   ctx.lineWidth = 4;   ctx.beginPath();   ctx.arc(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">, 50, 0, 2*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Math</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PI</span></span></span><span class="hljs-class">);   ctx.stroke();   ctx.closePath();   } } registerPaint('</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">awesomePattern'</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class">);</span></span></code> </pre> <br>  You can see the working version of the example on <a href="https://codepen.io/Rumyra/pen/JLLoZo">CodePen</a> .  As a matter of fact, this is what this code displays. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f2/18e/992/0f218e9927aa75625eb0ae0ae0ec8e4e.png"></div><br>  <i><font color="#999999">Circle created by CSS Paint API</font></i> <br><br>  All this is good, but our example is very simple.  Let's, instead of the usual circle, draw something more interesting.  For example - such an asterisk - the logo of the site css-tricks.com. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/26e/5a7/a1f26e5a7d56b1d3d98717c890deabbf.png"></div><br>  <i><font color="#999999">Asterisk created by CSS Paint API</font></i> <br><br>  <a href="https://codepen.io/Rumyra/pen/090169fb8eda59ca5c2da2838d3f7928">Here is a</a> project on CodePen that allows you to do this. <br><br>  When you look at the JS code of this project, pay attention to the <code>drawStar()</code> method and to the many functions that are used when working with the <code>&lt;canvas&gt;</code> . <br><br><h2>  <font color="#3AC1EF">Step 3: Custom CSS Properties</font> </h2><br>  Using new technology, we can go far beyond drawing circles and stars.  We can turn to the powerful capabilities of <a href="https://css-tricks.com/now-css-custom-properties-thing-value-parts-can-changed-individually/">custom CSS properties</a> (variables).  They, by the way, even in themselves, are very interesting.  In our case, they are especially useful. <br><br>  Suppose we want to be able to change the size or color of a previously created logo.  These parameters can be placed in the CSS code in the form of user properties, after which they can be used in the program through the third parameter passed to the <code>paint()</code> callback.  We are talking about the <code>properties</code> parameter. <br><br>  Add the <code>--star-scale</code> property to our CSS code, which is aimed at controlling the image resizing, and the <code>--star-color</code> property, which is designed to organize the change of the logo color directly in CSS.  Here's what we got: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">section</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">--star-scale</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">--star-color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">hsla</span></span>(200, 50%, 50%, 1); <span class="hljs-attribute"><span class="hljs-attribute">background-image</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">paint</span></span>(awesomePattern) };</code> </pre> <br>  Now back to the vorklet class.  Here we need to interact with the above user properties.  This is done using the <code>inputProperties</code> method, which gives us access to all CSS properties and the values ‚Äã‚Äãassigned to them. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">get</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inputProperties</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'--star-scale'</span></span>,<span class="hljs-string"><span class="hljs-string">'--star-color'</span></span>]; }</code> </pre> <br>  Now you can work with them in the <code>paint()</code> method: <br><br><pre> <code class="hljs lisp">const size = parseInt(<span class="hljs-name"><span class="hljs-name">properties</span></span>.get('--shape-size').toString())<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Naturally, the obtained values ‚Äã‚Äãcan be used in the code responsible for the formation of the image.  This leads to the fact that if we, in the CSS code, change the value of the <code>--star-scale</code> <code>--start-color</code> or <code>--start-color</code> , it will immediately reflect on how the image will look. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d2/7a0/676/7d27a06764d4888bcb66dc2a6d8d17b3.gif" alt="image"></div><br>  <i><font color="#999999">The effect of custom CSS properties on the final image</font></i> <br><br>  This functionality is implemented in <a href="https://codepen.io/Rumyra/pen/090169fb8eda59ca5c2da2838d3f7928">the same</a> project on CodePen, which we mentioned above. <br><br>  By the way, it is worth noting that when using the new API, all the usual CSS properties regarding the background settings of elements, such as <code>background-size</code> and <code>background-repeat</code> , will work the same as before.  They have not lost relevance. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  The CSS Paint API is a very powerful technology whose capabilities are not limited to creating background images. <br><br>  Imagine that an element should have a special border, for example, one that is not fully visible, or double.  Perhaps, to achieve similar effects, you usually use the <code>::before</code> pseudo-elements of <code>::before</code> or <code>::after</code> , and maybe the specially configured <code>box-shadow</code> .  Borders (and much more) can be implemented using CSS Paint API and <code>border-image</code> properties. <br><br>  The CSS Paint API brings together many great mechanisms, such as wormlets, ECMAScript 2015 classes, and the capabilities of the <code>&lt;canvas&gt;</code> .  In addition, it provides the developer with tools for image management software, based on JavaScript.  For example, using the event mechanism, you can organize the updating of user properties, which means the image itself, as, for example, done <a href="https://github.com/GoogleChromeLabs/houdini-samples/tree/master/paint-worklet/ripple">here</a> , where the <code>click</code> event starts the property update process in the <code>requestAnimationFrame</code> function, which allows you to create an animation every time the user clicks a button.  Moreover, even the coordinates of the mouse pointer are taken into account when clicked. <br><br>  At first glance, all this may seem a bit confusing, but let's take a look at some other parts of the Houdini project that we can meet with: <br><br><ul><li>  <a href="https://drafts.css-houdini.org/css-layout-api-1/">The CSS Layout API</a> allows a developer to do something like <code>display: layout('myCustomLayout')</code> .  A typical example is the creation of custom layouts in the style of the Masonry library, but the range of use of this feature is much wider. </li><li>  <a href="https://drafts.css-houdini.org/css-properties-values-api-1/">The CSS Properties and Values ‚Äã‚ÄãAPI</a> allows you to set custom property types. </li><li>  <a href="https://wicg.github.io/animation-worklet/">The CSS Animation Worklet API</a> takes animation processing operations out of the main thread, which should be expressed as perfectly smooth animations. </li></ul><br>  As a result, we can say that, literally before our eyes, technologies are emerging that open up many new opportunities for web developers.  The processes of their standardization and implementation in browsers are not so fast, but they, quite possibly, will have a tremendous impact on everything related to the styling of web pages. <br><br>  <b>Dear readers!</b>  Which areas of the CSS Paint API do you find most interesting? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/webt/cp/zf/te/cpzfteyh2kzlthzniyap-5t1h6c.jpeg"></a> </div><p>Source: <a href="https://habr.com/ru/post/417075/">https://habr.com/ru/post/417075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417063/index.html">Neural networks for the smallest</a></li>
<li><a href="../417065/index.html">Splunk How-to, or How and Where to Learn Splunk</a></li>
<li><a href="../417069/index.html">Once again about OpenSSL</a></li>
<li><a href="../417071/index.html">Friday's PHP: Free Skillbox Webinars</a></li>
<li><a href="../417073/index.html">A day in the life of a mobile developer Uber</a></li>
<li><a href="../417079/index.html">Package Manager for Kubernetes - Helm: Past, Present, Future</a></li>
<li><a href="../417081/index.html">North, will, hope, a country without borders (c), or How projects are made in the harsh Siberian conditions</a></li>
<li><a href="../417083/index.html">High loads of the World Cup 2018</a></li>
<li><a href="../417085/index.html">Browsers turn off the sound in your WebRTC application. Stop what?</a></li>
<li><a href="../417087/index.html">HPE Digitize 2018: event and live streaming</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>