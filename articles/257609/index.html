<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to translate an entire site to permanent HTTPS for all</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Encrypt everything 
 The era of unencrypted web is passing, and that is good. In this manual, we assume that your server is running a Nginx web server...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to translate an entire site to permanent HTTPS for all</h1><div class="post__text post__text-html js-mediator-article"><h4>  Encrypt everything </h4><br>  The era of unencrypted web is passing, and that is good.  In this manual, we assume that your server is running a Nginx web server.  And now we will make sure that all site visitors use only the HTTPS protocol.  In addition, we will enable HSTS - this is ‚ÄúHTTP Strict Transport Security‚Äù, when the site not only supports HTTPS, but also insists on using it. <br><br>  There are many ways to do this, but I will describe a method called ‚ÄúHTTPS termination‚Äù.  In other words, we will put a reverse proxy in front of the web server, which will provide HTTPS.  This is easier and more flexible than configuring HTTPS using only the capabilities of a web server.  You may find it counterintuitive that adding one more application to the stack will simplify your life - but this is true. <br><br>  Specify that this recipe is suitable for servers based on Linux, on which Nginx is installed. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What will work before all the other applications in the stack is HAProxy.  This is primarily a balancing application - it can distribute incoming requests between different physical servers.  Many high-load sites use it in this capacity (the same reddit), but in the latest version it has the ability to perform SSL termination.  He is able to establish HTTPS connections on behalf of the server. <br><br>  Therefore, we set HAProxy, feed it our SSL / TLS certificates, instruct us to redirect all HTTP requests to HTTPS, and show it to the web server itself as a backend. <br><a name="habracut"></a><br><h4>  Install HAProxy </h4><br>  Ports 80 and 443 will look to the Internet and receive HTTP and HTTPS traffic.  All HTTP requests will receive a 301 redirect to the same URL, but via HTTPS, and then redirected to the backend web server (nginx) via pure HTTP. <br><br>  The HAProxy package included in the Ubuntu 14.04 LTS package is quite old, so we will add a repository: <br><br><pre><code class="bash hljs">sudo add-apt-repository ppa:vbernat/haproxy-1.5</code> </pre> <br><br>  Then update the sources and install the application: <br><br><pre> <code class="bash hljs">sudo aptitude update sudo aptitude install haproxy</code> </pre><br><br>  The basic settings are in /etc/haproxy/haproxy.cfg.  Here are my settings: <br><br><pre> <code class="bash hljs">global <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> /dev/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> local0 <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> /dev/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> local1 notice chroot /var/lib/haproxy stats socket /run/haproxy/admin.sock mode 660 level admin stats timeout 30s user haproxy group haproxy daemon <span class="hljs-comment"><span class="hljs-comment"># Default SSL material locations ca-base /etc/ssl/certs crt-base /etc/ssl/private ssl-default-bind-ciphers EECDH+ECDSA+AESGCM:EECDH+aRSA+AESGCM:EECDH+ECDSA+SHA384:EECDH+ECDSA+SHA256:EECDH+aRSA+SHA384:EECDH+aRSA+SHA256:EECDH+aRSA+RC4:EECDH:EDH+aRSA:!aNULL:!eNULL:!LOW:!3DES:!MD5:!EXP:!PSK:!SRP:!DSS:!RC4 ssl-default-bind-options no-sslv3 no-tlsv10 tune.ssl.default-dh-param 4096 defaults log global mode http option httplog option dontlognull option forwardfor option http-server-close timeout connect 5000 timeout client 50000 timeout server 50000 errorfile 400 /etc/haproxy/errors/400.http errorfile 403 /etc/haproxy/errors/403.http errorfile 408 /etc/haproxy/errors/408.http errorfile 500 /etc/haproxy/errors/500.http errorfile 502 /etc/haproxy/errors/502.http errorfile 503 /etc/haproxy/errors/503.http errorfile 504 /etc/haproxy/errors/504.http frontend yourservername bind *:80 bind *:443 ssl crt /etc/ssl/private/cert1.pem crt /etc/ssl/private/cert2.pem acl secure dst_port eq 443 redirect scheme https if !{ ssl_fc } rspadd Strict-Transport-Security:\ max-age=31536000;\ includeSubDomains;\ preload rsprep ^Set-Cookie:\ (.*) Set-Cookie:\ \1;\ Secure if secure default_backend webservername backend webservername http-request set-header X-Forwarded-Port %[dst_port] http-request add-header X-Forwarded-Proto https if { ssl_fc } server webservername 192.168.1.50:80 listen stats *:9999 stats enable stats uri /</span></span></code> </pre><br><br>  By the way, if you need syntax highlighting of the HAProxy config for vim, <a href="http://www.vim.org/scripts/script.php%3Fscript_id%3D1845">you can take it here</a> .  We will analyze the settings in more detail. <br><br><h4>  Global </h4><br>  Leave the first piece intact.  These are logging settings, directory and permissions. <br><br>  The following parts need to be corrected - it indicates where the CA root and SSL / TLS certificates are located.  You may need to change ca-base and crt-base. <br><br>  The string ssl-default-bind-ciphers determines which SSL / TLS codes will be used by HAProxy when connecting to a client.  I use the recommended list from Qualys / SSL Labs.  I also edited the ssl-default-bind-options line and disabled SSLv3 and TLS1.0, since  they are full of holes.  The last line, tune.ssl.default-dh-param, tells the program to use no more than 4096 bits in the Diffie-Hellman parameter when exchanging DHE keys. <br><br><h4>  Defaults </h4><br>  Add a couple of things - forwardfor and http-server-close.  Since we use the application as a proxy, it should tell the server the IP addresses from which the requests come.  Otherwise it will look as if all traffic comes from HAProxy.  Therefore, forwardfor reports that the program works as a reverse proxy, and you need to add an X-Forwarded For header for the server. <br><br>  The http-server-close configuration is needed for speed ‚Äî HAProxy will decide whether to close the connection or reuse it while maintaining more advanced things like WebSockets. <br><br><h4>  Certificates </h4><br>  The first part of the section tells you what traffic HAproxy should handle and where to send it. <br><br>  We bind HAproxy to ports 80 and 443, she listens to HTTP on port 80 and HTTPS on port 443. For HTTP, we feed her two different certificates.  HAproxy uses Server Name Identification (SNI) to match the host of the incoming request with the required SSL / TLS certificate.  I have three sites on the server, they use different group certificates (* .bigdinosaur.org, * .chroniclesofgeorge.com and * .bigsaur.us) and HAProxy correctly selects the one of them. <br><br>  The only thing that needs to be done is to merge the certificate and private key files into one .pem: <br><br><pre> <code class="bash hljs">cat your-decrypted-ssl-key.key your-ssl-cert.crt &gt; your-ssl-cert.pem</code> </pre><br><br>  Make sure that the owner of the file is root: root, and it must have read-only permissions: <br><br><pre> <code class="bash hljs">sudo chown root:root your-ssl-cert.pem chmod 400 your-ssl-cert.pem</code> </pre><br><br><h4>  From HTTP to HTTPS, and HSTS as a bonus </h4><br>  Now we define the ACL, access control list.  In HAProxy, this is a list of things that satisfy a specific criterion: <br><br><pre> <code class="bash hljs">acl secure dst_port eq 443</code> </pre><br><br>  We created an ACL called secure that matches everything that goes to TCP port 443. We will need it soon. <br><br>  The next line is the one where the traffic is redirected from HTTP to HTTPS. <br><br><pre> <code class="bash hljs">redirect scheme https <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !{ ssl_fc }</code> </pre><br><br>  This means that if the incoming request is not HTTPS, then you need to send a redirect 301 to the same resource, but under the HTTPS scheme. <br><br>  This is exactly HTTP Strict Transport Security - all browsers are instructed to use HTTPS: <br><br><pre> <code class="bash hljs">rspadd Strict-Transport-Security:\ max-age=31536000;\ includeSubDomains;\ preload</code> </pre><br><br>  The setting adds the desired line to the headers.  The browser recognizing this header understands that the site prefers to work on HTTPS, and this indication is valid for a year (31,536,000 seconds).  The preload directive tells Googlebot that your site can be added to their list of sites that support HSTS. <br><br>  HSTS is the right thing.  Encryption should always be, and administrators should strive to distribute it everywhere. <br><br>  By the way, it is necessary to take into account that all cookies also include the secure attribute, since from the point of view of your web server, everything happens over the usual HTTP protocol.  To do this, use the directive rsprep: <br>  one <br><br><pre> <code class="bash hljs">rsprep ^Set-Cookie:\ (.*) Set-Cookie:\ \1;\ Secure <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> secure</code> </pre><br><br>  Pay attention to "if secure".  This means that only cookies that go over HTTPS are changed (secure is a variable that we defined several lines back).  In general, everything should work through HTTPS, so this is not necessary in principle - but you can also make secure. <br><br>  The last line determines where to send traffic.  This is default_backend.  Here you can define multiple servers for load sharing, etc.  But since we have one backend server, everything is pretty simple. <br><br><h4>  back end </h4><br>  Since we have one backend server, this section is short.  HAProxy only needs to add a couple of headers so that the server understands that real communication takes place via HTTPS, even if it sees only HTTP: <br><br><pre> <code class="bash hljs">http-request <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-header X-Forwarded-Port %[dst_port] http-request add-header X-Forwarded-Proto https <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> { ssl_fc }</code> </pre><br><br>  The first directive sets a header explaining that the client initially came on port 443. The second reinforces the first one by setting X-Forwarded-Proto to HTTPS if the request went through HTTPS, so that the web server understands what is happening and does not create the wrong answers. <br><br>  Then we explain HAProxy, where to send requests - the name, IP and port of the web server.  My web server was working on a separate machine, so I write another IP here and port 80.  If everything works on one computer, write localhost and port. <br><br><h4>  Statistics, if needed </h4><br>  The last section dictates HAProxy to issue a status page for a given port.  Here you can add basic auth by adding stats auth username: password, or define a different URL. <br><br>  If you use the HSTS ‚Äúincludesubdomains‚Äù directive, you may not be able to query the status page by name, as the web browser will try to download its HTTPS version, and HAProxy will only give you the HTTP version.  This can be bypassed by requesting a page by IP along with a port (http: //192.168.xx: 9999). <br><br><h4>  We clean </h4><br>  Save the settings, but do not restart the HAProxy service yet.  If everything works for you on the same machine, and nginx also listens to events on ports 80 and 443, you need to tweak something. <br><br>  Since nginx will no longer give out HTTPS requests, you need to remove all HTTPS references from all virtual host files. <br><br>  That's all.  You only need to add two lines to the main nginx.conf file to make sure that nginx will replace the ip-addresses according to the X-Forwarded-For header if the requests come from 127.0.0.1: <br><br><pre> <code class="bash hljs">set_real_ip_from 127.0.0.1; real_ip_header X-Forwarded-For;</code> </pre><br><br>  This will work if you compiled nginx with the ngx_http_realip_mod option. <br><br>  Restart HAProxy (service haproxy restart) and she will start listening to requests. <br><br><h4>  Operation check </h4><br>  Make a request to the site via http.  If the URL changes to https and you see the site - everything works.  You can verify that the HSTS header is sent correctly: <br><br><pre> <code class="bash hljs">curl -s -D- https://yoursite.whatever/ | grep Strict</code> </pre></div><p>Source: <a href="https://habr.com/ru/post/257609/">https://habr.com/ru/post/257609/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../257591/index.html">We rule bug without source codes</a></li>
<li><a href="../257593/index.html">ExpvarMon - console monitoring of services on Go</a></li>
<li><a href="../257603/index.html">Dizdok, or writing project documentation</a></li>
<li><a href="../257605/index.html">EMCSSL - WWW user identification system based on the NVS cryptocurrency subsystem EmerCoin and decentralized client SSL certificates</a></li>
<li><a href="../257607/index.html">Layered menu for Arduino and not only</a></li>
<li><a href="../257611/index.html">Unknown Smalltalk</a></li>
<li><a href="../257613/index.html">Test data for HL7 messages</a></li>
<li><a href="../257615/index.html">The best reports. NEXT 2014 Moscow (video inside). Part 1: Places 6 to 10</a></li>
<li><a href="../257617/index.html">Three features of JavaScript, which is useful to know every Java / C developer</a></li>
<li><a href="../257619/index.html">We write bot for browser game agar.io</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>