<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Quick removal of spaces from lines on ARM processors</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Suppose I gave you a relatively long string, and you want to remove all spaces from it. In ASCII, we can define spaces as a space character ('') and l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Quick removal of spaces from lines on ARM processors</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/ad3/88a/854/ad388a854496683ed3c076b107ecf56d.jpg" align="left">  Suppose I gave you a relatively long string, and you want to remove all spaces from it.  In ASCII, we can define spaces as a space character ('') and line terminations ('\ r' and '\ n').  I am most interested in the issues of algorithm and performance, so that we can simplify the task and delete all bytes with values ‚Äã‚Äãless than or equal to 32. <br><br>  In the <a href="http://lemire.me/blog/2017/01/20/how-quickly-can-you-remove-spaces-from-a-string/">previous article</a> , where I asked a question about removing spaces for speed, the best answer was to use vectorization using 128-bit registers (SSE4).  It turned out to be 5-10 times faster than approaching the forehead. <br><br>  It is very convenient that all processors have 128-bit vector registers, as well as x64 processors.  Are ARM processors as fast as x64 processors? <br><a name="habracut"></a><br>  Let's first consider a fast scalar implementation: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs swift">size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>, pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; howmany) { char <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = bytes[i++]; bytes[pos] = <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>; pos += (<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> &gt; <span class="hljs-number"><span class="hljs-number">32</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  It removes all characters with values ‚Äã‚Äãless than or equal to 32 and writes the data back.  It works very quickly. <br><br>  Is it possible to achieve even greater speed with vector instructions? <br><br>  On x64 processors, the best strategy is to capture 16 bytes of data, quickly compare for empty characters, then extract the mask value (or bitset) created from 16 bits, one bit per character, where each bit corresponds to the value, found a blank character or not.  Such a set is quickly calculated on the x64 processor, since there is a special instruction ( <code>movemask</code> ).  There is no such instruction on ARM processors.  You can emulate <code>movemask</code> with a few instructions. <br><br>  So, we cannot process data on ARM as on x86 processors.  What can be done? <br><br>  As SS4 does, we can quickly verify that the byte values ‚Äã‚Äãare less than or equal to 32, and so define empty characters: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint8x16_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_white</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8x16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8x16_t</span></span> wchar = vdupq_n_u8(<span class="hljs-string"><span class="hljs-string">' '</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint8x16_t</span></span> isw = vcleq_u8(data, wchar); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isw; }</code> </pre> <br>  Now we can quickly check any of the 16 characters, it is empty, using only two instructions: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint64_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_not_zero</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8x16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint64x2_t</span></span> v64 = vreinterpretq_u64_u8(v); <span class="hljs-keyword"><span class="hljs-keyword">uint32x2_t</span></span> v32 = vqmovn_u64(v64); <span class="hljs-keyword"><span class="hljs-keyword">uint64x1_t</span></span> result = vreinterpret_u64_u32(v32); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br>  This suggests a useful strategy.  Instead of comparing characters one by one, you can compare all 16 characters at once.  If none of them is empty, then simply copy 16 characters back to the input and move on.  Otherwise, we slide to the slow scalar approach, but with the added advantage that there is no need to repeat the comparison: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">uint8x16_t</span></span> vecbytes = vld1q_u8((<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *)bytes + i); <span class="hljs-keyword"><span class="hljs-keyword">uint8x16_t</span></span> w = is_white(vecbytes); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> haswhite = is_not_zero(w); w0 = vaddq_u8(justone, w); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!haswhite) { vst1q_u8((<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *)bytes + pos,vecbytes); pos += <span class="hljs-number"><span class="hljs-number">16</span></span>; i += <span class="hljs-number"><span class="hljs-number">16</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; k++) { bytes[pos] = bytes[i++]; pos += w[k]; } }</code> </pre> <br>  The advantages of this approach will be most pronounced if you expect a lot of streams of 16 bytes without empty characters.  In principle, this is true for many applications. <br><br>  I wrote a benchmark in which I tried to estimate how much space the removal of spaces would take, one at a time, based on input data with a small number of empty characters scattered randomly.  <a href="https://github.com/lemire/Code-used-on-Daniel-Lemire-s-blog/tree/master/2017/07/03">Source code is available</a> , but you need an ARM processor to run.  I ran it on a <a href="https://softiron.com/products/overdrive-1000/technical-specifications/">64-bit ARM processor (made from A57 cores)</a> .  John Reger has <a href="https://blog.regehr.org/archives/1465">a few more benchmarks on the same machine</a> .  It seems to me that the same cores work in the Nintendo Switch. <br><br><table><tbody><tr><td>  scalar </td><td>  1.40 ns </td></tr><tr><td>  NEON </td><td>  1.04 ns </td></tr></tbody></table><br>  <a href="http://cdn.softiron.com/OD1000_DS_Web_v11.pdf">Technical specifications are not rich</a> .  However, the processor runs at 1.7 GHz, which everyone can see if he starts <code>perf stat</code> .  Here are how many cycles we need the symbol: <br><br><table><tbody><tr><th>  scalar </th><th>  ARM </th><th>  Recent x64 </th></tr><tr><td>  scalar </td><td>  2.4 cycles </td><td>  1,2 cycles </td></tr><tr><td>  vectorized (NEON and SS4) </td><td>  1.8 cycle </td><td>  0.25 cycle </td></tr></tbody></table><br>  If we compare, on the x64 processor, the scalar version uses something like 1.2 cycles per character, and ARM is about twice as good as cycles per character.  This was quite expected, because the A57 cores are unlikely to compete with x64 in cycle performance.  However, using SS4 on an x64 machine, I managed to achieve a performance of just 0.25 cycles per character, which is more than five times faster than on ARM NEON. <br><br>  Such a big difference is due to the difference in algorithms.  On x64 processors, we use a combination of <code>movemask/pshufb</code> and a <code>movemask/pshufb</code> algorithm with a very small number of instructions.  The ARM NEON version is much weaker. <br><br>  There are many nice things on ARM processors.  The assembler code is much more elegant than the similar code for x86 / x64 processors.  Even the ARM NEON instructions seem cleaner than the SSE / AVX instructions.  However, for many tasks, the complete lack of a <code>movemask</code> instruction may limit your work. <br><br>  But maybe I underestimate the ARM NEON ... can you accomplish the task more effectively than I did? <br><br>  Note.  The article was edited: as noted by one of the commentators, on 64-bit ARM processors there is the possibility of permuting 16 bits with one instruction. </div><p>Source: <a href="https://habr.com/ru/post/332710/">https://habr.com/ru/post/332710/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332698/index.html">The digest of interesting materials for the mobile developer # 211 (July 03 - July 09)</a></li>
<li><a href="../332700/index.html">Quotes program data collection</a></li>
<li><a href="../332704/index.html">Announcement Heisenbag 2017 Moscow: Double the Benefit</a></li>
<li><a href="../332706/index.html">Translation of the Appium Essentials book. Chapter 4</a></li>
<li><a href="../332708/index.html">How does JVM allocate objects?</a></li>
<li><a href="../332712/index.html">GitLab CI for continuous integration and delivery in production. Part 1: our pipeline</a></li>
<li><a href="../332714/index.html">Cipher Hila. Detailed analysis</a></li>
<li><a href="../332718/index.html">Android Architecture Components. Part 2. Lifecycle</a></li>
<li><a href="../332722/index.html">PLC from manufacturers Aries, Segnetics and Schneider Electric for HVAC</a></li>
<li><a href="../332724/index.html">Cost of quality in software development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>