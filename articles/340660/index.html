<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pixel adventure: create a clone of Lemmings in Unity</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 I think I'm not the only one playing Amiga at Lemmings as a child. Decades passed, and I became, among other things, a game developer, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pixel adventure: create a clone of Lemmings in Unity</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/ec/54/59ec54d46beed743585302.png"></div><br><h1>  Introduction </h1><br>  I think I'm not the only one playing Amiga at Lemmings as a child.  Decades passed, and I became, among other things, a game developer, leading a Youtube channel <a href="http://sharpaccent.com/channel">with tutorials on Unity</a> . <br><br>  One evening I stumbled upon these two videos ( <a href="https://www.youtube.com/watch%3Fv%3Dazrd0sA8MCw">part 1</a> , <a href="https://www.youtube.com/watch%3Fv%3DHJ0uYDJWCD8">part 2</a> ) of <a href="https://twitter.com/mdf200%3Flang%3Den">Mike Dally</a> about re-creating Lemmings using Game Maker 2. Nostalgia flared up and I decided to do something with it.  So I started creating my own version in Unity using my own resources (for obvious reasons). <br><br>  In the article I will talk about my work process.  However, to be brief, I will consider only the most important aspects.  If it seems to you that this is not enough, you can watch the <a href="https://sharpaccent.com/%3Fc%3Dcourse%26id%3D19">video here</a> , describing the full development process, line by line. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In addition, <a href="https://sharpaccent.com/%3Fc%3Dmain%26a%3Dplay%26cid%3D19">here</a> you can play the project on WebGL.  Possible bugs. <br><br>  The complexity of the project was to recreate the sensations and mechanics of Lemmings.  Including the provision of pixel-perfect-collisions when moving through the level of many characters that can vary depending on their skills. <br><a name="habracut"></a><br><h1>  Creating a map </h1><br>  From the very beginning it was obvious that the level should be a grid that can be edited.  The problem was to render this grid with each individual node, while maintaining a high game speed. <br><br>  Gradually, I came to the decision to use a single texture for the whole level, in which each pixel would be one node, and changes to the nodes would be a change in the texture itself. <br><br>  To do this, we need to know that when texture changes from a disk, Unity changes the texture itself, not its copy.  Therefore, we need to manually create this instance.  This is very simply done with the following code: <br><br><pre><code class="cs hljs">textureInstance = Instantiate(levelTexture) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Texture2D;</code> </pre> <br>  However, we need not only to create an instance of the texture, but also to specify nodes based on the color information obtained from the texture.  Therefore, we will create a small Node class: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Node</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isEmpty; }</code> </pre> <br>  Later we will be able to store a bit more information in this class, but for now this is enough.  Now, using the following loop, we can create a grid from this class: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//maxX -  ,      Texture2D //maxY -   for (int x = 0; x &lt; maxX; x++) { for (int y = 0; y &lt; maxY; y++) { //   Node n = new Node(); nx = x; ny = y; //     //      Color c = levelTexture.GetPixel(x, y); //     textureInstance.SetPixel(x, y, c); //     ;     ,     0  -.     ,    . n.isEmpty = (ca == 0); //     ,      .       Color mC = minimapColor; if (n.isEmpty) mC.a = 0; miniMapInstance.SetPixel(x, y, mC); //       grid[x, y] = n; } } //  for        .Apply() textureInstance.Apply(); miniMapInstance.Apply();</span></span></code> </pre> <br>  <strong>Note: it is</strong> not necessary to set the pixels for each Instance texture, as we do here, creating an instance before the loop also works, but we can use this technique to influence the pixels and give them a color other than the usual.  For example, in the case of an opaque pixel, you can replace its normal color with green.  This way we can create a minimap. <br><br>  <strong>Note:</strong> the above for loop must be executed only once.  Therefore, even for large textures (I use a 1000x200 texture), the excess consumption of resources will be only at boot.  After that, we will use the address stored in the node to make changes to the map. <br><br>  Now we have a texture and we need to render it.  We add a GameObject with SpriteRenderer (in the code below it is stored as levelRenderer) and convert our Texture2D into a sprite to assign it.  This can be done using the following lines: <br><br><pre> <code class="cs hljs">Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, maxX, maxY); levelRenderer.sprite = Sprite.Create(textureInstance, rect, Vector2.zero,<span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>, SpriteMeshType.FullRect);</code> </pre> <br>  You can do the same for the minimap, but instead of Sprite Renderer, I used the Image UI component. <br><br>  Vector2.zero is the axial point, position 0.0 in the lower left corner.  The value 100 next to it is the pixel-to-point ratio, the default in Unity is 1 point per 100 pixels.  Also, when performing any calculations with world coordinates, it is important to know that, for example, to find a position in the node world (5,6), we multiply x and y by the ratio, i.e.  (x * (1/100))  Or you can set the ratio 1: 1 / for all sprites in the import settings <br><br>  Finally, it is important that the sprite mesh (sprite mesh) is of type FullRect.  Otherwise, Unity will optimize the sprites, creating "islands" of opaque pixels.  This will not be a problem when removing pixels from the map, but we need to add pixels to empty areas.  Having set the type to FullRect, we will force Unity to store the sprite as a whole rectangle the size of the original image. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07e/601/986/07e6019860e3a89ff64472de7db7c638.png"></div><br>  <em>The picture above shows the problem when sprites are not of the FullRect type.</em> <br><br>  Thanks to all of the above, we learned how to recreate the texture as a map. <br><br><h1>  Units and search for ways </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/537/8b5/d4f/5378b5d4fa0a0fe4c089e13b672f4134.gif"></div><br><br>  In this part, I‚Äôll skip the process of creating animations for units inside Unity, but if you don‚Äôt know how they are created, then this process is covered in the video. <br><br>  So how do we implement pixel-perfect-collisions? <br><br>  We already know where on our grid are empty nodes and nodes of the earth.  Let's decide on which nodes we can walk.  The ‚Äúrule‚Äù of our game will be as follows: if the node is the ground, and the node above it is air, then the top node is the node that you can go.  As a result, we will be able to walk from one empty node to another, but when we reach a node under which there is no ground, we fall.  Thus, creating a search path for each unit will be a relatively simple process. <br><br>  We just need to do the following in the correct order: <br><br><ol><li>  Check whether the current node is null.  If this is true, then we probably fell from the map. </li><li>  Check whether curNode is an exit node, and if so, the unit has left the level (more on this below). </li><li>  Check if the bottom node is empty.  This means that we are in the air, which means we are falling.  If we fall more than four frames (if the last four nodes along which we moved were empty), then we switch to the drop animation.  Because of this, the animation does not change when we just go down the slope. </li><li>  If there is land beneath us, then we need to look ahead.  We look forward, if there is an empty knot, then we move there. </li><li>  If the node in front is not empty, then we start looking at the four nodes up until we find an empty node. </li><li>  If we have not found an empty knot, then just turn around and go in the opposite direction. </li></ol><br>  As you can see, this search for ways is very rudimentary, but for a game like Lemmings, it's more than enough. <br><br>  There are also other aspects that need to be taken into account when searching for ways, for example, the ‚ÄúUmbrella‚Äù ability that is used in a fall, or the ‚ÄúDigging‚Äù ability, when we dug deep, and there is no land beneath us, and so on. <br><br>  That's the whole search for ways.  To move units, we need to interpolate from one pixel to another.  Or, you can add a certain number of points to the transform position at specified intervals, but with the help of interpolation we solve two problems.  We limit the number of pathfinding operations we use, so as not to execute them every frame, because units use pathfinding only when they reach a pixel.  Despite the fact that this is a simple operation, this way we can significantly save computational resources, thus increasing the number of units capable of moving at the same time level. <br><br>  All units are controlled by a simple dispatcher, which manually executes their Update ().  Since Lemmings had an ‚Äúaccelerate‚Äù button, to recreate it, we need an imitation of time Scale time (when accelerated, it has a value of 2 or 3), which is transferred to the units along with a scaled version of the time delta.  Units use scaled deltaTime (instead of Time.deltaTime) to interpolate between positions and use timeScale to change the speed in their Animator.  Thus, it seems that the game is in ‚Äúfast mode‚Äù, although the time scale of Unity retains its normal speed. <br><br><h1>  Level change </h1><br>  And here the fun begins.  We have a level, but the main part of Lemmings gameplay was dynamic interaction with levels. <br><br>  In other words, we need to learn how to add or remove pixels.  In both cases, we use the following code: <br><br><pre> <code class="cs hljs">textureInstance.SetPixel(x,y,c);</code> </pre> <br>  Where c = color (color).  The only difference between adding and removing a pixel is the alpha channel value.  Do not forget.  that a node is considered empty if the alpha value is 0. <br><br>  However, as we remember from the above, when we use .SetPixel (), we also need to call .Apply () on the texture so that it is actually updated.  We do not need to do this every time we change a pixel, because we can change several pixels per frame.  Therefore, we avoid using .Apply () until the end of the frame.  Therefore, at the end of our Update () loop, we have a simple boolean value.  When it is true, both for textureInstance and for the minimap .Apply () is executed: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(applyTexture) { applyTexture = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; textureInstance.Apply(); miniMapInstance.Apply(); }</code> </pre> <br><h1>  Abilities </h1><br>  After creating this system, we simply need to determine which pixels we are working on and how.  In the article I will consider only the high-level logic of events, but you can see the code in the video.  Hereinafter, when I say ‚Äúwhether there is a pixel or not,‚Äù it means the void of the node, because if you did not fall off the map, then there will always be a pixel in any place. <br><br><ul><li>  Walking <ul><li>  This is a basic ability.  Moving on, there is nothing interesting. </li></ul></li><li>  Stop <ul><li>  Stop!  Redirecting units to the other side. </li></ul></li><li>  Umbrella <ul><li>  When a unit falls from a great height, it dies, but with this ability it smoothly descends, like Mary Poppins.  This ability works very simply, it just checks its activity.  In addition, it changes the speed of the fall to interpolate between pixels to create the effect of a relaxed fall. </li></ul></li><li>  Forward digging <ul><li>  In the original game, it was called ‚ÄúBasher‚Äù - the unit simply dug the tunnel forward.  From the point of view of logic, it redefines the search path: if there is at least one pixel ahead, the unit continues to dig for a certain number of pixels, then for each pixel forward it takes 8 pixels above it and sends them so that they are deleted.  The size of eight pixels is chosen because of the growth of our characters. </li></ul></li><li>  Digging down <ul><li>  It looks like digging forward.  Instead of taking pixels from the front and top, the ability takes 2-3 pixels under the unit, 2-3 forward, and, of course, from one row below. </li></ul></li><li>  Blowing up <ul><li>  This is a simple suicide unit, it just explodes, leaving a hole in its place.  Removable pixels are at a given radius around its position. </li></ul></li><li>  Building <ul><li>  Another classic ability is that the unit builds a row of pixels diagonally upwards from the point at which it is looking.  This is achieved by obtaining 4-5 pixels in front and above with their further transfer to ‚Äúadd‚Äù.  It also affects the properties of nodes (turns a node from empty to full).  After that, the ability interpolates to the next diagonal position and repeats operations until it collides with the wall or until the number of pixels allocated for the building is completed. </li></ul></li><li>  Filling <ul><li>  Another fun ability that seamlessly brings us to the next section.  She first appeared in Lemmings 2: this is a unit that throws ‚Äúsand‚Äù pixels that have ‚Äúfluid‚Äù properties ‚Äî always go down until they reach a resting point.  We will discuss them in more detail later. </li></ul></li></ul><br>  Obviously, in the Lemmings series of games there are much more other abilities, but I suppose (although I haven‚Äôt tested them all) that they will be just combinations of all the above.  Miner, for example, is a variation of Basher, but instead of moving forward, it digs forward and down. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba9/c59/b9e/ba9c59b9ef61e5d2da271df8dd32e7e5.gif"></div><br>  <em>Get down smoothly like mary poppins</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d13/b4a/c4e/d13b4ac4efe22ce1351392fe075b85f7.gif"></div><br>  <em>Examples of using some abilities</em> <br><br><h1>  "Liquids" </h1><br>  Or as I call them, the fill nodes.  This is another fun addition.  Their high-level logic is as follows: they are dynamic nodes that have their own ‚Äúsearch for paths‚Äù.  Put them all together and get a fluid effect.  As shown in the video, you can also create the effect of falling snow. <br><br>  Here's how it works - we have the following class: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FillNode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t; }</code> </pre> <br>  x and y is, as you might guess, the node address.  t here is the number of times the fill node has been in the ‚Äúdeadlock position‚Äù.  You can experiment with numbers, but for myself I chose that if it was in it 15 times, then the node is considered to be stopped, thus turning from the filling node into a normal node. <br><br>  The fill nodes are not updated every frame, because then they would have to change position 60 times per second, because of which they could move too fast.  We use the universal timer acting only on them.  Personally, I used the update every 0.05 seconds, but you can experiment with it to get various effects of the fluid. <br><br>  So, when they are updated, their ‚Äúsearch for paths‚Äù looks like this: <br><br><ol><li>  We check if there is a node under our node, if not, then this filling node has fallen outside the map. </li><li>  If it exists, then we check if it is empty.  If it is empty, then clear the pixel in which we are and add it to the pixel (node) below.  So we keep moving down. </li><li>  However, if it is not empty, check the pixel forward-down.  If it is empty, move there. </li><li>  If the forward-down is full, then move back-down. </li><li>  If we are in a position from which there is no place to move, then we add to the filling node t. </li><li>  If t is greater than the value we specify, then delete the fill node and leave the pixel full. </li></ol><br>  t is responsible for three aspects.  First, by removing nodes that are not moving, it ensures that we do not have a huge list of filling nodes.  Secondly, it allows you to avoid sticking the nodes to each other when falling.  Thirdly, if the node is at a dead end, but is not yet considered to be stopped, then the unit digging under it will cause the filling node to fall down during the next update, which creates a beautiful dynamic effect. <br><br>  Considering all the above, one might think that the ‚Äúfluid‚Äù effect greatly affects the speed, but in our case it is not.  As shown in the video, I tested it with large numbers (more than 10,000 filling nodes).  Although there was no chance that all 10,000 would be ‚Äúalive‚Äù at the same time, this created a very beautiful effect, shown below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/106/1f8/3b2/1061f83b23be25cd3563cd74fe0e439e.gif"></div><br>  <i>Play with this extra system.</i>  <i>The "placeholder" ability needs only a spawn position, after which it will create several filling nodes and allow them to move independently.</i> <br><br><h1>  Level editor </h1><br>  You probably guessed that it would not be possible without it, because in essence, all we did was change the colors of the pixels.  Therefore, the next logical step will be the creation of a level editor, which, of course, will be a pixel drawing tool.  I don‚Äôt think that it‚Äôs worth going deeper into the analysis of this editor, because it only uses the same functions described above, but focuses not on units, but on the position of the mouse.  Of course, if you want to see the whole code, you can watch the video. <br><br>  But I want to talk more about serialization, so ... <br><br><h1>  Serialization </h1><br>  As I showed in the video, there are several ways to implement it.  I don't even have to use an editor to create levels.  We can simply load an image from a disk into .png and use it as a level.  The system we have already created opens up wide possibilities.  However, we still need to create a game from texture, so we need to maintain the spawn position and exit position (let's call them two events).  In the sequels of the original Lemmings there were several such events, but let's focus on each of them, the basis of the logic will be the same. <br><br>  Of course, there are also many ways to implement these events, for example, creating two textures per level, one with the level itself, the second with color-coded events, but in this case, players can change the level events in a third-party editor.  This is not necessarily bad, but is sometimes undesirable, for example, if you have campaign levels. <br><br>  As a result, I decided to serialize everything necessary on the level into one file.  The only thing worth mentioning here is of course that you cannot serialize Texture2D directly, but you can convert it into an array of bytes by encoding the texture.  Unity has simplified our lives because we just do the following: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] levelTexture = textureInstance.EncodeToPng();</code> </pre> <br><h1>  Advanced level editor </h1><br>  Although the level editor is a good feature of the game, most likely, it will be boring for players to start from scratch each time.  As stated above, in the video I have already demonstrated how to load .png from a file, but I wanted the game to work on WebGL without solving complex problems. <br><br>  I came up with the following solution - allow players to insert a link from the level editor, and then load it as a copy of the texture.  After that, the question will be only in setting the level events and saving. <br><br>  How to do it?  In Unity there is a WWW class, so we will create a cortina for loading textures: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadTextureFromWWW</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url</span></span></span><span class="hljs-function">)</span></span> { WWW www = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WWW(url); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> www; <span class="hljs-comment"><span class="hljs-comment">//  www ,    if(www.texture == null) { //  } else { //   ,  textureInstance = www.texture; } }</span></span></code> </pre> <br>  <strong>Note:</strong> although the above code is correct, it is still pseudo-code because there are several additional lines in the working code that process the UI, re-initialize the editor, etc.  I have not added them here so we can focus on the most important.  Of course, the full code is in the video. <br><br>  All the code written above works great in desktop builds, because you can insert a custom clipboard into your own Unity input fields.  But‚Ä¶ <br><br><h1>  Changes for the WebGL assembly </h1><br>  ... in WebGL is not allowed.  To get around this problem, you can insert a small fragment of javascript into the index file of the WebGL assembly.  Something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    (    WebGL-) var gameInstance = UnityLoader.instantiate("gameContainer", "Build/lennys.json"); // function GetUserInput(){ var inp = prompt("link"); gameInstance.SendMessage("GameManager","ReceiveLink",inp); }</span></span></code> </pre> <br>  Thanks to this, a pop-up window will appear in the browser with a text field where you can insert a link.  After clicking on OK, the script will transmit the message, find the game object ‚ÄúGameManager‚Äù and the function ‚ÄúReceiveLink‚Äù, in the signature of which there is a string inp.  The function itself looks like this: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReceiveLink</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url</span></span></span><span class="hljs-function">)</span></span> { linkField.text = url; }</code> </pre> <br>  Here, the linkField is an element of the UI InputField, nothing special. <br><br>  It is worth noting the following: <br><br><ul><li>  Even though we have a script called GameManager, JavaScript looks for a game object (and not a class!) With that name.  The function we call is located in the UIManager class (which is in the same gameobject). </li><li>  The texture does not load until the player clicks on the texture download button in the game UI. </li></ul><br>  To perform the JavaScript function, you need to add the following lines when you click the url download button: <br><br><pre> <code class="javascript hljs">Application.ExternalEval(<span class="hljs-string"><span class="hljs-string">"GetUserInput()"</span></span>);</code> </pre> <br>  In addition, there is another limitation in WebGL.  Yes, you guessed it - we can not maintain the level of the user, without securing a headache.  How to solve this problem?  Very simple - let's set the MVP for our project. <br><br>  However, we still need to give the players to play uploaded as they are images or hand-drawn levels.  Therefore, we will save them "on the fly."<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This means that all created levels will be lost in the next session. </font><font style="vertical-align: inherit;">This is not a particularly serious problem, because you can upload images online. </font><font style="vertical-align: inherit;">First, we determine whether we are on the WebGL platform; this is done like this:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Application.platform == RuntimePlatform.WebGLPlayer) isWebGl = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I do all this mainly in the framework of the tutorial, in fact, I planned to turn everything into WebGL, because I never intended to create builds for desktops or other platforms. </font><font style="vertical-align: inherit;">Therefore, instead of saving the files locally, we will store them in memory.</font></font><br><br><h1>  Conclusion </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e18/ce4/7a5/e18ce47a56257288d57c0cbcaa43bc4d.png"></div><br><br>     .           1-2 ,        ,   ,         ¬´¬ª  ¬´¬ª .  ,    . <br><br>   ,     API     . <br><br>   pixel-perfect-           .     ,       ,       ,    . </div><p>Source: <a href="https://habr.com/ru/post/340660/">https://habr.com/ru/post/340660/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340642/index.html">Add Basic Auth to a SOAP request using ksoap2-android</a></li>
<li><a href="../340646/index.html">Traveling from Moscow to Kazan through St. Petersburg or the process of developing an algorithm for finding all paths</a></li>
<li><a href="../340650/index.html">Environment for developing TypeScript and React web applications: from 'hello world' to modern SPA. Part 1</a></li>
<li><a href="../340652/index.html">"Star dealer" or computer training in the era of mini-computers</a></li>
<li><a href="../340654/index.html">State Library</a></li>
<li><a href="../340664/index.html">Combination of labor in software development</a></li>
<li><a href="../340666/index.html">Pro 112, and how it works now</a></li>
<li><a href="../340668/index.html">Big data and machine learning: new opportunities for medicine</a></li>
<li><a href="../340670/index.html">Vertical rhythm</a></li>
<li><a href="../340674/index.html">Algorithms for building a path for an unmanned vehicle. Yandex lecture</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>