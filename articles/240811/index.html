<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>An old dog learns new tricks: Code Kata using QuickCheck</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When I agitate fellow programmers to create more different autotests for their code, they often complain that this is a difficult and dismal work. And...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>An old dog learns new tricks: Code Kata using QuickCheck</h1><div class="post__text post__text-html js-mediator-article">  When I agitate fellow programmers to create more different autotests for their code, they often complain that this is a difficult and dismal work.  And in some ways they are right.  When using classic unit tests, in fact, often have to write a lot of code to check each individual case of behavior.  Yes, and the quality of testing sometimes raises questions, especially in complex systems, when trivial usage scenarios go bang, but in some more complex scenarios that no <em>one thought of</em> writing tests, unpleasant problems arise. <br><br>  I heard about the testing method used in <a href="http://en.wikipedia.org/wiki/QuickCheck">QuickCheck a</a> long time ago, but I still didn‚Äôt have enough of the final push to get to the close.  This impetus was <a href="http://www.infoq.com/presentations/automated-testing">this presentation</a> from John Hughes, the author of this wonderful library. <br><br><h1>  What is the QuickCheck approach </h1><br>  It‚Äôs quite simple to describe the essence of the approach: we don‚Äôt create sample tests, but instead set up <strong>rules</strong> that define the behavior of the system on <strong>arbitrary</strong> input data.  The library itself generates a large amount of random input data and checks whether the behavior of the code conforms to established rules.  If this is not the case, then it shows us in what example the test falls. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It sounds promising?  Full <br><br><a name="habracut"></a><br>  But from what side should a <s>simple bydlopprogrammer</s> person approach this miracle who writes not in Haskell and not in Erlang, but in more mainstream languages?  Here I, for example, feel more comfortable when programming in Java.  No problem!  Google almost immediately suggests that for JUnit there is a corresponding plugin called <a href="https://github.com/pholser/junit-quickcheck">JUnit-QuickCheck</a> . <br><br>  The best option to try a new approach to programming is to write something already known.  So I took the classic <a href="http://butunclebob.com/ArticleS.UncleBob.ThePrimeFactorsKata">Prime Factors Kata from Robert Martin</a> .  I recommend to get acquainted with it quickly before going deep into my article, because some moments might not be clear. <br><br><h1>  Go </h1><br>  First, create an empty project.  In order not to bore the reader with a sheet of XML files, I will use <a href="http://www.gradle.org/">Gradle</a> for this.  With him all the description of the project will fit in several lines: <br><br><pre><code class="hljs cs">apply plugin: <span class="hljs-string"><span class="hljs-string">'java'</span></span> repositories { mavenCentral() } dependencies { testCompile ( <span class="hljs-string"><span class="hljs-string">"junit:junit:4.11"</span></span>, <span class="hljs-string"><span class="hljs-string">"org.hamcrest:hamcrest-all:1.3"</span></span>, <span class="hljs-string"><span class="hljs-string">"org.junit.contrib:junit-theories:4.11"</span></span>, <span class="hljs-string"><span class="hljs-string">"com.pholser:junit-quickcheck-core:0.4-beta-1"</span></span>, <span class="hljs-string"><span class="hljs-string">"com.pholser:junit-quickcheck-generators:0.4-beta-1"</span></span> ) }</code> </pre> <br><br>  Every dependency is not here by chance.  Why JUnit is needed here, it is not necessary to explain, but I‚Äôll say a couple of words about other dependencies. <br><br><ul><li>  We will use Hamcrest to write beautiful and easy-to-read assertions. </li><li>  JUnit-Theories is also necessary, because our plugin only works with it (because in the embedded version of the theories in JUnit <a href="https://github.com/junit-team/junit/issues/64">one unpleasant bug</a> has not yet been fixed) </li><li>  The junit-quickcheck-core and junit-quickcheck-generators projects contain classes that we will use directly to generate test values. </li></ul><br><br>  Following the principles of TDD, we start with the simplest theory, which allows us to quickly verify that the feedback loop is functioning. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> org.hamcrest.CoreMatchers.is; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> org.hamcrest.MatcherAssert.assertThat; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.pholser.junit.quickcheck.ForAll; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.junit.contrib.theories.Theories; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.junit.contrib.theories.Theory; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.junit.runner.RunWith; <span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(Theories.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrimeFactorsTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Theory</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allOk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@ForAll Integer number)</span></span></span><span class="hljs-function"> </span></span>{ assertThat(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, is(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>)); } }</code> </pre><br><br>  This simple trick can save you a lot of time.  I have repeatedly seen how people, using TDD, spend a lot of time creating a complex test, and when it is finally launched, they discover that it cannot work due to some completely extraneous problem (dependencies did not download or do not register, do not JDK is installed, the project is incorrectly configured, the code is incorrectly written and a lot of other ridiculous errors).  It is always very frustrating and confusing to the work rhythm.  It is especially difficult to cope with this for beginners who are just trying to taste TDD. <br><br>  Therefore, I myself <em>always</em> start with the simplest, trivial, moronic test, and I advise you to do the same.  You just need to run it and check what I see when it passes, and see when it falls.  This means that my system is ready for <s>combat</s> , and nothing will distract from the Red-Green-Refactor cycle. <br><br><h1>  First working theory </h1><br>  In order not to bother with the question of how to identify prime numbers (this is what my code should do!), I simply <a href="">block already known numbers into an array</a> .  Obviously, due to the limitations of our list, we also have to limit the range of numbers to be tested.  Correct this later when the time comes.  In order not to be distracted from the main thing, I will no longer write in the import code, I will confine myself to the code itself. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Theory</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">primeNumberIsItsOwnFactor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@ForAll @InRange(minInt = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxInt = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">50</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Integer number) </span></span>{ List&lt;Integer&gt; firstPrimeNumbers = Arrays.asList(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-number"><span class="hljs-number">19</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-number"><span class="hljs-number">29</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">37</span></span>, <span class="hljs-number"><span class="hljs-number">41</span></span>, <span class="hljs-number"><span class="hljs-number">43</span></span>, <span class="hljs-number"><span class="hljs-number">47</span></span>); assumeThat(number, isIn(firstPrimeNumbers)); List&lt;Integer&gt; factors = PrimeFactors.extract(number); assertThat(factors, hasItem(number)); }</code> </pre><br><br>  We use the <code>@ForAll</code> and <code>@InRange</code> from the JUnit-QuickCheck project to automatically generate random numbers in the specified range.  Then we additionally filter them using the <code>assumeThat</code> function, so that the following code works only with the numbers I specified in the array.  The difference between <code>assumeThat</code> from <code>assertThat</code> is that the first function only stops the test (and proceeds to the next example) if the next number fails the test, and the second will signal an error (and stop the test for all subsequent examples).  Using assume in tests is more idiomatic than filtering values ‚Äã‚Äãusing conditional expressions. <br><br>  This test will fall first (because we have no implementation of the <code>extract</code> method), but this is easy to fix.  The solution that passes all the tests turns out to be trivial. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrimeFactors</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer number)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.asList(number); } }</code> </pre><br><br>  Do not be surprised or indignant ahead of time.  This code works <em>completely in accordance with the specification</em> , decomposing <em>any prime number not more than 50</em> into simple factors.  To teach the code to work with other numbers, just write a new theory. <br><br><h1>  Ramping meat on the skeleton </h1><br>  What properties does a set of factors of a number have?  Obviously, their product should be equal to the number itself. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Theory</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">productOfFactorsShouldBeEqualToNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@ForAll @InRange(minInt = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxInt = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">50</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Integer number) </span></span>{ List&lt;Integer&gt; factors = PrimeFactors.extract(number); Integer product = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Integer factor: factors) product = product * factor; assertThat(product, is(number)); }</code> </pre><br><br>  This theory ... does not fall!  And indeed, if our code returns the number itself, then it will always be.  Heck. <br><br>  Well, another theory, this time more successful. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Theory</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">everyFactorShouldBeSimple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@ForAll @InRange(minInt = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxInt = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">50</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Integer number) </span></span>{ List&lt;Integer&gt; factors = PrimeFactors.extract(number); assertThat(factors, everyItem(isIn(firstPrimeNumbers))); }</code> </pre><br><br>  Each factor should be simple (well, get on our list of simple), so the theory begins to fall steadily and regularly.  And this is exactly what we need.  Let, for example, the following error occurred: <br><br><pre> <code class="java hljs">org.junit.contrib.theories.internal.ParameterizedAssertionError: everyFactorShouldBeSimple(<span class="hljs-string"><span class="hljs-string">"10"</span></span> &lt;from <span class="hljs-number"><span class="hljs-number">10</span></span>&gt;) at org.junit.contrib.theories.Theories$TheoryAnchor.reportParameterizedError(Theories.java:<span class="hljs-number"><span class="hljs-number">215</span></span>) at org.junit.contrib.theories.Theories$TheoryAnchor$<span class="hljs-number"><span class="hljs-number">1</span></span>$<span class="hljs-number"><span class="hljs-number">1</span></span>.evaluate(Theories.java:<span class="hljs-number"><span class="hljs-number">169</span></span>) at org.junit.contrib.theories.Theories$TheoryAnchor.runWithCompleteAssignment(Theories.java:<span class="hljs-number"><span class="hljs-number">153</span></span>) at org.junit.contrib.theories.Theories$TheoryAnchor.runWithAssignment(Theories.java:<span class="hljs-number"><span class="hljs-number">142</span></span>) ...</code> </pre><br><br>  Let's write the most simple code that allows you to find dividers for this number: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrimeFactors</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer number)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (number % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.asList(<span class="hljs-number"><span class="hljs-number">2</span></span>, number / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.asList(number); } }</code> </pre><br><br>  Run the tests again.  They automatically fall on the new found value: <br><br><pre> <code class="java hljs">org.junit.contrib.theories.internal.ParameterizedAssertionError: everyFactorShouldBeSimple(<span class="hljs-string"><span class="hljs-string">"15"</span></span> &lt;from <span class="hljs-number"><span class="hljs-number">15</span></span>&gt;) at org.junit.contrib.theories.Theories$TheoryAnchor.reportParameterizedError(Theories.java:<span class="hljs-number"><span class="hljs-number">215</span></span>) at org.junit.contrib.theories.Theories$TheoryAnchor$<span class="hljs-number"><span class="hljs-number">1</span></span>$<span class="hljs-number"><span class="hljs-number">1</span></span>.evaluate(Theories.java:<span class="hljs-number"><span class="hljs-number">169</span></span>) at org.junit.contrib.theories.Theories$TheoryAnchor.runWithCompleteAssignment(Theories.java:<span class="hljs-number"><span class="hljs-number">153</span></span>) ...</code> </pre><br><br>  Let's make a hack for him too! <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrimeFactors</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer number)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (number % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.asList(<span class="hljs-number"><span class="hljs-number">2</span></span>, number / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (number % <span class="hljs-number"><span class="hljs-number">3</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.asList(<span class="hljs-number"><span class="hljs-number">3</span></span>, number / <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.asList(number); } }</code> </pre><br><br>  We run tests again and again, and each time they find a new value on which the implementation falls.  At the same time, we cannot simply <em>return any prime number</em> for the test to pass.  If we do this, the previous theory (which checks the product of numbers) will begin to break.  Therefore, we are forced, step by step, to implement the correct algorithm. <br><br>  Gradually (and in fact, rather quickly), this series of hacks leads us to the first correct <a href="">solution</a> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrimeFactors</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer number)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Integer&gt; factors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> divisor = <span class="hljs-number"><span class="hljs-number">2</span></span>; divisor &lt;=<span class="hljs-number"><span class="hljs-number">7</span></span>; divisor++) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((number &gt; divisor) &amp;&amp; (number % divisor == <span class="hljs-number"><span class="hljs-number">0</span></span>)) { factors.add(divisor); number = number / divisor; } } factors.add(number); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> factors; } }</code> </pre><br><br>  Of course, the word ‚Äúcorrect solution‚Äù means only that it consistently passes all tests <em>at this stage</em> .  Although, obviously, not suitable for the general case. <br><br>  It is necessary to take a break and reflex a little.  The theory, which itself selects a <em>counterexample</em> for the current code, turns out to be a very convenient thing.  The process of working on the code turns into ping-pong with a robot, which deals quick, accurate and tricky strikes.  No need to spend time thinking about new examples breaking the code, because they are born themselves.  Instead, you can fully concentrate on the thoughts about the algorithm itself, and polish it in the flow mode.  This is partly why there is <a href="https://github.com/ahitrin/jq-example/commit/196e5b6d942c78300d94dc272b43fa221d4d42c6">such a big leap</a> in commits.  It‚Äôs just that the code was born too fast for intermediate steps to harden and form into full-fledged commits. <br><br>  So far it seems that everything is very cool.  We wrote <em>just a couple of</em> theories, and they semi-automatically fed out our algorithm.  Isn't it a beauty?  However, let's see what happens next. <br><br><h1>  It's time to grow out of short pants </h1><br>  The euphoria gradually passes, and the eye begins to pay attention to the sharp corners, which we diligently skirted in the first stages.  Our code, of course, works according to the specification, but this specification is defined only for numbers from 2 to 50. It's not rich!  At this interval, and without a program, you can do without, just count everything in your mind. <br><br>  Let's move on.  We raise the upper limit 10 times in all theories! <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Theory</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">primeNumberIsItsOwnFactor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@ForAll @InRange(minInt = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxInt = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">500</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Integer number) </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">@Theory</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">productOfFactorsShouldBeEqualToNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@ForAll @InRange(minInt = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxInt = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">500</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Integer number) </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">@Theory</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">everyFactorShouldBeSimple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@ForAll @InRange(minInt = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxInt = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">500</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Integer number) </span></span>{ ... }</code> </pre><br><br>  <em>Suddenly</em> , a new problem arises: our theories are not aware that there are simple numbers, more than 47 (oops, no one introduced her to <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D1%2581%25D1%2582%25D0%25BE%25D0%25B5_%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D0%25BE">Euclid</a> ).  We must come up with a new way to determine the prime numbers. <br><br>  Let's cheat a little (or is everything honest here?) And use the <a href="http://docs.oracle.com/javase/7/docs/api/java/math/BigInteger.html">ready-made implementation of the test for simplicity</a> , which is in the standard Java library.  In order not to violate the beauty and uniformity of the code, we will do it in the form of an appropriate matcher. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Theory</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">primeNumberIsItsOwnFactor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@ForAll @InRange(minInt = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxInt = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">500</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Integer number) </span></span>{ assumeThat(number, isProbablySimple()); List&lt;Integer&gt; factors = PrimeFactors.extract(number); assertThat(factors, hasItem(number)); } <span class="hljs-meta"><span class="hljs-meta">@Theory</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">productOfFactorsShouldBeEqualToNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@ForAll @InRange(minInt = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxInt = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">500</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Integer number) </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">@Theory</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">everyFactorShouldBeSimple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@ForAll @InRange(minInt = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxInt = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">500</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Integer number) </span></span>{ List&lt;Integer&gt; factors = PrimeFactors.extract(number); assertThat(factors, everyItem(isProbablySimple())); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Matcher&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isProbablySimple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseMatcher&lt;Integer&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matches</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (item <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Integer) &amp;&amp; (BigInteger.valueOf((Integer) item).isProbablePrime(<span class="hljs-number"><span class="hljs-number">5</span></span>)); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">describeTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Description description)</span></span></span><span class="hljs-function"> </span></span>{ description.appendText(<span class="hljs-string"><span class="hljs-string">"prime number"</span></span>); } }; }</code> </pre><br><br>  Now our code falls on the decomposition of large numbers.  It's time to fix it! <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrimeFactors</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer number)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Integer&gt; factors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> divisor = <span class="hljs-number"><span class="hljs-number">2</span></span>; divisor &lt;= number; divisor++) { ...</code> </pre><br><br>  We fix the old cycle boundary (7) on the <code>number</code> , and it seems that everything is working again. <br><br>  Only a little remains: push the boundaries of the tests even wider and enjoy the result.  And here we are in for a sudden surprise ... <br><br><h1>  Facing harsh reality </h1><br>  The reality <a href="https://github.com/ahitrin/jq-example/commit/26c77e0386a757b9d956382333b52ec7452927a9">is</a> : <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Theory</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">primeNumberIsItsOwnFactor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@ForAll @InRange(minInt = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxInt = Integer.MAX_VALUE)</span></span></span><span class="hljs-function"> Integer number) </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">@Theory</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">productOfFactorsShouldBeEqualToNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@ForAll @InRange(minInt = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxInt = Integer.MAX_VALUE)</span></span></span><span class="hljs-function"> Integer number) </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">@Theory</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">everyFactorShouldBeSimple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@ForAll @InRange(minInt = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxInt = Integer.MAX_VALUE)</span></span></span><span class="hljs-function"> Integer number) </span></span>{ ... }</code> </pre><br><br>  As soon as we increased the upper bound of the tests from 500 to <code>Integer.MAX_VALUE</code> (2 ^ 31 - 1), the tests began to work <strong>unrealistically for a</strong> long time.  For a minute for each test.  What's the matter?  What's wrong? <br><br>  An unexpected side-effect of QuickCheck-style tests is their <em>sensitivity to the speed of the code under test</em> .  Although, if you think about it, this is quite logical: if our code is not optimized and works slowly, then a hundred calls to it will make this non-optimality a hundred times more visible.  In the "classic" unit tests, this slowdown will not be so noticeable, but here it manifests itself in all its glory. <br><br>  What do we do when we need to find a plug in the code?  There are two options: either we take a profiler in our hands and begin to take readings, or we are looking for an error <em>by means of close scrutiny</em> . <br><br>  However, in our code there is nothing special to look at, everything is already in sight.  The problem is that we run idle for too long in a cycle, burning electricity in vain.  Anyone familiar with the factorization algorithm remembers that it is enough for us to check factors that do not exceed the square root of a given number.  And who does not remember, he can go <a href="http://butunclebob.com/ArticleS.UncleBob.ThePrimeFactorsKata">to Uncle Bob</a> . <br><br>  Let's <a href="https://github.com/ahitrin/jq-example/commit/c93a68c449e3aba074731fd25f6abbb4d620a077">fix the</a> same <a href="https://github.com/ahitrin/jq-example/commit/c93a68c449e3aba074731fd25f6abbb4d620a077">fix</a> .  Again we change the upper bound of the loop, but this time to <code>Math.sqrt(number)</code> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrimeFactors</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer number)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Integer&gt; factors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> divisor = <span class="hljs-number"><span class="hljs-number">2</span></span>; divisor &lt;= Math.sqrt(number) + <span class="hljs-number"><span class="hljs-number">1</span></span>; divisor++) { ...</code> </pre><br><br>  How did this affect the result of the work?  Tests began to work again quickly, and the difference is truly impressive. <br><br>  Now everything is all right!  All tests pass, the code looks neat, an interesting experience is gained - isn't it time to write an article for Habr?  And then another thought creeps into my head ... <br><br><h1>  Test your tests </h1><br>  Stop, my friend, I tell myself, have you written down the boundary condition of the cycle correctly?  Is it necessary to add one to the root of a number, or is it superfluous? <br><br>  It seems to be a trifling question.  We also have tests that run on hundreds of test values!  They will show who is wrong here. <br><br>  Subtract "+1" at the top of the loop ( <code>divisor &lt;= Math.sqrt(number);</code> ) and run the tests. <br><br>  Great, they pass! <br><br>  We subtract one more, just like that, just in case ( <code>divisor &lt; Math.sqrt(number);</code> ). <br><br>  Tests pass again! <br><br>  What? <br><br>  And here I had to think again.  We will aggravate the situation <a href="https://github.com/ahitrin/jq-example/commit/5ad248fa471048abf561708f53ecb263d58eec99">even more</a> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrimeFactors</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer number)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Integer&gt; factors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> divisor = <span class="hljs-number"><span class="hljs-number">2</span></span>; divisor &lt; Math.sqrt(number) - <span class="hljs-number"><span class="hljs-number">2</span></span>; divisor++) { ...</code> </pre><br><br>  I wrote a deliberately wrong code (it will not find multipliers even for the number 9), <em>but the tests say that everything is fine</em> .  I run them again - again they say that everything is fine.  I run them again - time after time they pass successfully.  Falls occur very rarely, and counterexamples to my erroneous algorithm, which the tests occasionally find, are not saved for the next launches. <br><br>  What is the reason for this behavior tests? <br><br>  By <code>Integer.MAX_VALUE</code> test boundaries to <code>Integer.MAX_VALUE</code> , we were able to find and fix performance problems, but fell into a new trap.  The trick is that with such range settings in tests, <em>mostly large</em> numbers are used (because a uniform distribution is used for generation).  And the defect introduced into the code manifests itself only on the squares of prime numbers (I hope, does not require clarification), which are <em>very few</em> among large numbers. <br><br>  Unfortunately, I was not able to come up with solutions that were more successful than cheating again and making a <em>copy of the</em> existing specification, but only again with narrow boundaries. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Theory</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">everyFactorShouldBeSimple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@ForAll @InRange(minInt = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxInt = Integer.MAX_VALUE)</span></span></span><span class="hljs-function"> Integer number) </span></span>{ List&lt;Integer&gt; factors = PrimeFactors.extract(number); assertThat(factors, everyItem(isProbablySimple())); } <span class="hljs-meta"><span class="hljs-meta">@Theory</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">everyFactorShouldBeSimpleEspeciallyForSmallNumbers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@ForAll @InRange(minInt = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxInt = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">200</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Integer number) </span></span>{ everyFactorShouldBeSimple(number); }</code> </pre><br><br>  It looks clumsy, but at least allows you to find the exact upper limit to which you need to drive a cycle ( <code>divisor &lt;= Math.sqrt(number)</code> ). <br><br>  It's time to take stock and bring together all the discoveries that have come across to us in this (seemingly) simple example. <br><br><h1>  What we got in the end </h1><br>  Even one experiment in an unfamiliar area can bring a lot of discoveries.  I will try to collect all the features of the QuickCheck-approach in one bundle and evaluate them. <br><br><h2>  Laconic specification </h2><br><br>  Indeed, there is such.  I had to write only three theories, each of which tested one feature of the algorithm.  This is noticeably less than a dozen regular unit tests, which occurs in the classic version of the kata.  We write this feature in a unique plus of this technique. <br><br><h2>  The need to carefully formulate verifiable properties </h2><br><br>  In order for the theories to work well, it is necessary to invent <em>qualitative</em> properties for testing that are invariant with respect to the input parameters.  Sometimes it can be really difficult.  It may seem as if you need to fully implement the testing algorithm inside the test code. <br><br>  In the above example, we managed to use the <code>isProbablePrime</code> method, which uses a fast heuristic algorithm to <em>inaccurately</em> check the number for simplicity.  However, if such an algorithm did not exist, then what would be the possibility of verification?  Indeed, by definition, a prime number is such a number that do not have divisors.  And, to check the simplicity of the number, you need to try to <em>decompose it into dividers</em> . <br><br>  Perhaps this is the most difficult moment in QuickCheck testing.  I will need further research to understand how hard it is to create good invariants for use in theories. <br><br><h2>  Slow code sensitivity </h2><br><br>  On the one hand, this is good, because it can immediately indicate that our code is not optimal.  On the other hand, if the code in principle cannot be greatly accelerated, then you will either have to accept the slow work of the tests, or reduce the number of random values ‚Äã‚Äãthat are used as test parameters.  And if we reduce the number of random values, then our confidence that the tests will find possible defects in the code also falls to an appropriate degree. <br><br>  I think you already guessed that using QuickCheck for end-to-end testing might not be the best idea for this very reason.  Although, if you really want, you <a href="https://www.fpcomplete.com/user/christianpbrink/quickcheck-and-webdriver">can try</a> . <br><br><h2>  Insensitivity to boundary conditions </h2><br><br>  Perhaps this is a feature of the specific library JUnit-QuickCheck, and in other languages ‚Äã‚Äãwith this matter the situation is better.  Or is it a feature of a specific example that we have chosen for the sample.  Nevertheless, it shows that you should not always lightly rely on random values, which the library helpfully selects for us.  Anyway, you have to think hard with your brain and re-check the correctness of the written code. <br><br><h2>  QuickCheck can also be used for TDD! </h2><br><br>  It seems to be quite real, although the sensations are different.  Due to the fact that there are fewer theories (and each of them is testing more cases), it is easier to build a chain of test methods that will lead us to the working code.  On the other hand, it can turn into troubles if it is necessary to take too big a step in order to force the code to pass the newly added theory.  However, people encounter such problems in classic TDD (and either find ways to solve them, or begin to be afraid of TDD in principle). <br><br>  It is possible that when testing code, a combination of classic test examples and parameterized theories in the QuickCheck style will work well.  I will definitely try to continue my research in this area and share interesting findings. </div><p>Source: <a href="https://habr.com/ru/post/240811/">https://habr.com/ru/post/240811/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../240799/index.html">The story of one bug in the machine for video poker</a></li>
<li><a href="../240803/index.html">Free Cryptic Disk 4 with TrueCrypt support</a></li>
<li><a href="../240805/index.html">Strutext C ++ word processing library</a></li>
<li><a href="../240807/index.html">NodeMap, but not what you thought</a></li>
<li><a href="../240809/index.html">Package to create admin in projects on Laravel</a></li>
<li><a href="../240813/index.html">Expressive JavaScript: Data Structures: Objects and Arrays</a></li>
<li><a href="../240815/index.html">"Purple" I2P - a window into the world of C ++ applications</a></li>
<li><a href="../240817/index.html">Using Accept Header for API Versioning</a></li>
<li><a href="../240819/index.html">Javascript equalizer</a></li>
<li><a href="../240823/index.html">Odroid W, or giblets raspberry pie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>