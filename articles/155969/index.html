<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Understanding autorotation in iOS 6</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello friends! 

 If you are creating applications for gadgets from Apple, then you probably know that the iOS update to version 6 recently occurred. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Understanding autorotation in iOS 6</h1><div class="post__text post__text-html js-mediator-article">  Hello friends! <br><br>  If you are creating applications for gadgets from Apple, then you probably know that the iOS update to version 6 recently occurred. <br>  Along with <a href="https://developer.apple.com/library/ios/">other</a> new features, Apple has made changes to the autorotation mechanism. <br>  Just in case, let me remind you that autorotation is a mechanism that allows you to use the device both in portrait (stretched in height) and landscape (stretched in width) orientation, and also change this orientation when you turn the device. <br><img src="https://habrastorage.org/storage2/ff2/11f/477/ff211f477e513bf487f291aeaa0eb88d.png" alt="image"><br>  If content is displayed in both orientations in your application (and especially if you need to prohibit rotation on some screens), I bet that you already have some <a href="http://stackoverflow.com/questions/12526054/autorotate-in-ios-6-has-strange-behaviour/12538622">questions</a> . <br>  If you do not use the function of changing the orientation of the screen - the difference could not be noticed.  However, knowing how autorotation works in iOS6 will in any case be useful and useful in the future. <br><a name="habracut"></a><br><h4>  How was it before iOS 6 </h4><br>  IOS devices support 4 possible screen orientations, described by their respective system constants: <br><ul><li>  UIInterfaceOrientationPortrait </li><li>  UIInterfaceOrientationPortraitUpsideDown </li><li>  UIInterfaceOrientationLandscapeLeft </li><li>  UIInterfaceOrientationLandscapeRight </li></ul><br>  In iOS 5 and earlier versions, the autorotation mechanism uses the method <br><br><pre><code class="hljs objectivec">- (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)shouldAutorotateToInterfaceOrientation:(<span class="hljs-built_in"><span class="hljs-built_in">UIInterfaceOrientation</span></span>)interfaceOrientation { <span class="hljs-comment"><span class="hljs-comment">//  YES    return (interfaceOrientation == UIInterfaceOrientationPortrait); }</span></span></code> </pre> <br>  When a device changes its orientation in space, by calling this method, the system requests the active controller (view controller) whether it supports the transition to this orientation. <br>  When the method is called, the interfaceOrientation parameter contains one of 4 possible values, and the method should return YES if you need to rotate the application window (or NO otherwise). <br>  Thus, for each individual controller, it is sufficient to override the <i>shouldAutorotateToInterfaceOrientation:</i> method and specify the types of orientation it supports. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The UISupportedInterfaceOrientations key in Info.plist contains a list of orientations supported by the application (you can also select them in the Summary section of your Targets) and is used by the system only to determine the initial orientation when the application starts. <br><img src="https://habrastorage.org/storage2/4b1/645/4be/4b16454be593279e4c99db31eab84fc1.png"><br><br><img src="https://habrastorage.org/storage2/c55/59b/841/c5559b841abf6b0bd4c3ab5453a2f2ad.png"><br>  If no type of orientation is indicated - nothing terrible will happen, the application will be launched in the usual portrait (UIInterfaceOrientationPortrait). <br><br><h4>  Became in iOS 6 </h4><br>  In iOS 6, the <i>shouldAutorotateToInterfaceOrientation</i> method is deprecated, while the other autorotation logic is <i>supported by the supportedInterfaceOrientations</i> and <i>shouldAutorotate</i> . <br><br>  When changing the position of the device (or when the controller is presented modally), the system polls the top-most full-screen controller (top-most full-screen view controller).  At the same time, the first call is called the <i>mustAutorotate</i> , and then (only in the case of returning the value YES) the call is <i>supportedInterfaceOrientations</i> to get a bit mask describing the supported positions.  For example, the following code can be used to support ordinary portrait and both landscape orientations. <br><br><pre> <code class="hljs objectivec">- (<span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span>)supportedInterfaceOrientations { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">UIInterfaceOrientationMaskPortrait</span></span> | <span class="hljs-built_in"><span class="hljs-built_in">UIInterfaceOrientationMaskLandscapeLeft</span></span> | <span class="hljs-built_in"><span class="hljs-built_in">UIInterfaceOrientationMaskLandscapeRight</span></span>; }</code> </pre><br>  Next, the system uses the value obtained from the <i>supportedInterfaceOrientations</i> , performing a <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D1%258A%25D1%258E%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F">conjunction</a> (bitwise "AND") with a list of orientations globally supported by the application (taken from Info.plist or as a result of the AppDelegate <i>application: supportedInterfaceOrientationsForWindow</i> method:).  According to the results of the operation, a turn (or not) occurs. <br><br>  In short, the decision is made by operation <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">app_mask</span></span> &amp; topmost_controller_mask</code> </pre><br>  where <b>app_mask</b> is taken from Info.plist (or <i>application: supportedInterfaceOrientationsForWindow :)</i> , and <b>topmost_controller_mask</b> as a result of the <i>supportedInterfaceOrientations</i> call of the top full-screen controller. <br><br>  Also consider the following points: <br><br><ul><li>  since the value of app_mask is global, you should change it carefully </li><li>  to temporarily disable the ability to rotate, it is recommended to use <i>shouldAutorotate</i> , rather than perform mask manipulations in <i>supportedInterfaceOrientations</i> </li><li>  if the <i>application: supportedInterfaceOrientationsForWindow:</i> method is used in AppDelegate, then the values ‚Äã‚Äãfrom Info.plist will be ignored </li><li>  if at some point the result of the conjunction is 0, this will result in a <i>UIApplicationInvalidInterOfaceOrientationException</i> exception <i>.</i> </li><li>  if you have not redefined the <i>supportedInterfaceOrientations</i> and <i>shouldAutorotate methods</i> , by default the controllers will support all types of orientation on iPad devices, and on iPhone - all except PortraitUpsideDown </li><li>  new method <i>preferredInterfaceOrientationForPresentation</i> allows you to specify the preferred orientation of the controller when it is displayed </li><li>  <i>shouldAutoRotateToInterfaceOrientation:</i> no longer called in iOS 6, however you should still use it to support devices with previous versions of iOS </li></ul><br><br>  These are the changes.  This move is dictated by the desire of Apple to transfer responsibility for making decisions about the supported position of the screen from each specific active controller to the controller-containers and the application itself. <br><br>  Apple‚Äôs key thoughts (Session 236 from WWDC 2012) are as follows: <br><ul><li>  controllers should strive to support all possible modes </li><li>  child controllers must be able to display in any frame specified by their parent </li><li>  the application must be able to specify the supported orientation types (Info.plist or <i>application: supportedInterfaceOrientationsForWindow:)</i> </li><li>  when rotated, only root or top fullscreen controller will be polled </li></ul><br><br><h4>  What to do with it </h4><br>  When developing a new project that requires support for iOS 5 and earlier, Apple recommends trying to emulate iOS 6 mechanisms: <br><ul><li>  specify the full list of supported screen orientations in the root or full-screen controller </li><li>  in child controllers to implement support for all necessary orientations </li></ul><br>  However, what to do if it is necessary to migrate (preferably with minimal effort) on iOS 6 an already existing project, in which decisions about turns are made by different end controllers?  Using the <i>supportedInterfaceOrientations</i> / <i>shouldAutorotate methods</i> next to <i>shouldAutorotateToInterfaceOrientation</i> will not save the situation if these controllers are not root and not top-most full-screen.  To force the controller-containers to listen to the opinion of controlled ones, you can use the following approaches. <br><br>  <b>1. Category.</b> <br>  Using the category, redefine new methods so that the corresponding top controllers are polled for rotation.  For example, for a UINavigationController this might look like this: <br><br><pre> <code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UINavigationController</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RotationIOS6</span></span></span><span class="hljs-class">) -(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BOOL</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shouldAutorotate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.topViewController shouldAutorotate]; } -(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)supportedInterfaceOrientations { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.topViewController supportedInterfaceOrientations]; } - (<span class="hljs-built_in"><span class="hljs-built_in">UIInterfaceOrientation</span></span>)preferredInterfaceOrientationForPresentation { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.topViewController preferredInterfaceOrientationForPresentation]; } <span class="hljs-keyword"><span class="hljs-keyword">@end</span></span></code> </pre> <br><br>  <b>2. Inheritance.</b> <br>  Implement the same as in clause 1, but by inheriting from UINavigationController - when there is no need to globally expose all UINavigationControllers at once. <br><br><pre> <code class="hljs perl">// CustomNavigationController.h @interface CustomNavigationController : UINavigationController @end</code> </pre><br><br><pre> <code class="hljs pgsql">// CustomNavigationController.m #<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> "CustomNavigationController.h" @implementation CustomNavigationController -(<span class="hljs-type"><span class="hljs-type">BOOL</span></span>)shouldAutorotate { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [self.topViewController shouldAutorotate]; } -(NSUInteger)supportedInterfaceOrientations { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [self.topViewController supportedInterfaceOrientations]; } - (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [self.topViewController preferredInterfaceOrientationForPresentation]; } @<span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br>  <b>3. Method swizzling.</b> <br>  For runtime lovers and hardcore fans - using <a href="http://en.wikipedia.org/wiki/Pointer_swizzling">swizzling</a> , override new methods so as to actually use the calls to the old usual method <i>shouldAutorotateToInterfaceOrientation:.</i> <br><br>  (code taken <a href="https://gist.github.com/3725118">from here</a> ) <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@implementation</span></span> AppDelegate void SwapMethodImplementations(Class cls, SEL left_sel, SEL right_sel) { Method leftMethod = class_getInstanceMethod(cls, left_sel); Method rightMethod = class_getInstanceMethod(cls, right_sel); method_exchangeImplementations(leftMethod, rightMethod); } + (void)initialize { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self == [AppDelegate <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">]) </span></span>{ #ifdef __IPHONE_6_0 SwapMethodImplementations([UIViewController <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">], </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">@selector</span></span></span></span>(supportedInterfaceOrientations), <span class="hljs-meta"><span class="hljs-meta">@selector(sp_supportedInterfaceOrientations)</span></span>); SwapMethodImplementations([UIViewController <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">], </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">@selector</span></span></span></span>(shouldAutorotate), <span class="hljs-meta"><span class="hljs-meta">@selector(sp_shouldAutorotate)</span></span>); #endif } } <span class="hljs-meta"><span class="hljs-meta">@end</span></span> <span class="hljs-meta"><span class="hljs-meta">@implementation</span></span> UIViewController (iOS6Autorotation) #ifdef __IPHONE_6_0 <span class="hljs-comment"><span class="hljs-comment">/* * We've swizzled the new iOS 6 autorotation callbacks onto their iOS 5 and iOS 4 equivalents * to preserve existing functionality. * */</span></span> - (BOOL)sp_shouldAutorotate { BOOL shouldAutorotate = YES; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([self respondsToSelector:<span class="hljs-meta"><span class="hljs-meta">@selector(shouldAutorotateToInterfaceOrientation:)</span></span>]) { NSUInteger mask = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([self shouldAutorotateToInterfaceOrientation:UIInterfaceOrientationPortrait]) { mask |= UIInterfaceOrientationMaskPortrait; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([self shouldAutorotateToInterfaceOrientation:UIInterfaceOrientationLandscapeLeft]) { mask |= UIInterfaceOrientationMaskLandscapeLeft; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([self shouldAutorotateToInterfaceOrientation:UIInterfaceOrientationLandscapeRight]) { mask |= UIInterfaceOrientationMaskLandscapeRight; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([self shouldAutorotateToInterfaceOrientation:UIInterfaceOrientationPortraitUpsideDown]) { mask |= UIInterfaceOrientationMaskPortraitUpsideDown; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mask == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Shouldn't autorotate to *any* orientation. shouldAutorotate = NO; } } else { // This actually calls the original method implementation // instead of recursively calling into this method implementation. shouldAutorotate = [self sp_shouldAutorotate]; } return shouldAutorotate; } - (NSUInteger)sp_supportedInterfaceOrientations { NSUInteger mask = 0; /* * In iOS 6, Apple dramatically changed the way autorotation works. * Rather than having each view controller respond to shouldAutorotateToInterfaceOrientation: * to specify whether or not it could support a particular orientation, the responsibility was * shifted to top-level container view controllers. That means UINavigationController becomes * responsible for declaring whether or not an orientation is supported. Since our app * has logic for how to autorotate on a per view controller basis, we call through to the * swizzled version of supportedInterfaceOrientations for the topViewController. * */ if ([self isKindOfClass:[UINavigationController class]]) { return [[(UINavigationController *)self topViewController] supportedInterfaceOrientations]; } if ([self respondsToSelector:@selector(shouldAutorotateToInterfaceOrientation:)]) { if ([self shouldAutorotateToInterfaceOrientation:UIInterfaceOrientationPortrait]) { mask |= UIInterfaceOrientationMaskPortrait; } if ([self shouldAutorotateToInterfaceOrientation:UIInterfaceOrientationLandscapeLeft]) { mask |= UIInterfaceOrientationMaskLandscapeLeft; } if ([self shouldAutorotateToInterfaceOrientation:UIInterfaceOrientationLandscapeRight]) { mask |= UIInterfaceOrientationMaskLandscapeRight; } if ([self shouldAutorotateToInterfaceOrientation:UIInterfaceOrientationPortraitUpsideDown]) { mask |= UIInterfaceOrientationMaskPortraitUpsideDown; } } else { // This actually calls the original method implementation // instead of recursively calling into this method implementation. mask = [self sp_supportedInterfaceOrientations]; } return mask; } #endif @end</span></span></code> </pre> <br>  In this case, no changes to the existing code will be required at all - the runtime magic will do its job.  However, no matter how tempting it looks, <u><b>this code is not strongly recommended for use</b></u> <b><a href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c">(find out why)</a></b> . <br><br>  In my case, it was most convenient to use categories. <br><br>  I hope the material presented is useful to someone and will help save the most valuable developer resource - time :) <br><br>  <u>Useful links:</u> <br><ul><li>  <a href="http://developer.apple.com/library/ios/">View Controller Programming Guide for iOS</a> </li><li>  <a href="http://adcdownload.apple.com//wwdc_2012/wwdc_2012_session_pdfs/236__the_evolution_of_view_controllers_on_ios.pdf">WWDC 2012, Session 236 "View Controller Evolution"</a> </li><li>  <a href="http://cocoadev.com/wiki/MethodSwizzling">Method Swizzling</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/155969/">https://habr.com/ru/post/155969/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../155957/index.html">Mobile applications for iOS and Android on php</a></li>
<li><a href="../155959/index.html">Development through suffering</a></li>
<li><a href="../155961/index.html">Scaling Windows Azure Queues</a></li>
<li><a href="../155963/index.html">Each data center has its own constructor</a></li>
<li><a href="../155967/index.html">Acer Iconia Tab A701 - Return of the Jedi</a></li>
<li><a href="../155971/index.html">Soviet radio "Micro" 1965</a></li>
<li><a href="../155973/index.html">RFID tag on simple logic</a></li>
<li><a href="../155977/index.html">TCP Testing with Linear Network Coding (TCP / NC)</a></li>
<li><a href="../155981/index.html">ASUS UX31A Review</a></li>
<li><a href="../155983/index.html">Iron Renaissance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>