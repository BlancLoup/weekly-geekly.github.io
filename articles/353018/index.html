<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unit testing interfaces in Headless Chrome. Yandex lecture</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="To continuously improve large client interfaces, you need a powerful system of autotests. Yandex developer Dmitry Andriyanov dima117 knows something a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unit testing interfaces in Headless Chrome. Yandex lecture</h1><div class="post__text post__text-html js-mediator-article">  To continuously improve large client interfaces, you need a powerful system of autotests.  Yandex developer Dmitry Andriyanov <a href="https://habrahabr.ru/users/dima117/" class="user_link">dima117</a> knows something about it - a couple of months ago, he shared his experience on <a href="https://events.yandex.ru/events/yasubbotnik/20-Jan-2018/">J. Subbotnik</a> in Nizhny Novgorod. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/jUycQRFoOww" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Today I will tell you how we, in Direkt, write unit tests on the web interface.  We will generally see how the interface tests differ from other tests.  Consider two approaches to writing tests: using Selenium and using Headless browsers.  And at the end I will show the tool that we wrote in Directive for running tests in Headless Chrome. <br><a name="habracut"></a><br>  This is Direct - such an admin for advertisements. <br><br><img src="https://habrastorage.org/webt/oj/hp/id/ojhpidhjaewpfs81zehlxe4shhi.jpeg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And this is the second largest project in Yandex after Search.  For example, we have 16 people in the front-end team.  All my previous jobs had a maximum of four.  Why are there so many people?  You just entered the ad, the key phrases - what are all these people doing there? <br><br>  Direct is a very complex subject area.  This is a typical ad for the sale of elephants.  I highlighted one small block in red with additional links. <br><br><img src="https://habrastorage.org/webt/me/xu/_f/mexu_fnaakvz9eyrjk4c5-bmewo.png" width="700"><br><br>  In the Yandex interface, the form with the block settings looks like this: <br><br><img src="https://habrastorage.org/webt/lg/xd/yf/lgxdyf3pabmqo0nfjgdkwherwws.jpeg"><br><br>  There are ad previews, several fields for each link, and they are also hung with complex validation, to the extent that a special piece on the server taps the link that you entered and checks that it opens at all.  There is a lot of other logic there, and this form is just for one small block, and there are many blocks in the declaration. <br><br>  And it was only one type of ad - a text ad.  There are many other types.  In addition, we are now talking only about the display settings.  There are still many other settings that determine when and to whom this ad should show. <br><br>  In general, this picture is obtained. <br><br><img src="https://habrastorage.org/webt/fj/7-/ip/fj7-ippepkyrvqyxzf5ssqygedw.png" width="700"><br><br>  The ads that you see on the site or in the search have a lot of settings and a very complex interface with which they are created.  To implement this complex interface, a lot of code has been written.  We use BEM-stack in Direct.  The project is divided into blocks, and these blocks in the project are about 800. If you write on React, imagine a project with 800 React components.  This is a very big project!  I tried to measure the list of files in Web Storm, I got a height of 20 screens.  You see, this is a lot of code. <br><br><img src="https://habrastorage.org/webt/nx/zh/li/nxzhlilp0be3ngm8okfhzceh8zw.jpeg"><br><br>  The project is constantly changing, these 16 developers make dozens of commits daily there, constantly adding new features.  And we need to somehow check that when you add a new feature to the project, it does not break anything.  If the project were small, it could have been done with the help of manual testers: they added a feature - they tested it and made it into production.  And since our project is very large, we cannot afford to retest it every time. <br><br>  We write autotests for everything.  There are about 7,000 unit tests in the project, we run them on every commit, and they make sure that nothing is broken. <br><br>  When you have a very large project, auto tests are not just a nice addition, which sometimes helps to find errors.  This is a necessary working tool, without which you can not work.  You will drown in the number of bugs that appear in the code. <br><br>  This is an example of tests when you are testing some kind of logic, some kind of class or function. <br><br><img src="https://habrastorage.org/webt/tg/ta/f-/tgtaf-zauka6zh8fqevexsqg6vy.jpeg"><br><br>  First, you do some preparatory actions, then an action that needs to be checked, and at the end you compare the result of this action with the expected one.  If not as expected, then the test has dropped. <br><br>  How to write tests on the interface, on all sorts of buttons?  Similar! <br><br><img src="https://habrastorage.org/webt/ar/p_/1w/arp_1wyvcc23kasbzk0mkps-ifs.jpeg"><br><br>  We first render something on the page, then do the action that needs to be checked, for example, enter a value and click on the button, and at the end check that, for example, a request was sent to the server with the correct parameters or in the right place on the form An error message was displayed.  The sequence of actions is the same as when writing ordinary logic tests. <br><br>  What is the problem with this scheme?  These tests all need a browser.  This is a program with a graphical interface, where the user enters something from the keyboard, clicks on the buttons, and the result of any browser is the pixels drawn on the screen.  We have autotests, we want to run them automatically, without human intervention.  For tests on the interface, we need a browser, and this is not suitable for us. <br><br>  What can be done?  There are two ways to solve this problem.  The first is to use some kind of browser control tool.  Selenium is such a thing that does the same actions as the user in the browser, but you can control these actions programmatically, it will do them automatically.  The second way is to use Headless browsers.  Very popular - PhantomJS.  He died, but still very popular. <br><br>  When you use Selenium or another similar browser management tool, the scheme will be something like this. <br><br><img src="https://habrastorage.org/webt/cn/eg/k_/cnegk_ati56afjnymhzt2b3b15o.png" width="700"><br><br>  This notebook with checkmarks is a test run, it is similar to the code that you saw on the screen, and it gives commands to a special piece called the ‚ÄúSelenium web driver‚Äù.  This is a software library that provides an API to control the browser.  There are commands ‚Äúopen the page‚Äù, ‚Äúclick on the button‚Äù, ‚Äúenter text in the input field‚Äù and so on. <br><br>  Selenium web driver starts somewhere, on this machine or on a remote, real browser, a window will be drawn there, and the actions that need to be performed in the test will be automatically executed in it.  In this case, the browser will be unavailable to the user.  There will be a message that the browser is controlled by automated software and nothing can be done in this window.  This approach is similar to the usual test by the tester, only the commands are given not by the person, but by your test.  The test code here will look something like this. <br><br><img src="https://habrastorage.org/webt/ya/cw/ic/yacwic5zvjlzij_lai4t8oen5bo.jpeg"><br><br>  There is a variable browser.  In different frameworks, it may be called differently, but the essence is the same: you have an object with which you access the Selenium API of the web driver.  Preparing, verifiable actions, verification - there are all the same actions that were on the slide about testing functions / classes.  You just tell the browser what to do. <br><br>  What are the benefits of this approach?  First, the Selenium web driver provides the same way to control different browsers.  For example, you use it to test in Firefox and Chrome.  Then you were told to run tests in IE or in mobile Safari.  You add IE8 in the settings, and the tests start running in IE.  You do not need to edit the test code.  The uniformity of browser management is a big plus. <br><br>  The second plus is scalability.  In the scheme I showed, the third component is the browser.  It can be located not only on the computer where the tests are running, but also on the other.  And what's more, you can add more computers with browsers to this scheme, and at once drive a lot of tests into them in parallel.  This is very useful when you have hundreds or thousands of tests, and on the same computer they, for example, run for an hour and a half, and you added 10 computers or launched in the cloud, and they take you 10 minutes to complete.  This is a very good way to speed up your tests, and you can do it very easily.  This scheme scales very well. <br><br>  This approach works well, it is actively used in the search, because they have a large audience with different browsers. <br><br>  How to run tests using Selenium? <br><br><img src="https://habrastorage.org/webt/48/kq/f6/48kqf6vug0hsb5s-lswz6xtfaho.jpeg"><br><br>  The guys from the Search wrote a special tool - <a href="https://habrahabr.ru/company/yandex/blog/346608/">"Hermione"</a> .  This is not just a test run, there are many possibilities.  But first of all, it is a tool that runs tests in Selenium in a heap of browsers. <br><br><img src="https://habrastorage.org/webt/lc/ad/8x/lcad8xpa8hm5mlznorbxvpjlamo.jpeg"><br><br>  On the slide - npm packages.  Nightwatch knows about the same thing as Hermione, their possibilities are slightly different, you can watch these two things and choose what you like. <br><br>  Testing in Selenium is a good approach, it works, many people use it.  But he has one significant limitation. <br><br>  You cannot write unit tests.  Only integration.  What is the difference between unit tests and integration tests? <br><br><img src="https://habrastorage.org/webt/sm/db/zm/smdbzmwskvqxemis43nc2j9a_vs.jpeg"><br><br>  Integration tests check everything in the collection.  Your interface element under test can use other interface elements inside, for example, you are testing a form, it uses buttons, input fields, nested forms.  And it can have external APIs in dependencies, for example, it can download something from the network, download from some storage, system time is also an external dependency.  Integration tests are testing everything in a heap, they say: to render the forms on the page with all the pieces, to do some actions there. <br><br>  Unit tests test an element in isolation from its dependencies.  They put a stub on each arrow on the diagram, and the dependency code is not executed during the test.  Instead, the small stub code is executed.  He slips the data to be checked for the test block. <br><br>  Each approach solves its problem.  We in the Directive are exactly the unit tests.  Because we have very complex blocks with very complex logic and it is very difficult to check them with integration tests.  They need to submit a large sheet of data at the entrance, prepare the data for all the dependencies of the block.  If something breaks inside, it's hard to understand where it broke.  And integration tests are slow. <br><br>  We have integration tests, but there are many places where you need to write unit tests, test a separate unit, without this tail. <br><br><img src="https://habrastorage.org/webt/hw/c0/k8/hwc0k8gkkdboxbfkj5_gigfttui.jpeg"><br><br>  What happens in Selenium?  At the bottom of the file with the code that runs in the scheme.  On the left, where the test runs, the code of our tests is executed, and on the right, where the browser is, the test page code and the code we are testing are executed.  Between them is a layer in the form of Selenium, and the test code does not have direct access to the code that it is testing.  The test code cannot put all stubs in order to isolate the test code from dependencies.  It can interact only with the Selenium API, click something.  He can perform some kind of JS, but still he does not have direct access.  Because of this, you cannot write unit tests. <br><br>  Alternatively, it would be possible to transfer this test code to the browser side and report the data on how the tests go to the test run, so that it displays its checkmarks and crosses.  But with Selenium we cannot do this, because this API is one way.  You can ask the browser for something from the test, but you cannot send something from the browser to the program that controls it. <br><br>  Conclusion: we need modular tests in Direkt, but we cannot use the approach from Selenium for unit tests, only for integration tests. <br><br>  Let's take a look at the second approach - testing in Headless browsers. <br><br>  Headless browsers are the same as regular browsers, but during their work they do not display anything on the screen.  You can launch the Headless browser as a console application.  There the page will be opened inside, all CSS, JS will be executed, but you will not see anything on the screen. <br><br>  In this case, you can control the browser only through some API, it does not have any user interface.  This is similar to Selenium and the browser in one bottle, but the API is implemented inside the browser itself, it is not a separate external component. <br><br><img src="https://habrastorage.org/webt/8q/ah/c_/8qahc_u0p0pt3kief_popc5f8ig.jpeg"><br><br>  It turns out, the API has access to the internals of the browser.  Headless browsers APIs provide, as a rule, a much larger set of features than Selenium.  In particular, there you can listen to browser events like page load, page error, you can intercept requests to the network, intercept output to the console and much more.  These things make it possible for the variant I was talking about: transfer the test code to the browser side so that it sends information about how the tests go to the test runner.  This approach is also very popular, many need unit tests.  We have been using it for about three years. <br><br>  Until recently, the only browser that worked fine was PhantomJS. <br><br>  It had drawbacks - memory is flowing and it is difficult to join the debugger in order to debug tests - but in principle, this is a normal working browser.  He has a webkit inside, it all works, we used it for two years. <br><br><img src="https://habrastorage.org/webt/fd/it/6l/fdit6lzbgai6ki33odgf8za9fv8.jpeg"><br><br>  This is a screenshot from Google Groups, there the last PhantomJS developer Vitaly Slobodin says something like this: ‚Äúsoon there will be Headless Chrome, it works better, it does not eat memory like crazy, so I will not develop PhantomJS, switch to Chrome‚Äù.  We also began to look at Chrome and switched to it. <br><br>  This is the tool logo called Puppeteer - for managing Chrome in Headless mode.  Puppeteer (translated as "puppeteer") is developed by the Chrome Dev Tools team, there is some confidence that they will not abandon his support.  This is the NodeJS package, it has the JS API, and the coolest is that it puts Chrome along with it as a dependency.  You do not need to separately install the browser in order to run something in it.  You wrote npm install - and it all worked right away. <br><br><img src="https://habrastorage.org/webt/8b/e4/x2/8be4x2pzkfvrbowvcvlxyd2gkam.jpeg"><br><br>  We looked in his direction, tried it, we liked it.  The only problem was that there were no tools to cross our tests and Headless Chrome.  For PhantomJS such tools were, since it has existed for a long time, and Headless Chrome only appeared, there were no tools. <br><br>  We wrote our mocha-headless-chrome tool. <br><br><img src="https://habrastorage.org/webt/l5/0y/au/l50yauofmh9qkcvr2datugw3raw.jpeg"><br><br>  We have less fantasy than in the Search: their tool is called ‚ÄúHermione‚Äù, and ours is ‚Äúmocha-headless-chrome‚Äù.  We use it for half a year, it works.  For example, a small project will show how this happens.  (A demo from the report <a href="https://github.com/dima117/headless-testing-demo">is here</a> - ed.) <br><br>  In the test project, one file is test-form.js.  It is easy to guess that this is a search form, there is an input and a button.  The SearchForm class, it has a render method, almost like in React, and it adds a form, an input and a button to the page.  In addition, he subscribes to a click on the button, and when you click on the button, he makes an Ajax request, sends the contents of the form to example.com, and then he cleans the form. <br><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SearchForm</span></span></span><span class="hljs-class"> </span></span>{ onClick(e) { e.preventDefault(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); xhr.open(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-string"><span class="hljs-string">"http://example.com"</span></span>); xhr.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FormData(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.form)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.form.reset(); } render(parent) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.form = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'form'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.form.innerHTML = <span class="hljs-string"><span class="hljs-string">`&lt;input type="text" name="query" /&gt; &lt;input type="button" value="" /&gt;`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.input = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.form.querySelector(<span class="hljs-string"><span class="hljs-string">'input[type=text]'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.button = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.form.querySelector(<span class="hljs-string"><span class="hljs-string">'input[type=button]'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.button.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onClick.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); parent.appendChild(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.form); } destroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.form.remove(); } }</code> </pre> <br>  Let's write for this simple test.  The folder tests, in it file test.js.  While there are no tests here, just describe and the action that needs to be performed before each test and after. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> assert = chai.assert; describe(<span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> searchForm, server; beforeEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ searchForm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SearchForm(); searchForm.render(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body); server = sinon.createFakeServer({ <span class="hljs-attr"><span class="hljs-attr">respondImmediately</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }); }); afterEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ searchForm.destroy(); server.restore(); }); });</code> </pre> <br>  Before each test we add our form to the page, and after each test we delete it. <br><br>  Also, before each test we make a stub for Ajax requests, so that the test can check which requests are made.  And after each test, we reset this stub - remove it. <br><br>  We wrote a file of our tests, JS, there are no tests there yet, we will write soon. <br><br>  But first, let's make a test page that will open in the browser. <br><br>  In the tests folder, I make a file test.html.  There is nothing complicated here, we are connecting three libraries, Mocha is a test framework, I think everyone is familiar with it.  Sinon is a library that allows you to automatically create all sorts of stubs to isolate our block from its dependencies.  And the chai library with all kinds of assertions, it gives an API for various checks in tests. <br><br><pre> <code class="javascript hljs">&lt;html&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">head</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">meta</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">charset</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"utf-8"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">link</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"../node_modules/mocha/mocha.css"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">rel</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"stylesheet"</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"../node_modules/mocha/mocha.js"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="undefined"></span><span class="hljs-tag"><span class="xml"><span class="undefined"></span><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"../node_modules/sinon/pkg/sinon.js"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="undefined"></span><span class="hljs-tag"><span class="xml"><span class="undefined"></span><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"../node_modules/chai/chai.js"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="undefined"></span><span class="hljs-tag"><span class="xml"><span class="undefined"></span><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="actionscript"><span class="xml"><span class="actionscript">mocha.setup(</span></span><span class="hljs-string"><span class="xml"><span class="actionscript"><span class="hljs-string">'bdd'</span></span></span></span><span class="xml"><span class="actionscript">);</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">head</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">body</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"mocha"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"../src/search-form.js"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="undefined"></span><span class="hljs-tag"><span class="xml"><span class="undefined"></span><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"../tests/test.js"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="undefined"></span><span class="hljs-tag"><span class="xml"><span class="undefined"></span><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="undefined"><span class="xml"><span class="undefined">mocha.run();</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">body</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">html</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  We connected these three libraries, further connected the code of our form, the search-form, and connected our test file we just created.  In the end, they called the mocha-run command to start the tests. <br><br>  Run the page in the browser and make sure that everything is ok.  The page has opened, there are zero tests in it, which is expected.  Let's write a couple of tests.  The test checks that when we clicked the button, an Ajax request to the correct address was sent to the server.  This is the searchForm we created at the beginning.  The test fills the form with data, then clicks on the button, then with the help of a stub in the server variable it checks that the last request made had the desired url. <br><br><pre> <code class="javascript hljs"> it(<span class="hljs-string"><span class="hljs-string">'  '</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  searchForm.input.value = ''; //  searchForm.button.click(); //  assert.equal(server.lastRequest.url, 'http://example.com'); });</span></span></code> </pre> <br>  Let's see the page in the browser, it has been updated, and we see that one test has passed.  The browser has code that makes an Ajax request.  We put a stub on it so that it did not make this request during the test, and checked that the request was made with the correct parameters. <br><br>  Let's run it all in Headless Chrome. <br><br>  npm install mocha-headless-chrome <br><br>  I add the test command to package.json so that I do not write every time.  When you install the mocha-headless-chrome package, it adds a utility with the same name.  It needs to pass the parameter -f - the path to our test page, which we opened in the browser. <br><br><pre> <code class="hljs objectivec">{ ... <span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-string"><span class="hljs-string">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"mocha-headless-chrome -f tests/test.html"</span></span> }, ... }</code> </pre> <br>  Now, if I run the npm test now, everything should work. <br><br>  We set the dependency, it downloaded Chrome itself, put it locally in the node_modules folder.  Then we just call it by name as a console application and pass a test page via the f parameter.  The test passed, this is our test that we wrote. <br><br>  Let's try to add another test that verifies that after sending an Ajax request, we cleared the value in the search form. <br><br><pre> <code class="javascript hljs"> it(<span class="hljs-string"><span class="hljs-string">'   '</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  searchForm.input.value = ''; //  searchForm.button.click(); //  assert.equal(searchForm.input.value, ''); });</span></span></code> </pre> <br>  In the browser, check that it appeared.  Next, run it in the terminal.  We had two tests, and when they were executed, you did not see any browser window.  The person who starts it, did nothing with his hands, everything goes completely automatically. <br><br>  We use this tool for about six months.  7000 tests that previously worked in PhantomJS, without any problems began to work in Headless Chrome.  Test execution accelerated by 30%.  This thing is available in external npm, you can also take it and use it.  There are already 5000 downloads per month, that is, there are people outside of Yandex who use it. </div><p>Source: <a href="https://habr.com/ru/post/353018/">https://habr.com/ru/post/353018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353008/index.html">Overview of cases of interesting Big Data implementations in financial sector companies</a></li>
<li><a href="../353010/index.html">N + 6 useful books</a></li>
<li><a href="../353012/index.html">Do I need to collect NAS?</a></li>
<li><a href="../353014/index.html">Introducing the new dialog item</a></li>
<li><a href="../353016/index.html">More than a state: British East India Trading Company</a></li>
<li><a href="../353020/index.html">Check incoming data. The root cause of the vulnerability and attacks on Cisco IOS</a></li>
<li><a href="../353022/index.html">Metalsmith static site generator</a></li>
<li><a href="../353024/index.html">Operating systems from scratch; level 2 (upper half)</a></li>
<li><a href="../353026/index.html">"Japan - Guam - Australia": Google is laying a new submarine cable</a></li>
<li><a href="../353028/index.html">Another example of automation or PowerShell + Google Apps Script</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>