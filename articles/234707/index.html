<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using Stream Out-stages for debugging shaders in DirectX 10 \ 11</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In early March, I had the pleasure of visiting the Direct3D development team at Microsoft‚Äôs headquarters in Redmond. In the course of one of the discu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using Stream Out-stages for debugging shaders in DirectX 10 \ 11</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/e83/309/27b/e8330927b298493a884ed89dd0c9196f.gif" align="right"><br>  In early March, I had the pleasure of visiting the Direct3D development team at Microsoft‚Äôs headquarters in Redmond.  In the course of one of the discussions about debugging 3D applications, they advised me to use the new DirectX10 \ 11 feature to debug shaders. <br><br>  I used this technique to debug tessellation code under DirectX 11 (this code is shown below), but DirectX 10 has the same features and porting will be quite trivial. <br><br><h5>  What are we trying to do? </h5><br>  We are interested in obtaining the results of the work of shaders (vertex, geometry, tessellation) performed on the GPU for the subsequent processing of this data using the CPU.  In this case, we want to see the results of rendering graphics on the screen, and have all the coordinates in the form of buffers and structures in the RAM, from where we can already read them, write to the log, use them for further calculations. <br><a name="habracut"></a><br><h5>  Let's get down to business </h5><br>  You need to perform 4 basic steps: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Modify your shaders</b> <br>  We need to add additional fields to the shader output that we want to receive.  For example, in the normal state, your shader may not output world-space coordinates, but for debug output via the Stream Out-stage you can add them. <br><br>  <b>Change the way to create a geometric shader</b> <br>  Constructing an ID3D11GeometryShader (or ID3D10GeometryShader) and adding it to the pipeline will be different. <br><br>  <b>Buffer to get output</b> <br>  It is quite logical - you also need to store the results somewhere. <br><br>  <b>Decipher results</b> <br>  The received data in the buffer is an array of structures, each of which contains information about the vertex in a specific shader format.  The easiest way to decode a buffer is to declare a structure in the same format, and then bring a pointer to the beginning of the buffer to a pointer to an array of the above structures. <br><br>  So, we modify the shaders <br><br>  As you may know, Direct3D supports the ‚Äúpass forward‚Äù mechanism.  This means that the results of the withdrawal of the previous stage of the pipeline are transmitted to the next stage (and no longer return back).  Thus, if you want to display some additional data from the vertex shader, you will have to ‚Äústretch‚Äù them through the HS / DS / GS pipeline line. <br><br>  Let's look at such a geometric shader: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DS_OUTPUT</span></span></span><span class="hljs-class"> {</span></span> float4 position : SV_Position; float3 colour : COLOUR; float3 uvw : DOMAIN_SHADER_LOCATION; float3 wPos : WORLD_POSITION; }; [maxvertexcount(<span class="hljs-number"><span class="hljs-number">3</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gsMain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( triangle DS_OUTPUT input[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">], inout TriangleStream&lt;DS_OUTPUT&gt; TriangleOutputStream )</span></span></span><span class="hljs-function"> </span></span>{ TriangleOutputStream.Append( input[<span class="hljs-number"><span class="hljs-number">0</span></span>] ); TriangleOutputStream.Append( input[<span class="hljs-number"><span class="hljs-number">1</span></span>] ); TriangleOutputStream.Append( input[<span class="hljs-number"><span class="hljs-number">2</span></span>] ); TriangleOutputStream.RestartStrip(); }</code> </pre> <br><br>  This geometric shader is completely ‚Äútransparent‚Äù - it simply redirects the input to the output.  Pay attention to the DS_OUTPUT structure - later we will choose which elements of this structure we want to receive. <br><br>  It should be noted that your pixel shaders do not require changes.  In the example above, the pixel shader will receive only the second parameter of the structure - float3 color: COLOR and ignore all other parameters.  Thus, we will use the simplest idea: all new fields that we want to bring to the Stream Out-stages will simply be added to the end of the DS_OUTPUT structure. <br><br>  Now we modify the procedure for creating a geometric shader.  You need to call the CreateGeometryShaderWithStreamOutput () method instead of CreateGeometryShader (), passing to it the D3D11_SO_DECLARATION_ENTRY structure (or D3D10_SO_DECLARATION_ENTRY - depending on which version of DirectX you are using) describing the vertex format. <br><br><pre> <code class="cpp hljs">D3D11_SO_DECLARATION_ENTRY soDecl[] = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"COLOUR"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> } , { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"DOMAIN_SHADER_LOCATION"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> } , { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"WORLD_POSITION"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> } }; UINT stride = <span class="hljs-number"><span class="hljs-number">9</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>); <span class="hljs-comment"><span class="hljs-comment">// *NOT* sizeof the above array! UINT elems = sizeof(soDecl) / sizeof(D3D11_SO_DECLARATION_ENTRY);</span></span></code> </pre><br><br>  It is necessary to pay attention to three things: <br><ol><li>  Semantic names: they must correspond to be written in the HLSL code of your shader.  Please note - in the structure above, we select three fields from the four declared in the geometric shader. </li><li>  The initial element and the number of elements: for the data type float3, we want to get all three coordinates, starting with zero, respectively, the initial element is 0, the number is 3. </li><li>  Step (offset) between two adjacent vertices: calling CreateGeometryShaderWithStreamOutput () requires knowing the size of the structure that describes the vertex.  It‚Äôs not so difficult to calculate, but you can make a mistake and transfer the size of the soDecl structure, which will be wrong. </li></ol><br><br>  Now you need to create a buffer to get the results.  It is created in much the same way as you create vertex and index buffers.  We need two buffers - one available for writing from the GPU, the second - available for reading from the CPU. <br><br><pre> <code class="cpp hljs">D3D11_BUFFER_DESC soDesc; soDesc.BindFlags = D3D11_BIND_STREAM_OUTPUT; soDesc.ByteWidth = <span class="hljs-number"><span class="hljs-number">10</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 10mb soDesc.CPUAccessFlags = 0; soDesc.Usage = D3D11_USAGE_DEFAULT; soDesc.MiscFlags = 0; soDesc.StructureByteStride = 0; if( FAILED( hr = g_pd3dDevice-&gt;CreateBuffer( &amp;soDesc, NULL, &amp;g_pStreamOutBuffer ) ) ) { /* handle the error here */ return hr; } // Simply re-use the above struct soDesc.BindFlags = 0; soDesc.CPUAccessFlags = D3D11_CPU_ACCESS_READ; soDesc.Usage = D3D11_USAGE_STAGING; if( FAILED( hr = g_pd3dDevice-&gt;CreateBuffer( &amp;soDesc, NULL, &amp;g_pStagingStreamOutBuffer ) ) ) { /* handle the error here */ return hr; }</span></span></code> </pre><br><br>  You cannot call the Map () method on a buffer created with the D3D11_USAGE_DEFAULT flag and you cannot bind the buffer with the D3D11_CPU_ACCESS_READ flag to the Stream Out stage of the pipeline, so you create one buffer of each type and copy data from one to another. <br><br>  Now bind the buffer to the Stream Out-stage: <br><br><pre> <code class="cpp hljs">UINT offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; g_pContext-&gt;SOSetTargets( <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;g_pStreamOutBuffer, &amp;offset );        : g_pContext-&gt;CopyResource( g_pStagingStreamOutBuffer, g_pStreamOutBuffer ); D3D11_MAPPED_SUBRESOURCE data; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( SUCCEEDED( g_pContext-&gt;Map( g_pStagingStreamOutBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, D3D11_MAP_READ, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;data ) ) ) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GS_OUTPUT</span></span></span><span class="hljs-class"> {</span></span> D3DXVECTOR3 COLOUR; D3DXVECTOR3 DOMAIN_SHADER_LOCATION; D3DXVECTOR3 WORLD_POSITION; }; GS_OUTPUT *pRaw = <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt; GS_OUTPUT* &gt;( data.pData ); <span class="hljs-comment"><span class="hljs-comment">/* Work with the pRaw[] array here */</span></span> <span class="hljs-comment"><span class="hljs-comment">// Consider StringCchPrintf() and OutputDebugString() as simple ways of printing the above struct, or use the debugger and step through. g_pContext-&gt;Unmap( g_pStagingStreamOutBuffer, 0 ); }</span></span></code> </pre><br><br>  All of the above must be done after drawing is called.  You need to be careful with the structure to which you are converting the contents of the buffer (take alignment into account). <br><br>  How much data is received?  We can write code using the D3D11_QUERY_PIPELINE_STATISTICS query to find out. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// When initializing/loading D3D11_QUERY_DESC queryDesc; queryDesc.Query = D3D11_QUERY_PIPELINE_STATISTICS; queryDesc.MiscFlags = 0; if( FAILED( hr = g_pd3dDevice-&gt;CreateQuery( &amp;queryDesc, &amp;g_pDeviceStats ) ) ) { return hr; } // When rendering g_pContext-&gt;Begin(g_pDeviceStats); g_pContext-&gt;DrawIndexed( 3, 0, 0 ); // one triangle only g_pContext-&gt;End(g_pDeviceStats); D3D11_QUERY_DATA_PIPELINE_STATISTICS stats; while( S_OK != g_pContext-&gt;GetData(g_pDeviceStats, &amp;stats, g_pDeviceStats-&gt;GetDataSize(), 0 ) );</span></span></code> </pre><br><br><h5>  Any restrictions? </h5><br><br>  Unfortunately yes. <br><br><ul><li>  The performance of this whole business is not very high.  Still, we have to copy data from video memory to RAM, which is not very fast.  It must, however, be remembered that all this is a debugging mechanism and most likely it will not be used in the production code. </li><li>  This trick does not work for pixel shaders.  The pixel shader in the pipeline is already after the Stream Out-stage. </li><li>  This technique requires changing shaders - i.e.  code base of your project.  You will have to either use different shaders in debug and release builds, or accept a slight drop in performance in the release. </li><li>  We are tied to the main pipeline - we can not get the information we need neither more nor less often than every frame is drawn. </li><li>  There are some restrictions on the total size of the data structure that describes the vertex format ‚Äî for DirectX10, these are 64 scalar values ‚Äã‚Äãor 2 KB of vector data. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/234707/">https://habr.com/ru/post/234707/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../234695/index.html">Lucidchart vs Visio</a></li>
<li><a href="../234697/index.html">How to quickly run voluntary distributed computing on a hundred machines</a></li>
<li><a href="../234701/index.html">Launch the 64-bit version of Chrome for Windows</a></li>
<li><a href="../234703/index.html">Adjail for all: how to make an accountant be flexible</a></li>
<li><a href="../234705/index.html">A $ 25 mini-lab was created at Harvard to identify a number of diseases.</a></li>
<li><a href="../234709/index.html">The beta version of Unity3D 4.6, new advertising opportunities from Google and the sale of a game studio for 1 billion - the main mobile news for the week</a></li>
<li><a href="../234713/index.html">64-bit Chrome released</a></li>
<li><a href="../234715/index.html">How we built the engineering infrastructure for Phistech data center</a></li>
<li><a href="../234717/index.html">New Life Telebreeze Player</a></li>
<li><a href="../234719/index.html">Metasploit Secrets</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>