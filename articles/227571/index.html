<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Testing in Yandex. What we learned about the Appium framework, and whether it can be used for serious tasks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the world of software testing, a very young direction is gaining momentum - automating the testing of mobile applications. And it is expected that ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Testing in Yandex. What we learned about the Appium framework, and whether it can be used for serious tasks</h1><div class="post__text post__text-html js-mediator-article">  In the world of software testing, a very young direction is gaining momentum - automating the testing of mobile applications.  And it is expected that the corresponding tools began to appear like mushrooms after the rain: <a href="http://calaba.sh/">Calabash</a> , <a href="http://ios-driver.github.io/ios-driver/%3Fpage%3Dhome">iOS Driver</a> , <a href="https://code.google.com/p/robotium/">Robotium</a> , <a href="http://selendroid.io/">Selendroid</a> , <a href="http://appium.io/">Appium</a> .  And it is about our experiments with the latest in mobile testing that I want to tell. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/732/25f/e29/73225fe2970bb2442f7ae4d1711a9360.png"></div><br>  Recently, Appium is often mentioned at conferences and here, on Habr√©, there were already several posts about it.  This is an open source framework written in JavaScript and designed to automate the testing of mobile applications.  In essence, this is Selenium WebDriver, but for mobile applications.  Appium allows you to manage Safari and Chrome on relevant devices, and therefore test websites under them, but an overview of these features and the nuances associated with them is a separate topic. <br><br>  To protect you from those bumps that we ourselves filled, working with Appium, I want to tell you about what features of the framework we have encountered, what difficulties you may have and how to cope with them. <br><a name="habracut"></a><br>  First, a little about why we chose Appium for ourselves.  In Yandex, the automatic testing infrastructure is mainly designed to use the Java language, and I don‚Äôt want to build something new.  The same Calabash, for example, is focusing on Ruby.  Appium can be used with Selenium Grid out of the box.  And we have a lot of applications, so I want a convenient test run in many threads.  It is important to write them for all platforms using the same tool, because we have applications for both iOS and Android.  In addition, Appium does not require additional modification of the application with which we deal in tests.  Of great importance is the fact that there is a large community of third-party developers interested in the further development of this framework. <br><br>  In addition, I want to highlight the main features of the tool: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Included with the server, the test developer is offered an application element inspector. </li><li>  The framework allows you to manage applications written for iOS and for Android. </li><li>  The interaction between the test and the Appium server is based on the WebDriver API. </li></ul><br>  But the choice of the tool is not limited to everything; the field of rakes begins with its direct use.  So I will focus on these points in more detail. <br><br><h4>  Application Elements Inspector </h4><br>  The process of writing tests for a mobile application using Appium is very similar to writing tests for websites.  You find any application elements (buttons, input fields, lists) by their selectors, interact with them and analyze their status.  In the case of websites, we use various web inspectors to understand what element the selector has.  In the case of mobile applications, each operating system offers its own solution.  Appium also made a single application for all platforms, which allows you to look at the tree of elements and the current screenshot, as well as the values ‚Äã‚Äãof some attributes of the selected element. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/890/a09/eba/890a09eba8ee654722d9c92e5a6e0a77.png"><br><br>  But not everything is so rosy, and here's why: <br><ul><li>  At the time of writing this post, the inspector worked only under MacOS, but the version under Windows is being actively developed. </li><li>  The inspector does not show all the attributes of the elements.  For example, for Android, you will not see in the inspector a wonderful attribute resource id, by which Appium can find elements. </li><li>  The tool is developed separately from the server.  Because of this, the inspector sometimes stops working.  For example, starting with version 0.14, Appium, when running a test, requires the device field to be specified.  The inspector was not designed for such a requirement, but he could automatically update the Appium server inside himself. </li><li>  Sometimes not all the elements that you see with your eyes on the phone screen are shown.  The situation is rare, and it was not possible to understand its nature. </li><li>  In the case of an Android application, the inspector may show an incorrect xpath element selector.  If you try to use the automatically generated selector, be prepared for the fact that Appium can return a completely different element.  Below, I will tell you more about this issue. </li></ul><br><h4>  Manage iOS Applications </h4><br>  The principle of operation comes down to converting your requests from the WebDriver API format into Apple's test framework commands - <a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/UsingtheAutomationInstrument/UsingtheAutomationInstrument.html">UI Automation</a> .  To run the tests on the simulator, you have enough of the app file of your application - no integration of third-party libraries is required.  If you want to drive tests on a real device, you will have to be a <a href="">little confused</a> .  In general, everything works out of the box: it is enough to install Appium from npm and install Xcode.  But let's look at the pitfalls. <br><br>  <b>One test session - one application</b> .  While the test is being executed, it is impossible to exit the application specified at its launch without losing the session.  If you want to go to Safari first, and then launch your application, then you will fail.  Below I will talk about a possible solution to the problem. <br><br>  <b>On big data, Appium runs at low speed and Appium just dies on timeout</b> .  This causes an unpleasant problem.  The way out of such a situation is competent thinking out test data.  Avoid lists with a large number of items in the application under test. <br><br>  <b>Xcode does not allow you to run multiple simulators</b> .  So you can forget about parallel running multiple tests on one machine.  There is only one legal way to brighten up the situation a bit.  The server version of MacOS allows the user to create two virtual machines, each of which can work.  The solution is expensive, since only 2 iOS simulators are obtained from one Mac mini, but we stopped there due to the lack of other options. <br><br>  <b>Port to control the browser - unchangeable</b> .  This item is about testing websites on the iOS simulator, which I promised not to touch, but its understanding explains better the impossibility of parallel test launches.  The fact is that when trying to configure the launch of multiple emulators on a single iron machine, we did not stop at the variant with virtual machines.  It turns out that if you have several accounts under one operating system, then each user will be able to run the simulator.  But this is where the described problem occurs.  Appium manages the browser of the simulator via Web Inspector, which in the case of the simulator listens to port 27753 on the local host.  This port is not set, respectively, when starting from under different users, each of the simulators will try to occupy this port and nothing good will come of it. <br><br>  <b>You can not select the desired version of iOS on the simulator</b> .  When launched through the console, the simulator runs by default with the latest version of iOS, available in Xcode, and cannot be selected.  Accordingly, in order to test the application on iOS 6 and iOS 7, you need to download Xcode 5 and Xcode 4 and switch to the correct version with the command <a href="">sudo xcode-select -switch</a> before running the tests. <br><br>  <b>The tool does not see transparent elements</b> .  In the Yandex.Maps mobile application, on top of the entire map lies a transparent element that catches the actions of your fingers.  His eyes are not visible, but he is.  And there are, for example, buttons for zooming in and out.  And we see them with our eyes, but if you try using Appium to find the elements responsible for these buttons and try to tap them, then nothing happens.  UI Automation begins to think that this element is not on the screen, and it is necessary to fix this by flushing the screen, but there is no place to scroll.  As a result - a mistake.  The solution to the problem is tap by code.  Read the position and size of the required object.  We add to the position of half the width and height and tapa.  Works. <br><br>  <b>Unstable simulator in Xcode 5+</b> .  Yes, problems are not always connected with Appium itself.  Developers from large corporations also throw sticks in the wheels.  So the iOS simulator, starting with Xcode version 5, began to fall with enviable regularity at startup.  As a result, the Appium server has an argument responsible for the number of attempts to launch the simulator. <br><br>  <b>There is no way to prepare a simulator</b> .  Sometimes to test the application is not enough empty operating system.  For example, when testing the Yandex.Disk application, we needed to check the download of unique files.  I wanted to have a fresh image in the photo album when you run the test.  If you run tests on a single machine, then there is no problem: you run the test, which in Safari downloads the picture to you, and then you run the test, which is already working with the application that uses the picture.  But when working with Selenium GRID, different tests will end up on different simulators.  To solve the problem, Appium had to be slightly modified.  In JavaScript, a test was written that ran Safari, pulled a handle that returns the current timestamp as qr code, and saved the resulting image into a photo album.  In turn, Appium began to monitor another parameter ‚Äî DesiredCapabilities, and if it was true, then before returning the current session to the tests, our test for creating the file was run locally.  Accordingly, when the main test began, there was already a picture in the albums.  Uploading files is required not only in our tasks, soon it will be possible to <a href="https://github.com/appium/appium/issues/2058">do without crutches</a> . <br><br><h4>  Manage Android Applications </h4><br>  With the Android operating system, the framework considered in this article is also pretty good in general.  This time, WebDriver API calls are converted to calls from Google‚Äôs test framework - <a href="http://developer.android.com/tools/help/uiautomator/index.html">uiautomator</a> .  The application can be tested both on the simulator and on a real device.  In some places it is even more convenient to work with Android than with iOS.  For example, Android does not limit developer tests to a single application within a single session, you can log in and out of any applications an unlimited number of times per session.  And running tests on a live phone will only require you to connect it to a computer, Appium does the rest for you.  Now let's take a look at how Appium works with Android applications. <br><br><h5>  Difficulties </h5><br>  <b>In the tree of elements there are only those that fall when the tree is built into the screen area.</b>  In the case of iOS, if an element is out of the screen's scope, then iOS will try to scroll through it itself, but Android doesn't know anything about such an element, because it is not in the current tree.  Accordingly, if you need to tap on a button that you do not see right now, you will first have to skip it. <br><br>  <b>Images of Android under Intel, and under ARM.</b>  ARM is the most common, but the simulator has to emulate the processor architecture, and as a result, everything works very slowly.  Intel is closer to reality (at least the processor architecture is no different from the one presented on the system running the simulator).  On top of that, Intel itself <a href="https://software.intel.com/en-us/android/articles/intel-hardware-accelerated-execution-manager">launches the HAXM</a> accelerator, which makes testing even more comfortable - everything works very fast.  But there are situations when it turns out that the third-party library used in the application is compiled only under ARM.  For such cases, you can run tests on the functionality that uses this library on slow ARMs, and the rest on fast Intel. <br><br>  <b>Unreal xpath.</b>  In the Appium inspector there is an automatically generated selector for the selected element in the form of xpath.  But be careful: for Android it may be incorrect.  The fact is that at the moment Appium does not distinguish // from /.  He does not care how deep the descendant is in relation to the parent.  And very often the wrong item is returned.  The situation is promised to be fixed in <a href="https://github.com/appium/appium/issues/1447">Appium 1.0</a> .  In the meantime, I can recommend using other types of selectors - by class or id - or try to check xpath, which offers you Appium. <br><br>  <b>If your application goes to the API via https, then your root certificate may not be on the list of trusted certificates.</b>  So after the next renewal of certificates on test servers, the application stopped working for us.  Visually, it looks like the absence of the Internet, but you will not see any error messages.  To fix the problem, you will have to manually pour the certificate into the simulator, and then import it in the settings.  The system will ask you to set a PIN code for the phone.  Put, Appium can unlock the phone. <br><br>  <b>OpenGL ES can slow down tests.</b>  Do not forget that in addition to acceleration in the form of HAXM, Android also uses graphics acceleration using OpenGL.  So, locally, it will most likely work fine for you, and the tests will run relatively quickly, even on ARM.  But on serious servers, where the video card is far from the most important component, OpenGL is likely to refuse to perform its task.  Therefore, the tests will go slower than on the local computer.  This must be considered. <br><br>  <b>In the tree of elements there may not even be those objects that are now visible on the screen.</b>  This is a very rare situation that we have encountered only once.  In the Yandex.Music application it was not possible to find a point of contact with the search sadgest.  How to get around the problem without modifying the application is not clear.  Unless only interaction with the supposed coordinates of the elements will help. <br><br>  <b>Problems on the side of the Android SDK.</b>  If Apple in the iOS 7 simulator became all bad with stability, then Google has some failures in the work of the Android SDK itself.  One recent example: in Android 4.2, erasing text has stopped working.  Even the transfer of the backspace button code as a symbol did not help.  As a result, all tests for renaming text were ordered to live long.  In addition, some time ago it was impossible to get a screen shot, which is also unpleasant.  So if something is not working for you, it‚Äôs not a fact that the problem is in Appium. <br><br>  <b>Distortion of the input audio signal.</b>  The simulator distorts the sound coming to the microphone, so your application will not be able to recognize the voice.  Theoretically, you can make your patched image of the image of Android.  So in the Bluestack simulator there are no problems with sound, but there is no uiautomator in it, so working with it through Appium will not work. <br><br><h5>  Useful features </h5><br>  <i><b>Parallel test run.</b></i>  Unlike the iOS simulator, Android has great flexibility in terms of settings and can run an unlimited number of its instances on one machine.  So you can tell the simulator the port on which adb will communicate with it.  In addition, due to this, simulators will work separately, you will also know the simulator id, which is obtained from the <code>emulator-{port}</code> pattern.  Then, when you start Appium, you will need to scatter servers on different ports and set a parameter pointing to another port for communicating with Appium with the simulator (using adb, only a small part of the commands are executed).  As a result, the command to start the simulator will look something like this <code>emulator-x86 -avd API18_X86_1 -port 5554 -sdcard 200MB-1.img -no-boot-anim -qemu -m 2047 -enable-kvm</code> , and Appium itself will run line <code>appium -a {server address} -p 4721 -U emulator-5554 -dp 6721 --full-reset --nodeconfig register-x86-port-4721.json</code> .  You will only have to change the ports for new copies of simulators and Appium servers.  Register them all in Selenium GRID and get the infrastructure ready for parallel test runs. <br><br>  <i><b>The freedom of action.</b></i>  In the case of Android, you can do anything you like: exit the application specified when starting the test, go into another application, exit it and enter the third one.  All this will be one session.  Android allows you to work with all your system as a single application in a single session.  So it will be much easier to set up a simulator from the test for your test.  Save files, perform some actions in the settings of the system itself. <br><br>  <i><b>Proxy support.</b></i>  When can it come in handy?  For example, to test the functionality of your application, which depends on the geographic region.  By specifying a proxy from another country, you can beautifully check this functionality.  This attribute in another situation was useful to us.  Let's say you have a production server for the application and testing.  But your developers did not take into account the possibility of switching the environment in the application, and you urgently needed to test the application on the test API.  This is where the proxy will help.  We raise nginx, we just write a perl redirector that will replace the address of the combat API with the one being tested, and force the simulator to go through our proxy with the redirector.  So - without modifying the application - you can check the correctness of working with the API on various environments. <br><br><h4>  Interaction between the test and the Appium server based on WebDriver API </h4><br>  There can be only one problem: if it turns out that the method you need is not yet implemented.  You can view the missing methods in the <a href="">routing</a> file.  The rest of the use of WebDriver API is a huge plus Appium.  After all, this allows you to use various third-party solutions that were intended for testing websites, for testing mobile applications.  So here I will list only the benefits of using Appium. <br><br>  <b><i>Selenium GRID support</i></b> .  You lift the Selenium GRID server, put Appium servers on machines, create <a href="">json configuration files</a> , launch Appium with them.  Everything.  The infrastructure for parallel test run is ready. <br><br>  <b><i>No need to connect extra libraries</i> .</b>  A classic artifact (if we are talking about Java) selenium-java to help you.  For other languages, it is also sufficient to connect a library containing the WebDriver client. <br><br>  <b><i>Ability to use various add-ons for WebDriver</i> .</b>  For example, our guys have developed an excellent library <a href="http://habrahabr.ru/company/yandex/blog/158787/">HtmlElements</a> , designed for convenient storage of selectors of elements and the organization of the beautiful architecture of your tests like the PageObject template.  This approach allows the use of practices already tested on testing websites in testing mobile applications. <br><br><h4>  Conclusion </h4><br>  What do we have in the end?  Appium is still a raw but fast-growing product.  The topic of automating the testing of mobile applications is still gaining momentum, so Appium is more likely an old Selenium than a modern WebDriver.  The server may crash at the wrong moment, the test session may hang in Selenium GRID (after our pull request, since version 0.17.7, the error has been fixed).  Documentation is not always relevant and sometimes after the next update that some attribute has suddenly become mandatory, you will learn only after studying the source code of the product.  Errors are not corrected as quickly as we would like.  For example, Appium for a long time did not work under ubuntu.  The error was <a href="https://github.com/rgonalo/appium/commit/24adf93d9d78942709ae1bb60eac70b89a1ac40d">corrected</a> quite recently.  But, as I said earlier, the product is developing rapidly, he (at the time of writing the post) already has almost 1000 forks and almost 1200 likes on a githaba.  It can be seen that the developers follow the wishes of users and take them into account.  If earlier almost all development was carried out by several people from Sauce Labs, now, thanks to open source, third-party developers are involved in the emergence of new features and bug fixes.  At the moment, we are considering using Appium as an experiment, but it is becoming more and more like a serious solution to practical problems. <br><br>  PS While this post was being prepared, new versions of Appium: 1.0 and 1.1 were released.  While we are just looking at them and not in a hurry to update.  On the one hand, the new versions have fixed some of the problems described here.  For example, "earned the correct xpath."  But in version 1.0 it ‚Äúearned‚Äù so much that, when requesting an ‚Äúimage‚Äù, it could return an ‚Äúinput field‚Äù.  1.1 fixed this problem.  In general, not everything is still perfect, and if they corrected something in one place, it is not a fact that they did not break it in other places.  We are waiting for stability. </div><p>Source: <a href="https://habr.com/ru/post/227571/">https://habr.com/ru/post/227571/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../227555/index.html">Paint.NET 4.0 graphic editor released</a></li>
<li><a href="../227559/index.html">Again about the clouds. Several tools for VMware virtual infrastructure administrators</a></li>
<li><a href="../227565/index.html">LG G Watch and Samsung Gear Live smart watches are available for pre-order</a></li>
<li><a href="../227567/index.html">News from the world of P2P: Tox began to support audio calls and TCP Relay, various improvements in Twister</a></li>
<li><a href="../227569/index.html">Like music, smells and images influence shoppers. (basic postulates)</a></li>
<li><a href="../227575/index.html">ProtonMail or what is it really?</a></li>
<li><a href="../227577/index.html">How to roll the dice without opengl</a></li>
<li><a href="../227581/index.html">Toaster. User's contribution to the tags: enter the reputation system</a></li>
<li><a href="../227583/index.html">Downshifting for a programmer? Cambodia, survival experience and life experience</a></li>
<li><a href="../227585/index.html">Everything you wanted to know about refactoring, but were afraid to ask</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>