<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SObjectizer: from simple to complex. Part III</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the next article about SObjectizer, we will continue to follow the evolution of a simple at first agent, which becomes more and more complicated as...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SObjectizer: from simple to complex. Part III</h1><div class="post__text post__text-html js-mediator-article"><p>  In the next article about SObjectizer, we will continue to follow the evolution of a simple at first agent, which becomes more and more complicated as it develops.  Consider how to deal with deferred messages in which we are no longer interested.  And we will use some functionality of hierarchical finite automata. </p><br><a name="habracut"></a><br><p>  <a href="https://habrahabr.ru/post/307306/">In the previous article,</a> we stopped at the fact that we have an agent email_analyzer, which can be considered more or less reliably solving its task.  However, he himself, sequentially, performs three stages of checking email: first he checks the headers, then the contents, then the attachments. </p><br><p>  Most likely, each of these operations will not be exclusively CPU-bound.  It is much more likely that after isolating some values ‚Äã‚Äãfrom the fragment being checked (for example, from letter headers), you will need to make a request somewhere to check the validity of this value.  For example, a query in the database in order to check whether the name of the sending host is blacklisted.  While this request will be executed, it would be possible to perform some other operation, for example, to parse the contents of the text of the letter into separate key phrases, so that they can be checked using a dictionary of spam markers.  Or check if there are archives in attachments and initiate antivirus check.  In general, it makes sense to parallelize the analysis of email. </p><br><p>  Let's try to use individual agents for each operation.  Those.  You can write agents like: </p><br><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">email_headers_checker</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result</span></span></span><span class="hljs-class"> {</span></span> check_status status_ }; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> email_headers_checker( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, ... <span class="hljs-comment"><span class="hljs-comment">/* -  */</span></span> ) {...} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_evt_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> } ... <span class="hljs-comment"><span class="hljs-comment">/* -   */</span></span> }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">email_body_checker</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> {...}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">email_attachment_checker</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> {...};</code> </pre> <br><p>  Each such agent will perform operations specific to its operation, and then send the result email_analyzer as a message.  Our email_analyzer will need to create instances of these agents at home and wait for messages from them with the results of the analysis: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_load_succeed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> load_email_succeed &amp; msg )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> parsed_data = parse_email( msg.content_ ); introduce_child_coop( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-comment"><span class="hljs-comment">// -checker-      // thread-pool-,     //   . disp::thread_pool::create_disp_binder( "checkers", disp::thread_pool::bind_params_t{} ), [&amp;]( coop_t &amp; coop ) { coop.make_agent&lt; email_headers_checker &gt;( so_direct_mbox(), parsed_data-&gt;headers() ); coop.make_agent&lt; email_body_checker &gt;( so_direct_mbox(), parsed_data-&gt;body() ); coop.make_agent&lt; email_attach_checker &gt;( so_direct_mbox(), parsed_data-&gt;attachments() ); } ); } catch( const exception &amp; ) {...} }</span></span></code> </pre><br><p>  Those who carefully read the previous articles, the phrase "wait for messages from them" should have been alerted.  Waiting without time limit is not good, it is a direct way to get in vain dangling in the system and not doing anything agent.  Therefore, when waiting for responses from checkers, it makes sense for us to do the same as when waiting for the result of an IO operation: to send ourselves some sort of deferred signal, having received which we will understand that it is no use waiting any longer.  Those.  we would have to write something like: </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/    email_analyzer    . class email_analyzer : public agent_t { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     ,    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   IO-    . struct io_agent_response_timeout : public signal_t {}; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     ,    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     email-. struct checkers_responses_timeout : public signal_t {}; ... virtual void so_evt_start() override { ... /</span></span>*   IO- *<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      -    IO-. send_delayed&lt; io_agent_response_timeout &gt;( *this, 1500ms ); } ... void on_load_succeed( const load_succeed &amp; msg ) { ... /</span></span>*     checker- *<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     -    -checker-. send_delayed&lt; checkers_responses_timeout &gt;( *this, 750ms ); } ... void on_checkers_responses_timeout() { ... /</span></span>*   . *<span class="hljs-regexp"><span class="hljs-regexp">/ } };</span></span></code> </pre><br><p>  However, having gone this way we will step on a rake: waiting for a response from the checkers, we can easily get a pending signal io_agent_response_timeout.  After all, it has not been canceled.  And when this signal comes, we will generate a negative response due to the supposedly existing I / O timeout, which is not.  Let's try to get around this rake. </p><br><p>  Often, developers who are not used to asynchronous messaging try to cancel the delayed signal.  This can be done if you save the timer identifier when referring to send_periodic: </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/    email_analyzer    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  io_agent_response_timeout. class email_analyzer : public agent_t { struct io_agent_response_timeout : public signal_t {}; ... virtual void so_evt_start() override { ... /</span></span>*   IO- *<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ send_periodic  send_delayed,   period /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   0,     , /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . io_response_timer_ = send_periodic&lt; io_agent_response_timeout &gt;( *this, 1500ms, 0ms ); } ... void on_load_succeed( const load_succeed &amp; msg ) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . io_response_timer_.reset(); ... /</span></span>*     checker- *<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     -    -checker-. send_delayed&lt; checkers_responses_timeout &gt;( *this, 750ms ); } ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       -  IO-. timer_id_t io_response_timer_; };</span></span></code> </pre><br><p>  Unfortunately, this simple method does not always work.  The problem is that the delayed signal can be sent to the email_analyzer agent just a moment before the email_analyzer agent resets the timer for this delayed signal.  There's nothing to be done - the wonders of multithreading, they are. </p><br><p>  The email_analyzer agent can enter on_load_succeed on the context of its working thread, it may even have time to enter the reset () call for the timer ... But then its thread will be forced out, the control will receive the SObjectizer timer thread, on which the delayed signal will be sent.  After that, the management will again receive the email_analyzer () agent's working thread and the reset () method for the timer will cancel the signal that has already been sent.  However, the signal is already in the agent's message queue, from which no one will throw it away - once the message has been queued up to the agent, it cannot be removed from there. </p><br><p>  The worst thing about this situation is that such an error will occur sporadically.  Because of that, it will be difficult to understand exactly what is happening and what exactly the error is.  So it must be remembered that canceling a deferred message is not at all a guarantee that it will not be sent. </p><br><p>  So, if you simply cancel the postponed message incorrectly, then what to do? </p><br><p>  For example, you can use agent states.  When email_analyzer waits for a response from an IO agent, it is in one state.  When the response from the IO agent arrives, the email_analyzer agent changes to a different state in which it will wait for responses from checkers.  Since  in the second state, the email_analyzer to the io_agent_response_timeout signal is not signed, then this signal will simply be ignored. </p><br><p>  With the introduction of states into the email_analyzer agent, we might get something like: </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/    email_analyzer   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  . class email_analyzer : public agent_t { struct io_agent_response_timeout : public signal_t {}; struct checkers_responses_timeout : public signal_t {}; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,       IO-. state_t st_wait_io{ this }; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,        checker-. state_t st_wait_checkers{ this }; ... virtual void so_define_agent() override { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,    ,    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ‚Äì    state_t. st_wait_io .event( &amp;email_analyzer::on_load_succeed ) .event( &amp;email_analyzer::on_load_failed ) .event&lt; io_agent_response_timeout &gt;( &amp;email_analyzer::on_io_timeout ); st_wait_checkers .event( &amp;email_analyzer::on_header_check_result ) .event( &amp;email_analyzer::on_body_check_result ) .event( &amp;email_analyzer::on_attach_check_result ) .event&lt; checkers_responses_timeout &gt;( &amp;email_analyzer::on_checkers_timeout ); } ... };</span></span></code> </pre><br><p>  However, in SObjectizer you can do even easier: you can set a time limit for the agent to be in a particular state.  When this limit expires, the agent will be forcibly transferred to another state.  Those.  we can write something like: </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/    email_analyzer     /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      . class email_analyzer : public agent_t { state_t st_wait_io{ this }; state_t st_io_timeout{ this }; state_t st_wait_checkers{ this }; state_t st_checkers_timeout{ this }; ... virtual void so_define_agent() override { st_wait_io .event( &amp;email_analyzer::on_load_succeed ) .event( &amp;email_analyzer::on_load_failed ) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . .time_limit( 1500ms, st_io_timeout ); st_wait_checkers .event( &amp;email_analyzer::on_header_check_result ) .event( &amp;email_analyzer::on_body_check_result ) .event( &amp;email_analyzer::on_attach_check_result ) .time_limit( 750ms, st_checkers_timeout ); } };</span></span></code> </pre><br><p>  But just to limit the time spent in some state is not enough.  We still need to take some action when this time expires.  How to do it? </p><br><p>  Use such a thing as a state entry handler.  When the agent enters a specific state, the SObjectizer calls the input handler function in that state, if the user has assigned such a function.  This means that at the entrance to st_io_timeout we can hang the handler, which sends a check_result with a negative result and terminates the agent: </p><br><pre> <code class="hljs kotlin">st_io_timeout.on_enter( [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]{ send&lt; check_result &gt;( reply_to_, email_file_, check_status::check_failure ); so_deregister_agent_coop_normally(); } );</code> </pre><br><p>  We will hang the same handler on the input to st_checkers_timeout.  And since  actions inside these handlers will be the same, then we can put them in a separate agent method email_analyzer and specify this method as an input handler for both the st_io_timeout state and the st_checkers_timeout state: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">email_analyzer</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_wait_io{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_io_timeout{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_wait_checkers{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_checkers_timeout{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ ... st_io_timeout .on_enter( &amp;email_analyzer::on_enter_timeout_state ); ... st_checkers_timeout .on_enter( &amp;email_analyzer::on_enter_timeout_state ); }; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_enter_timeout_state</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ send&lt; check_result &gt;( reply_to_, email_file_, check_status::check_failure ); so_deregister_agent_coop_normally(); } };</code> </pre><br><p>  But that's not all.  Since we have touched on the topic of agent states and their capabilities, we can further develop it and refactor the email_analyzer code. </p><br><p>  It is easy to see that a couple of actions are often duplicated in the code: sending a check_result message and deregistration of agent cooperation.  Such duplication is not good, you should get rid of it. </p><br><p>  In essence, the email_analyzer agent‚Äôs job is to end up with the agent in one of two states: either everything ended normally and a positive result should be sent, then shut down, or everything ended with an error, a negative result should be sent and, again did shut down the agent.  So let's express it directly in the code using two agent states: st_success and st_failure. </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/    email_analyzer    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  st_success  st_failure. class email_analyzer : public agent_t { state_t st_wait_io{ this }; state_t st_wait_checkers{ this }; state_t st_failure{ this }; state_t st_success{ this }; ... virtual void so_define_agent() override { st_wait_io .event( &amp;email_analyzer::on_load_succeed ) .event( &amp;email_analyzer::on_load_failed ) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . .time_limit( 1500ms, st_failure ); st_wait_checkers .event( &amp;email_analyzer::on_header_check_result ) .event( &amp;email_analyzer::on_body_check_result ) .event( &amp;email_analyzer::on_attach_check_result ) .time_limit( 750ms, st_failure ); st_failure .on_enter( [this]{ send&lt; check_result &gt;( reply_to_, email_file_, status_ ); so_deregister_agent_coop_normally(); } ); st_success .on_enter( [this]{ send&lt; check_result &gt;( reply_to_, email_file_, check_status::safe ); so_deregister_agent_coop_normally(); } ); }; ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        . check_status status_{ check_status::check_failure }; };</span></span></code> </pre><br><p>  This will allow us in the agent code to simply change the state to shut down the agent in one way or another: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_load_failed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> load_email_failed &amp; </span></span></span><span class="hljs-function">)</span></span> { st_failure.activate(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_checker_result</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> check_status status </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//        . if( check_status::safe != status ) { status_ = status; st_failure.activate(); } else { ++checks_passed_; if( 3 == checks_passed_ ) //   .     //  . st_success.activate(); } }</span></span></code> </pre><br><p>  But you can go even further.  For the st_failure and st_success states, there is one general action that needs to be performed when entering any of these states - a call to so_deregister_agent_coop_normally ().  And this is no accident, because both of these states are responsible for the completion of the agent.  And if so, then we can use the nested states.  Those.  we will enter the st_finishing state, for which st_failure and st_success will be substates.  When you enter st_finishing, so_deregister_agent_coop_normally () will be called.  And at the entrance to st_failure and st_success - the corresponding message will only be sent. </p><br><p>  Since  the st_failure and st_success states are nested in st_finishing, then upon entering any of them, the input handler for st_finishing will be called first, and only then the input handler for st_failure or st_success will be called.  It turns out that when we enter st_finishing, we deregister the agent, and then, upon entering st_failure or st_success, we send the message check_result. </p><br><p>  If one of the readers feels uncomfortable with the mention of nested states, state entry handlers, restrictions on the time they are in a state, then it makes sense to get acquainted with one of the fundamental articles on hierarchical finite automata: <a href="http://www.wisdom.weizmann.ac.il/~dharel/SCANNED.PAPERS/Statecharts.pdf">David Harel, Statecharts: A visual formalism for complex systems.</a>  <a href="http://www.wisdom.weizmann.ac.il/~dharel/SCANNED.PAPERS/Statecharts.pdf">Science of Computer Programming</a> .  The states of agents in SObjectizer realize a fair amount of the features described there. </p><br><p>  As a result of all these transformations, the email_analyzer agent will take the form shown below. </p><br><pre> <code class="hljs markdown">//    email<span class="hljs-emphasis"><span class="hljs-emphasis">_analyzer,      //  email-    . class email_</span></span>analyzer : public agent<span class="hljs-emphasis"><span class="hljs-emphasis">_t { state_</span></span>t st<span class="hljs-emphasis"><span class="hljs-emphasis">_wait_</span></span>io{ this }; state<span class="hljs-emphasis"><span class="hljs-emphasis">_t st_</span></span>wait<span class="hljs-emphasis"><span class="hljs-emphasis">_checkers{ this }; state_</span></span>t st<span class="hljs-emphasis"><span class="hljs-emphasis">_finishing{ this }; state_</span></span>t st<span class="hljs-emphasis"><span class="hljs-emphasis">_failure{ initial_</span></span>substate<span class="hljs-emphasis"><span class="hljs-emphasis">_of{ st_</span></span>finishing } }; state<span class="hljs-emphasis"><span class="hljs-emphasis">_t st_</span></span>success{ substate<span class="hljs-emphasis"><span class="hljs-emphasis">_of{ st_</span></span>finishing } }; public : email<span class="hljs-emphasis"><span class="hljs-emphasis">_analyzer( context_</span></span>t ctx, string email<span class="hljs-emphasis"><span class="hljs-emphasis">_file, mbox_</span></span>t reply<span class="hljs-emphasis"><span class="hljs-emphasis">_to ) : agent_</span></span>t(ctx), email<span class="hljs-emphasis"><span class="hljs-emphasis">_file_</span></span>(move(email<span class="hljs-emphasis"><span class="hljs-emphasis">_file)), reply_</span></span>to<span class="hljs-emphasis"><span class="hljs-emphasis">_(move(reply_</span></span>to)) {} virtual void so<span class="hljs-emphasis"><span class="hljs-emphasis">_define_</span></span>agent() override { st<span class="hljs-emphasis"><span class="hljs-emphasis">_wait_</span></span>io .event( &amp;email<span class="hljs-emphasis"><span class="hljs-emphasis">_analyzer::on_</span></span>load<span class="hljs-emphasis"><span class="hljs-emphasis">_succeed ) .event( &amp;email_</span></span>analyzer::on<span class="hljs-emphasis"><span class="hljs-emphasis">_load_</span></span>failed ) //  -   . .time<span class="hljs-emphasis"><span class="hljs-emphasis">_limit( 1500ms, st_</span></span>failure ); st<span class="hljs-emphasis"><span class="hljs-emphasis">_wait_</span></span>checkers .event( [<span class="hljs-string"><span class="hljs-string">this</span></span>](<span class="hljs-link"><span class="hljs-link"> const email_headers_checker::result &amp; msg </span></span>) { on<span class="hljs-emphasis"><span class="hljs-emphasis">_checker_</span></span>result( msg.status<span class="hljs-emphasis"><span class="hljs-emphasis">_ ); } ) .event( [this]( const email_</span></span>body<span class="hljs-emphasis"><span class="hljs-emphasis">_checker::result &amp; msg ) { on_</span></span>checker<span class="hljs-emphasis"><span class="hljs-emphasis">_result( msg.status_</span></span> ); } ) .event( [<span class="hljs-string"><span class="hljs-string">this</span></span>](<span class="hljs-link"><span class="hljs-link"> const email_attach_checker::result &amp; msg </span></span>) { on<span class="hljs-emphasis"><span class="hljs-emphasis">_checker_</span></span>result( msg.status<span class="hljs-emphasis"><span class="hljs-emphasis">_ ); } ) //   -  . .time_</span></span>limit( 750ms, st<span class="hljs-emphasis"><span class="hljs-emphasis">_failure ); //  ,     , //     . st_</span></span>finishing.on<span class="hljs-emphasis"><span class="hljs-emphasis">_enter( [this]{ so_</span></span>deregister<span class="hljs-emphasis"><span class="hljs-emphasis">_agent_</span></span>coop<span class="hljs-emphasis"><span class="hljs-emphasis">_normally(); } ); st_</span></span>failure.on<span class="hljs-emphasis"><span class="hljs-emphasis">_enter( [this]{ send&lt; check_</span></span>result &gt;( reply<span class="hljs-emphasis"><span class="hljs-emphasis">_to_</span></span>, email<span class="hljs-emphasis"><span class="hljs-emphasis">_file_</span></span>, status<span class="hljs-emphasis"><span class="hljs-emphasis">_ ); } ); st_</span></span>success.on<span class="hljs-emphasis"><span class="hljs-emphasis">_enter( [this]{ send&lt; check_</span></span>result &gt;( reply<span class="hljs-emphasis"><span class="hljs-emphasis">_to_</span></span>, email<span class="hljs-emphasis"><span class="hljs-emphasis">_file_</span></span>, check<span class="hljs-emphasis"><span class="hljs-emphasis">_status::safe ); } ); } virtual void so_</span></span>evt<span class="hljs-emphasis"><span class="hljs-emphasis">_start() override { //      ,  //      . st_</span></span>wait<span class="hljs-emphasis"><span class="hljs-emphasis">_io.activate(); //       IO-   //  email . send&lt; load_</span></span>email<span class="hljs-emphasis"><span class="hljs-emphasis">_request &gt;( so_</span></span>environment().create<span class="hljs-emphasis"><span class="hljs-emphasis">_mbox( "io_</span></span>agent" ), email<span class="hljs-emphasis"><span class="hljs-emphasis">_file_</span></span>, so<span class="hljs-emphasis"><span class="hljs-emphasis">_direct_</span></span>mbox() ); } private : const string email<span class="hljs-emphasis"><span class="hljs-emphasis">_file_</span></span>; const mbox<span class="hljs-emphasis"><span class="hljs-emphasis">_t reply_</span></span>to<span class="hljs-emphasis"><span class="hljs-emphasis">_; //      ,   //      st_</span></span>failure. check<span class="hljs-emphasis"><span class="hljs-emphasis">_status status_</span></span>{ check<span class="hljs-emphasis"><span class="hljs-emphasis">_status::check_</span></span>failure }; int checks<span class="hljs-emphasis"><span class="hljs-emphasis">_passed_</span></span>{}; void on<span class="hljs-emphasis"><span class="hljs-emphasis">_load_</span></span>succeed( const load<span class="hljs-emphasis"><span class="hljs-emphasis">_email_</span></span>succeed &amp; msg ) { //   ..    . st<span class="hljs-emphasis"><span class="hljs-emphasis">_wait_</span></span>checkers.activate(); try { auto parsed<span class="hljs-emphasis"><span class="hljs-emphasis">_data = parse_</span></span>email( msg.content<span class="hljs-emphasis"><span class="hljs-emphasis">_ ); introduce_</span></span>child<span class="hljs-emphasis"><span class="hljs-emphasis">_coop( *this, // -checker-      // thread-pool-,     //   . disp::thread_</span></span>pool::create<span class="hljs-emphasis"><span class="hljs-emphasis">_disp_</span></span>binder( "checkers", disp::thread<span class="hljs-emphasis"><span class="hljs-emphasis">_pool::bind_</span></span>params<span class="hljs-emphasis"><span class="hljs-emphasis">_t{} ), [&amp;]( coop_</span></span>t &amp; coop ) { coop.make<span class="hljs-emphasis"><span class="hljs-emphasis">_agent&lt; email_</span></span>headers<span class="hljs-emphasis"><span class="hljs-emphasis">_checker &gt;( so_</span></span>direct<span class="hljs-emphasis"><span class="hljs-emphasis">_mbox(), parsed_</span></span>data-&gt;headers() ); coop.make<span class="hljs-emphasis"><span class="hljs-emphasis">_agent&lt; email_</span></span>body<span class="hljs-emphasis"><span class="hljs-emphasis">_checker &gt;( so_</span></span>direct<span class="hljs-emphasis"><span class="hljs-emphasis">_mbox(), parsed_</span></span>data-&gt;body() ); coop.make<span class="hljs-emphasis"><span class="hljs-emphasis">_agent&lt; email_</span></span>attach<span class="hljs-emphasis"><span class="hljs-emphasis">_checker &gt;( so_</span></span>direct<span class="hljs-emphasis"><span class="hljs-emphasis">_mbox(), parsed_</span></span>data-&gt;attachments() ); } ); } catch( const exception &amp; ) { st<span class="hljs-emphasis"><span class="hljs-emphasis">_failure.activate(); } } void on_</span></span>load<span class="hljs-emphasis"><span class="hljs-emphasis">_failed( const load_</span></span>email<span class="hljs-emphasis"><span class="hljs-emphasis">_failed &amp; ) { st_</span></span>failure.activate(); } void on<span class="hljs-emphasis"><span class="hljs-emphasis">_checker_</span></span>result( check<span class="hljs-emphasis"><span class="hljs-emphasis">_status status ) { //        . if( check_</span></span>status::safe != status ) { status<span class="hljs-emphasis"><span class="hljs-emphasis">_ = status; st_</span></span>failure.activate(); } else { ++checks<span class="hljs-emphasis"><span class="hljs-emphasis">_passed_</span></span>; if( 3 == checks<span class="hljs-emphasis"><span class="hljs-emphasis">_passed_</span></span> ) //   .     //  . st_success.activate(); } } };</code> </pre><br><p>  Well, now it makes sense to look at the code of the resulting email_analyzer agent and ask yourself a simple but important question: was it worth it? </p><br><p>  Obviously, the answer to this question is not so simple.  But we will try to talk about this in the next article.  In which we will touch on the topic of lessons that we have learned after more than ten years of using SObjectizer in the development of software systems. </p><br><p>  Source codes for the examples shown in the article can be found <a href="https://bitbucket.org/sobjectizerteam/habrhabr_article_2">in this repository</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/308084/">https://habr.com/ru/post/308084/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308070/index.html">How are the channels in Go</a></li>
<li><a href="../308074/index.html">Cisco and Fortinet Release Safety Notices after Data Leakage by Equation Group</a></li>
<li><a href="../308076/index.html">Microsoft opened the source code of PowerShell</a></li>
<li><a href="../308080/index.html">Website development based on ASP.NET Core and Platformus CMS</a></li>
<li><a href="../308082/index.html">Analysis of the Quran with AI</a></li>
<li><a href="../308086/index.html">Individual daily limit for outgoing calls (limitation of paid directions)</a></li>
<li><a href="../308088/index.html">Safely use Go language in web programming</a></li>
<li><a href="../308090/index.html">About the division of labor and its consequences</a></li>
<li><a href="../308092/index.html">It's time to tell you how I was Beeline for 4 years on Habr√© - and what I learned about Habr during that time</a></li>
<li><a href="../308094/index.html">Training with reinforcements for the smallest</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>