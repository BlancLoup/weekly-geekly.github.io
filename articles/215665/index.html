<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>+ (AppStore *) Timera: application architecture and design features. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For those who have not read the first part, briefly: it described the solution to the problem of creating layers and effects, to combine the old and t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>+ (AppStore *) Timera: application architecture and design features. Part 2</h1><div class="post__text post__text-html js-mediator-article">  For those who have not read the first part, briefly: it described the solution to the problem of creating layers and effects, to combine the old and the new photo.  Details about this can be <a href="http://habrahabr.ru/company/timera_inc/blog/212497/">found here.</a> <br><br>  In this part, our iOS developer, <a href="http://habrahabr.ru/users/heximal/">heximal</a> , will talk about how geo-positional-cartographic functionality was implemented.  Since he has read only, I post this post again (it will be cool if someone gives him an invite).  In his words, everything is written correctly. <a name="habracut"></a><br><br>  ‚ÄúInitially, timera was designed as a means of creating time tunnels.  According to many scientific theories, space and time are directly related, so the location for timers is a very important aspect.  The first implementation of the timers meant searching for old photos exclusively on the map: the user opened the screen with a map in the application, found old photos around him, chose the one he liked, and started the timeout process.  For this, a web service was developed that returns all old photos in the region, which was determined by the visible area on the map screen (minlat, maxlat, minlng, maxlng).  At the testing stage, it became clear that this process needs to be optimized, since the number of pins in a certain area can reach such an amount that there will be an incomprehensible mess, and in the end it will be very difficult to choose an object on the map. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/86e/4c7/06c/86e4c706ce836f313ee73d2ec5efc186.png" alt="image"><br><br>  Solving this problem was solved by clustering.  Clusters are pins on a map associated with a group, rather than with any particular object.  Visually, this is an icon with a number that reflects the number of grouped objects. <br>  It should be mentioned here that we chose Google Maps as a map service.  Why did we prefer them to native Apple cards?  Most likely, this decision will be revised in the near future.  It‚Äôs just that at the time of the design there were still fresh memories of the Apple card fiasco, as well as my personal experience of using both frameworks. <br>  We return to clustering.  Initially, the possibility of implementing clusters locally was considered.  It turned out that Google Maps has the ability to do it literally in one line of code, but this property was available only on Android.  We have already started the local implementation of clusters on iOS, as a common thought has taken it into the collective consciousness: to improve the web service so that it returns the clusters.  The server solution has a great advantage in terms of optimization: firstly, reducing the number of transferred objects (read, reducing traffic), and secondly, reducing the cost of storing data in Core Data.  The Core Data model also had to be modified - a new entity MapCluster was added, which has attributes such as latitude, longitude, zoom, count, objectId <br>  Where <br>  latitude, longitude - cluster coordinates <br>  zoom - the zoom level that the user sets. <br>  count - the number of objects attached to the cluster. <br>  objectId - a cluster can be tied to a specific object, thus, it should be displayed as a real clickable pin. <br><br>  Further, a technical matter: if the user changes the location of the map or the zoom level, then a request is first made in the local storage for the selected area, and the clusters from the resulting collection are mapped, and a request is sent to the server with the same parameters.  If everything is good with the connection, and the server returns the answer, the local clusters are removed from the database, and new ones are filled in their place - this is how the update occurs. <br>  I am sure that a lot of interesting things about the implementation of a web service could be told by our server-side developers.  I can only say that for the sake of this, new database entities were also created to aggregate objects into clusters, which are filled with a scheduled task. <br><br>  I would also like to tell a couple of interesting points about the iOS implementation of clusters.  To render the clusters, we had to create a small class that returns an image as a circle with a number, because the setIcon method of the GMSMarker class from GoogleMaps.framework needs a UIImage, in which it will display the corresponding pin. <br>  As a result, the created class is a heir of UIView, which contains nested elements that form the image of a cluster, and the UIImage from this all is obtained by the following method: <br><br><pre><code class="objectivec hljs">-(<span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> *) renderedClusterImage { <span class="hljs-built_in"><span class="hljs-built_in">UIGraphicsBeginImageContextWithOptions</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.bounds.size, <span class="hljs-literal"><span class="hljs-literal">NO</span></span>, [<span class="hljs-built_in"><span class="hljs-built_in">UIScreen</span></span> mainScreen].scale); [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layer renderInContext:<span class="hljs-built_in"><span class="hljs-built_in">UIGraphicsGetCurrentContext</span></span>()]; <span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> *capturedImage = <span class="hljs-built_in"><span class="hljs-built_in">UIGraphicsGetImageFromCurrentImageContext</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">UIGraphicsEndImageContext</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> capturedImage; }</code> </pre> <br><br>  I would also like to talk about one feature of the GoogleMaps framework, with which I had to tinker pretty.  This is a way to create a custom view of InfoWindow (a window with a description that appears when a user pokes a pin). <br><br>  To display a custom window of Google Map information, call the delegate method. <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">UIView</span></span> *)mapView:(GMSMapView *)mapView markerInfoWindow:(GMSMarker *)marker;</code> </pre> <br><br>  apparently, this method should return a UIView object.  Different components can be placed on this view (UILabel, UIImageView etc), and all this will eventually be displayed next to the selected pin.  It seems everything is clear and does not cause suspicion.  However, in our case, it became necessary to redraw the window due to the fact that the preview image at the time of opening InfoWindow may not be loaded from the server.  In this case, the image loading process is started, after which you need to redraw the InfoWindow.  And then there was a nuance.  I thought it would be enough to save a pointer to a UIView, which we return in the delegate method, and then use the properties to change the image to the nested UIImageView.  It turned out that GoogleMaps rasterizes (translates to a UIImage) a UIView given to it, perhaps for optimization reasons, so all attempts to redraw it in a planned way were in vain. <br><br>  As a result, had to invent a hack.  It consisted in the following: when tapping on the pin, an empty InfoWindow is shown, if there is no data yet, the boot process starts, and then the following happens: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">UIView</span></span> *)mapView:(GMSMapView *)mapView markerInfoWindow:(GMSMarker *)marker { TMMapImagePreview *view = [[TMMapImagePreview alloc] initWithFrame:<span class="hljs-built_in"><span class="hljs-built_in">CGRectMake</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, mapView.frame.size.width * <span class="hljs-number"><span class="hljs-number">0.7</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>)]; <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> image = marker.userData; <span class="hljs-built_in"><span class="hljs-built_in">NSData</span></span> *imgData = (((MapCluster *)image).image).imageThumbnailData; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (imgData) view.imgView.image = [<span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> imageWithData:imgData]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> * url = (((MapCluster *)image).image).imageThumbnailURL; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (url) { [[ImageCache sharedInstance] downloadDataAtURL:[<span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span> URLWithString:url] completionHandler:^(<span class="hljs-built_in"><span class="hljs-built_in">NSData</span></span> *data) { (((MapCluster *)image).image).imageThumbnailData = data; [marker setSnippet:<span class="hljs-string"><span class="hljs-string">@""</span></span>]; [mapView_ setSelectedMarker:marker]; }]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> view; }</code> </pre> <br><br>  here TMMapImagePreview is a descendant class of UIView, the InfoWindow layout is formed in it.  All the magic of forced redrawing is enclosed in the compeltion-block of the ImageCache single-file downloadDataAtURL method, which, as it is not difficult to guess, deals with downloading and caching graphic content. <br><br>  It will be great you download the application, check it and give weighted criticism and comments.  Moreover, we have released an update since the writing of the first part of the post.  Need feedback  Thank! </div><p>Source: <a href="https://habr.com/ru/post/215665/">https://habr.com/ru/post/215665/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../215651/index.html">Application on Express.js + Sass / Compass + CoffeeScript + Haml</a></li>
<li><a href="../215653/index.html">We use nginx, docker, skydns and skydock to update the code on the fly (zero-downtime deployment)</a></li>
<li><a href="../215655/index.html">Downloading historical data to SAP using LSMW (Legacy System Migration Workbench)</a></li>
<li><a href="../215657/index.html">We program in Python</a></li>
<li><a href="../215661/index.html">In the Indian police for 8 years did not respond to complaints because they lost the password from the database</a></li>
<li><a href="../215667/index.html">Pwn2Own 2014: first results</a></li>
<li><a href="../215669/index.html">New gTLD statistics</a></li>
<li><a href="../215671/index.html">How to return to the usual style of issuing Google. Simple instruction</a></li>
<li><a href="../215673/index.html">Generating the correct code of the banner zone in JavaScript</a></li>
<li><a href="../215675/index.html">Rails 4. Web Application Development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>