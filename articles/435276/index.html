<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Javascript multithreaded computing, or how the phone won the laptop race</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 We continue the battle for Javascript performance using the example of creating pivot tables. Last time, we implemented several optimizat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Javascript multithreaded computing, or how the phone won the laptop race</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br><br>  We continue the battle for Javascript performance using the example of creating pivot tables.  <a href="https://habr.com/post/434438/">Last time,</a> we implemented several optimizations, and the last real opportunity to speed up the calculation remained - to switch to multi-threaded calculations.  In Javascript, <a href="https://developer.mozilla.org/ru/docs/DOM/Using_web_workers">workers</a> have long existed, the implementation of which is not without flaws, but it is stated that they use real operating system threads - so why not try?  Suddenly, it turned out that to parallelize a simple, in essence, algorithm, we had to rewrite syntacys of aggregate formulas, since the old ones did not have the additivity property (in more detail under the cut), but ultimately everything turned out. <br><br>  The processing of 1 million facts was tested on two devices: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Linux netbook 4.15, 2 x Intel Celeron CPU N2830 @ 2.16 GHz </li><li>  Android phone 7.0,4 x ARM Cortex-A53 @ 1.44 GHz </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sk/3c/1v/sk3c1vrthnwxuqx2z3tcb2zmj5y.png"></div><a name="habracut"></a><br>  From the graphs it follows several conclusions. <br><br><ol><li>  The gain from multithreading turned out to be quite modest, much less than expected, because there are no miracles - software multithreading requires hardware multiprocessing, and in our devices there are few cores. </li><li>  The optimal size of the pool of workers is the same as the number of cores.  That is why the phone, consistently losing all single-threaded tests, suddenly took the lead, showing the best result - a million facts in 9 seconds. </li><li>  The one-pass algorithm is scaled linearly ‚Äî as the amount of input data increases by an order of magnitude ‚Äî the calculation time increases by the same order.  I checked on the phone - 10 million facts settled in 80 seconds, 100 million facts in 1000 seconds.  Nothing hung and fell.  About 15 years ago for tables of this size usually bought Oracle. </li><li>  Since business applications are actively moving to WEB and mobile phones - multi-core personal devices are absolutely justified, and multi-threaded programming is just a must have, even for the frontend. </li></ol><br>  You can play with the tests yourself - the <a href="https://pocketolap.com/3">application is here</a> , the test data generator is included, the calculation time is displayed. <br><br><h3>  Algorithm features </h3><br>  Let me remind you what is our algorithm.  An unstructured fact store is used as the source data; a data scheme is not created.  JSON is sent to the input, containing interleaved operations and directories.  We define calculations at 2 levels - a formula at the level of an individual fact (essentially a calculated attribute), and an aggregate formula at the row level of the pivot table.  Then we apply a filter, and build a pivot table in one pass through the array of facts.  In this single cycle, grouping is performed, aggregates are calculated, reference data is extracted, and column widths are determined. <br><br>  Data is stored in IndexedDB in blocks, each worker is allocated its own range of blocks, the main thread starts the workers, periodically receives status from them (the number of records processed), and, waiting for everyone to stop, it reduces the result.  In the control example, the time for converting the result is negligible, but on other data, of course, there may be options.  For the result to be reduced correctly, all aggregate formulas must have additivity, that is, they could be applied to both single facts and already counted blocks. <br><br><h3>  Aggregate formulas </h3><br>  I did not understand before why Excel, adult OLAP systems and RDBMSs do not allow writing their own aggregate function in a scripting language, but contain only a set of predefined types like sum (), avg () and so on.  For example, for a long time in Excel, there was not even a count_distinct function, and even now not all DBMSs have it.  It turns out that if the user is allowed to determine his aggregate functions, not all of them will be additive, which means that the calculation cannot be parallelized, which is deadly for an industrial system.  Let's show it on the example of 3 array aggregation functions: <br><br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>].reduce( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">accumulator, currentValue</span></span></span><span class="hljs-function">) =&gt;</span></span> accumulator + currentValue )); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>].reduce( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">accumulator, currentValue</span></span></span><span class="hljs-function">) =&gt;</span></span> (accumulator + currentValue) ** <span class="hljs-number"><span class="hljs-number">2</span></span> )); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>].reduce( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">accumulator, currentValue</span></span></span><span class="hljs-function">) =&gt;</span></span> accumulator + currentValue ** <span class="hljs-number"><span class="hljs-number">2</span></span> ));</code> </pre> <br>  The first function is additive, since it can be applied to itself, that is: <br><br>  <b><i>accumulator + (accumulator + currentValue)</i></b> . <br><br>  The second function cannot be parallelized at all, it is necessary to work with the third one, because applying it in the forehead to the block: <br><br>  <b><i>accumulator + (accumulator + currentValue ** 2) ** 2</i></b> - will give an incorrect result, but if you parse the expression, and understand that this is just a sum of squares - additivity is achieved.  In our algorithm, accumulator is not just a scalar, but an array representing the current row of the pivot table, and currentValue is, respectively, an array of attribute values ‚Äã‚Äãof the current fact (including those calculated), with the result that the risk of additivity breaks increases. <br><br>  I recall that in the <a href="https://habr.com/post/433080/">first version of the</a> application, the functions fact (colname) and row (colname) were used in the aggregate formulas (the first one returns the attribute of the current fact, the second - the intermediate calculated value of the pivot table column), and already from them the summing, counting, and etc.  However, the user is tempted to use, for example, several attributes of the fact in one aggregate formula, which is unacceptable if we want multithreading.  I was too lazy to do the parsing of formulas - what the user can think of - and I made the simplest decision - to prohibit using fact attributes directly in the aggregate formula, but only wrapping them in predefined aggregate primitives, thus our summary table will be described with the following formulas: <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"quantity-sum"</span></span>: <span class="hljs-string"><span class="hljs-string">"sum('quantity')"</span></span>, <span class="hljs-string"><span class="hljs-string">"amount-sum"</span></span>: <span class="hljs-string"><span class="hljs-string">"round(sum('amount'), 2)"</span></span>, <span class="hljs-string"><span class="hljs-string">"price-max"</span></span>: <span class="hljs-string"><span class="hljs-string">"max('price')"</span></span>, <span class="hljs-string"><span class="hljs-string">"price-min"</span></span>: <span class="hljs-string"><span class="hljs-string">"min('price')"</span></span>, <span class="hljs-string"><span class="hljs-string">"price-last"</span></span>: <span class="hljs-string"><span class="hljs-string">"last('price')"</span></span>, <span class="hljs-string"><span class="hljs-string">"price-avg"</span></span>: <span class="hljs-string"><span class="hljs-string">"round(sum('price') / count(), 2)"</span></span>, <span class="hljs-string"><span class="hljs-string">"price-weight"</span></span>: <span class="hljs-string"><span class="hljs-string">"round(sum('amount') / sum('quantity'), 2)"</span></span>, <span class="hljs-string"><span class="hljs-string">"EAN-code"</span></span>: <span class="hljs-string"><span class="hljs-string">"selectlast('EAN-code', \"fact('product') == row('product')\")"</span></span></code> </pre><br>  Re-computing does not occur - the results of the calculation of aggregate primitives are cached.  Primitives sum (), count (), mul (), min (), max (), last (), first () are available.  The last function selectlast () pulls up the directory attribute from another fact, that is, in effect, it implements the join store itself to itself, but is calculated in a common cycle, that is, without loss of performance.  As for the functions <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BE%25D0%25B4%25D0%25B0_(%25D1%2581%25D1%2582%25D0%25B0%25D1%2582%25D0%25B8%25D1%2581%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)">mode ()</a> , <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25B0%25D0%25BD%25D0%25B0_(%25D1%2581%25D1%2582%25D0%25B0%25D1%2582%25D0%25B8%25D1%2581%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)">median ()</a> , count_distinct (), they are not additive, do not scale linearly, until the end of the calculation they will need to store all values ‚Äã‚Äãin a separate structure (memory consumption), and therefore will be implemented later. <br><br><h3>  Summary </h3><br>  Probably, we can finish Javascript overclocking on this; we still didn‚Äôt quite catch up with Excel, although we came very close.  Theoretically, you can still look in the direction of GPU-computing, for which you have to completely rewrite the algorithm ( <a href="http://vasilisc.com/libreoffice-calc-amd">there is a precedent</a> ), but, in principle, it turned out pretty well.  I wish you pleasant programming and fresh ideas! </div><p>Source: <a href="https://habr.com/ru/post/435276/">https://habr.com/ru/post/435276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../435262/index.html">Li-Fi: The Future of the Internet</a></li>
<li><a href="../435264/index.html">Editing prices in the RMK. 1C: Trade Management 11</a></li>
<li><a href="../435268/index.html">Do not treat me, doctor</a></li>
<li><a href="../435272/index.html">Cycling phobia</a></li>
<li><a href="../435274/index.html">PVS-Studio and Bug Bounties on Free and Open Source Software</a></li>
<li><a href="../435278/index.html">10 materials about unusual musical instruments and atypical ways of sound extraction</a></li>
<li><a href="../435282/index.html">Sales of vinyl and magnetic tapes are growing.</a></li>
<li><a href="../435284/index.html">Microchips that make life easier for thousands of Swedes</a></li>
<li><a href="../435286/index.html">How I saved Mars or a small quest on python</a></li>
<li><a href="../435288/index.html">A swarm of satellites as a replacement for large orbital telescopes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>