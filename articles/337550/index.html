<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Learn OpenGL. Part 2.4. - Texture Cards</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Earlier we discussed the possibility of each object to have a unique material in order to respond differently to light. This is great for giving each ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Learn OpenGL. Part 2.4. - Texture Cards</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="image" align="left" width="300"></p><br><p>  Earlier we discussed the possibility of each object to have a unique material in order to respond differently to light.  This is great for giving each object a unique look relative to other objects in the scene.  But this still does not give us much flexibility in customizing the appearance of the object. </p><br><a name="habracut"></a><br><br><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text">  Part 1. Start <br><br><ol><li>  <a href="https://habrahabr.ru/post/310790/">Opengl</a> </li><li>  <a href="https://habrahabr.ru/post/311198/">Creating a window</a> </li><li>  <a href="https://habrahabr.ru/post/311234/">Hello window</a> </li><li>  <a href="https://habrahabr.ru/post/311808/">Hello triangle</a> </li><li>  <a href="https://habrahabr.ru/post/313380/">Shaders</a> </li><li>  <a href="https://habrahabr.ru/post/315294/">Textures</a> </li><li>  <a href="https://habrahabr.ru/post/319144/">Transformations</a> </li><li>  <a href="https://habrahabr.ru/post/324968/">Coordinate systems</a> </li><li>  <a href="https://habrahabr.ru/post/327604/">Camera</a> </li></ol><br>  Part 2. Basic lighting 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  <a href="https://habrahabr.ru/post/329592/">Colors</a> </li><li>  <a href="https://habrahabr.ru/post/333932/">Lighting Basics</a> </li><li>  <a href="https://habrahabr.ru/post/336166/">Materials</a> </li><li>  <a href="https://habrahabr.ru/post/337550/">Texture Cards</a> </li><li>  <a href="https://habrahabr.ru/post/337642/">Sources of light</a> </li><li>  <a href="https://habrahabr.ru/post/338254/">Multiple light sources</a> </li></ol><br>  Part 3. Loading 3D Models <br><br><ol><li>  <a href="https://habrahabr.ru/post/338436/">Assimp library</a> </li><li>  <a href="https://habrahabr.ru/post/338436/">Mesh mesh class</a> </li><li>  <a href="https://habrahabr.ru/post/338998/">Model class</a> </li></ol><br>  Part 4. OpenGL advanced features <br><br><ol><li>  <a href="https://habrahabr.ru/post/342610/">Depth test</a> </li><li>  <a href="https://habrahabr.ru/post/344238/">Stencil test</a> </li><li>  <a href="https://habrahabr.ru/post/343096/">Mixing colors</a> </li><li>  <a href="https://habrahabr.ru/post/346964/">Face clipping</a> </li></ol></div></div><br><br><h1>  Texture Cards </h1><br><p>  In the previous lesson, we defined material for a whole object, but in the real world, objects usually consist of not one, but several materials.  Imagine a car: its external case is brilliant;  windows partially reflect the environment;  the car also has frosted tires, and there are sparkling rims (sparkling if you wash your car well).  So, each object has different material properties for each part. </p><br><p>  So, our system of materials from the previous lesson is not suitable for more or less complex objects, so we need to expand it by introducing <em>diffuse</em> and <em>specular</em> maps.  This will give us the opportunity to influence the diffuse (and, indirectly, the background, as it is almost always the same) and the specular component of the object with greater accuracy. </p><br><h2>  Diffuse cards </h2><br><p>  All we need is a way to set a diffuse color for each object fragment.  What can affect the color value based on the position of the fragment? </p><br><p>  Do you remember?  These are textures that we discussed extensively in a previous lesson.  Lighting maps are just another name for the same principle: using an image applied to the surface of an object, we can make color samples for each fragment.  In scenes with lighting, this is usually referred to as a <em>diffuse map</em> (usually 3D artists call it that way), since the texture image represents all the diffuse colors of an object. </p><br><p>  To show diffuse maps, we will use an <a href="">image of a</a> wooden container with an iron frame: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/15e/bda/b33/15ebdab33f70067567ca9603b495f7ba.png"></p><br><p> Using diffuse maps in shaders is very similar to using textures in one of the previous lessons.  However, now we will replace the previously defined <code>vec3</code> <strong>vector of the</strong> diffuse color with the diffuse <code>sampler2D</code> <strong>map</strong> . </p><br><blockquote><p>  Keep in mind that <code>sampler2D</code> is the so-called <strong>opaque data type</strong> .  This means that we cannot create an instance of this type; we can only define it as <em>uniform</em> .  If we try to use this type <strong>not</strong> as <em>uniform</em> (for example, as a function parameter), then GLSL will produce strange errors.  This rule also applies to any structure that contains an <em>opaque type</em> . </p><br></blockquote><br><p>  We also deleted the <code>ambient</code> vector, since in most cases it coincides with the diffuse color, so we don‚Äôt need to keep it separate: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Material { sampler2D diffuse; vec3 specular; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shininess; }; ... <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec2 TexCoords;</code> </pre><br><blockquote><p>  If you are so stubborn and still want to set the background color to be non-diffuse, you can leave the <code>ambient</code> vector.  But the background color will be the <strong>same</strong> for the <strong>entire</strong> object.  To get different background color values ‚Äã‚Äãfor each object fragment, you need to use a separate texture for the background color values. </p><br></blockquote><br><p>  Note that we need texture coordinates in the fragment shader again, so we declare an additional input variable.  Then we simply sample the texture to extract the diffuse color value of the fragment: </p><br><pre> <code class="hljs markdown">vec3 diffuse = light.diffuse <span class="hljs-bullet"><span class="hljs-bullet">* diff *</span></span> vec3(texture(material.diffuse, TexCoords));</code> </pre><br><p>  Also, do not forget to set the background color of the material to be the same as the diffuse one: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">vec3</span></span> ambient = light.ambient * vec3(texture(material.diffuse, TexCoords));</code> </pre><br><p>  This is all we need to use a diffuse map.  As you can see, this is nothing new, but it gives an impressive increase in visual quality.  For this to work, we need to add texture coordinates to the vertex data and transfer them as a vertex attribute to the fragment shader, load the texture and link it to the corresponding texture block. </p><br><p>  Updated vertex data can be found <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dlighting/vertex_data_textures">here</a> .  Now they include vertex positions, normal vectors, and texture coordinates for each vertex of the cube.  Let's update the vertex shader so that it can take texture coordinates as a vertex attribute and pass them to the fragment shader: </p><br><pre> <code class="hljs mel">#version <span class="hljs-number"><span class="hljs-number">330</span></span> core <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span> (location = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 aPos; <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span> (location = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 aNormal; <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span> (location = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec2 aTexCoords; ... out vec2 TexCoords; void main() { ... TexCoords = aTexCoords; }</code> </pre><br><p>  Make sure to update the vertex attributes of both VAO ( <em>note the translator: meaning VAO textured cube and VAO cube-lamp</em> ) so that they coincide with the new vertex data, and load the image of the container into the texture.  Before drawing the container, we need to assign the preferred texture unit to the <code>material.diffuse</code> variable and associate the texture of the container with it: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">lightingShader</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setInt</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">material</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.diffuse</span></span>", 0); ... <span class="hljs-selector-tag"><span class="hljs-selector-tag">glActiveTexture</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL_TEXTURE0</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">glBindTexture</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL_TEXTURE_2D</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">diffuseMap</span></span>);</code> </pre><br><p>  Using a diffuse map, we again got a huge increase in detail and now, with added lighting, our container really began to shine (literally).  It probably now looks like this: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/69b/fcf/bcc/69bfcfbcc6ca1023db0261cf5b9cc671.png"></p><br><p>  You can find the full source code of the application <a href="https://learnopengl.com/code_viewer_gh.php%3Fcode%3Dsrc/2.lighting/4.1.lighting_maps_diffuse_map/lighting_maps_diffuse.cpp">here</a> . </p><br><h2>  Glare cards </h2><br><p>  You probably noticed that the flare looks a bit strange, because our object is a container, which mostly consists of wood.  And, as we know, the tree does not give such a mirror shine.  We can fix this by setting the <code>specular</code> vector in the <code>Material</code> structure to be <code>vec3(0.0)</code> , but this means that the iron frame of the container will also stop giving glare, and we know that the metal <strong>should</strong> , at least shine a little.  And again we would like to control which parts of the object should shine and with what force.  This problem is very similar to the discussion of diffuse maps.  Coincidence?  I do not think. </p><br><p>  We can again use the texture map, only now for mirror highlights.  This means that we need to create a black and white (or color, if you want) texture that determines the brilliance of each part of the object.  Here is an example of a <a href="">glare map</a> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6ab/97b/ecb/6ab97becbeb5a018e18f7828c74de150.png"></p><br><p>  The intensity of the brightness is determined by the brightness of each pixel of the image.  Each pixel of such a card can be represented as a color vector, where black is <code>vec3(0.0)</code> and gray is <code>vec3(0.5)</code> , for example.  Then, in the fragment shader, we select the corresponding color value and multiply it by the intensity of the highlight color.  Accordingly, the "whiter" the pixel, the greater the result of the multiplication, and, consequently, the brightness of the glare on the object fragment. </p><br><p>  Since the container is mostly made of wood, and wood is a material that does not give glare, the entire ‚Äúwooden‚Äù part of the texture is painted black.  The black pieces <strong>do</strong> n't shine <strong>at all</strong> .  The surface of the steel frame of the container has a variable power of specular gloss: the steel itself gives quite intense glares, while cracks and abrasions do not. </p><br><blockquote><p>  Technically, wood also has specular reflections, although with a much lower gloss power (the light is more diffused), but for educational purposes, we pretend that the wood does not react to specular light. </p><br></blockquote><br><p>  Using tools such as <em>Photoshop</em> or <em>Gimp</em> , it is quite simple to turn a diffuse texture into a glare.  Simply cut out some parts, make the image black and white and increase the brightness / contrast. </p><br><h2>  Sampling of glare maps </h2><br><p>  The specular reflection map is the most common texture, so its loading code is very similar to the diffuse map loading.  Make sure you have loaded the image correctly and generated a texture object.  Since we are using a new texture in the same fragment shader, we need to use another texture unit for the highlight map.  Let's link this texture with the appropriate texture unit before rendering: </p><br><pre> <code class="cpp hljs">lightingShader.setInt(<span class="hljs-string"><span class="hljs-string">"material.specular"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); ... glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, specularMap);</code> </pre><br><p>  Then we will update the material properties in the fragment shader so that the reflecting component is taken as <code>sampler2D</code> , not <code>vec3</code> : </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Material</span></span></span><span class="hljs-class"> {</span></span> sampler2D diffuse; sampler2D specular; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shininess; };</code> </pre><br><p>  And, finally, we need to sample the glare map in order to get the corresponding flare intensity for each object fragment: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">vec3</span></span> ambient = light.ambient * vec3(texture(material.diffuse, TexCoords)); <span class="hljs-attribute"><span class="hljs-attribute">vec3</span></span> diffuse = light.diffuse * diff * vec3(texture(material.diffuse, TexCoords)); <span class="hljs-attribute"><span class="hljs-attribute">vec3</span></span> specular = light.specular * spec * vec3(texture(material.specular, TexCoords)); <span class="hljs-attribute"><span class="hljs-attribute">FragColor</span></span> = vec4(ambient + diffuse + specular, <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br><p>  Using the glare map, we can determine with extreme accuracy which parts of the object mirror reflections give and determine their corresponding intensity.  Thus, the glare map gives us an additional level of control over the diffuse map. </p><br><blockquote><p>  You can also use colors in the glare map, which determine not only the intensity of the glare, but also its color.  However, in reality, the color of the glare largely (and in most cases completely) depends on the light source, therefore the use of color glare maps will not give realistic results (which is why these images are usually black and white - we are only interested in the glare intensity). </p><br></blockquote><br><p>  If you run the application, you will see that the container material is very similar to a wooden container with an iron frame: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a7a/649/6fd/a7a6496fd4623c7b99dd093236d1cdb0.png"></p><br><p>  You can find the full source code of the application <a href="https://learnopengl.com/code_viewer_gh.php%3Fcode%3Dsrc/2.lighting/4.2.lighting_maps_specular_map/lighting_maps_specular.cpp">here</a> . </p><br><p>  Using diffuse and specular maps, we can add a huge amount of detail to relatively simple objects.  We can add even more details using other texture maps, such as normal / relief maps and / or reflection maps, but we will save them for the next lessons.  Show your container to friends and family and remember that one day our container may become even more attractive than it is now! </p><br><h2>  Exercises </h2><br><ul><li>  Try to play with the background, diffuse and glare vectors of the light source and see how they affect the appearance of the object. </li><li>  Try to invert the colors of the highlight map in the fragment shader, i.e.  the tree should shine, and the iron frame should not (note that the cracks in the frame still mirror, albeit with less intensity): the <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dlighting/lighting_maps-exercise2">solution</a> . </li><li>  Try to create a glare map from a diffuse map that uses non-black and white colors, and you will see that the result is not very realistic.  You can use this <a href="">color highlight map</a> if you cannot do it yourself.  <a href="">Result</a> . </li><li>  You can also try adding <em>an emission map</em> to our cube that stores the luminosity value of each object fragment.  Emission values ‚Äã‚Äãare colors that an object can <em>emit</em> as if it contained a source of light.  Thus, the object can be lit regardless of the lighting conditions.  Usually glow maps can be seen on those game objects that glow (for example <a href="">, the robot's eyes</a> or <a href="">stripes of light on the container</a> ).  Add <a href="">this</a> texture (from creativesam) to our container as a glow card, so that the letters emit light.  <a href="https://learnopengl.com/code_viewer_gh.php%3Fcode%3Dsrc/2.lighting/4.3.lighting_maps_exercise4/lighting_maps_exercise4.cpp">The decision</a> , the <a href="">result</a> . </li></ul></div><p>Source: <a href="https://habr.com/ru/post/337550/">https://habr.com/ru/post/337550/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337536/index.html">Fix 7 common exception handling errors in java</a></li>
<li><a href="../337538/index.html">‚ÄúYoung people want to buy shares of familiar start-ups on the stock exchange‚Äù: finance trends according to the founder of the Robinhood service</a></li>
<li><a href="../337540/index.html">Setting up a Webpack 3 + Angular 4 development environment: from complex to simple</a></li>
<li><a href="../337546/index.html">Why don't CRM work</a></li>
<li><a href="../337548/index.html">Kaggle: how our nets considered sea lions in the Aleutian Islands</a></li>
<li><a href="../337554/index.html">The path of the Jedi. From a small user to an employee of an IT company</a></li>
<li><a href="../337556/index.html">SAMBA File Server Based on Linux CentOS 7</a></li>
<li><a href="../337558/index.html">What is LinkedList under the hood?</a></li>
<li><a href="../337560/index.html">Why did we do VOD on WebRTC</a></li>
<li><a href="../337564/index.html">Specific use of Redux in Polymer and Vue</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>