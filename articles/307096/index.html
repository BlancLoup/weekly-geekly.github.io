<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why use RxJava in Android - a brief introduction to RxJava</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello everyone. 

 We continue to acquaint you with our publishing search, and wanted to probe public opinion on the topic of RxJava. 



 In the near...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why use RxJava in Android - a brief introduction to RxJava</h1><div class="post__text post__text-html js-mediator-article">  Hello everyone. <br><br>  We continue to acquaint you with our publishing search, and wanted to probe public opinion on the topic of RxJava. <br><br><img src="https://habrastorage.org/files/e36/dbb/593/e36dbb593ba04fac9a0ef02653cd594e.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the near future we are going to publish a more general material on reactive programming, which we are also interested in not for the first year, but today we suggest reading about the use of RxJava in Android, since dynamism and responsiveness are especially important on this platform.  Welcome under cat <br><a name="habracut"></a><br>  In most Android applications, we respond to user actions (clicks, flicking, etc.), while some other work (network) is in the background. <br><br>  Orchestration of all these processes is a difficult task; any code risks quickly turning into a shapeless mess. <br>  For example, it is not so easy to send a request to the database over the network, and after it is executed, immediately start simultaneously selecting both user messages and settings, and after completing all this work, display a welcome message. <br><br>  It is in such cases that <a href="https://github.com/ReactiveX/RxJava">RxJava</a> (ReactiveX) is a library that allows you to organize many actions caused by certain events in the system. <br><br>  Working with RxJava, you can forget about callbacks and the hellish control of the global state. <br><br>  <b>Why?</b> <br><br>  Let's return to our example: <br><br><blockquote>  send a request to the database over the network, and after its execution, immediately start simultaneously selecting user messages and settings, and after completing all this work, display a welcome message. </blockquote><br><br>  If we analyze this situation in more detail, we will find three main stages in it, <b>all three occurring in the background</b> : <br><br><ol><li>  Select user from database </li><li>  <b>Simultaneously</b> select custom settings and messages </li><li>  Combine the results of both queries into one </li></ol><br><br>  To do the same in Java SE and Android, we would need: <br><br><ol><li> Make 3-4 different <code>AsyncTasks</code> </li><li>  Create a semaphore that will wait for the completion of both requests (by settings and by messages) </li><li>  Implement object-level fields for storing results. </li></ol><br><br>  It is already clear that for this purpose it is required to manage the state, and also to use some blocking mechanisms that exist in Java. <br><br>  All this can be avoided by working with RxJava (see examples below) - all code looks like a stream located <b>in one place</b> and is built on the basis of the <b>functional</b> paradigm (see <a href="http://c2.com/cgi/wiki%3FAdvantagesOfFunctionalProgramming">here</a> ). <br><br>  <b>Quick start in Android</b> <br><br>  To get the libraries that you most likely need for your project, insert the following lines into your build.gradle file: <br><br>  compile 'io.reactivex: rxjava: 1.1.0' <br><pre> <code class="java hljs">compile <span class="hljs-string"><span class="hljs-string">'io.reactivex:rxjava-async-util:0.21.0'</span></span> compile <span class="hljs-string"><span class="hljs-string">'io.reactivex:rxandroid:1.1.0'</span></span> compile <span class="hljs-string"><span class="hljs-string">'com.jakewharton.rxbinding:rxbinding:0.3.0'</span></span> compile <span class="hljs-string"><span class="hljs-string">'com.trello:rxlifecycle:0.4.0'</span></span> compile <span class="hljs-string"><span class="hljs-string">'com.trello:rxlifecycle-components:0.4.0'</span></span></code> </pre><br><br>  Thus will be included: <br><br><ul><li>  <a href="https://github.com/ReactiveX/RxJava">RxJava</a> is the main ReactiveX library for Java. </li><li>  <a href="https://github.com/ReactiveX/RxAndroid">RxAndroid</a> - <a href="https://github.com/ReactiveX/RxAndroid">RxJava</a> extensions for Android, which will help to work with threads in Android and with Loopers. </li><li>  <a href="https://github.com/JakeWharton/RxBinding">RxBinding</a> - bindings between RxJava and Android user interface elements, in particular, Buttons buttons and text views of TextViews </li><li>  <a href="https://github.com/ReactiveX/RxJavaAsyncUtil">RxJavaAsyncUtil</a> - helps to glue <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Callable.html">Callable</a> and <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html">Future</a> code. </li></ul><br><br>  <b>Example</b> <br><br>  Let's start with an example: <br><br><pre> <code class="java hljs">Observable.just(<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-string"><span class="hljs-string">"2"</span></span>) .subscribe(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Action1&lt;String&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(s); } });</code> </pre><br><br>  Here we have created <a href="http://reactivex.io/documentation/observable.html">Observable</a> , which will generate two elements - 1 and 2. <br>  We have subscribed to observable, and now, as soon as the item is received, we will display it on the screen. <br><br>  <b>Some details</b> <br><br>  An <i>Observable</i> object is an entity that you can subscribe to and then receive generated Observable elements.  They can be created in a variety of ways.  However, the Observable does not usually start generating elements until you subscribe to them. <br><br>  After you subscribe to observable, you will receive a subscription (subscription).  The subscription will receive objects from observable until it signals that it has completed its work (does not put such a mark), or (in very rare cases) the reception will continue indefinitely. <br><br>  Moreover, all these actions will be performed in the main thread. <br><br>  <b>Advanced example</b> <br><br><pre> <code class="java hljs">Observable.from(fetchHttpNetworkContentFuture()) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Action1&lt;String&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(s); } }, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Action1&lt;Throwable&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable throwable)</span></span></span><span class="hljs-function"> </span></span>{ throwable.printStackTrace(); } });</code> </pre><br><br>  Here we see something new: <br><ol><li>  subscribeOn (Schedulers.io ()) - thanks to this method, Observable will perform waiting and calculations in the thread pool ThreadPool intended for input / output (Schedulers.io ()). </li><li>  observeOn (AndroidSchedulers.mainThread ()) - thanks to this method, the result of the subscriber‚Äôs action will be performed on the main Android thread.  This is required in cases where you need to change something in the Android user interface. </li><li>  In the second argument to .subscribe (), an error handler appears for operations with a subscription in case something goes wrong.  Such a thing should be present almost always. </li></ol><br><br>  <b>Complex flow control</b> <br><br>  Remember the complex flow we described at the very beginning? <br><br>  This is how it will look like with RxJava: <br><br><pre> <code class="java hljs">Observable.fromCallable(createNewUser()) .subscribeOn(Schedulers.io()) .flatMap(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Func1&lt;User, Observable&lt;Pair&lt;Settings, List&lt;Message&gt;&gt;&gt;&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Observable&lt;Pair&lt;Settings, List&lt;Message&gt;&gt;&gt; call(User user) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.zip( Observable.from(fetchUserSettings(user)), Observable.from(fetchUserMessages(user)) , <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Func2&lt;Settings, List&lt;Message&gt;, Pair&lt;Settings, List&lt;Message&gt;&gt;&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Pair&lt;Settings, List&lt;Message&gt;&gt; call(Settings settings, List&lt;Message&gt; messages) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Pair.create(settings, messages); } }); } }) .doOnNext(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Action1&lt;Pair&lt;Settings, List&lt;Message&gt;&gt;&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pair&lt;Settings, List&lt;Message&gt;&gt; pair)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Received settings"</span></span> + pair.first); } }) .flatMap(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Func1&lt;Pair&lt;Settings, List&lt;Message&gt;&gt;, Observable&lt;Message&gt;&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Observable&lt;Message&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pair&lt;Settings, List&lt;Message&gt;&gt; settingsListPair)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.from(settingsListPair.second); } }) .subscribe(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Action1&lt;Message&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Message message)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"New message "</span></span> + message); } });</code> </pre><br><br>  In this case, a new user (createNewUser ()) will be created, and at the stage of creating and returning the result, the selection of user messages (fetchUserMessages ()) and user settings (fetchUserSettings) will continue at the same time.  We will wait for both actions to complete and return the combined result (Pair.create ()). <br><br>  Do not forget - all this happens in a separate thread (in the background). <br><br>  Then the program will display the results.  Finally, the list of messages will be adapted to another observable, which will display messages one by one, rather than a whole list, with each message appearing in the terminal window. <br><br>  <b>Functional approach</b> <br><br>  It will be much easier to work with RxJava if you are familiar with functional programming, in particular, with map and zip concepts.  In addition, generalized logic is very similar in RxJava and OP. <br><br>  <b>How to create your own observable?</b> <br><br>  If the code becomes largely tied to RxJava (for example, <a href="http://www.feedpresso.com/">here</a> ), then often you will have to write your own observable, so that they fit into the logic of your program. <br><br>  Consider an example: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Observable&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">customObservable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rx.Observable.create(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> rx.Observable.OnSubscribe&lt;String&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Subscriber&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String&gt; subscriber)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     Scheduler.Worker inner = Schedulers.io().createWorker(); subscriber.add(inner); inner.schedule(new Action0() { @Override public void call() { try { String fancyText = getJson(); subscriber.onNext(fancyText); } catch (Exception e) { subscriber.onError(e); } finally { subscriber.onCompleted(); } } }); } }); }</span></span></code> </pre><br><br>  But a similar option that does not require performing an action strictly in a specific thread: <br><br><pre> <code class="java hljs">Observable&lt;String&gt; observable = Observable.create( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable.OnSubscribe&lt;String&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscriber&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String&gt; subscriber)</span></span></span><span class="hljs-function"> </span></span>{ subscriber.onNext(<span class="hljs-string"><span class="hljs-string">"Hi"</span></span>); subscriber.onCompleted(); } } );</code> </pre><br><br>  Here it is important to note three methods: <br><br><ol><li>  onNext (v) - sends a new value to the subscriber </li><li>  onError (e) - notifies the observer about the error that occurred </li><li>  onCompleted () - notifies the subscriber that you should unsubscribe, since no more content will be received from this observable </li></ol><br><br>  In addition, it will probably be convenient to use RxJavaAsyncUtil. <br><br>  Integration with other libraries <br><br>  As RxJava becomes more popular and de facto turns into the standard of asynchronous programming in Android, more and more libraries are increasingly integrating with it. <br><br>  Just a few examples: <br><br>  <a href="https://github.com/square/retrofit">Retrofit</a> - "Type-safe HTTP-client for Android and Java" <br>  <a href="https://github.com/square/sqlbrite">SqlBrite</a> - ‚ÄúLightweight wrapper for SQLiteOpenHelper, enriching SQL operations with semantics of reactive flows.‚Äù <br>  <a href="https://github.com/pushtorefresh/storio">StorIO</a> - ‚ÄúBeautiful API for SQLiteDatabase and ContentResolver‚Äù <br><br>  All of these libraries greatly simplify working with HTTP requests and databases. <br><br>  <b>Interactivity with Android UI</b> <br><br>  This introduction would be incomplete if we did not consider how to use native UI elements in Android. <br><br><pre> <code class="java hljs">TextView finalText; EditText editText; Button button; ... RxView.clicks(button) .subscribe(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Action1&lt;Void&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Void aVoid)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Click"</span></span>); } }); RxTextView.textChanges(editText) .subscribe(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Action1&lt;CharSequence&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CharSequence charSequence)</span></span></span><span class="hljs-function"> </span></span>{ finalText.setText(charSequence); } }); ...</code> </pre><br><br>  Obviously, you can simply rely on setOnClickListener, but in the long run, RxBinding might be better for you, because it allows you to connect the UI to the general flow of RxJava. <br><br>  <b>Tips</b> <br><br>  Practice shows that when working with RxJava, you should follow some rules. <br><br>  <i><b>Always use error handler</b></i> <br><br>  Skip the error handler in this way. <br><pre> <code class="java hljs">.subscribe(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Action1&lt;Void&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Void aVoid)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Click"</span></span>); } });</code> </pre><br><br>  usually does not follow.  An exception that is thrown at the observer or in one of the actions will throw an exception that will most likely kill you the entire application. <br><br>  It would be even better to make a generic handler: <br><br><pre> <code class="java hljs">.subscribe(..., myErrorHandler);</code> </pre><br><br>  <b>Extract action methods</b> <br><br>  If you have a lot of internal classes, then after some time the readability of the code may deteriorate (especially if you are not working with RetroLambda). <br><br>  Therefore, this code: <br><br><pre> <code class="java hljs">.doOnNext(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Action1&lt;Pair&lt;Settings, List&lt;Message&gt;&gt;&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pair&lt;Settings, List&lt;Message&gt;&gt; pair)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Received settings"</span></span> + pair.first); } })</code> </pre><br><br>  would look better after this refactoring: <br><br><pre> <code class="java hljs">.doOnNext(logSettings()) <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Action1&lt;Pair&lt;Settings, List&lt;Message&gt;&gt;&gt; logSettings() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Action1&lt;Pair&lt;Settings, List&lt;Message&gt;&gt;&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pair&lt;Settings, List&lt;Message&gt;&gt; pair)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Received settings"</span></span> + pair.first); } }; }</code> </pre><br><br>  <i><b>Use own classes or tuples</b></i> <br><br>  There are cases in which a certain value is determined by a different value (for example, user and user settings), and you would like to get both of these values ‚Äã‚Äãusing two asynchronous requests. <br>  In such cases, I recommend using <a href="http://www.javatuples.org/">JavaTuples</a> . <br><br>  Example: <br><br><pre> <code class="java hljs">Observable.fromCallable(createNewUser()) .subscribeOn(Schedulers.io()) .flatMap(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Func1&lt;User, Observable&lt;Pair&lt;User, Settings&gt;&gt;&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Observable&lt;Pair&lt;User, Settings&gt;&gt; call(<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> User user) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.from(fetchUserSettings(user)) .map(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Func1&lt;Settings, Pair&lt;User, Settings&gt;&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Pair&lt;User, Settings&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Settings o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Pair.create(user, o); } }); } });</code> </pre><br><br>  <i><b>Lifecycle Management</b></i> <br><br>  It often happens that the background process (subscription) must last longer than the activity or fragment in which it is contained.  But what if the result doesn't interest you anymore, as soon as the user leaves the activity? <br><br>  In such cases, the <a href="https://github.com/trello/RxLifecycle">RxLifecycle</a> project will help you. <br><br>  Wrap your observable like this (taken from the documentation) and immediately after its destruction, an unsubscribe will be executed: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RxActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onResume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onResume(); myObservable .compose(bindToLifecycle()) .subscribe(); } }</code> </pre><br><br>  <b>Conclusion</b> <br><br>  Of course, this is not a complete guide on using RxJava in Android, but I hope I was able to convince you that in some respects RxJava is better than ordinary AsyncTask. </div><p>Source: <a href="https://habr.com/ru/post/307096/">https://habr.com/ru/post/307096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../307086/index.html">How do Fault Tolerant servers differ from ‚Äúconsumer‚Äù consumer goods in a specific example?</a></li>
<li><a href="../307088/index.html">Interception of functions .NET / CLR</a></li>
<li><a href="../307090/index.html">State machines in the SimInTech dynamic simulation environment</a></li>
<li><a href="../307092/index.html">Variant of working with the cache without access to the backend using the example of Yii2</a></li>
<li><a href="../307094/index.html">Another way to load CSS via RequireJS</a></li>
<li><a href="../307098/index.html">Started selling tickets for the conference Droidcon Moscow 2016</a></li>
<li><a href="../307102/index.html">5 organizations that give college students a paid development tool</a></li>
<li><a href="../307104/index.html">Fighting the mysterious falls of MSBuild on XamlTaskFactory</a></li>
<li><a href="../307108/index.html">Video of the conference "Payment innovations and alternative payment systems"</a></li>
<li><a href="../307110/index.html">Is there software for KCS (knowledge-centered support)?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>