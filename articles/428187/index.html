<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to write an extension for GNOME Shell: ‚ÄúDo Not Disturb‚Äù mode</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It all started with moving to a new version of a single Linux distribution, and there - the notorious GNOME Shell (GH for short), in Javascript. Well,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to write an extension for GNOME Shell: ‚ÄúDo Not Disturb‚Äù mode</h1><div class="post__text post__text-html js-mediator-article"><p>  It all started with moving to a new version of a single Linux distribution, and there - the <em>notorious</em> GNOME Shell (GH for short), in Javascript.  Well, OK, on ‚Äã‚ÄãJS, so on JS, it works - and all right. </p><br><p> At the same time, the pace of my work has long been demanding to find a normal mailer, instead of slowing down and eating tons of megabytes of the <code>outlook.office.com</code> tab in the browser.  And I found out, in our time there are several almost excellent candidates, one problem - the mailer began to get me notifications about new letters - both with sound and pop-up inscriptions. </p><br><p>  What to do?  The decision to write the "Do Not Disturb" extension did not come immediately, I really did not want to write a bicycle and / or get bogged down in the development / code / tons of errors, but I decided, and now I want to share my experience with Habr.  <sup><a href="https://habr.com/ru/post/428187/">one</a></sup> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/737/175/2b5/7371752b5fb33b8858bff75857fbfa83.jpg"></p><a name="habracut"></a><br><h2 id="tehnicheskie-trebovaniya">  Technical requirements </h2><br><p>  I want to have <del>  one big </del>  button to turn off notifications and sounds for a time of choice: 20 minutes, 40 minutes, 1 hour, 2 hours, 4, 8 and 24 hours.  <sup><a href="https://habr.com/ru/post/428187/">2</a></sup> Aha, timing as in Slack. </p><br><p>  In the expanses of extensions.gnome.org there was an extension of the "Do Not Disturb Button", which served as a model for writing its extension of <a href="https://extensions.gnome.org/extension/1484/do-not-disturb-time/">Do Not Disturb Time</a> . </p><br><h2 id="konechnyy-rezultat-do-not-disturb-timehttpsextensionsgnomeorgextension1484do-not-disturb-time">  End result: <a href="https://extensions.gnome.org/extension/1484/do-not-disturb-time/">Do Not Disturb Time</a> </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/104/41d/479/10441d479062c7540a2743c6fb0b852d.png" alt="Do Not Disturb Time"></p><br><p>  Install from the site <a href="https://extensions.gnome.org/extension/1484/do-not-disturb-time/">extensions.gnome.org</a> . <br>  Sources on <a href="https://github.com/muravjov/do-not-disturb">github</a> : we put asterisks, forkaem, we offer improvements. </p><br><h3 id="kak-ustanovit-rasshirenie-gh-instrukciya">  How to install the extension GH: instructions </h3><br><ol><li>  Install the <em>chrome-gnome-shell</em> package, a browser connector, using the example of Ubuntu: <br> <code>sudo apt install chrome-gnome-shell</code> </li> <li>  Click the <a href="https://extensions.gnome.org/local/">link to</a> install the browser extension: <br><ul><li>  <em>Click here to install browser extension</em> </li><li>  in Ubuntu 18.04, it worked for me in the Chrome / Chromium browser, in Fedora 28/29 - both in Firefox and in Chromium </li></ul></li><li>  We are looking for the desired extension in the list <a href="https://extensions.gnome.org/">https://extensions.gnome.org</a> : enable, disable, change the extension settings. </li><li>  PROFIT! </li></ol><br><h2 id="nachalo">  Start </h2><br><p>  Create an extension from scratch: </p><br><pre> <code class="hljs delphi">$ gnome-shell-extension-tool --create-extension <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Not</span></span> Disturb Time Description: Disables notifications <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> sound <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a period Uuid: dnd@catbo.net Created extension <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">'~/.local/share/gnome-shell/extensions/dnd@catbo.net'</span></span> #  gnome-shell Alt+F2, r, Enter #    https:<span class="hljs-comment"><span class="hljs-comment">//extensions.gnome.org/local/      #   Gnome Shell - , gnome-shell   systemd,   journalctl -f /usr/bin/gnome-shell #    ,       gnome-shell journalctl -f /usr/bin/gnome-shell | grep -E 'dnd|$'</span></span></code> </pre> <br><p>  The <code>extension.js</code> file in the corresponding directory is the entry point in our application, in the minimal version it looks like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} <span class="hljs-comment"><span class="hljs-comment">//   ;    function disable() {} // --||-- ;     enable()</span></span></code> </pre> <br><h3 id="pervyy-kod">  First code </h3><br><p>  First we want to add a button to the <code>Status Menu</code> top right, as in the screenshot above. </p><br><p>  So where to start?  Oh, let's start with the documentation.  We have official documentation, everything.  But no, the official documentation is very small and scattered, but thanks to <code>julio641742</code> and its unofficial documentation we get what we need: </p><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// 1 -    (1 - , 0 - , 0.5 -  ) // true,     let dndButton = new PanelMenu.Button(1, "DoNotDisturb", false); // `right` -      (left/center/right) Main.panel.addToStatusArea("DoNotDisturbRole", dndButton, 0, "right"); let box = new St.BoxLayout(); dndButton.actor.add_child(box); let icon = new St.Icon({ style_class: "system-status-icon" }); icon.set_gicon(Gio.icon_new_for_string("/tmp/bell_normal.svg")); box.add(icon);</span></span></code> </pre> <br><p>  This code creates the key <code>dndButton</code> object of the <code>dndButton</code> class, a button specifically designed for the Status Menu panel.  And we insert it into this panel using the function Main.panel.addToStatusArea ().  <sup><a href="https://habr.com/ru/post/428187/">3</a></sup> </p><br><p>  Insert menu items with handlers bolted to them, example: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> menuItem = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PopupMenu.PopupMenuItem(<span class="hljs-string"><span class="hljs-string">"hello, world!"</span></span>); menuItem.connect(<span class="hljs-string"><span class="hljs-string">"activate"</span></span>, (menuItem, event) =&gt; { log(<span class="hljs-string"><span class="hljs-string">"hello, world!"</span></span>); }); dndButton.menu.addMenuItem(menuItem);</code> </pre> <br><p>  Thank you, julio641742, for the documentation!  Link: <br>  <a href="https://github.com/julio641742/gnome-shell-extension-reference">https://github.com/julio641742/gnome-shell-extension-reference</a> </p><br><p>  The final working code - by <a href="">reference</a> . </p><br><h2 id="osobennosti-raboty-gnome-shell-i-javascript">  GNOME Shell and Javascript Features </h2><br><p>  The end of 2018 is in the courtyard, and Node.js / V8 is the main tool for running Javascript code.  All modern web development rests on the "node". </p><br><p>  But GNOME Shell and the entire infrastructure around it use a different Javascript engine, Mozilla's SpiderMonkey, and hence there are many important differences in the work. </p><br><h3 id="import-moduley">  Import modules </h3><br><p>  Unlike Node.js, there is no require (), and the trendy ES6-import is also not.  Instead, there is a special imports object, whose access to the attributes leads to the loading of the module: </p><br><pre> <code class="hljs lisp"> //const PanelMenu = require(<span class="hljs-string"><span class="hljs-string">"ui/panelMenu"</span></span>)<span class="hljs-comment"><span class="hljs-comment">; const PanelMenu = imports.ui.panelMenu;</span></span></code> </pre> <br><p>  In this case, we downloaded the js / ui / panelMenu.js module from the GNOME Shell library library, which implements the button functionality with a pop-up menu. </p><br><p>  Yes, all the buttons in the panel of the modern Linux desktop using GNOME are based on panelMenu.js.  Including: the very right button with battery indicators, Wi-fi, sound volume;  input language switch en-ru. </p><br><p>  Next, there is a special attribute <code>imports.searchPath</code> - this is a list of paths (strings) where our JS modules will be searched.  For example, we selected the timer functionality in a separate module, timeUtils.js, and put it next to the input point of our extension, extension.js.  Import timeUtils.js as follows: </p><br><pre> <code class="hljs pgsql">//     , -  ~/.<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">share</span></span>/gnome-shell/extensions/&lt;your-<span class="hljs-keyword"><span class="hljs-keyword">extension</span></span>&gt;/ const Me = imports.misc.extensionUtils.getCurrentExtension(); //       imports.searchPath.unshift(Me.path); //   const timeUtils = imports.timeUtils;</code> </pre> <br><h3 id="logirovanie-otladka-javascript">  Logging, debugging Javascript </h3><br><p>  Well, since we do not have Node.js, then we have our own logging.  Instead of console.log (), several logging functions are available in the code, see gjs /../ global.cpp, static_funcs: </p><br><ul><li>  "log" = g_message ("JS LOG:" + message) - logging to stderr, example: </li></ul><br><pre> <code class="hljs pgsql">$ cat helloWorld.js log("hello, world"); $ gjs helloWorld.js Gjs-Message: <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">21.048</span></span>: JS <span class="hljs-keyword"><span class="hljs-keyword">LOG</span></span>: hello, world</code> </pre> <br><ul><li>  "logError" - logs the exception stack: <br><ul><li>  The first required argument is an exception, then separated by a comma, whatever you want. </li><li>  For example, if you need to print the stack in the right place: </li></ul></li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'bum!'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(e) { logError(e, <span class="hljs-string"><span class="hljs-string">"what a fuck"</span></span>); }</code> </pre> <br><p>  and it will draw in stderr in the style: </p><br><pre> <code class="hljs mel">(gjs:<span class="hljs-number"><span class="hljs-number">28674</span></span>): Gjs-WARNING **: <span class="hljs-number"><span class="hljs-number">13</span></span>:<span class="hljs-number"><span class="hljs-number">39</span></span>:<span class="hljs-number"><span class="hljs-number">46.951</span></span>: JS ERROR: what a fuck: Error: bum! ggg@./gtk.js:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span> ddd@./gtk.js:<span class="hljs-number"><span class="hljs-number">12</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span> @./gtk.js:<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><ul><li>  "print" = g_print ("% s \ n", txt);  - only text + "\ n" in stdout, without prefixes and coloring, unlike log () </li><li>  "printerr" = g_printerr ("% s \ n", txt) - the difference from print is that in stderr </li></ul><br><p>  But there is no debugger for SpiderMonkey out of the box (it‚Äôs not for nothing that I painstakingly wrote out all the available logging tools above, use it!).  If you prefer, you can try JSRDbg: <a href="https://wiki.gnome.org/Projects/GnomeShell/DebuggingJavaScript">one</a> , <a href="https://github.com/swojtasiak/jsrdbg">two</a> . </p><br><h2 id="a-est-li-zhizn-dlya-js-koda-vne-gnome-shell">  Is there life for JS code outside GNOME Shell? </h2><br><p>  There is.  Full-featured applications, including a graphical user interface (GUI), can be written in Javascript!  You need to run them using the gjs binary, the JS-GTK code starter, an example of creating a GUI window: </p><br><pre> <code class="hljs vala">$ which gjs /usr/bin/gjs $ dpkg --search /usr/bin/gjs gjs: /usr/bin/gjs $ cat gtk.js <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span> = imports.gi.<span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.init(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); let win = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.Window(); win.connect(<span class="hljs-string"><span class="hljs-string">"delete-event"</span></span>, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.main_quit(); }); win.show_all(); <span class="hljs-built_in"><span class="hljs-built_in">Gtk</span></span>.main(); $ gjs gtk.js</code> </pre> <br><p>  I mentioned above about breaking the code into modules and loading them from Javascript.  The question arises, how to determine in the module itself whether it is running as a "main" module, or loaded from another module? </p><br><p>  Python has an authentic construct: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: main()</code> </pre> <br><p>  In Node.js - the same way: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">require</span></span>.main === <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>) { main(); }</code> </pre> <br><p>  I did not find an official answer to this question for Gjs / GH, but I came up with a technique that I hasten to share with the reader (and why did someone read the "dosyudov"? Respect!). </p><br><p>  So, a tricky trick is based on the analysis of the current call stack, if it consists of 2 or more lines, then we are not in the main () - module: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>().stack.split(<span class="hljs-regexp"><span class="hljs-regexp">/\r\n|\r|\n/g</span></span>).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">line</span></span></span><span class="hljs-function"> =&gt;</span></span> line.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) .length == <span class="hljs-number"><span class="hljs-number">1</span></span> ) { main(); }</code> </pre> <br><h2 id="uborka-za-soboy">  Cleaning after themselves </h2><br><p>  Each GNOME Shell extension has access to all objects of the entire GNOME Shell.  For example, to display the number of more unread notifications, let's get to the container with them in the <code>Notification Area</code> located in the center above, number 4 in the picture (click on the current time label, it is clickable in real, not here): </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/91e/eec/acc/91eeecaccdc67202335ce4d51d8d90d3.png" alt="Do Not Disturb Time"></p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> unseenlist = Main.panel.statusArea.dateMenu._messageList._notificationSection._list;</code> </pre> <br><p>  You can find out how many of them, unread notifications, subscribe to the events of adding and deleting notifications: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> number = unseenlist.get_n_children(); unseenlist.connect(<span class="hljs-string"><span class="hljs-string">"actor-added"</span></span>, () =&gt; { log(<span class="hljs-string"><span class="hljs-string">"added!"</span></span>); }); unseenlist.connect(<span class="hljs-string"><span class="hljs-string">"actor-removed"</span></span>, () =&gt; { log(<span class="hljs-string"><span class="hljs-string">"removed!"</span></span>); });</code> </pre> <br><p>  This is fine, but the user may decide that he no longer needs the extension X, and will press the button to disable the extension.  For expansion, this is equivalent to calling the disable () function, and every effort must be made to ensure that the disabled extension does not break the working GH: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ dndButton.destroy(); }</code> </pre> <br><p>  In this case, in addition to removing the button itself, you need to unsubscribe from the events of "actor-added" / "actor-removed", for example: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> signal = unseenlist.connect(<span class="hljs-string"><span class="hljs-string">"actor-added"</span></span>, () =&gt; { log(<span class="hljs-string"><span class="hljs-string">"added!"</span></span>); }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ dndButton.destroy(); unseenlist.disconnect(signal); }</code> </pre> <br><p>  If this is not done, the handler code will continue to be called on the corresponding event, try to update the state of the menu button that does not already exist and ... GNOME Shell will start to fail.  Well, yes, we will foul, users will swear, the stones will fly to the developers of GNOME Shell and GNOME as a whole.  The real picture, che. </p><br><p>  So, GNOME Shell / Gjs is a symbiosis of two systems, Glib / GTK and Javascript, and they have a different approach to resource management.  Glib / GTK requires an explicit release of its resources (buttons, timers, etc.).  If the object is created by the Javascript engine, then we act as usual (do not free anything). </p><br><p>  As a result, as soon as our extension is ready, and not ‚Äúflowing‚Äù, you can safely publish it at <a href="https://extensions.gnome.org/">https://extensions.gnome.org</a> . </p><br><h2 id="rezhim-gnomesessionpresencestatusbusy-i-dbus">  GnomeSession.PresenceStatus.BUSY and DBus mode. </h2><br><p>  If you have not forgotten, we are doing the extension "Do Not Disturb", which turns off the display of notifications to the user. </p><br><p>  GNOME already has a flag for this state.  After the user login, a gnome-session process is created in which this flag is located: this is the GsmPresencePrivate.status attribute, see the gnome-session sources, gnome-session / gsm-presence.c.  Access to this flag is obtained through the DBus interface (such interprocess communication). </p><br><p>  Not only us, but GH itself also needs information about this flag, so as not to display notifications.  This is quite easily searched for in the GH sources: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._presence = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GnomeSession.Presence(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">proxy, error</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onStatusChanged(proxy.status); }); ... this._presence.connectSignal(<span class="hljs-string"><span class="hljs-string">'StatusChanged'</span></span>, (proxy, senderName, [status]) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onStatusChanged(status); });</code> </pre> <br><p>  In this case, the _onStatusChanged method is a handler that reacts to a state transition.  We copy this code to ourselves, adapt it - we sorted out the notifications <sup><a href="https://habr.com/ru/post/428187/">4</a></sup> , there was a sound. </p><br><h2 id="vyklyuchenievklyuchenie-zvuka">  Mute / unmute sound </h2><br><p>  Most modern Linux desktops are managed by PulseAudio, <del>  notorious division </del>  program for the authorship of the notorious Lennart Poettering.  So far, I have not gotten my hands on the PulseAudio code, and I was glad to have the opportunity to understand PulseAudio at some level. </p><br><p>  As a result, it turned out that for mute / unmute, one <code>pactl</code> utility, or rather three commands based on it, is sufficient: </p><br><ul><li>  "pactl info": find out the <code>default sink</code> - to which sound output, if there are several, the default sound is delivered </li><li>  "pactl list sinks": find out mute / unmute status of corresponding device </li><li>  "pactl set-sink-mute% (defaultSink) s% (isMute) s": for mute / unmute itself </li></ul><br><p>  So, our task is to run commands / processes, read their output from stdout and search for the necessary values ‚Äã‚Äãby the regular routine.  In short, the standard task. </p><br><p>  In GNOME, the base library glib is responsible for creating processes, and there is excellent <a href="https://developer.gnome.org/glib/stable/glib-Spawning-Processes.html">documentation</a> on it.  And of course she is C. And we have JS.  It is known that the Gjs package made a smart, "intuitive" layer between the C-API and Javascript.  But you still understand that you need examples and you can not do without googling. </p><br><p>  As a result, thanks to the excellent <a href="https://gist.github.com/buzztaiki/1487781/74ea93d3a30f20c7f094327db9cb263a6286f6d6">gist,</a> we get the working code: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> resList = GLib.spawn_command_line_sync(cmd); <span class="hljs-comment"><span class="hljs-comment">// res = true/false, /   // status = int,    // out/err = ,  stdout/stderr  let [res, out, err, status] = resList; if (res != true || status != 0) { print("not ok!"); } else { // do something useful }</span></span></code> </pre> <br><h2 id="sohranenie-nastroek-v-reestre">  Saving settings <del>  in the registry </del></h2><br><p>  No, of course the registry in Linux is not.  Here you are not Windows.  There are better things called GSettings (this is an API), there are several implementation options behind it, GNOME uses Dconf by default.  This is what a GUI wizard looks like for it: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0fe/03c/eca/0fe03ceca6c7fc9338377fc5d0909024.png" alt="dconf-editor"></p><br><p>  - How is it better to store the settings in plain text files?  - will ask old and bearded Linux users.  The main feature of GSettings is that you can easily subscribe to configuration changes, for example: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Gio = imports.gi.Gio; settings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Gio.Settings({ <span class="hljs-attr"><span class="hljs-attr">settings_schema</span></span>: schemaObj }); settings.connect(<span class="hljs-string"><span class="hljs-string">"changed::mute-audio"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ log(<span class="hljs-string"><span class="hljs-string">"I see, you changed it!"</span></span>); });</code> </pre> <br><p>  The only setting so far in our "Do Not Disturb" is the "mute-audio" option, which allows the user to turn off or not the sound during the "quiet hour". </p><br><h2 id="i-nemnogo-klassiki-gui-na-gtk">  And some classics, GTK GUI </h2><br><p>  In order to nicely show the user the settings of our extension (and not to use the dirty paws on the registry), GH suggests that we write a GUI code and put it into the buildPrefsWidget () function of the prefs.js file.  In this case, in front of our extension in the list of "Installed Extensions" <a href="https://extensions.gnome.org/local/">here</a> we will see an additional button "Configure this extension", by pressing which our beauty will appear. </p><br><p>  Let's create a separate About tab, because we know that without Ebout, sorry, the program is not complete. </p><br><p>  Generally speaking, to build a classic graphical interface, GTK has a whole range of building blocks, <code></code> , check out the number and the quality of which can be <a href="https://developer.gnome.org/gtk3/stable/">here</a> . </p><br><p>  We will use only a few of them: </p><br><ul><li>  Gtk.Notebook are tabs, just like in a browser </li><li>  Gtk.VBox is a container for vertically structuring a list of widgets. </li><li>  Gtk.Label is a basic element, an inscription, with the possibility of HTML formatting. </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildPrefsWidget</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    Gtk.Notebook    GUI let notebook = new Gtk.Notebook(); ... //  About,    VBox c   10 , //   margin/padding   let aboutBox = new Gtk.VBox({ border_width: 10 }); //     About notebook.append_page( aboutBox, new Gtk.Label({label: "About"}), ); //        , //      ,    (expand) aboutBox.pack_start( new Gtk.Label({ label: "&lt;b&gt;Do Not Disturb Time&lt;/b&gt;", use_markup: true, }), true, // expand true, // fill 0, ); ... notebook.show_all(); return notebook; }</span></span></code> </pre> <br><p>  Final screenshot: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f87/554/787/f8755478763d159cbb9dfc1518881e60.png"></p><br><h2 id="dopolnitelno">  Additionally </h2><br><div class="spoiler">  <b class="spoiler_title">1. Operating modes: support and operation</b> <div class="spoiler_text"><p>  The work of the programmer involves 2 modes in my case: <br>  1) in support mode, when you need to quickly respond to events - mail, Slack, Skype, etc. <br>  2) in the mode of operation, when it is vitally necessary to cut down notifications by at least 20 minutes, otherwise the focus is lost and the total labor productivity is negligible.  This is what the Do Not Disturb mode is useful for. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">2. How to turn off the sound</b> <div class="spoiler_text"><p>  It may seem like a complete mute, mute, that's too much.  Indeed, after all, ideally, in the Do Not Disturb mode, you want to hear Slack / Skype calls, but the other sounds (real notifications) are not.  But for this they need to somehow distinguish.  You can, of course, make a sound API specifically for notifications (and this is already there), except that there is always a program / programmer who does not use such functionality.  An example is the Mailspring mailer: it just loses sounds through the <code>audio</code> tag, and you can‚Äôt distinguish them from, say, a speech in a Slack call. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">3. PanelMenu.Button</b> <div class="spoiler_text"><p>  PanelMenu.Button is actually the button in the panel + pop-up menu, and you can figure it out yourself and create it from scratch, and that, and the other, the <em>boys on raene</em> will appreciate!  I had a focus on quick results and therefore I copied the code from informal documentation. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">4. SetStatusRemote ()</b> <div class="spoiler_text"><p>  Actually, you need to initiate a mode change using SetStatusRemote (). </p></div></div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/428187/">https://habr.com/ru/post/428187/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../428175/index.html">Sly prefix C tree implementation</a></li>
<li><a href="../428177/index.html">So what is wrong with finding a job / IT worker?</a></li>
<li><a href="../428179/index.html">At the Japanese auction, a prototype Wii controller appeared, which was developed for the GameCube</a></li>
<li><a href="../428181/index.html">Moral Machine: merciless or meaningless?</a></li>
<li><a href="../428183/index.html">Implementation of the Levenberg-Marquardt algorithm for optimizing neural networks on TensorFlow</a></li>
<li><a href="../428189/index.html">Who is a Paladin?</a></li>
<li><a href="../428191/index.html">What should we arrange a hackathon, or How do we conduct an internal hackathon</a></li>
<li><a href="../428193/index.html">Pro departure tours</a></li>
<li><a href="../428197/index.html">Effective personal finance. Level 1</a></li>
<li><a href="../428201/index.html">Wormholes in JavaScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>