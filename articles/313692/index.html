<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Connecting the ADC to the FPGA. Features, complexity, implementation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! In this article we will discuss the connection of ADC chips to FPGA crystals. The main features of the connection of circuit nodes will be cons...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Connecting the ADC to the FPGA. Features, complexity, implementation</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/3f1/63c/177/3f163c17739344cfb625350440a24caa.png"></div><br>  Hello!  In this article we will discuss the connection of ADC chips to FPGA crystals.  The main features of the connection of circuit nodes will be considered, modern ADCs and their characteristics will be presented.  The article will give practical advice on quick and proper connection of the ADC to the FPGA with minimal time costs.  In addition, we will discuss the connection principles of various ADCs, the input buffer of the FPGA and its basic components - triggers, IODELAY delay nodes, ISERDES serializers, etc. will be considered.  In more detail, with examples of software code in the VHDL language, we will review the main elements required for the qualitative reception of data from the ADC.  This is an input buffer, a data packaging node for single-channel and multichannel systems, a synchronization and data transmission module based on FIFO, an ADC programming node via SPI interface, a data frequency synthesis node - MMCM / PLL.  Also, the article will present an overview of the finished devices (in the FMC standard) from leading foreign and domestic manufacturers of analog and digital circuits.  At the end of the article you will find a link to the source codes of a universal data receiver node from multichannel ADC circuits.  The code is simple and flexible in configuration, it is presented in VHDL and sharpened on Xilinx 7 series FPGAs and higher, but can be applied in other FPGA crystals. <br><a name="habracut"></a><br><h3>  Article layout </h3><br><ul><li>  ADC (overview, purpose, element base) </li><li>  Examples of completed ADC modules of various manufacturers </li><li>  Connecting the ADC to the FPGA.  Choice FPGA.  Number of contacts, amount of logical resources, data interface <br><br><ul><li>  FPGA input buffer.  Composition, the main units.  Purpose </li><li>  Data wrapper for single-channel and multi-channel circuits </li><li>  Data synchronization node (FIFO) </li><li>  Control of ADC by SPI interface (example) </li><li>  Inner tire.  Connecting FPGA to a remote device </li></ul><br></li><li>  Source codes of the ADC data receiver </li><li>  Bibliography </li></ul><br><h3>  Analog-to-Digital Converters </h3><br>  A / D converters are used for a wide range of radio engineering tasks - in any devices where it is required to convert an analog signal into digital form.  They can be used in audio and video systems, used in hydroacoustics and hydro communication problems (low sampling frequency, high data width), in radio frequency conversion devices (DDC / DUC circuits), in radar and radio navigation (high sampling frequencies, medium bit length data).  ADCs are used in digital voltmeters and multimeters, in video input boards of computers, video cameras, speech recognition systems, and sound devices.  Fast ADCs are used in oscilloscopes and spectrum analyzers, used in laboratory equipment and medical equipment.  Very often, the ADC is used in tasks of collecting and processing data at high speeds. <br><br>  As you can see, ADC chips are an integral part of analog-digital devices.  In the modern world it is very difficult to find a device that would not have ADCs.  A classic view of the ADC is shown in the following figure. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/files/f9f/560/548/f9f560548b774cecaafae086c4a42bd4.png"></div><br>  This is a simplified circuit taken from the datasheet on the AD9684 chip.  It contains two differential analog inputs <i>VINA</i> and <i>VINB</i> , clock frequency input <i>CLK</i> , control via SPI interface, output bus in parallel form <i>D0-D13</i> , power supply voltage points of various microcircuit nodes, <i>SYNC</i> synchronization unit and other control signals. <br><br>  Obviously, ADC chips are characterized by a set of specific parameters on which the final choice of the user depends and which determines the scope of the ADC.  On the <b>digital side</b> , this is the data transfer rate (effective clock frequency), which can be in the range of several tens of kHz to several GHz.  The data width at the ADC output is in modern devices from 8 to 32 data bits.  On the side of <b>analog characteristics</b> , this is the signal-to-noise ratio ( <i>SNR</i> ) and the dynamic range free of spurious components ( <i>SFDR</i> ), expressed, as a rule, in decibels (typical SNR levels are between 70-80 dB, and SFDR levels are around 90 dBc).  Important parameters when choosing an ADC are - power dissipation (W), the number of channels in one package, the exchange interface with the digital node and, of course, the cost of the component. <br><br>  Consider modern high-speed ADCs and their characteristics on the example of a table taken from the well-known Analog Devices website - a giant in the field of manufacturing all kinds of ADC and DAC chips.  For convenience, the table summarizes the most important characteristics of the chips, they are divided according to the type of exchange interface with a digital device, and are arranged according to the speed of information transfer (clock frequency) from a higher value to a lower value. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e45/5cc/9f3/e455cc9f32084cf98a9659748ba29b1f.png"></div><br>  The table contains 4 high-end chips that transmit data in parallel form according to the LVDS standard.  The data width of 14-16, channels 1-2, the maximum sampling rate of 500 MHz.  The average SNR and SFDR values ‚Äã‚Äãare 70 dBFS and 90 dBc, respectively.  For some chips with a serial data transmission bus (Serial), the characteristics are almost the same.  For modern ADC chips that use the JESD204B transmission interface and connect to the FPGA via gigabit lines, the clock frequencies are much higher, but the analog characteristics are slightly worse (at least due to the fact that the digital data is lower than 12 and 14 bits).  In this article <u>will not be</u> considered connecting the ADC to FPGA crystals via gigabit lines.  I will focus on a simple and well-studied version of the connection of microcircuits - a serial and parallel bus with data transfer interfaces such as <i>LVTTL, LVDS, LVCMOS, LVPECL</i> .  In particular, an interesting method of data transmission over the LVDS bus, which is distinguished by the ease of tracing printed circuit boards, low cost performance, low noise and power dissipation, as well as high data transfer speeds.  To receive data via a serial bus, FPGA uses serializers / deserializers.  For a parallel bus, everything is much simpler and data is accepted as is. <br><br>  In the course of work on the pairing of analog and digital devices, I had to learn the following ADC microcircuits.  These are already outdated, but still used - <i>AD9224, AD6644ST-65, AD9244, LCT2207, ADS5474, AD9432BST-105, AD7475BR</i> , state-of-the- <i>art ICs</i> - <i>AD9430BSV, ADS54RF, AD9467, ADC12D1800, AD9680</i> and others.  Since the area of ‚Äã‚Äãmy work is only partially related to analog circuitry, I can hardly tell you about ways to improve the characteristics of complete analog-digital modules.  Also, I will not be able to give advice on the qualitative construction of analog paths and the method of selecting those or other circuit components to achieve the best analog indicators (SNR, SFDR).  But I will try to answer the questions of connecting the ADC to FPGA crystals and further data processing in this article. <br><br><h3>  Examples of ADC Modules </h3><br>  The following figures will present modern examples of complete and high-quality analog-to-digital data conversion modules from Russian and foreign manufacturers.  All of them have one or several analog connection inputs and an FMC adapter connector (FPGA Mezzanine Card) for connection to the carrier board on which the data handler is installed (as a rule, this is FPGA).  FMC is one of the main standards for connecting products on a modular architecture.  An analog part is often installed on the mezzanine board (mezzanine board), and a central device is installed on the carier board, which performs data processing - it is one or more FPGAs and / or signal processors.  Of the foreign manufacturers of devices should be allocated two leading manufacturing companies - this is 4dsp and hitechglobal.  From domestic manufacturers, Google in the first lines of the search is issued by CJSC Scan Engineering Telecom, CJSC Tool Systems and others.  The author of the article is <u>not responsible</u> for the presented modules and <u>does not use the</u> article in order to <u>advertise the</u> product of a company. <br><br>  <b>HTG-ADC16</b> .  It has the following characteristics (taken from the official site): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/531/224/567/5312245671044d33b9ad9ef669698b16.png"></div><br><ul><li>  16-Bit Resolution, Dual-Chanel, 1-GSPS ADC </li><li>  Noise Floor: ‚Äì159 dBFS / Hz </li><li>  Spectral Performance (fIN = 170 MHz at ‚Äì1 dBFS): <br><br><ul><li>  SNR: 70 dBFS </li><li>  SFDR: 86 dBc </li><li>  SFDR: 96 dBc (Except HD2, HD3, and Interleaving Tones) </li></ul><br></li><li>  Spectral Performance (fIN = 350 MHz at ‚Äì1 dBFS): <br><br><ul><li>  SNR: 67.5 dBFS </li><li>  NSD: ‚Äì154.5 dBFS / Hz </li><li>  SFDR: 75 dBc </li><li>  SFDR: 85 dBc (Except HD2, HD3, and Interleaving Tones) </li></ul><br></li><li>  Channel Isolation: 100 dBc at fIN = 170 MHz </li><li>  Input Full-Scale: 1.9 VPP </li><li>  Input Bandwidth (3 dB): 700 MHz </li><li>  On-chip dither </li><li>  Integrated Wideband DDC Block </li><li>  JESD204B Interface with Subclass 1 Support: <br><br><ul><li>  2 Lanes per ADC at 10.0 Gbps </li><li>  4 Lanes per ADC at 5.0 Gbps </li><li>  Support for Multi-Chip Synchronization </li></ul><br></li><li>  Power Dissipation: 1.35 W / ch at 1 GSPS </li></ul><br>  <b>FMC104: 4-Channel 250 MSPS @ 14-bit</b> .  Characteristics (some removed due to redundancy of information): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/550/d2e/aa6/550d2eaa65ee4c1c9bc694e9e727ba03.jpg"></div><br><ul><li>  Four Channel 14-bit 250 MSPS A / D conversion </li><li>  Available as air cooled and conduction cooled </li><li>  VITA 57.1-2010 compliant </li><li>  Based on TI ADS62P49 </li><li>  LVDS or 1.8V LVCMOS output operation </li><li>  Single ended AC- or DC-coupled analog input </li><li>  Flexible clock tree enables </li><li>  LPC (low-pin count) compatible </li></ul><br>  The feature of the module is four ADC channels, 1.8V supply voltage (HP-banks FPGA Xilinx are used). <br><br>  <b>FMC120: 4-Channel 250 MSPS @ 14-bit</b> .  Specifications: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/08b/90a/4f1/08b90a4f1f90417da0efb50bd9210b75.JPG"></div><br><br><ul><li>  Quad - A / D - D / A Channel Operation <br><br><ul><li>  Quad Channels 16-bit 1.00 GSPS A / D </li><li>  Quad Channels 16-bit 1.25 GSPS D / A </li><li>  Simultaneous sampling on all channels up to 1 GSPS </li></ul><br></li><li>  VITA 57.1-2010 compliant </li><li>  Conduction Cooled - Standard Option </li><li>  Single ended DC or AC-coupled analog input. </li><li>  Clock Source, Sampling Frequency, and Calibration through SPI communication bus </li><li>  HPC - High Pin Count Connector </li><li>  2Kbit EEPROM (24LC02B) accessible from the Host via I2C bus </li><li>  JTAG - CPLD device accessible from the FMC connection </li></ul><br>  <b>FMC140: 4-channel 16-bit 370MSPS A / D.</b>  It has the following characteristics: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/86b/699/b97/86b699b974d148be849b7f32e7cff73a.jpg"></div><br><br><ul><li>  Four-channel, 16-bit A / D up to 370 MSPS </li><li>  VITA 57.1-2010 compliant </li><li>  JESD204B serial interface </li><li>  AC or DC-coupled analog signals </li><li>  SPI communication busses </li><li>  Flexible clock tree enables </li><li>  Power-down modes for switch power off </li><li>  HPC - High Pin Count connector </li></ul><br>  The feature of the module is 4 high-speed ADC channels, 16-bit data width, exchange via JESB204B interface. <br><br>  <b>Module SFM-4A1000</b> .  Specifications: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ea5/acc/0c7/ea5acc0c772a43578fb46319e0fcd8dd.jpg"></div><br><ul><li>  Four channels ADC: 14 bit 1000 MHz </li><li>  Broadband Transformer Input with bandwidth up to 2 GHz </li><li>  Interface with carrier module JESD204B </li><li>  Support for digital decimation and AGC functions built into the ADC </li><li>  Highly stable reference generator, external reference clock input </li><li>  Software control of ADC settings and clocking scheme </li><li>  Single-width FMC form factor with air or conductive cooling </li></ul><br>  The peculiarity of the module is domestic development, 4 high-speed ADC channels, 2 GHz band, exchange via JESB204B interface. <br><br>  <b>FMC212x4GDA module</b> .  Specifications: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/46b/8b1/2a1/46b8b12a1ad34a8084d9c942c6fc3578.jpg"></div><br><ul><li>  Two channels ADC 12 bit </li><li>  Conversion Frequency: 1 to 4 GSPS </li><li>  Analog input bandwidth: 5 to 2000 MHz </li><li>  Input resistance: 50 ohm </li><li>  DDC embedded in ADC </li><li>  Maximum DDC bandwidth: 800 MHz </li><li>  DDC decimation factor: 4 to 32 </li><li>  Four channels D / A 16 bit 2.8 GSPS </li><li>  Interpolation: x2, x4, x8 </li><li>  The frequency range of the output signals of the DAC: from 0.5 to 400 MHz </li><li>  Maximum output amplitude: ¬± 0.5 V </li><li>  Output impedance: 50 ohm </li><li>  ADC and DAC clock synthesizer with low phase noise </li><li>  ANSI / VITA 57.1 FMC module 69x76.5 mm </li></ul><br>  The feature of the module is 2 high-speed ADC channels, signal bandwidth up to 2 GHz, exchange via JESB204B interface, built-in DDC chips, 4 DAC channels. <br><br>  <b>FMC816x250M module</b> .  Specifications: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ecd/343/d1b/ecd343d1b3e0445b998c7f67703881fa.jpg"></div><br><ul><li>  ANSI / VITA 57.1 FMC double width module 139x76.5mm </li><li>  8 ADC 16 bit </li><li>  Conversion frequency: 50 MHz to 250 MHz </li><li>  Analog input band 0.1 ... 250 MHz </li><li>  Conversion scales: ¬± 0.8V;  ¬± 0.65V </li><li>  Input resistance: 50 ohm </li><li>  Internal / external clocking </li><li>  Tunable clock generator 10 ... 250 MHz </li></ul><br>  Module feature - 8 ADC channels, dual module. <br><br>  As you can see, many of the analog-to-digital conversion modules in the FMC standard are similar and have almost identical characteristics, which are determined by the installed ADC and DAC chips.  The final choice of a module is determined by the task that the end user needs to decide. <br><br><h3>  Connecting ADC to FPGA </h3><br>  Let us turn to the main section of the article - the connection of ADC chips to FPGA crystals.  Consider connecting the ADC over <i>parallel</i> and <i>serial</i> bus, with data interfaces - <i>LVTTL, LVCMOS, LVDS</i> .  The article <u>will not</u> consider connecting the ADC interface <b>JESD204B</b> , because it is the material of a separate topic, which will take more than one full article.  In addition, JESD204B differs significantly in the implementation of the "classic" options for connecting ADC chips and requires more detailed consideration. <br><br>  As is known, banks (pin groups) of I / O FPGAs can be configured for different supply voltages, the boundaries of which are determined by the manufacturer of the crystals.  In modern FPGAs of the Xilinx type, the voltage range applied depends on the type of bank.  There are two main types of banks (Xilinx) - <b>HP</b> (high-performance) and <b>HR</b> (banks with a large selection of standards and power).  For example, in chips 7 of the Xilinx series, the voltage range for HR banks is from 1.2 to 3.3V, and for HP banks - from 1.2 to 1.8V.  In addition, banks' pins can be programmed for a wide range of standard data transfer interfaces, but the final choice of a standard is determined by two rules: the supply voltage of the FPGA bank and the method of connecting the remote device and the FPGA.  On the other hand, an important factor in the choice of the voltage supply of the FPGA bank is a family of crystals.  So, for Kintex-7 it is possible to use the LVDS 25 standard and supply a 2.5V bank, and for many FPGA Virtex-7 chips, the connection standard is exclusively LVDS 18, and the bank is powered by 1.8V.  In this regard, the problem arises of pairing some analog modules and carrier boards with different FPGA families.  Therefore, when you purchase an ADC module and / or carrier card from a third-party manufacturer, you need to make sure that they are compatible with the standard and the supply voltage.  As a rule, the data transfer interface is written in the constraint file ( <b>UCF</b> or <b>XDC</b> ), and not in the project source codes, which provides configuration flexibility and reuse of source files in other projects. <br><br>  The block diagram of the project's top-level file (as well as the internal blocks used to receive data from ADC chips according to the LVTTL / LVCMOS / LVDS standard) is presented in the following figure. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/7dd/3dd/6d4/7dd3dd6d4fb64b0ca8a960614dfd7ed3.png"></div><br>  It includes the following elements: <br><br><ul><li>  Input receiver </li><li>  Data packer </li><li>  Data Flow Synchronizer (FIFO) </li><li>  The control unit chips ADC </li></ul><br>  In addition to these nodes, at the top level, the MMCM-based frequency synthesis module is used - a standard FPGA resource.  The IDELAYCTRL component is also used to control delays in the IODELAY nodes. <br><br>  The main parameters of the top-level file on which the FPGA scheme configuration depends: <br><br><ul><li>  NCHAN - the number of independent ADC channels, </li><li>  DATA_WIDTH - the data width of the ADC, </li><li>  FIFO_ADDR - FIFO depth: DEPTH = 2 ** ADDR, </li><li>  DATA_RATE - data reception mode: SDR / DDR, </li><li>  PACK_OUT - width of the output bus of the packer (system bus), </li><li>  CLK_SEL - select the main clock source for the multichannel circuit, </li><li>  USE_MMCM - using the MMCM node instead of BUFR to divide the CLKDIV frequency by SERDES, </li><li>  DIFF_TERM - using differential input signals (TRUE / FALSE), </li><li>  IOSTANDARD - voltage standard for LVDS lines, </li><li>  DATA_IOBDELAY_TYPE - the operation mode of the IODELAY delay node, </li><li>  DATA_IOBDELAY_VALUE - default delay value, </li><li>  DIFF_CLOCK - use differential input clock (TRUE / FALSE), </li><li>  OVR_PRES - using the ADC overflow lines (overflow), </li><li>  STR_PRES - use the ADC external start signal lines (start), </li><li>  RESYNC_OUT - enable the mechanism of primary resynchronization of data on the input buffer (YES / NO). </li></ul><br>  And some other options. <br><br>  The part of the code file of the top-level ADC receiver looks like this: <br><br><pre><code class="vhdl hljs">xFIFO: CTRL_FIFO_CONFIG <span class="hljs-keyword"><span class="hljs-keyword">generic</span></span> <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> ( DATA_WIDTH =&gt; PACK_OUT, ADDR_WIDTH =&gt; FIFO_ADDR ) <span class="hljs-keyword"><span class="hljs-keyword">port</span></span> <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> ( reset =&gt; reset, wr_clk =&gt; clk_pack, rd_clk =&gt; sys_clk, data_i =&gt; do_pack, data_o =&gt; do_fifo, rd_en =&gt; cs_fifo, wr_en =&gt; dv_pack, empty =&gt; ef_fifo, full =&gt; ff_fifo );</code> </pre> <br>  This is where the FIFO node connects to synchronize data with the device's system bus.  Programming delays for IODELAY in a multichannel and multi-bit buffer scheme is as follows: <br><br><pre> <code class="vhdl hljs"><span class="hljs-comment"><span class="hljs-comment">---- Data delays ---- x_dat_dd &lt;= x_dat_do(conv_integer(unsigned(dl_chan))) when rising_edge(dl_clk); x_dat_in(conv_integer(unsigned(dl_chan)))(conv_integer(unsigned(dl_muxs))) &lt;= dl_dat_in when rising_edge(dl_clk); x_dat_ce(conv_integer(unsigned(dl_chan)))(conv_integer(unsigned(dl_muxs))) &lt;= dl_dat_ce when rising_edge(dl_clk); x_dat_ld(conv_integer(unsigned(dl_chan)))(conv_integer(unsigned(dl_muxs))) &lt;= dl_dat_ld when rising_edge(dl_clk);</span></span></code> </pre><br>  Where <i>dl_chan</i> is the selected ADC channel, <i>dl_muxs</i> is the selected ADC bit.  This is done for independent programming of every bit of data. <br><br>  Consider each node in detail. <br><br>  <b>Note:</b> for connecting FPGAs and D / A converters (D / A converters), the situation is mirrored.  It is necessary to do everything the same, but in reverse order.  In this article, the connection of the FPGA to the DAC is not considered. <br><br><h3>  Input receiver </h3><br>  It contains the primary elements of the connection between the external signals of the circuit board and the logic of the FPGA.  This is the IPAD buffer from the FPGA pin to the <b>IOBUF</b> input buffer <b>logic</b> .  Depending on the data transfer interface, the buffer may be differential - IBUFDS and unipolar - IBUF.  For many buffers, a hard link to the required standard is possible, or it is possible to set the type of output signal through attributes.  For example, for IBUFDS, using the <b>IOSTANDARD</b> attribute, <b>you</b> can define and set the standard " <i>LVDS_25</i> " in advance in the source codes. <br><br>  Behind the buffer, a node for controlling the delay of the <b>IODELAY</b> signal passing is <b>set</b> to align the <b>edges of the</b> parallel data bus and to first match the multi-channel nodes connecting the ADC to the FPGA.  IODELAY is a programmable FPGA resource, the delay value can be fixed and determined by the default setting, or programmed in the range from 0 to 31 conventional time values ‚Äã‚Äã(the digit is determined by the FPGA datasheet).  Programming is done in a primitive way with the help of several signals.  We will not dwell on the detailed analysis of the programming algorithm; for more information, you can refer to the document from the list of references at the end of the article.  For IODELAY nodes, you need to connect a special <b>IDELAYCTRL</b> delay control <b>node</b> , which real-time calibrates the delays for each FPGA clock region.  To eliminate the influence of the crystal temperature, the supply voltage and the load on the FPGA, the IDELAYCTRL node is clocked with an independent REFCLK signal.  This clock signal provides an equal amount of delay ( <i>TAP</i> ) in all IODELAY nodes of each FPGA clock region.  If each clock region needs its own trim values, several IDELAYCTRL nodes are initialized in the FPGA chip.  The clock signal REFCLK can be supplied from an external generator installed outside the FPGA, or it can be obtained by synthesizing a frequency at the <b>FPGA</b> crystal <b>MMCM</b> node. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/9f4/7fe/58b/9f47fe58b86d42e1a5cbf57717d6925e.png"></div><br>  Following the IODELAY delay node, the <b>FD</b> trigger can be set if the data transfer mode is <i>DATA_RATE</i> = ‚Äú <i>SDR</i> ‚Äù.  This trigger is optionally placed in the input buffer and clocked by the ADC frequency that accompanies the data from the analog module.  In the <i>DATA_RATE</i> = " <i>DDR</i> " mode, the trigger is replaced with a sophisticated version of <b>IDDR</b> , which has one data input and two outputs.  From the output, data can be output in several modes, but in practice I used only one - this is ‚Äú <i>SAME_EDGE_PIPELINED</i> ‚Äù, in which data from the output of Q1 and Q2 are output on the same edge of the clock signal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/dfb/bb1/460/dfbbb14607af4a8fa8b02ba3f1bf4726.png"></div><br>  Finally, the most interesting option is to connect the IODELAY node to the ISERDES data deserialization <b>module</b> .  The serializer node is a complex element of the FPGA input buffer, it contains the following options: <br><br><ul><li>  <i>DATA_RATE</i> - defines the output mode ( <i>SDR</i> / DDR), </li><li>  <i>DATA_WIDTH</i> - determines the width of the data bus at the node output (from 1 to 8), </li><li>  <i>INTERFACE_TYPE</i> - type of data interface.  To connect the ADC chips, the ‚Äú <i>NETWORKING</i> ‚Äù mode is used. </li><li>  <i>SERDES_MODE</i> - connection mode ISERDES in the case of using multiple serializers to receive data from one FPGA contact. </li></ul><br>  A node clock is <i>triggered</i> by several signals ‚Äî this is the signal at the high frequency of the received <i>CLK</i> data and the signal <i>CLKDIV</i> divided by the number defined by the DATA_WIDTH parameter.  Fission can occur outside the FPGA, but in practice, frequency synthesizers are used in the FPGA chip itself, which are called MMCM.  Thus, a serial signal at the CLK frequency is input to the ISERDES node, and a parallel data stream is obtained at the ISERDES node output at the reduced frequency <b>CLKDIV</b> = <b>CLK</b> / <b>DATA_WIDTH</b> .  The clock frequency can be divided using the regional buffer <b>BUFR</b> , the value of the division factor <i>BUFR_DIVIDE</i> = 1-8, or on the <b>MMCM</b> frequency synthesizer node, programmed in a wide range. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/8c0/8ed/c31/8c08edc311ff412aadc0eaf54ca343d0.jpg"></div><br>  To eliminate the effect of coincidence of the clock and data edge, IODELAY nodes and frequency adjustment in the MMCM are not always enough.  Often it is necessary to look for alternative ways to solve this problem.  Fortunately, this solution was found by my colleague, which he recently talked about in his article ( <a href="https://habrahabr.ru/post/309944/">Useful Properties of Jitter</a> ). <br><br>  All of the above nodes (with the exception of MMCM) are part of the input FPGA buffer and do not occupy the logical resources of the crystal.  From the FD / IDDR / ISERDES output, the data already arrive at the logic elements ‚Äî this is a small trigger or FIFO for primary resynchronization of data to the frequency obtained after passing the ADC sampling frequency at the MMCM node.  In some cases, resynchronization is not used, and the data is synchronized directly by the ADC sampling rate.  The following figure shows a timing diagram for processing serial data from an ADC chip on an ISERDES device.  The input clock frequency, the serial input data, and the converted data into parallel code are shown. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f45/e5e/7e1/f45e5e7e1d3e40e1b653d3e5e7c9058a.png"></div><br>  Thus, depending on the configuration, there are three possible signal paths in the input buffer, as shown in the figure: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/2ee/3db/e06/2ee3dbe069a148e894620d003c2921e6.jpg"></div><br><blockquote>  A) <i>SDR</i> mode - data is received via a parallel bus, for each data bit its FPGA buffer is used, <br>  B) <i>DDR</i> mode - data is received on a parallel bus, data is clocked by double the frequency. <br>  C) <i>SERDES</i> mode - data is received via serial bus </blockquote><br><h3>  Data packer </h3><br>  This node is used in single-channel and multichannel data reception circuits from the ADC.  Its main purpose is to <u>pack the data into a convenient internal bus format</u> used inside the FPGA.  The internal bus width is determined by the developer or corporate standard.  Typical values ‚Äã‚Äãof bitness at the packer output are <i>32, 64, 128, 256, 512</i> data bits.  In some cases, the packer cannot be configured.  It depends on the number of input channels, the width of the input and output data bus packer.  For example, for a four-channel source with input data width = 16 bits, it is impossible to organize a repacker with an output bus that is less than <b>WOUT</b> = <b>WIN</b> * <b>NCHAN</b> = 16 * 4 = 64 bits.  For a single-channel data source with the same bit width at the input and output, the data will be sequentially packed in packs of 16 bits into a 64-bit bit grid.  That is, the first ADC countdown will take the bit field [15: 0], the second countdown - [31:16], the third one - [47:32], and the fourth one - [63:48].  Further, the samples will cyclically occupy bit fields from the lowest to the highest in the output data grid.  Another example.  2 data channels are used, the bit widths at the input and output remain the same - 16 and 64 bits, respectively.  If the data acquisition system on the remote device includes only one channel, then the packaging occurs, as shown in the example above, and it does not matter which channel is included.  If the acquisition system includes both channels, then the data is packed in pairs from the lower part of the discharge grid to the older one.  The first reading of the first channel will take the position [15: 0], the first reading of the second channel will take the position [31:16], the second reading of the first channel - [47:32], the second reading of the second channel - [63:48].  As practice has shown, this is the most convenient way to pack data for multichannel processing, in the case of disconnection of certain transmission channels.  Note: the number of channels must be a multiple of the power of two - 1, 2, 4, 8, etc.  It may seem that this site is difficult to implement and understand, but after several applications in your projects you will find for yourself that there is nothing complicated or unusual here. <br><br>  The following figure shows time diagrams of the data packer node operation in the mode: <i>NCHAN</i> = 1, <i>WIN</i> = 8, <i>WOUT</i> = 32. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/dda/5bb/515/dda5bb515fd9472db62697ac93f0a7b6.png"></div><br>  The red lines show the process of data packing to the output bus, which is accompanied by a <i>DVAL</i> = 1 resolution signal after receiving 4 data samples. <br><br><h3>  Data stream synchronizer </h3><br>  This node is built on the basis of a primitive <b>FIFO</b> scheme and has one important and simple purpose ‚Äî converting the data stream from the sampling frequency <i>CLK_ADC</i> to the processing frequency or the frequency of the internal bus of the <i>SYS_CLK</i> device (system clock frequency).  For simplicity, you can create a FIFO node in the <i>Xilinx Core Generator</i> , but ideally it is better to write your own module, which will be flexible in configuration to an arbitrary bus width ( <b>FIFO_WIDTH</b> ) and memory depth ( <b>FIFO_DEPTH</b> ).  The following figure shows time diagrams of the FIFO node operation, shows the input and output data, as well as the <i>empty</i> and full FIFO flags.  It should be noted that for the FIFO ADC to work properly, the FULL full flag must always be 0, which indicates the correctness of data received from the ADC and the absence of overflow.  If the FULL flag = 1, then the data reception rate of the remote processor is insufficient, or the ADC operation speed is too high for the selected system. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/aa7/777/949/aa7777949dda4a58b70659b826be60d8.png"></div><br>  The following figure shows a schematic representation of the FIFO node in the Plan Ahead environment. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/093/1cb/f0d/0931cbf0de7148439f5a7ca07e953db4.png"></div><br>  It can be seen that the FIFO is built on the basis of dual-port memory.  On the memory bus address data is sent in gray code - in the diagram there are two nodes for reading and writing.  This allows to reduce the bit error at high frequencies, since  neighboring values ‚Äã‚Äãin the gray code differ only in one bit position.  The logic of the FIFO flags is determined by the values ‚Äã‚Äãin the Gray Counter modules, and the registers are used to increase the clock frequency of the node. <br><br><h3>  Inner tire </h3><br>  The question arises - <i>where</i> does the <i>collected and packed data go further</i> ?  The answer is simple: with the help of interfaces <i>PCI / PCIe, USB, Ethernet, SRIO, SATA, the</i> data reach the final goal, where they undergo further processing and where all information is collected.  Prior to this link, a digital signal processing (DSP) node can be inside the FPGA, for example, <i>DDC, DUC, FFT / IFFT</i> , etc. In addition, data can be buffered on external high-capacity memory, such as <i>DDR3 / DDR4</i> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a frequent technique that is used to process a large flow of information at high speeds. In this case, the external memory simulates a large FIFO. To connect the FPGA with external memory, special controllers are used, which, as a rule, are accessible and open for use. In the case of Xilinx, they are in the IP Core Generator. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Among other things, the developer needs to create his own </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">control state machine.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">all ADC receiver resources: this is the configuration of delays in IODELAY, programming of the MMCM frequency synthesizer, sending commands via SPI to ADC and DAC modules, controlling the beginning and end of data collection from the ADC, managing the number of active channels, using external DDR memory and much more. </font><font style="vertical-align: inherit;">All have their own unique architecture, but the basic principles remain the same. </font><font style="vertical-align: inherit;">In the company in which I work, control nodes called " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tetrads</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " are used. </font><font style="vertical-align: inherit;">My colleague told about them in detail </font></font><a href="https://habrahabr.ru/post/309136/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Control of the ADC module </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a rule, the analog module is controlled via </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI-like</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> interfaces. </font><font style="vertical-align: inherit;">Implement the SPI-interface under the power of any senior student, in the program of which there is a study of programmable logic and FPGA. </font><font style="vertical-align: inherit;">Focus on the SPI node, I will not. </font><font style="vertical-align: inherit;">At the end of the article, as an example, the source control code of the remote </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HI-6131</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chip is given </font><font style="vertical-align: inherit;">, which processes messages in the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MIL-STD-1553</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> format </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The code is not parameterizable and sharpened specifically on the selected chip. </font><font style="vertical-align: inherit;">To warm up, you can write your SPI node, which will be configured for different parameters. </font><font style="vertical-align: inherit;">The timing diagram of control over the SPI interface is as follows:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/43a/cc5/7aa/43acc57aac644868b7491d048a8e37a0.png"></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Source </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The source code of all components and assemblies is presented in the VHDL language and is intended for FPGA Xilinx 7 series chips (and above). </font><font style="vertical-align: inherit;">Source codes are open for use and are available via the link on the </font></font><a href="https://github.com/capitanov/adc_configurator/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">githaba - see here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">All components are made as flexible as possible in the configuration and do not require significant intervention in the source code (with the exception of the SPI node - </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sorry, it was too lazy</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Unfortunately, it is impossible to adapt to all existing solutions, but this example has successfully worked for all the analog modules with which I worked. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, the read and write operations in the FIFO, as well as the connection of the binary-to-gray conversion nodes look like this:</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FIFO R / W</font></font></b> <div class="spoiler_text"><pre> <code class="vhdl hljs"><span class="hljs-comment"><span class="hljs-comment">---- Read data ---- pr_rd: process(rd_clk) begin if (rising_edge(rd_clk)) then if (rd_en = '1' and xempty = '0') then data_o &lt;= Mem(conv_integer(pNextWordToRead)); end if; end if; end process; ---- Write data ---- pr_wr: process (wr_clk) begin if (rising_edge(wr_clk)) then if (wr_en = '1' and xfull = '0') then Mem(conv_integer(pNextWordToWrite)) &lt;= data_i; end if; end if; end process; ---- Gray counters ---- xGray_WR : rtl_gray_count generic map ( COUNTER_WIDTH =&gt; ADDR_WIDTH ) port map ( cnt =&gt; pNextWordToWrite, ena =&gt; NextWriteAddressEn, rst =&gt; reset, clk =&gt; wr_clk ); xGray_RD : rtl_gray_count generic map ( COUNTER_WIDTH =&gt; ADDR_WIDTH ) port map ( cnt =&gt; pNextWordToRead, ena =&gt; NextReadAddressEn, rst =&gt; reset, clk =&gt; rd_clk );</span></span></code> </pre><br></div></div><br><h3>  Bibliography </h3><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7 Series FPGAs Overview (DS180) (xilinx.com) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Xilinx 7 Series Libraries Guide for Schematic Designs (xilinx.com) </font></font></li><li> 7 Series FPGAs SelectIO Resources User Guide (UG471) (xilinx.com) </li><li> 7 Series FPGAs Clocking Resources User Guide (UG472) (xilinx.com) </li><li> Serial LVDS High-Speed ADC Interface (xilinx.com) </li><li> Analog for Xilinx ¬Æ FPGAs Selection Guide (ti.com) </li><li> HSC-ADC-FPGA High Speed Deserialization (analog.com) </li><li> Interfacing Analog to Digital Converters to FPGAs (latticesemi.com) </li></ul>  etc. <br><br>  <i>To be continued...</i> </div><p>Source: <a href="https://habr.com/ru/post/313692/">https://habr.com/ru/post/313692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../313682/index.html">As I wrote the game for the contest, or the wonderful transformation of "Lines" into "Sea battle"</a></li>
<li><a href="../313684/index.html">Selection of useful materials on DevOps</a></li>
<li><a href="../313686/index.html">Comparison of logging libraries</a></li>
<li><a href="../313688/index.html">Two-factor authentication and open doors</a></li>
<li><a href="../313690/index.html">The cellars of the Tower of Babel, or the internationalization of databases with access through ORM</a></li>
<li><a href="../313694/index.html">History of programming languages: C # - ahead of the rest</a></li>
<li><a href="../313696/index.html">[Bookmark] Zoo neural network architectures. Part 1</a></li>
<li><a href="../313698/index.html">Pro information systems and old sewer pipes</a></li>
<li><a href="../313700/index.html">Twelve commandments of software localization</a></li>
<li><a href="../313702/index.html">Mikrotik: a little trick switch chip</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>