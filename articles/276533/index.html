<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Procedurally generated world maps on Unity C #, part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the third article from the series on procedurally generated maps using Unity and C # maps of the world. The cycle will consist of four article...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Procedurally generated world maps on Unity C #, part 3</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/2a7/1b8/0ec/2a71b80ec9814265bec7783fbdb01cc8.png" alt="image"><br><br>  This is the third article from the series on procedurally generated maps using Unity and C # maps of the world.  The cycle will consist of four articles. <br><a name="habracut"></a><br>  Content <br><br>  <a href="https://habrahabr.ru/post/276251/">Part 1</a> : 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Introduction <br>  Noise generation <br>  Beginning of work <br>  Generate elevation map <br><br>  <a href="https://habrahabr.ru/post/276281/">Part 2</a> : <br><br>  Map folding on one axis <br>  Map folding on both axes <br>  Neighbor Search <br>  Bit masks <br>  Fill <br><br>  Part 3 (this article): <br><br>  Heat map generation <br>  Humidity Map Generation <br>  River generation <br><br>  <a href="https://habrahabr.ru/post/276551/">Part 4</a> : <br><br>  Biome generation <br>  Spherical map generation <br><br>  <b>Heat map generation</b> <br><br>  The heat map determines the temperature of the generated world.  The heat map we create will be based on the height and latitude data.  These latitudes can be obtained by a simple noise gradient.  The Accidental Noise library provides the following function: <br><br><pre><code class="cs hljs">ImplicitGradient gradient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImplicitGradient (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Since we are folding the world, as a heat gradient we will have only one gradient along the Y axis. <br><br>  To generate a heat map texture, add a new function to the TextureGenerator class.  It will allow us to visually monitor changes occurring with the heat map: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Texture2D </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHeatMapTexture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, Tile[,] tiles</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D(width, height); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pixels = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color[width * height]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; height; y++) { pixels[x + y * width] = Color.Lerp(Color.blue, Color.red, tiles[x,y].HeatValue); <span class="hljs-comment"><span class="hljs-comment">//darken the color if a edge tile if (tiles[x,y].Bitmask != 15) pixels[x + y * width] = Color.Lerp(pixels[x + y * width], Color.black, 0.4f); } } texture.SetPixels(pixels); texture.wrapMode = TextureWrapMode.Clamp; texture.Apply(); return texture; }</span></span></code> </pre><br>  Our temperature gradient will look like this: <br><br><img src="https://habrastorage.org/files/37c/038/c80/37c038c80b5a476fbe5893222bf0665e.png" alt="image"><br><br>  This data is a great start, because we need a warm strip in the center of the map, similar to the equator of the Earth.  This will be the basis of the heat map on which we will begin work. <br><br>  Now we need to assign HeatType areas (heat types) that are similar to the HeightType areas (height types) from the previous part of the article. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HeatType { Coldest, Colder, Cold, Warm, Warmer, Warmest }</code> </pre><br>  We will make these types of heat customizable from the Unity inspector using new variables: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ColdestValue = <span class="hljs-number"><span class="hljs-number">0.05f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ColderValue = <span class="hljs-number"><span class="hljs-number">0.18f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ColdValue = <span class="hljs-number"><span class="hljs-number">0.4f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WarmValue = <span class="hljs-number"><span class="hljs-number">0.6f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WarmerValue = <span class="hljs-number"><span class="hljs-number">0.8f</span></span>;</code> </pre><br>  In LoadTiles, based on the heat value, we will assign a HeatType for each tile. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    if (heatValue &lt; ColdestValue) t.HeatType = HeatType.Coldest; else if (heatValue &lt; ColderValue) t.HeatType = HeatType.Colder; else if (heatValue &lt; ColdValue) t.HeatType = HeatType.Cold; else if (heatValue &lt; WarmValue) t.HeatType = HeatType.Warm; else if (heatValue &lt; WarmerValue) t.HeatType = HeatType.Warmer; else t.HeatType = HeatType.Warmest;</span></span></code> </pre><br>  Now we can add new colors for each HeatType to the TextureGenerator class: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    private static Color Coldest = new Color(0, 1, 1, 1); private static Color Colder = new Color(170/255f, 1, 1, 1); private static Color Cold = new Color(0, 229/255f, 133/255f, 1); private static Color Warm = new Color(1, 1, 100/255f, 1); private static Color Warmer = new Color(1, 100/255f, 0, 1); private static Color Warmest = new Color(241/255f, 12/255f, 0, 1); public static Texture2D GetHeatMapTexture(int width, int height, Tile[,] tiles) { var texture = new Texture2D(width, height); var pixels = new Color[width * height]; for (var x = 0; x &lt; width; x++) { for (var y = 0; y &lt; height; y++) { switch (tiles[x,y].HeatType) { case HeatType.Coldest: pixels[x + y * width] = Coldest; break; case HeatType.Colder: pixels[x + y * width] = Colder; break; case HeatType.Cold: pixels[x + y * width] = Cold; break; case HeatType.Warm: pixels[x + y * width] = Warm; break; case HeatType.Warmer: pixels[x + y * width] = Warmer; break; case HeatType.Warmest: pixels[x + y * width] = Warmest; break; } // ,     if (tiles[x,y].Bitmask != 15) pixels[x + y * width] = Color.Lerp(pixels[x + y * width], Color.black, 0.4f); } } texture.SetPixels(pixels); texture.wrapMode = TextureWrapMode.Clamp; texture.Apply(); return texture; }</span></span></code> </pre><br>  By generating this heat map, we get the following image: <br><br><img src="https://habrastorage.org/files/405/516/d47/405516d476b54268a7a1320f3ef53c1d.png" alt="image"><br><br>  Now we can clearly see the designated areas of HeatType.  However, this data is still only stripes.  They tell us nothing but temperature data based on latitude.  In reality, temperature depends on many factors, so we will mix fractal noise with this gradient noise. <br><br>  Add a couple of new variables and a new fractal to the Generator: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> HeatOctaves = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> HeatFrequency = <span class="hljs-number"><span class="hljs-number">3.0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ImplicitGradient gradient = new ImplicitGradient (1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1); ImplicitFractal heatFractal = new ImplicitFractal(FractalType.MULTI, BasisType.SIMPLEX, InterpolationType.QUINTIC, HeatOctaves, HeatFrequency, Seed); //      HeatMap = new ImplicitCombiner (CombinerType.MULTIPLY); HeatMap.AddSource (gradient); HeatMap.AddSource (heatFractal); }</span></span></code> </pre><br>  When combining a fractal with a gradient using a multiply operation (Multiply), the final noise is multiplied based on the latitude.  The Multiply operation is illustrated below: <br><br><img src="https://habrastorage.org/files/2a7/1b8/0ec/2a71b80ec9814265bec7783fbdb01cc8.png" alt="image"><br><br>  Gradient noise on the left, fractal noise in the middle, the Multiply operation result on the right.  As you can see, we have a much more pleasant heat map. <br><br>  Now let's do the breadth.  We need to take into account the height map: we want the peaks of the highest mountains to be cold.  This can be configured in the LoadTiles function: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//      .  =  if (t.HeightType == HeightType.Grass) { HeatData.Data[tX, tY] -= 0.1f * t.HeightValue; } else if (t.HeightType == HeightType.Forest) { HeatData.Data[tX, tY] -= 0.2f * t.HeightValue; } else if (t.HeightType == HeightType.Rock) { HeatData.Data[tX, tY] -= 0.3f * t.HeightValue; } else if (t.HeightType == HeightType.Snow) { HeatData.Data[tX, tY] -= 0.4f * t.HeightValue; }</span></span></code> </pre><br>  This setting gives us the final heat map, which takes into account both latitude and height: <br><br><img src="https://habrastorage.org/files/6d4/678/c65/6d4678c651cf4f21bbdfff68ac4b94c6.png" alt="image"><br><br>  <b>Humidity Map Generation</b> <br><br>  The humidity map is similar to a heat map.  First, generate a fractal to fill the base with random values.  Then we change this data based on the heat map. <br><br>  We will look at the moisture generation code in brief, because it is very similar to the heat map code. <br><br>  First, let's add the Tile class to the new MoistureType: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> MoistureType { Wettest, Wetter, Wet, Dry, Dryer, Dryest }</code> </pre><br>  The Generator class will need new variables visible from Unity Inspector: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MoistureOctaves = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> MoistureFrequency = <span class="hljs-number"><span class="hljs-number">3.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DryerValue = <span class="hljs-number"><span class="hljs-number">0.27f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DryValue = <span class="hljs-number"><span class="hljs-number">0.4f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WetValue = <span class="hljs-number"><span class="hljs-number">0.6f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WetterValue = <span class="hljs-number"><span class="hljs-number">0.8f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WettestValue = <span class="hljs-number"><span class="hljs-number">0.9f</span></span>;</code> </pre><br>  In TextureGenerator, a new moisture map generation function (MoistureMap) and its associated colors are needed: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  private static Color Dryest = new Color(255/255f, 139/255f, 17/255f, 1); private static Color Dryer = new Color(245/255f, 245/255f, 23/255f, 1); private static Color Dry = new Color(80/255f, 255/255f, 0/255f, 1); private static Color Wet = new Color(85/255f, 255/255f, 255/255f, 1); private static Color Wetter = new Color(20/255f, 70/255f, 255/255f, 1); private static Color Wettest = new Color(0/255f, 0/255f, 100/255f, 1);</span></span></code> </pre><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Texture2D </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMoistureMapTexture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, Tile[,] tiles</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D(width, height); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pixels = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color[width * height]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; height; y++) { Tile t = tiles[x,y]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t.MoistureType == MoistureType.Dryest) pixels[x + y * width] = Dryest; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t.MoistureType == MoistureType.Dryer) pixels[x + y * width] = Dryer; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t.MoistureType == MoistureType.Dry) pixels[x + y * width] = Dry; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t.MoistureType == MoistureType.Wet) pixels[x + y * width] = Wet; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t.MoistureType == MoistureType.Wetter) pixels[x + y * width] = Wetter; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> pixels[x + y * width] = Wettest; } } texture.SetPixels(pixels); texture.wrapMode = TextureWrapMode.Clamp; texture.Apply(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> texture; }</code> </pre><br>  Finally, the LoadTiles function will set the type of moisture (MoistureType) based on the value of moisture (MoistureValue): <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   float moistureValue = MoistureData.Data[x,y]; moistureValue = (moistureValue - MoistureData.Min) / (MoistureData.Max - MoistureData.Min); t.MoistureValue = moistureValue; //   if (moistureValue &lt; DryerValue) t.MoistureType = MoistureType.Dryest; else if (moistureValue &lt; DryValue) t.MoistureType = MoistureType.Dryer; else if (moistureValue &lt; WetValue) t.MoistureType = MoistureType.Dry; else if (moistureValue &lt; WetterValue) t.MoistureType = MoistureType.Wet; else if (moistureValue &lt; WettestValue) t.MoistureType = MoistureType.Wetter; else t.MoistureType = MoistureType.Wettest;</span></span></code> </pre><br>  When rendering the original noise for a MoistureMap, we get the following: <br><br><img src="https://habrastorage.org/files/03a/0ef/aad/03a0efaada3740c7bf6b8158fbb1574f.png" alt="image"><br><br>  The only thing left for us is to adjust the humidity map according to the height map.  We do this in the LoadTiles function: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    if (t.HeightType == HeightType.DeepWater) { MoistureData.Data[tX, tY] += 8f * t.HeightValue; } else if (t.HeightType == HeightType.ShallowWater) { MoistureData.Data[tX, tY] += 3f * t.HeightValue; } else if (t.HeightType == HeightType.Shore) { MoistureData.Data[tX, tY] += 1f * t.HeightValue; } else if (t.HeightType == HeightType.Sand) { MoistureData.Data[tX, tY] += 0.25f * t.HeightValue; }</span></span></code> </pre><br>  After adjusting the humidity map to the height of certain tiles, the updated humidity map looks much better: <br><br><img src="https://habrastorage.org/files/01d/f6b/714/01df6b71456f487d9ea7ea1df378e259.png" alt="image"><br><br>  <b>River generation</b> <br><br>  The way of generating rivers, which I will describe, is an attempt to solve the problem of creating convincing-looking brute-force rivers. <br><br>  The first step of the algorithm is the selection of a random tile on the map.  The selected tile must be dry and have a height value above a certain limit. <br><br>  Starting from this tile, we determine which neighboring tile is located below all, and move to it.  In this way, we create a path until a water tile is reached. <br><br>  If the generated path meets our criteria (river length, number of bends, number of crossings), we save it for future use. <br><br>  Otherwise, we discard it and try again.  The code below will allow us to start: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateRivers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> attempts = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rivercount = RiverCount; Rivers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;River&gt; (); <span class="hljs-comment"><span class="hljs-comment">//   while (rivercount &gt; 0 &amp;&amp; attempts &lt; MaxRiverAttempts) { //    int x = UnityEngine.Random.Range (0, Width); int y = UnityEngine.Random.Range (0, Height); Tile tile = Tiles[x,y]; //   if (!tile.Collidable) continue; if (tile.Rivers.Count &gt; 0) continue; if (tile.HeightValue &gt; MinRiverHeight) { //      River river = new River(rivercount); // ,        river.CurrentDirection = tile.GetLowestNeighbor (); //      FindPathToWater(tile, river.CurrentDirection, ref river); //     if (river.TurnCount &lt; MinRiverTurns || river.Tiles.Count &lt; MinRiverLength || river.Intersections &gt; MaxRiverIntersections) { //   -    for (int i = 0; i &lt; river.Tiles.Count; i++) { Tile t = river.Tiles[i]; t.Rivers.Remove (river); } } else if (river.Tiles.Count &gt;= MinRiverLength) { //  -     Rivers.Add (river); tile.Rivers.Add (river); rivercount--; } } attempts++; } }</span></span></code> </pre><br>  The recursive function FindPathToWater () determines the best selectable path based on the height of the land, existing rivers and the preferred direction.  Sooner or later she will find a way to the water tile.  The function is called recursively until the path is completed. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPathToWater</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Tile tile, Direction direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> River river</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Rivers.Contains (river)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ,        if (tile.Rivers.Count &gt; 0) river.Intersections++; river.AddTile (tile); //    Tile left = GetLeft (tile); Tile right = GetRight (tile); Tile top = GetTop (tile); Tile bottom = GetBottom (tile); float leftValue = int.MaxValue; float rightValue = int.MaxValue; float topValue = int.MaxValue; float bottomValue = int.MaxValue; //     if (left.GetRiverNeighborCount(river) &lt; 2 &amp;&amp; !river.Tiles.Contains(left)) leftValue = left.HeightValue; if (right.GetRiverNeighborCount(river) &lt; 2 &amp;&amp; !river.Tiles.Contains(right)) rightValue = right.HeightValue; if (top.GetRiverNeighborCount(river) &lt; 2 &amp;&amp; !river.Tiles.Contains(top)) topValue = top.HeightValue; if (bottom.GetRiverNeighborCount(river) &lt; 2 &amp;&amp; !river.Tiles.Contains(bottom)) bottomValue = bottom.HeightValue; //     ,   ,    if (bottom.Rivers.Count == 0 &amp;&amp; !bottom.Collidable) bottomValue = 0; if (top.Rivers.Count == 0 &amp;&amp; !top.Collidable) topValue = 0; if (left.Rivers.Count == 0 &amp;&amp; !left.Collidable) leftValue = 0; if (right.Rivers.Count == 0 &amp;&amp; !right.Collidable) rightValue = 0; //  ,     if (direction == Direction.Left) if (Mathf.Abs (rightValue - leftValue) &lt; 0.1f) rightValue = int.MaxValue; if (direction == Direction.Right) if (Mathf.Abs (rightValue - leftValue) &lt; 0.1f) leftValue = int.MaxValue; if (direction == Direction.Top) if (Mathf.Abs (topValue - bottomValue) &lt; 0.1f) bottomValue = int.MaxValue; if (direction == Direction.Bottom) if (Mathf.Abs (topValue - bottomValue) &lt; 0.1f) topValue = int.MaxValue; //   float min = Mathf.Min (Mathf.Min (Mathf.Min (leftValue, rightValue), topValue), bottomValue); //     -  if (min == int.MaxValue) return; //    if (min == leftValue) { if (left.Collidable) { if (river.CurrentDirection != Direction.Left){ river.TurnCount++; river.CurrentDirection = Direction.Left; } FindPathToWater (left, direction, ref river); } } else if (min == rightValue) { if (right.Collidable) { if (river.CurrentDirection != Direction.Right){ river.TurnCount++; river.CurrentDirection = Direction.Right; } FindPathToWater (right, direction, ref river); } } else if (min == bottomValue) { if (bottom.Collidable) { if (river.CurrentDirection != Direction.Bottom){ river.TurnCount++; river.CurrentDirection = Direction.Bottom; } FindPathToWater (bottom, direction, ref river); } } else if (min == topValue) { if (top.Collidable) { if (river.CurrentDirection != Direction.Top){ river.TurnCount++; river.CurrentDirection = Direction.Top; } FindPathToWater (top, direction, ref river); } } }</span></span></code> </pre><br>  After performing the process of generating rivers, we will have several paths leading to the water.  It will look something like this: <br><br><img src="https://habrastorage.org/files/631/0bb/8bb/6310bb8bb43e4783be3f975e20f187fe.png" alt="image"><img src="https://habrastorage.org/files/b7c/4dc/b96/b7c4dcb968054259897e2f72f362363b.png" alt="image"><br><br>  Many paths intersect, and if we dug these rivers now, they would look a little strange, because their dimensions would not match at the intersection point.  Therefore, we need to determine which of the rivers intersect, and group them. <br><br>  We need the RiverGroup class: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RiverGroup</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;River&gt; Rivers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;River&gt;(); }</code> </pre><br>  As well as code grouping intersecting rivers: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildRiverGroups</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,      for (var x = 0; x &lt; Width; x++) { for (var y = 0; y &lt; Height; y++) { Tile t = Tiles[x,y]; if (t.Rivers.Count &gt; 1) { //   ==  RiverGroup group = null; //        ? for (int n=0; n &lt; t.Rivers.Count; n++) { River tileriver = t.Rivers[n]; for (int i = 0; i &lt; RiverGroups.Count; i++) { for (int j = 0; j &lt; RiverGroups[i].Rivers.Count; j++) { River river = RiverGroups[i].Rivers[j]; if (river.ID == tileriver.ID) { group = RiverGroups[i]; } if (group != null) break; } if (group != null) break; } if (group != null) break; } //    --    if (group != null) { for (int n=0; n &lt; t.Rivers.Count; n++) { if (!group.Rivers.Contains(t.Rivers[n])) group.Rivers.Add(t.Rivers[n]); } } else //    --   { group = new RiverGroup(); for (int n=0; n &lt; t.Rivers.Count; n++) { group.Rivers.Add(t.Rivers[n]); } RiverGroups.Add (group); } } } } }</span></span></code> </pre><br>  So, we have groups of rivers that intersect and flow to the water.  When rendering these groups, the following is obtained, each group is represented by its own random color: <br><br><img src="https://habrastorage.org/files/fc4/2de/193/fc42de19341547399cca36998005f59f.png" alt="image"><br><br>  With this information, we can begin to "dig" our rivers.  For each group of rivers, we begin by digging the longest river in the group.  The remaining rivers are digging on the basis of this longest journey. <br><br>  The code below shows how we begin to dig groups of rivers: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DigRiverGroups</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; RiverGroups.Count; i++) { RiverGroup <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> = RiverGroups[i]; River longest = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">//       for (int j = 0; j &lt; group.Rivers.Count; j++) { River river = group.Rivers[j]; if (longest == null) longest = river; else if (longest.Tiles.Count &lt; river.Tiles.Count) longest = river; } if (longest != null) { //     DigRiver (longest); for (int j = 0; j &lt; group.Rivers.Count; j++) { River river = group.Rivers[j]; if (river != longest) { DigRiver (river, longest); } } } } }</span></span></code> </pre><br>  The river digging code is a bit more complicated as it tries to randomize as many parameters as possible. <br><br>  It is also important that the river expands when approaching the water.  The DigRiver () code is not very beautiful, but it copes with the task: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DigRiver</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">River river</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     ? int size = UnityEngine.Random.Range(1,5); river.Length = river.Tiles.Count; //    int two = river.Length / 2; int three = two / 2; int four = three / 2; int five = four / 2; int twomin = two / 3; int threemin = three / 3; int fourmin = four / 3; int fivemin = five / 3; //     int count1 = UnityEngine.Random.Range (fivemin, five); if (size &lt; 4) { count1 = 0; } int count2 = count1 + UnityEngine.Random.Range(fourmin, four); if (size &lt; 3) { count2 = 0; count1 = 0; } int count3 = count2 + UnityEngine.Random.Range(threemin, three); if (size &lt; 2) { count3 = 0; count2 = 0; count1 = 0; } int count4 = count3 + UnityEngine.Random.Range (twomin, two); // ,         if (count4 &gt; river.Length) { int extra = count4 - river.Length; while (extra &gt; 0) { if (count1 &gt; 0) { count1--; count2--; count3--; count4--; extra--; } else if (count2 &gt; 0) { count2--; count3--; count4--; extra--; } else if (count3 &gt; 0) { count3--; count4--; extra--; } else if (count4 &gt; 0) { count4--; extra--; } } } //   for (int i = river.Tiles.Count - 1; i &gt;= 0 ; i--) { Tile t = river.Tiles[i]; if (counter &lt; count1) { t.DigRiver (river, 4); } else if (counter &lt; count2) { t.DigRiver (river, 3); } else if (counter &lt; count3) { t.DigRiver (river, 2); } else if ( counter &lt; count4) { t.DigRiver (river, 1); } else { t.DigRiver(river, 0); } counter++; } }</span></span></code> </pre><br>  After digging the river we get something like this: <br><br><img src="https://habrastorage.org/files/947/25d/6bd/94725d6bd17c494bbd66b7f714d36f26.png" alt="image"><br><br>  We received convincing-looking rivers, but we need to make sure that they provide moisture maps.  Rivers do not appear in desert areas, so you need to check whether the area around the rivers is dry. <br><br>  To simplify this process, we will add a new function that will customize the humidity map based on the river data. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustMoistureMap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; Width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; Height; y++) { Tile t = Tiles[x,y]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t.HeightType == HeightType.River) { AddMoisture (t, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)<span class="hljs-number"><span class="hljs-number">60</span></span>); } } } }</code> </pre><br>  The added moisture varies based on the distance from the original tile.  The farther from the river, the less moisture the tile receives. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddMoisture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Tile t, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startx = MathHelper.Mod (tX - radius, Width); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endx = MathHelper.Mod (tX + radius, Width); Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(tX, tY); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curr = radius; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (curr &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x1 = MathHelper.Mod (tX - curr, Width); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x2 = MathHelper.Mod (tX + curr, Width); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = tY; AddMoisture(Tiles[x1, y], <span class="hljs-number"><span class="hljs-number">0.025f</span></span> / (center - <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(x1, y)).magnitude); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; curr; i++) { AddMoisture (Tiles[x1, MathHelper.Mod (y + i + <span class="hljs-number"><span class="hljs-number">1</span></span>, Height)], <span class="hljs-number"><span class="hljs-number">0.025f</span></span> / (center - <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(x1, MathHelper.Mod (y + i + <span class="hljs-number"><span class="hljs-number">1</span></span>, Height))).magnitude); AddMoisture (Tiles[x1, MathHelper.Mod (y - (i + <span class="hljs-number"><span class="hljs-number">1</span></span>), Height)], <span class="hljs-number"><span class="hljs-number">0.025f</span></span> / (center - <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(x1, MathHelper.Mod (y - (i + <span class="hljs-number"><span class="hljs-number">1</span></span>), Height))).magnitude); AddMoisture (Tiles[x2, MathHelper.Mod (y + i + <span class="hljs-number"><span class="hljs-number">1</span></span>, Height)], <span class="hljs-number"><span class="hljs-number">0.025f</span></span> / (center - <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(x2, MathHelper.Mod (y + i + <span class="hljs-number"><span class="hljs-number">1</span></span>, Height))).magnitude); AddMoisture (Tiles[x2, MathHelper.Mod (y - (i + <span class="hljs-number"><span class="hljs-number">1</span></span>), Height)], <span class="hljs-number"><span class="hljs-number">0.025f</span></span> / (center - <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(x2, MathHelper.Mod (y - (i + <span class="hljs-number"><span class="hljs-number">1</span></span>), Height))).magnitude); } curr--; } }</code> </pre><br>  This setting gives us an updated map of humidity, taking into account the presence of rivers.  It will come in handy in the next part, in which we will begin to generate biomes. <br><br>  The updated humidity map will look something like this: <br><br><img src="https://habrastorage.org/files/4bf/c71/c83/4bfc71c8305a4eb6aae6fc602e5a7ec4.png" alt="image"><br><br>  The fourth part of the article will be ready soon.  This will be the best part in which we use all the maps we have generated to create the world. <br><br>  The source code for the third part on github: <a href="https://github.com/jongallant/WorldGeneratorPart3">World Generator Part 3</a> . <br>  <a href="https://habrahabr.ru/post/276551/">The fourth part, the last</a> . </div><p>Source: <a href="https://habr.com/ru/post/276533/">https://habr.com/ru/post/276533/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276519/index.html">SVG-files from the inside and the output of vector images on the canvas "manually" (Part 1)</a></li>
<li><a href="../276523/index.html">The most basic need: how did we implement DNS hosting at Mail.Ru for business?</a></li>
<li><a href="../276525/index.html">Recruitment to St. Petersburg Academic University</a></li>
<li><a href="../276527/index.html">Notes of a true architect: just about the most important thing (Part 1)</a></li>
<li><a href="../276531/index.html">Unified test runner and analysis of test data</a></li>
<li><a href="../276535/index.html">How are the packages for checking the quality of random sequences?</a></li>
<li><a href="../276539/index.html">This is the future</a></li>
<li><a href="../276541/index.html">The report on the results of visits to ISC-2015</a></li>
<li><a href="../276545/index.html">FBI: Hedge Fund Traders Share Insider Information in the Call of Duty Game Chat</a></li>
<li><a href="../276547/index.html">Install Azure Stack TP1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>