<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A short course in computer graphics: we write a simplified OpenGL do it yourself, article 2 of 6</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Course content 


- Article 1: Bresenham algorithm 
- Article 2: rasterization of the triangle + clipping of the rear faces 
- Article 3: Removing inv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A short course in computer graphics: we write a simplified OpenGL do it yourself, article 2 of 6</h1><div class="post__text post__text-html js-mediator-article"><h1>  Course content </h1><br><ul><li>  <a href="http://habrahabr.ru/post/248153/">Article 1: Bresenham algorithm</a> </li><li>  <b>Article 2: rasterization of the triangle + clipping of the rear faces</b> </li><li>  <a href="http://habrahabr.ru/post/248179/">Article 3: Removing invisible surfaces: z-buffer</a> </li><li>  Article 4: Required Geometry: Matrix Festival <br><ul><li>  <a href="http://habrahabr.ru/post/248611/">4a: Construction of perspective distortion</a> </li><li>  <a href="http://habrahabr.ru/post/248723/">4b: we move the camera and what follows from this</a> </li><li>  <a href="http://habrahabr.ru/post/249467/">4c: a new rasterizer and perspective distortion correction</a> </li></ul></li><li>  <a href="http://habrahabr.ru/post/248963/">Article 5: We write shaders for our library</a> </li><li>  <a href="http://habrahabr.ru/post/249139/">Article 6: A little more than just a shader: shadow rendering</a> </li></ul><br><h3>  Code enhancement </h3><br><ul><li>  <a href="http://habrahabr.ru/post/248909/">Article 3.1: It‚Äôs time to refactor</a> </li><li>  <a href="http://habrahabr.ru/post/249101/">Article 3.14: Beautiful Matrix Class</a> </li></ul><br><br><br><hr><h3>  The official translation (with a bit of polishing) is available <a href="https://github.com/ssloy/tinyrenderer/wiki">here.</a> </h3><hr><br><br><h3>  Update: </h3><br>  <b>Attention, <a href="http://habrahabr.ru/post/249467/">Article 4c</a> provides a new, simpler version of the rasterizer.</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's get acquainted, it's me. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b58/d5f/0e8/b58d5f0e8f7de59bcad1354b0fc92a35.png"><br><br>  That is, the model of my head, rendered in the program, which we will do in the next hour or two. <br><br>  Last time we drew a wire mesh of a three-dimensional model, this time we fill in polygons.  More precisely, the triangles, since OpenGL almost every polygon triangulates, so there‚Äôs no need to disassemble the complex case.  I remind you that this series of articles was created for <i>independent</i> programming.  The time I give here is not the time to read my code.  This is the time to write your code from scratch.  My code is here only to compare your (working) code with mine.  I‚Äôm not a good programmer at all, so your code can be significantly better than mine.  Any criticism is welcome, any questions glad. <br><br>  <b>Please, if you follow this tutorial and write your code, post it on github.com/code.google.com and the like and give links in the comments!</b>  <b>It may well help both you (other people may advise something) and future readers.</b> <br><a name="habracut"></a><br><h1>  Draw a filled triangle </h1><br>  So, the topic for today (about two hours for badly programming, but motivated students): drawing two-dimensional triangles.  Last time we disassembled the Brezenham algorithm for rasterization of the segment, now the task is to draw a filled triangle.  You will laugh, but this is not a trivial task.  I don't know why, but I know that it is.  Most of my students, without prompts, spend significantly more than a couple of hours on this task.  Let's determine the method, and then we will program. <br><br>  At the very beginning, let's consider this pseudocode: <br><br><pre> triangle (vec2 points [3]) {
     vec2 bbox [2] = find_bounding_box (points);
     for (each pixel in the bounding box) {
         if (inside (points, pixel)) {
             put_pixel (pixel);
         }
     }
 }
</pre><br>  I really love this method.  He is simple and working.  It is extremely easy to find a descriptive rectangle; it‚Äôs also easy to verify that a point belongs to a two-dimensional triangle (and any convex polygon). <br><br>  <i>Offtopic: if I need to write a code that will spin on, say, a plane, and this code will have to check the belonging of a point to a polygon, I will never sit on this plane.</i>  <i>This is a surprisingly difficult problem if we want to solve it <b>reliably</b> .</i> <br><br>  Why do I love this code?  Yes, because, having seen such a thing, a newcomer to programming will be enthusiastically perceived by him, a person who is a little familiar with programming, just smirks smugly, saying that the idiot wrote.  An expert in computer graphics programming just shrugs, saying, well, yes, that‚Äôs how it works in real life.  Massively parallel computing in thousands of small GPUs (I‚Äôm talking about ordinary consumer computers) work wonders.  But we will write code for the central processor, so we will not use this method.  And what's the difference, as it is there in silicon, our abstraction is enough to understand the principle of operation. <br><br>  Ok, the initial stub will look like this: <br><pre> void triangle (Vec2i t0, Vec2i t1, Vec2i t2, TGAImage &amp; image, TGAColor color) {
     line (t0, t1, image, color);
     line (t1, t2, image, color);
     line (t2, t0, image, color);
 }<font></font>
<font></font>
 [...]<font></font>
<font></font>
     Vec2i t0 [3] = {Vec2i (10, 70), Vec2i (50, 160), Vec2i (70, 80)};
     Vec2i t1 [3] = {Vec2i (180, 50), Vec2i (150, 1), Vec2i (70, 180)};
     Vec2i t2 [3] = {Vec2i (180, 150), Vec2i (120, 160), Vec2i (130, 180)};<font></font>
<font></font>
<font></font>
     triangle (t0 [0], t0 [1], t0 [2], image, red);
     triangle (t1 [0], t1 [1], t1 [2], image, white);
     triangle (t2 [0], t2 [1], t2 [2], image, green);
</pre><br><br><img src="https://habrastorage.org/getpro/habr/post_images/30e/b4e/46f/30eb4e46f1904293298677f515d7e97c.png"><br><br>  As usual, a <a href="https://github.com/ssloy/tinyrenderer/tree/7e46cc57fa3f5a41129d6b6fefe4e77f77b8aa84">code fingerprint</a> is available on the githaba.  Everything is simple in this code: I give three triangles for initial debugging of your code;  if inside the triangle function just make the call line (), then we get the outline of the triangle.  How to draw a <i>filled</i> triangle? <br><br>  A good method for drawing a triangle should have the following properties: <br><ul><li>  It should be (surprise) simple and fast. </li><li>  It should be symmetrical: the picture should not depend on the order of the vertices passed to the drawing function </li><li>  If two triangles have two common vertices, there should be no holes between them due to rounding rasterization. </li></ul><br>  There are many more requirements to add, but we are content with these three. <br><br>  Traditionally, line sweeping is used: <br><ul><li>  Sort the vertices of the triangle by their y-coordinate </li><li>  Rasterize parallel the left and right borders of the triangle </li><li>  Draw a horizontal segment between the left and right point of the border </li></ul><br><br>  Then my students begin to get lost, who is left, who is right, and indeed, there are three segments in the triangle ... <br>  At this point, I leave my students for about an hour, reading my code is far less valuable than comparing my (suffered!) Code with mine. <br><br>  [An hour has passed] <br><br>  How do i draw?  Once again, if you have a better method, I will use it with great pleasure.  Let's assume that we have three points of the triangle, t0, t1, t2, they are sorted in ascending order of the y-coordinate. <br>  Then the border A will be between t0 and t2, the border B will be between t0 and t1, and then between t1 and t2. <br><pre> void triangle (Vec2i t0, Vec2i t1, Vec2i t2, TGAImage &amp; image, TGAColor color) {
     // sort the vertices, t0, t1, t2 lower-to-upper (bubblesort yay!)
     if (t0.y&gt; t1.y) std :: swap (t0, t1);
     if (t0.y&gt; t2.y) std :: swap (t0, t2);
     if (t1.y&gt; t2.y) std :: swap (t1, t2);<font></font>
<font></font>
     line (t0, t1, image, green);
     line (t1, t2, image, green);
     line (t2, t0, image, red);
 }
</pre><br><br>  Here we have border A drawn in red, and border B in green. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c86/7b3/e2c/c867b3e2c19c2af991885384f76847c0.png"><br><br>  Border B, unfortunately, is compound.  Let's draw the lower half of the triangle, cutting it horizontally at the breakpoint of the border B. <br><br><pre> void triangle (Vec2i t0, Vec2i t1, Vec2i t2, TGAImage &amp; image, TGAColor color) {
     // sort the vertices, t0, t1, t2 lower-to-upper (bubblesort yay!)
     if (t0.y&gt; t1.y) std :: swap (t0, t1);
     if (t0.y&gt; t2.y) std :: swap (t0, t2);
     if (t1.y&gt; t2.y) std :: swap (t1, t2);<font></font>
<font></font>
     int total_height = t2.y-t0.y;
     for (int y = t0.y; y &lt;= t1.y; y ++) {
         int segment_height = t1.y-t0.y + 1;
         float alpha = (float) (y-t0.y) / total_height;
         float beta = (float) (y-t0.y) / segment_height;  // be careful with divisions by zero
         Vec2i A = t0 + (t2-t0) * alpha;
         Vec2i B = t0 + (t1-t0) * beta;
         image.set (Ax, y, red);
         image.set (Bx, y, green);
     }
 }
</pre><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d41/6a4/99a/d416a499a0e471b80d05a6488ea1fa4c.png"><br><br>  Notice that this time I have got discontinuous segments.  Unlike the last time (where we drew straight lines), I didn‚Äôt get fooled by rotating the image 90 ¬∞.  Why?  This turns out not to be an obvious point.  Simply, if we connect the corresponding pairs of dots with horizontal lines, the spaces will disappear: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a91/fa0/094/a91fa0094cbd7e921d129fbb47eed7b1.png"><br><br>  Now it remains to draw the second half of the triangle.  This can be done by adding a second cycle: <br><pre> void triangle (Vec2i t0, Vec2i t1, Vec2i t2, TGAImage &amp; image, TGAColor color) {
     // sort the vertices, t0, t1, t2 lower-to-upper (bubblesort yay!)
     if (t0.y&gt; t1.y) std :: swap (t0, t1);
     if (t0.y&gt; t2.y) std :: swap (t0, t2);
     if (t1.y&gt; t2.y) std :: swap (t1, t2);<font></font>
<font></font>
     int total_height = t2.y-t0.y;
     for (int y = t0.y; y &lt;= t1.y; y ++) {
         int segment_height = t1.y-t0.y + 1;
         float alpha = (float) (y-t0.y) / total_height;
         float beta = (float) (y-t0.y) / segment_height;  // be careful with divisions by zero
         Vec2i A = t0 + (t2-t0) * alpha;
         Vec2i B = t0 + (t1-t0) * beta;
         if (Ax&gt; Bx) std :: swap (A, B);
         for (int j = Ax; j &lt;= Bx; j ++) {
             image.set (j, y, color);  // attention, due to int casts t0.y + i! = Ay
         }
     }
     for (int y = t1.y; y &lt;= t2.y; y ++) {
         int segment_height = t2.y-t1.y + 1;
         float alpha = (float) (y-t0.y) / total_height;
         float beta = (float) (y-t1.y) / segment_height;  // be careful with divisions by zero
         Vec2i A = t0 + (t2-t0) * alpha;
         Vec2i B = t1 + (t2-t1) * beta;
         if (Ax&gt; Bx) std :: swap (A, B);
         for (int j = Ax; j &lt;= Bx; j ++) {
             image.set (j, y, color);  // attention, due to int casts t0.y + i! = Ay
         }
     }
 }
</pre><br><br><img src="https://habrastorage.org/getpro/habr/post_images/dda/7b2/516/dda7b251616a80f1cb65690de02e3851.png"><br><br>  One could calm down on this, but indigestion happens to me when I see the same code twice, and even so near.  Therefore, we will make it a little less readable, but more simple for modifications. <br><br><pre> void triangle (Vec2i t0, Vec2i t1, Vec2i t2, TGAImage &amp; image, TGAColor color) {if (t0.y == t1.y &amp;&amp; t0.y == t2.y) return;  // i dont care about degenerate triangles // sort the vertices t0, t1, t2 lower-to-upper (bubblesort yay!) if (t0.y&gt; t1.y) std :: swap (t0, t1);  if (t0.y&gt; t2.y) std :: swap (t0, t2);  if (t1.y&gt; t2.y) std :: swap (t1, t2);  int total_height = t2.y-t0.y;  for (int i = 0; i &lt;total_height; i ++) {bool second_half = i&gt; t1.y-t0.y ||  t1.y == t0.y;  int segment_height = second_half?  t2.y-t1.y: t1.y-t0.y;  float alpha = (float) i / total_height;  float beta = (float) (i- (second_half? t1.y-t0.y: 0)) / segment_height;  // be careful here A = t0 + (t2-t0) * alpha;  Vec2i B = second_half?  t1 + (t2-t1) * beta: t0 + (t1-t0) * beta;  if (Ax&gt; Bx) std :: swap (A, B);  for (int j = Ax; j &lt;= Bx; j ++) {image.set (j, t0.y + i, color);  // attention, due to int casts t0.y + i! = Ay}}} </pre><br><br>  <a href="https://github.com/ssloy/tinyrenderer/tree/024ad4619b824f9179c86dc144145e2b8b155f52">Fingerprint code</a> for drawing 2d triangles. <br><br><h1>  Draw a model </h1><br>  We can already draw a model with empty triangles, let's fill them with a random color, this will help us check how well we have encoded the filling of triangles.  Here is the <a href="https://github.com/ssloy/tinyrenderer/tree/9afc1e163a6d1e9e4f302637a860cc42b9e2b482">code</a> . <br><br><pre>     for (int i = 0; i &lt;model-&gt; nfaces (); i ++) {
         std :: vector &lt;int&gt; face = model-&gt; face (i);
         Vec2i screen_coords [3];
         for (int j = 0; j &lt;3; j ++) {
             Vec3f world_coords = model-&gt; vert (face [j]);
             screen_coords [j] = Vec2i ((world_coords.x + 1.) * width / 2., (world_coords.y + 1.) * height / 2.);
         }
         triangle (screen_coords [0], screen_coords [1], screen_coords [2], image, TGAColor (rand ()% 255, rand ()% 255, rand ()% 255, 255));
     }
</pre><br><br>  It's simple: as before, we run through all the triangles, turn the world coordinates into screen coordinates and draw triangles.  A detailed description of the different coordinate systems in subsequent articles.  You should get something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aad/06f/ead/aad06feadf75e37142b7d4e9bfa212cd.png"><br><br><h1>  Flat toning </h1><br>  Let's now remove these clown colors and illuminate our model. <br>  Captain Obvious: "With the same intensity of light, the polygon is lit as brightly as possible if the light is perpendicular to it." <br><br>  Let's compare: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4d1/454/771/4d145477141e08ea0b0ab8310bcc38f7.jpg"><br><img src="https://habrastorage.org/getpro/habr/post_images/5fa/04a/e76/5fa04ae761ef0f4975bde6145bc94df5.jpg"><br><br>  Zero illumination we get if the polygon is parallel to the vector of light. <br>  To paraphrase: the intensity of illumination is equal to the scalar product of the vector of light and the normal to this triangle. <br>  The normal to a triangle can be calculated simply as the vector product of its two edges. <br><br><pre>     for (int i = 0; i &lt;model-&gt; nfaces (); i ++) {
         std :: vector &lt;int&gt; face = model-&gt; face (i);
         Vec2i screen_coords [3];
         Vec3f world_coords [3];
         for (int j = 0; j &lt;3; j ++) {
             Vec3f v = model-&gt; vert (face [j]);
             screen_coords [j] = Vec2i ((v.x + 1.) * width / 2., (v.y + 1.) * height / 2.);
             world_coords [j] = v;
         }
         Vec3f n = (world_coords [2] -world_coords [0]) ^ (world_coords [1] -world_coords [0]);
         n.normalize ();
         float intensity = n * light_dir;
         if (intensity&gt; 0) {
             triangle (screen_coords [0], screen_coords [1], screen_coords [2], image, TGAColor (intensity * 255, intensity * 255, intensity * 255, 255));
         }
     }
</pre><br><br>  But the scalar product can be negative, what does it mean?  This means that the light falls behind the polygon.  If the model is good (usually not our concern, but 3d modelers), then we just can not draw this triangle.  This allows you to quickly remove some of the invisible triangles.  In English literature, called <a href="http://en.wikipedia.org/wiki/Back-face_culling">back-face culling</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a3a/f41/137/a3af4113710b41eb09ed4b935891da80.png"><br>  Does my head model look more detailed?  Well, in it a quarter of a million triangles.  Nothing, we will add the details later, after receiving the picture that I gave for the seed in the first article. <br><br>  Notice, the internal cavity of the mouth is drawn over the lips.  Well, what, such a quick clipping of invisible triangles removes all unnecessary only for convex models.  We will remove these flaws next time by encoding the z-buffer. <br><br>  <a href="https://github.com/ssloy/tinyrenderer/tree/e1a3f2b0f9638fa6db9e0437c621132e1baa3fb1">The current version of the</a> renderer. </div><p>Source: <a href="https://habr.com/ru/post/248159/">https://habr.com/ru/post/248159/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248147/index.html">Tree - killer JSON, XML, YAML and their ilk</a></li>
<li><a href="../248149/index.html">2D lighting system for Unity3D running on a GPU</a></li>
<li><a href="../248153/index.html">A brief course of computer graphics: we write a simplified OpenGL do it yourself, article 1 of 6</a></li>
<li><a href="../248155/index.html">Sex-inspired startups: pros, cons, pitfalls</a></li>
<li><a href="../248157/index.html">Programming languages. Compositional view</a></li>
<li><a href="../248161/index.html">The digest of interesting materials for the mobile # 86 developer (on January 12-18)</a></li>
<li><a href="../248163/index.html">.NET Developer Skills</a></li>
<li><a href="../248165/index.html">Review of the most interesting materials on data analysis and machine learning ‚Ññ31 (January 12 - 18, 2015)</a></li>
<li><a href="../248169/index.html">A large list of materials for studying Meteor.JS</a></li>
<li><a href="../248173/index.html">The legacy of Jacob Bernoulli in Wolfram Language (Mathematica)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>