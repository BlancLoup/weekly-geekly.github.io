<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Select query travel through Postgres internals</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Only a few days left until the PG Day'16 Russia conference, the schedule can be viewed on our website. We are working hard, but nevertheless we manage...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Select query travel through Postgres internals</h1><div class="post__text post__text-html js-mediator-article">  <i>Only a few days left until the <b>PG Day'16 Russia</b> conference, the schedule can be viewed on our website.</i>  <i>We are working hard, but nevertheless we manage to prepare for you translations of the most interesting materials about PostgreSQL.</i>  <i>Today we bring to your attention the translation of <a href="http://patshaughnessy.net/">Pat Shaughnessy</a> 's article on the behavior of the Select query.</i> <br><br>  Preparing for this presentation in the summer, I decided to study some parts of the PostgreSQL source code in C. I ran a very simple select query and watched what Postgres does with it using the LLDB debugger C. How did Postgres understand my query?  How did he find the data I was looking for? <br><br><img src="https://habrastorage.org/files/ac8/78a/513/ac878a513fa64cc6a4368c472c777932.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This post is an informal journal of my journey through the insides of PostgreSQL.  I will describe the path I traveled and what I saw in the process.  I use a series of simple conceptual diagrams to explain how Postgres fulfilled my request.  In case you understand C, I will also leave you some landmarks and pointers that you can search if you suddenly decide to delve into the insides of the Postgres. <br><br>  The source code for PostgreSQL delighted me.  It turned out to be clean, well documented and easy to understand.  Find out for yourself how Postgres works from the inside by joining me on a journey to the depths of the tool that you use every day. <br><a name="habracut"></a><br><h3>  <font color="#000000">In search of Captain Nemo</font> </h3><br>  Here is an example request from the <a href="http://patshaughnessy.net/2014/9/17/20000-leagues-under-activerecord">first half of my presentation</a> .  We will follow Postgres while he searches for Captain Nemo: <br><br><img src="https://habrastorage.org/files/998/26a/374/99826a37400f4e368739d476ef1e6586.png"><br><br>  Finding one single name in a text column should be easy enough, right?  We will hold tight to this select query, exploring the insides of the Postgres, as deep-sea divers hold on to the rope to find their way back to the surface. <br><br><h3>  <font color="#000000">Picture as a whole</font> </h3><br>  What does Postgres do with this SQL string?  How does he understand what we mean?  How does he know what data we are looking for? <br><br>  Postgres processes each SQL command that we send it in four steps. <br><br><img src="https://habrastorage.org/files/d52/a99/861/d52a99861b694d81a8f881a740e72d4e.png"><br>  First, PostgreSQL <i>parses (‚Äúparses‚Äù)</i> our SQL query and converts it into a series of stored in memory data structures of the C language - <i>parse tree</i> .  Next, Postgres <i>analyzes</i> and <i>rewrites</i> our query, optimizing and simplifying it using a series of complex algorithms.  After that, it generates a <i>plan</i> to search our data.  Like a person with obsessive compulsive disorder who does not leave the house until his portfolio is carefully packed, Postgres will not launch our request until he has a plan.  Finally, Postgres <i>executes</i> our query.  In this presentation, I will briefly touch on the first three steps, and then focus on the last one: the <i>execution of the request</i> . <br><br>  The C function inside the Postgrece that performs this four-step process is called exec_simple_query.  You can find the link to it below along with the LLDB trace, which shows details of exactly when and how Postgres calls exec_simple_query. <br><br><hr><br><img src="https://habrastorage.org/getpro/habr/post_images/35b/699/c9a/35b699c9ae8b4cc5f6d7437e14115b9c.png" alt="image" align="left"><br><h1>  exec_simple_query </h1>  <a href="http://doxygen.postgresql.org/postgres_8c.html">view on postgresql.org</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f03/b49/c82/f03b49c82251f42679c82746c461d0ea.png" alt="image"><br><img src="https://habrastorage.org/getpro/habr/post_images/03a/932/f5a/03a932f5a87e950d8a042b01951da3e9.png" alt="image"><br><br><hr><br><h3>  <font color="#000000">Parsing</font> </h3><br>  How does Postgres understand the SQL string we sent to it?  How does he find meaning in keywords and SQL expressions of our select query?  Through a process called <i>parsing</i> ( <i>parsing</i> ).  Postgres converts our SQL string to an internal data structure, which it understands - the parse tree. <br><br>  It turns out Postgres uses the same parsing technology as Ruby, namely, a parser generator called <a href="http://www.gnu.org/software/bison/">Bison</a> .  Bison works during the postgrese build process and generates a parser code based on a set of grammar rules.  The generated parser code is what works inside Postgres when we send SQL commands to it.  Each grammar is called when the generated parser finds the corresponding pattern or syntax in the SQL string and inserts a new C memory structure into the parsing tree. <br><br>  Today I will not waste time on a detailed explanation of how the parsing algorithm works.  If you are interested in such topics, I advise you to read my book <a href="http://patshaughnessy.net/ruby-under-a-microscope">Ruby Under a Microscope</a> .  In the first chapter, I take a detailed look at an example of the LALR parsing algorithm used by Bison and Ruby.  Postgres parses the SQL query in exactly the same way. <br><br>  Using LLDB and activating some logging C code, I watched as the Postgres parser created the following parse tree for our search query for Captain Nemo: <br><br><img src="https://habrastorage.org/files/247/1a6/42d/2471a642d1894a4181a72b0ba5e25918.png"><br>  At the top is the node representing the complete SQL query, and below are the child nodes or branches that represent different pieces of SQL query syntax: the target list (list of columns), the from condition (list of tables), the where condition, the sort order, and the number of records. <br><br>  If you want to learn more about how Postgres parses SQL queries, follow the order of execution from exec_simple_query through another C function called pg_parse_query. <br><br><hr><br><img src="https://habrastorage.org/getpro/habr/post_images/35b/699/c9a/35b699c9ae8b4cc5f6d7437e14115b9c.png" alt="image" align="left"><br><h1>  pg_parse_query </h1>  <a href="http://doxygen.postgresql.org/postgres_8c.html">view on postgresql.org</a> <br><br><img src="https://habrastorage.org/files/70b/0ab/afa/70b0abafab0f437991e3946f6ad1e738.png"><br><img src="https://habrastorage.org/files/8d3/243/406/8d3243406f0a4483be674cfa06bc24e7.png"><br><br><hr><br>  As you can see, the Postgres source code has many useful and detailed comments that not only explain what is happening, but also point to important design decisions. <br><br><h3>  <font color="#000000">All the work of the dog down the drain</font> </h3><br>  The parse tree above probably seemed familiar to you - it is almost exactly the same abstract syntax tree (AST), which we observed earlier in ActiveRecord.  Remember the <a href="http://patshaughnessy.net/2014/9/17/20000-leagues-under-activerecord">first part of the presentation</a> : ActiveRecord generated our select query about Captain Nemo when we executed this Ruby query: <br><br><img src="https://habrastorage.org/files/e1a/8a0/7d5/e1a8a07d5671477d984148fea3de5b5f.png"><br>  We saw that ActiveRecord created an internal AST representation when we called methods such as where and first.  Later (see the <a href="http://patshaughnessy.net/2014/9/23/how-arel-converts-ruby-queries-into-sql-statements">second post</a> ) we watched how gem Arel converted AST into our sample select query using an algorithm based on the visitor pattern. <br><br>  If you think it‚Äôs very ironic that the first thing Postgres does with your SQL query is to convert it from string back to AST.  The process of parsing in Postgres cancels everything that ActiveRecord did before that, all the hard work that gem Arel did was in vain!  The only reason to create the SQL string was to access Postgres over the network.  But as soon as Postgres received the request, he converted it back to AST, which is a much more convenient and useful way to submit requests. <br><br>  After learning this, you can ask: Is there a better way?  Is there no other way to conceptually explain to Postgres what data we need without writing an SQL query?  Without learning a complicated SQL language or additional overhead due to using ActiveRecord and Arel?  It seems a monstrous waste of time to go that long way, creating an SQL string from AST just to convert it back to AST again.  Maybe you should use a NoSQL solution instead? <br><br>  Of course, the AST used by Postgres is very different from the AST used by ActiveRecord.  In ActiveRecord, AST consists of Ruby objects, and in Postgres it consists of a series of in-memory C language structures. The idea is one, but the implementation is very different. <br><br><h3>  <font color="#000000">Parse and rewrite</font> </h3><br>  Once Postgres has generated the parsing tree, it converts it to another tree using a different set of nodes.  It is known as the <i>query tree</i> .  Returning to the exec_simple_query C function, you can see that another C function is called further - pg_analyze_and_rewrite. <br><br><hr><br><img src="https://habrastorage.org/getpro/habr/post_images/35b/699/c9a/35b699c9ae8b4cc5f6d7437e14115b9c.png" alt="image" align="left"><br><h1>  pg_analyze_and_rewrite </h1>  <a href="http://doxygen.postgresql.org/postgres_8c.html">view on postgresql.org</a> <br><br><img src="https://habrastorage.org/files/ebd/586/d66/ebd586d668794a36878f030a956d6591.png"><br><img src="https://habrastorage.org/files/fa0/d3d/8c7/fa0d3d8c7f304e00b88d6ce4f6e242f9.png"><br><br><hr><br>  Without going into details, the analysis and rewriting process uses a number of complex algorithms and heuristics in an attempt to optimize and simplify your SQL query.  If you executed a complex select query with nested queries and a set of inner and outer join, then the scope for optimization is huge.  It is possible that Postgres will reduce the number of nested queries or unions to produce a simpler query that will execute faster. <br><br>  For our simple query select pg_analyze_and_rewrite created the following query tree: <br><br><img src="https://habrastorage.org/files/849/bd0/33e/849bd033ebbc494bb27526b91eb7c444.png"><br>  I will not pretend that I understand in detail the algorithms behind pg_analyze_and_rewrite.  I just noticed that for our example the query tree is very similar to the parse tree.  This means that the select query was so simple that Postgres could not make it even easier. <br><br><h3>  <font color="#000000">Plan</font> </h3><br>  The last thing the Posgres does before starting to fulfill our request is creating a plan.  This process involves the creation of a third node tree, which is a list of instructions for the Postgres.  Here is the plan tree for our select query: <br><br><img src="https://habrastorage.org/files/9ff/cbb/369/9ffcbb3694bf48458430df47dc0f7538.png"><br><br>  Imagine that each node in the plan tree is some kind of machine or worker.  The plan tree resembles a data pipeline or a conveyor belt in a factory.  In my simple example, the tree has only one branch.  Each node of the plan tree takes data from the output of the underlying node, processes it, and returns the result as input data for the node above.  In the next paragraph, we will follow Postgres while he fulfills the plan. <br><br>  The C function that starts the process of scheduling a request is called pg_plan_queries. <br><br><hr><br><img src="https://habrastorage.org/getpro/habr/post_images/35b/699/c9a/35b699c9ae8b4cc5f6d7437e14115b9c.png" alt="image" align="left"><br><h1>  pg_plan_queries </h1>  <a href="http://doxygen.postgresql.org/postgres_8c.html">view on postgresql.org</a> <br><br><img src="https://habrastorage.org/files/06b/1ed/7b0/06b1ed7b06184649a3cc321c2e2e87b9.png"><br><img src="https://habrastorage.org/files/d58/2a0/bdf/d582a0bdf52c47a9ab6bab54ced03821.png"><br><br><hr><br>  Notice the startup_cost and total_cost values ‚Äã‚Äãin each node.  Postgres uses these values ‚Äã‚Äãto estimate how long it will take to execute the plan.  You do not need to use the C debugger to see the execution plan for your request.  Simply add the SQL EXPLAIN command to the beginning of the query.  Like this: <br><br><img src="https://habrastorage.org/files/da8/2c6/8b6/da82c68b6e224e46b782b2d4ed8e5461.png"><br>  This is a great way to understand what Postgres is doing internally with one of your queries and why it may be slow or inefficient, despite the complex scheduling algorithms in pg_plan_queries. <br><br><h3>  <font color="#000000">Limit plan node execution</font> </h3><br>  At this point, Postgres has parsed your SQL string and converted it back to AST.  Then he optimized it and rewrote it, probably simplifying it.  After this, Postgres wrote a plan to follow to find and return the data you are looking for.  Finally, the time has come for Postgres to fulfill your request!  How will he do it?  By following the plan, of course! <br><br>  Let's start at the top of the plan tree and move down.  If you skip the root node, the first worker that Postgres uses for our request for Captain Nemo is called Limit.  The Limit node, as you might have guessed, executes the SQL LIMIT command, which limits the result to a certain number of records.  Also, this plan node executes the OFFSET command, which initiates a window with the result set, starting from the specified line. <br><br><img src="https://habrastorage.org/files/1bd/8bc/295/1bd8bc29583442bcadd0e6eaecafa7e5.png"><br><br>  When the Limit node is first called, Postgres calculates what the values ‚Äã‚Äãof limit and offset should be, since they can be tied to the result of some dynamic calculation.  In our example, the offset is 0, and limit is 1. <br><br>  Next, the Limit plan node repeatedly calls the subplan ‚Äî in our case, this Sort ‚Äî until it reaches the offset value: <br><br><img src="https://habrastorage.org/files/464/327/ec9/464327ec95894dae976575855e63c876.png"><br>  In our example, the offset is zero, so this loop will load the first data value and stop iterating.  Then Postgres will return the last data value loaded from the subplan to the calling or superior plan.  For us, this will be the very first value from the subplan. <br><br>  Finally, when Postgres continues to call the Limit node, it will transmit the data values ‚Äã‚Äãfrom the subplan one by one: <br><br><img src="https://habrastorage.org/files/66c/8cc/e4e/66c8cce4ef6d4fdcb3636056dfcead7d.png"><br>  Since in our example limit is 1, Limit will immediately return NULL, indicating to the higher plan that there is no more data available. <br><br>  Postgres executes a Limit node using a code from a file called nodeLimit.c <br><br><hr><br><img src="https://habrastorage.org/getpro/habr/post_images/35b/699/c9a/35b699c9ae8b4cc5f6d7437e14115b9c.png" alt="image" align="left"><br><h1>  Execlimit </h1>  <a href="http://doxygen.postgresql.org/nodeLimit_8c.html">view on postgresql.org</a> <br><br><img src="https://habrastorage.org/files/997/c9c/460/997c9c460b004fcfb810eea1ae3bffb2.png"><br><img src="https://habrastorage.org/files/981/ab3/f33/981ab3f33602418d95c69839c204e0d6.png"><br><br><hr><br>  You can see that Postgres source code uses words like <i>tuple</i> (a set of values, one from each column) and <i>subplan</i> .  In this example, the subplan is the Sort node, which is located in the plan under the Limit. <br><br><h3>  <font color="#000000">Running the Sort plan node</font> </h3><br>  Where do the data values ‚Äã‚Äãthat Limit filters come from?  From the Sort node located under Limit in the plan tree.  Sort loads data values ‚Äã‚Äãfrom its subplan and returns them to the calling Limit node.  This is what Sort does when the Limit node calls it the first time to get the first data value: <br><br><img src="https://habrastorage.org/files/923/bad/ca4/923badca4fed491fa722e9ed7bef8752.png"><br>  As you can see, Sort does not function at all like Limit.  It immediately loads all available data from the subplan into the buffer before returning anything.  It then sorts the buffer using the <a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort</a> algorithm and finally returns the first sorted value. <br><br>  For the second and subsequent calls, Sort simply returns additional values ‚Äã‚Äãfrom the sorted buffer, and it no longer needs to call the subplan again: <br><br><img src="https://habrastorage.org/files/11a/049/225/11a0492257e54e33b4f409143f4d5987.png"><br><br>  The Sort plan node is executed by a C function called ExecSort: <br><br><hr><br><img src="https://habrastorage.org/getpro/habr/post_images/35b/699/c9a/35b699c9ae8b4cc5f6d7437e14115b9c.png" alt="image" align="left"><br><h1>  ExecSort </h1>  <a href="http://doxygen.postgresql.org/nodeSort_8c.html">view on postgresql.org</a> <br><br><img src="https://habrastorage.org/files/34d/29f/9c2/34d29f9c2e95451fb3e783a41f0eb240.png"><br><img src="https://habrastorage.org/files/3e1/992/0a7/3e19920a719243f68e9da0bdd98ba7c4.png"><br><br><hr><br><h3>  <font color="#000000">Running the SeqScan plan node</font> </h3><br>  Where does ExecSort get values?  From its sublan - the SeqScan node located at the very bottom of the plan tree.  SeqScan stands for <i>sequential scan</i> , which means viewing all values ‚Äã‚Äãin the table and returning values ‚Äã‚Äãthat correspond to the specified filter.  To understand how scanning works with our filter, let's imagine a table of users filled with fictitious names and try to find Captain Nemo in it. <br><br><img src="https://habrastorage.org/files/b4e/ad9/8f2/b4ead98f27314d429a594020b1161d3c.png"><br><br>  Postgres starts with the first entry in the table (which is called a <i>relation</i> in the Postgres source code) and starts boolean expressions from the plan tree.  Simply put, Postgres asks the question: ‚ÄúIs this Captain Nemo?‚Äù Since Laurianne Goodwin is not Captain Nemo, Postgres moves on to the next entry. <br><br><img src="https://habrastorage.org/files/c44/9ba/b3c/c449bab3c2624b79924117aac4a84485.png"><br><br>  No, Candace is not Captain Nemo either.  Postgres continues: <br><br><img src="https://habrastorage.org/files/0c9/922/c74/0c9922c745ca47e886612e70538b508c.png"><br><br>  ... and finally finds Captain Nemo! <br><br><img src="https://habrastorage.org/files/7dd/6ea/2f8/7dd6ea2f80e94101894b7194b3328aec.png"><br><br>  Postgres executes the SeqScan node using a C function called ExecSeqScan. <br><br><hr><br><img src="https://habrastorage.org/getpro/habr/post_images/35b/699/c9a/35b699c9ae8b4cc5f6d7437e14115b9c.png" alt="image" align="left"><br><h1>  ExecSeqScan </h1>  <a href="http://doxygen.postgresql.org/nodeSeqscan_8c.html">view on postgresql.org</a> <br><br><img src="https://habrastorage.org/files/bcf/d7c/ff0/bcfd7cff07074e3d951ff322df50f223.png"><br><img src="https://habrastorage.org/files/cd4/35f/157/cd435f1571fc46ebbf3967b7cced7eac.png"><br><br><hr><br><h3>  <font color="#000000">What are we doing wrong?</font> </h3><br>  Here we are at the end!  We followed the simple select query all the way through the insides of the Postgres and saw how it was parsed, rewritten, planned, and finally executed.  After doing many thousands of lines of C code, Postgres found the data we were looking for!  Now all he has to do is return the Captain Nemo line back to our Rails application, and ActiveRecord can create a Ruby object.  Finally, we can return to the surface of our application. <br><br>  But Postgres does not stop!  Instead of simply returning the data, he continues to scan the user table, although we have already found Captain Nemo: <br><br><img src="https://habrastorage.org/files/280/f4f/1dc/280f4f1dc434482aa5284d4763ba9fa7.png"><br><br>  What is going on?  Why does Postgres waste his time continuing to search, despite having already found the necessary data? <br><br>  The answer lies in the plan tree, in the Sort node.  Recall that to sort all users, ExecSort first loads all values ‚Äã‚Äãinto the buffer, repeatedly calling the subplan until the values ‚Äã‚Äãrun out.  This means that <i>ExecSeqScan will continue to scan to the end of the table</i> until it gathers all the appropriate users.  If our table contained thousands or even millions of records (imagine that we are working on Facebook or Twitter), ExecSeqScan would have to repeat the cycle for all user records and perform a comparison for each of them.  Obviously, this is slow and inefficient, and we will slow down more and more as new user records are added to the table. <br><br>  If we have only one entry about Captain Nemo, ExecSort "sorts" only this suitable entry, and ExecLimit will pass it through its offset / limit filter ... but only after ExecSeqScan passes through all the names. <br><br><h3>  <font color="#000000">Next</font> </h3><br>  How to solve this problem?  What if the execution of our SQL queries on the user table takes more and more time?  The answer is simple: we create an index. <br><br>  In the next and last post of this series, we will learn how to create indexes in Postgres and avoid using ExecSeqScan.  But most importantly, I'll show you what the postgres index looks like: how it works and why it speeds up requests like this. </div><p>Source: <a href="https://habr.com/ru/post/304258/">https://habr.com/ru/post/304258/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../304248/index.html">A working day on Wall Street: what hedge fund financial analysts actually do</a></li>
<li><a href="../304250/index.html">Databoom control panel. Work with collections. Part 2</a></li>
<li><a href="../304252/index.html">Central grid symmetry</a></li>
<li><a href="../304254/index.html">Examinations for admission to the "free" Master in the US</a></li>
<li><a href="../304256/index.html">Designing sites for people with dementia</a></li>
<li><a href="../304260/index.html">Google I / O 2016: WatchFace 2.0 - Complications</a></li>
<li><a href="../304262/index.html">The only way to get humanity out of the paws of the internet</a></li>
<li><a href="../304264/index.html">Dell Compellent Data Reduction Features</a></li>
<li><a href="../304268/index.html">Cinema on the map - find out the next film shows in the nearest cinemas</a></li>
<li><a href="../304270/index.html">Factor modeling based on the Verlet method</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>