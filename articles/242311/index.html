<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Captain America vs VirtualSurfaceImageSource</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Most of the time, developing under Windows Runtime brings incomparable pleasure. I did nothing at all: I put on controls, added a pinch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Captain America vs VirtualSurfaceImageSource</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="https://habrastorage.org/files/409/21f/c59/40921fc5962a4cc5b2d57069565a70d9.jpg"><br><h2>  Introduction </h2><br>  Most of the time, developing under Windows Runtime brings incomparable pleasure.  I did nothing at all: I put on controls, added a pinch of MVVM, and then you sit and admire your code.  This happens in 99% of cases.  In the remaining hundredth part, real dances with a tambourine begin. <br><br>  In fact, I am exaggerating, I resort to pagan rituals only in absolutely hopeless situations.  But WP developers have something to scold MS, starting at least with the <i>poor Silverlight developers, which accounted for all the misfortunes</i> .  Well, okay, it's all already gone offtopic. <br><br><h2>  Cap, where are you? </h2><br>  So, let's mentally transfer to a hypothetical situation.  We have an application, let it be a client for kinopoisk.ru under Windows 8.1.  And a poster of a Hollywood AAA project with a multi-million dollar budget and superheroes from our favorite comics.  The task is to display the poster to the user in perfect quality.  By the word ‚Äúperfect‚Äù I mean the correspondence <u>1 pixel of the image == 1 pixel physical</u> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It would seem a trifle, create an <font color="#2b91af">Image</font> and assign its desired Source <font color="#2b91af">BitmapImage</font> with a picture to its Source property.  That's just the size of the image is alarming - 9300 x 12300. Taking the calculator in hand, I start counting: 9300 * 12300 pixels * 4 B / pix = 436 MB.  A rather impressive figure, but in the 21st century you will not be surprised with such things.  The average desktop 2010 without problems digesting such amounts of data, so press F5 and enjoy your creation.  Everything works fine, at least on my computer, and all right.  On this article could finish ... <br><a name="habracut"></a><br><h2>  When the whole doorway got too narrow for us </h2><br><img src="https://habrastorage.org/files/46e/cc6/877/46ecc687761a4dfe9488d0032538ab35.png" align="right">  Well, then we mentally correct the TK.  Let our client kinopoisk.ru be a new-fashioned ‚ÄúUniversal Application‚Äù, i.e.  one application for both Windows and Windows Phone.  Well, I didn‚Äôt have to edit anything in the code, it was enough just to recompile.  Rolling up my sleeves, I run on my Lumia 920 and ... it immediately falls ... <br><br>  After a little zaguglivaniya, it turned out that on my lumiya (which has on board as much as 1 GB of memory) applications only have 390 MB <u>in which our picture clearly does not fit</u> .  Devices with 2 GB - so far not allowable, in my case, a luxury.  It is a pity, it is necessary to look for workarounds. <br><br><h2>  And what should I do now? </h2><br>  You say.  In general, there are some variants: <br><ol><li>  Shrink the picture to an acceptable size. </li><li>  Draw only visible part of the screen. </li></ol><br>  The first option immediately disappears, we will not sacrifice quality.  So go directly to the second.  Here we are again waiting for a crossroads: <br><ol><li>  Write everything yourself </li><li>  VirtualSurfaceImageSource </li></ol><br>  And then I remembered that a real programmer is primarily a lazy programmer.  So let's use the ready-made version, courtesy of Redmond developers.  In fact, <font color="#2b91af">VirtualSurfaceImageSource</font> has several advantages that could not have been achieved on our own with a bunch of XAML + C #, but we will leave all these goodies for later. <br><br><h2>  VirtualSurfaceImageSource - the same ‚Äúsilver bullet‚Äù </h2><br>  So, here we come to the ‚Äúnail‚Äù of our program today.  As I noted earlier, <font color="#2b91af">VirtualSurfaceImageSource</font> stores in memory only the visible part of the image.  This thing helps a lot if the application needs to display large amounts of data.  All of us face such applications all the time: maps (Bing Maps, HERE Maps), PDF Reader (which is in Windows 8.1), and even such cool ones as Internet Explorer, Word and Excel under Windows Phone use similar technology. <br><br>  The description turned out to be rather simplistic, although in fact the logic of <font color="#2b91af">VirtualSurfaceImageSource is</font> much more complicated, and under the hood it performs a lot of calculations and all sorts of different optimizations.  We should not worry about these details, all this is boring and uninteresting.  What matters is what we see outside. <br><br><img src="https://habrastorage.org/files/783/7e4/9a2/7837e49a26dc45f4a31b88d268cf9824.jpg"><br>  And for us, everything is very simple.  <font color="#2b91af">VirtualSurfaceImageSource</font> gives instructions on which parts of the image to redraw.  The rest of the work he takes on.  As indicated in the image above, we draw only the visible part of the image.  There is no need to <font color="#2b91af">count the</font> offset coordinates, <font color="#2b91af">VirtualSurfaceImageSource</font> calculates them for us.  Roughly speaking, the sequence of our actions is as follows: <br><br><ol><li>  We <font color="#2b91af">get IVirtualSurfaceImageSourceNative</font> </li><li>  Subscribe to render using RegisterForUpdatesNeeded </li><li>  When you call a callback draw the desired region </li></ol><br><br><div class="spoiler">  <b class="spoiler_title">Disclaimer!</b> <div class="spoiler_text">  And yes, I almost forgot to warn you - no C # will be here!  Yes, in such cases, you have to go out of your comfort zone.  But do not rush to close the tab, the key part of the article is applicable for Win2D.  The wrapper over VirtualSurfaceImageSource is already in the roadmap, so it remains to wait quite a bit.  Or you can make a pull request with your implementation.  I just plan to do this in the near future, so wait for updates! </div></div><br><br>  Everything looks very simple, it remains only to write the code.  We will draw using <i>Direct2D</i> , although in my case a banal copying of memory to Surface would be appropriate.  In order not to clutter up the solution with a dozen projects that we don‚Äôt need, I created the C ++ Blank App (Universal Application).  With the advent of C ++ / CX, interaction with C # code is reduced to a minimum of changes, <i>so in this article I will tactfully cover this topic</i> .  But if anyone is interested, write in the comments, I will gladly tell you! <br><br><h2>  Step 0: Preparatory </h2><br>  Once again, in this example I created the <u>C ++ Blank App (Universal Application)</u> .  For simplicity, all the code will be in the code-behind of the MainPage page. <br><br>  Since <font color="#2b91af">IVirtualSurfaceImageSourceNative is</font> not a Windows Runtime interface, you will need to include a special header file. <br><br><blockquote>  <font color="blue">#include</font> <font color="#a31515">&lt;windows.ui.xaml.media.dxinterop.h&gt;</font> <br></blockquote><br><br>  We declare all the fields and methods we need: <br><br><blockquote>  <font color="blue">public</font> <font color="blue">ref</font> <font color="blue">class</font> <font color="#2b91af">MainPage</font> <font color="blue">sealed</font> <br>  { <br>  <font color="blue">public</font> : <br>  MainPage (); <br>  <font color="blue">void</font> UpdatesNeeded (); <br><br>  <font color="blue">private</font> : <br>  <font color="green">// DirectX methods</font> <br>  <font color="blue">void</font> CreateDeviceResources (); <br>  <font color="blue">void</font> CreateDeviceIndependentResources (); <br>  <font color="blue">void</font> HandleDeviceLost (); <br><br>  <font color="green">// Creates VirtualSurfaceImageSource</font> <br>  <font color="green">// and set it to Image</font> <br>  <font color="blue">void</font> CreateVSIS (); <br><br>  <font color="green">// Draws the specified region</font> <br>  <font color="blue">void</font> RenderRegion ( <font color="blue">const</font> <font color="#2b91af">RECT</font> &amp; updateRect); <br><br>  <font color="blue">private</font> : <br>  <font color="blue">float</font> dpi; <br>  <font color="#2b91af">ComPtr</font> &lt; <font color="#2b91af">ID2D1Factory1</font> &gt; d2dFactory; <br>  <font color="#2b91af">ComPtr</font> &lt; <font color="#2b91af">ID2D1Device</font> &gt; d2dDevice; <br>  <font color="#2b91af">ComPtr</font> &lt; <font color="#2b91af">ID2D1DeviceContext</font> &gt; d2dDeviceContext; <br>  <font color="#2b91af">ComPtr</font> &lt; <font color="#2b91af">IDXGIDevice</font> &gt; dxgiDevice; <br><br>  <font color="green">// Our image</font> <br>  <font color="#2b91af">BitmapFrame</font> ^ bitmapFrame; <br>  <font color="green">// Link to this VirtualSurfaceImageSource</font> <br>  <font color="#2b91af">VirtualSurfaceImageSource</font> ^ vsis; <br>  <font color="green">// Link to IVirtualSurfaceImageSourceNative</font> <br>  <font color="#2b91af">ComPtr</font> &lt; <font color="#2b91af">IVirtualSurfaceImageSourceNative</font> &gt; vsisNative; <br>  }; </blockquote><br><br>  And the designer: <br><br><blockquote>  <font color="#2b91af">MainPage</font> :: MainPage () <br>  { <br>  InitializeComponent (); <br>  <font color="green">// Get the current DPI</font> <br>  dpi = <font color="#2b91af">DisplayInformation</font> :: GetForCurrentView () -&gt; LogicalDpi; <br>  CreateDeviceIndependentResources (); <br>  CreateDeviceResources (); <br>  CreateVSIS (); <br>  } </blockquote><br><br>  Comment here and not much of that, except that someone may confuse <font color="#2b91af">ComPtr &lt;T&gt;</font> .  <i>This is a regular smart pointer</i> , similar to <font color="#2b91af">shared_ptr &lt;T&gt;</font> , only for COM objects. <br><br>  In the future, I will use such a simple thing, which is very useful when debugging: <br><br><blockquote>  <font color="blue">namespace</font> DX <br>  { <br>  <font color="blue">inline</font> <font color="blue">void</font> ThrowIfFailed ( <font color="#6f008a">_In_</font> <font color="#2b91af">HRESULT</font> <font color="gray">hr</font> ) <br>  { <br>  <font color="blue">if</font> ( <font color="#6f008a">FAILED</font> ( <font color="gray">hr</font> )) <br>  { <br>  <font color="green">// Set a breakpoint on this line to catch DX API errors.</font> <br>  <font color="blue">throw</font> Platform :: <font color="#2b91af">Exception</font> :: CreateException ( <font color="gray">hr</font> ); <br>  } <br>  } <br>  } </blockquote><br><br><h2>  Step 1: Initialization routine </h2><br>  There is nothing interesting here, writing such hands is a non-Guusarian affair.  So I dragged off this code from the MS examples with minimal changes.  Comments are original. <br><br><blockquote> <font color="green">// Create device independent resources</font> <br>  <font color="blue">void</font> <font color="#2b91af">MainPage</font> :: CreateDeviceIndependentResources () <br>  { <br>  <font color="#2b91af">D2D1_FACTORY_OPTIONS</font> options; <br>  <font color="#6f008a">ZeroMemory</font> (&amp; options, <font color="blue">sizeof</font> ( <font color="#2b91af">D2D1_FACTORY_OPTIONS</font> )); <br><br>  <font color="blue">#if</font> <font color="blue">defined</font> ( <font color="#6f008a">_DEBUG</font> ) <br>  <font color="green">// If the project is a debug build, enable Direct2D debugging via Direct2D SDK layer.</font> <br>  <font color="green">// Enabling SDK</font> <br>  <font color="green">// resource leaking needs to be fixed during the development cycle.</font> <br>  options.debugLevel = <font color="darkslategray">D2D1_DEBUG_LEVEL_INFORMATION</font> ; <br>  <font color="blue">#endif</font> <br><br>  DX :: ThrowIfFailed ( <br>  D2D1CreateFactory ( <br>  <font color="darkslategray">D2D1_FACTORY_TYPE_SINGLE_THREADED</font> , <br>  <font color="blue">__uuidof</font> ( <font color="#2b91af">ID2D1Factory1</font> ), <br>  &amp; options, <br>  &amp; d2dFactory <br>  ) <br>  ); <br>  } <br>  <font color="green">// These resources depend on hardware.</font> <br>  <font color="blue">void</font> <font color="#2b91af">MainPage</font> :: CreateDeviceResources () <br>  { <br>  <font color="green">This flag adds support for a different default channel ordering than the default API.</font> <br>  <font color="green">// It is recommended usage, and is required for compatibility with Direct2D.</font> <br>  <font color="#2b91af">UINT</font> creationFlags = <font color="darkslategray">D3D11_CREATE_DEVICE_BGRA_SUPPORT</font> ; <br><br>  <font color="green">// This array will be supported by this feature.</font> <br>  <font color="green">// Note the ordering should be preserved.</font> <br>  <font color="#2b91af">D3D_FEATURE_LEVEL</font> featureLevels [] = <br>  { <br>  <font color="darkslategray">D3D_FEATURE_LEVEL_11_1</font> , <br>  <font color="darkslategray">D3D_FEATURE_LEVEL_11_0</font> , <br>  <font color="darkslategray">D3D_FEATURE_LEVEL_10_1</font> , <br>  <font color="darkslategray">D3D_FEATURE_LEVEL_10_0</font> , <br>  <font color="darkslategray">D3D_FEATURE_LEVEL_9_3</font> , <br>  <font color="darkslategray">D3D_FEATURE_LEVEL_9_2</font> , <br>  <font color="darkslategray">D3D_FEATURE_LEVEL_9_1</font> <br>  }; <br><br>  <font color="green">// Create the D3D11 API device object, and get a corresponding context.</font> <br>  <font color="#2b91af">ComPtr</font> &lt; <font color="#2b91af">ID3D11Device</font> &gt; d3dDevice; <br>  <font color="#2b91af">ComPtr</font> &lt; <font color="#2b91af">ID3D11DeviceContext</font> &gt; d3dContext; <br>  <font color="#2b91af">D3D_FEATURE_LEVEL</font> featureLevel; <br>  DX :: ThrowIfFailed ( <br>  D3D11CreateDevice ( <br>  <font color="blue">nullptr</font> , <font color="green">// specify null to use the default adapter</font> <br>  <font color="darkslategray">D3D_DRIVER_TYPE_HARDWARE</font> , <br>  0, <font color="green">// leave as 0 unless software device</font> <br>  creationFlags, <font color="green">// optionally set debug and Direct2D compatibility flags</font> <br>  featureLevels, <font color="green">// list of feature levels this app can support</font> <br>  <font color="#6f008a">ARRAYSIZE</font> (featureLevels), <font color="green">// number of entries in above list</font> <br>  <font color="#6f008a">D3D11_SDK_VERSION</font> , <font color="green">// always set this to D3D11_SDK_VERSION for Modern style apps</font> <br>  &amp; d3dDevice, <font color="green">// returns the Direct3D device created</font> <br>  &amp; featureLevel, <font color="green">// returns feature level of device created</font> <br>  &amp; d3dContext <font color="green">// returns the device immediate context</font> <br>  ) <br>  ); <br><br>  <font color="green">// Obtain the DXGI device of the Direct3D11.1 device.</font> <br>  DX :: ThrowIfFailed ( <br>  d3dDevice.As (&amp; dxgiDevice) <br>  ); <br><br>  <font color="green">// Obtain the Direct2D device for 2-D rendering.</font> <br>  DX :: ThrowIfFailed ( <br>  d2dFactory-&gt; CreateDevice (dxgiDevice.Get (), &amp; d2dDevice) <br>  ); <br><br>  <font color="green">// And get its corresponding device context object.</font> <br>  DX :: ThrowIfFailed ( <br>  d2dDevice-&gt; CreateDeviceContext ( <br>  <font color="darkslategray">D2D1_DEVICE_CONTEXT_OPTIONS_NONE</font> , <br>  &amp; d2dDeviceContext <br>  ) <br>  ); <br><br>  <font color="green">// Since this device was the surface image source,</font> <br>  <font color="green">// it needs to operate as pixels.</font>  <font color="green">Setting pixel unit mode</font> <br>  <font color="green">// ints, as in pixels.</font> <br>  d2dDeviceContext-&gt; SetUnitMode ( <font color="darkslategray">D2D1_UNIT_MODE_PIXELS</font> ); <br><br>  <font color="green">// Despite the fact that it is still very important to tell Direct2D</font> <br>  <font color="green">// the logical DPI the application operates on.</font>  <font color="green">Direct2D uses the DPI value as a hint to</font> <br>  <font color="green">// optimize internal rendering policy</font> <br>  <font color="green">// symmetric text rendering modes.</font>  <font color="green">Not specifying the appropriate DPI in this case will hurt</font> <br>  <font color="green">// application performance.</font> <br>  d2dDeviceContext-&gt; SetDpi (dpi, dpi); <br><br>  <font color="green">// When an application performs animation or image composition</font> <br>  <font color="green">// to use Direct2D grayscale text rendering mode rather than ClearType.</font>  <font color="green">The ClearType technique</font> <br>  <font color="green">// it doesn‚Äôt work</font> <br>  <font color="green">// image composition or sub-pixel animation of text.</font>  <font color="green">ClearType is still a method of choice when it</font> <br>  <font color="green">// comes with no further composition required.</font> <br>  d2dDeviceContext-&gt; SetTextAntialiasMode ( <font color="darkslategray">D2D1_TEXT_ANTIALIAS_MODE_GRAYSCALE</font> ); <br>  } </blockquote><br><br>  The only thing worth mentioning is SetUnitMode ().  According to the commentary, in principle, everything should be clear.  But do not forget to change the value to <font color="darkslategray">D2D1_UNIT_MODE_DIPS</font> if you draw Direct2D primitives or text.  In our case it will only interfere. <br><br><h2>  Step 2: Create VirtualSurfaceImageSource </h2><br>  This operation is reduced to just 3 actions: <br><br><blockquote>  <font color="green">// Create VirtualSurfaceImageSource</font> <br>  <font color="green">// We don‚Äôt need transparency, so isOpaque = false</font> <br>  vsis = <font color="blue">ref</font> <font color="blue">new</font> <font color="#2b91af">VirtualSurfaceImageSource</font> (bitmapFrame-&gt; PixelWidth, bitmapFrame-&gt; PixelHeight, <font color="blue">false</font> ); <br><br>  <font color="green">// Give VirtualSurfaceImageSource to IVirtualSurfaceImageSourceNative</font> <br>  DX :: ThrowIfFailed ( <br>  <font color="blue">reinterpret_cast</font> &lt; <font color="#2b91af">IInspectable</font> *&gt; (vsis) -&gt; QueryInterface ( <font color="#6f008a">IID_PPV_ARGS</font> (&amp; vsisNative)) <br>  ); <br><br>  <font color="green">// Install DXGI Device</font> <br>  DX :: ThrowIfFailed ( <br>  vsisNative-&gt; SetDevice (dxgiDevice.Get ()) <br>  ); </blockquote><br><br>  Now we need to create a callback object.  To do this, we will declare a new class that implements <font color="#2b91af">IVirtualSurfaceUpdatesCallbackNative</font> : <br><br><blockquote>  <font color="blue">class</font> <font color="#2b91af">VSISCallback</font> : <font color="blue">public</font> <font color="#2b91af">RuntimeClass</font> &lt; <font color="#2b91af">RuntimeClassFlags</font> &lt; <font color="darkslategray">ClassicCom</font> &gt;, <font color="#2b91af">IVirtualSurfaceUpdatesCallbackNative</font> &gt; <br>  { <br>  <font color="blue">public</font> : <br>  <font color="#2b91af">HRESULT</font> RuntimeClassInitialize ( <font color="#6f008a">_In_</font> <font color="#2b91af">WeakReference</font> <font color="gray">parameter</font> ) <br>  { <br>  reference = <font color="gray">parameter</font> ; <br>  <font color="blue">return</font> <font color="#6f008a">S_OK</font> ; <br>  } <br><br>  <font color="#6f008a">IFACEMETHODIMP</font> UpdatesNeeded () <br>  { <br>  <font color="green">// cast to MainPage ^</font> <br>  <font color="#2b91af">MainPage</font> ^ mainPage = reference.Resolve &lt; <font color="#2b91af">MainPage</font> &gt; (); <br>  <font color="green">// If mainPage is not deleted yet</font> <br>  <font color="blue">if</font> (mainPage! = <font color="blue">nullptr</font> ) <br>  { <br>  mainPage-&gt; UpdatesNeeded (); <br>  } <br>  <font color="blue">return</font> <font color="#6f008a">S_OK</font> ; <br>  } <br><br>  <font color="blue">private</font> : <br>  <font color="#2b91af">WeakReference</font> reference; <br>  }; </blockquote><br><br>  This callback will work if necessary to redraw the region.  Our implementation calls <font color="#2b91af">MainPage</font> :: UpdatesNeeded (), which does all the dirty work.  <font color="#2b91af">WeakReference is</font> needed to prevent memory leaks, in case we moved to another page, but forgot to unsubscribe our callback. <br><br>  It remains only to register this callback: <br><br><blockquote>  <font color="green">// Create an instance of VSISCallBack</font> <br>  <font color="#2b91af">WeakReference</font> parameter ( <font color="blue">this</font> ); <br>  <font color="#2b91af">ComPtr</font> &lt; <font color="#2b91af">VSISCallback</font> &gt; callback; <br>  DX :: ThrowIfFailed ( <br>  MakeAndInitialize &lt; <font color="#2b91af">VSISCallback</font> &gt; (&amp; callback, parameter) <br>  ); <br><br>  <font color="green">// Register callback</font> <br>  DX :: ThrowIfFailed ( <br>  vsisNative-&gt; RegisterForUpdatesNeeded (callback.Get ()) <br>  ); </blockquote><br><br><h2>  Step 3: Drawing </h2><br>  For a start, we‚Äôll get all the dirty regions.  After that we draw each of them: <br><br><blockquote>  <font color="blue">void</font> <font color="#2b91af">MainPage</font> :: UpdatesNeeded () <br>  { <br>  <font color="green">// Get the number of regions to be redrawn</font> <br>  <font color="#2b91af">DWORD</font> rectCount; <br>  DX :: ThrowIfFailed ( <br>  vsisNative-&gt; GetUpdateRectCount (&amp; rectCount) <br>  ); <br><br>  <font color="green">// Get the regions themselves</font> <br>  std :: <font color="#2b91af">unique_ptr</font> &lt; <font color="#2b91af">RECT</font> []&gt; updateRects ( <font color="blue">new</font> <font color="#2b91af">RECT</font> [rectCount]); <br>  DX :: ThrowIfFailed ( <br>  vsisNative-&gt; GetUpdateRects (updateRects.get (), rectCount) <br>  ); <br><br>  <font color="green">// Draw them</font> <br>  <font color="blue">for</font> ( <font color="#2b91af">ULONG</font> i = 0; i &lt;rectCount; ++ i) <br>  { <br>  RenderRegion (updateRects [i]); <br>  } <br>  } </blockquote><br><br>  Finally, we come to the long-awaited finale of our saga - drawing.  But first one little note. <br><br><img src="https://habrastorage.org/files/25c/3e8/407/25c3e84077524d5d91b15da6940fcb93.jpg"><br>  Let the red box be our current region.  For this region, <font color="#2b91af">invoking IVirtualSurfaceImageSourceNative</font> :: BeginDraw () will give us the desired Surface, and already on it we have to draw the entire area in the red rectangle.  At the end of the drawing call <font color="#2b91af">IVirtualSurfaceImageSourceNative</font> :: EndDraw (). <br><br>  What does this mean?  That Surface will only display the current region.  That is, the origin of this Surface will be in the upper left corner of our region, and we do not need to think about unnecessary transfers.  We cannot go beyond this region. <br><br>  In words it sounds a bit confusing, in practice everything becomes very clear, so let's get started: <br><br><blockquote>  <font color="blue">void</font> <font color="#2b91af">MainPage</font> :: RenderRegion ( <font color="blue">const</font> <font color="#2b91af">RECT</font> &amp; <font color="gray">updateRect</font> ) <br>  { <br>  <font color="green">// Surface, where we will draw</font> <br>  <font color="#2b91af">ComPtr</font> &lt; <font color="#2b91af">IDXGISurface</font> &gt; dxgiSurface; <br>  <font color="green">// Surface Offset</font> <br>  <font color="#2b91af">POINT</font> surfaceOffset = {0}; <br><br>  <font color="#2b91af">HRESULT</font> hr = vsisNative-&gt; BeginDraw ( <font color="gray">updateRect</font> , &amp; dxgiSurface, &amp; surfaceOffset); <br><br>  <font color="blue">if</font> ( <font color="#6f008a">SUCCEEDED</font> (hr)) <br>  { <br>  <font color="green">// Turn our Surface into a Bitmap, on which we will draw</font> <br>  <font color="#2b91af">ComPtr</font> &lt; <font color="#2b91af">ID2D1Bitmap1</font> &gt; targetBitmap; <br>  DX :: ThrowIfFailed ( <br>  d2dDeviceContext-&gt; CreateBitmapFromDxgiSurface ( <br>  dxgiSurface.Get (), <br>  <font color="blue">nullptr</font> , <br>  &amp; targetBitmap <br>  ) <br>  ); <br>  d2dDeviceContext-&gt; SetTarget (targetBitmap.Get ()); <br><br>  <font color="green">// Make the transfer to surfaceOffset</font> <br>  <font color="blue">auto</font> transform = D2D1 :: <font color="#2b91af">Matrix3x2F</font> :: Translation ( <br>  <font color="blue">static_cast</font> &lt; <font color="blue">float</font> &gt; (surfaceOffset.x), <br>  <font color="blue">static_cast</font> &lt; <font color="blue">float</font> &gt; (surfaceOffset.y) <br>  ); <br>  d2dDeviceContext-&gt; SetTransform (transform); <br><br>  <font color="green">// Draw Bitmap</font> <br>  d2dDeviceContext-&gt; BeginDraw (); <br><br>  <font color="green">// ********************</font> <br>  <font color="green">// TODO: Drawing Here</font> <br>  <font color="green">// ********************</font> <br><br>  DX :: ThrowIfFailed ( <br>  d2dDeviceContext-&gt; EndDraw () <br>  ); <br><br>  <font color="green">// Clean up after ourselves</font> <br>  d2dDeviceContext-&gt; SetTarget ( <font color="blue">nullptr</font> ); <br><br>  <font color="green">// Finish Draw</font> <br>  DX :: ThrowIfFailed ( <br>  vsisNative-&gt; EndDraw () <br>  ); <br>  } <br>  <font color="blue">else</font> <font color="blue">if</font> ((hr == <font color="#6f008a">DXGI_ERROR_DEVICE_REMOVED</font> ) || (hr == <font color="#6f008a">DXGI_ERROR_DEVICE_RESET</font> )) <br>  { <br>  <font color="green">// Handle device reset</font> <br>  HandleDeviceLost (); <br>  <font color="green">// Try again to draw updateRect</font> <br>  vsisNative-&gt; Invalidate ( <font color="gray">updateRect</font> ); <br>  } <br>  <font color="blue">else</font> <br>  { <br>  <font color="green">// Unknown error</font> <br>  DX :: ThrowIfFailed (hr); <br>  } <br>  } </blockquote><br><br>  Pay attention to the resulting surfaceOffset.  All our <u>artworks must be shifted to the surfaceoffset</u> .  This was done in order to increase productivity, although we should not worry about such details.  The easiest way to shift is the transformation matrix. <br><br>  In the case of a device reset (due to a driver failure or something else), re-create the device and mark the current region as ‚Äúdirty‚Äù using <font color="#2b91af">IVirtualSurfaceImageSourceNative</font> :: Invalidate ().  Thus, <font color="#2b91af">VirtualSurfaceImageSource will</font> redraw this region later. <br><br><h2>  1: 0 in favor of Cap </h2><br><img src="https://habrastorage.org/files/934/20e/b30/93420eb30646458dadcec0d6bb535f9f.jpg"><br>  <a href="https://github.com/eadordzhiev/VSISSample">The code for this example is on github.</a> <br><br>  So, having done a really hard way, I finally launch the application on my lumiya and ... very happy!  Alas, the first impression is always deceptive, and this case is no exception.  I was very upset, watching the unbearable lags with the swipe.  Yes, we have achieved our goal, but at what cost?  It‚Äôs impossible to lay out such an article in the Windows Store, <s>there‚Äôs no trash in it without it.</s> <br><br>  The reason for these lags, as always, is trivial - blocking the UI flow.  And if in the case of C # applications a bunch of async + await almost always saves, then in our case problems will arise with asynchrony. <br>  Observant readers immediately noticed "Part 1" in the title of this post.  And all because I did not cover many things.  For example, Trim, because of which this application will not pass certification in the Windows Store.  And most importantly - <u>drawing in a separate stream</u> .  Thus, we kill two birds with one stone: single-threaded trash in the example code and getting rid of terrible brakes when scrolling. <br><br>  That's all for today.  I wish you exciting coding and more happy users! </div><p>Source: <a href="https://habr.com/ru/post/242311/">https://habr.com/ru/post/242311/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../242297/index.html">Announcement Brackets 1.0 and Extract for Brackets (Preview version)</a></li>
<li><a href="../242301/index.html">Nexus 5 + javascript + 48 hours = touch surface?</a></li>
<li><a href="../242305/index.html">Data Types Strike Back</a></li>
<li><a href="../242307/index.html">Open Terminal Client OTC-110 - news "November 2014"</a></li>
<li><a href="../242309/index.html">Optimization for beginners, or the benefits of profiling</a></li>
<li><a href="../242313/index.html">ProductCamp Minsk 2014 - video and conference review</a></li>
<li><a href="../242315/index.html">Projector on the knee</a></li>
<li><a href="../242317/index.html">100 tricks for managing time, attention and energy</a></li>
<li><a href="../242319/index.html">ZeroNights 2014: hack and get</a></li>
<li><a href="../242323/index.html">Programming for beginners - an example of creating Morse code based on the visual system Snap!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>