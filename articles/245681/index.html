<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About easy navigation and debugging of C ++ code in Vim</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The company where I work develops software in C ++ for Linux. For a long time, we used Qt Creator, with rare guys working from Emacs and Vim. When I m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About easy navigation and debugging of C ++ code in Vim</h1><div class="post__text post__text-html js-mediator-article">  The company where I work develops software in C ++ for Linux.  For a long time, we used Qt Creator, with rare guys working from Emacs and Vim.  When I myself tried to transfer to Vim, I realized that the situation with plug-ins for C ++ development is not very simple.  After working a bit with CTags, I quickly realized that without a file, working in Vim would be very difficult. <br>  Unfortunately, with the growing experience with Vim, the editor in Qt Creator in emulation mode suited me less and at some point I decided to spend some time and figure out how to make Vim a normal environment. <br>  I outlined for myself four things that I would like from the development environment, and which I would have been enough in Vim to go completely into it: <br><br>  1. autocompletion <br>  2. Code Navigation <br>  3. Debugging directly from the environment <br>  4. Integration with Git (in particular, Blame right in the editor, and Git Grep) <br><br>  Autocompletion in Vim is a solved problem, and the name of the solution is <a href="https://github.com/Valloric/YouCompleteMe">YouCompleteMe</a> .  This is a very high-quality plugin that implements auto-completion for a large number of programming languages, in particular Python and C ++.  Rumor has it that inside Google YouCompleteMe solves the second problem with code navigation, but uses Google‚Äôs internal tools for indexing. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Integration with Git is to some extent solved by <a href="https://github.com/tpope/vim-fugitive">vim-fugitive</a> .  This is not as complex integration as Jet Brains, or in Visual Studio, but is comparable to what Qt Creator offers.  Those two scenarios that I needed: blame and grep - work well. <br><br>  Debugging and navigation were problems solved much worse.  In this article I will talk about the plugin that we wrote to navigate through C ++ code.  At the end of the article I will also talk about how we solved the problem with the integrated debugger for ourselves. <a name="habracut"></a><br><br>  Of course, as I mentioned above, CTags could be used for navigation, but if you worked with CTags, then you know that it does not solve the problem.  The C ++ parser is very weak, and often CTags find completely wrong parts of the code. <br><br>  On the Internet as a few years ago, and now, the only thing that is on the topic of navigation on C ++ code is <a href="http://blog.wuwon.id.au/2011/10/vim-plugin-for-navigating-c-with.html">this article</a> .  I set up this plugin, and it basically worked.  But there were many complaints, of which two are the biggest: <br>  1. The indexing process must be started by hand. <br>  2. It is impossible to find a symbol by its name. <br><br>  In the end, it all ended with the development of our own plugin for Vim, which allows you to navigate through C ++ code.  It requires the <a href="http://clang.llvm.org/docs/JSONCompilationDatabase.html">Compilation Database</a> .  If CMake is used in the project, it is enough to call it to get it. <br><br><pre><code class="bash hljs">cmake . -DCMAKE_EXPORT_COMPILE_COMMANDS=ON</code> </pre> <br><br>  Otherwise, you can either use <a href="https://github.com/rizsotto/Bear">Bear</a> , or build it with your hands, the format is very simple. <br><br>  The plugin is called <a href="https://github.com/SkidanovAlex/CtrlK">CtrlK</a> , and allows you to do the following things: <br><br>  1. Go to the definition of the character under the cursor. <br>  2. Search for all occurrences of the character under the cursor. <br>  3. Search for a symbol by its name (FuzzyFinder is used for this, but unfortunately, the search is not Fuzzy, but only by a substring).  The search works for functions, methods, classes, global variables, macros, and even function arguments and local variables. <br>  4. Displays the name of the function, inside which the cursor is located, in the status bar.  Very handy when editing large functions when its ad is off screen. <br><br>  In addition, there is an experimental ability to show a separate window in which the definition of the character under the cursor is constantly displayed.  I saw this opportunity only in the Source Insight environment, and its usefulness seems debatable, but I find it very convenient. <br><br>  The plugin uses libclang to parse the code and leveldb for the index. <br><br>  Like YouCompleteMe, the plugin consists of a server part and a client.  Here, the server part refers to a process that runs in parallel with Vim, and which communicates with Vim.  For installation, we went a little different way than YCM.  If YouCompleteMe asks you to run Make with your hands after installing via Vundle, we instead installed the server part via pip. <br>  At first it seemed that it was possible to write the entire plugin in Python, and not to do the server part, but the speed of parsing a large number of files through the clang library for python is very low, and I had to write it in C ++, which requires taking this functionality to a separate process and complicates the installation. <br><br>  As a result, the installation is reduced to the installation of the Python libraries clang, leveldb and the server part of ctrlk: <br><br><pre> <code class="bash hljs"> sudo pip install leveldb sudo pip install clang sudo pip install ctrlk</code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">(If sudo pip install ctrlk did not work)</b> <div class="spoiler_text">  Historically, the pip package for ctrlk does not belong to me.  There are two flaws in the current package - the dependence on ez_setup is not specified, it can be resolved by hand <br><br><pre> <code class="bash hljs"> sudo pip install ez_setup</code> </pre><br><br>  And there are no header files and clang libraries.  This is more likely to result in a compilation error, because the standard installation of clang / llvm does not put them where the compiler would find them without a hint. <br>  Both of these problems are resolved in the repository, but so far the pip package has not been updated.  If sudo pip install ctrlk fell with a compilation error, you can simply install it with your hands <br><br><pre> <code class="bash hljs"> git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/SkidanovAlex/py-ctrlk.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> py-ctrlk python setup.py build sudo python setup.py install</code> </pre><br></div></div><br><br>  Installing the plugin (as well as L9 and FuzzyFinder, on which CtrlK depends).  The easiest way to do this is to use <a href="">Vundle</a> : <br><br><pre> <code class="bash hljs"> Plugin <span class="hljs-string"><span class="hljs-string">'L9'</span></span> Plugin <span class="hljs-string"><span class="hljs-string">'FuzzyFinder'</span></span> Plugin <span class="hljs-string"><span class="hljs-string">'SkidanovAlex/CtrlK'</span></span></code> </pre><br><br>  And small settings in vimrc <br><br><pre> <code class="bash hljs"> <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> g:ctrlk_clang_library_path=<span class="hljs-string"><span class="hljs-string">"/home/user/llvm/lib"</span></span> nmap &lt;F3&gt; :call GetCtrlKState()&lt;CR&gt; nmap &lt;Ck&gt; :call CtrlKNavigateSymbols()&lt;CR&gt; nmap &lt;F2&gt; :call CtrlKGoToDefinition()&lt;CR&gt; nmap &lt;F12&gt; :call CtrlKGetReferences()&lt;CR&gt;</code> </pre><br><br>  Where g_ctrlk_clang_library_path should point to the path to libclang.so.  It can be found, for example, by running <br><br><pre> <code class="bash hljs">locate libclang.so</code> </pre><br><br>  After that, vim, launched from the compilation database directory (or any of its subdirectories), will start indexing the files, and after a while you can navigate through them.  F3 will show the current status of the parser, Ctrl + K opens FuzzyFinder where you can search for characters, F2 jumps to the definition of a character, and F12 shows all the places in the code where the character under the cursor is used. <br><br>  If you want the status bar to show the name of the current function, you can configure it, for example, like this: <br><br><pre> <code class="bash hljs"> hi User1 ctermbg=darkgreen ctermfg=black guibg=darkgreen guifg=black hi User2 ctermbg=gray ctermfg=black guibg=gray guifg=black hi User3 ctermbg=darkgray ctermfg=gray guibg=darkgray guifg=gray <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> statusline=%1*\ %{CtrlKGetCurrentScope()}\ %2*\ %F%m%r%h\ %w\ \ %3*\ %r%{getcwd()}%h%=%l:%c <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> laststatus=2</code> </pre><br><br>  Here are two examples of work.  In the first example, we launch Vim from the project folder, press Ctrl + K, and go to the file.  This is not a very good example, because you can go to a file simply by using Fuzzy Finder or CtrlP, but you can also go to any class or other symbol in CtrlK. <br><br><img src="https://habrastorage.org/files/8bb/691/6f3/8bb6916f31c149abb5e58f15c53dbfd2.gif"><br><br>  In the second example, we again use Ctrl + K to find the RestoreStartWorker function, position the cursor on the CodePrinter class in it, and find all references to this class in the code by pressing F12.  If we had pressed F2, then Vim would immediately jump to class definition. <br><br><img src="https://habrastorage.org/files/b9a/5d0/e9d/b9a5d0e9de264e03ac82235e5b3b9f9d.gif"><br><br>  In this example, there is a slight delay in finding all occurrences.  In fact, it works instantly, but after the first opening of any file, it takes 1-3 seconds to parse it, and before the parsing ends, the transition to the definition and search for entries does not work. <br><br>  In conclusion, a little about debugging.  There are several plugins for debugging, and they are all very bad.  I spent a few days, and still managed to install <a href="http://pyclewn.sourceforge.net/">PyClewn</a> and make it work.  PyClewn allows you to set breakpoints, look at local variables, monitor the output of a program directly from Vim, and allow you to enter commands for GDB.  This is much less convenient than integration with QtCreator, for example, or with any other fully-fledged development environment, but a little better than running GDB in a separate terminal.  PyClewn generally solved the problem, but wanted more. <br>  My colleague wrote a plugin for Vim that uses TMux to run GDB next to Vim on the same screen, and either manage it directly from Vim (for example, set breakpoints, watch the values ‚Äã‚Äãof variables), or switch to the GDB window and just work with GDB .  Local variables, or fields of objects, can be viewed as a tree in the nerd tree.  Unfortunately, the plugin has no documentation, but its installation is quite simple.  You need to install two plugins via Vundle, and then configure vimrc. <br><br><pre> <code class="bash hljs">Plugin <span class="hljs-string"><span class="hljs-string">'ManOfTeflon/exterminator'</span></span> Plugin <span class="hljs-string"><span class="hljs-string">'ManOfTeflon/nerdtree-json'</span></span></code> </pre><br><br>  If the standard nerdtree is already used, then it should be removed.  nerttree-json is a fork of nerdtree, which allows you to expand its capabilities, and do lazy-computing elements of the tree. <br><br>  Then here is an example of setting the exterminator from the plugin author: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span>! s:get_range() <span class="hljs-string"><span class="hljs-string">" Why is this not a built-in Vim script function?! let [lnum1, col1] = getpos("</span></span><span class="hljs-string"><span class="hljs-string">'&lt;")[1:2] let [lnum2, col2] = getpos("'</span></span>&gt;<span class="hljs-string"><span class="hljs-string">")[1:2] let lines = getline(lnum1, lnum2) let lines[-1] = lines[-1][: col2 - (&amp;selection == 'inclusive' ? 1 : 2)] let lines[0] = lines[0][col1 - 1:] return join(lines, "</span></span>\n<span class="hljs-string"><span class="hljs-string">") endfunction nnoremap &lt;silent&gt; &amp; :exec 'VimGrep ' . expand('&lt;cword&gt;')&lt;cr&gt; vnoremap &lt;silent&gt; &amp; :exec 'VimGrep ' . s:get_range() comm! -nargs=0 -range GdbVEval exec 'GdbEval ' . s:get_range() nnoremap &lt;silent&gt; &lt;F6&gt; :exec "</span></span>GdbEval <span class="hljs-string"><span class="hljs-string">" . expand("</span></span>&lt;cword&gt;<span class="hljs-string"><span class="hljs-string">")&lt;CR&gt; vnoremap &lt;silent&gt; &lt;F6&gt; :GdbVEval&lt;cr&gt; nnoremap &lt;silent&gt; &lt;F5&gt; :GdbLocals&lt;CR&gt; nnoremap &lt;silent&gt; &lt;F4&gt; :GdbNoTrack&lt;CR&gt; nnoremap &lt;silent&gt; &lt;Insert&gt; :GdbContinue&lt;cr&gt; nnoremap &lt;silent&gt; &lt;End&gt; :GdbBacktrace&lt;cr&gt; nnoremap &lt;silent&gt; &lt;Home&gt; :GdbUntil&lt;cr&gt; nnoremap &lt;silent&gt; &lt;S-Up&gt; :GdbExec finish&lt;cr&gt; nnoremap &lt;silent&gt; &lt;S-Down&gt; :GdbExec step&lt;cr&gt; nnoremap &lt;silent&gt; &lt;S-Right&gt; :GdbExec next&lt;cr&gt; nnoremap &lt;silent&gt; &lt;S-Left&gt; :GdbToggle&lt;cr&gt; noremap &lt;silent&gt; &lt;PageUp&gt; :GdbExec up&lt;cr&gt; noremap &lt;silent&gt; &lt;PageDown&gt; :GdbExec down&lt;cr&gt; function! s:start_debugging(cmd) cd </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$PATH_TO_EXECUTABLE</span></span></span><span class="hljs-string"> exec 'Dbg ' . a:cmd endfunction command! -nargs=1 DbgWrapper call s:start_debugging(&lt;f-args&gt;) nnoremap &lt;silent&gt; &lt;leader&gt;B :DbgWrapper ./executable&lt;cr&gt;</span></span></code> </pre><br><br>  Where $ PATH_TO_EXECUTABLE and ./executable are the path to the debugging program and its name. <br></div></div><br><br>  With this configuration, in Vim running from TMux, you can start debugging via \ B, as a result of which TMux splits the screen in two, and starts in the second GDB associated with Vim.  In particular, when moving through frames in GDB, Vim will show the code in the current frame, and from Vim you can use the hot keys to move through the frames, set breakpoints, execute the program step by step, and show the values ‚Äã‚Äãof variables in the nerdtree.  In particular, F5 will show the values ‚Äã‚Äãof all local variables, and F6 will show the variable under the cursor. <br><br>  The plugin code for navigating through C ++ and its server part is open and available on GitHub under the MIT License: <br>  <a href="https://github.com/SkidanovAlex/CtrlK">https://github.com/SkidanovAlex/CtrlK</a> <br>  <a href="https://github.com/SkidanovAlex/py-ctrlk">https://github.com/SkidanovAlex/py-ctrlk</a> <br><br>  The debug code of the plug-in is also open, and is available under the WTFPL license: <br>  <a href="https://github.com/ManOfTeflon/exterminator">https://github.com/ManOfTeflon/exterminator</a> </div><p>Source: <a href="https://habr.com/ru/post/245681/">https://habr.com/ru/post/245681/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../245669/index.html">New Year's Eve: once again about goal-setting</a></li>
<li><a href="../245671/index.html">Fake BLE device on nRF24l01</a></li>
<li><a href="../245673/index.html">All data on one screen: Experience integrating Kato messenger with IFTTT, Hubot and Stripe</a></li>
<li><a href="../245675/index.html">High Frequency Trading Neighborhood - Part IV</a></li>
<li><a href="../245677/index.html">How to download the latest Office from the Microsoft website without any App-V</a></li>
<li><a href="../245683/index.html">How to add Bing Maps to a Windows application in HTML and JavaScript. Part 1</a></li>
<li><a href="../245685/index.html">Dynamic Solution Check: Idle Brain and Situational Anxiety</a></li>
<li><a href="../245687/index.html">Which cycle is faster? We test 1C</a></li>
<li><a href="../245689/index.html">Fully own button "Select File"</a></li>
<li><a href="../245691/index.html">Vim FileStyle: check open file for compliance with Vim settings</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>