<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementation of disaster recovery</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sergey Burladyan (Avito) 


 Hello everyone, my name is Sergey Burladyan, I work at Avito as a database administrator. I work with such systems: 



 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementation of disaster recovery</h1><div class="post__text post__text-html js-mediator-article"><h2>  Sergey Burladyan (Avito) </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/f5e/27f/463/f5e27f463f8c2bcfd7c3a75c650ed92a.jpg" alt="Sergey Burladyan"><br><br>  Hello everyone, my name is Sergey Burladyan, I work at Avito as a database administrator.  I work with such systems: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/766/8e5/0c5/7668e50c5f350479004ad86b8f0ab6ba.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This is our central base of 2 TB, 4 servers - 1 master, 3 standby.  We also have logical replication based on londiste (this is from Skytools), external sphinx index, various uploads to external systems such as DWH, for example.  We also have our own developments in the field of a remote procedure call, the so-called xrpc.  Storage for 16 bases.  And another such figure is that our backup takes 6 hours, and its recovery is about 12 hours.  I would like that in the case of various accidents of these systems, the downtime of our site took no more than 10 minutes. <br><a name="habracut"></a><br>  If you try to present the various connections of these systems, they somehow look like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/756/454/4cd/7564544cdfd53aba91571aaa4096b6fc.png"><br><br>  And how not to lose all this in an accident? <br><br>  What could be the accident? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/411/c94/f64/411c94f64558253a5d985c6006d00da3.png"><br><br>  I consider, basically, server loss crashes, and a plus for the master may be another such crash as an explosion of data. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://player.vimeo.com/video/150095113" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Let's start. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/23b/60f/3fe/23b60f3fe476e4361690b2823324c231.png"><br><br>  Suppose some administrator mistakenly made an update without where.  We have had such a case several times.  How to protect against it?  We defend ourselves by the fact that we have a standby that applies WALs with a delay of 12 hours.  When such an accident occurred, we took this data from standby and downloaded it back to master. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4d8/9b4/c13/4d89b4c136de8cac7c954e151280d394.png"><br><br>  The second crash that can happen to the master is the loss of the server.  We use asynchronous replication and after losing the server, we have to promote some standby.  And since  Since our replication is asynchronous, we still need to perform various procedures to restore the connected systems.  Our master is central and is the source of data, respectively, if it switches and replication is asynchronous, then we lose part of the transaction, and it turns out that part of the system is in the unreachable future for the new master. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a2/b9d/53e/2a2b9d53e9a3616cdfb8a1f42c17e043.png"><br><br>  It‚Äôs all difficult to do with your hands, so you need to immediately make a script.  What does an accident look like?  In external systems, ads appear that are no longer on the master, sphinx gives out non-existent ads when searching, sequences were jumped back, logical replicas, in particular because of this, also stopped working (londiste). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/976/7e9/73c/9767e973c7bf8bae9d109a5961f4a1e0.png"><br><br>  But not everything is so bad, it can all be restored.  We sat, thought and planned the recovery procedure.  In particular, we can simply unload DWH again.  And directly, because  we have a simple 10 minutes, then on the monthly reports the change of these lost items is simply not visible. <br><br>  How to repair xrpc?  We use xrpc for geocoding, for calling asynchronous procedures on the master and for calculating the user's karma.  Accordingly, if we zheokodili something, i.e.  from the address they turned it into coordinates on the map, and then this address disappeared, then it's okay that it will remain zodiac, it‚Äôs just that we won‚Äôt geocode the same address a second time, respectively, we don‚Äôt need to restore anything.  The local procedure call is asynchronous, since  it is local, it is located on the same base server, even on the same base, and therefore, when we switch the base, it is consistent.  Also, nothing needs to be restored.  Karma user.  We decided that if a user did something bad, and then an accident occurred, and we lost these bad items, then the karma of users can also not be restored.  He did these bad things, let him stay. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7df/7b6/55a/7df7b655a18f188a5907ba23f873316e.png"><br><br>  Sphinx site.  We have two sphinx - one for the site, the other for backoffice.  Sphinx, which is the site, is implemented in such a way that it completely rebuilds its entire index every 10 minutes.  Accordingly, an accident occurred, recovered, and after 10 minutes the index is completely rebuilt and corresponds to the master.  And for backoffice, we decided that it‚Äôs not critical either, we can refrain some of the ads that have changed after recovery, and once a month we completely rebuild the whole sphinx backoffice, and all these emergency items will be cleaned. <br><br>  How to recover sequences so that they do not jump back?  We simply chose sequences that are important to us, such as item_id, user_id, the payment primary key, and after the accident we scroll them forward 100 thousand (we decided that it would be enough for us). <br><br>  We restore logical replication using our system, this is a patch for londiste, which makes UNDO for a logical replica. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fbf/a80/1dc/fbfa801dcc9b0aa16d51dd576e5711c6.png"><br><br>  Patch Undo - these are the three teams.  Directly the command itself and plus two commands add / remove Undo for a logical replica.  And the replay in londiste, we added a flag to transfer the TICK_ID from the master to the Postgres session variable. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0fb/8c6/867/0fb8c6867406f53ace15841ae261093e.png"><br><br>  This is needed directly in the Undo implementation itself, since  it is implemented - it's just triggers on all subscriber tables.  The trigger writes in the history plate, which directly the operation occurred.  In the target table.  This transmitted tick_id with the master he remembers in this record.  Accordingly, when the accident occurred, the logical replica turned out to be in the future, and it needs to be cleaned in order to recover changes that are from an unattainable future.  This is done by performing backward queries, i.e.  for insert we do delete, for update we update with the previous values, well, and for delete - insert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6d8/077/112/6d8077112a6f78ef02feb0913434b342.png"><br><br>  We do not do all this with our hands, we do it with the help of a script.  What is the feature of our script here?  We have three asynchronous standby, respectively, before switching, you need to find out which one is closest to the master.  Next, we select this standby, wait until it loses the remaining WALs from the archive, and select it for the future master.  Next, we use Postgres 9.2.  The features of this version are that in order for the standby to switch to the new promotion and the master, they have to be stopped.  In theory, at 9.4 it is already possible not to do it.  Accordingly, we do promote, we move the sequences ahead, we execute our Undo procedure, we run standby.  And then this is also an interesting moment - you need to wait for standby to connect to the new master.  We do this by waiting for the timeline of the new wizard to appear on the appropriate standby. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cd2/204/9e3/cd22049e3ccc3de6fe431f383c32ca4f.png"><br><br>  And so it turns out that in Postgres there is no such function for SQL, it is impossible to understand the timeline on standby.  But we solve it in this way, it turns out you can connect via Postgres replication protocol to standby, and there after the first command standby will report its red highlighted timeline. <br><br>  This is our master recovery script. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a6/1a6/d45/2a61a6d451d35ad70f3a32e3f9413f4f.png"><br><br>  Let's go further.  As we are restored directly, when some external systems fall apart.  For example, standby.  Since  we have three standby, as I said, we just take, switch to the remaining standby, if one of them falls.  As a last resort, even if we lose all standby, we can switch traffic to the master.  Part of the traffic will be lost here, but, in principle, the site will work.  There was still such a trick - at first I kept creating new standby from backup, then we got SSD servers, and I still continued to restore standby from backup.  Then it turned out that if you take from a backup, the recovery takes 12 hours, and if you just take pg_basebackup from any working standby, then it takes much less time.  If you have several standby, you can try to check it with you. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/981/837/9bb/9818379bb836858be1492caaa75184f9.png"><br><br>  If the sphinx site breaks down.  The Sphinx site we have written in such a way that it completely rebuilds the entire index, and the site sphinx is all active site ads.  Now all 30 or 35 million ads on the site are indexed by this system.  Indexing comes from a separate logical replica, it is specially prepared for indexing and is made so that everything is laid out in memory, and indexing happens very quickly, so we can do indexing every 10 minutes, completely from scratch.  Our logical replicas are pairwise.  And if we lose the replica, we switch to its reserve.  And if something happened to sphinx, then in 10 minutes it will be fully reindexed, and everything will be fine. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/52e/564/6d9/52e5646d9f8f2602d470d1eb61314cf0.png"><br><br>  How can restore export to DWH?  Suppose we exported something, an accident occurred at DWH, we lost some of the latest data.  Our DWH export goes through a separate logical replica, and the last four days are stored on this replica.  We can simply call the export script again with our hands and unload all this data.  Plus there is another archive in half a year.  Or, in extreme cases, because  we have several standby, we can take one of them, pause and reload, in general, all the data from the master in DWH. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a6/e08/d58/5a6e08d582cc93f11cf74f942f246d16.png"><br><br>  Hrpc is implemented on top of pgq (this is Skytools), and thanks to that we can do such tricky things.  Pgq is, in fact, just a table in the database, it stores events.  It looks something like the figure.  There is an event time and transaction id.  When we have restored the xrpc client, we can take and move back in this queue, and re-play those events that are not in the receiver. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/30c/8e9/f2e/30c8e9f2edfa470effecbb0c9119fbeb.png"><br><br>  Xdb - we have a repository of several databases.  16 bases are located on eight machines.  This storage is reserved as follows - just Postgres binary replication is configured from one machine to another.  Those.  the first car is reserved by standby on the second, the second on the third, respectively, the eighth on the first.  In addition, the playback of WALs, there is also a delay of four days, i.e., in fact, we have four days of backup of any of these nodes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5d3/c08/644/5d3c086443525ca75d3e8589b7f3bb96.png"><br><br>  Now I will tell you in detail about the replica of what it is.  The logical replica is built on the basis of Postgres capabilities; this is the view'ha on the master and the deferred trigger on the necessary tables.  For these triggers, a special function is triggered, which writes to a separate table.  It can be considered as a materialized view.  And further this label means londiste is replicated on a logical turnip. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c1f/00a/c73/c1f00ac736ba66f1de845418a28430e2.png"><br><br>  Directly it looks something like this, I will not dwell on this in detail. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/86f/fc0/150/86ffc0150531cc6e8f4715aca779b163.png"><br><br>  And the logical replica server itself, why is this, in general, necessary?  This is a separate server.  It is characterized by the fact that everything is in memory there, i.e.  shared_buffers of such size that all this plate and its indexes completely fit into it.  This allows for such logical replicas to handle a large load, in particular, for example, one turnip serves 7000 transactions per second and 1000 events are poured into the queue from the master.  Since  This logical replica is implemented by means of londiste and pgq, then there is a handy thing - tracking which transactions have already been lost on this logical replica.  And based on this thing, you can do such things as Undo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5f4/b2d/85e/5f4b2d85ef02cb893b6261a94d9b2160.png"><br><br>  I have already said that we have two replicas, we can recover by simply switching.  If one replica is lost, switch to the second.  This is possible because pgq allows multiple consumers to subscribe to one queue.  The turnip fell, and then we need to restore its copy.  If this is done simply by means of londiste, then it takes us 4 hours for the site turnip, 8 hours for the sphinx, because  there triggers are called, which cut the data for convenient indexing to the Sphinx, and this is all very long.  But it turned out that there is another way to create a fallen turnip - you can make pg_dump working. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f9e/4ec/21b/f9e4ec21bd8964cf576335cbc17d0c17.png"><br><br>  But if you simply make pg_dump and run londiste on it, then all this will not work, because londiste keeps track of the current position of the lost transaction on both the master and logical replica.  Therefore, there still need to take additional steps.  It is necessary to correct after restoring the dump on the tick_id master, so that it corresponds to the tick_id that is on the restored turnip.  If so, through pg_dump to copy, then all this takes no more than 15 minutes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e0e/9e2/8f2/e0e9e28f209913e0de935558757aa0f4.png"><br><br>  The algorithm itself looks something like this. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/196/330/dc2/196330dc2a8513bc24c895b769202c64.png"><br><br>  Backup is designed to protect against accidents, but directly with the backup itself, accidents can also occur.  For example, in Postgres, the WAL archiving command doesn‚Äôt say what fsynk needs to do when WAL is written to the archive.  But this is an important thing and allows you to protect against, say, an emergency reboot of the archive.  In addition, our backup is still backed up by the fact that it is backed up to an external cloud.  But in the plans: we want to make two active archive servers so that archive_command writes to both WAL.  We can also say that at first we experimented with pg_receivexlog for receiving directly on the WAL archive servers themselves, but it turned out that at 9.2 it is almost impossible to use it, because it does not do fsynk, does not track which WAL it already received from the master which can be cleaned at checkpoint.  Now in Postgres this is completed.  And, probably, in the future we will use not archive_command, but pg_receivexlog after all. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ba/f5c/387/4baf5c3870f9e6266bd05a521fd69b60.png"><br><br>  We do not use streaming at home.  Those.  what I was talking about is all based only on the WAL archive.  This was done due to the fact that it is difficult to ensure when streaming is also an archive, because  if, for example, we take an archive with standby, the backup is completed, and the master has not yet managed to archive all these WALs needed to restore the backup.  And we get a broken backup.  This can be circumvented if we have, say, standby, from which we take a backup, it is 12 hours behind, like ours.  Or - in Postgres 9.5, we made this setting archive_mode = always, in which there will be no such problem.  You can safely take a backup from standby and receive WALs directly from standby to the archive as well. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c56/2ad/49f/c562ad49f117a4e62234f180c036dcf9.png"><br><br>  It is not enough just to make a backup, it still needs to be checked to see if everything is correct there.  We do this on a test server, and for this we wrote a special backup check script.  It is based on what it checks after restoring the server and running error messages in the server log.  And for each database restored on the cluster, a special checking function check_backup is called, which performs additional checks.  In particular, such a check that the date of the last transaction should differ from the date of the last announcement by no more than a minute.  Those.  if there are no holes, we assume that the backup has been restored correctly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5d5/380/59b/5d538059b5fa093265b6863789ddeb7b.png"><br><br>  On the slides, you can see what specific errors we analyze in the log when checking the backup. <br><br>  Previously, we checked backups using vacuuming the entire database and reading the tables, but then we decided to refuse it, because we believe the restored backup still contains reports, and if the reports were calculated correctly, there are no holes, strange values, then the backup was done correctly . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f11/22e/dae/f1122edaef7dcf0fc0747e4d23d0abf6.png"><br><br>  I talked about asynchronous replication, but sometimes I want to make synchronous.  We have Avito consists of many services, one of these services is a payment service.  And due to the fact that it is selected, we can do synchronous replication for it, because  He works on a separate database.  There is not such a large load and standard network latency allows us to enable synchronous replication there. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e68/c88/b29/e68c88b2955371f4ab8c3bb029a70389.png"><br><br>  What can be said at the end?  Still, despite the fact that replication is synchronous, you can work and recover in this mode, if you look at your connected systems, you can think up and how they can be restored.  It is important to still test backups. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aba/24b/915/aba24b915b239048877f5cdcc9de5018.png"><br><br>  Another such remark.  We have a recovery script, at the end it is necessary to change the DNS, since  we have this master or slave - this is fixed in the DNS.  We are now thinking about using some type of ZooKeeper system to automatically switch DNS.  Such plans. <br><br><blockquote>  <font color="gray">This report is a transcript of one of the best speeches at the conference of developers of high-loaded <a href="http://highload.ru/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon">HighLoad ++</a> systems.</font>  <font color="gray">Now we are actively preparing for the conference in 2016 - this year HighLoad ++ will be held in Skolkovo on November 7 and 8.</font> <font color="gray"><br><br></font>  <font color="gray">The Avito team traditionally offers very strong performances, for example, this year it will be:</font> <font color="gray"><br></font> <ul><li>  <a href="http://www.highload.ru/2016/abstracts/2274.html">Experience of migration between data centers</a> / Mikhail Tyurin </li><li>  <a href="http://www.highload.ru/2016/abstracts/2273.html">Sphinx 3.0 and RT indexes on the Avito main search</a> / Andrey Smirnov, Vyacheslav Kryukov; </li></ul><br>  Also, some of these materials are used by us in an online training course on the development of high-load systems <a href="http://highload.guide/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon">HighLoad.Guide</a> is a chain of specially selected letters, articles, materials, videos.  Already, in our textbook more than 30 unique materials.  Get connected! </blockquote></div><p>Source: <a href="https://habr.com/ru/post/311472/">https://habr.com/ru/post/311472/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../311458/index.html">Top 10 Free SharePoint Apps from Microsoft Store</a></li>
<li><a href="../311460/index.html">What is big data, part 3</a></li>
<li><a href="../311462/index.html">FreeType 2.7 - excellent quality Linux fonts</a></li>
<li><a href="../311464/index.html">Site optimization. Diagnoses and treatments</a></li>
<li><a href="../311466/index.html">We do not just get a remote job, but we join a remote team and its culture.</a></li>
<li><a href="../311474/index.html">IBM helps Indians to learn in advance about weather disasters</a></li>
<li><a href="../311476/index.html">Paul Graham: The Other Side of "Masterpieces on Time"</a></li>
<li><a href="../311480/index.html">How to calculate permutations. Lecture in Yandex</a></li>
<li><a href="../311482/index.html">Happy together: Getting feedback from customers makes them loyal</a></li>
<li><a href="../311486/index.html">Why are successful games in China do not get popular in the West?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>