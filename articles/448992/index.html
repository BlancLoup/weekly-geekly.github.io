<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Universal and perfect hashing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We start the week with useful material dedicated to the launch of the course "Algorithms for Developers" . Enjoy your reading. 



 1. Overview 

 Has...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Universal and perfect hashing</h1><div class="post__text post__text-html js-mediator-article">  We start the week with useful material dedicated to the launch of the course <a href="https://otus.pw/52Rv/">"Algorithms for Developers"</a> .  Enjoy your reading. <br><br><img src="https://habrastorage.org/webt/na/5_/ja/na5_jaknhrabunnqxjqmc1yjtvi.png"><br><br>  <b>1. Overview</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Hashing is a great practical tool, with an interesting and subtle theory.  In addition to being used as a vocabulary data structure, hashing is also found in many different areas, including cryptography and complexity theory.  In this lecture, we describe two important concepts: universal hashing (also known as universal families of hash functions) and perfect hashing. <a name="habracut"></a><br><br>  The material covered in this lecture includes: <br><br><ul><li>  Formal statement and general idea of ‚Äã‚Äãhashing. </li><li>  Universal hashing. </li><li>  Perfect hashing. </li></ul><br>  <b>2. Introduction</b> <br><br>  We will look at the main problem with the dictionary that we discussed before and consider two versions: static and dynamic: <br><br><ul><li>  <i>Static</i> : given the many elements of S, we want to store it in such a way that you can quickly perform a search. </li><li>  For example, a fixed dictionary. </li><li>  <i>Dynamic</i> : here we have a sequence of requests for insertion, search, and possibly deletion.  We want to do it all efficiently. </li></ul><br>  For the first problem, we could use a sorted array and a binary search.  For the second, we could use a balanced search tree.  However, hashing provides an alternative approach, which is often the fastest and most convenient way to solve these problems.  For example, suppose you are writing a program for an AI search and want to store situations that you have already resolved (positions on the board or elements of the state space), so as not to repeat the same calculations when encountering them again.  Hashing provides an easy way to store such information.  There are also many applications in cryptography, networks, complexity theory. <br><br>  <b>3. Basics of Hashing</b> <br><br>  The formal setting for hashing is as follows. <br><br><ul><li>  The keys belong to some large set of U. (For example, imagine that U is a set of all strings with a length of no more than 80 ascii characters.) </li><li>  There are some set of keys S in U, which we actually need (the keys can be both static and dynamic).  Let N = | S |.  Imagine that N is much smaller than the size of U. For example, S is the set of names of students in a class that is much smaller than 12880. </li><li>  We will perform inserts and search using an array A of some size M and a <b>hash function</b> h: U ‚Üí {0, ..., M - 1}.  Given an element x, the idea of ‚Äã‚Äãhashing is that we want to store it in A [h (x)].  Note that if U were small (for example, 2-character strings), then you could just save x to A [x], as in block sorting.  The problem is that U is big, so we need a hash function. </li><li>  We need a method for resolving collisions.  A collision is when h (x) = h (y) for two different keys x and y.  In this chapter, we will handle collisions by defining each element of A as a linked list.  There are a number of other methods, but for the problems that we focus on here, this is the most suitable.  This method is called the chain method.  To insert an item, we simply place it at the top of the list.  If h is a good hash function, then we hope that the lists will be small. </li></ul><br>  One of the remarkable properties of hashing is that all dictionary operations are incredibly simple to implement.  To search for the key x, simply calculate the index i = h (x) and then go through the list in A [i] until you find it (or leave the list).  To insert, simply place a new item at the top of its list.  To delete, you just need to perform the delete operation in the linked list.  Now we come to the question: what do we need to achieve good performance? <br><br>  Desirable properties.  The main desirable properties for a good hashing scheme: <br><br><ol><li>  The keys are well spread out so that we do not have too many collisions, since collisions affect the time it takes to perform a search and delete. </li><li>  M = O (N): in particular, we would like our scheme to reach property (1) without the need for the table size M to be much larger than the number of elements N. </li><li>  The function h must be quickly calculated.  In our today's analysis, we will consider the time for calculating h (x) as a constant.  However, it is worth remembering that it should not be too complex, because it affects the overall execution time. </li></ol><br>  Given this, the search time for the element x is O (the list size is A [h (x)]).  The same is true for deletions.  Inserts take O (1) time, regardless of the length of the lists.  So we want to analyze how big these lists are. <br><br>  Basic intuition: one of the ways to distribute elements beautifully is to distribute them randomly.  Unfortunately, we cannot simply use a random number generator to decide where to send the next element, because then we can never find it again.  So, we want h to be something ‚Äúpseudo-random‚Äù in some formal sense. <br><br>  We will now set out some bad news, and then some good news. <br><br>  Statement 1 (Bad News) For any hash function h, if | U |  ‚â• (N ‚àí1) M +1, there is a set S of N elements that are all hashed in one place. <br><br>  Proof: according to the Dirichlet principle.  In particular, to consider the contraposition, if each location had at most N - 1 U elements hashing it, then U could have a size of at most M (N - 1). <br><br>  This is partly why hashing seems so mysterious - how can you say that hashing is good, if for any hash function you can think of ways to prevent it?  One answer is that there are a lot of simple hash functions that work well in practice for typical sets S. But what if we want to get a good guarantee of the worst case? <br><br>  Here's the key idea: let's use randomization in our design h, by analogy with the randomized quick sort.  (Needless to say, h is a deterministic function).  We show that for any sequence of insertion and search operations (we do not need to assume that the set of inserted elements of S is random), if we choose h in this probabilistic way, the performance of h in this sequence will be good in waiting.  Thus, this is the same guarantee as in randomized quicksort or traps.  In particular, this is the idea of ‚Äã‚Äãuniversal hashing. <br><br>  As soon as we develop this idea, we will use it for a particularly nice application called ‚Äúperfect hashing‚Äù. <br><br>  <b>4. Universal hashing</b> <br><br>  Definition 1. Randomized algorithm H for constructing hash functions h: U ‚Üí {1, ..., M} <br>  is universal if for all x! = y in U we have <br><br><img src="https://habrastorage.org/webt/bj/h3/hd/bjh3hdghlrhmfl-4mf6i3xybf14.png"><br><br>  We can also say that the set H of hash functions is a universal family of hash functions, if the procedure ‚Äúchoose h ‚àà H at random‚Äù is universal.  (Here we identify a set of functions with a uniform distribution over the set.) <br><br>  Theorem 2. If H is universal, then for any set S ‚äÜ U of size N, for any x ‚àà U (for example, which we could look for), if we build h randomly according to H, the expected number of collisions between x and others elements in S no more than N / M. <br><br>  Proof: every y ‚àà S (y! = X) has no more than 1 / M chance of colliding with x by the definition of ‚Äúuniversal‚Äù.  So, <br><br><ul><li>  Let Cxy = 1 if x and y collide, and 0 otherwise. </li><li>  Let Cx denote the total number of collisions for x.  So, Cx = Py‚ààS, y! = X Cxy. </li><li>  We know that E [Cxy] = Pr (x and y collide) ‚â§ 1 / M. </li><li>  Thus, by linearity, the expectation is E [Cx] = Py E [Cxy] &lt;N / M. </li></ul><br>  Now we get the following corollary. <br><br>  Corollary 3. If H is universal, then for any sequence of operations L insert, search and delete, in which there can be no more than M elements in the system at the same time, the expected total cost of L operations for random h ‚àà H is equal to O (L) (viewing time to calculate h as a constant). <br><br>  Proof: for any given operation in sequence, its expected cost is constant by Theorem 2, therefore the expected total cost of L operations is O (L) in linearity of expectation. <br><br>  The question is: can we actually build a universal H?  If not, then this is all pretty pointless.  Fortunately, the answer is yes. <br><br>  <i><b>4.1.</b></i>  <i><b>Creating a universal hash family: matrix method</b></i> <br><br>  Suppose the keys are u-bit in length.  Say, the size of the table M is equal to degree 2, so the index is the length of b-bits with M = 2b. <br><br>  What we will do is choose h as the random matrix 0/1 b-by-u and define h (x) = hx, where we add mod 2. These matrices are short and thick.  For example: <br><br><img src="https://habrastorage.org/webt/ly/q4/4k/lyq44kg-g4d8iloztroepglar9k.png"><br><br>  Statement 4. For x! = Y, Prh [h (x) = h (y)] = 1 / M = 1 / 2b. <br><br>  Proof: First, what does multiplying h by x mean?  We can think of this as adding some of the columns of h (doing vector addition mod 2), where 1 bit in x indicates which ones to add.  (for example, we added the 1st and 3rd columns h above) <br><br>  Now take an arbitrary pair of keys x, y such that x! = Y.  They should differ somewhere, so, let's say, they differ in the i-th coordinate, and for concreteness, say xi = 0 and yi = 1. Imagine that first we chose all h except the i-th column.  For the remaining samples of the ith column, h (x) is fixed.  However, each of the 2b different settings of the i-th column gives a different value of h (y) (in particular, each time we turn a bit in this column, we turn the corresponding bit in h (y)).  Thus, there is exactly a 1 / 2b chance that h (x) = h (y). <br><br>  There are other methods for constructing universal hash families, also based on multiplying prime numbers (see Section 6.1). <br><br>  The next question we will consider is: if we correct the set S, can we find the hash function h such that all searches will have constant time?  The answer is yes, and this leads to the topic of perfect hashing. <br><br>  <b>5. Perfect hashing</b> <br><br>  We say that the hash function is ideal for S if all searches occur in O (1).  Here are two ways to build perfect hash functions for a given set of S. <br><br>  <i><b>5.1 Method 1: Solution in O (N2) space</b></i> <br><br>  Let's say we want to have a table whose size is quadratic in size N of our dictionary S. Then here is a simple method for constructing an ideal hash function.  Let H be universal and M = N2.  Then just choose a random h from H and try it!  The assertion is that there is at least a 50% chance that she will not have collisions. <br><br>  Proposition 5. If H is universal and M = N2, then Prh‚àºH (no collisions in S) ‚â• 1/2. <br><br>  Evidence: <br><br>  ‚Ä¢ How many pairs (x, y) are there in S?  Answer: <img src="https://habrastorage.org/webt/1n/oh/w7/1nohw79oejhbrsciul36nklg4sq.png"><br>  ‚Ä¢ For each pair, the probability of their collision is ‚â§ 1 / M by definition universality. <br>  ‚Ä¢ So, Pr (there is a collision) ‚â§ <img src="https://habrastorage.org/webt/1n/oh/w7/1nohw79oejhbrsciul36nklg4sq.png">  / M &lt;1/2. <br><br>  It‚Äôs like the other side of the ‚Äúbirthday paradox‚Äù.  If the number of days is much more than the number of people in the square, then there is a reasonable chance that no couple will have the same birthday. <br><br>  So, we just choose a random h from H, and if there are any collisions, we simply choose a new h.  On average, we only need to do this twice.  Now, what if we want to use only the O (N) space? <br><br>  5.2 Method 2: Solution in O (N) space <br><br>  The question of whether you can achieve perfect hashing in O (N) space has been open for some time: ‚ÄúShould the tables be sorted?‚Äù.  That is, for a fixed set, you can get a constant search time only with linear space?  There was a series of more and more complex attempts, until finally it was solved using the good idea of ‚Äã‚Äãuniversal hash functions in a two-level scheme. <br><br>  The method consists in the following.  First we will hash into a table of size N using universal hashing.  This will lead to some collisions (unless we are lucky).  However, then we rehash each basket using method 1, squaring the size of the basket to get zero collisions.  Thus, the scheme is that we have the first level hash function h and the first level table A, and then the second level N hash functions h1, ..., hN and N of the second level table A1, ..., A.N ... To find the element x, we first calculate i = h (x), and then find the element in Ai [hi (x)].  (If you did this in practice, you could set the flag so that you take the second step only if there were actually collisions with the index i, and otherwise you would just put x in A [i], but let's let's not worry about it here.) <br><br>  Say, the hash function h hashes n elements S to location i.  We have already proved (by analyzing method 1) that we can find h1, ..., hN, so that the total space used in the secondary tables is Pi (ni) 2. It remains to show that we can find a first-level function h such that Pi (ni) 2 = O (N).  In fact, we show the following: <br><br>  Theorem 6. If we choose the starting point h from the universal set H, then <br><br><pre><code class="plaintext hljs">Pr[X i (ni)2 &gt; 4N] &lt; 1/2.</code> </pre> <br>  Evidence.  We prove this by showing that E [Pi (ni) 2] &lt;2N.  This implies what we want from Markov's inequality.  (If there was even a probability of 1/2 that the amount could be more than 4N, then this fact in itself would mean that the expectation should have been more than 2N. Thus, if the expectation is less than 2N, the probability of failure should be less 1/2.) <br><br>  Now, the tricky trick is that one of the ways to calculate this number is to count the number of ordered pairs that have collisions, including collisions with themselves.  For example, if the basket has {d, e, f}, then d will have a collision with each of {d, e, f}, e will have a collision with each of {d, e, f}, and f will have a conflict with each of {d, e, f}, so we get 9. So, we have: <br><br><pre> <code class="plaintext hljs">E[X i (ni)2] = E[X x X y Cxy] (Cxy = 1 if x and y collide, else Cxy = 0) = N +X x X y6=x E[Cxy] ‚â§ N + N(N ‚àí 1)/M (where the 1/M comes from the definition of universal) &lt; 2N. (since M = N)</code> </pre><br>  So, we simply try a random h from H until we find such that Pi n2 i &lt;4N, and then, fixing this function h, we find N secondary hash functions h1, ..., hN as in method 1. <br><br>  <b>6. Further discussion</b> <br><br>  <i><b>6.1 Another universal hashing method</b></i> <br><br>  Here is another method for constructing universal hash functions, which is slightly more efficient than the matrix method given earlier. <br><br>  In the matrix method, we considered the key as a vector of bits.  In this method, instead, we will consider the key x as a vector of integers [x1, x2, ..., xk] with the only requirement that each xi be in the range {0, 1, ..., M-1}.  For example, if we hash strings of length k, then xi may be the i-th character (if the size of our table is at least 256) or the i-th pair of characters (if the size of our table is at least 65536).  In addition, we will require that the size of our table M is a prime number.  To choose the hash function h, we will select k random numbers r1, r2, ..., pk from {0, 1, ..., M - 1} and determine: <br><br><pre> <code class="plaintext hljs">h(x) = r1x1 + r2x2 + . . . + rkxk mod M.</code> </pre> <br>  The proof that this method is universal is constructed in the same way as the proof of the matrix method.  Let x and y be two different keys.  We want to show that Prh (h (x) = h (y)) ‚â§ 1 / M. Since x! = Y, there must be a case when there exists some index i such that xi! = Yi.  Now imagine that you first selected all random numbers rj for j! = I.  Let h ‚Ä≤ (x) = Pj6 = i rjxj.  So, choosing ri, we get h (x) = h ‚Ä≤ (x) + rixi.  This means that we have a collision between x and y precisely when <br><br><pre> <code class="plaintext hljs">h‚Ä≤(x) + rixi = h‚Ä≤(y) + riyi mod M, or equivalently when ri(xi ‚àí yi) = h‚Ä≤(y) ‚àí h‚Ä≤(x) mod M.</code> </pre> <br>  Since M is simple, division by a non-zero value mod M is valid (every integer from 1 to M ‚àí1 has a multiplicative inverse modulo M), which means that there is exactly one value ri modulo M for which the above equation true, namely ri = (h (y) - h (x)) / (xi - yi) mod M. Thus, the probability of this occurrence is exactly 1 / M. <br><br>  <b><i>6.2 Other uses of hashing</i></b> <br><br>  Suppose we have a long sequence of elements, and we want to see how many different elements are in the list.  Is there a good way to do this? <br><br>  One way is to create a hash table, and then make one pass through the sequence, making a search for each element and then inserting it if it is not already in the table.  The number of individual elements is simply the number of inserts. <br><br>  And now that if the list is really huge and we do not have a place to store it, but an approximate answer will suit us.  For example, imagine that we are a router and observe how many packets pass, and we want (approximately) to see how many different source IP addresses exist. <br><br>  Here's a good idea: let's say we have a hash function h, which behaves like a random function, and let's imagine that h (x) is a real number from 0 to 1. One thing we can do is just keep track of the minimum The hash cost has been generated so far (so we won't have a table at all).  For example, if the keys are 3, 10, 3, 3, 12, 10, 12 and h (3) = 0.4, h (10) = 0.2, h (12) = 0.7, then we get 0, 2 <br><br>  The fact is that if we choose N random numbers in [0, 1], the expected minimum value will be 1 / (N + 1).  In addition, there is a good chance that it is pretty close (we can improve our estimate by running several hash functions and taking the median of the minima). <br><br>  Question: why use a hash function, and not just choose a random number every time?  This is because we care about the number of different elements, not just the total number of elements (the problem is much simpler: just use the counter ...). <br><br>  Friends, was this article helpful to you?  Write in the comments and join the <a href="https://otus.ru/lessons/algorithm/%3Futm_source%3Dhabr%26utm_medium%3Daffilate%26utm_campaign%3Dalgo%26utm_term%3Dprofi23.04.2019">open day</a> , which will be held on April 25th. </div><p>Source: <a href="https://habr.com/ru/post/448992/">https://habr.com/ru/post/448992/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448976/index.html">Spring activities on game dev in VSBI</a></li>
<li><a href="../448980/index.html">Our first lunch together: why and how we spend a test day</a></li>
<li><a href="../448982/index.html">Headless CMS. Why i write my</a></li>
<li><a href="../448986/index.html">Reverse engineering in production using 3D scanning</a></li>
<li><a href="../448988/index.html">Kingston SSDs have become more capacious, retaining almost the same price - we meet A400-R series</a></li>
<li><a href="../448994/index.html">Is it so difficult to start the way of IT-recruiter?</a></li>
<li><a href="../448996/index.html">Creating a password policy in Linux</a></li>
<li><a href="../448998/index.html">If the bond is just tin, then you need to bury it.</a></li>
<li><a href="../449002/index.html">Formal verification using the wolf, goat and cabbage problem</a></li>
<li><a href="../449004/index.html">New in certification of information security tools</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>