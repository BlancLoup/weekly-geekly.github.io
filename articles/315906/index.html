<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SPDK: Acceleration with NVMe Disks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The SPDK (Storage Performance Developer Kit) is a set of open source tools and libraries that are designed to facilitate the development of high-perfo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SPDK: Acceleration with NVMe Disks</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://habrahabr.ru/company/intel/blog/270713/">The SPDK</a> (Storage Performance Developer Kit) is a set of <a href="https://github.com/spdk/spdk">open source</a> tools and libraries that are designed to facilitate the development of high-performance, scalable applications focused on interaction with disk drives.  In this article we will focus on the NVMe driver available in the SPDK operating in the Linux user space, and also consider the implementation of the Hello World example application on the Intel platform. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/9f5/8f0/ccc/9f58f0ccc70b402385fa766d18dd18eb.png"></div><br><a name="habracut"></a><br>  In our experiments, the server is based on the Intel C610 chipset (C1 stepping, system bus QPI, 9.6 GT / s) with two sockets, which are equipped with 12-core Intel Xeon E5-2697 processors (clock frequency - 2.7 GHz, 24 logical cores Ht).  The configuration of the RAM - 8x8 GB (Samsung M393B1G73BH0 DDR3 1866).  The system has an <a href="http://ark.intel.com/products/79624/Intel-SSD-DC-P3700-Series-400GB-12-Height-PCIe-3_0-20nm-MLC">Intel SSD DC P3700 Series</a> solid-state drive.  The operating system used is CentOS 7.2.1511 (kernel 3.10.0). <br><br><h2>  <font color="#0071c5">Why do we need NVMe-driver working in the user space of Linux?</font> </h2><br>  Historically, disk drives are orders of magnitude slower than other components of computer systems, such as memory and processor.  This means that the operating system and processor are forced to interact with the disks using the interrupt mechanism.  For example, a session of such an interaction might look like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  A request is made to the OS to read data from the disk. </li><li>  The driver processes this request and communicates with the hardware. </li><li>  The disc plate is unwound. </li><li>  The read / write head moves to the desired part of the plate, preparing to start reading the data. </li><li>  Data is read and written to the buffer. </li><li>  An interrupt is generated, which notifies the processor that the data is ready for use in the system. </li><li>  Finally, data is read from the buffer. </li></ol><br>  The interrupt model creates an additional load on the system.  However, usually this load was significantly less than the delays characteristic of conventional hard drives.  As a result, this additional load was not paid much attention, since it could not noticeably reduce the efficiency of the storage subsystems. <br><br>  Nowadays, SSDs and next-generation technologies, such as <a href="http://www.intel.com/content/www/us/en/architecture-and-technology/non-volatile-memory.html">3D XPoint</a> storage, are much faster than traditional HDDs.  As a result, the bottleneck of data storage subsystems, which used to be hardware, has moved into the sphere of software mechanisms.  Now, as can be seen in the figure below, the delays that contribute to the process of working with drives interrupt and the operating system, in comparison with the speed of response of drives, look very significant. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c70/db9/7c3/c70db97c3e20b5a7d3078df3e32e56f4.jpg"></div><br>  <i><font color="#999999">SSD-drives and storage systems based on 3D XPoint technology work much faster than traditional HDDs.</font></i>  <i><font color="#999999">As a result, software has now become a bottleneck in storage subsystems</font></i> <br><br>  The NVMe driver, which works in Linux user space, solves the ‚Äúinterrupt problem‚Äù.  Instead of waiting for an operation completion message, it interrogates the storage device as it reads or writes.  In addition, and this is very important, the NVMe driver works inside user space.  This means that applications can directly interact with the NVMe device, bypassing the Linux kernel.  One advantage of this approach is getting rid of system calls that require context switching.  This leads to an additional load on the system.  The NVMe architecture does not provide locks; this is intended not to use processor mechanisms to synchronize data between threads.  The same approach provides for parallel execution of input-output commands. <br><br>  Comparing the NVMe user-space driver from the SPDK with the approach of using the Linux kernel, it can be found that when using the NVMe-driver, the delays caused by the additional load on the system are reduced by about 10 times. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dda/644/db4/dda644db4c7ef93374643853784c0b6b.jpg"></div><br>  <i><font color="#999999">Delays, in nanoseconds, caused when using the Linux kernel and SPDK mechanisms for working with drives</font></i> <br><br>  The SPDK can, using one processor core, serve 8 NVMe solid-state drives, which gives more than 3.5 million IOPs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b41/d7e/2fa/b41d7e2faa82bdaa1aaac140051b1892.jpg"></div><br>  <i><font color="#999999">Changing I / O performance when working with different numbers of SSDs using Linux kernel and SPDK mechanisms</font></i> <br><br><h2>  <font color="#0071c5">Prerequisites and SPDK Assembly</font> </h2><br>  SPDK supports operating systems such as Fedora, CentOS, Ubuntu, Debian, FreeBSD.  A complete list of packages required for SPDK can be found <a href="https://github.com/spdk/spdk">here</a> . <br><br>  Before collecting the SPDK, you need to install the <a href="http://dpdk.org/">DPDK</a> (Data Plane Development Kit), since the SPDK relies on the memory management capabilities and the work with the queues that already exist in the DPDK.  DPDK is a mature library that is commonly used to process network packets.  It is well optimized for memory management and fast data queuing. <br><br>  The SPDK source code can be cloned from the GitHub repository with the following command: <br><br><pre><code class="hljs php">git <span class="hljs-keyword"><span class="hljs-keyword">clone</span></span> https:<span class="hljs-comment"><span class="hljs-comment">//github.com/spdk/spdk.git</span></span></code> </pre> <br><h3>  <font color="#0071c5">‚ñç Building DPDK (for Linux)</font> </h3><br><pre> <code class="hljs dos"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /<span class="hljs-built_in"><span class="hljs-built_in">path</span></span>/to/build/spdk wget http://fast.dpdk.org/rel/dpdk-<span class="hljs-number"><span class="hljs-number">16</span></span>.<span class="hljs-number"><span class="hljs-number">07</span></span>.tar.xz tar xf dpdk-<span class="hljs-number"><span class="hljs-number">16</span></span>.<span class="hljs-number"><span class="hljs-number">07</span></span>.tar.xz <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> dpdk-<span class="hljs-number"><span class="hljs-number">16</span></span>.<span class="hljs-number"><span class="hljs-number">07</span></span> &amp;&amp; make install T=x86_64-native-linuxapp-gcc DESTDIR=.</code> </pre> <br><h3>  <font color="#0071c5">‚ñç Build SPDK (for Linux)</font> </h3><br>  After the compiled DPDK is in the SPDK folder, we need to go back to this directory and compile the SPDK, passing make path to the DPDK. <br><br><pre> <code class="hljs pgsql">cd /<span class="hljs-type"><span class="hljs-type">path</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>/build/spdk make DPDK_DIR=./dpdk<span class="hljs-number"><span class="hljs-number">-16.07</span></span>/x86_64-native-linuxapp-gcc</code> </pre> <br><h3>  <font color="#0071c5">‚ñçSetting up the system before running the SPDK application</font> </h3><br>  The following command allows you to enable the use of large memory pages (hugepages) and unlink any NVMe and I / OAT devices from the kernel drivers. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sudo</span></span> scripts/setup.sh</code> </pre> <br>  The use of large pages is important for performance, as they are 2 MB in size.  This is much more than standard 4 Kb pages.  Due to the increased size of memory pages, the probability of a miss in the associative translation buffer (Translate Lookaside Buffer, TLB) is reduced.  TLB is a component inside the processor that is responsible for translating virtual addresses into physical memory addresses.  Thus, working with large pages leads to a more efficient use of TLB. <br><br><h2>  <font color="#0071c5">Hello World sample application</font> </h2><br>  There are many <a href="https://github.com/spdk/spdk/tree/master/examples">examples</a> included in the SPDK, and there is quality <a href="http://www.spdk.io/spdk/doc/">documentation here</a> .  All this allows you to quickly get started.  We will look at an example in which the phrase ‚ÄúHello World‚Äù is first saved on the NVMe device, and then read back to the buffer. <br><br>  Before you get into the code, you should talk about how the NVMe devices are structured and give an example of how the NVMe driver will use this information to locate devices, write data, and then read it. <br><br>  The NVMe device (also called the NVMe controller) is structured based on the following considerations: <br><br><ul><li>  One or several NVMe devices may be present in the system. </li><li>  Each NVMe device consists of a number of namespaces (it can be only one in this case). </li><li>  Each namespace consists of a number of addresses of logical blocks (Logical Block Addresses, LBA). </li></ul><br>  Now we will start our step by step example. <br><br><h3>  <font color="#0071c5">‚ñçSetting</font> </h3><br><ol><li>  Initialize the environment abstraction layer (EAL) abstraction layer.  In the code below, <code>-c</code> is a bitmask that serves to select the cores on which the code will be executed.  <code>‚Äìn</code> is the kernel ID, and <code>--proc-type</code> is the directory where the hugetlbfs file system will be mounted. <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ealargs[] = {        <span class="hljs-string"><span class="hljs-string">"hello_world"</span></span>,        <span class="hljs-string"><span class="hljs-string">"-c 0x1"</span></span>,        <span class="hljs-string"><span class="hljs-string">"-n 4"</span></span>,        <span class="hljs-string"><span class="hljs-string">"--proc-type=auto"</span></span>, }; rte_eal_init(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ealargs) / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ealargs[<span class="hljs-number"><span class="hljs-number">0</span></span>]), ealargs);</code> </pre> <br></li><li>  Create a query buffer pool that is used inside the SPDK to store the data of each I / O request. <br><br><pre> <code class="hljs objectivec">request_mempool = rte_mempool_create(<span class="hljs-string"><span class="hljs-string">"nvme_request"</span></span>, <span class="hljs-number"><span class="hljs-number">8192</span></span>,         spdk_nvme_request_size(), <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>,         <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>,         SOCKET_ID_ANY, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br></li><li>  Check the system for the presence of NVMe devices. <br><br><pre> <code class="hljs objectivec">rc = spdk_nvme_probe(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, probe_cb, attach_cb, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br></li><li>  We list the NVMe devices, returning a SPDK boolean value indicating whether the device should be attached. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">probe_cb</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cb_ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params"> spdk_pci_device *dev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params"> spdk_nvme_ctrlr_opts *opts</span></span></span><span class="hljs-function">)</span></span> {    printf(<span class="hljs-string"><span class="hljs-string">"Attaching to %04x:%02x:%02x.%02x\n"</span></span>,    spdk_pci_device_get_domain(dev),    spdk_pci_device_get_bus(dev),    spdk_pci_device_get_dev(dev),    spdk_pci_device_get_func(dev));    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br></li><li>  The device is attached.  Now you can request data on the number of namespaces. <br><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> void attach_cb(void *cb_ctx, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">spdk_pci_device</span></span></span></span> *dev, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">spdk_nvme_ctrlr</span></span></span></span> *ctrlr, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">spdk_nvme_ctrlr_opts</span></span></span></span> *opts) {   int nsid, num_ns; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">spdk_nvme_ctrlr_data</span></span></span></span> *cdata = spdk_nvme_ctrlr_get_data(ctrlr); printf(<span class="hljs-string"><span class="hljs-string">"Attached to %04x:%02x:%02x.%02x\n"</span></span>,      spdk_pci_device_get_domain(dev),      spdk_pci_device_get_bus(dev),      spdk_pci_device_get_dev(dev),      spdk_pci_device_get_func(dev)); snprintf(entry-&gt;name, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(entry-&gt;name), <span class="hljs-string"><span class="hljs-string">"%-20.20s (%-20.20s)"</span></span>, cdata-&gt;mn, cdata-&gt;sn); num_ns = spdk_nvme_ctrlr_get_num_ns(ctrlr); printf(<span class="hljs-string"><span class="hljs-string">"Using controller %s with %d namespaces.\n"</span></span>, entry-&gt;name, num_ns); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (nsid = <span class="hljs-number"><span class="hljs-number">1</span></span>; nsid &lt;= num_ns; nsid++) { register_ns(ctrlr, spdk_nvme_ctrlr_get_ns(ctrlr, nsid)); } }</code> </pre> <br></li><li>  We list the namespaces in order to get information about them, for example, such as size. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register_ns</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params"> spdk_nvme_ctrlr *ctrlr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params"> spdk_nvme_ns *ns</span></span></span><span class="hljs-function">)</span></span> { printf(<span class="hljs-string"><span class="hljs-string">"  Namespace ID: %d size: %juGB\n"</span></span>, spdk_nvme_ns_get_id(ns),   spdk_nvme_ns_get_size(ns) / <span class="hljs-number"><span class="hljs-number">1000000000</span></span>); }</code> </pre><br></li><li>  Create a queue pair of input / output to send a read / write request to the namespace. <br><br><pre> <code class="hljs lisp">ns_entry-&gt;qpair = spdk_nvme_ctrlr_alloc_io_qpair(<span class="hljs-name"><span class="hljs-name">ns_entry-&gt;ctrlr</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> </li></ol><br><h3>  <font color="#0071c5">‚ñçRead / write data</font> </h3><br><ol><li>  Allocate a buffer for the data to be read / written. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">sequence</span></span>.buf = rte_zmalloc(<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0x1000</span></span>, <span class="hljs-number"><span class="hljs-number">0x1000</span></span>);</code> </pre> <br></li><li>  Copy the string ‚ÄúHello World‚Äù to the clipboard. <br><br><pre> <code class="hljs lisp">sprintf(<span class="hljs-name"><span class="hljs-name">sequence</span></span>.buf, <span class="hljs-string"><span class="hljs-string">"Hello world!\n"</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br></li><li>  Send a write request to the specified namespace, providing a pair of queues, a pointer to a buffer, an LBA index, a callback function that will work after the data has been written, and a pointer to the data that must be passed to the callback function. <br><br><pre> <code class="hljs pgsql">rc = spdk_nvme_ns_cmd_write(ns_entry-&gt;ns, ns_entry-&gt;qpair, <span class="hljs-keyword"><span class="hljs-keyword">sequence</span></span>.buf,   <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*  LBA */</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span>  write_complete, &amp;<span class="hljs-keyword"><span class="hljs-keyword">sequence</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br></li><li>  The callback function, after the completion of the write process, will be called synchronously. <br><br></li><li>  Send a read request to the specified namespace, providing the same set of service data that was used for the write request. <br><br><pre> <code class="hljs pgsql">rc = spdk_nvme_ns_cmd_read(ns_entry-&gt;ns, ns_entry-&gt;qpair, <span class="hljs-keyword"><span class="hljs-keyword">sequence</span></span>-&gt;buf,      <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* LBA start */</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* number of LBAs */</span></span>      read_complete, (<span class="hljs-type"><span class="hljs-type">void</span></span> *)<span class="hljs-keyword"><span class="hljs-keyword">sequence</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br></li><li>  The callback function, after the completion of the reading process, will be called synchronously. <br><br></li><li>  Check the flag that indicates the completion of the read and write operations.  If the request is still being processed, we can check the status of the specified pair of queues.  Although the actual read and write operations are performed asynchronously, the <code>spdk_nvme_qpair_process_completions</code> function checks the progress and returns the number of completed I / O requests, and also calls the callback functions to signal the completion of the read and write procedures described above. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">sequence</span></span>.is_completed) {      spdk_nvme_qpair_process_completions(ns_entry-&gt;qpair, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br></li><li>  Free up a couple of queues and other resources before leaving. <br><br><pre> <code class="hljs lisp">spdk_nvme_ctrlr_free_io_qpair(<span class="hljs-name"><span class="hljs-name">ns_entry-&gt;qpair</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> </li></ol><br>  <a href="">Here is the</a> complete code for the example that was parsed here, posted on GitHub.  On the <a href="http://www.spdk.io/">spdk.io</a> website, <a href="http://www.spdk.io/">you</a> can find the <a href="http://www.spdk.io/spdk/doc/nvme.html">documentation</a> for the API SPDK NVMe. <br><br>  After launching our ‚ÄúHello World‚Äù the following should be displayed: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/176/c96/3f1/176c963f142efe126becbad0477fb684.jpg"></div><br>  <i><font color="#999999">The results of the ‚ÄúHello World‚Äù example</font></i> <br><br><h2>  <font color="#0071c5">Other examples included in SPDK</font> </h2><br>  The SPDK includes many examples that are designed to help programmers quickly understand how the SPDK works and begin developing their own projects. <br><br>  Here, for example, the results of the <a href="https://github.com/spdk/spdk/tree/master/examples/nvme/perf">perf</a> example, which tests the performance of the NVMe disk. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d14/7a3/651/d147a365159368f91d75c6c6a0f6aa28.jpg"></div><br>  <i><font color="#999999">Sample perf testing NVMe disk performance</font></i> <br><br>  Developers who need access to information on NVMe disks, such as functionality, attributes of the administrative command set, attributes of the NVMe command set, data on power management, information about the technical state of the device, can use an example to <a href="https://github.com/spdk/spdk/tree/master/examples/nvme/identify">identify</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/da4/d4c/45ada4d4ca20400842f162ec742a02f1.jpg"></div><br>  <i><font color="#999999">Example identify, displaying NVMe-disk information</font></i> <br><br><h2>  <font color="#0071c5">findings</font> </h2><br>  We talked about how to use the SPDK and the driver working in the Linux user space to work with NVMe disks.  This approach minimizes additional delays caused by the use of kernel mechanisms for accessing storage devices, which increases the speed of data transfer between the drive and the system. <br><br>  If you are interested in developing high-performance applications that work with disk drives using SPDK, <a href="https://lists.01.org/mailman/listinfo/spdk">here</a> you can subscribe to the SPDK newsletter.  And <a href="https://www.brighttalk.com/webcast/10773/178503">here</a> <a href="https://www.brighttalk.com/webcast/10773/179977">are some</a> useful videos. </div><p>Source: <a href="https://habr.com/ru/post/315906/">https://habr.com/ru/post/315906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../315896/index.html">Asset Operations: routine industrial documentation</a></li>
<li><a href="../315898/index.html">[ZeroNights2016] [CTFzone] Without 100 grams you will not understand</a></li>
<li><a href="../315900/index.html">The difference of the frame from the library</a></li>
<li><a href="../315902/index.html">New season webinars Hewlett Packard Enterprise</a></li>
<li><a href="../315904/index.html">Meeting lovers of big data and art</a></li>
<li><a href="../315908/index.html">When is it harmful to test your components?</a></li>
<li><a href="../315910/index.html">Asterisk statistics interface. New version, new functionality</a></li>
<li><a href="../315912/index.html">Connecting a character LCD to the board from WD MyBook Live on AppliedMicro APM82181</a></li>
<li><a href="../315914/index.html">Using Intel technology to transfer network traffic from a physical adapter to a virtual one</a></li>
<li><a href="../315916/index.html">You, Inc. How to develop personal and professional skills, sell them and stand out from the crowd</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>