<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Neural network speech synthesis with their own hands</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The synthesis of speech today is used in various fields. These are voice assistants, and IVR systems, smart homes, and much more. By itself, the task,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Neural network speech synthesis with their own hands</h1><div class="post__text post__text-html js-mediator-article">  The synthesis of speech today is used in various fields.  These are voice assistants, and IVR systems, smart homes, and much more.  By itself, the task, for my taste, is very clear and understandable: the written text should be pronounced as a person would. <br><br>  Some time ago machine learning came to the field of speech synthesis, as well as in many other areas.  It turned out that a number of components of the entire system can be replaced with neural networks, which will allow not only to approach the existing algorithms in quality, but even to significantly surpass them. <br><br><img src="https://habrastorage.org/webt/g2/-j/hw/g2-jhwalba1v-5toodv7dcqxjro.jpeg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I decided to try to make a fully neural network synthesis with my own hands, and at the same time share my experience with the community.  What came out of this, you can find out by looking under the cat. <br><a name="habracut"></a><br><h2>  Speech synthesis </h2><br>  To build a speech synthesis system, we need a whole team of specialists from different areas.  For each of them there is a whole mass of algorithms and approaches.  Written doctoral dissertations and thick books describing the fundamental approaches.  Let's first understand the surface of each of them. <br><br><h4>  Linguistics </h4><br><ol><li>  <b>Normalization of the text</b> .  First we need to expand all abbreviations, numbers and dates into text.  <i>The 50s of the 20th century</i> should turn into the <i>fifties of the twentieth century</i> , and the <i>city ‚Äã‚Äãof St. Petersburg, Bolshoy Prospect P.S.</i>  to the <i>city ‚Äã‚Äãof St. Petersburg, Bolshoi Prospekt Petrogradskoy Side</i> .  This should occur as naturally as if the person was asked to read the writing. </li><li>  <b>Prepare a dictionary of stress</b> .  The placement of stresses can be made according to the rules of the language.  In English, stress is often placed on the first syllable, and in Spanish - on the penultimate.  At the same time, there is a whole mass of exceptions from these rules that are not susceptible to any general rule.  They must be taken into account.  For the Russian language in the general sense, the rules of placement of accents do not exist at all, so that without a dictionary with accented accents there is absolutely no way to go. </li><li>  <b>Removing homography</b> .  Omographs are words that are the same in spelling, but differ in pronunciation.  A native speaker can easily stress: a <i>door lock</i> and a <i>castle on a mountain</i> .  But the <i>key to the lock</i> - the task is more complicated.  It is impossible to completely remove the homography without context. </li></ol><br><h4>  Prosodic </h4><br><ol><li>  <b>Selection of syntagmas and pause arrangement</b> .  Syntagma is a relatively complete segment of speech.  When a person speaks, he usually inserts a pause between phrases.  We need to learn how to divide the text into such syntagmas. </li><li>  <b>Determination of the type of intonation</b> .  The expression of completeness, question and exclamation - the most simple intonation.  But to express the irony, doubt or inspiration task is much more difficult. </li></ol><br><h4>  Phonetics </h4><br><ol><li>  <b>Receiving transcription</b> .  Since in the end we work with pronouncing rather than spelling, it is obvious that instead of letters (graphemes), it is logical to use sounds (phonemes).  The transformation of a grapheme entry into a phonemic one is a separate task consisting of a set of rules and exceptions. </li><li>  <b>Calculation of intonation parameters</b> .  At this point, it is necessary to decide how the pitch of the pitch and the speed of pronunciation will vary depending on the pauses placed, the selected sequence of phonemes and the type of intonation expressed.  In addition to the basic tone and speed, there are other parameters with which you can experiment for a long time. </li></ol><br><h4>  Acoustics </h4><br><ol><li>  <b>Selection of sound elements</b> .  Synthesis systems operate on the so-called allophones ‚Äî implementations of phonemes that depend on the environment.  Records from the training data are cut into pieces by phoneme markup, which form the allophone base.  Each allophone is characterized by a set of parameters such as context (phonemes neighbors), pitch, duration, and others.  The synthesis process itself is the selection of the correct sequence of allophones most suitable in the current conditions. </li><li>  <b>Modification and sound effects</b> .  For the resulting records sometimes need post-processing, some special filters that make synthesized speech a little closer to human or correct some defects. </li></ol><br>  If suddenly it seemed to you that all this can be simplified, figured out in your head, or quickly select some heuristics for individual modules, then just imagine that you need to do a synthesis in Hindi.  If you do not speak the language, you will not even be able to assess the quality of your synthesis without attracting someone who would speak the language at the right level.  My mother tongue is Russian, and I hear when the synthesis is mistaken in accents or speaks with the wrong intonation.  But at the same time, all the synthesized English for me sounds about the same, not to mention the more exotic languages. <br><br><h2>  Implementations </h2><br>  We will try to find the End-2-End (E2E) implementation of the synthesis, which would take on all the difficulties associated with the subtleties of the language.  In other words, we want to build a system based on neural networks, which would accept text at the input, and give synthesized speech at the output.  Is it possible to train such a network that would allow replacing a whole team of specialists from narrow areas with a team (perhaps even from one person) specializing in machine learning? <br><br>  At the <i>end2end tts query,</i> Google produces a whole lot of results.  Led by - the implementation of Tacotron from Google itself.  It seemed to me the easiest to go from specific people on Github who are engaged in research in this area and spread their implementations of various architectures. <br><br>  I would single out three: <br><br><ol><li>  <a href="https://github.com/Kyubyong/">Kyubyong Park</a> </li><li>  <a href="https://github.com/keithito/">Keith ito</a> </li><li>  <a href="https://github.com/r9y9/">Ryuichi Yamamoto</a> </li></ol><br>  Look to them in the repository, there is a whole storehouse of information.  There are a lot of architectures and approaches to the E2E synthesis problem.  Among the main ones: <br><br><ol><li>  Tacotron (version 1, 2). </li><li>  DeepVoice (versions 1, 2, 3). </li><li>  Char2Wav. </li><li>  DCTTS. </li><li>  WaveNet. </li></ol><br>  We need to choose one.  I chose Deep Convolutional Text-To-Speech (DCTTS) from <a href="https://github.com/Kyubyong/dc_tts">Kyubyong Park</a> as the basis for future experiments.  The original article can be viewed at the <a href="https://arxiv.org/abs/1710.08969">link</a> .  Let's take a closer look at the implementation. <br><br>  The author laid out the results of the synthesis in three different bases and at different stages of learning.  For my taste, as not a native speaker, they sound quite decent.  The latest database in English (Kate Winslet's Audiobook) contains only 5 hours of speech, which for me is also a great advantage, since my database contains approximately a comparable amount of data. <br><br>  Some time after I trained my system, information appeared in the repository that the author had successfully trained a model for the Korean language.  This is also quite important, since languages ‚Äã‚Äãcan vary greatly and robustness in relation to language is a pleasant addition.  It can be expected that the learning process does not require a special approach to each set of training data: language, voice or some other characteristics. <br><br>  Another important point for this kind of systems is the training time.  Tacotron on the gland that I have, according to my estimates, would have studied for about 2 weeks.  For prototyping at the initial level it seemed to me too resource-intensive.  The pedals, of course, wouldn‚Äôt have to be turned, but it would take a lot of calendar time to create some kind of basic prototype.  DCTTS in the final form is studying for a couple of days. <br><br>  Every researcher has a set of tools that he uses in his work.  Everyone chooses them to their liking.  I love PyTorch very much.  Unfortunately, I did not find the implementation of DCTTS on it, and I had to use TensorFlow.  Perhaps at some point, I will post my implementation on PyTorch. <br><br><h2>  Data for training </h2><br>  A good base for the implementation of synthesis is the main key to success.  To the preparation of a new voice fit very thoroughly.  A professional announcer pronounces pre-prepared phrases for many hours.  For each utterance, you need to endure all the pauses, speak without jerks and delays, reproduce the correct contour of the main tone, and all this combined with the correct intonation.  Among other things, not all voices sound equally pleasant. <br><br>  I had about 8 hours base on my hands, recorded by a professional speaker.  Now we are discussing with colleagues the opportunity to put this voice in free access for non-commercial use.  If everything works out, then a distributive with a voice in addition to the recordings themselves will include the exact text for each of them. <br><br><h2>  Let's start </h2><br>  We want to create a network that would accept text as input, and would produce synthesized sound at the output.  The abundance of implementations shows that this is possible, but of course there are a number of reservations. <br><br>  The main parameters of the system are usually called hyperparameters and are placed in a separate file, which is called appropriately: <i>hparams.py</i> or <i>hyperparams.py</i> , as in our case.  Everything that can be twisted without touching the main code is taken into the hyperparameters.  Starting from directories for logs, ending with the size of hidden layers.  After this, the hyperparameters in the code are used like this: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hyperparams <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Hyperparams <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> hp batch_size = hp.B <span class="hljs-comment"><span class="hljs-comment">#     </span></span></code> </pre> <br>  Hereinafter, all variables with prefix <i>hp.</i>  They are taken from the hyperparameters file.  It is understood that these parameters do not change in the learning process, so be careful when restarting something with new parameters. <br><br><h4>  Text </h4><br>  For text processing, the so-called embedding-layer is usually used, which is put first.  Its essence is simple - it‚Äôs just a sign that associates with each character from the alphabet a certain vector of features.  In the process of learning, we select the optimal values ‚Äã‚Äãfor these vectors, and when we synthesize according to the finished model, we simply take the values ‚Äã‚Äãfrom this plate itself.  This approach is used in the already quite widely known Word2Vec, where a vector representation for words is built. <br><br>  For example, take the simple alphabet: <br><br><pre> <code class="python hljs">[<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>]</code> </pre> <br>  In the process of learning, we found out that the optimal values ‚Äã‚Äãof each of their characters are as follows: <br><br><pre> <code class="python hljs">{ <span class="hljs-string"><span class="hljs-string">'a'</span></span>: [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'b'</span></span>: [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-string"><span class="hljs-string">'c'</span></span>: [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] }</code> </pre> <br>  Then, for the <i>aabbcc</i> line <i>,</i> after passing the embedding layer, we get the following matrix: <br><br><pre> <code class="python hljs">[[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>], [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]]</code> </pre> <br>  This matrix is ‚Äã‚Äãthen fed to other layers that no longer use the concept of a symbol. <br><br>  At this point, we see the first constraint that appears in us: the set of characters that we can send to synthesis is limited.  For each character there must be some non-zero number of examples in the training data, preferably with a different context.  This means that we need to be careful in choosing the alphabet. <br><br>  In my experiments, I stopped at the option: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#       vocab = "E -"</span></span></code> </pre> <br>  This is the alphabet of the Russian language, a hyphen, a space, and the end of a line.  There are several important points and assumptions: <br><br><ol><li>  I did not add punctuation to the alphabet.  On the one hand, we really do not pronounce them.  On the other hand, by the punctuation marks we divide the phrase into parts (syntagmas), dividing them into pauses.  How can the system say the <i>execution can not be pardoned</i> ? </li><li>  The alphabet has no numbers.  We expect that they will be deployed in numerals before serving for synthesis, that is, normalized.  In general, all the E2E architectures that I have seen require exactly normalized text. </li><li>  The alphabet has no Latin characters.  The English system will not be able to pronounce.  You can try a transliteration and get a strong Russian accent - the notorious <i>mi spik frome May hart</i> . </li><li>  The alphabet has the letter <i></i> .  In the data for which I trained the system, it stood where it was needed, and I decided not to change this alignment.  However, at that moment, when I was evaluating the results, it turned out that now, before applying for synthesis, this letter also needs to be set correctly, otherwise the system says exactly <i>e</i> , not <i></i> . </li></ol><br>  In future versions, you can pay more attention to each of the items, but for now we will leave in such a bit simplified form. <br><br><h4>  Sound </h4><br>  Almost all systems operate not by the signal itself, but by various kinds of spectra obtained on windows with a certain step.  I will not go into details, there are quite a lot of different kinds of literature on this topic.  Focus on implementation and use.  The implementation of DCTTS uses two types of spectra: amplitude spectrum and chalk spectrum. <br><br>  They are considered as follows (the code from this listing and all subsequent ones are taken from the DCTTS implementation, but modified for clarity): <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      y, sr = librosa.load(wavename, sr=hp.sr) #     y, _ = librosa.effects.trim(y) # Pre-emphasis  y = np.append(y[0], y[1:] - hp.preemphasis * y[:-1]) #    linear = librosa.stft(y=y, n_fft=hp.n_fft, hop_length=hp.hop_length, win_length=hp.win_length) #   mag = np.abs(linear) # - mel_basis = librosa.filters.mel(hp.sr, hp.n_fft, hp.n_mels) mel = np.dot(mel_basis, mag) #    mel = 20 * np.log10(np.maximum(1e-5, mel)) mag = 20 * np.log10(np.maximum(1e-5, mag)) #  mel = np.clip((mel - hp.ref_db + hp.max_db) / hp.max_db, 1e-8, 1) mag = np.clip((mag - hp.ref_db + hp.max_db) / hp.max_db, 1e-8, 1) #       mel = mel.T.astype(np.float32) mag = mag.T.astype(np.float32) #      t = mel.shape[0] num_paddings = hp.r - (t % hp.r) if t % hp.r != 0 else 0 mel = np.pad(mel, [[0, num_paddings], [0, 0]], mode="constant") mag = np.pad(mag, [[0, num_paddings], [0, 0]], mode="constant") #     - mel = mel[::hp.r, :]</span></span></code> </pre><br>  For calculations, almost all E2E synthesis projects use the LibROSA library ( <a href="https://librosa.github.io/librosa/">https://librosa.github.io/librosa/</a> ).  It contains a lot of useful, I recommend to look into the documentation and see what is in it. <br><br>  Now let's see how the amplitude spectrum (magnitude spectrum) looks like on one of the files from the database I used: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9_/_k/x8/9__kx8nn97o0ksl3i0iayi6l2ek.png"></div><br>  Such a variant of the representation of window spectra is called a spectrogram.  On the abscissa axis is the time in seconds, on the y-axis - the frequency in Hertz.  The color is the amplitude of the spectrum.  The brighter the point, the greater the amplitude value. <br><br>  A chalk spectrum is an amplitude spectrum, but taken on a chalk scale with a specific step and window.  We set the number of steps in advance; in most implementations, the value 80 is used for the synthesis (set by the <i>hp.n_mels</i> parameter).  The transition to the chalk spectrum makes it possible to greatly reduce the amount of data, but this preserves the characteristics important for the speech signal.  The chalk spectrogram for the same file looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kg/lb/gb/kglbgboruly8io9anzhvttcjnku.png"></div><br>  Notice the thinning of the chalk spectra in time on the last line of the listing.  We take only every 4th vector ( <i>hp.r == 4</i> ), thus reducing the sampling rate accordingly.  Speech synthesis is reduced to predicting chalk spectra from a sequence of characters.  The idea is simple: the less network you have to predict, the better it will be. <br><br>  Well, we can get a spectrogram from the sound, but we can't listen to it.  Accordingly, we need to be able to restore the signal back.  For these purposes, the systems often use the Griffin-Lima algorithm and its more modern interpretations (for example, RTISILA, the <a href="https://ieeexplore.ieee.org/document/4244543/">link</a> ).  The algorithm allows the signal to be recovered from its amplitude spectra.  The implementation I used: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">griffin_lim</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(spectrogram, n_iter=hp.n_iter)</span></span></span><span class="hljs-function">:</span></span> x_best = copy.deepcopy(spectrogram) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(n_iter): x_t = librosa.istft(x_best, hp.hop_length, win_length=hp.win_length, window=<span class="hljs-string"><span class="hljs-string">"hann"</span></span>) est = librosa.stft(x_t, hp.n_fft, hp.hop_length, win_length=hp.win_length) phase = est / np.maximum(<span class="hljs-number"><span class="hljs-number">1e-8</span></span>, np.abs(est)) x_best = spectrogram * phase x_t = librosa.istft(x_best, hp.hop_length, win_length=hp.win_length, window=<span class="hljs-string"><span class="hljs-string">"hann"</span></span>) y = np.real(x_t) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y</code> </pre> <br>  And the signal from the amplitude spectrogram can be restored like this (steps inverse to obtaining the spectrum): <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  mag = mag.T #  mag = (np.clip(mag, 0, 1) * hp.max_db) - hp.max_db + hp.ref_db #      mag = np.power(10.0, mag * 0.05) #   wav = griffin_lim(mag**hp.power) # De-pre-emphasis  wav = signal.lfilter([1], [1, -hp.preemphasis], wav)</span></span></code> </pre> <br>  Let's try to get the amplitude spectrum, restore it back, and then listen. <br><br>  Original: <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://w.soundcloud.com/player/" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Restored signal: <iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://w.soundcloud.com/player/" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  For my taste, the result has become worse.  The authors of Tacotron (the first version also uses this algorithm) noted that they used the Griffin-Lim algorithm as a temporary solution to demonstrate the capabilities of the architecture.  WaveNet and similar architectures allow synthesizing better-quality speech.  But they are more heavy and require some effort for training. <br><br><h2>  Training </h2><br>  DCTTS, which we have chosen, consists of two almost independent neural networks: Text2Mel and Spectrogram Super-resolution Network (SSRN). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pk/82/jb/pk82jbp5bnguczow3_ygrqh9gdq.png"></div><br>  Text2Mel predicts the chalk spectrum on the text using the attention mechanism (Attention), which links two encoders (TextEnc, AudioEnc) and one decoder (AudioDec).  Note that Text2Mel restores precisely the rarefied chalk spectrum. <br><br>  SSRN recovers a full amplitude spectrum from the chalk spectrum, taking into account frame drops and restoring the sampling rate. <br><br>  The sequence of calculations is described in some detail in the original article.  In addition, there is the source code of the implementation, so you can always debug and delve into the subtleties.  Please note that the author of the implementation has moved away from the article in some places.  I would single out two points: <br><br><ol><li>  Additional layers appeared for normalization (normalization layers), without which, according to the author, nothing worked. </li><li>  The implementation uses a dropout mechanism for better regularization.  This article is not. </li></ol><br>  I took a voice that includes 8 hours of recordings (several thousand files).  Left only entries that: <br><br><ol><li>  The texts contain only letters, spaces and hyphens. </li><li>  The length of the text does not exceed <i>hp.max_N</i> . </li><li>  The length of the chalk spectra after thinning does not exceed <i>hp.max_T</i> . </li></ol><br>  I got a little more than 5 hours.  I counted the necessary spectra for all the records and in turn started the training of Text2Mel and SSRN.  All this is done fairly simple: <br><br><pre> <code class="bash hljs">$ python prepro.py $ python train.py 1 $ python train.py 2</code> </pre> <br>  Please note that in the original repository <i>prepro.py</i> is referred to as <i>prepo.py</i> .  My inner perfectionist could not tolerate this, so I renamed it. <br><br>  DCTTS contains only convolutional layers, and unlike RNN implementations like Tacotron, it learns much faster. <br><br>  On my machine with an Intel Core i5-4670, 16 Gb of RAM and a GeForce 1080 on board, 50 thousand steps for Text2Mel learns in 15 hours, and 75 thousand steps for SSRN in 5 hours.  The time required for a thousand steps in the learning process, I almost did not change, so you can easily estimate how long it will take to study with a large number of steps. <br><br>  The size of the batch can be adjusted with the <i>hp.B</i> parameter.  Periodically, the learning process I fell into out-of-memory, so I just divided the size of the batch by 2 and restarted the training from scratch.  I believe that the problem lies somewhere in the depths of TensorFlow (I used not the freshest) and the intricacies of the implementation of batching.  I did not begin to deal with this, since on the value of <i>8</i> everything stopped falling. <br><br><h2>  Result </h2><br>  After the models have learned, you can finally run the synthesis.  To do this, fill in the file with phrases and run: <br><br><pre> <code class="bash hljs">$ python synthesize.py</code> </pre> <br>  I corrected implementation a little to generate phrases from the necessary file. <br><br>  The results as wav files will be saved in the <i>samples</i> directory.  Here are examples of the synthesis system, which turned out for me: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://w.soundcloud.com/player/" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Conclusions and Remarks </h2><br>  The result exceeded my personal expectations in quality.  The system places the stress, the speech is legible, and the voice is recognizable.  In general, it turned out quite well for the first version, especially given the fact that only 5 hours of training data were used for training. <br><br>  There are questions about the controllability of such a synthesis.  While it is impossible to even correct the stress in the word, if it is wrong.  We are rigidly tied to the maximum length of the phrase and the size of the chalk spectrogram.  There is no way to control intonation and playback speed. <br><br>  I did not post my changes to the code of the original implementation.  They touched only the download of training data and phrases for the synthesis of a ready-made system, as well as the values ‚Äã‚Äãof hyper <i>parameters</i> : the alphabet ( <i>hp.vocab</i> ) and the size of the batch ( <i>hp.B</i> ).  The rest of the implementation remained original. <br><br>  As part of the story, I didn‚Äôt touch upon the production of such systems at all; before this, E2E speech synthesis systems are still very far away.  I used a GPU with CUDA, but even in this case, everything is slower than real time.  On the CPU, everything works just indecently slowly. <br><br>  All these questions will be solved in the coming years by large companies and scientific communities.  I am sure that it will be very interesting. </div><p>Source: <a href="https://habr.com/ru/post/358816/">https://habr.com/ru/post/358816/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358804/index.html">Protocol-Oriented Programming</a></li>
<li><a href="../358806/index.html">Red Hat Summit: The best moments of the main open source conference in 30 minutes</a></li>
<li><a href="../358808/index.html">Promise guide for those who want to understand them</a></li>
<li><a href="../358810/index.html">‚ÄúLife after Java 10‚Äù: what changes Java 11 will bring</a></li>
<li><a href="../358814/index.html">Lead Dev New York: review of reports and review of the conference</a></li>
<li><a href="../358818/index.html">Summer vacation: how not to worry about the work of your site in vain</a></li>
<li><a href="../358820/index.html">FontCode: a new way of steganography through the shape of letters</a></li>
<li><a href="../358822/index.html">The sofa as the limit of the lazy employee's abilities in the turquoise paradigm</a></li>
<li><a href="../358824/index.html">Kubernetes NodePort vs LoadBalancer vs Ingress? When and what to use?</a></li>
<li><a href="../358826/index.html">Automatic visualization of the python code. Part three: new features of the graphical representation of the code</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>