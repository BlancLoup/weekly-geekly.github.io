<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The reasons why 64-bit programs require more stack memory</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In forums, people often mention that 64-bit versions of programs consume more memory and stack. It usually refers to the fact that the size of the dat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The reasons why 64-bit programs require more stack memory</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/a17/c37/e61/a17c37e61a24a5479c53da92a371768d.png"><br>  In forums, people often mention that <a href="http://www.viva64.com/art-1-1-3323188440.html">64-bit</a> versions of programs consume more memory and stack.  It usually refers to the fact that the size of the data became 2 times larger.  However, this is an unfounded statement, since the size of most types (char, short, int, float) in C / C ++ language remains the same on 64-bit systems.  Of course, for example, the size of pointers has increased, but not all the data in the program consists of pointers.  The reasons for the growth of memory consumption and the stack are more complex.  I decided to investigate this issue in more detail. <br><br>  In this article I will talk about the stack, and in the future I plan to discuss the allocation of memory and the size of the binary code.  And I also want to immediately notice that the article is devoted to the C / C ++ language and the Visual Studio development environment. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Until recently, I thought that the code of a 64-bit program can absorb a stack no faster than twice as compared to a 32-bit code.  Based on this assumption, I recommended in articles just in case to double the program stack.  However, now I found out an unpleasant fact.  The absorption of the stack can grow significantly more than twice.  I was surprised because I had previously considered growing the stack twice as the most pessimistic scenario.  The reason for my unfounded hopes will become clear later.  Let us now consider how parameters are passed in a 64-bit program when calling functions. <br><br>  When developing <a href="http://www.viva64.com/go.php%3Furl%3D328">calling conventions</a> for the <a href="http://www.viva64.com/terminology/AMD64_rus.html">x86-64 architecture,</a> they decided to put an end to the existence of various options for calling functions.  In <a href="http://www.viva64.com/terminology/Win32_rus.html">Win32,</a> there were a number of calling conventions: stdcall, cdecl, fastcall, thiscall, and so on.  In <a href="http://www.viva64.com/terminology/Win64_rus.html">Win64, there is</a> only one native calling convention.  Modifiers like __cdecl are ignored by the compiler.  I think everyone will agree in the nobility of such a sharp reduction in the number of agreements. <br><br>  The x86-64 calling convention is similar to the fastcall agreement in x86.  In the x64 agreement, the first four integer arguments (from left to right) are transmitted in 64-bit registers chosen specifically for this purpose: <br><br>  RCX: 1st integer argument <br>  RDX: 2nd integer argument <br>  R8: 3rd integer argument <br>  R9: 4th integer argument <br><br>  The remaining integer arguments are passed through the stack.  The ‚Äúthis‚Äù pointer is considered an integer argument, so it is always placed in the RCX register.  If floating-point values ‚Äã‚Äãare transmitted, the first four of them are transmitted in the XMM0-XMM3 registers, and the subsequent ones via the stack. <br><br>  From this information, I previously concluded that a 64-bit program in many cases can save stack memory compared to 32-bit.  After all, if parameters are passed through registers, the function code is short and there is no need to store arguments in the memory (stack), then the size of the used stack memory should be reduced.  But it is not. <br><br>  Although the arguments can be passed in registers, the compiler still reserves space for them in the stack, reducing the value of the RSP register (stack pointer).  At a minimum, each function must reserve 32 bytes in the stack (four 64-bit values ‚Äã‚Äãcorresponding to the registers RCX, RDX, R8, R9).  This space in the stack makes it easy to save the contents of the registers passed to the function in the stack.  The called function is not required to drop the input parameters passed through the registers to the stack, but reserving a place in the stack, if necessary, allows this.  If more than four integer parameters are passed, the corresponding additional space must be reserved in the stack. <br><br>  Consider an example.  A certain function transfers two integer parameters of a child function.  The compiler will put the values ‚Äã‚Äãof the arguments in the registers RCX and RDX and at the same time subtract 32 bytes from the register RSP.  The called function can access parameters via the RCX and RDX registers.  If the code of this function needs these registers for some other purpose, it will be able to copy their contents into the reserved stack space of 32 bytes in size. <br><br>  The described feature leads to a significant increase in the rate of absorption of the stack.  Even if the function has no parameters, 32 bytes will still be ‚Äúbit off‚Äù from the stack, which are then not used at all.  I did not catch the point of using such an inefficient mechanism.  Something is said about the unification and simplification of debugging, but somehow vague. <br><br>  Let's pay attention to one more moment.  The RSP stack pointer must be aligned to 16 bytes before another function call.  Thus, the total size of the used stack when calling a function <b>without parameters</b> in the 64-bit code is: 8 (return address) + 8 (alignment) + 32 (reserve for arguments) = <b>48 bytes!</b> <br><br>  Consider what this may lead to in practice.  Here and further, for experiments, I will use Visual Studio 2010. We construct a recursive function of the form: <br><br><pre>  void StackUse (size_t * depth)
 {
   volatile size_t * ptr = 0;

   if (depth! = NULL)
     ptr = depth;

   cout &lt;&lt; * ptr &lt;&lt; endl;

   (* ptr) ++;

   StackUse (depth);

   (* ptr) -;
 }
</pre><br>  The function is a bit confusing so that the optimizer doesn't turn it into ‚Äúnothing‚Äù.  The main thing here is the following: the function has a pointer type argument and one local variable, also a pointer type.  Let's see how many functions a stack consumes in 32-bit and 64-bit versions and how many times it can be called recursively with a 1-megabyte stack (default size). <br><br>  Release 32-bit: The last displayed number (stack depth) is 51331. <br>  The compiler uses 20 bytes when calling this function. <br><br>  Release 64-bit: The last number displayed is 21288. <br>  The compiler uses 48 bytes when calling this function. <br><br>  Thus, the 64-bit version of the StackUse function is more than 2 times more voracious than the 32-bit one. <br><br>  Note that changing the data alignment rules can also have an effect on the size of the stack being absorbed.  Suppose a function takes a structure as an argument: <br><br><pre>  struct S
 {
   char a;
   size_t b;
   char c;
 };

 void StackUse (S s) {...} </pre><br>  The size of the 'S' structure due to changes in the alignment rules and changes in the size of the 'b' member will grow from 12 to 24 bytes when recompiled in 64-bit mode.  The structure is passed to the function by value.  And, therefore, the structure in the stack will also take twice as much memory. <br><br>  is it so bad?  Not.  We should not forget about the greater number of registers available in the 64-bit compiler.  Complicate the code of the experimental function: <br><br><pre>  void StackUse (size_t * depth, char a, int b)
 {
   volatile size_t * ptr = 0;

   int c = 1;
   int d = -1;

   for (int i = 0; i &lt;b; i ++)
     for (char j = 0; j &lt;a; j ++)
       for (char k = 0; k &lt;5; k ++)
         if (* depth&gt; 10 &amp;&amp; k&gt; 2)
         {
           c + = j * k - i;
           d - = (i - j) * c;
         }

   if (depth! = NULL)
     ptr = depth;

   cout &lt;&lt; c &lt;&lt; "" &lt;&lt; d &lt;&lt; "" &lt;&lt; * ptr &lt;&lt; endl;
   (* ptr) ++;

   StackUse (depth, a, b);

   (* ptr) -;
 } </pre><br>  Startup Results: <br><br>  Release 32-bit: The last displayed number is 16060. <br>  The compiler uses 64 bytes when calling this function. <br><br>  Release 64-bit: The last number displayed is 21310. <br>  The compiler still uses 48 bytes when calling this function. <br><br>  For this example, the 64-bit compiler managed to use additional registers and build more efficient code, which reduced the amount of stack memory used! <br><br><h2>  findings </h2><ol><li>  It is impossible to predict how much stack memory will use the 64-bit version of the program compared to the 32-bit one.  The size can be either smaller (which is unlikely) or much larger. </li><li>  For a 64-bit program, just in case, it is worth increasing the volume of the reserved stack by a factor of 2-3.  Better 3 times for peace of mind.  To do this, in the project settings there is the Stack Reserve Size parameter (/ STACK: reserve key).  The default stack size is 1 megabyte. </li><li>  You should not worry that a 64-bit program consumes more stack memory.  There is much more physical memory in 64-bit systems.  A 2 megabyte stack on a 64-bit system with 8 gigabytes of memory takes up a smaller percentage of memory than 1 megabyte of a stack on a 32-bit system with 2 gigabytes of memory. </li></ol><br><h2>  Additional links </h2><ol><li>  Raymond Chen.  The history of calling conventions, part 5: amd64.  <a href="http://www.viva64.com/go.php%3Furl%3D325">http://www.viva64.com/go.php?url=325</a> </li><li>  Kevin Frei.  x64 ABI vs.  x86 ABI (aka Calling Conventions for AMD64 &amp; EM64T).  <a href="http://www.viva64.com/go.php%3Furl%3D326">http://www.viva64.com/go.php?url=326</a> </li><li>  Msdn  x64 Software Conventions.  <a href="http://www.viva64.com/go.php%3Furl%3D327">http://www.viva64.com/go.php?url=327</a> </li><li>  Wikipedia.  x86 calling conventions.  <a href="http://www.viva64.com/go.php%3Furl%3D328">http://www.viva64.com/go.php?url=328</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/94340/">https://habr.com/ru/post/94340/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../94332/index.html">So who exactly is "Big Brother"?</a></li>
<li><a href="../94333/index.html">Eyes on the web</a></li>
<li><a href="../94335/index.html">We perform in public. Preparing for your first conference talk</a></li>
<li><a href="../94337/index.html">Synchronize your smartphone with a computer over the air</a></li>
<li><a href="../94339/index.html">Virtual Conference "Information in action." Visit without leaving the office!</a></li>
<li><a href="../94344/index.html">Mail hosting based on Exchange Server 2010 - for free ?!</a></li>
<li><a href="../94347/index.html">Conveniently complete schedules with jQuery</a></li>
<li><a href="../94348/index.html">3D gestures</a></li>
<li><a href="../94349/index.html">Site qip.ru vulnerability</a></li>
<li><a href="../94350/index.html">named pipes to Unix</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>