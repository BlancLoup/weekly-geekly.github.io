<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why study Clojure?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is a good programming language? What qualities and characteristics should it have? The answer is difficult to give. Here is one of the possible d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why study Clojure?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/0a9/90e/657/0a990e65761cf8699e791e29e7e30fe5.jpg" align="left"><br>  What is a good programming language?  What qualities and characteristics should it have?  The answer is difficult to give.  Here is one of the possible definitions: a good PL should perform its tasks well.  After all, PL is only a tool in the hands of a programmer.  And the tool is obliged to help us in our work.  In the end, this is the reason for its creation.  Different PL try to solve different problems (with varying success).  The goal that was set when designing Clojure is to make the programs we write <b>simple</b> .  And, as a result, to speed up their creation, testing.  And most importantly, reduce the time for their understanding, change and maintenance. <br><a name="habracut"></a><br><br><h2>  Clojure rocks? </h2><br>  I'll warn you right away - the article will not contain pieces of code that demonstrate the Clojure slope.  There will be no phrases like "in X it took 5 lines and in Clojure only 4".  This is a disgusting criterion for the quality of the language!  In the end, I absolutely do not care if I can write <code>qsort</code> in 2 lines, or I have to strain my fingers for as many as 5 - in real life I will use the library function! <br><br>  Lambdos won't surprise anyone now, they are everywhere (well, almost, although usually they appear everywhere in the 8th version).  Processing of collections (including parallel), list expressions, various syntactic sugar - this is now enough in many languages.  In truth, I just adore <a href="http://habrahabr.ru/post/120665/">such articles</a> .  But such comparisons are absolutely not suitable for comparing the quality of languages!  This is how to measure the speed of PL by how fast the program displays ‚ÄúHello, world!‚Äù.  Well, unless we measure the speed of <a href="http://ru.wikipedia.org/wiki/HQ9%252B">HQ9 +</a> .  If you think, then such details are not so important for large systems.  As the project grows, we are less and less concerned about whether we use parentheses or indents, infix or prefix notation.  The extra line when finding the sum of the array already ceases to care for all - in the first place there are problems of a different kind. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Complexity </h2><br>  The systems we create are inherently fluid.  It would be very good if the requirements did not change.  It‚Äôs just great if you could foresee all situations at the very beginning of the development.  Alas, in real life we ‚Äã‚Äãconstantly have to finish, rework, improve, rewrite, replace, optimize ... The most annoying thing is that with time the complexity of the system only grows.  Constantly, continuously.  At the beginning of development, everything is simple and transparent, any change is made quickly, no ‚Äúcrutches‚Äù.  Beauty.  Over time, the situation ceases to be so rosy and fun.  Even the slightest revision of the code could potentially lead to an avalanche-like change in the behavior of the system.  We have to carefully study, analyze the code, try to <i>predict the</i> side effects of each change.  So, over time, we literally cannot thoroughly analyze all possible consequences of our changes. <br><br>  A person by nature can perceive at one time only a limited amount of information.  As the project grows, the number of internal connections increases.  Moreover, most of the links are implicit.  It‚Äôs harder and harder for us to hold what we need  Meanwhile, the team is growing, the team is changing - new people no longer know the whole project.  There is a division of responsibilities, which can lead to even more entanglement.  Gradually, our system becomes complex. <br><br>  How to deal with it?  Maximum coverage of regression tests and their run after each change?  Tests are extremely useful, but they are only a safety rope.  The tests did not pass - something is wrong, we have problems.  This is a treatment of symptoms, but tests do not eliminate the essence of the problem.  Strict guidelines and widespread use of patterns?  No, the problem is not local difficulties.  We simply stop understanding how components interact in our code, there are too many implicit links.  Perhaps constant refactoring?  This is not a panacea, the complexity is not growing from low-level solutions.  In fact, the problem should be solved comprehensively.  And one of the important tools is the right tool.  A good programming language should help us write simple and transparent programs. <br><br><h2>  Simple and easy </h2><br>  But ‚Äúsimple‚Äù (simple) does not mean ‚Äúeasy‚Äù (easy).  These are different concepts.  Rich Hickey (author of Clojure) even made the famous <a href="http://www.infoq.com/presentations/Simple-Made-Easy">Simple Made Easy</a> report on this topic.  On Habr√© published <a href="http://habrahabr.ru/post/133352/">translation slides</a> .  Simplicity is an objective concept.  This is the lack of complexity (complexity), the absence of interweaving, confusion, a small number of links.  On the other hand, ‚Äúeasy‚Äù is very subjective.  Is it easy to drive a bike?  Win a chess game?  Speak German?  I do not know German, but this is not a reason to say "this language is not needed, it is too complicated."  It is complicated <u>for me</u> , and only because I do not know him banally. <br><br>  We are all used to the fact that the function call is written as <code>f(x, y)</code> .  We are accustomed to programming in the framework of the PLO.  This is commonplace.  But in fact, the lung is not necessarily easy.  We just get used to the complexity of some things, start to ignore it, take it for granted.  Example function: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defn</span></span> select <span class="hljs-string"><span class="hljs-string">"Returns a set of the elements for which pred is true"</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:added</span></span> <span class="hljs-string"><span class="hljs-string">"1.0"</span></span>} [pred xset] (<span class="hljs-name"><span class="hljs-name">reduce</span></span> (<span class="hljs-name"><span class="hljs-name">fn</span></span> [sk] (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">pred</span></span> k) s (<span class="hljs-name"><span class="hljs-name">disj</span></span> sk))) xset xset))</code> </pre><br><br>  Looks very ... <b>weird</b> !  It is necessary to spend some time studying the language, mastering its concepts so that it becomes easy.  But simplicity (or complexity) is constant.  If we study the tool well, the number of internal dependencies will not change anyway.  It will not become more difficult or easier, although it will be easier for us. <br><br>  The familiar tool can give better results right now, momentarily, but in a more distant future, the simplest solution shows the best results. <br><br><h2>  Side effects </h2><br>  What are the sources of difficulty in our programs?  One of them is side effects.  We cannot completely do without them, but we can localize them.  And the language <i>should</i> help us in this. <br><br>  Clojure is a functional language, it <i>stimulates</i> us to write pure functions.  The result of such functions depends only on the input parameters.  No need to wrestle with "hmm, but what will happen if I run this one before calling this function".  If there is no input, there is a weekend.  No matter how many times we run a function, its result will be the same.  This makes testing very easy.  You do not need to go through different call orders or re-create (simulate) the correct external state. <br><br>  Pure functions are easier to analyze, you can literally play with them, see how they behave on live data.  Easier to debug the code.  We can always reproduce the problem with the pure function - it is enough to pass to it the input parameters that cause an error, because the result of the function does not depend on what was performed before.  Pure functions are extremely simple, even if they do a lot of work. <br><br>  Of course, Clojure supports higher order functions and their composition. <br><br><pre> <code class="hljs php">((juxt dec inc) <span class="hljs-number"><span class="hljs-number">1</span></span>) ; =&gt; [<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>] ((comp str *) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) ; =&gt; <span class="hljs-string"><span class="hljs-string">"6"</span></span> (map (partial * <span class="hljs-number"><span class="hljs-number">10</span></span>) [<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>]) ; =&gt; [<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span>] (map (comp inc inc) [<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>]) ; =&gt; [<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>]</code> </pre><br><br>  Clojure is not a pure language, and functions can have side effects.  For example, <code>println</code> is a function call, an action.  It is important that the very essence of such functions lies in interaction with the outside world.  Print the value to a file, send an HTTP request, execute SQL - all these actions are meaningless apart from the side effect they create.  Therefore, it is very useful to separate such functions (clean and dirty). <br><br>  But they (dirty functions) do not possess a state.  They only serve as a means of interaction with the outside world.  As we will see, Clojure separates the state of our program with mediated references. <br><br><h2>  Immunity </h2><br>  <i>All</i> data structures in Clojure are immutable.  There is no way to change the vector element.  All we can do is create a <i>new</i> vector for which one element will be changed.  A very important point is that Clojure preserves the algorithmic complexity (in time and memory) for all standard operations on collections.  Well, almost, instead of O (1) for vectors, we have O (lg <sub>32</sub> (N)).  In practice, for even collections of millions of elements, lg <sub>32</sub> (N) does not exceed 5. <br><br>  Such complexity is achieved through the use of <a href="http://en.wikipedia.org/wiki/Persistent_data_structure">persistent collections</a> .  The idea is that with the ‚Äúchange‚Äù of the structure, the old version and the new one share most of the internal data.  At the same time, the old version remains fully operational.  Moreover, we have access to <b>all versions of the</b> structure.  This is an important point.  Of course, unnecessary versions will be collected by the garbage collector. <br><br><pre> <code class="hljs ruby">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-function"> [1 2 3 4 5 6 7 8]) ;</span></span> a -&gt; [<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>] (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">b</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(assoc a </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">999</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>) ;b -&gt; [<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">999</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>]</code> </pre><br><br>  Out of the box, Clojure supports single-linked lists, vectors, hash tables, red-black trees.  There is an implementation of a persistent queue (for the stack, you can use a list or vector).  And everything is immutable.  For better performance, you can create your own record types. <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defrecord</span></span> Color [red green blue]) (<span class="hljs-name"><span class="hljs-name">def</span></span> a (<span class="hljs-name"><span class="hljs-name">Color</span></span>. <span class="hljs-number"><span class="hljs-number">0.5</span></span> <span class="hljs-number"><span class="hljs-number">0.6</span></span> <span class="hljs-number"><span class="hljs-number">0.7</span></span>) <span class="hljs-comment"><span class="hljs-comment">; a =&gt; {:red 0.5, :green 0.6, :blue 0.7}</span></span></code> </pre><br><br>  Here we declare a structure with 3 fields.  The Clojure compiler will create an object with 5 fields (2 "extra").  One metadata field, in our case it will be null.  3 fields for the actual data.  And one more field - for additional keys.  Even if to increase the speed in our program, we declare a structure with an explicit enumeration of fields, Clojure still leaves us with the ability to add additional values. <br><br><pre> <code class="hljs ruby">(defrecord Color [red green blue]) (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">b</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(assoc a </span></span><span class="hljs-symbol"><span class="hljs-function"><span class="hljs-params"><span class="hljs-symbol">:alpha</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">.</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>) ; b =&gt; {<span class="hljs-symbol"><span class="hljs-symbol">:alpha</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:red</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:green</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:blue</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>}</code> </pre><br><br>  And yes, there is a special syntax for data structures in Clojure: <br><br><pre> <code class="hljs objectivec">;  [<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>] ; - {:x <span class="hljs-number"><span class="hljs-number">1</span></span>, :y <span class="hljs-number"><span class="hljs-number">2</span></span>} ;  <span class="hljs-meta"><span class="hljs-meta">#{</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"a"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"b"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"c"</span></span></span><span class="hljs-meta">}</span></span></code> </pre><br><br><h2>  condition </h2><br>  So, we have pure functions, they define the business logic of our application.  There are dirty functions that serve to interact with external systems (sockets, database, web-server).  And there is an <b>internal</b> state of our system, which is stored in Clojure as indirect references. <br><br>  There are 4 types of standard links: <br><ul><li>  <code>var</code> is an analogue of thread-local variables, used to set context data: current database connection, current HTTP request, precision parameters for mathematical expressions, and the like; </li><li>  <code>atom</code> - an <a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/atomic/AtomicReference.html">atomic cell</a> , allows updating the state <i>synchronously, but not coordinatedly</i> ; </li><li>  <code>agent</code> - a lightweight analogue for actor (although, in a sense, they are antipodes, more on this below), are used for <i>asynchronous</i> work with the state; </li><li>  <code>ref</code> - transactional memory cells, provides <i>synchronous and coordinated</i> work with the state. </li></ul><br><br>  All global variables are stored in <code>var</code> (including functions).  Therefore, they can be redefined ‚Äúlocally‚Äù. <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">def</span></span> ^<span class="hljs-symbol"><span class="hljs-symbol">:dynamic</span></span> *a* <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">println</span></span> a) <span class="hljs-comment"><span class="hljs-comment">; =&gt; 1 (binding [a 42] (println a)) ; =&gt; 42</span></span></code> </pre><br><br>  Here we indicated to the compiler that the variable <code>a</code> should be dynamic, i.e.  stored inside <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/ThreadLocal.html">ThreadLocal</a> .  Using <code>ThreadLocal</code> reduces performance somewhat, so it does not apply to all <code>var</code> cells by default.  But, if necessary, any <code>var</code> cell can be made dynamic after creation (which is often used in tests). <br><br>  In tests, you can replace entire functions. <br><br><pre> <code class="hljs lua">;     ,   .. (defn some-<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">with</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">side</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">effect</span></span></span><span class="hljs-function"> [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-function">] ...)</span></span> ;       (defn another-<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-function">] ...)</span></span> (deftest just-a-test ... (binding [some-<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">with</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">side</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">effect</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn [x] ...)</span></span></span></span>] ;  mock- (another-<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> 123)</span></span>) ...)</code> </pre><br><br>  All references in Clojure support the <code>deref</code> operation (get value).  For <code>var</code> cells, it looks like this: <br><br><pre> <code class="hljs sql">;   <span class="hljs-comment"><span class="hljs-comment">#'a (def a 123) (println a) ; =&gt; 123 (println #'a) ; =&gt; #'user/a (println (deref #'a)) ; =&gt; 123</span></span></code> </pre><br><br>  The cell stores the value (immutable), but at the same time is itself a separate entity.  A special syntax has <code>deref</code> introduced for the <code>deref</code> function (yes, this is just sugar).  Here is an example of using <code>atom</code> . <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">let</span></span> [x (<span class="hljs-name"><span class="hljs-name">atom</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)] (<span class="hljs-name"><span class="hljs-name">println</span></span> @x) <span class="hljs-comment"><span class="hljs-comment">; =&gt; 0 (swap! x inc) ; CAS- (println @x)) ; =&gt; 1</span></span></code> </pre><br><br>  <code>swap!</code> function <code>swap!</code>  accepts atom and "mutates" function.  The latter takes the current value of the atom, and must return a new one.  This is where the persistent data structures come in very handy.  For example, we can store a vector of a million elements in an atom, but the ‚Äúmutated‚Äù function will be performed fairly quickly for <a href="http://en.wikipedia.org/wiki/Compare-and-swap">CAS</a> (we remember that the complexity of operations on persistent collections is the same as for ordinary, mutable).  Or we can update a couple of fields in the hash table: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">def</span></span> user (<span class="hljs-name"><span class="hljs-name">atom</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:login</span></span> <span class="hljs-string"><span class="hljs-string">"theuser"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:email</span></span> <span class="hljs-string"><span class="hljs-string">"theuser@example.com"</span></span>})) (<span class="hljs-name"><span class="hljs-name">swap!</span></span> account assoc <span class="hljs-symbol"><span class="hljs-symbol">:phone</span></span> <span class="hljs-string"><span class="hljs-string">"12345"</span></span>) <span class="hljs-comment"><span class="hljs-comment">;    (swap! account (fn [x] (assoc x :phone "12345")))</span></span></code> </pre><br><br>  It is important that the function is clean, since it can be executed several times.  We cannot (should not!) Write something like: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">swap!</span></span> x (<span class="hljs-name"><span class="hljs-name">fn</span></span> [x] (<span class="hljs-name"><span class="hljs-name">insert-new-record-to-db</span></span> x) (<span class="hljs-name"><span class="hljs-name">inc</span></span> x)))</code> </pre><br><br><h2>  Agents </h2><br>  Agents serve to maintain a condition that is directly related to side effects.  The idea is simple.  We have a cell, a queue of functions is ‚Äúattached‚Äù to it.  Functions are alternately applied to the value that is stored in this cell, the result of the function becomes the new value.  Everything is calculated asynchronously in a separate thread pool. <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">def</span></span> a (<span class="hljs-name"><span class="hljs-name">agent</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-comment"><span class="hljs-comment">;   (send a inc) (println @a) ; =&gt; 1 (send a (fn [x] (Thread/sleep 100) (inc x))) (println @a) ; =&gt; 1 ;  100  (println @a) ; =&gt; 2</span></span></code> </pre><br><br>  Agents update their value asynchronously.  But we can at any time know the status of the agent.  Agents can send messages to each other, when sending a message is delayed until the sending agent updates its status.  In other words, if an exception is thrown in one agent, messages sent from it will not be sent anywhere. <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">def</span></span> a (<span class="hljs-name"><span class="hljs-name">agent</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">def</span></span> b (<span class="hljs-name"><span class="hljs-name">agent</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">send</span></span> a (<span class="hljs-name"><span class="hljs-name">fn</span></span> [x] (<span class="hljs-name"><span class="hljs-name">send</span></span> b inc) <span class="hljs-comment"><span class="hljs-comment">;    b (throw (Exception. "Error")))) (println @b) ; -&gt; 0,     </span></span></code> </pre><br><br>  It begs some analogy with the <a href="http://en.wikipedia.org/wiki/Actor">model of actors</a> .  They are similar, but there are fundamental differences.  The state of the agents explicitly, at any time you can call <code>deref</code> and get the value of the agent.  This is contrary to the idea of ‚Äã‚Äãactors, where we can find out the state only indirectly, by sending and receiving messages.  In the case of actors, we can‚Äôt even be sure that by querying his condition we will not ‚Äúaccidentally‚Äù change it.  The agent is absolutely reliable in this sense - its state can <i>only</i> be changed <i>by the</i> functions <code>send</code> and <code>send-off</code> (which differ only in the thread pool in which our message will be processed). <br><br>  The second key difference is that agents are open to change and add functionality.  The only way to change the behavior of an actor is to rewrite its code.  Agents are only links, they do not have their own behavior.  We can write a new function and send it to the agent queue. <br><br>  Actors are trying to divide the state of our program into small parts that are easier to smash or isolate.  Updating and status reading operations are reduced to sending messages.  Sometimes this is extremely useful (for example, when running an erlang program on several nodes).  But more often it is not required.  Sometimes even the opposite.  So, in agents it is convenient to store large amounts of information that <i>need to be</i> searched between threads: caches, sessions, intermediate results of mathematical calculations, etc. <br><br>  For the actors, we fix a lot of messages to which he can respond (the rest he considers erroneous).  The order of the messages is also important, as they can potentially lead to side effects.  This is his public contract.  For the agent, we fix only the data that can be stored in it, their structure.  It is very important to emphasize that the agents are <a href="https://github.com/jasongustafson/akka-clojure">not trying to replace</a> the actors at all.  These are different concepts, and their uses differ. <br><br>  As mentioned, agents work asynchronously.  We can build chains of events (sending messages from the agent to the agent).  But with the help of some agents, we will not be able to change the state of our program in a <i>coordinated manner</i> . <br><br><h2>  STM </h2><br>  Software transactional memory is one of the key features of Clojure.  Implemented by <a href="http://en.wikipedia.org/wiki/Multiversion_concurrency_control">MVCC</a> .  And immediately an example: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">def</span></span> account1 (<span class="hljs-name"><span class="hljs-name">ref</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>) (<span class="hljs-name"><span class="hljs-name">def</span></span> account2 (<span class="hljs-name"><span class="hljs-name">ref</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">dosync</span></span> (<span class="hljs-name"><span class="hljs-name">alter</span></span> account1 - <span class="hljs-number"><span class="hljs-number">30</span></span>) (<span class="hljs-name"><span class="hljs-name">alter</span></span> account2 + <span class="hljs-number"><span class="hljs-number">30</span></span>))</code> </pre><br><br>  We increase one value and simultaneously reduce the other.  If something goes wrong (the exception), then the <i>entire</i> transaction will be canceled: <br><br><pre> <code class="hljs php">(println @account1) ; =&gt; <span class="hljs-number"><span class="hljs-number">70</span></span> (println @account2) ; =&gt; <span class="hljs-number"><span class="hljs-number">30</span></span> (dosync (alter account1 * <span class="hljs-number"><span class="hljs-number">0</span></span>) (alter account2 / <span class="hljs-number"><span class="hljs-number">0</span></span>)) ; =&gt; ArithmeticException ;    (println @account1) ; =&gt; <span class="hljs-number"><span class="hljs-number">70</span></span> (println @account2) ; =&gt; <span class="hljs-number"><span class="hljs-number">30</span></span></code> </pre><br><br>  Very similar to the usual ACID, but without Durability.  When entering a transaction, all links seem to be frozen, their values ‚Äã‚Äãare fixed for the duration of the entire transaction.  If, when reading / writing a link, it is found that it has already changed its value (another transaction has completed and spoiled our life), then the current transaction is restarted.  Therefore, there should be no side effects inside the transaction (I / O, work with atoms).  And then the agents are at an opportune moment. <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">def</span></span> a (<span class="hljs-name"><span class="hljs-name">ref</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">def</span></span> b (<span class="hljs-name"><span class="hljs-name">ref</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">def</span></span> out-agent (<span class="hljs-name"><span class="hljs-name">agent</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">dosync</span></span> (<span class="hljs-name"><span class="hljs-name">println</span></span> <span class="hljs-string"><span class="hljs-string">"transaction"</span></span>) (<span class="hljs-name"><span class="hljs-name">alter</span></span> a inc) <span class="hljs-comment"><span class="hljs-comment">;      (let [a-value @a b-value @b] (send-off out-agent (fn [_] (println "a" a-value "b" b-value)))) (alter b dec)) ;     </span></span></code> </pre><br><br>  All messages for agents adhere to the moment when the transaction is completed.  In our example, changing the references <code>a</code> and <code>b</code> may result in restarting the transaction, the word ‚Äútransaction‚Äù may be typed several times.  But the code inside the agent will be executed exactly once, and after the transaction is completed. <br><br>  To keep various transactions from interfering with each other as little as possible, Clojure's links store a history of values.  By default, this is only the last value, but when a conflict occurs (one transaction writes and the other reads), then for a specific reference the size of the stored history is increased by one (up to 5 values).  Do not forget that we store in the links persistent structures that share common structural elements.  Therefore, storing such a story in Clojure is very cheap in terms of memory consumption. <br><br>  STM transactions do not prevent us from changing our code.  There is no need to analyze whether it is possible to use this or that link in the current transaction.  They are all accessible, and we can add new links completely transparent to existing code.  Links do not interact with each other.  For example, when using ordinary locks, we need to follow the lock / unlock order in order not to cause a deadlock. <br><br>  With concurrent access, reader transactions do not block each other, just like when using <a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/locks/ReadWriteLock.html">ReadWriteLock</a> .  Moreover, transaction-writers do not block readers!  Even if a transaction is currently being executed that changes the link, we can get the value without blocking. <br><br>  Agents and STM links complement each other.  The former are not suitable for coordinated change of state, the latter do not allow working with side effects.  But their sharing makes our programs more transparent and simpler (less confusing) than when using ‚Äúclassical‚Äù means (mutexes, semaphores, and the like). <br><br><h2>  Metaprogramming </h2><br>  Now many languages ‚Äã‚Äãhave certain metaprogramming tools.  These are <a href="http://en.wikipedia.org/wiki/AspectJ">AspectJ</a> for Java, AST-transformation for Groovy, decorators and metaclasses for Python, various reflections. <br><br>  Clojure, as a member of the Lisp family, uses macros for this purpose.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With their help, we can program (expand) a language with the means of the language itself. </font><font style="vertical-align: inherit;">A macro is an ‚Äúordinary‚Äù function, with the only difference being that it is executed during the compilation of the program. </font><font style="vertical-align: inherit;">The not yet compiled code is transferred to the macro input, the result of the macro execution is a new code that the compiler is already compiling.</font></font><br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defmacro</span></span> unless [pred ab] `(if (not ~pred) ~a ~b)) (<span class="hljs-name"><span class="hljs-name">unless</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>) (<span class="hljs-name"><span class="hljs-name">println</span></span> <span class="hljs-string"><span class="hljs-string">"1 &gt; 10. ok"</span></span>) (<span class="hljs-name"><span class="hljs-name">println</span></span> <span class="hljs-string"><span class="hljs-string">"1 &lt; 10. wat"</span></span>))</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have created our own control structure (inverse version </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">All you need to do is write a function! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Macros are used extensively in Clojure. </font><font style="vertical-align: inherit;">By the way, many of the operators built into the language are actually macros. </font><font style="vertical-align: inherit;">For example, here is the implementation </font></font><code>or</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defmacro</span></span> or ([] <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) ([x] x) ([x &amp; next] `(let [or# ~x] (if or# or# (or ~@next)))))</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even </font></font><code>defn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">just a macro unfolding in </font></font><code>def</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>fn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">By the way, destructuring is also implemented using macros.</font></font><br><br><pre> <code class="hljs lua">(let <span class="hljs-string"><span class="hljs-string">[[ab] [1 2]]</span></span> (+ ab)) ;   - ... (let* [vec__123 [<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>] a (clojure.core/nth vec__123 <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) b (clojure.core/nth vec__123 <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)] (+ ab))</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recently appeared in Java </font></font><a href="http://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">try-with-resources</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In this 7th version of Java, we waited only a few years. For Clojure, just write a few lines:</font></font><br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defmacro</span></span> with-open [[vr] &amp; body] `(let [~r ~v] (try ~@body (finally (.close ~v)))))</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In other languages, the situation is better, but still far from ideal. It is important not the presence of a particular construct in the language, but the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ability to add</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> your own. Therefore, it is not surprising that, say, pattern matching for Clojure is implemented as a separate </font></font><a href="https://github.com/clojure/core.match"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plug-in library</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . There is simply no need to include such things in the core of the language, it is much more expedient to implement them in the form of a macro. The situation is similar with </font></font><a href="https://github.com/clojure/algo.monads"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">monad support</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://github.com/clojure/core.logic"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">logical programming</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://github.com/scgilardi/slingshot"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">advanced error handling</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and other language extensions. There is even </font></font><a href="https://github.com/clojure/core.typed"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an optional static typing</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Not to mention the convenience of creating a DSL. For Clojure, they created a lot. This and</font></font><a href="https://github.com/weavejester/hiccup"> HTML</a> ,  <a href="https://github.com/weavejester/compojure"> HTTP-</a> ,    <a href="http://sqlkorma.com/"></a> <a href="http://clojureql.org/"></a> <a href="https://bitbucket.org/anjensan/azql"></a> ,    <a href="https://github.com/ztellman/gloss"> </a> ,  <a href="https://github.com/leonardoborges/bouncer"> </a> ‚Ä¶      (      ). <br><br> Clojure (   Lisp- )     ‚Äî  <a href="http://en.wikipedia.org/wiki/Homoiconicity"></a> .  ,         ,    <i></i>       AST-,     .      -  ,   ,   .         ,     . <br><br><pre> <code class="hljs swift">(defn do2 [x] (list '<span class="hljs-keyword"><span class="hljs-keyword">do</span></span> xx)) (do2 '(<span class="hljs-built_in"><span class="hljs-built_in">println</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>)) ; =&gt; '(<span class="hljs-keyword"><span class="hljs-keyword">do</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">println</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-built_in"><span class="hljs-built_in">println</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>)) ;   ; =&gt; (list '<span class="hljs-keyword"><span class="hljs-keyword">do</span></span> (list '<span class="hljs-built_in"><span class="hljs-built_in">println</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) (list '<span class="hljs-built_in"><span class="hljs-built_in">println</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>))</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For all its power, macros in Clojure do not degrade the readability of the program (unless, of course, using them in moderation). After all, a macro is just a function, and we can always uniquely determine which function is used in the current context. For example, if we see the code </font></font><code>(dosomething [ab] c)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it is easy to find out what is behind the name </font></font><code>dosomething</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, just look at the beginning of the file (where the import of other modules occurs). If this is a macro, then its semantics is constant and known. We do not need advanced IDE to understand this code. Although, of course, advanced development environments are able to "deploy" the macro in place, allowing you to see what the program will turn into a compiler.</font></font><br><br><h2>  Polymorphism </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clojure has 2 mechanisms for creating polymorphic functions. </font><font style="vertical-align: inherit;">Initially, the language was supported only by multimethods - a powerful tool, but most often redundant. </font><font style="vertical-align: inherit;">Starting with version 1.2 (and version 1.5.1 is currently relevant) a new concept has been added to the language - protocols. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protocols are similar to Java interfaces, but cannot inherit each other. </font><font style="vertical-align: inherit;">Each protocol describes a set of functions.</font></font><br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defprotocol</span></span> IShowable (<span class="hljs-name"><span class="hljs-name">show</span></span> [this])) <span class="hljs-comment"><span class="hljs-comment">; ... (map show [1 2 3])</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By this we declare 2 entities - the protocol itself, as well as the function </font></font><code>show</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is the usual Clojure function, which, when it is called, searches for the most appropriate implementation based on the type of the first argument. </font><font style="vertical-align: inherit;">Separately, we declare the necessary data structures, and specify the protocol implementation for them.</font></font><br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defrecord</span></span> Color [red green blue] IShowable (<span class="hljs-name"><span class="hljs-name">show</span></span> [this] (<span class="hljs-name"><span class="hljs-name">str</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;R"</span></span> (<span class="hljs-symbol"><span class="hljs-symbol">:red</span></span> this) <span class="hljs-string"><span class="hljs-string">" G"</span></span> (<span class="hljs-symbol"><span class="hljs-symbol">:green</span></span> this) <span class="hljs-string"><span class="hljs-string">" B"</span></span> (<span class="hljs-symbol"><span class="hljs-symbol">:blue</span></span> this))))</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can implement a protocol for third-party type (even built-in). </font></font><br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">extend-protocol</span></span> IShowable String (<span class="hljs-name"><span class="hljs-name">show</span></span> [this] (<span class="hljs-name"><span class="hljs-name">str</span></span> <span class="hljs-string"><span class="hljs-string">"string "</span></span> this)) clojure.lang.IPersistentVector (<span class="hljs-name"><span class="hljs-name">show</span></span> [this] (<span class="hljs-name"><span class="hljs-name">str</span></span> <span class="hljs-string"><span class="hljs-string">"vector "</span></span> this)) Object (<span class="hljs-name"><span class="hljs-name">show</span></span> [this] <span class="hljs-string"><span class="hljs-string">"WAT"</span></span>)) (<span class="hljs-name"><span class="hljs-name">show</span></span> <span class="hljs-string"><span class="hljs-string">"123"</span></span>) <span class="hljs-comment"><span class="hljs-comment">; =&gt; "string 123" (show [1 2 3]) ; =&gt; "vector [1 2 3]" (show '(1 2 3)) ; =&gt; "WAT"</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can add the implementation of the protocols to the already existing types, even if we do not have access to the source codes. There is no magical manipulation with baytkodom or similar tricks. Clojure creates a global table </font></font><code> -&gt;  </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; when you call a protocol method, the </font><font style="vertical-align: inherit;">table </font><font style="vertical-align: inherit;">is searched for by the type of the first argument, taking into account the hierarchy. Thus, the declaration of the new implementation for the protocol is reduced to updating the global table. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But sometimes protocols are not enough. For example, </font></font><a href="http://en.wikipedia.org/wiki/Double_dispatch"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for double dispatch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In this (and not only) cases, </font><i><font style="vertical-align: inherit;">multimethods</font></i><font style="vertical-align: inherit;"> will be useful to us.</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">When declaring a multimethod, we indicate a special side function dispatcher. </font><font style="vertical-align: inherit;">Dispatcher receives the same arguments as the multimethod. </font><font style="vertical-align: inherit;">The search for the final implementation is already on the value that returned dispatcher. </font><font style="vertical-align: inherit;">This can be a type, keyword or vector. </font><font style="vertical-align: inherit;">In the case of a vector, the most suitable implementation is searched for by several values.</font></font><br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defmulti</span></span> convert (<span class="hljs-name"><span class="hljs-name">fn</span></span> [obj target-type] [(<span class="hljs-name"><span class="hljs-name">class</span></span> obj) target-type])) (<span class="hljs-name"><span class="hljs-name">defmethod</span></span> convert [String Integer] [x _] (<span class="hljs-name"><span class="hljs-name">Integer/parseInt</span></span> x)) (<span class="hljs-name"><span class="hljs-name">defmethod</span></span> convert [String Long] [x _] (<span class="hljs-name"><span class="hljs-name">Long/parseLong</span></span> x)) (<span class="hljs-name"><span class="hljs-name">defmethod</span></span> convert [Object String] [x _] (.toString x)) (<span class="hljs-name"><span class="hljs-name">defmethod</span></span> convert [java.util.List String] [x _] (<span class="hljs-name"><span class="hljs-name">str</span></span> <span class="hljs-string"><span class="hljs-string">"V"</span></span> (<span class="hljs-name"><span class="hljs-name">vec</span></span> x))) (<span class="hljs-name"><span class="hljs-name">convert</span></span> <span class="hljs-string"><span class="hljs-string">"123"</span></span> Integer) <span class="hljs-comment"><span class="hljs-comment">; -&gt; 123 (convert "123" Long) ; -&gt; 123 (convert 123 String) ; -&gt; "123" (convert [1 2 3] String) ; -&gt; "V[1 2 3]"</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we have declared an abstract function, the implementation of which is selected based on the type of the first argument and the value of the second (this should be a class). </font><font style="vertical-align: inherit;">Of course, Clojure considers the type hierarchy when searching for a suitable implementation. </font><font style="vertical-align: inherit;">It is convenient to use types, but their hierarchy is strictly fixed. </font><font style="vertical-align: inherit;">But we can create our own ad-hoc hierarchy of keywords.</font></font><br><br><pre> <code class="hljs ruby">;   <span class="hljs-string"><span class="hljs-string">"-"</span></span> (derive <span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:rect</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:shape</span></span>) (derive <span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:square</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:rect</span></span>) (derive <span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:circle</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:shape</span></span>) (derive <span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:triangle</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:shape</span></span>) (defmulti perimeter <span class="hljs-symbol"><span class="hljs-symbol">:type</span></span>) ;       ,  <span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> ~ (fn [x] (<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> x)) (defmethod perimeter <span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:rect</span></span> [x] (* <span class="hljs-number"><span class="hljs-number">2</span></span> (+ (<span class="hljs-symbol"><span class="hljs-symbol">:hx</span></span>) (<span class="hljs-symbol"><span class="hljs-symbol">:wx</span></span>)))) (defmethod perimeter <span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:triangle</span></span> [x] (reduce + ((juxt <span class="hljs-symbol"><span class="hljs-symbol">:a</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:b</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:c</span></span>) x))) (defmethod perimeter <span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:circle</span></span> [x] (* <span class="hljs-number"><span class="hljs-number">2</span></span> Math/PI (<span class="hljs-symbol"><span class="hljs-symbol">:rx</span></span>))) (perimeter {<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:rect</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:h</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:w</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>}) ; -&gt; <span class="hljs-number"><span class="hljs-number">26</span></span> (perimeter {<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:square</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:h</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:w</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>}) ; -&gt; <span class="hljs-number"><span class="hljs-number">40</span></span> (perimeter {<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:triangle</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:a</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:b</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:c</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>}) ; -&gt; <span class="hljs-number"><span class="hljs-number">12</span></span> (perimeter {<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:shape</span></span>}) ; -&gt; throws IllegalArgumentException</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hierarchies can declare several. </font><font style="vertical-align: inherit;">As well as with types, it is possible to carry out dispatching on several values ‚Äã‚Äãat once (vector). </font><font style="vertical-align: inherit;">When specifying your own hierarchies, you can even mix keywords and Java types!</font></font><br><br><pre> <code class="hljs css">(<span class="hljs-selector-tag"><span class="hljs-selector-tag">derive</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.util</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Map</span></span> <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::collection)</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">derive</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.util</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Collection</span></span> <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::collection)</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">derive</span></span> <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::tag</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Iterable</span></span>) ; <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">ClassCastException</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can ‚Äúinherit‚Äù the type from keyword (but not vice versa). </font><font style="vertical-align: inherit;">This is useful for creating groups of classes open for extension. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The system of multimethods is simple, but at the same time extremely powerful. </font><font style="vertical-align: inherit;">Usually, there is enough protocol functionality for everyday needs, but multimethods can be an excellent way out in difficult and unusual situations.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Common sense </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Language means nothing without infrastructure. Without a community, a set of libraries, frameworks, various kinds of utilities. One of the strengths of Clojure is the use of the JVM platform. Integration with Java (in both directions) is extremely simple. It's no secret that there is just a huge number of libraries for Java (we will not discuss their quality). They can all be </font><font style="vertical-align: inherit;">used </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">directly</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from Clojure. Although the number of native libraries </font></font><a href="https://clojars.org/projects"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is large enough</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (and constantly growing). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plug-ins for </font></font><a href="http://code.google.com/p/counterclockwise/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eclipse</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://github.com/JetBrains/la-clojure"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDEA are</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> actively developing </font><font style="vertical-align: inherit;">. For the assembly of projects, the </font></font><a href="http://leiningen.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">leiningen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utility </font><font style="vertical-align: inherit;">used by the entire community </font><font style="vertical-align: inherit;">has long been the de facto standard </font><font style="vertical-align: inherit;">. There are a variety of frameworks to </font></font><a href="http://www.webnoir.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">create</font></font></a> <a href="http://www.joodoweb.com/">WEB</a> ,   <a href="https://github.com/ztellman/aleph"> </a> <br><br>    <a href="http://immutant.org/">Immutant</a> (  <a href="http://www.jboss.org/as7">JBoss AS7</a> ). Immutant      Ring (HTTP   Clojure),  ,  ,    ,  ,    .      Immutant  . <br><br>  Clojure    ,    <a href="https://github.com/richhickey/clojure-clr">.Net CLR</a> . ,   ,     <a href="https://github.com/clojure/clojurescript">ClojureScript</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, port for javascript. </font><font style="vertical-align: inherit;">Of course, there are no means of multithreading, and, as a result, transactional memory and agents. </font><font style="vertical-align: inherit;">But all other language tools are available, including persistent structures, macros, protocols, and multimethods. </font><font style="vertical-align: inherit;">And the integration between ClojureScript and JavaScript is as good and simple as between Clojure and Java (and even better in some places).</font></font><br><br><h2>  What's next? </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And then everything is simple. </font><font style="vertical-align: inherit;">We have a tool. </font><font style="vertical-align: inherit;">Worker, reliable. </font><font style="vertical-align: inherit;">Not a silver bullet, but quite versatile.</font></font> Plain.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yes, you may have to spend some time to master it. </font><font style="vertical-align: inherit;">Much may seem unusual and strange. </font><font style="vertical-align: inherit;">But this is just a matter of habit, you quickly understand - the whole beauty of the language is in its organicity, the fine joining of individual elements into a single whole. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get to know Clojure is worth it.</font></font> Definitely.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Even if this tool does not suit you for one reason or another, the ideas that are in it will be very useful. </font></font></div><p>Source: <a href="https://habr.com/ru/post/173071/">https://habr.com/ru/post/173071/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../173049/index.html">Data preprocessing and model analysis</a></li>
<li><a href="../173059/index.html">Oracle ADF. Business Components</a></li>
<li><a href="../173063/index.html">Moving and renaming files in GitHub</a></li>
<li><a href="../173065/index.html">The digest of news from the world of mobile development for the last week ‚Ññ6 (March 11 - 17, 2013)</a></li>
<li><a href="../173067/index.html">Application security: it's almost simple</a></li>
<li><a href="../173073/index.html">Is the interface evil?</a></li>
<li><a href="../173075/index.html">Chromebook Pixel: it's easy to disassemble, it's impossible to upgrade</a></li>
<li><a href="../173079/index.html">Google Glass has already received official opponents</a></li>
<li><a href="../173081/index.html">More than 500,000 Google Reader users switched to Feedly in two days</a></li>
<li><a href="../173083/index.html">Social networking applications are starting to make money.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>