<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Google Cloud Messaging: ‚ÄúOwl, discover! Push has come! ‚Äù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The well-known service Google Cloud Messaging (GCM) is needed to ensure that your application always shows actual data to the user. The scheme of the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Google Cloud Messaging: ‚ÄúOwl, discover! Push has come! ‚Äù</h1><div class="post__text post__text-html js-mediator-article">  The well-known service Google Cloud Messaging (GCM) is needed to ensure that your application always shows actual data to the user.  The scheme of the service includes three components. <br><br><img src="https://habrastorage.org/files/dbc/319/af8/dbc319af88a14f518086b1dbfeca4315.jpg"><br><br>  Directly GCM server, your push server and device with an installed application.  The operation algorithm is simple: the device registers with the GCM, receives the <b>registrationId</b> ‚Äî a certain token that is used later ‚Äî stores it locally and sends it to the server.  Next, the push server uses this registrationId to send messages to your application on the device. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This material will address the problems at two sites, which are indicated in the diagram: push server - GCM and GCM - device. <br><a name="habracut"></a><br><h1>  Error handling from GCM server </h1><br>  If the message is successfully sent, your push server will receive a response from GCM with status code 200 and a non-zero <b>message_id</b> . <br><br><img src="https://habrastorage.org/files/4de/258/dad/4de258dad5de4800a0fb39ce862e0c59.jpg"><br><br>  Errors come in the response body with the status code 200. Therefore, relying only on the status code 200 is not enough.  Here I will give an example of one of the most important errors, these are <b>NotRegistered</b> , others less interesting.  In most cases, it means that the application to which your push server sends a message has been deleted, or the application already uses another registrationId, and for some reason your push server does not know about it.  Having received such a response from GCM, the push server should immediately remove the given registrationId from its repository. <br>  To monitor errors, enable GCM statistics in the developer console. <br><br><h1>  Synchronization of registrationId on the client and push server </h1><br>  <b>RegistrationId</b> is one of the most important parts of the GCM infrastructure.  Disregarding the <b>registrationId</b> between the client and the push server will have dire consequences.  There is every chance that users will remain without push-notifications forever.  GCM monitors the situation when the <b>registrationId is</b> updated on the device for some reason, and reports this to the push server using the <b>canonical_ids</b> parameter. <br><br><img src="https://habrastorage.org/files/324/c9e/4d7/324c9e4d78694f1ba2bea0707975482b.jpg"><br><br>  A case with <b>canonical_ids</b> can be reproduced as follows: <br><ol><li>  Install the application </li><li>  Send a message to him </li><li>  Remove the application </li><li>  Install the application </li><li>  Send a message to him </li></ol><br>  After sending the message in step 5, you will receive a response from GCM with the <b>canonical_ids</b> parameter equal to 1 and the fresh <b>registrationId</b> directly, which is already being used by your client. <br><br><img src="https://habrastorage.org/files/11c/4eb/f30/11c4ebf304244971adec682677d7b800.jpg"><br><br>  Having received such a response, the push server is simply obliged to update the <b>registrationId</b> to the value from the response.  If this is not done, then for some time the messages will reach the client and the old <b>registrationId</b> will be valid, but sooner or later the GCM will respond with a <b>NotRegistered</b> error, after which the push server will delete the <b>registrationId</b> and users will forget about the push notifications in your application .  Therefore, handle the parameter <b>canonical_ids</b> and do not bring to sin. <br><br><h1>  Two main approaches to working with GCM </h1><br>  The first is <b>Messages with Payload</b> .  Its essence is to convey some useful information in the message itself.  For example, in the messenger it may be the text of the message, in the news application - the news itself.  The second mechanism is <b>Send-to-Sync</b> .  It is more optimized for traffic consumption, because  The message itself does not pack a lot of data.  The message acts as a signal that the application should pick up fresh data from the server.  The second approach is directly related to the <b>collapse_key</b> parameter. <br><br><h3>  Messages with Payload </h3><br>  The ideal situation is when your device holds a connection to the GCM server, messages are sent and successfully delivered to the device.  If there is no connection (for example, you are stuck in a bodice or entered the subway), and messages are being sent to you at this time, then they begin to form a queue in the GCM storage.  This queue is not infinite, the limit is 100 messages.  As soon as 101 messages arrive, they all disappear and no longer accumulate.  When the device catches the network and establishes a connection with GCM, an intent will come into the application with information about what has been deleted, for example, 345 messages. <br><br><img src="https://habrastorage.org/files/a52/167/0c7/a521670c77094700b8b4656a35515767.jpg"><br><br>  Having received such an intent, you need not be lazy and go to the server for fresh data.  Otherwise, the user will see them only when another push notification arrives, and when it comes, nobody knows.  This is a very important point to remember when implementing the ‚ÄúMessages with Payload‚Äù approach. <br><br><h3>  Send-to-sync </h3><br>  Let's say we use <b>collapse_key</b> .  This is a kind of constant, which can be no more than four for one registrationId, i.e.  for one instance of the application.  For example, a news application collects some data from different services.  Let one server give sports news, another - culture, the third - policy, the fourth - auto.  There will be a problem, of course, when the fifth service appears, but now this is not the point.  In sending a message for the appropriate column, you can use your <b>collapse_key</b> : sport, culture, policy, auto. <br><br>  When the next message arrives with the same <b>collapse_key,</b> GCM replaces the old message with the new one.  In principle, it is logical, since  we remember that the message in the ‚ÄúSend-to-Sync‚Äù approach is only a signal to our application that we should go to the server for fresh data.  But here we were lurked by one unpleasant moment, because of which we had to abandon the ‚ÄúSend-to-Sync‚Äù approach - trotting.  Trotling is that the GCM server can wait some time to collect as many messages as possible with the same <b>collapse_key</b> .  Everything would be fine, but this introduces a delay in the delivery of the message to the client (consistently noticed a delay of half a minute-minute), which is unacceptable for some types of applications, for example, the messenger. <br><br><img src="https://habrastorage.org/files/ee1/578/1d2/ee15781d25cb4369b7c657101fe040b7.jpg"><br><br>  Because of this delay, we stopped using <b>collapse_key</b> .  If your application doesn‚Äôt have a small delay in message delivery, then the Send-to-Sync approach is a good choice. <br><br>  Over time, we took into account all the above details in the implementation of our push server.  But still there was a large number of reviews with something like this: ‚ÄúI see new messages only when I go to the application.  When it is not running, messages do not reach me !!! ‚Äù.  At first, the main hypothesis was the registrationId desynchronization stored on the device and on the push server.  To confirm it, we installed a check on the device, the essence of which is that the application periodically asked the push server: ‚ÄúDo you have my registratioinId?‚Äù.  The answer "yes" guarantees us with a high probability that the registrationId is up to date. <br><br><img src="https://habrastorage.org/files/ab8/d75/bda/ab8d75bda30242e38f01ed705c841e3e.jpg"><br><br>  And according to statistics, the answers are "yes" 99.7%.  Which allowed us to conclude that with registrationId synchronization everything is fine.  Began to look for a problem in the area between the device and the GCM.  Repeatedly witnessed a situation where Samsung S4, forgive me Samsung, turn off the screen, and messages start to arrive with a big delay (about 10 - 15 minutes).  With the help of our network administrators colleagues, it was found that the TCP connection between the device and the GCM became idle, and the packets stopped walking.  The reason for all this is the so-called "heartbeat".  ‚ÄúHeartbeat‚Äù is a sachet (ping) sent by the system once a certain time interval in order to ‚Äúliven up‚Äù a TCP connection between the device and the GCM (you can read more about it <a href="https://productforums.google.com/forum/">here</a> ). <br><br><img src="https://habrastorage.org/files/cee/13d/f6f/cee13df6f40d4a53aa9942a3668d3b88.jpg"><br><br>  And the interval through which heartbeat is sent is quite large.  It seems that in August 2014 it was reduced to 8 minutes, but the information may not be accurate.  The Internet offers a solution that is used in the so-called "push-fixes."  Its essence is to initiate sending a heartbeat-package manually.  But unfortunately, this solution only works for root devices. <br><br><img src="https://habrastorage.org/files/eff/15b/e86/eff15be86aa94fd4a04603cd53b5fb4e.jpg"><br><br>  Optimism to achieve instant message delivery on all devices supported by us (with the exception of the Chinese iPhones on the android) by means of GCM remained less and less.  And the problem with the delay in the delivery of messages must be solved.  The only thing that can guarantee a more or less stable delivery of messages is to keep your own connection with the server.  But first I would like to learn how to identify the devices on which there is a problem with the delay of push messages.  For this purpose, we wrote down the statistics, the essence of which is to compare the difference between the time of the push arrival and the time when the data on the server was ready for the client (when the push was sent).  And the statistics showed that approximately 20% of users experience a delay in the delivery of messages.  But it is rather rough, because  it does not take into account cases with the disappearance of the network and other things.  At the moment we are thinking about the implementation of the following algorithm: <br><ol><li>  Determine whether there is a delay on this device. </li><li>  If yes, then we begin to keep a constant connection with the backend server, no - we continue to use only GCM (in order to save battery). </li></ol><br><img src="https://habrastorage.org/files/396/cac/afc/396cacafca654514b149ddfb715a655a.jpg"><br><br>  Ten minutes taken from the head.  If the delta is greater than the threshold value, then switch the application to the operating mode with its own connection. <br><br><img src="https://habrastorage.org/files/57a/59f/178/57a59f1786d040ecab5bcd002b0522e3.jpg"><br><br>  For experimental purposes, the own connection was implemented using the http long-polling connection, since  It was the fastest way to "try."  Such an assembly was sent to several of our beta users with a request to observe the message delivery and battery consumption.  In general, oddly enough, there was no sharp increase in battery consumption, and users were satisfied with the speed of message delivery.  The topic of implementing your own connection to the backend server deserves a separate article, and we continue to think about the implementation itself. <br><br>  I hope the article will be useful and will reduce your time when using the GCM service, and I will also be happy if you share your experience in solving the problem of the speed of message delivery to the client in your applications. <br><br>  PS For debugging purposes, I wrote a test <a href="http://1-dot-sigma-freedom-752.appspot.com/">push server</a> - maybe someone will come in handy.  The source code is <a href="https://bitbucket.org/azatsepin/gcmpusher">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/260841/">https://habr.com/ru/post/260841/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../260829/index.html">Wheel-indicator - a touchstart emulation plugin when working with trackpads</a></li>
<li><a href="../260831/index.html">Network Interface for BMW</a></li>
<li><a href="../260833/index.html">How and where should SKZI be used - FSB point of view</a></li>
<li><a href="../260837/index.html">Making a home farm for video rendering.</a></li>
<li><a href="../260839/index.html">Metalworking - 2015, part two: welding, roboruki, manipulators, tumbling</a></li>
<li><a href="../260845/index.html">Stream data processing with Akka</a></li>
<li><a href="../260847/index.html">Hosting for business. The story of one move</a></li>
<li><a href="../260849/index.html">WorkFlowSoft - a tool for organizing the work of the company</a></li>
<li><a href="../260851/index.html">Quick helpers for your Asterisk</a></li>
<li><a href="../260855/index.html">How DIY robots will change education by 2035</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>