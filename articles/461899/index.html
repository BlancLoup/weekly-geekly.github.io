<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Event Generation, CQRS and Laravel</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of the article was prepared for students of the professional course "Framework Laravel" 
 



 Introduction 
 This article is devoted to t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Event Generation, CQRS and Laravel</h1><div class="post__text post__text-html js-mediator-article">  <i>Translation of the article was prepared for students of the professional course <a href="https://otus.pw/laCG/">"Framework Laravel"</a></i> <i><br></i> <br><img src="https://habrastorage.org/webt/h8/4u/y5/h84uy5i5spnt3rdmpaiw2aynd0s.png"><br><br><hr><br><h2>  Introduction </h2><br>  This article is devoted to the basics of creating event CQRS-systems in the PHP language and in the Laravel framework.  It is assumed that you are familiar with the development scheme using the command bus and have an idea of ‚Äã‚Äãevents (in particular, the publication of events for an array of listeners).  To refresh this knowledge, you can use the Laracasts service.  In addition, it is assumed that you have a certain understanding of the CQRS principle.  If not, I highly recommend listening to two lectures: <a href="http://verraes.net/2014/03/practical-event-sourcing">Mathias Verraes Workshop on Event Generation</a> and <a href="https://www.youtube.com/watch%3Fv%3DJHGkaShoyNs">Greg Young's CQRS and Event Generation</a> . <br><a name="habracut"></a><br>  Do not use the code given here in your projects!  It is a learning platform for understanding the ideas behind CQRS.  This code cannot be called reliable, it is poorly tested, and in addition, I rarely program interfaces, so it will be much more difficult to change individual parts of the code.  A much better example of a CQRS package you can use is <a href="https://github.com/qandidate-labs/broadway">Broadway, developed by Qandidate Lab</a> .  This is clean, loosely coupled code, however, some abstractions make it not entirely clear if you have never come across event systems. <br><br>  And the last - my code is connected with events and the Laravel command bus.  I wanted to see how the code would look in Laravel (I usually use this framework for projects of small agencies), however, looking back, I think that I should create my own implementations.  I hope my code will be clear even to those who do not use frameworks. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      On github, the code is located at <a href="">https://github.com/scazz/cqrs-tutorial.git</a> , and in our guide we will consider its components for increasing logic. <br><br>  We will create the initial registration system for the surf school.  With its help, school clients can register for classes.  For the recording process, we formulate the following rules: <br><br><ul><li>  Each lesson must have at least one client ... </li><li>  ... but not more than three. </li></ul><br>  One of the most impressive features of event-based CQRS systems is the creation of reading models specific to each metric required by the system.  You'll find examples of projection of reading models in ElasticSearch, and Greg Young has implemented a subject-oriented language in his event store for handling complex events.  However, for simplicity, our read projection will be a standard SQL database for use with Eloquent.  As a result, we will have one table for classes and one for clients. <br><br>  The concept of event generation also allows you to process events offline.  But in this article I will adhere to the ‚Äútraditional‚Äù development models to the maximum (again for simplicity), and our reading projections will be updated in real time, immediately after the events are stored in the repository. <br><br><h2>  Project setup and first test </h2><br><pre><code class="plaintext hljs">git clone https://github.com/scazz/cqrs-tutorial</code> </pre> <br>  Create a new Laravel 5 project <br><br><pre> <code class="plaintext hljs">$&gt; laravel new cqrs-tutorial</code> </pre> <br>  And for starters, we need a test.  We will use the integration test, which will make sure that the client‚Äôs registration for classes leads to the fact that the lesson is created in our Eloquent model. <br><br>  Listing tests / CQRSTest.php: <br><br><pre> <code class="plaintext hljs">use Illuminate\Foundation\Bus\DispatchesCommands; class CQRSTest extends TestCase { use DispatchesCommands;</code> </pre><br><pre> <code class="bash hljs">/** *  ,   BookLesson       * @<span class="hljs-built_in"><span class="hljs-built_in">return</span></span> void */ public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFiringEventUpdatesReadModel</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$testLessonId</span></span> = <span class="hljs-string"><span class="hljs-string">'123e4567-e89b-12d3-a456-426655440000'</span></span>; <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span> = <span class="hljs-string"><span class="hljs-string">"George"</span></span>; <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId(<span class="hljs-variable"><span class="hljs-variable">$testLessonId</span></span>); <span class="hljs-variable"><span class="hljs-variable">$command</span></span> = new BookLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch(<span class="hljs-variable"><span class="hljs-variable">$command</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertNotNull(Lesson::find(<span class="hljs-variable"><span class="hljs-variable">$testLessonId</span></span>)); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertEquals( Lesson::find(<span class="hljs-variable"><span class="hljs-variable">$testLessonId</span></span>)-&gt;clientName, <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span> ); } }</code> </pre> <br>  We preassign the new activity to an ID, create a team to sign up for a new activity, and tell Laravel to send it.  In the lesson table, we need to create a new record that we can read using the Eloquent model.  We need a database, so fill in your .env file properly. <br><br>  Each event registered in our event repository is attached to the root of the aggregate, which we will simply call the entity (Entity) - an abstraction for educational purposes only adds confusion.  ID is a universal unique identifier (UUID).  The event store doesn‚Äôt care if the event applies to the lesson or the client.  He only knows that it is associated with an ID. <br><br>  Based on the errors identified during testing, we can create missing classes.  First, we will create the LessonId class, then the BookLesson command (don‚Äôt worry about the handler method yet, just continue to run the test).  The Lesson class is a reading model outside the Lesson namespace.  An exclusively reading model - the logic of the subject area will never be stored here.  In conclusion, we need to create a migration for the occupation table. <br><br>  To maintain the clarity of the code, I will use the assertion verification library.  It can be added with the following command: <br><br><pre> <code class="plaintext hljs">$&gt; composer require beberlei/assert</code> </pre> <br>  Consider the process that should be initiated by this command: <br><br><ol><li>  Validation: imperative commands may fail, and events have already occurred and therefore should not fail. </li><li>  Create a new LessonWasBooked event (signed up for a lesson). </li><li>  Update the activity status.  (The recording model must be aware of the state of the model so that it can perform validation.) </li><li>  Add this event to the stream of uncommitted events stored in the activity record model. </li><li>  Save the stream of uncommitted events to the repository. </li><li>  Raise the LessonWasBooked event globally to inform all reading projectors of the need to update the lesson table. </li></ol><br>  First you need to create a recording model for the lesson.  <code>Lesson::bookClientOntoNewLesson()</code> use the static factory method <code>Lesson::bookClientOntoNewLesson()</code> .  It generates a new <code>LessonWasOpened</code> event (the lesson is open), applies this event to itself (just sets its ID), adds the new event to the list of uncommitted events in the form of <code>DomainEventMessage</code> (the event plus some metadata that we use when saving to the event store). <br><br>  The process is repeated to add a client to the event.  When applying the <code>ClientWasBookedOntoLesson</code> event (the client was enrolled in the lesson), the recording model does not track client names, but only the number of registered clients.  Record models do not need to know customer names to ensure consistency. <br><br>  The <code>applyLessonWasOpened</code> and <code>applyClientWasBookedOntoLesson</code> methods may seem a bit odd <code>applyClientWasBookedOntoLesson</code> now.  We will use them later when we need to reproduce old events in order to form the state of the recording model.  It‚Äôs not easy to explain, so I‚Äôll give a code that will help you understand this process.  Later we will extract the code that processes uncommittedEvents and generates domain event messages. <br><br><pre> <code class="bash hljs">app/School/Lesson/Lesson.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> openLesson( LessonId <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> ) { /*      ,      ,       */ <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;apply( new LessonWasOpened( <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>) ); } protected <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> applyLessonWasOpened( LessonWasOpened <span class="hljs-variable"><span class="hljs-variable">$event</span></span> ) { <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;lessonId = <span class="hljs-variable"><span class="hljs-variable">$event</span></span>-&gt;getLessonId(); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;numberOfClients = 0; } public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> bookClient( <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;numberOfClients &gt;= 3) { throw new TooManyClientsAddedToLesson(); } <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;apply( new ClientBookedOntoLesson( <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;lessonId, <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span>) ); } /** *       ‚Äî *  ,       *      ,       , *      . */ protected <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> applyClientBookedOntoLesson( ClientBookedOntoLesson <span class="hljs-variable"><span class="hljs-variable">$event</span></span> ) { <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;numberOfClients++; }</code> </pre> <br>  We can extract the CQRS components from our recording model ‚Äî fragments of the class involved in processing uncommitted events.  We can also clear the API for an event-generated entity by creating a secure <code>apply()</code> function that accepts the event, invokes the appropriate <code>applyEventName()</code> method, and adds a new <code>DomainEventMessage</code> event to the list of uncommitted events.  The extracted class is a detail of the CQRS implementation and does not contain domain logic, so we can create a new namespace: App \ CQRS: <br><br>  <i>Pay attention to the code <code>app/CQRS/EventSourcedEntity.php</code></i> <i><br></i>  <i>For the code to work, we need to add the <code>DomainEventMessage</code> class, which is a simple DTO - it can be found in <code>app/CQRS/DomainEventMessage.php</code></i> <br><br>  Thus, we got a system that generates events for each write attempt and uses events to record the changes necessary to prevent invariants.  The next step is to store these events in the store (EventStore).  First of all, this event repository needs to be created.  To simplify, we will use the Eloquent model, a simple SQL table with the following fields: * <code>UUID</code> (to know which entity to apply the event to) * <code>event_payload</code> (serialized message containing everything necessary to recreate the event) * <code>recordedAt</code> - timestamp to know when the event happened.  If you carefully review the code, you will see that I created two commands - to create and destroy our event storage table: <br><br><ul><li>  php artisan eloquenteventstore: create (App \ CQRS \ EloquentEventStore \ CreateEloquentEventStore) </li><li>  php artisan eloquenteventstore: drop (App \ CQRS \ EloquentEventStore \ DropEloquentEventStore) (don't forget to add them to App \ Console \ Kernel.php so that they load). </li></ul><br>  There are two very good reasons not to use SQL as an event store: it does not implement the append-only model (only adding data, events must be immutable), and also because SQL is not an ideal query language for temporal databases.  We program the interface to facilitate the replacement of the event store in subsequent publications. <br><br>  To save events, use the repository.  Whenever <code>save()</code> is called for the recording model, we save the uncommittedEvents list in the event store.  To store events, we need a mechanism for their serialization and deserialization.  Create a Serializer for this.  We need metadata, such as an event class (for example, <code>App\School\Lesson\Events\LessonWasOpened</code> ) and an event payload (data needed to reconstruct an event). <br><br>  All this will be encoded in JSON format, and then written to our database along with the entity UUID and timestamp.  We want to update our reading models after capturing events, so the repository will trigger every event after saving.  The Serializer will be responsible for writing the event class, while the event will be responsible for serializing its payload.  A fully serialized event will look something like this: <br><br><pre> <code class="plaintext hljs"> { class: "App\\School\\Lesson\\Events\\", event: $event-&gt;serialize() }</code> </pre> <br>  Since all events require a serialization and deserialization method, we can create a <code>SerializableEvent</code> interface and add an indication of the type of expected value.  Update our <code>LessonWasOpened</code> event: <br><br><pre> <code class="bash hljs">app/School/Lesson/Events/LessonWasOpened.php class LessonWasOpened implements SerializableEvent { public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serialize</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> array( <span class="hljs-string"><span class="hljs-string">'lessonId'</span></span>=&gt; (string) <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;getLessonId() ); } }</code> </pre> <br>  Create a <code>LessonRepository</code> repository.  We can refactor and extract the core CQRS components later. <br><br> <code>app/School/Lesson/LessonRepository.php</code> <br> <pre> <code class="plaintext hljs">eventStoreRepository = new EloquentEventStoreRepository( new EventSerializer() ); } public function save(Lesson $lesson) { /** @var DomainEventMessage $domainEventMessage */ foreach( $lesson-&gt;getUncommittedDomainEvents() as $domainEventMessage ) { $this-&gt;eventStoreRepository-&gt;append( $domainEventMessage-&gt;getId(), $domainEventMessage-&gt;getEvent(), $domainEventMessage-&gt;getRecordedAt() ); Event::fire($domainEventMessage-&gt;getEvent()); } } }</code> </pre> <br>  If you run the integration test again, and then check the <code>domain_events</code> SQL table, you should see two events in the database. <br><br>  Our final step in successfully passing the test is listening to the broadcast events and updating the projection of the Lesson reading model.  Lesson broadcast events will be intercepted by the <code>LessonProjector</code> , which will apply the necessary changes to <code>LessonProjection</code> (Eloquent models of the lesson table): <br><br><pre> <code class="bash hljs"> app/School/Lesson/Projections/LessonProjector.php class LessonProjector { public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> applyLessonWasOpened( LessonWasOpened <span class="hljs-variable"><span class="hljs-variable">$event</span></span> ) { <span class="hljs-variable"><span class="hljs-variable">$lessonProjection</span></span> = new LessonProjection(); <span class="hljs-variable"><span class="hljs-variable">$lessonProjection</span></span>-&gt;id = <span class="hljs-variable"><span class="hljs-variable">$event</span></span>-&gt;getLessonId(); <span class="hljs-variable"><span class="hljs-variable">$lessonProjection</span></span>-&gt;save(); } public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> subscribe(Dispatcher <span class="hljs-variable"><span class="hljs-variable">$events</span></span>) { <span class="hljs-variable"><span class="hljs-variable">$fullClassName</span></span> = self::class; <span class="hljs-variable"><span class="hljs-variable">$events</span></span>-&gt;listen( LessonWasOpened::class, <span class="hljs-variable"><span class="hljs-variable">$fullClassName</span></span>.<span class="hljs-string"><span class="hljs-string">'@applyLessonWasOpened'</span></span>); } }  app/School/Lesson/Projections/LessonProjection.php class LessonProjection extends Model { public <span class="hljs-variable"><span class="hljs-variable">$timestamps</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; protected <span class="hljs-variable"><span class="hljs-variable">$table</span></span> = <span class="hljs-string"><span class="hljs-string">"lessons"</span></span>; }</code> </pre> <br>  If you run the test, you will see that an SQL error has occurred: <br><br><pre> <code class="plaintext hljs">Unknown column 'clientName' in 'field list'</code> </pre> <br>  As soon as we create a migration to add <code>clientName</code> to the lesson table, we will successfully pass the test.  We have implemented the basic functionality of CQRS: the teams create events that are used to generate reading models. <br><br><h2>  Improving the reading model with links </h2><br>  We have reached a significant milestone, but that is not all!  So far, the reading model only supports one client (we specified three in our domain rules).  The changes we make to the reading model are quite simple: we just create a Client projection model and a <code>ClientProjector</code> that catches the <code>ClientBookedOntoLesson</code> event.  First, update our test to reflect the changes we want to see in our reading model: <br><br><pre> <code class="bash hljs">tests/CQRSTest.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFiringEventUpdatesReadModel</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId( (string) \Rhumsaa\Uuid\Uuid::uuid1() ); <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span> = <span class="hljs-string"><span class="hljs-string">"George"</span></span>; <span class="hljs-variable"><span class="hljs-variable">$command</span></span> = new BookLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch(<span class="hljs-variable"><span class="hljs-variable">$command</span></span>); <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span> = Lesson::find( (string) <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertEquals( <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;id, (string) <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> ); <span class="hljs-variable"><span class="hljs-variable">$client</span></span> = <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;clients()-&gt;first(); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertEquals(<span class="hljs-variable"><span class="hljs-variable">$client</span></span>-&gt;name, <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span>); }</code> </pre><br>  This is a clear demonstration of how easy it is to change reading models.  Everything, down to the event repository, remains unchanged.  As a bonus, when using the event system, we get data for basic tests - when changing the projector of the reading model, we listen to every event that has ever happened in our system. <br><br>  We reproduce these events using the new projector, check for exceptions, and compare the results with previous projections.  After the system has been working for some time, we will have a fairly representative selection of events for testing our projectors. <br><br>  Our recording model currently does not have the ability to load the current state.  If we want to add a second client to the lesson, we can simply create a second ClientWasAddedToLesson event, but we cannot provide protection against invariants.  For greater clarity, I propose to write a second test simulating the recording of two clients per lesson. <br><br><pre> <code class="bash hljs">tests/CQRSTest.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLoadingWriteModel</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId( (string) \Rhumsaa\Uuid\Uuid::uuid1() ); <span class="hljs-variable"><span class="hljs-variable">$clientName_1</span></span> = <span class="hljs-string"><span class="hljs-string">"George"</span></span>; <span class="hljs-variable"><span class="hljs-variable">$clientName_2</span></span> = <span class="hljs-string"><span class="hljs-string">"Fred"</span></span>; <span class="hljs-variable"><span class="hljs-variable">$command</span></span> = new BookLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-variable"><span class="hljs-variable">$clientName_1</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch(<span class="hljs-variable"><span class="hljs-variable">$command</span></span>); <span class="hljs-variable"><span class="hljs-variable">$command</span></span> = new BookClientOntoLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-variable"><span class="hljs-variable">$clientName_2</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch(<span class="hljs-variable"><span class="hljs-variable">$command</span></span>); <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span> = Lesson::find( (string) <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertClientCollectionContains(<span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;clients, <span class="hljs-variable"><span class="hljs-variable">$clientName_1</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertClientCollectionContains(<span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;clients, <span class="hljs-variable"><span class="hljs-variable">$clientName_2</span></span>); }</code> </pre> <br>  For our recording model, we need to implement a method of ‚Äúloading‚Äù an entity for which events already apply to it in the event store.  We can achieve this by playing back every event that refers to the entity's UUID.  In general terms, the process is as follows: <br><br><ol><li>  We receive all relevant event messages from the event store. </li><li>  For each message, we recreate the corresponding event. </li><li>  We create a new entity record model and play back each event. </li></ol><br>  At the moment, our tests throw exceptions, so we will start by creating the necessary <code>BookClientOntoLesson</code> (register a client for the lesson), using the <code>BookLesson</code> command as a template.  The handler method will look like this: <br><br><pre> <code class="bash hljs"> app/School/Lesson/Commands/BookClientOntoLesson.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> handle(LessonRepository <span class="hljs-variable"><span class="hljs-variable">$repository</span></span>) { /** @var Lesson <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span> */ <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span> = <span class="hljs-variable"><span class="hljs-variable">$repository</span></span>-&gt;load(<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;lessonId); <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;bookClient(<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;clientName); <span class="hljs-variable"><span class="hljs-variable">$repository</span></span>-&gt;save(<span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>); }      : app/School/Lesson/LessonRepository.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> load(LessonId <span class="hljs-variable"><span class="hljs-variable">$id</span></span>) { <span class="hljs-variable"><span class="hljs-variable">$events</span></span> = <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;eventStoreRepository-&gt;load(<span class="hljs-variable"><span class="hljs-variable">$id</span></span>); <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span> = new Lesson(); <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;initializeState(<span class="hljs-variable"><span class="hljs-variable">$events</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>; }</code> </pre> <br>  The repository load function returns an array of recreated events.  To do this, she first finds messages about events in the repository, and then passes them to the <code>Serializer</code> to convert each message into an event.  <code>Serializer</code> creates messages from events, so we need to add the <code>deserialize()</code> method to perform the inverse transform.  Recall that the <code>Serializer</code> is passed to each event to serialize the event data (for example, the client name).  We will do the same to perform the inverse transformation, while our <code>SerializableEvent</code> interface must be updated using the <code>deserialize()</code> method.  Let's look at the code so that everything falls into place.  First up is the <code>EventStoreRepository</code> load <code>EventStoreRepository</code> : <br><br><pre> <code class="bash hljs">app/CQRS/EloquentEventStore/EloquentEventStoreRepository.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> load(<span class="hljs-variable"><span class="hljs-variable">$uuid</span></span>) { <span class="hljs-variable"><span class="hljs-variable">$eventMessages</span></span> = EloquentEventStoreModel::<span class="hljs-built_in"><span class="hljs-built_in">where</span></span>(<span class="hljs-string"><span class="hljs-string">'uuid'</span></span>, <span class="hljs-variable"><span class="hljs-variable">$uuid</span></span>)-&gt;get(); <span class="hljs-variable"><span class="hljs-variable">$events</span></span> = []; foreach(<span class="hljs-variable"><span class="hljs-variable">$eventMessages</span></span> as <span class="hljs-variable"><span class="hljs-variable">$eventMessage</span></span>) { /*       event_payload,        . */ <span class="hljs-variable"><span class="hljs-variable">$events</span></span>[] = <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;eventSerializer-&gt;deserialize( json_decode(<span class="hljs-variable"><span class="hljs-variable">$eventMessage</span></span>-&gt;event_payload)); } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$events</span></span>; }</code> </pre><br>  Using the appropriate deserialization function in <code>eventSerializer</code> : <br><br><pre> <code class="bash hljs">app/CQRS/Serializer/EventSerializer.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> serialize( SerializableEvent <span class="hljs-variable"><span class="hljs-variable">$event</span></span> ) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> array( <span class="hljs-string"><span class="hljs-string">'class'</span></span> =&gt; get_class(<span class="hljs-variable"><span class="hljs-variable">$event</span></span>), <span class="hljs-string"><span class="hljs-string">'payload'</span></span> =&gt; <span class="hljs-variable"><span class="hljs-variable">$event</span></span>-&gt;serialize() ); } public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> deserialize( <span class="hljs-variable"><span class="hljs-variable">$serializedEvent</span></span> ) { <span class="hljs-variable"><span class="hljs-variable">$eventClass</span></span> = <span class="hljs-variable"><span class="hljs-variable">$serializedEvent</span></span>-&gt;class; <span class="hljs-variable"><span class="hljs-variable">$eventPayload</span></span> = <span class="hljs-variable"><span class="hljs-variable">$serializedEvent</span></span>-&gt;payload; <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$eventClass</span></span>::deserialize(<span class="hljs-variable"><span class="hljs-variable">$eventPayload</span></span>); }</code> </pre> <br>  In conclusion, we will use the static factory method <code>deserialize()</code> in <code>LessonWasOpened</code> (we need to add this method to each event) <br><br><pre> <code class="bash hljs">app/School/Lesson/Events/LessonWasOpened.php public static <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> deserialize(<span class="hljs-variable"><span class="hljs-variable">$data</span></span>) { <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId(<span class="hljs-variable"><span class="hljs-variable">$data</span></span>-&gt;lessonId); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> new self(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>); }</code> </pre> <br>  Now we have an array of all the events that we just reproduced relative to our Entity record model for initializing the state in the <code>initializeState</code> method in <code>app/CQRS/EventSouredEntity.php</code> <br><br>  Now run our test.  Bingo! <br>  In fact, at the moment we do not have a test to verify compliance with our domain rules, so let's write it: <br><br><pre> <code class="bash hljs">tests/CQRSTest.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testMoreThan3ClientsCannotBeAddedToALesson</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId( (string) \Rhumsaa\Uuid\Uuid::uuid1() ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch( new BookLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-string"><span class="hljs-string">"bob"</span></span>) ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch( new BookClientOntoLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-string"><span class="hljs-string">"george"</span></span>) ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch( new BookClientOntoLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-string"><span class="hljs-string">"fred"</span></span>) ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;setExpectedException( TooManyClientsAddedToLesson::class ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch( new BookClientOntoLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-string"><span class="hljs-string">"emma"</span></span>) ); }</code> </pre> <br>  Please note that we only need <code>lessonId</code> - this test reinitializes the state of the lesson during each command. <br><br>  At the moment, we simply transfer manually created <code>UUID</code> , whereas in reality we want to generate them automatically.  I am going to use the <code>Ramsy\UUID</code> package, so let's install it with <code>composer</code> : <br><br><pre> <code class="plaintext hljs">$&gt; composer require ramsey/uuid</code> </pre> <br>  Now update our tests to use the new package: <br><br><pre> <code class="bash hljs">tests/CQRSTest.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEntityCreationWithUUIDGenerator</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId( (string) \Rhumsaa\Uuid\Uuid::uuid1() ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch( new BookLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-string"><span class="hljs-string">"bob"</span></span>) ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertInstanceOf( Lesson::class, Lesson::find( (string) <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>) ); }</code> </pre><br>  Now the new project developer can look at the code, see <code>App\School\ReadModels</code> , which contains a set of Eloquent models, and use these models to write changes to the lesson table.  We can prevent this by creating an <code>ImmutableModel</code> class that extends the Eloquent Model class and overrides the save method in <code>app/CQRS/ReadModelImmutableModel.php</code> . </div><p>Source: <a href="https://habr.com/ru/post/461899/">https://habr.com/ru/post/461899/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461885/index.html">EDS is another type of fraud</a></li>
<li><a href="../461887/index.html">Entering Aeronet Episode 2: Homing Drone</a></li>
<li><a href="../46189/index.html">Chinese netbook with a Chinese processor at the "Chinese" price</a></li>
<li><a href="../461891/index.html">How we made friends in bank infrastructure using ManageIQ</a></li>
<li><a href="../461895/index.html">Learn While Travel - how we drove on 1st European Business Analysis Day</a></li>
<li><a href="../4619/index.html">Public key cryptography is 30 years old</a></li>
<li><a href="../46190/index.html">Photos of paper "AMERO" which will replace the dollar with the spring!</a></li>
<li><a href="../461901/index.html">Three years of autotests: how to increase speed and not only</a></li>
<li><a href="../461903/index.html">Mysterious adversary: ‚Äã‚Äãfuzzy borrowing</a></li>
<li><a href="../461905/index.html">Tic Tac Toe, part 7: pytest and Travis CI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>