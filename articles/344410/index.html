<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a decentralized music player on IPFS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article describes the results of two-month experiments with IPFS. The main result of these experiments was the creation of a proof-of-concept str...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a decentralized music player on IPFS</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/nu/0t/oy/nu0toydplmwfwkhophme051-0as.jpeg"></p><br><p>  This article describes the results of two-month experiments with IPFS.  The main result of these experiments was the creation of a proof-of-concept streaming audio player capable of building a music library solely on the basis of information published in the IPFS distributed network, starting with the metadata (album name, tracklist, cover), ending directly with audio files. </p><br><p>  Thus, being a desktop electron-application, the player does not depend on a single centralized resource. </p><a name="habracut"></a><br><h2 id="ipfs">  IPFS </h2><br><h3 id="kak-eto-rabotaet">  How it works </h3><br><p>  At first glance, the technology resembles something between BitTorrent, DC, git and blockchain.  On the second one, it turns out that IPFS can store and distribute objects of any of the above mentioned protocol. </p><br><p>  To begin with, IPFS is a peer-to-peer network of computers that exchange data.  For its formation, a combination of various network technologies is used, which develops within the framework of a separate project <a href="https://libp2p.io/">libp2p</a> .  Each computer has a special cache, where for the time being stored data that the user has published or downloaded.  Information in the IPFS cache is stored as blocks and is not fixed by default.  As soon as the space becomes scarce, the local garbage collector will clean up blocks that have not been accessed for a long time.  The pin / unpin methods are responsible for pinning / unpinning the information in the cache. </p><br><p>  For each block, a unique cryptographic imprint of its contents is calculated, which then acts as a link to this content in the IPFS space.  Blocks can be merged into merkle-tree objects whose nodes have their own footprint, calculated on the basis of lower node / block prints.  Here begins the most curious. </p><br><h3 id="ipld-dag">  IPLD-DAG </h3><br><p>  IPFS consists of a large number of smaller Protocol Labs projects, one of which is called IPLD (InterPlanetary Linked Data).  I'm not sure that I can correctly explain the essence, so I'll leave the <a href="https://github.com/ipld/specs/tree/master/ipld">link to the specification</a> curious. </p><br><p>  In short, the architecture described in the previous paragraph is so flexible that it can be used to recreate more complex structures, such as the blockchain, unix-like file system or git repository.  To do this, use the appropriate interfaces / plugins. </p><br><p> So far, I have worked exclusively with the <code>dag</code> interface, which allows you to publish regular JSON objects to IPFS: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">simple</span></span>: <span class="hljs-string"><span class="hljs-string">'object'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dagParams = { <span class="hljs-attr"><span class="hljs-attr">format</span></span>: <span class="hljs-string"><span class="hljs-string">'dag-cbor'</span></span>, <span class="hljs-attr"><span class="hljs-attr">hashAlg</span></span>: <span class="hljs-string"><span class="hljs-string">'sha3-512'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cid = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ipfs.dag.put(obj, dagParams)</code> </pre> <br><p>  If successful, a content identifier (CID) object is returned, inside which a unique imprint of the published information is stored, as well as methods for converting it into various formats.  That way you can get the base-string. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cidString = cid.toBaseEncodedString() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(cidString) <span class="hljs-comment"><span class="hljs-comment">// zdpuAzE1oAAMpsfdoexcJv6PmL9UhE8nddUYGU32R98tzV5fv</span></span></code> </pre> <br><p>  This string can be used to get data back using the <code>get</code> method.  In this case, no additional parameters are required, since the line contains information about the data format and the encryption algorithm used: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ipfs.dag.get(cidString) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj.value) <span class="hljs-comment"><span class="hljs-comment">// { // simple: 'object' // }</span></span></code> </pre> <br><p>  Further more.  You can publish a second object, one of the fields of which will refer to the first. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj2 = { <span class="hljs-attr"><span class="hljs-attr">complex</span></span>: <span class="hljs-string"><span class="hljs-string">'object'</span></span>, <span class="hljs-attr"><span class="hljs-attr">link</span></span>: { <span class="hljs-string"><span class="hljs-string">'/'</span></span> : cidString <span class="hljs-comment"><span class="hljs-comment">// cid-   } } const cid2 = await ipfs.dag.put(obj2, dagParams) const cid2String = cid2.toBaseEncodedString()</span></span></code> </pre> <br><p>  When trying to get obj2 back, all internal links will be resolved, unless otherwise specified by a special parameter. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj2 = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ipfs.dag.get(cid2String) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj2.value) <span class="hljs-comment"><span class="hljs-comment">// { // complex: "object", // link: { // "simple" : "object" // } // }</span></span></code> </pre> <br><p>  You can request the value of a separate field, for which you need to add a postfix of the form <code>/_</code> field_name to the CID line. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ipfs.dag.get(cid2String+<span class="hljs-string"><span class="hljs-string">"/complex"</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result.value) <span class="hljs-comment"><span class="hljs-comment">// object</span></span></code> </pre> <br><p>  In this way, you can ‚Äúwalk‚Äù around the entire object, including its links to other objects as if they were one large object.  Since links are cryptographic hashes of content, an object cannot contain a link to itself. </p><br><blockquote>  The concept of IPLD implies the ability to refer not only to other DAG objects, but also any other IPLD structures.  Thus, one field of your object can refer to a git-commit, and another to a bitcoin transaction. </blockquote><br><h3 id="pubsub">  Pub / Sub </h3><br><p>  A fundamental role in the implementation of the conceived functionality was played by the <code>pubsub</code> interface.  With it, you can subscribe to p2p-rooms, united by a special key line, send your messages and receive other people. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> topic = <span class="hljs-string"><span class="hljs-string">' '</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> receiveMsg = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      } await ipfs.pubsub.subscribe(topic, receiveMsg) const msg = new Buffer('') await ipfs.pubsub.publish(topic, msg)</span></span></code> </pre><br><p>  One of the first pubsub-based applications was the irc-like p2p-chat orbit ( <a href="https://orbit.chat/">still working</a> , if that).  You subscribe to the channel, you receive messages, the story is stored between the participants and gradually ‚Äúforgotten‚Äù.  Such a Vypress for the entire web. </p><br><blockquote>  Both in go and js versions of IPFS, the pubsub interface is turned on by a special parameter, since it is still considered an experimental technology. </blockquote><br><h2 id="zadumka">  Idea </h2><br><p>  At some point in my audiophile life, I noticed that I had been listening to music for a long time exclusively using Google Music.  And not only on the phone, but already on the desktop.  There are several reasons, but the main one is significantly fewer clicks between ‚ÄúI want to listen‚Äù and ‚Äúlisten‚Äù in most everyday situations in comparison with the same torrents.  The second most important reason is the size of the available library.  Very rarely, I don‚Äôt find what I‚Äôm looking for (much more often I meet regional restrictions).  But this is not an advantage over torrents, but other streaming services. </p><br><p><img src="https://habrastorage.org/webt/77/dr/or/77drorfp5zh_4tqslg9feugzyp0.png"></p><br><p>  It became curious whether it is possible to create an application comparable in usability based solely on distributed data sources.  Over time, two main conditions were formulated under which this task becomes feasible: </p><br><ul><li>  the ability to directly track the appearance of data in a distributed network, </li><li>  data published by network members should be standardized. </li></ul><br><p>  In the BitTorrent ecosystem, when someone wants to download something, in most cases he will have to first access the torrent directory - a regular site located on a regular server for a normal ip under a regular domain.  The first condition is necessary so that the application can form a local database automatically and without the participation of centralized resources. </p><br><p>  The second condition is the most important.  To execute it, it is necessary that the information published by the participants of the distributed network is executed in accordance with the model / scheme that is known in advance by all the others.  This makes the distributed data space available for search and filtering systems, increases their effectiveness. </p><br><p>  As it turned out, IPFS makes it possible to provide both of these conditions, and quite effectively. </p><br><h2 id="realizaciya">  Implementation </h2><br><p>  At present, "Phathofon" is a primitive record player.  Here is almost all of its functionality: </p><br><ul><li>  posting albums in IPFS </li><li>  list of found albums </li><li>  opportunity to play an album </li></ul><br><p>  Let's start with the publication.  In the previous chapter, I said that information in a distributed network should be somehow standardized.  In the "Pathhone" this task is achieved through the album json-scheme. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> albumSchema = { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, <span class="hljs-attr"><span class="hljs-attr">properties</span></span>: { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">artist</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">cover</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">tracks</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"array"</span></span> items: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, <span class="hljs-attr"><span class="hljs-attr">properties</span></span>: { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">artist</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">hash</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span> } } } } } }</code> </pre> <br><p>  In accordance with this scheme, a specific copy is checked and then published.  For this is the usual form of input. </p><br><p><img src="https://habrastorage.org/webt/fj/gh/mx/fjghmxwhuelfjrai-dnssnlwbj0.png"></p><br><p>  At first it was assumed that the publication will occur directly from the file system.  Standardization of data would be achieved using a special <code>.meta</code> file, where all the necessary properties and connections of the instance would be described.  But after experimenting a little I came to the conclusion that doing it through the interface of the application itself would be more convenient, clearer and more efficient. </p><br><p><img src="https://habrastorage.org/webt/wa/vg/bb/wavgbb4z1ktlcafvhuxtpw1lgnu.gif"></p><br><blockquote>  An important detail - the attached files are published separately using <code>ipfs.files.add()</code> .  Returned CIDs are inserted into the corresponding input in a separate line.  The input is left in case there is no file at hand, but its CID is known. </blockquote><p>  When the form is completed and the user presses "ADD ALBUM" the final JSON data is first checked for compliance with the scheme, then published using the DAG interface, after which the resulting CID in the form of a buffer is sent to a special pubsub room. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isValid = validateAlbumObj(albumObj) <span class="hljs-comment"><span class="hljs-comment">//       if (isValid) { const albumCid = await ipfs.dag.put(albumObj, dagParams) //      dag await ipfs.pubsub.publish(albumSchemaCidString, albumCid.buffer) //  CID   pubsub    }</span></span></code> </pre><br><p>  The obvious solution would be to use something like "albums", "music-albums" or, in extreme cases, "pathephone" as a room key, if you want to isolate the network within your application.  But then a cleverer thought came to mind - to use the CID string of the album's json scheme as a key.  In the end, it is the data scheme that truly merges all copies of the application.  Moreover, it is from this room that one can expect that all received messages will contain verified instances of this scheme. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleReceivedMessage = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (message) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { data, <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> } = message <span class="hljs-comment"><span class="hljs-comment">// data -   , from - id  const cid = new CID(data).toBaseEncodedString() // ,     CID-,     CID-      base- const { value } = await ipfs.dag.get(cid) const isValid = validateAlbumObj(value) //        if (isValid) { // value -   ,    ,    } else { throw new Error('invalid schema instance received') } } catch (error) { //   } } const albumSchemaCid = await ipfs.dag.put(albumSchema, dagParams) const albumSchemaCidString = albumSchemaCid.toBaseEncodedString() await ipfs.pubsub.subscribe( albumSchemaCidString, handleReceivedMessage )</span></span></code> </pre><br><p>  As you can see, each "arriving" object is still checked for compliance with the scheme, since no one interferes with any member of the network, knowing the key, to purposefully begin to flood the room.  At the same time, the uniqueness of the key minimizes the likelihood of accidental intervention.  On the other hand, if any other application starts to use the same scheme as the ‚ÄúGambler‚Äù, then together they will begin to form and use the same data space, which can be a plus. </p><br><p>  Behind the brackets are some application-specific things, like storing an object in a database. </p><br><blockquote>  The process of publishing an album on one computer and getting it on another <a href="https://drive.google.com/open%3Fid%3D182y4UP-gLaHd9oHXqqau8nyr0qChRDv_">can be seen on the video</a> .  The speed is almost instant, but it depends on a large number of factors.  There was a case when the computers did not end up in one ‚Äúswarm‚Äù, so the transfer failed. </blockquote><br><h2 id="metabin-gate">  Metabin gate </h2><br><p>  I described everything described above in the form of an npm-module called <code>@metabin/gate</code> .  It hides the details, leaving the developer only to transfer the ipfs node and the json scheme: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gate = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> openGate( ipfsNode, <span class="hljs-comment"><span class="hljs-comment">//   js-ipfs  js-ipfs-api schema //  json-schema, (instance, cid) =&gt; { // instance -     // cid - base-encoded   } ) await gate.send(instance) //   await gate.close()</span></span></code> </pre><br><h2 id="vyvody">  findings </h2><br><p>  IPFS is one of the most advanced technologies for distributed information sharing.  Despite the fact that both (and go and javascript) versions are in the alpha stage, they are already used by some relatively popular applications, like OpenBazaar or d.tube.  Another thing is that they use it mainly only as a file storage. </p><br><p>  This can be understood, given that IPFS is mainly regarded as a kind of alternative to BitTorrent.  The concept of IPLD and the capabilities of the respective interfaces are rarely in the spotlight.  Although, in my opinion, this is the most promising development of Protocol Labs, which makes it possible to distribute normal data objects via IPFS. </p><br><p>  <code>pubsub</code> uncomplicatedly combining <code>files</code> , <code>dag</code> and <code>pubsub</code> interfaces, the developer gets a free, self-organizing data source for his application.  Add Electron and get a pretty tempting technology stack: </p><br><ul><li>  does not require servers </li><li>  does not require a domain name </li><li>  speed of data distribution is limited only by the quantity and quality of participants </li><li>  complexity and data structure is limited only by your imagination </li><li>  don't bother with cross-browser support </li><li>  high resistance to censorship </li></ul><br><p>  Of course, not all applications need such autonomy at all, given that it leads to a loss of control over the content.  Not to mention that all this is quite an experimental area.  How such a network will scale, how it will affect performance, whether it is possible to influence this process - there are many questions that have not yet been formulated. </p><br><p>  Nevertheless, the possibilities and prospects are curious. </p><br><h2 id="ssylki">  Links </h2><br><ul><li>  <a href="https://github.com/ipfs/ipfs">IPFS on github</a> </li><li>  <a href="https://github.com/ipld/ipld">IPLD on github</a> </li><li>  <a href="https://github.com/pathephone/pathephone-desktop">"Gramophone" on GitHub</a> <br><ul><li>  <a href="">Build under Linux, Windows, Mac</a> </li></ul></li><li>  <a href="https://www.npmjs.com/package/%40metabin/gate">Metabin Gate at npm</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/344410/">https://habr.com/ru/post/344410/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../344398/index.html">Airflow Workshop: complex DAGs without crutches</a></li>
<li><a href="../344400/index.html">My Body Gadget (Part # 2)</a></li>
<li><a href="../344402/index.html">Popularity statistics of operating systems in IaaS: Ubuntu is still number one, CentOS popularity is growing</a></li>
<li><a href="../344406/index.html">How users perceive different authentication methods</a></li>
<li><a href="../344408/index.html">How to write UI tests using Instagram accounts and not get a block</a></li>
<li><a href="../344412/index.html">Mitap BugBusters: All About Selenium, Effective Automatizers and Weekly Load Testers</a></li>
<li><a href="../344414/index.html">How IaaS helps 1C franchisee: 1cloud experience</a></li>
<li><a href="../344416/index.html">Debate about a great Java application server with Tomcat, Jboss, GlassFish, Jetty and Liberty Profile. Part two</a></li>
<li><a href="../344418/index.html">How to choose the right database for your organization</a></li>
<li><a href="../344420/index.html">Uber data leakage - learn from mistakes?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>