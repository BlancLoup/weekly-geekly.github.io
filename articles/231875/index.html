<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to use .NET from LoadRunner</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Although LoadRunner has a good API for various text processing, sometimes it is still not enough, and then you have to expand it with self-written fun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to use .NET from LoadRunner</h1><div class="post__text post__text-html js-mediator-article">  Although LoadRunner has a good API for various text processing, sometimes it is still not enough, and then you have to expand it with self-written functions.  Often, such implementations become the invention of the bicycle, since almost all the tasks, as you know, have already been solved by someone once.  In addition, since I have a good background in C #, when solving a task, I often think that this task would be easily solved if I had the .NET Framework class library at hand.  In principle, if I were a Java programmer, I would have similar thoughts about Java (where almost everything is also there), but as far as .NET is closer to me, then it will be about him.  As a side effect, the article will be useful for those who want to learn how to call CLR code from native code.  There is also a small study of the performance of this option and the Visual Studio work template and the LoadRunner script are attached. <br><a name="habracut"></a><br><h4>  .NET, and Java in LoadRunner </h4><br>  To begin, consider an attractive, but bad option.  In principle, both .NET and Java work directly in LoadRunner.  For each of these platforms, there are classes that represent wrappers over the standard LoadRunner API.  They can be used right away by selecting, respectively, the <i>.NET</i> and <i>Java Vuser modes</i> .  Let's say right away: these script development modes are created somewhat for another.  The <i>.NET</i> mode allows you to record the activity of a .NET application and create a script that directly calls the methods of the application classes.  <i>Java Vuser</i> has a full and documented API for Java, but it doesn‚Äôt have a recording mode at all (it has <i>Java Record Replay</i> in the sense of <i>.NET</i> ).  For this reason, using them for the Web is very problematic, and in general, ‚Äúusing‚Äù in this case means ‚Äúwriting some kind of working code‚Äù and nothing more.  When developing load scripts from a tool, it is important to be able to record traffic and convert it into a script, at least a rough one, which will later be refined.  But here's the ill luck: recording web traffic ( <i>Web</i> mode <i>- HTTP / HTML</i> ) is possible only with conversion into C code.  The community has been waiting for this for a long time, and I, frankly, hoped that at least in the new version 12.00 it would be possible to choose C # or Java, but this did not happen.  In addition, the API for .NET is practically not documented, and you have to act when stepping on a rake in the dark (by the way, method signatures for .NET and Java wrappers are also different).  If I can find the necessary wrapper method in the .NET classes relatively quickly, then I don‚Äôt know how to transfer the parameters to it. <br><br>  For example: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Script</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">VuserClass</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Action</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { web.url(<span class="hljs-string"><span class="hljs-string">"ya.ru"</span></span>, <span class="hljs-string"><span class="hljs-string">"URL=http://ya.ru/"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } }</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This code works and implements a query equivalent to the <i>web_url ()</i> C function.  The method is attractive because you can connect any .NET libraries to the Run-Time Settings and use them immediately, however, questions immediately arise: <br><br><ul><li>  How to pass <i>web.url ()</i> parameters similar to <i>web_url ()</i> ? </li><li>  How to make it all work through a proxy? </li><li>  Why does the good part of Run-Time Settings disappear in this mode?  (In principle, it is clear why, but this does not make it any easier.) </li></ul><br><br>  In general, this mode was not made for this purpose, therefore, despite the potential convenience of this option, we will not use it for other purposes and will remain on C.  Still, the ability to quickly rewrite a piece of script is more substantial.  At the same time, after performing a few simple steps, you can call .NET code from the LoadRunner C-script. <br><br>  LoadRunner regularly supports calling native libraries, for this there is a function <i>lr_load_dll ()</i> .  In order to call .NET, you have to write a native layer and, in fact, the whole question comes down to calling the CLR code from the native code.  Who knows how to do this, you can skip the next section, for the rest below I will tell you how to do it. <br><br><h4>  Native DLL with .NET access </h4><br>  Once I needed to decode strings like: <br><br> <code>&amp;#1057;&amp;#1086;&amp;#1079;&amp;#1076;&amp;#1072;&amp;#1090;&amp;#1100; &amp;#1079;&amp;#1072;&amp;#1103;&amp;#1074;&amp;#1082;&amp;#1091;</code> <br> <br>  This is a kind of encoding used internally in XML and HTML: each character is represented as UTF-8 code.  I couldn‚Äôt do it on LoadRunner (if anyone knows how, please stick my nose).  But in the HttpUtility class, <i>there</i> is a <i>HtmlDecode ()</i> method, which does it perfectly.  Let's see how you can zayuzat it. <br><br><h5>  Requirements </h5><br>  Naturally, you will need installed in the .NET Framework.  Specifically, this method is in any version starting from 2.0 (or maybe earlier, but this is not important anymore), but remember that the native library indicates which version we are accessing, and different versions are not interchangeable.  Also remember that Win7 / 2008 is already installed .NET FW 3.5, so if you use load stations on these OSs, then you do not need to install anything, you just need to specify inside the symplus library that we use .NET Framework 3.5. <br><br><h5>  We write DLL </h5><br>  For some time in Visual Studio, it has become very easy to access .NET classes from C ++ code.  To do this, you need to set the <i>Common Language Runtime Support</i> mode in the project settings.  Next you need to go to the project properties, Common Properties, Framework and References and add links to the assemblies that you want to use.  In this case, we are interested in System.Web from Assemblies / Framework.  After that, you can already refer to the .NET classes, however, in C ++ - syntax: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"..\LR include 11.50\lrun.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//... int xml_http_decode(const char* inputStr, const char* outputParam) { try { System::String^ temp = gcnew System::String(inputStr); System::String^ result = HttpUtility::HtmlDecode(temp); marshal_context^ context = gcnew marshal_context(); lr_save_string(context-&gt;marshal_as&lt;const char*&gt;(result), outputParam); } catch(char* message) { lr_save_string(message, outputParam); return LR_FAIL; } catch(...) { lr_save_string("!!! Unknown exception raised !!!", outputParam); return LR_FAIL; } return LR_PASS; }</span></span></span></span></code> </pre><br>  LoadRunner can only connect native dlls, so we declare a function with a C-compatible signature and a return value.  Further, to declare .NET types and distinguish them from C ++ types, use the "^" sign.  We need to create CLR strings from C strings to pass them to .NET methods.  To create CLR objects, use the <i>gcnew</i> operator. <br><br>  So that the function can be called from outside the dll, it needs to be exported.  To do this, we write: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> { __declspec( dllexport ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xml_http_decode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* inputStr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* outputParam)</span></span></span></span>; }</code> </pre><br>  Next, we connect the library to LoadRunner and calmly call our function: <br><br><pre> <code class="cpp hljs">lr_load_dll(<span class="hljs-string"><span class="hljs-string">"hplr.dll"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Native DLL  C++. xml_http_decode( "&lt;span class=\"x11z\"&gt;&amp;#1057;&amp;#1086;&amp;#1079;&amp;#1076;&amp;#1072;&amp;#1090;&amp;#1100; " "&amp;#1079;&amp;#1072;&amp;#1103;&amp;#1074;&amp;#1082;&amp;#1091;&lt;/span&gt;", "p_decoded"); lr_output_message("%s", lr_eval_string("{p_decoded}")); //     .</span></span></code> </pre><br>  If the <i>loadrunner</i> function <i>lr_load_dll ()</i> crashes with a confusing error ‚Äúcannot find the file‚Äù, then the matter may not be in the plug-in DLL itself, but in its dependencies.  To successfully connect the library compiled in Debug mode, you need to add the files <i>msvcp110d.dll</i> and <i>msvcr110d.dll</i> in System32 or in SysWOW64 for 32-bit and 64-bit OS, respectively.  Other dependencies can be investigated using a Dependency Walker tool or similar tool.  If the library is compiled in Release mode, then nothing extra is needed (remove also the additional <i>#include</i> and dependencies in the compiler settings). <br><br>  Functions written in C ++ are available in the DLL right away (do not forget to make an export!).  You can write in LoadRunner <br>  relative path to the DLL, starting with the script folder.  You do not need to restart VuGen or re-open the script. <br><br>  So we can refer to the already ready .NET classes.  But writing my own C ++ code to work with .NET is, in my opinion, somewhat inconvenient, there are more suitable languages ‚Äã‚Äãfor this. <br>  <i><b>Note:</b> C ++ also has a bunch of ready-made libraries (and they will work faster, by the way), but first, they need known experience and accuracy, and second, it is beyond the scope of this article.</i> <br><br><h4>  Appeal to custom library on C # </h4><br>  Suppose we wrote more complex logic in C # and packed it into a separate assembly.  How to contact her from LR? <br>  In principle, everything is the same as in the previous case, only the link needs to be added to our assembly (via Solution or Browse) and the classes need to be called from our assembly. <br><br><h5>  C # DLL </h5><br>  For some reason, LoadRunner can search for regular expressions only in server responses, and how to find a regular expression in the C-string or in the parameter value is not clear (if anyone knows, stick my nose).  To solve this problem, you can write the following function: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// C#-,    input   pattern   //   nGroup    nMatch. namespace HplrCs { public static class HplrHelper { public static string GetRegexMatch(string input, string pattern, int nMatch, int nGroup) { try { var re = new Regex(pattern); var matches = re.Matches(input); if (matches.Count &lt; nMatch + 1) return String.Empty; var match = matches[nMatch]; if (match.Success) { if (match.Groups.Count &lt; nGroup + 1) return String.Empty; return match.Groups[nGroup].Value; } else return String.Empty; } catch (Exception ex) { return ex.ToString(); } } } }</span></span></code> </pre><br>  The assembly with this code we have to put in the Global Assembly Cache (GAC).  To do this, you need to use the gacutil.exe utility, which is included with the Windows SDK, and also installed with Visual Studio.  For .NET Framework 4.0 / 4.5, you need to use the appropriate version of gacutil.exe from the 8th version of the SDK, earlier versions will not be able to install build 4.0 / 4.5. <br><br> <code>gacutil.exe -i HplrCs.dll</code> <br> <br>  Installation in the GAC should be done under admin rights.  You can make sure that the assembly is present in the cache like this: <br><br> <code>gacutil.exe -l HplrCs</code> <br> <br>  To replace the build version in the GAC, you need to install again, on top of the previous one.  You do not need to delete the old version, but it is important to make sure that the installation was successful. <br><br><h5>  Writing a native wrapper </h5><br>  Again, similar to the first version, we will create a native library, which will be the link between LoadRunner and the .NET assembly: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"..\LR include 11.50\lrun.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//... extern "C" { __declspec( dllexport ) int get_regex_match( const char* inputStr, const char* pattern, const char* outputParam, int nMatch, int nGroup ); } int get_regex_match(const char* inputStr, const char* pattern, const char* outputParam, int nMatch, int nGroup) { try { System::String^ _inputStr = gcnew System::String(inputStr); System::String^ _pattern = gcnew System::String(pattern); System::String^ result = HplrHelper::GetRegexMatch(_inputStr, _pattern, nMatch, nGroup); marshal_context^ context = gcnew marshal_context(); lr_save_string(context-&gt;marshal_as&lt;const char*&gt;(result), outputParam); } catch(char* message) { lr_save_string(message, outputParam); return LR_FAIL; } catch(...) { lr_save_string("!!! Unknown exception raised !!!", outputParam); return LR_FAIL; } return LR_PASS; }</span></span></span></span></code> </pre><br><br><h4>  LR Functions and Constants </h4><br>  You probably noticed that the above code uses functions and constants of LoadRunner.  This is possible thanks to what we have done. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"..\LR include 11.50\lrun.h"</span></span></span></span></code> </pre><br><br>  In order for this to gather correctly, you need to add the lrun50.lib library to the linker input.  They lie, respectively, in <br><br><pre> <code class="html hljs xml">C:\Program Files (x86)\HP\LoadRunner\include C:\Program Files (x86)\HP\LoadRunner\setup\dot_net\Vc9\VCWizards\LrCVuserDllLibrary\templates\1033</code> </pre><br><br>  With their help, you can call API functions of the LoadRunner in the same way as if you called them from a script. <br><br><h4>  Example </h4><br>  There is a completely ready template in the form of the MS Visual Studio 2012 project. You can take it by <a href="https://yadi.sk/d/aTGXs4eQYbwFB">reference</a> . <br><br>  Archive content: <br><br><ul><li>  C ++ is a project that demonstrates calling code both directly in the .NET Framework and in other .NET assemblies. </li><li>  C Sharp is an example of a library (assembly) on .NET. </li><li>  LR include * and LR lib * - files from the LoadRunner distribution, copied to enable the project to be built if LoadRunner is not installed. </li><li>  Output - collected binaries. </li><li>  LR Ext lib usage example is a sample LoadRunner script using the above approach. </li></ul><br>  When you first open a project in Visual Studio, you will be prompted to update the version of the .NET Framework being used.  You should not do this if you do not understand the meaning of what is happening.  Upgrading the version will oblige you to build a .NET assembly with this version as the Target Framework (in the project properties).  By the way, I did not find where in the interface you can change the version of the .NET Framework for a C ++ project.  It is shown in the properties of a C ++ project, but only for viewing, it cannot be changed.  But you can do this by opening the .vcxproj file in a text editor and finding the TargetFrameworkVersion XML element.  Therefore, if you have updated the project, edit TargetFrameworkVersion to the one you need, or switch to using a different version of the .NET Framework. <br><br><h4>  Performance </h4><br>  The performance of the proposed approach will be the more attractive, the less you are going to use the built-in functions and the more you want to use the code in C LR.  If for any purpose there is a built-in LoadRunner function, you should use it, since the native code is behind it, which means that it will work faster. <br><br>  For example, let's try to find a substring in a string of approximately 32KB (longer to make it difficult, because this is the maximum that allows LoadRunner to allocate in the stack for local parameters).  I specifically take the search for a substring, as one of the classical problems, because the algorithms for it, I think, should be optimized as much as possible. <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUFF_SIZE 32700 char buff[BUFF_SIZE]; int i; lr_load_dll(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"hplr.dll"</span></span></span><span class="hljs-meta">); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Native DLL. memset(buff, '-', BUFF_SIZE); buff[BUFF_SIZE - 1] = 0; strcpy(buff + BUFF_SIZE - 4, "+++"); lr_start_transaction("Find substring, internal function"); for (i = 0; i &lt; 100000; i++) strstr(buff, "+++"); lr_end_transaction("Find substring, internal function", LR_AUTO); lr_start_transaction("Find substrings, C# function"); for (i = 0; i &lt; 100000; i++) find_substr_net(buff, "+++"); lr_end_transaction("Find substrings, C# function", LR_AUTO);</span></span></span></span></code> </pre><br><br>  I will not give the code on .NET, there is a normal <i>String.IndexOf ()</i> behind it.  Measurements should be carried out only in the startup mode in the Controller, in VuGen the execution is two orders of magnitude slower. <br><br><pre> <code class="xml hljs">Find substring, internal function: 1,505 Find substring, C# function: 13,323</code> </pre><br><br>  Well, it is expected.  The main execution time is actually the search for the substring, and here the native code gives a significant advantage.  Also, the conversion of <i>const char *</i> to <i>System.String</i> slows down. <br>  But we have what to answer.  Let the interpreter work independently.  To do this, we write a function that performs simple actions in integer arithmetic: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int_arithm_lr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s = p; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; i++) { s += i * (i % <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s; }</code> </pre><br><br>  The C # code is exactly the same, only with the words public static. <br>  Let's compare the execution speed in both runtimes: <br><br><pre> <code class="cpp hljs"> lr_start_transaction(<span class="hljs-string"><span class="hljs-string">"Integer arithmetics, LR function"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">500</span></span>; i++) int_arithm_lr(i); lr_end_transaction(<span class="hljs-string"><span class="hljs-string">"Integer arithmetics, LR function"</span></span>, LR_AUTO); lr_start_transaction(<span class="hljs-string"><span class="hljs-string">"Integer arithmetics, C# function"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">500</span></span>; i++) int_arithm_net(i); lr_end_transaction(<span class="hljs-string"><span class="hljs-string">"Integer arithmetics, C# function"</span></span>, LR_AUTO);</code> </pre><br><pre> <code class="xml hljs">Integer arithmetics, LR function: 45,772 Integer arithmetics, C# function: 0,013</code> </pre><br><br>  The difference is 3.5 thousand times. <br><br>  Although the use of such calculations is not typical for load testing scenarios, it exposes the weak side of the LR interpreter: the low speed of its own code.  Therefore, if you need to write something sophisticated, then in .NET languages ‚Äã‚Äãthis will not only be more convenient to implement, but it will also work much faster than the C code in LR. <br><br>  On this, perhaps, everything, thank you for your attention! </div><p>Source: <a href="https://habr.com/ru/post/231875/">https://habr.com/ru/post/231875/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../231861/index.html">Tugging a Camel or integration with Camel. Part 2</a></li>
<li><a href="../231863/index.html">How-to: What is Russian Volatility Index and how it is calculated</a></li>
<li><a href="../231865/index.html">What's so complicated, or how I broke a new quadrocopter</a></li>
<li><a href="../231869/index.html">As we did a small security system on the RPi. Part 1</a></li>
<li><a href="../231871/index.html">Alexander Zharov gave an interview for Vedomosti</a></li>
<li><a href="../231877/index.html">AdSense money can now be withdrawn directly to a bank account.</a></li>
<li><a href="../231879/index.html">As I wrote my first technical task</a></li>
<li><a href="../231881/index.html">Study Abroad: Vietnam</a></li>
<li><a href="../231883/index.html">Creating JS Modules</a></li>
<li><a href="../231885/index.html">New technology adjusts the image on the display for people with visual impairments</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>