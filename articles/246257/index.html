<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How slow are iostreams?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I / O streams in the standard C ++ library are easy to use, type safe, resilient to resource leaks, and allow simple error handling. However, behind t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How slow are iostreams?</h1><div class="post__text post__text-html js-mediator-article">  I / O streams in the standard C ++ library are easy to use, type safe, resilient to resource leaks, and allow simple error handling.  However, behind them the reputation of "slow".  There are several reasons for this, such as the extensive use of dynamic allocation and virtual functions.  In general, flows are one of the most ancient parts of the standard library (they began to be used around 1988), and many decisions in them are now perceived as "controversial."  However, they are widely used, especially when you need to write some simple program that works with text data. <br><br>  Performance issue iostreams is not idle.  In particular, the problem of console I / O performance can be encountered in sports programming systems, where even using a good algorithm, one can not go through time only because of input / output.  I also encountered this problem when processing scientific data in text format. <br><br>  Today in the comments at the <a href="http://habrahabr.ru/post/245801">post</a> there was a discussion about the slowness of iostreams.  In particular, <a href="https://habrahabr.ru/users/freopen/" class="user_link">freopen</a> writes <br><blockquote>  It's funny to look at your optimization, located next door with reading through cin :) </blockquote><br>  <a href="https://habrahabr.ru/users/aesamson/" class="user_link">aesamson</a> gives this recommendation <br><blockquote>  You can replace it with getchar_unlocked () for * nix or getchar () for all others. <br>  getchar_unlocked&gt; getchar&gt; scanf&gt; cin, where "&gt;" means faster. </blockquote>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this post I will dispel and confirm some myths and give a couple of recommendations. <br><a name="habracut"></a><br><br>  All measurements in this post are for Ubuntu 14.10 system with GCC 4.9.1 compiler, compiled with keys <br><pre><code class="bash hljs">g++ -Wall -Wextra -std=c++11 -O3</code> </pre> <br>  The launch was carried out on a laptop with an Intel Core2 Duo P8600 processor (2.4 GHz). <br><br><h4>  Formulation of the problem </h4><br>  In sports programming, as in the UNIX-way, input data is usually fed to the input stream.  So, the task: <br><br>  <b>There are many non-negative integers on the input stream (stdin), one per line.</b>  <b>The program should output the maximum of the input numbers.</b> <br><br>  Form input data <br><pre> <code class="bash hljs">seq 10000000 &gt; data</code> </pre><br>  In the data file, we recorded 10 million consecutive integers, with a total volume of 76 megabytes. <br>  We will run the program so <br><pre> <code class="bash hljs">time ./a.out &lt; data</code> </pre><br>  So, we proceed. <br><br><h4>  1. <code>scanf</code> </h4><br>  We solve the problem using the good old scanf. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max_scanf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> max = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">scanf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, &amp;x) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { max = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(x, max); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max; }</code> </pre><br>  When using scanf, it is important not to forget to always check the return value - this is the number of actually read and filled arguments (GCC with -Wall reminds about this).  In our case, with successful reading, the return value should be 1. <br><div class="spoiler">  <b class="spoiler_title">Main function</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; max_scanf() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre></div></div><br>  Work time: <b>1.41</b> s <br><br><h4>  2. Naive <code>std::cin</code> </h4><br>  Now we will solve the problem in the simplest way with the help of iostreams: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max_iostream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::istream &amp; f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> max = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(f &gt;&gt; x) max = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(x, max); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max; }</code> </pre><br>  Work time: <b>4.41</b> s <br>  Wow!  Streams were slower than scanf 3 times!  That is, it turns out that iostream are really worthless in terms of speed? <br><br><h4>  3. Fast <code>std::cin</code> </h4><br>  In fact, to correct the situation, it is enough to add one single line to the program.  At the very beginning of the main function, we insert: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ios::sync_with_stdio(<span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br>  What does it mean? <br>  In order to mix iostreams and stdio in the program, this synchronization was introduced.  By default, when working with standard streams ( <code>std::cin, std::cout, std::cerr</code> ...), the buffer is flushed after each I / O operation, so that the data is not mixed.  If we assume to use only iostream, then we can disable this synchronization.  More details can be read at <a href="http://en.cppreference.com/w/cpp/io/ios_base/sync_with_stdio">cppreference</a> . <br>  Work time: <b>1.33</b> s <br>  It is quite another matter!  Moreover, it is <b>faster</b> than scanf!  That is, not everything is so bad.  The advantages of iostreams include ease of use, type safety and easier error handling. <br><br>  <i>All subsequent variants using std :: cin will use this optimization.</i> <br><br><h4>  4. Naive <code>std::istringstream</code> </h4><br>  In addition to input from a file, the standard library also provides classes for input from a string with the same interface.  Let's see how slow it is.  We will read from the input stream one line at a time, and then parse it with <code>std::istringstream</code> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max_iostream_iss</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::istream &amp; f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> max = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> line; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::getline(f, line)) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">istringstream</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iss</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(line)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(! (iss &gt;&gt; x)) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; max = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(x, max); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max; }</code> </pre><br>  Work time: <b>7.21</b> s <br>  So slow! <br><br><h4>  5. Reusing <code>std::istringstream</code> </h4><br>  It may seem surprising, but the slowest thing in <code>istringstream</code> is creating it.  And we create anew for each input line.  Let's try to reuse the same object: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max_iostream_iss_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::istream &amp; f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> max = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> line; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">istringstream</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iss</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(line)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::getline(f, line)) { iss.clear(); <span class="hljs-comment"><span class="hljs-comment">//    iss.str(line); //    if(! (iss &gt;&gt; x)) break; max = std::max(x, max); } return max; }</span></span></code> </pre><br>  Note that you need 2 calls, clear, to reset the status flags, and str, to set a new buffer from which to read. <br><br>  Work time: <b>2.16</b> s <br>  This is another matter.  This is expected to be slower than reading directly from <code>std::cin</code> (data passes 2 times through the thread classes), but not catastrophic. <br><br><h4>  6. We want even faster!  (getchar / getchar_unlocked) </h4><br>  What if the performance is still not enough?  Use lower-level I / O and a custom parser.  In the comments on the above topic, <a href="https://habrahabr.ru/users/aesamson/" class="user_link">aesamson</a> gave a sample code that implements the simplest parser of integers (probably taken from StackOverflow).  <code>getchar_unlocked</code> is the read-safe version of <code>getchar</code> for reading from the input stream.  I added the omission of extra characters and the simplest handling of the end of the file: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_int_unlocked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; out)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = getchar_unlocked(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> neg = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; !(<span class="hljs-string"><span class="hljs-string">'0'</span></span>&lt;=c &amp;&amp; c&lt;=<span class="hljs-string"><span class="hljs-string">'9'</span></span>) &amp;&amp; c != <span class="hljs-string"><span class="hljs-string">'-'</span></span>; c = getchar_unlocked()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == EOF) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-string"><span class="hljs-string">'-'</span></span>) { neg = <span class="hljs-number"><span class="hljs-number">1</span></span>; c = getchar_unlocked(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == EOF) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; <span class="hljs-string"><span class="hljs-string">'0'</span></span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span> ; c = getchar_unlocked()) { x = x*<span class="hljs-number"><span class="hljs-number">10</span></span> + c - <span class="hljs-string"><span class="hljs-string">'0'</span></span>; } out = neg ? -x : x; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max_getchar_unlocked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> max = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(read_int_unlocked(x)) max = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(x, max); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max; }</code> </pre><br>  Work time: <code>getchar</code> <b>0.82</b> s, <code>getchar_unlocked</code> <b>0.28</b> s! <br>  Very good result!  And you can see how great the slowdown is due to locks for the sake of thread safety. <br>  But this approach has disadvantages - it is necessary to write parsers for all data types used (and this is not so easy even for floating-point numbers), the complexity of error handling, and thread safety in the case of <code>getchar_unlocked</code> .  Alternatively, you can try using a parser generator, for example, <code>re2c</code> , <code>boost::Spirit::Qi</code> , etc.  (a lot of them). <br><br><h4>  7. C ++ 11: <code>std::stoi</code> </h4><br>  Thanks to <a href="https://habrahabr.ru/users/lol4t0/" class="user_link">Lol4t0</a> for recalling the <a href="http://en.cppreference.com/w/cpp/string/basic_string/stol"><code>std::stoi/std::stol/std::stoll</code></a> functions in the C ++ 11 <a href="http://en.cppreference.com/w/cpp/string/basic_string/stol"><code>std::stoi/std::stol/std::stoll</code></a> .  We will read one line with getline, and then parse it with stol.  The code will look like this: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max_stoi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::istream &amp; f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> max = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> line; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::getline(f, line)) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::stoi(line); max = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(x, max); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max; }</code> </pre><br>  Work time: <b>1.04 seconds</b> <br>  This is the fastest standard way to read integers.  (And for floating point numbers there are similar functions stof / stod). <br><br><h4>  8. Bonus: Reading in big blocks + Boost :: Spirit </h4><br>  Let's try to write the fastest option.  We will read the input data in large blocks and then parse with <a href="http://www.boost.org/doc/libs/1_57_0/libs/spirit/doc/html/spirit/qi.html">Boost :: Spirit :: Qi</a> , which is declared as a generator of very fast parsers.  This is a compile-time generator: we describe a grammar in C ++ in notation close to BNF, and a parser is generated during compilation using metaprogramming magic. <br><div class="spoiler">  <b class="spoiler_title">Code (attention, boost and metaprogramming detected!)</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;boost/spirit/include/qi.hpp&gt; #include &lt;boost/spirit/include/phoenix_core.hpp&gt; #include &lt;boost/spirit/include/phoenix_operator.hpp&gt; #include &lt;boost/spirit/include/phoenix_statement.hpp&gt; template &lt;typename Iterator&gt; Iterator max_parser(Iterator first, Iterator last, int&amp; max) { namespace qi = boost::spirit::qi; namespace ascii = boost::spirit::ascii; namespace phoenix = boost::phoenix; using qi::int_; using qi::_1; using ascii::space; using phoenix::ref; using phoenix::if_; using qi::eoi; using qi::lexeme; bool r = qi::phrase_parse(first, last, // Begin grammar ( *lexeme[int_ &gt;&gt; (!eoi)][if_(_1 &gt; ref(max))[ref(max) = _1]] ) , // End grammar space); return first; } int max_spirit(std::istream &amp; f) { size_t chunk_size = 1 &lt;&lt; 20; std::unique_ptr&lt;char[]&gt; buffer(new char[2*chunk_size]); char * middle = buffer.get() + chunk_size; char * begin = middle; int max = -1; while(true) { f.read(middle, chunk_size); if (f.gcount() == 0) break; char * end = middle + f.gcount(); char * last = max_parser(begin, end, max); if (last &lt; middle) break; // copy the remaining data just before the middle: begin = middle - (end - last); std::copy(last, end, begin); } return max; }</span></span></span></span></code> </pre><br></div></div><br>  Work time: <b>0.18</b> s <br>  This is a record! <br><br><h4>  Results and Tips </h4><br><h5>  Working hours: </h5><br><table><tbody><tr><th>  No </th><th>  Method </th><th>  GCC 4.9.1 </th><th>  clang 3.5.0 + libc ++ </th><th>  GCC 100M * </th></tr><tr><td>  one </td><td>  scanf </td><td>  1.41 </td><td>  1.48 </td></tr><tr><td>  2 </td><td>  std :: cin </td><td>  4.41 </td><td>  13.30 </td></tr><tr><td>  3 </td><td>  std :: cin and std :: ios :: sync_with_stdio (false) </td><td>  1.33 </td><td>  13.24 </td></tr><tr><td>  four </td><td>  std :: istringstream </td><td>  7.21 </td><td>  9.16 </td></tr><tr><td>  five </td><td>  std :: istringstream with reuse </td><td>  2.16 </td><td>  7.92 </td></tr><tr><td>  6a </td><td>  getchar </td><td>  0.82 </td><td>  0.84 </td><td>  9.14 </td></tr><tr><td>  6b </td><td>  getchar_unlocked </td><td>  0.28 </td><td>  0.26 </td><td>  2.94 </td></tr><tr><td>  7 </td><td>  std :: getline + std :: stoi </td><td>  1.04 </td><td>  3.53 </td><td>  10.8 </td></tr><tr><td>  eight </td><td>  Big block + Boost :: Spirit </td><td>  0.18 </td><td>  1.67 </td><td>  1.90 </td></tr></tbody></table><br>  * - Measurements on a file with 100 million numbers (file size is 848 megabytes). <br><br><h5>  Recommendations: </h5><br><ul><li>  In C ++ 11, the fastest standard way to read numbers from a stream is <code>std::getline</code> + <a href="http://en.cppreference.com/w/cpp/string/basic_string/stol"><code>std::stol</code></a> (in combination with <code>sync_with_stdio(false)</code> if the standard stream is <code>std::cin</code> ).  This method is much faster than scanf and second only to getchar methods. </li><li>  To speed up <code>std::cin/std::cout</code> , you can use <code>std::ios::sync_with_stdio(false);</code>  In this case, the speed will be comparable or better than scanf.  (Just make sure you don't mix stream and stdio operations on the same stream.) </li><li>  Istringstream has a very slow constructor.  Therefore, the performance can be seriously raised if you reuse the stream object. </li><li>  Greater performance can be achieved using <code>getchar_unlocked</code> (or just <code>getchar</code> if thread safety is needed) and a custom parser. </li><li>  Even better performance can be achieved if you read the data in large chunks and then work exclusively in memory. </li></ul><br>  Attention!  The results are valid only on a specific system and can vary greatly on other systems!  In particular, I quickly tried clang + libc ++ and got much worse thread performance (whereas with libstdc ++, both clang and gcc gave almost identical results).  Be sure to test performance when applying tips!  (And ideally, report the results on your system in the comments so that others can use it).  The full code is available <a href="https://gist.github.com/ilyapopov/1006a5a5ccdfdde85935">here</a> . <br><br>  <b>Update 1.</b> On the advice of <a href="https://habrahabr.ru/users/lol4t0/" class="user_link">Lol4t0</a> method number 7 is added. <br>  <b>Update 2.</b> The runtime on clang + libc ++ has been added to the table (version 3.5.0, performed on the same system).  It can be seen that the performance of the threads is very bad, and besides the trick with turning off synchronization does not work.  As a result, stoi is 2 times slower than scanf. <br>  <b>Update 3.</b> Added option number 8: reading in large blocks and parsing with Boost :: Spirit.  And this is a champion! </div><p>Source: <a href="https://habr.com/ru/post/246257/">https://habr.com/ru/post/246257/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../246245/index.html">Smartphone owners, on average, spend 5‚Öì hours a year waiting for video to load.</a></li>
<li><a href="../246247/index.html">How to build your own framework for iOS</a></li>
<li><a href="../246249/index.html">Security Meetup at the Mail.Ru Group office - how it was</a></li>
<li><a href="../246251/index.html">Key qualities of business intelligence in IT</a></li>
<li><a href="../246253/index.html">As we increased the responsiveness of the application</a></li>
<li><a href="../246259/index.html">WebGL or Three.js vs Babylon.js game world</a></li>
<li><a href="../246263/index.html">5 improvements for the site, which can increase sales by 3 times</a></li>
<li><a href="../246265/index.html">C # for AS3 developers. Part 2: Extending Classes and Implementing Interfaces</a></li>
<li><a href="../246269/index.html">Promotional codes for the free Microsoft 70-695, 70-696 exams</a></li>
<li><a href="../246273/index.html">WordPress updated to version 4.1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>