<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hierarchical clustering of categorical data in R</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The translation was prepared for students of the course ‚ÄúApplied Analytics on R‚Äù . 




 This was my first attempt to cluster clients based on real da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hierarchical clustering of categorical data in R</h1><div class="post__text post__text-html js-mediator-article">  <i>The translation was prepared for students of the course <a href="https://otus.pw/Bxbt/">‚ÄúApplied Analytics on R‚Äù</a> .</i> <br><br><img src="https://habrastorage.org/webt/wq/q0/sp/wqq0sphqihtnsg1f8eor15ffkgi.png"><br><hr><br><br>  This was my first attempt to cluster clients based on real data, and it gave me valuable experience.  There are many articles on the Internet about clustering using numerical variables, but finding solutions for categorical data, which is somewhat more difficult, was not so simple.  Clustering methods for categorical data are still under development, and in another post I am going to try another one. <br><a name="habracut"></a><br>  On the other hand, many people think that clustering categorical data may not produce meaningful results - and this is partly true (see the <a href="https://stats.stackexchange.com/questions/218604/with-categorical-data-can-there-be-clusters-without-the-variables-being-related">excellent discussion on CrossValidated</a> ).  At one point, I thought: ‚ÄúWhat am I doing?  They can simply be divided into cohorts. ‚Äù  However, cohort analysis is also not always advisable, especially with a significant number of categorical variables with a large number of levels: you can easily deal with 5-7 cohorts, but if you have 22 variables and each has 5 levels (for example, a customer survey with discrete estimates 1 , 2, 3, 4 and 5), and you need to understand what characteristic groups of clients you are dealing with - you will get 22x5 cohorts.  No one wants to bother with such a task.  And here clustering could help.  So in this post I‚Äôll talk about what I myself would like to know as soon as I started clustering. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The clustering process itself consists of three steps: <br><br><ol><li>  Building a matrix of dissimilarity is undoubtedly the most important decision in clustering.  All subsequent steps will be based on the dissimilarity matrix you created. </li><li>  The choice of clustering method. </li><li>  Cluster Evaluation. </li></ol><br>  This post will be a kind of introduction that describes the basic principles of clustering and its implementation in the environment R. <br><br><h2>  Dissimilarity matrix </h2><br>  The basis for clustering will be the dissimilarity matrix, which in mathematical terms describes how different the points in the data set are (removed) from each other.  It allows you to further combine into groups those points that are closest to each other, or to separate the most distant from each other - this is the main idea of ‚Äã‚Äãclustering. <br><br>  At this stage, differences between data types are important, since the dissimilarity matrix is ‚Äã‚Äãbuilt on the basis of the distances between the individual data points.  It is easy to imagine the distances between the points of numerical data (a well-known example is <a href="https://en.wikipedia.org/wiki/Euclidean_distance">Euclidean distances</a> ), but in the case of categorical data (factors in R), everything is not so obvious. <br><br>  In order to construct a dissimilarity matrix in this case, the so-called Gover distance should be used.  I will not delve into the mathematical part of this concept, I will simply provide links: <a href="http://venus.unive.it/romanaz/modstat_ba/gowdis.pdf">here</a> and <a href="https://www.rdocumentation.org/packages/cluster/versions/2.0.6/topics/daisy">there</a> .  For this, I prefer to use <code>daisy()</code> with the <code>metric = c("gower")</code> from the <code>cluster</code> package. <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">#-----   -----# #    ,       ,     ,   ,    library(dplyr) #     set.seed(40) #     #    ;   data.frame()     #    ,   200   1  200 id.s &lt;- c(1:200) %&gt;% factor() budget.s &lt;- sample(c("small", "med", "large"), 200, replace = T) %&gt;% factor(levels=c("small", "med", "large"), ordered = TRUE) origins.s &lt;- sample(c("x", "y", "z"), 200, replace = T, prob = c(0.7, 0.15, 0.15)) area.s &lt;- sample(c("area1", "area2", "area3", "area4"), 200, replace = T, prob = c(0.3, 0.1, 0.5, 0.2)) source.s &lt;- sample(c("facebook", "email", "link", "app"), 200, replace = T, prob = c(0.1,0.2, 0.3, 0.4)) ##   ‚Äî      dow.s &lt;- sample(c("mon", "tue", "wed", "thu", "fri", "sat", "sun"), 200, replace = T, prob = c(0.1, 0.1, 0.2, 0.2, 0.1, 0.1, 0.2)) %&gt;% factor(levels=c("mon", "tue", "wed", "thu", "fri", "sat", "sun"), ordered = TRUE) #  dish.s &lt;- sample(c("delicious", "the one you don't like", "pizza"), 200, replace = T) #   data.frame()      synthetic.customers &lt;- data.frame(id.s, budget.s, origins.s, area.s, source.s, dow.s, dish.s) #-----   -----# library(cluster) #       #   : daisy(), diana(), clusplot() gower.dist &lt;- daisy(synthetic.customers[ ,2:7], metric = c("gower")) # class(gower.dist) ## , </span></span></code> </pre> <br>  The dissimilarity matrix is ‚Äã‚Äãready.  For 200 observations, it is built quickly, but may require a very large amount of computation if you are dealing with a large data set. <br><br>  In practice, it is very likely that you will first have to clean the data set, perform the necessary transformations from the rows into factors, and track the missing values.  In my case, the data set also contained rows of missing values, which were beautifully clustered each time, so it seemed like it was a treasure, until I looked at the values ‚Äã‚Äã(alas!). <br><br><h2>  Clustering Algorithms </h2><br>  You may already know that clustering is <i>k-means and hierarchical</i> .  In this post, I focus on the second method, since it is more flexible and allows various approaches: you can choose either <i>agglomerative</i> (from bottom to top) or <i>divisional</i> (top to bottom) clustering algorithm. <br><br><img src="https://habrastorage.org/webt/nl/vp/u4/nlvpu4e8ykoh_nd_el_4i6plh8q.png"><br>  <i>Source: <a href="http://uc-r.github.io/hc_clustering">UC Business Analytics R Programming Guide</a></i> <br><br>  Agglomerative clustering begins with <code>n</code> clusters, where <code>n</code> is the number of observations: it is assumed that each of them is a separate cluster.  Then the algorithm tries to find and group the most similar data points among themselves - this is how cluster formation begins. <br><br>  Divisional clustering is performed in the opposite way - it is initially assumed that all n data points that we have are one large cluster, and then the least similar ones are divided into separate groups. <br><br>  When deciding which of these methods to choose, it always makes sense to try all the options, however, in general, <i>agglomerative clustering is better for identifying small clusters and is used by most computer programs, and divisional clustering is more suitable for identifying large clusters</i> . <br><br>  Personally, before deciding which method to use, I prefer to look at dendrograms - a graphical representation of clustering.  As you will see later, some dendrograms are well balanced, while others are very chaotic. <br><br>  # The main input for the code below is the dissimilarity (distance matrix) <br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">#             #            ‚Äî         ‚Äî    #------------  ------------# divisive.clust &lt;- diana(as.matrix(gower.dist), diss = TRUE, keep.diss = TRUE) plot(divisive.clust, main = "Divisive")</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/54/mp/m1/54mpm19v8jkkpmj6usehxlgr5qk.png"><br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">#------------   ------------# #      #         ‚Äî     ,      #    (complete linkages) aggl.clust.c &lt;- hclust(gower.dist, method = "complete") plot(aggl.clust.c, main = "Agglomerative, complete linkages")</span></span></code> </pre> <br><h2>  Clustering Quality Assessment </h2><br>  At this stage, it is necessary to make a choice between different clustering algorithms and a different number of clusters.  You can use different methods of assessment, not forgetting to be guided by <b>common sense</b> .  I highlighted these words in bold and italics, because the meaningfulness of the choice is <b>very important</b> - the number of clusters and the method of dividing data into groups should be practical.  The number of combinations of values ‚Äã‚Äãof categorical variables is finite (since they are discrete), but not any breakdown based on them will be meaningful.  You may also not want to have very few clusters - in this case they will be too generalized.  In the end, it all depends on your goal and the tasks of the analysis. <br><br>  In general, when creating clusters, you are interested in obtaining clearly defined groups of data points, so that the distance between such points within the cluster ( <i>or compactness</i> ) is minimal, and the distance between groups ( <i>separability</i> ) is the maximum possible.  This is easy to understand intuitively: the distance between the points is a measure of their dissimilarity, obtained on the basis of the dissimilarity matrix.  Thus, the assessment of the quality of clustering is based on the assessment of compactness and separability. <br><br>  Next, I will demonstrate two approaches and show that one of them can give meaningless results. <br><br><ul><li>  <i>Elbow method</i> : start with it if the most important factor for your analysis is the compactness of the clusters, i.e. similarity within the groups. </li><li>  <i>Silhouettes Assessment Method</i> : The <i>silhouette</i> graph used as a measure of data consistency shows how close each of the points within the same cluster is to the points in neighboring clusters. </li></ul><br>  In practice, these two methods often give different results, which can lead to some confusion - the maximum compactness and the clearest separation will be achieved with a different number of clusters, so common sense and understanding of what your data really means will play an important role when making a final decision. <br><br>  There are also a number of metrics that you can analyze.  I will add them directly to the code. <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">#      ,        #      ,     ,   ‚Äî   #     ,      ,         ,   ,     library(fpc) cstats.table &lt;- function(dist, tree, k) { clust.assess &lt;- c("cluster.number","n","within.cluster.ss","average.within","average.between", "wb.ratio","dunn2","avg.silwidth") clust.size &lt;- c("cluster.size") stats.names &lt;- c() row.clust &lt;- c() output.stats &lt;- matrix(ncol = k, nrow = length(clust.assess)) cluster.sizes &lt;- matrix(ncol = k, nrow = k) for(i in c(1:k)){ row.clust[i] &lt;- paste("Cluster-", i, " size") } for(i in c(2:k)){ stats.names[i] &lt;- paste("Test", i-1) for(j in seq_along(clust.assess)){ output.stats[j, i] &lt;- unlist(cluster.stats(d = dist, clustering = cutree(tree, k = i))[clust.assess])[j] } for(d in 1:k) { cluster.sizes[d, i] &lt;- unlist(cluster.stats(d = dist, clustering = cutree(tree, k = i))[clust.size])[d] dim(cluster.sizes[d, i]) &lt;- c(length(cluster.sizes[i]), 1) cluster.sizes[d, i] } } output.stats.df &lt;- data.frame(output.stats) cluster.sizes &lt;- data.frame(cluster.sizes) cluster.sizes[is.na(cluster.sizes)] &lt;- 0 rows.all &lt;- c(clust.assess, row.clust) # rownames(output.stats.df) &lt;- clust.assess output &lt;- rbind(output.stats.df, cluster.sizes)[ ,-1] colnames(output) &lt;- stats.names[2:k] rownames(output) &lt;- rows.all is.num &lt;- sapply(output, is.numeric) output[is.num] &lt;- lapply(output[is.num], round, 2) output } #     :      7 #     ,            stats.df.divisive &lt;- cstats.table(gower.dist, divisive.clust, 7) stats.df.divisive</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/r-/g_/ou/r-g_oukwyorhqnsls_cbg4c8spw.png"><br><br>  So, the average.within indicator, which represents the average distance between observations within clusters, decreases, as does within.cluster.ss (the sum of the squares of the distances between observations in a cluster).  The average width of the silhouette (avg.silwidth) does not change so unambiguously, however, an inverse relationship can still be seen. <br>  Notice how disproportionate cluster sizes are.  I would not rush to work with an incomparable number of observations within clusters.  One of the reasons is that the data set may be unbalanced, and some group of observations will outweigh all the others in the analysis - this is not good and will most likely lead to errors. <br><br> <code>stats.df.aggl &lt;-cstats.table(gower.dist, aggl.clust.c, 7) #      </code> <br> <br> <code>stats.df.aggl</code> <br> <br><img src="https://habrastorage.org/webt/a_/-u/aa/a_-uaa_nff99nuyobulroyk_hka.png"><br><br>  Notice how agglomerative hierarchical clustering based on the full communication method is balanced in terms of the number of observations per group. <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment"># ---------    ---------# #   ¬´¬ª       #    ,     7  library(ggplot2) #  #   ggplot(data = data.frame(t(cstats.table(gower.dist, divisive.clust, 15))), aes(x=cluster.number, y=within.cluster.ss)) + geom_point()+ geom_line()+ ggtitle("Divisive clustering") + labs(x = "Num.of clusters", y = "Within clusters sum of squares (SS)") + theme(plot.title = element_text(hjust = 0.5))</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/kw/kz/xy/kwkzxyuuzwhe0yst9kteg9inias.png"><br><br>  So, we have created a graph of the "elbow".  It shows how the sum of the squared distances between the observations (we use it as a measure of the proximity of the observations - the smaller it is, the closer the measurements inside the cluster are to each other) varies for a different number of clusters.  Ideally, we should see a distinct ‚Äúelbow bend‚Äù at the point where further clustering gives only a slight decrease in the sum of squares (SS).  For the graph below, I would stop at about 7. Although in this case one of the clusters will consist of only two observations.  Let's see what happens during agglomerative clustering. <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">#       ggplot(data = data.frame(t(cstats.table(gower.dist, aggl.clust.c, 15))), aes(x=cluster.number, y=within.cluster.ss)) + geom_point()+ geom_line()+ ggtitle("Agglomerative clustering") + labs(x = "Num.of clusters", y = "Within clusters sum of squares (SS)") + theme(plot.title = element_text(hjust = 0.5))</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/y0/ck/q-/y0ckq-zxtzg0fbjr9gcq1jgorvq.png"><br><br>  Agglomerative "elbow" is similar to divisional, but the graph looks smoother - bends are not so pronounced.  As with divisional clustering, I would focus on 7 clusters, however, when choosing between the two methods, I like the cluster sizes that are obtained by the agglomerative method better ‚Äî it is better that they are comparable with each other. <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">#  ggplot(data = data.frame(t(cstats.table(gower.dist, divisive.clust, 15))), aes(x=cluster.number, y=avg.silwidth)) + geom_point()+ geom_line()+ ggtitle("Divisive clustering") + labs(x = "Num.of clusters", y = "Average silhouette width") + theme(plot.title = element_text(hjust = 0.5))</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/u9/nj/nf/u9njnfcjqbxbzlfgpl5sxqailra.png"><br><br>  When using the silhouette estimation method, you should choose the amount that gives the maximum silhouette coefficient, because you need clusters that are far enough apart to be considered separate. <br><br>  The silhouette coefficient can range from ‚Äì1 to 1, with 1 corresponding to good consistency within the clusters, and ‚Äì1 not very good. <br>  In the case of the above chart, you would choose 9 rather than 5 clusters. <br><br>  For comparison: in the ‚Äúsimple‚Äù case, the silhouette graph is similar to the one below.  Not quite like ours, but almost. <br><br><img src="https://habrastorage.org/webt/18/yw/uj/18ywujz8uh4q5hhnhtxlzrgs1nm.png"><br>  <i>Source: <a href="http://data-sailors.com/2016/10/17/let-the-machine-find-optimal-number-of-clusters-from-your-data/">Data Sailors</a></i> <br><br><pre> <code class="sql hljs">ggplot(data = data.frame(t(cstats.table(gower.dist, aggl.clust.c, 15))), aes(x=cluster.number, y=avg.silwidth)) + geom_point()+ geom_line()+ ggtitle("Agglomerative clustering") + labs(x = "Num.of clusters", y = "Average silhouette width") + theme(plot.title = element_text(hjust = 0.5))</code> </pre> <br><img src="https://habrastorage.org/webt/vk/f1/fl/vkf1fln-v-nedwuh6rzbjkxz2pg.png"><br><br>  The silhouette width chart tells us: the more you split the data set, the clearer the clusters become.  However, in the end you will reach individual points, and you do not need this.  However, this is exactly what you will see if you start to increase the number of clusters <i>k</i> .  For example, for <code>k=30</code> I got the following graph: <br><br><img src="https://habrastorage.org/webt/sz/nq/sy/sznqsykdros9uf8clfabfg8yb94.png"><br><br>  To summarize: the more you split the dataset, the better the clusters, but we cannot reach individual points (for example, in the chart above we selected 30 clusters, and we only have 200 data points). <br><br>  So, agglomerative clustering in our case seems to me much more balanced: cluster sizes are more or less comparable (just look at a cluster of only two observations when dividing by the divisional method!), And I would stop at 7 clusters obtained by this method.  Let's see how they look and what they are made of. <br><br>  The data set consists of 6 variables that need to be visualized in 2D or 3D, so you have to work hard!  The nature of categorical data also imposes some limitations, so ready-made solutions may not work.  I need to: a) see how observations are divided into clusters, b) understand how observations are categorized.  Therefore, I created a) a color dendrogram, b) a heat map of the number of observations per variable inside each cluster. <br><br><pre> <code class="sql hljs">library("ggplot2") library("reshape2") library("purrr") library("dplyr") <span class="hljs-comment"><span class="hljs-comment">#    library("dendextend") dendro &lt;- as.dendrogram(aggl.clust.c) dendro.col &lt;- dendro %&gt;% set("branches_k_color", k = 7, value = c("darkslategray", "darkslategray4", "darkslategray3", "gold3", "darkcyan", "cyan3", "gold3")) %&gt;% set("branches_lwd", 0.6) %&gt;% set("labels_colors", value = c("darkslategray")) %&gt;% set("labels_cex", 0.5) ggd1 &lt;- as.ggdend(dendro.col) ggplot(ggd1, theme = theme_minimal()) + labs(x = "Num. observations", y = "Height", title = "Dendrogram, k = 7")</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/iy/hf/jx/iyhfjxt9q7vztvwbaazmqlzzno0.png"><br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">#     ( ) ggplot(ggd1, labels = T) + scale_y_reverse(expand = c(0.2, 0)) + coord_polar(theta="x")</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/if/4g/yv/if4gyv42vtgecjd9n-b_0bb91rs.png"><br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">#  ‚Äî   #    ‚Äî       #    ,      clust.num &lt;- cutree(aggl.clust.c, k = 7) synthetic.customers.cl &lt;- cbind(synthetic.customers, clust.num) cust.long &lt;- melt(data.frame(lapply(synthetic.customers.cl, as.character), stringsAsFactors=FALSE), id = c("id.s", "clust.num"), factorsAsStrings=T) cust.long.q &lt;- cust.long %&gt;% group_by(clust.num, variable, value) %&gt;% mutate(count = n_distinct(id.s)) %&gt;% distinct(clust.num, variable, value, count) # heatmap.c ,      ‚Äî ,   ,     heatmap.c &lt;- ggplot(cust.long.q, aes(x = clust.num, y = factor(value, levels = c("x","y","z", "mon", "tue", "wed", "thu", "fri","sat","sun", "delicious", "the one you don't like", "pizza", "facebook", "email", "link", "app", "area1", "area2", "area3", "area4", "small", "med", "large"), ordered = T))) + geom_tile(aes(fill = count))+ scale_fill_gradient2(low = "darkslategray1", mid = "yellow", high = "turquoise4") #            cust.long.p &lt;- cust.long.q %&gt;% group_by(clust.num, variable) %&gt;% mutate(perc = count / sum(count)) %&gt;% arrange(clust.num) heatmap.p &lt;- ggplot(cust.long.p, aes(x = clust.num, y = factor(value, levels = c("x","y","z", "mon", "tue", "wed", "thu", "fri","sat", "sun", "delicious", "the one you don't like", "pizza", "facebook", "email", "link", "app", "area1", "area2", "area3", "area4", "small", "med", "large"), ordered = T))) + geom_tile(aes(fill = perc), alpha = 0.85)+ labs(title = "Distribution of characteristics across clusters", x = "Cluster number", y = NULL) + geom_hline(yintercept = 3.5) + geom_hline(yintercept = 10.5) + geom_hline(yintercept = 13.5) + geom_hline(yintercept = 17.5) + geom_hline(yintercept = 21.5) + scale_fill_gradient2(low = "darkslategray1", mid = "yellow", high = "turquoise4") heatmap.p</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/c5/gg/y5/c5ggy5vih07qcfi4h26mgcvkfgy.png"><br><br>  The heat map graphically shows how many observations are made for each factor level for the initial factors (the variables we started with).  Dark blue color corresponds to a relatively large number of observations within the cluster.  This heat map also shows that for the day of the week (sun, sat ... mon) and the basket size (large, med, small), the number of customers in each cell is almost the same - this may mean that these categories are not determinative for analysis, and Perhaps they do not need to be taken into account. <br><br><h2>  Conclusion </h2><br>  In this article, we calculated the dissimilarity matrix, tested the agglomerative and divisional methods of hierarchical clustering, and familiarized ourselves with the elbow and silhouette methods for assessing the quality of clusters. <br><br>  Divisional and agglomerative hierarchical clustering is a good start to study the topic, but do not stop there if you want to really master cluster analysis.  There are many other methods and techniques.  The main difference from clustering numerical data is the calculation of the dissimilarity matrix.  When assessing the quality of clustering, not all standard methods will give reliable and meaningful results - the silhouette method is very likely not suitable. <br><br>  And finally, since some time has passed since I made this example, now I see a number of shortcomings in my approach and will be glad to any feedback.  One of the significant problems of my analysis was not related to clustering as such - <i>my data set was unbalanced</i> in many ways, and this moment remained unaccounted for.  This had a noticeable effect on clustering: 70% of clients belonged to one level of the ‚Äúcitizenship‚Äù factor, and this group dominated most of the clusters obtained, so it was difficult to calculate the differences within other levels of the factor.  Next time I will try to balance the data set and compare the clustering results.  But about this - in another post. <br><br>  Finally, if you want to clone my code, here is the link to github: <a href="https://github.com/khunreus/cluster-categorical">https://github.com/khunreus/cluster-categorical</a> <br>  I hope you enjoyed this article! <br><br><h3>  <i>Sources that helped me:</i> </h3><br>  Hierarchical clustering guide (data preparation, clustering, visualization) - this blog will be interesting for those who are interested in business analytics in the R environment: <a href="http://uc-r.github.io/hc_clustering">http://uc-r.github.io/hc_clustering</a> and <a href="https://uc-r.github.io/kmeans_clustering">https: // uc-r. github.io/kmeans_clustering</a> <br><br>  Clustering: <a href="http://www.sthda.com/english/articles/29-cluster-validation-essentials/97-cluster-validation-statistics-must-know-methods/">http://www.sthda.com/english/articles/29-cluster-validation-essentials/97-cluster-validation-statistics-must-know-methods/</a> <br><br>    (   k-): <a href="https://eight2late.wordpress.com/2015/07/22/a-gentle-introduction-to-cluster-analysis-using-r/">https://eight2late.wordpress.com/2015/07/22/a-gentle-introduction-to-cluster-analysis-using-r/</a> <br><br>    denextend,        : <a href="https://cran.r-project.org/web/packages/dendextend/vignettes/introduction.html">https://cran.r-project.org/web/packages/dendextend/vignettes/introduction.html#the-set-function</a> <br><br>    ,   : <a href="https://www.r-statistics.com/2010/06/clustergram-visualization-and-diagnostics-for-cluster-analysis-r-code/">https://www.r-statistics.com/2010/06/clustergram-visualization-and-diagnostics-for-cluster-analysis-r-code/</a> <br><br>     : <a href="https://jcoliver.github.io/learn-r/008-ggplot-dendrograms-and-heatmaps.html">https://jcoliver.github.io/learn-r/008-ggplot-dendrograms-and-heatmaps.html</a> <br><br>       ,    <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5025633/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5025633/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (repository on GitHub: </font></font><a href="https://github.com/khunreus/EnsCat"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/khunreus/EnsCat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></div><p>Source: <a href="https://habr.com/ru/post/461741/">https://habr.com/ru/post/461741/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../46173/index.html">Chinese cybercafes forcibly translate to Linux</a></li>
<li><a href="../461733/index.html">Learning English: 9 American-style idioms</a></li>
<li><a href="../461735/index.html">FFmpeg DXVA2 Hardware Decoding Practice</a></li>
<li><a href="../461737/index.html">We collect the environment for modern TDD on JavaScript + VS code</a></li>
<li><a href="../461739/index.html">Backend United 4: Okroshka. Incidents</a></li>
<li><a href="../461743/index.html">Security Week 31: VLC vulnerability and broken phone</a></li>
<li><a href="../461745/index.html">Russian black market prices for breaking through personal data (plus a response to Tinkoff Bank's answer)</a></li>
<li><a href="../461747/index.html">How we implemented ML in an application with nearly 50 million users. Sberbank Experience</a></li>
<li><a href="../461751/index.html">Designer's contribution to mobile app development</a></li>
<li><a href="../461753/index.html">InterSystems IRIS Global Transactions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>