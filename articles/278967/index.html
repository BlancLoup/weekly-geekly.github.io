<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>STM32 and LCD, fast screen fill</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At present, various liquid crystal displays, which are perfectly connected to the STM32 family of controllers, have become popular. This article will ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>STM32 and LCD, fast screen fill</h1><div class="post__text post__text-html js-mediator-article">  At present, various liquid crystal displays, which are perfectly connected to the STM32 family of controllers, have become popular.  This article will discuss one of the common STM32F103C8T6 controllers and a 7 "display on the SSD1963 controller. Both as finished units are easily available on Aliexpress and are relatively inexpensive. Of course, everything discussed below is true for other displays with a parallel interface and most STM32 controllers . <br><a name="habracut"></a><br>  Here are the connectable devices: <br><br><img src="https://habrastorage.org/files/fe1/3f3/2d1/fe13f32d1d054345901b9974771f8a7e.jpg" alt="image"><br><br><img src="https://habrastorage.org/files/eb9/ffd/bcd/eb9ffdbcd75a4b9992030246cf54777c.jpg" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Included with the display was pinout pinouts and initialization code for the 51st controller with comments in the language of the manufacturer. <br><br><h3>  Briefly about connecting </h3><br>  Connecting the display consists in supplying 3.3 and 5 volts of power to the required outputs and connecting the information lines to the controller.  Control signals D / C, WE, RST are connected to free I / O lines on the processor.  In our case, this is D / C - PA1, WE - PA8, RST - PA2.  The signals RD and CS can be not used, and a logical unit must be supplied to the RD, i.e.  connect via a resistor (in this case, 4.7 kOhm) to +3.3 V, and to CS - ‚Äú0‚Äù, i.e.  connect to the ground. <br><br><div class="spoiler">  <b class="spoiler_title">Comment</b> <div class="spoiler_text">  The display is configured by the manufacturer for operation of the interface in the 8080 mode, and, according to the documentation, the CS ‚Äúchip select‚Äù signal must be enabled: <br><br><img src="https://habrastorage.org/files/b56/f6f/d94/b56f6fd940c74bac980fb242546126bd.jpg" alt="image"><br><br>  Initially, he worked.  However, as the verification showed, if you do not want to use the data bus for other purposes, it is not needed. <br></div></div><br>  Next you need to connect the data bus.  In this display, it is assumed to be 16-bit, but it is possible to select 8 and 9 bit modes of operation during initialization.  That is, you need to connect at least the display lines DB0-DB7, as well as the maximum DB8-DB15.  For ease of programming and minimizing data conversion commands, it is better to add them to one I / O group.  If we consider the option of a 16-bit data bus, then it is not necessary to choose on this microcontroller - only PB0 - PB15. <br><br>  We connect them accordingly with the DB0-DB15 display: <br><br><div class="spoiler">  <b class="spoiler_title">Comment</b> <div class="spoiler_text">  Of course there is also PA0-PA15, but if we want to use ST-Link for debugging, then a couple of them are already taken. <br></div></div><br>  There are a lot of unconnected contacts on the display comb, do not be confused by this.  It has an SD memory card slot, a screen sensor, there is even an EEPROM memory card layout, but it is missing.  These devices and occupy the rest of the connector.  By the way, a 40-pin display connector is ideal for the PATA cable of computer hard drives. <br><br><div class="spoiler">  <b class="spoiler_title">Like this</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/4d3/812/8fa/4d38128fa569431b84ed35cb7ab46d95.jpg"><br></div></div><br><h3>  Display initialization </h3><br>  The original code was transferred almost unchanged to the project, only conditional compilation was added to select the data bus width (initialization and commands go over an 8-bit bus, regardless of this mode). <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SET_LCD_RDS LCD_RDS_PORT-&gt;BSRR = LCD_RDS #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RESET_LCD_RDS LCD_RDS_PORT-&gt;BRR = LCD_RDS #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SET_LCD_WR LCD_WR_PORT-&gt;BSRR = LCD_WR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RESET_LCD_WR LCD_WR_PORT-&gt;BRR = LCD_WR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SET_LCD_RST LCD_RST_PORT-&gt;BSRR = LCD_RST #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RESET_LCD_RST LCD_RST_PORT-&gt;BRR = LCD_RST void SSD1963_Init (void) { uint16_t HDP=799; uint16_t HT=928; uint16_t HPS=46; uint16_t LPS=15; uint8_t HPW=48; uint16_t VDP=479; uint16_t VT=525; uint16_t VPS=16; uint16_t FPS=8; uint8_t VPW=16; RESET_LCD_RST; delay_ms(5); SET_LCD_RST; delay_ms(5); SSD1963_WriteCommand(0x00E2); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//PLL multiplier, set PLL clock to 120M SSD1963_WriteData(0x0023); //N=0x36 for 6.5M, 0x23 for 10M crystal SSD1963_WriteData(0x0002); SSD1963_WriteData(0x0004); SSD1963_WriteCommand(0x00E0); // PLL enable SSD1963_WriteData(0x0001); delay_ms(1); SSD1963_WriteCommand(0x00E0); SSD1963_WriteData(0x0003); delay_ms(5); SSD1963_WriteCommand(0x0001); // software reset delay_ms(5); SSD1963_WriteCommand(0x00E6); //PLL setting for PCLK, depends on resolution SSD1963_WriteData(0x0003); SSD1963_WriteData(0x00ff); SSD1963_WriteData(0x00ff); SSD1963_WriteCommand(0x00B0); //LCD SPECIFICATION SSD1963_WriteData(0x0000); SSD1963_WriteData(0x0000); SSD1963_WriteData((HDP&gt;&gt;8)&amp;0X00FF); //Set HDP SSD1963_WriteData(HDP&amp;0X00FF); SSD1963_WriteData((VDP&gt;&gt;8)&amp;0X00FF); //Set VDP SSD1963_WriteData(VDP&amp;0X00FF); SSD1963_WriteData(0x0000); SSD1963_WriteCommand(0x00B4); //HSYNC SSD1963_WriteData((HT&gt;&gt;8)&amp;0X00FF); //Set HT SSD1963_WriteData(HT&amp;0X00FF); SSD1963_WriteData((HPS&gt;&gt;8)&amp;0X00FF); //Set HPS SSD1963_WriteData(HPS&amp;0X00FF); SSD1963_WriteData(HPW); //Set HPW SSD1963_WriteData((LPS&gt;&gt;8)&amp;0X00FF); //Set HPS SSD1963_WriteData(LPS&amp;0X00FF); SSD1963_WriteData(0x0000); SSD1963_WriteCommand(0x00B6); //VSYNC SSD1963_WriteData((VT&gt;&gt;8)&amp;0X00FF); //Set VT SSD1963_WriteData(VT&amp;0X00FF); SSD1963_WriteData((VPS&gt;&gt;8)&amp;0X00FF); //Set VPS SSD1963_WriteData(VPS&amp;0X00FF); SSD1963_WriteData(VPW); //Set VPW SSD1963_WriteData((FPS&gt;&gt;8)&amp;0X00FF); //Set FPS SSD1963_WriteData(FPS&amp;0X00FF); SSD1963_WriteCommand(0x00BA); SSD1963_WriteData(0x0005); //GPIO[3:0] out 1 SSD1963_WriteCommand(0x00B8); SSD1963_WriteData(0x0007); //GPIO3=input, GPIO[2:0]=output SSD1963_WriteData(0x0001); //GPIO0 normal SSD1963_WriteCommand(0x0036); //rotation SSD1963_WriteData(0x0000); SSD1963_WriteCommand(0x00F0); //pixel data interface #if DATAPIXELWIDTH==16 SSD1963_WriteData(0x0003); //16 bit (565) #endif #if DATAPIXELWIDTH==9 SSD1963_WriteData(0x0006); // 9 bit #endif #if DATAPIXELWIDTH==8 SSD1963_WriteData(0x0000); // 8 bit #endif delay_ms(5); SSD1963_WriteCommand(0x0029); //display on SSD1963_WriteCommand(0x00d0); SSD1963_WriteData(0x000d); } void SSD1963_WriteCommand(uint16_t commandToWrite) { LCD_DATA_PORT-&gt;ODR = commandToWrite; RESET_LCD_RDS; RESET_LCD_WR; SET_LCD_WR; } void SSD1963_WriteData(uint16_t dataToWrite) { LCD_DATA_PORT-&gt;ODR = dataToWrite; SET_LCD_RDS; RESET_LCD_WR; SET_LCD_WR; }</span></span></span></span></code> </pre> <br></div></div><br>  In the code, there is no initialization of I / O ports and a system timer, based on which millisecond delays are realized (delay_ms ()). <br><br>  After performing initialization: <br><br><pre> <code class="cpp hljs"> tick_init(); <span class="hljs-comment"><span class="hljs-comment">//    lcd_port_init(); //   - SSD1963_Init(); //  </span></span></code> </pre><br>  We see the garbage of video memory on the display: <br><br><div class="spoiler">  <b class="spoiler_title">Garbage</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/35c/ad5/70f/35cad570f63944bd92f918bd4c12499f.jpg"><br></div></div><br><h3>  Display fill </h3><br>  Now I want to erase this garbage and fill the screen with some color.  In the source from the manufacturer the necessary material for writing the code is present.  We use it. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Fills whole screen specified color void SSD1963_SetArea(uint16_t x1, uint16_t x2, uint16_t y1, uint16_t y2) { SSD1963_WriteCommand(0x002a); SSD1963_WriteData((x1 &gt;&gt; 8) &amp; 0xff); SSD1963_WriteData(x1 &amp; 0xff); SSD1963_WriteData((x2 &gt;&gt; 8) &amp; 0xff); SSD1963_WriteData(x2 &amp; 0xff); SSD1963_WriteCommand(0x002a); SSD1963_WriteData((y1 &gt;&gt; 8) &amp; 0xff); SSD1963_WriteData(y1 &amp; 0xff); SSD1963_WriteData((y2 &gt;&gt; 8) &amp; 0xff); SSD1963_WriteData(y2 &amp; 0xff); } #if DATAPIXELWIDTH==16 void SSD1963_WriteDataPix(uint16_t pixdata) { LCD_DATA_PORT-&gt;ODR = pixdata; SET_LCD_RDS; RESET_LCD_WR; SET_LCD_WR; } #endif #if DATAPIXELWIDTH==9 void SSD1963_WriteDataPix(uint16_t pixdata) { LCD_DATA_PORT-&gt;ODR = (LCD_DATA_PORT-&gt;ODR &amp; 0xfe00) | ((pixdata &gt;&gt; 8) &amp; 0x000f) | ((pixdata &gt;&gt; 7) &amp; 0x01f0); SET_LCD_RDS; RESET_LCD_WR; SET_LCD_WR; LCD_DATA_PORT-&gt;ODR = (LCD_DATA_PORT-&gt;ODR &amp; 0xfe00) | ((pixdata &lt;&lt; 1) &amp; 0x01f7) | (pixdata &amp; 0x0001); RESET_LCD_WR; SET_LCD_WR; } #endif #if DATAPIXELWIDTH==8 void SSD1963_WriteDataPix(uint16_t pixdata) { LCD_DATA_PORT-&gt;ODR = (LCD_DATA_PORT-&gt;ODR &amp; 0xff00) | ((pixdata &gt;&gt; 8) &amp; 0x00f8) | ((pixdata &gt;&gt; 9) &amp; 0x0004); SET_LCD_RDS; RESET_LCD_WR; SET_LCD_WR; LCD_DATA_PORT-&gt;ODR = (LCD_DATA_PORT-&gt;ODR &amp; 0xff00) | ((pixdata &gt;&gt; 3) &amp; 0x00fc); RESET_LCD_WR; SET_LCD_WR; LCD_DATA_PORT-&gt;ODR = (LCD_DATA_PORT-&gt;ODR &amp; 0xff00) | ((pixdata &lt;&lt; 3) &amp; 0x00f8) | ((pixdata &lt;&lt; 2) &amp; 0x0004); RESET_LCD_WR; SET_LCD_WR; } #endif void SSD1963_ClearScreen(uint16_t color) { unsigned int x,y; SSD1963_SetArea(0, TFT_WIDTH-1 , 0, TFT_HEIGHT-1); SSD1963_WriteCommand(0x002c); for(x=0;x&lt;TFT_WIDTH;x++){ for(y= 0;y&lt;TFT_HEIGHT;y++){ SSD1963_WriteDataPix(color); } } }</span></span></code> </pre><br></div></div><br>  As you can see, the code depends on the selected bus width.  Accordingly, the time required for the transfer of the pixel to the display depends.  For a 16-bit bus, a pixel is transmitted in one transmission cycle over the data bus, for a 9-bit bus ‚Äî for two, for an 8-bit bus ‚Äî for 3. Where does this data come from?  From the documentation on SSD1963. <br><br><img src="https://habrastorage.org/files/04c/07f/5b7/04c07f5b731a4b0182f0d806fd95b38b.jpg"><br><br>  In the table you can find the location of each color component of the pixel, depending on the mode.  The project uses 8-bit, 9-bit and 16-bit modes (565 format).  As you can see, it was also possible to use the ‚Äúclean‚Äù 16-bit format for more accurate color coding, but it also requires three cycles of data transmission over the bus.  We cannot use the 18 and 24 bit formats because there is only a 16-bit bus at the display output. <br><br>  So, with what speed we can fill the display on a processor with a clock frequency of 72 MHz? <br><br>  176 ms - 16-bit bus <br>  374 ms - 9-bit bus <br>  470 ms - 8-bit bus <br><br>  Not very fast, of course, but it may be enough to display slowly changing information.  Of course, a 16-bit bus looks more attractive, and perhaps it will suit someone, but it takes too many I / O ports, which may then not be enough to connect other devices to the processor. <br><br>  Let's try to consider a compromise version - 9 bits, as winning almost 0.1 s for the 8-bit version at the expense of just one additional I / O port. <br><br><div class="spoiler">  <b class="spoiler_title">Waveform</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/501/190/12a/50119012afb749fda66b9db6b063aa9c.png"><br></div></div><br><h3>  Speed ‚Äã‚Äãoptimization </h3><br>  Let's try to speed up the process of pouring the display.  What if you reduce the number of logical operations within a loop? <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   18-  RGB666 void SSD1963_WriteDataPix_9(uint32_t pixdata) { uint32_t tmp = (LCD_DATA_PORT-&gt;ODR &amp; 0xfe00); SET_LCD_RDS; LCD_DATA_PORT-&gt;ODR = tmp | ((pixdata &gt;&gt; 9) &amp; 0x01ff); RESET_LCD_WR; SET_LCD_WR; LCD_DATA_PORT-&gt;ODR = tmp | (pixdata &amp; 0x01ff); RESET_LCD_WR; SET_LCD_WR; } //   18-  RGB666 void SSD1963_ClearScreen_9(uint32_t color) { unsigned int x,y; SSD1963_SetArea(0, TFT_WIDTH-1 , 0, TFT_HEIGHT-1); SSD1963_WriteCommand(0x002c); for(x=0;x&lt;TFT_WIDTH;x++) { for(y= 0;y&lt;TFT_HEIGHT;y++) { SSD1963_WriteDataPix_9(color); } } }</span></span></code> </pre><br>  Changed the color coding instead of the 16-bit variable in the RGB565 format, we use 32-bit, using only 18 of them in the RGB666 format.  In addition, we introduced a temporary variable to store the value of the register LCD_DATA_PORT-&gt; ODR during two cycles of outputting 9-bit data to the bus.  Here it is necessary to make a reservation that it is not always possible, because  during the output, the status of other ports of the GPIO B group configured for output can be changed at this time in the interrupt and the program will not work correctly.  However, in our case there are no such problems and we check what we have achieved.  So after the first optimization, the screen is filled in 9-bit mode for 298 ms.  If you do not use the variable and work with the current state of the port, then there is also a speed increase, although not so significant - 335 ms: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SSD1963_WriteDataPix_9</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pixdata)</span></span></span><span class="hljs-function"> </span></span>{ SET_LCD_RDS; LCD_DATA_PORT-&gt;ODR = (LCD_DATA_PORT-&gt;ODR &amp; <span class="hljs-number"><span class="hljs-number">0xfe00</span></span>) | ((pixdata &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x01ff</span></span>); RESET_LCD_WR; SET_LCD_WR; LCD_DATA_PORT-&gt;ODR = (LCD_DATA_PORT-&gt;ODR &amp; <span class="hljs-number"><span class="hljs-number">0xfe00</span></span>) | (pixdata &amp; <span class="hljs-number"><span class="hljs-number">0x01ff</span></span>); RESET_LCD_WR; SET_LCD_WR; }</code> </pre><br>  For the sake of speed, it is also possible to sacrifice the possibility of using the remaining ports of group B in the output mode and to remove the logical operations related to maintaining their state: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SSD1963_WriteDataPix_9</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pixdata)</span></span></span><span class="hljs-function"> </span></span>{ SET_LCD_RDS; LCD_DATA_PORT-&gt;ODR = pixdata &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>; RESET_LCD_WR; SET_LCD_WR; LCD_DATA_PORT-&gt;ODR = pixdata; RESET_LCD_WR; SET_LCD_WR; }</code> </pre><br>  It is clear that in the input mode and in alternative functions the possibility of use will be preserved, they are not dependent on the register ODR. <br>  This will give some more acceleration, up to 246 ms. <br><br><div class="spoiler">  <b class="spoiler_title">Waveform</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/54e/4fa/8e3/54e4fa8e3e1441e2826663170664be2e.png"><br></div></div><br>  Moving on. <br><br>  The next step is to move the main loop through the pixels in the function to a deeper level and try to make a software version of the DMA channel emulation, direct memory access.  To do this, we need to transfer the display control line WE to the group where the data bus is located, i.e.  GPIO B. Let it be PB9. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SSD1963_WriteDataPix_9</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pixdata, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> dp[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> i; SET_LCD_RDS; RESET_LCD_WR; dp[<span class="hljs-number"><span class="hljs-number">0</span></span>] = (pixdata &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x01ff</span></span>; dp[<span class="hljs-number"><span class="hljs-number">1</span></span>] = ((pixdata &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x01ff</span></span>) | <span class="hljs-number"><span class="hljs-number">0x0200</span></span>; dp[<span class="hljs-number"><span class="hljs-number">2</span></span>] = pixdata &amp; <span class="hljs-number"><span class="hljs-number">0x01ff</span></span>; dp[<span class="hljs-number"><span class="hljs-number">3</span></span>] = (pixdata &amp; <span class="hljs-number"><span class="hljs-number">0x01ff</span></span>) | <span class="hljs-number"><span class="hljs-number">0x0200</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;n;n--){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>;i++) { LCD_DATA_PORT-&gt;ODR = dp[i]; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SSD1963_ClearScreen_9</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> color)</span></span></span><span class="hljs-function"> </span></span>{ SSD1963_SetArea(<span class="hljs-number"><span class="hljs-number">0</span></span>, TFT_WIDTH<span class="hljs-number"><span class="hljs-number">-1</span></span> , <span class="hljs-number"><span class="hljs-number">0</span></span>, TFT_HEIGHT<span class="hljs-number"><span class="hljs-number">-1</span></span>); SSD1963_WriteCommand(<span class="hljs-number"><span class="hljs-number">0x002c</span></span>); SSD1963_WriteDataPix_9(color, TFT_HEIGHT*TFT_WIDTH); }</code> </pre><br>  As can be seen from the code, we sequentially write 4 data options to the port B group, where, in addition to the 9-bit data bus, the WE signal is also located.  The operation "| 0x0200" is just setting this signal.  This code gives a great boost up to 85 ms, and if you replace the definition of the array ‚Äústatic uint32_t dp [4]‚Äù by ‚Äústatic uint16_t dp [4]‚Äù, then up to 75 ms.  For verification, a variant with the inclusion of the DMA mode and the same transfer of the contents of 4 cells to the I / O port was measured.  The result is only 230 ms.  Why is DMA slower?  Everything is simple, in the program mode the compiler optimizes the code and all 4 values ‚Äã‚Äãare placed in the registers of the processor, and not in memory, and the selection from memory that is performed by the DMA controller is much slower than working with registers. <br>  The compiled main loop looks like this: <br><br> <code>08000265: ldr r3, [pc, #24] ; (0x8000280 &lt;SSD1963_WriteDataPix_9+84&gt;) <br> 08000267: str r6, [r3, #12] <br> 08000269: str r5, [r3, #12] <br> 0800026b: str r4, [r3, #12] <br> 0800026d: str r1, [r3, #12] <br> 0800026f: subs r2, #1 <br> 08000271: bne.n 0x8000266 &lt;SSD1963_WriteDataPix_9+58&gt; <br></code> <br>  In this variant, as well as in the variant with the DMA channel, the restriction on the use of ports PB10-PB15 remains.  However, they can display the signals of the display RST and D / C and take them into account in the cycle, then the restrictions will be less. <br><br>  Thus, we have reached the maximum speed of filling the entire screen or a rectangular area with one color.  It seems to be the limit, but you can enter another restriction and move a little further. <br><br>  The fact is that in some applications, the display does not need the entire set of colors (in RGB656 - 65536 colors).  For example, in the field of automated process control systems, where you want to display the state of the production facility, or some textual application, display of messages.  If this assumption is correct, and we do not need to display full-color photos and video materials, then we will try to continue the optimization. <br>  Consider a palette, where each color is equal to the first and second part of the data transmitted via the bus in the display.  Those.  Of the 18 bits of the RGB666 model, the first 9 bits are equal to the second 9. This gives us 2 ^ 9 = 512 colors.  It may not seem enough to anyone, but it may well be enough to build graphs or display alphanumeric information.  Let's call them conditionally "symmetrical colors." <br><br><div class="spoiler">  <b class="spoiler_title">Symmetric colors</b> <div class="spoiler_text">  Here they are displayed: <br><br><img src="https://habrastorage.org/files/2b4/a92/4f7/2b4a924f72a147559ddcccf82b026810.jpg"><br><br>  Here is a selection of them, 100 pieces, more clearly: <br><br><img src="https://habrastorage.org/files/bbc/2ba/0d1/bbc2ba0d1a5b4c98b6376e4cd1ed12c6.jpg"><br></div></div><br>  What gives us the use of only these colors?  Yes, the fact that to fill the area we do not need to change the state of the data bus in the process of filling.  It is enough to switch the state of the signal WE and count how many times we have done it.  Moreover, we can invert the WE for as long as necessary, the main thing is not less than what is needed to fill the area.  It is easy to calculate that once per pixel we need to transfer two data blocks on the bus, then 2 acknowledgments with the signal WE are required.  Accordingly, the full screen is necessary (screen_ width * screen_ length * 2) pulses, or 800 * 480 * 2 = 768000. <br><br>  How easy it is to generate pulses.  Of course!  You can use a timer.  TIM1 in this controller is faster than TIM2-TIM4 timers, because  located on the faster APB2 clocking bus.  Studies have shown that by turning on the timer in the PWM generator mode with a minimum divider, you can get a fill time of 32 ms!  It is clear that the WE signal should be removed from the timer output, for example PA8 (TIM1_CH1). <br><br>  Can I still increase the fill rate?  It turned out yes, just by sending a SYSCLK signal from the RCC_MCO output to the WE LCD input.  This is the maximum available frequency on the processor, 72 MHz.  The time to fill the display with a symmetrical color is 10.7 ms. <br>  The time is counted by the timer, after which the signal is removed by interruption, and the port switches to the output mode. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  void SSD1963_TimInit2(void){ TIM_TimeBaseInitTypeDef Timer; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE); TIM_TimeBaseStructInit(&amp;Timer); Timer.TIM_Prescaler = 72-1; Timer.TIM_Period = 10000; Timer.TIM_CounterMode = TIM_CounterMode_Down; TIM_TimeBaseInit(TIM4, &amp;Timer); TIM_ITConfig(TIM4, TIM_IT_Update, ENABLE); NVIC_EnableIRQ(TIM4_IRQn); } void SSD1963_WriteDataPix(uint32_t pixdata, uint32_t n){ GPIO_InitTypeDef GPIO_InitStr; SET_LCD_RDS; LCD_DATA_PORT-&gt;ODR = (LCD_DATA_PORT-&gt;ODR &amp; ~0x01ff) | (pixdata &amp; 0x01ff); GPIO_InitStr.GPIO_Pin = LCD_WR; GPIO_InitStr.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStr.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(LCD_WR_PORT, &amp;GPIO_InitStr); //    TIM_ITConfig(TIM4, TIM_IT_Update, DISABLE); //        if (n &gt; 32000 ){ TIM_PrescalerConfig(TIM4, 72 - 1, TIM_PSCReloadMode_Immediate); //  1  TIM4-&gt;CNT = (uint16_t) (n / 36); //       } else { TIM_PrescalerConfig(TIM4, 0, TIM_PSCReloadMode_Immediate); //  1/72  () TIM4-&gt;CNT = (uint16_t) (n * 2 - 1); //      } TIM_ClearITPendingBit(TIM4, TIM_IT_Update); //    TIM_ITConfig(TIM4, TIM_IT_Update, ENABLE); //   RCC_MCOConfig(RCC_MCO_SYSCLK); //MCO   TIM4-&gt;CR1 |= TIM_CR1_CEN; //  } void TIM4_IRQHandler() { GPIO_InitTypeDef GPIO_InitStr; if (TIM_GetITStatus(TIM4, TIM_IT_Update) != RESET) { TIM_ClearITPendingBit(TIM4, TIM_IT_Update); //    TIM_Cmd(TIM4, DISABLE); //   RCC_MCOConfig(RCC_MCO_NoClock); //  SYSCLK   MCO GPIO_InitStr.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStr.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStr.GPIO_Pin = LCD_WR; GPIO_Init(LCD_WR_PORT, &amp;GPIO_InitStr); //      } } void SSD1963_ClearScreen_9(uint32_t color) { SSD1963_SetArea(0, TFT_WIDTH-1 , 0, TFT_HEIGHT-1); SSD1963_WriteCommand(0x2c); SSD1963_WriteDataPix(color, TFT_HEIGHT*TFT_WIDTH); } int main(void){ tick_init(); //    lcd_port_init(); //   - SSD1963_Init(); //   SSD1963_TimInit2(); //   TIM4 SSD1963_ClearScreen_9(0x1ff); //     while(1) {} }</span></span></code> </pre><br></div></div><br>  The timer counts the time with an accuracy of 1/72 ¬µs for the number of points less than 32000 and with an accuracy of 1 ¬µs for more points.  This is due to the bit counter timer.  Given that it takes some time to process the interrupt when the timer is turned off, the signal at the MCO output is removed a little later than required, with a small margin.  It was established experimentally that it is about 10-11 clock speeds of the processor.  Thus, we can say that there is a threshold for using this technique, at which it remains faster, despite the overhead of initializing the timer and RCC_MCO and shutting down.  A square of 2x2 pixels is probably more profitable to programmatically fill the cycle. <br><br>  As an output, it can be said that by adding some restrictions, the screen filling time was reduced from 375 to 11 ms.  In addition, the filling is without the participation of the processor, which at this time can perform other tasks. <br><br>  I will be glad comments and additions. </div><p>Source: <a href="https://habr.com/ru/post/278967/">https://habr.com/ru/post/278967/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278957/index.html">ScribeJava - even your grandma can work with OAuth</a></li>
<li><a href="../278959/index.html">A fresh look at the Oracle VM VirtualBox code</a></li>
<li><a href="../278961/index.html">Reinforced.Typings - TypeScript Angular services directly from your MVC controllers</a></li>
<li><a href="../278963/index.html">"Festive Chef" at FBD, step by step</a></li>
<li><a href="../278965/index.html">Announcement of Java-conference for students in Moscow: JPoint 2016 Student Day</a></li>
<li><a href="../278969/index.html">What's new in Rails 5.0. You can plan a move</a></li>
<li><a href="../278971/index.html">All nil zero: almost all programming languages ‚Äã‚Äãdo it</a></li>
<li><a href="../278973/index.html">The program of the conference DUMP-2016: look who is speaking this year</a></li>
<li><a href="../278975/index.html">Mike Shapiro, DSSD / EMC: ‚ÄúWhen the puzzle was formed, we got a solution ten times ahead of competitors' products‚Äù</a></li>
<li><a href="../278977/index.html">1.1 SFML and Visual Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>