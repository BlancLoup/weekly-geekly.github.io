<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lagrange formalism in problems with dry friction</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 This article is a logical continuation of the topic begun in the previous publication . As promised in the comments, we consider the ap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lagrange formalism in problems with dry friction</h1><div class="post__text post__text-html js-mediator-article"><h1>  Introduction </h1><br>  This article is a logical continuation of the topic begun in the <a href="http://habrahabr.ru/post/244957/">previous publication</a> .  As promised in the comments, we consider the applicability of the method of redundant coordinates to the dynamic analysis of mechanical systems moving under the action of dry Coulomb friction forces.  As an illustrative example, solve the following problem <br><br><img src="https://habrastorage.org/files/16e/7ba/bef/16e7babef7304c0fa6a51f43b9cdfee5.png"><br><br><blockquote>  A thin homogeneous mass rod <i>m</i> = 2 kg, length <i>AB</i> = 2 <i>l</i> = 1 m at point <i>A is</i> pivotally attached to a weightless slider moving in horizontal rough guides.  At the initial moment of time, the rod is located vertically, then it is deflected from the vertical at a negligibly small angle and released without the initial velocity.  It is necessary to make up the equations of motion of a given mechanical system and find the law of its motion.  The friction coefficient between the slider and the guides is equal to <i>f</i> = 0.1. <br></blockquote>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Before proceeding to the solution of the problem by the method proposed by the author, we consider a slightly elementary theory concerning dry friction. <br><a name="habracut"></a><br><h1>  1. What could be "easier" friction? </h1><br>  There is no more terrible punishment for a mechanic than friction force.  Appearing in the problem, this force immediately makes it essentially nonlinear, because it behaves in a rather interesting way. <br><br>  Consider a fairly simple example.  Let a horizontal bar rest on a rough surface. <br><br><img src="https://habrastorage.org/files/4d7/df9/3a6/4d7df93a65b04d47a0b088456c8f4581.png"><br><br>  Let no force be applied to it at the beginning (except for gravity and normal reaction).  In this case, the friction force between the bar and the plane will be zero. <br><br>  Now apply a small horizontal force to the bar.  The bar will not budge, since in response to our impact from the surface, a friction force will act on it, which will satisfy the condition <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3D%5Cvec%7BF%7D_%7Bfr%7D%26space%3B%3D%26space%3B-%5Cvec%7BF%7D%26space%3B%5Cquad%26space%3B%5Cquad%26space%3B(1)"><img src="https://habrastorage.org/getpro/habr/post_images/b0f/1a1/673/b0f1a16732d3155eca466a8ae05a78ed.gif" title="\ vec {F} _ {fr} = - \ vec {F} \ quad \ quad (1)"></a> <br><br>  We will gradually increase the strength <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3D%5Cvec%7BF%7D"><img src="https://habrastorage.org/getpro/habr/post_images/ca4/699/b48/ca4699b4843034fd448205021f7efc17.gif" title="\ vec {F}"></a>  and, according to (1), the friction force will also grow, which in this case is called the <i>friction force of rest</i> .  This will continue until the friction force of rest reaches the value <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DF_%7Bfr%7D%5E%7B%5Cmax%7D%26space%3B%3D%26space%3BfN"><img src="https://habrastorage.org/getpro/habr/post_images/8ca/439/133/8ca43913374076a36b7db12834e481b3.gif" title="F_ {fr} ^ {\ max} = fN"></a> <br><br>  called the limit value of the friction force of rest.  Here <i>f</i> is the coefficient of dry friction between the bar and the plane;  <i>N</i> is a normal reaction from the plane.  After that, the friction force will cease to grow, and with a further increase in the horizontal force, the bar will begin to slip.  The frictional force will translate into a sliding friction force equal to <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3D%5Cvec%7BF%7D_%7Bfr%7D%26space%3B%3D%26space%3B-fN%26space%3B%5Ccfrac%7B%5Cvec%7Bv%7D%7D%7B%5Cleft%7C%26space%3B%5Cvec%7Bv%7D%5Cright%26space%3B%7C%7D%26space%3B%5Cquad%26space%3B%5Cquad%26space%3B(2)"><img src="https://habrastorage.org/getpro/habr/post_images/ca4/699/b48/ca4699b4843034fd448205021f7efc17.gif_{fr}&amp;space;=&amp;space;-fN&amp;space;\cfrac{\vec{v}}{\left|&amp;space;\vec{v}\right&amp;space;|}&amp;space;\quad&amp;space;\quad&amp;space;(2)" title="\ vec {F} _ {fr} = -fN \ cfrac {\ vec {v}} {\ left | \ vec {v} \ right |} \ quad \ quad (2)"></a> <br><br>  Where <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3D%5Cvec%7Bv%7D"><img src="https://habrastorage.org/getpro/habr/post_images/b18/609/e4f/b18609e4ffa0b99de107c8e22a9b26eb.gif" title="\ vec {v}"></a>  - the speed of the bar. <br><br>  The example is rather trivial, but it reveals the essence of the behavior of the dry friction force.  Thus, we obtain the following algorithm for calculating the friction force: <br><br>  If the point where the applied friction force is fixed: <br><ol><li>  Calculate the friction force of rest and normal reaction </li><li>  Check condition <br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DF_%7Bfr%7D%26space%3B%5Cle%26space%3BfN"><img src="https://habrastorage.org/getpro/habr/post_images/37a/310/2be/37a3102beb83a30125044038af39a842.gif" title="F_ {fr} \ le fN"></a> <br>  in violation of which we accept the friction force equal to the ultimate friction force of rest <br></li></ol><br>  If the point of application of the friction force moves: <br><ol><li>  Calculate the normal reaction </li><li>  Calculate the force of sliding friction, according to the expression (2) </li></ol><br><br><h1>  2. Simulation of motion systems with friction </h1><br>  Now we solve our problem.  The system we are considering has two degrees of freedom, but because of the need to determine the normal reaction, we expand the number of degrees of freedom to three and obtain the following calculation scheme <br><br><img src="https://habrastorage.org/files/1d4/bb4/35c/1d4bb435c890456280ddc1df62b7c3f5.png"><br><br>  Here we take the vector as generalized coordinates. <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3D%5Cvec%7Bq%7D%26space%3B%3D%26space%3B%5Cleft%5Bx(t),%26space%3By(t),%26space%3B%5Cvarphi(t)%26space%3B%5Cright%26space%3B%5D%5ET%26space%3B%5Cquad%26space%3B%5Cquad%26space%3B(3)"><img src="https://habrastorage.org/getpro/habr/post_images/15f/089/abf/15f089abf977cdc06e900ee132f2c5f2.gif" title="\ vec {q} = \ left [x (t), y (t), \ varphi (t) \ right] ^ T \ quad \ quad (3)"></a> <br><br>  where <i>x, y</i> are the coordinates of point <i>A</i> ; <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3D%5Cvarphi"><img src="https://habrastorage.org/getpro/habr/post_images/171/69a/674/17169a6741a1bb27b86a1280ebc0586a.gif" title="\ varphi"></a>  - the angle of the rod to the vertical.  Arming Maple'om <br><br><pre><code class="hljs pgsql">#   <span class="hljs-keyword"><span class="hljs-keyword">restart</span></span>; #    <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>(LinearAlgebra): #    <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> `/home/maisvendoo/<span class="hljs-keyword"><span class="hljs-keyword">work</span></span>/maplelibs/mechanics/lagrange.m`:</code> </pre> <br><br>  We determine the kinematics of the system <br><br><pre> <code class="hljs go">#    q := [x(t), y(t), phi(t)]: #   A xA := q[<span class="hljs-number"><span class="hljs-number">1</span></span>]: yA := q[<span class="hljs-number"><span class="hljs-number">2</span></span>]: #     xC := q[<span class="hljs-number"><span class="hljs-number">1</span></span>] - L*sin(q[<span class="hljs-number"><span class="hljs-number">3</span></span>]): yC := q[<span class="hljs-number"><span class="hljs-number">2</span></span>] + L*cos(q[<span class="hljs-number"><span class="hljs-number">3</span></span>]): # -  A  C rA := Vector([xA, yA]): rC := Vector([xC, yC]): #      VectorCalculus[BasisFormat](<span class="hljs-literal"><span class="hljs-literal">false</span></span>): vC := VectorCalculus[diff](rC, t):</code> </pre><br><br>  Calculate its kinetic energy <br><br><pre> <code class="hljs go">#       J := m*(<span class="hljs-number"><span class="hljs-number">2</span></span>*L)^<span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">12</span></span>: #    T := simplify(J*diff(q[<span class="hljs-number"><span class="hljs-number">3</span></span>], t)^<span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> + m*DotProduct(vC, vC, conjugate=<span class="hljs-literal"><span class="hljs-literal">false</span></span>)/<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  Maple produces this result. <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DT%26space%3B%3D%26space%3B1/6%5C,m%26space%3B%5Cleft(%26space%3B4%5C,%7BL%7D%5E%7B2%7D%26space%3B%5Cleft(%26space%3B%7B%5Cfrac%26space%3B%7Bd%7D%7Bdt%7D%7D%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5E%7B2%7D-6%5C,L%26space%3B%5Cleft(%26space%3B%7B%5Cfrac%26space%3B%7Bd%7D%7Bdt%7D%7D%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5Cleft(%26space%3B%7B%5Cfrac%26space%3B%7Bd%7D%7Bdt%7D%7Dx%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5Ccos%26space%3B%5Cleft(%26space%3B%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B-6%5C,L%26space%3B%5Cleft(%26space%3B%7B%5Cfrac%26space%3B%7Bd%7D%7Bdt%7D%7D%26space%3B%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5Cleft(%26space%3B%7B%5Cfrac%26space%3B%7Bd%7D%7Bdt%7D%7Dy%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5Csin%26space%3B%5Cleft(%26space%3B%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%26plus%3B3%5C,%26space%3B%5Cleft(%26space%3B%7B%5Cfrac%26space%3B%7Bd%7D%7Bdt%7D%7Dx%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5E%7B2%7D%26plus%3B3%5C,%26space%3B%5Cleft(%26space%3B%7B%26space%3B%5Cfrac%26space%3B%7Bd%7D%7Bdt%7D%7Dy%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5E%7B2%7D%26space%3B%5Cright)"><img src="https://habrastorage.org/getpro/habr/post_images/7cd/e55/59b/7cde5559b07ce1228cd15464c517d473.gif" title="T = 1/6 \, m \ left (4 \, {L} ^ {2} \ left ({\ frac {d} {dt}} \ phi \ left (t \ right) \ right) ^ {2} -6 \, L \ left ({\ frac {d} {dt}} \ phi \ left (t \ right) \ right) \ left ({\ frac {d} {dt}} x \ left (t \ right ) \ right) \ cos \ left (\ phi \ left (t \ right) \ right) -6 \, L \ left ({\ frac {d} {dt}} \ phi \ left (t \ right) \ right ) \ left ({\ frac {d} {dt}} y \ left (t \ right) \ right) \ sin \ left (\ phi \ left (t \ right) \ right) +3 \, \ left ({ \ frac {d} {dt}} x \ left (t \ right) \ right) ^ {2} +3 \, \ left ({\ frac {d} {dt}} y \ left (t \ right) \ right) ^ {2} \ right)"></a> <br><br>  It is rather cumbersome, but we don‚Äôt ‚Äúpick‚Äù with our hands on a piece of paper, so we move on.  We set vectors and points of application of forces <br><br><pre> <code class="hljs go">#  ,    Mg := Vector([<span class="hljs-number"><span class="hljs-number">0</span></span>, -m*g]): #   F_A := Vector([-F, <span class="hljs-number"><span class="hljs-number">0</span></span>]): #   N_A := Vector([<span class="hljs-number"><span class="hljs-number">0</span></span>, N]): #   #    Fk := [Mg, F_A, N_A]: #      rk := [rC, rA, rA]:</code> </pre><br><br>  We obtain the equations of motion of the system in the form of Lagrange 2 kind <br><pre> <code class="hljs vala"><span class="hljs-meta"><span class="hljs-meta">#    2  EQs := LagrangeEQs(T, q, rk, Fk):</span></span></code> </pre><br>  We get three "crocodiles" <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3D%5Cfrac%7B4%7D%7B3%7DmL%5E2%5Cddot%7B%5Cvarphi%7D-mL%5Cddot%7By%7D%5Csin%26space%3B%5Cvarphi-mL%5Cddot%7Bx%7D%5Ccos%5Cvarphi%26space%3B%3D%26space%3BmgL%5Csin%5Cvarphi%26space%3B%5Cquad%26space%3B%5Cquad%26space%3B(4)"><img src="https://habrastorage.org/getpro/habr/post_images/3ec/33c/65b/3ec33c65b090603bda6e39898a03f5a9.gif" title="\ frac {4} {3} mL ^ 2 \ ddot {\ varphi} -mL \ ddot {y} \ sin \ varphi-mL \ ddot {x} \ cos \ varphi = mgL \ sin \ varphi \ quad \ quad ( four)"></a> <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Dm%5Cddot%7By%7D-mL%5Cdot%7B%5Cvarphi%7D%5E2%5Ccos%5Cvarphi%26space%3B-%26space%3BmL%5Cddot%7B%5Cvarphi%7D%5Csin%5Cvarphi%26space%3B%3D%26space%3BN%26space%3B-%26space%3Bmg%26space%3B%5Cquad%26space%3B%5Cquad%26space%3B(5)"><img src="https://habrastorage.org/getpro/habr/post_images/217/eb5/1a1/217eb51a17899aee37660b5aa81250f0.gif" title="m \ ddot {y} -mL \ dot {\ varphi} ^ 2 \ cos \ varphi - mL \ ddot {\ varphi} \ sin \ varphi = N - mg \ quad \ quad (5)"></a> <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Dm%5Cddot%7Bx%7D%26space%3B%26plus%3B%26space%3BmL%5Cdot%7B%5Cvarphi%7D%5E2%5Csin%5Cvarphi-mL%5Cddot%7B%5Cvarphi%7D%5Ccos%5Cvarphi%26space%3B%3D%26space%3B-F%26space%3B%5Cquad%26space%3B%5Cquad%26space%3B(6)"><img src="https://habrastorage.org/getpro/habr/post_images/e4c/e92/bb4/e4ce92bb477e8cc588e38d104a5417b2.gif" title="m \ ddot {x} + mL \ dot {\ varphi} ^ 2 \ sin \ varphi-mL \ ddot {\ varphi} \ cos \ varphi = -F \ quad \ quad (6)"></a> <br><br>  These equations had to be hammered into the article with my hands, because Maple's ‚Äúcopy-paste‚Äù of LaTeX output leads to an unattractive result.  But even this can be seen - the equations are complex and given the fact that <i>F</i> is the friction force, they are not analytically integrable. <br><br>  Now we introduce the equation of relations.  First, the slider moves along horizontal guides, therefore <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Dy(t)%26space%3B%3D%26space%3B0%26space%3B%5Cquad%26space%3B%5Cquad%26space%3B(7)"><img src="https://habrastorage.org/getpro/habr/post_images/c40/3d8/dbb/c403d8dbb689e8830600d828d2849ab0.gif" title="y (t) = 0 \ quad \ quad (7)"></a> <br><br>  In addition, in the case when the slider is stationary and the friction force at rest does not exceed the limit value, one more connection is activated <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Dx(t)%26space%3B%3D%26space%3BA%26space%3B%5Cquad%26space%3B%5Cquad%26space%3B(8)"><img src="https://habrastorage.org/getpro/habr/post_images/969/2f3/f9c/9692f3f9cbe40483d1f0dc7f089de767.gif" title="x (t) = A \ quad \ quad (8)"></a> <br><br>  Where <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DA%26space%3B%3D%26space%3B%5Ctext%7Bconst%7D"><img src="https://habrastorage.org/getpro/habr/post_images/b94/c0f/f35/b94c0ff351324ccfb9ef0ed4ca4f583e.gif" title="A = \ text {const}"></a>  - some horizontal coordinate of the slider.  Now we transform the system (4) - (6) taking into account equations (7) and (8) and find the friction force of rest and the normal reaction <br><br><pre> <code class="hljs vbscript">#   link_eq1 := q[<span class="hljs-number"><span class="hljs-number">1</span></span>] = A: #  ,    -    link_eq2 := q[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>: #     X Link_EQs := {link_eq1, link_eq2}: #           Reduced_EQs := ReduceSystem(EQs, Link_EQs, q): solv_reduced := SolveAccelsReacts(Reduced_EQs, [q[<span class="hljs-number"><span class="hljs-number">3</span></span>]], [F, N]): #     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i from <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> numelems(solv_reduced) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> has(solv_reduced[i], F) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> F1 := rhs(solv_reduced[i]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> has(solv_reduced[i], N) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> N1 := rhs(solv_reduced[i]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>:</code> </pre><br><br>  Here I will give the result directly issued Maple <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DF_1%26space%3B%3D%26space%3B-mL%5Csin%26space%3B%5Cleft(%26space%3B%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5Cleft(%26space%3B%7B%5Cfrac%26space%3B%7Bd%7D%7Bdt%7D%7D%26space%3B%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5E%7B2%7D%26plus%3B3/4%5C,%5Ccos%26space%3B%5Cleft(%26space%3B%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3Bmg%5Csin%26space%3B%5Cleft(%26space%3B%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5Cquad%26space%3B%5Cquad%26space%3B(9)"><img src="https://habrastorage.org/getpro/habr/post_images/490/0ea/17d/4900ea17dab3dfe39740e061d90e8428.gif" title="F_1 = -mL \ sin \ left (\ phi \ left (t \ right) \ right) \ left ({\ frac {d} {dt}} \ phi \ left (t \ right) \ right) ^ {2} +3/4 \, \ cos \ left (\ phi \ left (t \ right) \ right) mg \ sin \ left (\ phi \ left (t \ right) \ right) \ quad \ quad (9)"></a> <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DN_1%26space%3B%3D%26space%3B-mL%5Ccos%26space%3B%5Cleft(%26space%3B%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5Cleft(%26space%3B%7B%5Cfrac%26space%3B%7Bd%7D%7Bdt%7D%7D%26space%3B%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5E%7B2%7D-3/4%5C,%26space%3B%5Cleft(%26space%3B%5Csin%26space%3B%5Cleft(%26space%3B%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5E%7B2%7Dmg%26plus%3Bmg%26space%3B%5Cquad%26space%3B%5Cquad%26space%3B(10)"><img src="https://habrastorage.org/getpro/habr/post_images/05f/7de/787/05f7de787045ecb94cfba4322795949a.gif" title="N_1 = -mL \ cos \ left (\ phi \ left (t \ right) \ right) \ left ({\ frac {d} {dt}} \ phi \ left (t \ right) \ right) ^ {2} -3/4 \, \ left (\ sin \ left (\ phi \ left (t \ right) \ right) \ right) ^ {2} mg + mg \ quad \ quad (10)"></a> <br><br>  If you look at the resulting expressions, they are quite consistent with the logic of the process.  Now we obtain an expression for calculating the normal reaction in the case when the slider slides along the guides, taking into account that in this case the friction force will be determined by the expression <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DF%26space%3B%3D%26space%3BfN%5Ctext%7Bsign%7D%26space%3B%5Cleft(%5Cdot%7Bx%7D%26space%3B%5Cright%26space%3B)"><img src="https://habrastorage.org/getpro/habr/post_images/d8b/b13/ddb/d8bb13ddb10aa6f7c221e1e5171e7752.gif" title="F = fN \ text {sign} \ left (\ dot {x} \ right)"></a> <br><br>  (minus is already in the equations of motion) <br><pre> <code class="hljs vbscript">#          Slade_EQs := ReduceSystem(EQs, {link_eq2}, q): #        <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i from <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> numelems(Slade_EQs) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Slade_EQs[i] := subs(F = f*N*signum(diff(q[<span class="hljs-number"><span class="hljs-number">1</span></span>], t)), Slade_EQs[i]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: solv_slade := SolveAccelsReacts(Slade_EQs, [q[<span class="hljs-number"><span class="hljs-number">1</span></span>], q[<span class="hljs-number"><span class="hljs-number">3</span></span>]], [N]): #      <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i from <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> numelems(solv_reduced) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> has(solv_slade[i], N) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> N2 := rhs(solv_slade[i]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>:</code> </pre><br><br>  Hmmm, the crocodile is still out, especially since Maple does generate enough LaTeX code <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DN_2%26space%3B%3D%26space%3B-%7B%5Cfrac%26space%3B%7Bm%26space%3B%5Cleft(%26space%3B3%5C,L%26space%3B%5Cleft(%26space%3B%7B%5Cfrac%26space%3B%7Bd%7D%7Bdt%7D%7D%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5E%7B2%7D%26space%3B%5Cleft(%26space%3B%5Ccos%26space%3B%5Cleft(%26space%3B%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5E%7B3%7D%26plus%3B3%5C,L%26space%3B%5Cleft(%26space%3B%7B%5Cfrac%26space%3B%7Bd%7D%7Bdt%7D%7D%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5E%7B2%7D%5Ccos%26space%3B%5Cleft(%26space%3B%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5Cleft(%26space%3B%5Csin%26space%3B%5Cleft(%26space%3B%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5E%7B2%7D-4%5C,L%5Ccos%26space%3B%5Cleft(%26space%3B%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5Cleft(%26space%3B%7B%5Cfrac%26space%3B%7Bd%7D%7Bdt%7D%7D%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5E%7B2%7D-3%5C,%26space%3B%5Cleft(%26space%3B%5Ccos%26space%3B%5Cleft(%26space%3B%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5E%7B2%7Dg-3%5C,%26space%3B%5Cleft(%26space%3B%5Csin%26space%3B%5Cleft(%26space%3B%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5E%7B2%7Dg%26plus%3B4%5C,g%26space%3B%5Cright)%26space%3B%7D%7B3%5C,f%5Csin%26space%3B%5Cleft(%26space%3B%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5Ccos%26space%3B%5Cleft(%26space%3B%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%7B%5Cit%26space%3B%5Ctext%7Bsign%7D%7D%26space%3B%5Cleft(%26space%3B%7B%5Cfrac%26space%3B%7Bd%7D%7Bdt%7D%7Dx%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%26plus%3B3%5C,%26space%3B%5Cleft(%26space%3B%5Ccos%26space%3B%5Cleft(%26space%3B%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5E%7B2%7D-4%7D%7D%26space%3B%5Cquad%26space%3B%5Cquad%26space%3B(11)"><img src="https://habrastorage.org/getpro/habr/post_images/418/acc/72a/418acc72af7773b47939534dc06aa323.gif" title="N_2 = - {\ frac {m \ left (3 \, L \ left ({\ frac {d} {dt}} \ phi \ left (t \ right) \ right) ^ {2} \ left (cos \ left (\ phi \ left (t \ right) \ right) \ right) ^ {3} +3 \, L \ left ({\ frac {d} {dt}} \ phi \ left (t \ right) \ right ) ^ {2} \ cos \ left (\ phi \ left (t \ right) \ right) \ left (\ sin \ left (\ phi \ left (t \ right) \ right) \ right) ^ {2} - 4 \, L \ cos \ left (\ phi \ left (t \ right) \ right) \ left ({\ frac {d} {dt}} \ phi \ left (t \ right) \ right) ^ {2} -3 \, \ left (\ cos \ left (\ phi \ left (t \ right) \ right) \ right) ^ {2} g-3 \, \ left (\ sin \ left (\ phi \ left (t \ right) \ right) \ right) ^ {2} g + 4 \, g \ right)} {3 \, f \ sin \ left (\ phi \ left (t \ right) \ right) \ cos \ left ( \ phi \ left (t \ right) \ right) {\ it \ text {sign}} \ left ({\ frac {d} {dt}} x \ left (t \ right) \ right) +3 \, \ left (\ cos \ left (\ phi \ left (t \ right) \ right) \ right) ^ {2} -4}} \ quad \ quad (11)"></a> <br><br>  All the expressions we need are obtained, now we can proceed to modeling.  In contrast to the problem with a pendulum, about which I have already written, here we honestly transform our equations with Maple-means for a form suitable for a numerical solution.  First of all, we solve equations (4) - (6) with respect to generalized accelerations <br><pre> <code class="hljs go">#        Main_EQs := SolveAccelsReacts(EQs, q, []): #    s := numelems(q):</code> </pre><br>  I will not give the result anymore - it is also quite cumbersome.  Go to the phase coordinates <br><pre> <code class="hljs vbscript">#    # Y[<span class="hljs-number"><span class="hljs-number">1</span></span>] -&gt; x(t) # Y[<span class="hljs-number"><span class="hljs-number">2</span></span>] -&gt; y(t) # Y[<span class="hljs-number"><span class="hljs-number">3</span></span>] -&gt; phi(t) # Y[<span class="hljs-number"><span class="hljs-number">4</span></span>] -&gt; vx(t) -     # Y[<span class="hljs-number"><span class="hljs-number">5</span></span>] -&gt; vy(t) -     # Y[<span class="hljs-number"><span class="hljs-number">6</span></span>] -&gt; omega(t) -    #            <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i from <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> N2 := subs(diff(q[i], t) = y[i+s], N2); N2 := subs(q[i] = y[i], N2); N1 := subs(diff(q[i], t) = y[i+s], N1); N1 := subs(q[i] = y[i], N1); F1 := subs(diff(q[i], t) = y[i+s], F1); F1 := subs(q[i] = y[i], F1); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: #        <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i from <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j from <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> eq := Main_EQs[j]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> has(eq, diff(diff(q[i], t), t)) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> accel[i] := rhs(eq); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j from <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> accel[i] := subs(diff(q[j], t) = y[j+s], accel[i]); accel[i] := subs(q[j] = y[j], accel[i]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>:</code> </pre><br><br>  We form the functions of calculating the forces we need <br><pre> <code class="hljs lua">#       GetN1 := proc(mass, length, grav_accel, fric_coeff, Y) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> react := subs(m = mass, L = length, g = grav_accel, f = fric_coeff, N1); <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i from <span class="hljs-number"><span class="hljs-number">1</span></span> to numelems(Y) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> react := subs(y[i] = Y[i], react); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evalf(react); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> proc: #       GetN2 := proc(mass, length, grav_accel, fric_coeff, Y) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> react := subs(m = mass, L = length, g = grav_accel, f = fric_coeff, N2); <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i from <span class="hljs-number"><span class="hljs-number">1</span></span> to numelems(Y) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> react := subs(y[i] = Y[i], react); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evalf(react); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> proc: #     GetF1 := proc(mass, length, grav_accel, fric_coeff, Y) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> react := subs(m = mass, L = length, g = grav_accel, f = fric_coeff, F1); <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i from <span class="hljs-number"><span class="hljs-number">1</span></span> to numelems(Y) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> react := subs(y[i] = Y[i], react); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evalf(react); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> proc:</code> </pre><br>  The code given, albeit voluminous, is quite simple - the substitution of numerical parameters into the corresponding expressions and their calculation is performed.  We form the same function to calculate generalized accelerations. <br><pre> <code class="hljs delphi">#     GetAccel := proc(mass, length, grav_accel, fric_force, normal_react, Y) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> acc; <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> i, j; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i from <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> numelems(Y)/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> acc[i] := subs(m = mass, L = length, g = grav_accel, F = fric_force, N = normal_react, accel[i]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i from <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> numelems(Y)/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j from <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> numelems(Y) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> acc[i] := evalf(subs(y[j] = Y[j], acc[i])); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: return [seq(acc[i], i=<span class="hljs-number"><span class="hljs-number">1</span></span>..numelems(Y)/<span class="hljs-number"><span class="hljs-number">2</span></span>)]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> proc:</code> </pre><br><br>  We set the parameters given to us in the statement of the problem <br><pre> <code class="hljs go">#    m1 := <span class="hljs-number"><span class="hljs-number">2.0</span></span>; L1 := <span class="hljs-number"><span class="hljs-number">0.5</span></span>; f1 := <span class="hljs-number"><span class="hljs-number">0.1</span></span>; g1 := <span class="hljs-number"><span class="hljs-number">9.81</span></span>;</code> </pre><br><br>  Time to set the basic logic of the model, which determines the calculation of the friction force.  In this case, we set the error of the speed of the slider, at which we will consider it equal to zero. <br><br><pre> <code class="hljs lua">#       GetFricNormal := proc(mass, length, grav_accel, fric_coeff, Y) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> F1, N1; #      <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> eps_v := <span class="hljs-number"><span class="hljs-number">1e-6</span></span>; #     #    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(Y[<span class="hljs-number"><span class="hljs-number">4</span></span>]) &lt; eps_v <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> #        F1 := GetF1(mass, length, grav_accel, fric_coeff, Y); N1 := GetN1(mass, length, grav_accel, fric_coeff, Y); #       , #        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(F1) &gt; fric_coeff*<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(N1) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> F1 := fric_coeff*<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(N1)*signum(F1); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> #    ,       N1 := GetN2(mass, length, grav_accel, fric_coeff, Y); F1 := fric_coeff*<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(N1)*signum(Y[<span class="hljs-number"><span class="hljs-number">4</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [F1, N1]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> proc:</code> </pre><br><br>  Define a callback for the solver: <br><br><pre> <code class="hljs go">#           (  ) EQs_func := proc(N, t, Y, dYdt) local F1, N1; #      local acc; #   local ret; #       ret := GetFricNormal(m1, L1, g1, f1, Y); F1 := ret[<span class="hljs-number"><span class="hljs-number">1</span></span>]; N1 := ret[<span class="hljs-number"><span class="hljs-number">2</span></span>]; #     acc := GetAccel(m1, L1, g1, F1, N1, Y); dYdt[<span class="hljs-number"><span class="hljs-number">1</span></span>] := Y[<span class="hljs-number"><span class="hljs-number">4</span></span>]; dYdt[<span class="hljs-number"><span class="hljs-number">2</span></span>] := Y[<span class="hljs-number"><span class="hljs-number">5</span></span>]; dYdt[<span class="hljs-number"><span class="hljs-number">3</span></span>] := Y[<span class="hljs-number"><span class="hljs-number">6</span></span>]; dYdt[<span class="hljs-number"><span class="hljs-number">4</span></span>] := acc[<span class="hljs-number"><span class="hljs-number">1</span></span>]; dYdt[<span class="hljs-number"><span class="hljs-number">5</span></span>] := acc[<span class="hljs-number"><span class="hljs-number">2</span></span>]; dYdt[<span class="hljs-number"><span class="hljs-number">6</span></span>] := acc[<span class="hljs-number"><span class="hljs-number">3</span></span>]; end proc:</code> </pre><br>  We form the list of phase coordinates for the solver and the initial conditions (the bar deflection angle from the vertical is made small) and perform numerical integration (in fact, the last dsolve () call only indicates our intentions by a numerical solution - it will be produced when calculating specific values ‚Äã‚Äãof phase coordinates). <br><br><pre> <code class="hljs delphi">#    vars := [X(t), Y(t), Phi(t), Vx(t), Vy(t), Omega(t)]; #   initc := <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>([<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>e-<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>]); #   dsolv := dsolve(numeric, number = <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EQs_func</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-function"> = 0, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initial</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initc</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">procvars</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vars</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">output</span></span></span><span class="hljs-function">=</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listprocedure</span></span></span><span class="hljs-function">);</span></span></code> </pre><br>  Perform some preparatory operations <br><pre> <code class="hljs vbscript">#      x := <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(X(t), dsolv); y := <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(Y(t), dsolv); phi := <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(Phi(t), dsolv); vx := <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(Vx(t), dsolv); vy := <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(Vy(t), dsolv); omega := <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(Omega(t), dsolv);</code> </pre><br>  Next, we calculate the motion of the system for a certain time interval and form arrays of data for output to the graphs <br><pre> <code class="hljs go">#         t0 := <span class="hljs-number"><span class="hljs-number">0.0</span></span>: t1 := <span class="hljs-number"><span class="hljs-number">10.0</span></span>: num_plots := <span class="hljs-number"><span class="hljs-number">1000</span></span>: dt := (t1 - t0)/num_plots: t := t0: i := <span class="hljs-number"><span class="hljs-number">1</span></span>: while t &lt;= t1 do Time[i] := t; Y := [x(t), y(t), phi(t), vx(t), vy(t), omega(t)]; x1[i] := Y[<span class="hljs-number"><span class="hljs-number">1</span></span>]; phi1[i] := Y[<span class="hljs-number"><span class="hljs-number">3</span></span>]; fric[i] := GetFricNormal(m1, L1, g1, f1, Y)[<span class="hljs-number"><span class="hljs-number">1</span></span>]; norm_react[i] := GetFricNormal(m1, L1, g1, f1, Y)[<span class="hljs-number"><span class="hljs-number">2</span></span>]; lim_fric[i] := f1*abs(norm_react[i])*fric[i]/abs(fric[i]); t := t + dt; i := i + <span class="hljs-number"><span class="hljs-number">1</span></span>; end do:</code> </pre><br>  Well, we have almost everything ready <br><pre> <code class="hljs go">#   G_x := [ [Time[k],x1[k]] $k=<span class="hljs-number"><span class="hljs-number">1.</span></span>.num_plots]: G_phi := [ [Time[k],phi1[k]] $k=<span class="hljs-number"><span class="hljs-number">1.</span></span>.num_plots]: G_fric := [ [Time[k],fric[k]] $k=<span class="hljs-number"><span class="hljs-number">1.</span></span>.num_plots]: G_norm_react := [ [Time[k],norm_react[k]] $k=<span class="hljs-number"><span class="hljs-number">1.</span></span>.num_plots]: G_lim_fric := [ [Time[k],lim_fric[k]] $k=<span class="hljs-number"><span class="hljs-number">1.</span></span>.num_plots]: #     gr_opts := captionfont=[<span class="hljs-string"><span class="hljs-string">'ROMAN'</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>], axesfont=[<span class="hljs-string"><span class="hljs-string">'ROMAN'</span></span>,<span class="hljs-string"><span class="hljs-string">'ROMAN'</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>],titlefont=[<span class="hljs-string"><span class="hljs-string">'ROMAN'</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>],gridlines=<span class="hljs-literal"><span class="hljs-literal">true</span></span>: plot(G_x, gr_opts, view=[t0..t1, <span class="hljs-number"><span class="hljs-number">-1.</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>]); plot(G_phi, gr_opts, view=[t0..t1, <span class="hljs-number"><span class="hljs-number">0.0</span></span>.<span class="hljs-number"><span class="hljs-number">.7</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>]); plot({G_fric, G_lim_fric}, gr_opts, view=[t0..t1, <span class="hljs-number"><span class="hljs-number">-20.</span></span><span class="hljs-number"><span class="hljs-number">.20</span></span>]); plot(G_norm_react, gr_opts, view=[t0..t1, <span class="hljs-number"><span class="hljs-number">0.0</span></span>.<span class="hljs-number"><span class="hljs-number">.200</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>]);</code> </pre><br><br>  We get graphics.  Beauty for the sake of graphics were converted from Maple to * .eps and slightly processed in inkscape. <br><br>  <b>Move the slider</b> <br> <a href="http://itmages.ru/image/view/2100442/7fc45083"><img src="http://storage9.static.itmages.ru/i/14/1207/s_1417992330_9068980_7fc45083d6.png"></a> <br><br>  <b>Rod deflection angle from vertical</b> <br> <a href="http://itmages.ru/image/view/2100441/78bfd76a"><img src="http://storage9.static.itmages.ru/i/14/1207/s_1417992330_4663147_78bfd76a14.png"></a> <br><br>  <b>Friction force</b> <br> <a href="http://itmages.ru/image/view/2100443/d8f0f6ce"><img src="http://storage9.static.itmages.ru/i/14/1207/s_1417992331_5793347_d8f0f6ce9e.png"></a> <br>  Here the blue line shows the limit value of static friction, and the red line shows the actual value of the friction force. <br><br>  <b>Normal reaction from guides</b> <br> <a href="http://itmages.ru/image/view/2100444/ab399e29"><img src="http://storage5.static.itmages.ru/i/14/1207/s_1417992331_1500564_ab399e29a4.png"></a> <br><br>  It can be seen that the slider rests for a little more than two seconds, and then, after overcoming the friction of rest, it begins to move, which gradually fades out and completely stops 6.5 seconds after the start of movement.  After that, the friction force never exceeds the limit value for rest, the slider remains in place, and the rod performs harmonic oscillations around a stable equilibrium position. <br><br><h1>  Conclusion </h1><br>  The application of the method of redundant coordinates and Lagrange equations of the second kind to the analysis of the motion of systems with dry friction is considered.  It can be seen that with the external bulkiness of the results obtained, the process of synthesis of the equations of motion can be automated by means of symbolic mathematics, and this is essential for modern technical tasks. <br><br>  Thank you for your attention to my work. </div><p>Source: <a href="https://habr.com/ru/post/245211/">https://habr.com/ru/post/245211/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../245199/index.html">Load: system, export problems down, crisis and behavior strategy</a></li>
<li><a href="../245201/index.html">Parallel data loading with time constraints</a></li>
<li><a href="../245203/index.html">Conference ZeroNights 2014 - how everything was</a></li>
<li><a href="../245205/index.html">Do away with chaos: implement business processes in CRM</a></li>
<li><a href="../245209/index.html">The digest of interesting materials from the world of Drupal # 1</a></li>
<li><a href="../245213/index.html">Some interesting and useful things for web developer # 34</a></li>
<li><a href="../245215/index.html">Highload ++ 2014 through the eyes of a speaker who really loves Processing Large-Scale Graph Data in various bad ways</a></li>
<li><a href="../245221/index.html">Quickhull algorithm for finding a convex hull</a></li>
<li><a href="../245223/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ137 (December 1 - 7, 2014)</a></li>
<li><a href="../245225/index.html">Blender Development Plans</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>