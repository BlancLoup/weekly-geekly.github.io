<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to make your blockchain. Part 1 - Build, Store, Sync, Display, Mining, and Proof</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good all! We slowly began to explore a new direction for us to learn - blockchains and found something that turned out to be interesting as part of ou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to make your blockchain. Part 1 - Build, Store, Sync, Display, Mining, and Proof</h1><div class="post__text post__text-html js-mediator-article">  Good all!  We slowly began to explore a new direction for us to learn - blockchains and found something that turned out to be interesting as part of our <a href="https://otus.pw/Fdw4/">Python</a> course, including.  What, in fact, want to share with you. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/g4/ay/jr/g4ayjrgmkp9dyb6r-epiyi10igw.jpeg"></div><a name="habracut"></a><br>  I can find out when I got my first Bitcoin, from the history of the wallet in my Coinbase account - an incoming transaction in 2012 as a gift for registration.  Bitcoin at that time cost about $ 6.50.  If I had saved those 0.1 BTC, at the time of writing this article it would have cost more than $ 500.  If anyone is interested, I sold them when Bitcoin cost $ 2000.  So I only got $ 200 instead of the current $ 550.  Not worth the rush. <br><br>  I knew about the existence of Bitcoin, but I was not particularly interested.  I have seen the ups and downs of the $ / BTC rate.  I saw people say that the future was with him, and I saw articles about his complete meaninglessness.  But I had no personal opinion - I just watched from the side. <br>  In the same way, I almost did not follow the blockchains.  But lately, my father mentioned several times that on CNBC and Bloomberg, which he watches in the morning, they often talk about blockchains, and he has no idea what it is. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And then I suddenly realized that I needed to sort out this topic a little deeper.  And he began with a "study" - read a huge number of articles on the Internet, explaining their essence.  Some were good, some were bad, some were deep, and some were very superficial. <br><br>  Reading was not enough, and if there is one thing that I know for sure, it is that reading does not explain even a hundredth of what programming explains.  And so I realized that it was worth writing your own local blockchain. <br><br>  It should be borne in mind that there is a big difference between the basic blockchain, which I describe and the ‚Äúprofessional‚Äù blockchain.  This chain will not create a cryptocurrency.  Blockchains do not require the production of coins that can be sold and exchanged for physical money. <br>  Blockchains are used to store and confirm information.  Coins encourage sites to participate in validation, but their presence is not required. <br><br>  I write a post for several reasons: 1) So that people who have read it can learn more about blockchains;  2) So that I can understand more by explaining the code, rather than simply writing it. <br>  In this post, I will show you how to store the blockchain data and generate the initial block, synchronize the node with the local blockchain data, display the blockchain (which will later be used to synchronize with other nodes), and then mine and create valid new blocks.  In the first post there will be no other nodes.  No wallets, peers, important data.  We will talk about them later. <br><br>  <b>In a nutshell</b> <br><br>  If you do not want to go into details and read the code, or if you stumbled upon this post, counting on an article that would explain the blockchains in an understandable language, I will try to briefly summarize how they work. <br><br>  At the highest level, the blockchain is a database where everyone who participates in the blockchain can store, view, confirm and never delete data. <br><br>  At a lower level, the data in these blocks can be anything as long as a particular blockchain allows.  For example, the data in the Bitcoin blockchain is exclusively Bitcoin transactions between accounts.  The Ethereum blockchain allows both similar Ether transactions and transactions used to run code. <br><br>  Before a block is created and merged into a blockchain, it is confirmed by the majority of people working on the blockchain ‚Äî they are called nodes.  A real blockchain is a chain consisting of a huge number of blocks, confirmed by the majority of nodes.  Thus, if the node tries to change the data of the previous block, the new blocks will not be valid, and the nodes will not trust the data from the incorrect block. <br><br>  Don't worry if this is confusing.  It took me a while to get into it myself, and even more time to write such a post, so that even my sister (who knows nothing about the blockchains) could understand. <br><br>  If you want to study the code, look at the <a href="https://github.com/jackschultz/jbc/tree/part-1">part 1</a> branch on Github.  Feel free to send me any questions, comments, edits and praises (if you are in the mood to do something particularly good), or just tweet. <br><br>  <b>Step 1 - Classes and Files</b> <br><br>  The first step is to write a class that handles blocks when starting nodes.  I will call this class Block.  Honestly, there is not much to do.  In the function __init__, we will believe that all the necessary information is already presented in the dictionary.  For a production blockchain, this is not the wisest decision, but it is suitable as an example, because only I am writing code.  I will also write a method that packs important block information into a dictionary, and then I‚Äôm getting a more convenient way to display block information when it is printed to a terminal. <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Block</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, dictionary)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">''' We're looking for index, timestamp, data, prev_hash, nonce '''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> dictionary.items(): setattr(self, k, v) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> hasattr(self, <span class="hljs-string"><span class="hljs-string">'hash'</span></span>): <span class="hljs-comment"><span class="hljs-comment">#in creating the first block, needs to be removed in future self.hash = self.create_self_hash() def __dict__(self): info = {} info['index'] = str(self.index) info['timestamp'] = str(self.timestamp) info['prev_hash'] = str(self.prev_hash) info['hash'] = str(self.hash) info['data'] = str(self.data) return info def __str__(self): return "Block&lt;prev_hash: %s,hash: %s&gt;" % (self.prev_hash, self.hash)</span></span></code> </pre> <br>  To create the first block, run this simple code: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_first_block</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># index zero and arbitrary previous hash block_data = {} block_data['index'] = 0 block_data['timestamp'] = date.datetime.now() block_data['data'] = 'First block data' block_data['prev_hash'] = None block = Block(block_data) return block</span></span></code> </pre><br>  Fine.  The last question in this part is where to store data in the file system.  This is necessary if we do not want to lose the local block data when the node is disconnected. <br>  I will name the 'chaindata' folder, to some extent imitating the Etherium Mist folder scheme.  Each block is now assigned a separate file, named for its index.  You need to make sure that the file names contain a sufficient number of zeros at the beginning, so that the blocks are listed in order. <br><br>  Given the code above, you need to write the following to create the first block: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#check if chaindata folder exists. chaindata_dir = 'chaindata' if not os.path.exists(chaindata_dir): #make chaindata dir os.mkdir(chaindata_dir) #check if dir is empty from just creation, or empty before if os.listdir(chaindata_dir) == []: #create first block first_block = create_first_block() first_block.self_save()</span></span></code> </pre><br>  <b>Step 2 - Synchronize the blockchain locally</b> <br><br>  Before you start mining, interpreting data, or sending / creating new data for a chain, you need to synchronize a node.  In our case, there are no other nodes, so I‚Äôm talking only about reading blocks from local files.  In the future, part of the synchronization will not only be reading from files, but also communicating with peers to collect blocks that were generated before your node was launched. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> node_blocks = [] <span class="hljs-comment"><span class="hljs-comment">#We're assuming that the folder and at least initial block exists chaindata_dir = 'chaindata' if os.path.exists(chaindata_dir): for filename in os.listdir(chaindata_dir): if filename.endswith('.json'): #.DS_Store sometimes screws things up filepath = '%s/%s' % (chaindata_dir, filename) with open(filepath, 'r') as block_file: block_info = json.load(block_file) block_object = Block(block_info) #since we can init a Block object with just a dict node_blocks.append(block_object) return node_blocks</span></span></code> </pre> <br>  While simple and beautiful.  Reading lines from files loading them into data structures does not require overly complex code.  While it works.  But in future posts, where I will write about the communication capabilities of different nodes, this sync function will become much more difficult. <br><br>  <b>Step 3 - Displaying the blockchain</b> <br><br>  Now our blockchain is in memory, and therefore I want to display the chain in the browser.  To do this right now, there are two reasons.  First, you need to confirm in the browser that the changes have occurred.  Secondly, I will use the browser in the future to view and perform any operations related to the blockchain.  For example, sending transactions or managing a wallet. <br><br>  For this, I use Flask - it has a low threshold of entry, and I decided that it is suitable for our purposes. <br><br>  Below is the code to display json blockchain.  I will ignore imports to save space. <br><br><pre> <code class="python hljs">node = Flask(__name__) node_blocks = sync.sync() <span class="hljs-comment"><span class="hljs-comment">#inital blocks that are synced @node.route('/blockchain.json', methods=['GET']) def blockchain(): ''' Shoots back the blockchain, which in our case, is a json list of hashes with the block information which is: index timestamp data hash prev_hash ''' node_blocks = sync.sync() #regrab the nodes if they've changed # Convert our blocks into dictionaries # so we can send them as json objects later python_blocks = [] for block in node_blocks: python_blocks.append(block.__dict__()) json_blocks = json.dumps(python_blocks) return json_blocks if __name__ == '__main__': node.run()</span></span></code> </pre> <br>  Run this code, go to localhost: 3000 / blockchain.json and see the current block. <br><br>  <b>Step 4 - ‚ÄúMining‚Äù, also known as block creation</b> <br><br>  Now there is only the genesis of the block, but if we have more data that needs to be stored and distributed, we need a way to include it in the new block.  The question is how to create a new block and connect it with the previous one. <br><br>  Satoshi describes it as follows in the bitcoin whitepaper.  Note that the ‚Äútimestamp server‚Äù is called a ‚Äúnode‚Äù. <br><br>  ‚ÄúLet's start the description of our solution with the timestamp server.  His job is to hash a block of data on which to put a timestamp, and open publication of this hash ... Timestamp shows that at this moment specific data existed and therefore fell into a block hash.  Each hash includes the previous timestamp: this is how the chain is built, where the next link strengthens all previous ones. ‚Äù <br><br>  Screenshot of the image attached under the description: <br><br><img src="https://habrastorage.org/webt/ch/4g/x-/ch4gx-cgdgx7pcjv9yxtaj7nvpa.png"><br><br>  The main idea of ‚Äã‚Äãthe section is to connect the blocks, if necessary, we create a hash of information about the new block, including the block creation time, the previous block hash, and the information in the block itself.  I will call all this information a ‚Äúblock header‚Äù.  Thus, we can check the correctness of the block, counting all the hashes in front of it, confirming the sequence. <br><br>  In this case, the header that I create combines the string values ‚Äã‚Äãinto one huge string.  I have included the following data: <br><br><ol><li>  An index showing how the block is; </li><li>  The hash of the previous block; </li><li>  Data is just random strings.  For bitcoin, they are called Merkle root and contain information about transactions; </li><li>  Timestamp mining this unit. </li></ol><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate_header</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(index, prev_hash, data, timestamp)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str(index) + prev_hash + data + str(timestamp)</code> </pre> <br>  Let me explain one thing - the union of information lines is not mandatory for creating a header.  <i>The requirement is that everyone knows how to generate a block header and a hash of the previous block inside it.</i>  <i>This is done so that everyone can verify the correctness of the hash in the new block and confirm the connection between the two blocks.</i> <br><br>  <a href="https://en.bitcoin.it/wiki/Block_hashing_algorithm">Bitcoin headers are</a> much harder to concatenate strings.  It uses data and time hashes and is tied to how data is located in memory.  But in our case, string concatenation is sufficient. <br><br>  Now we have a header and we can calculate the validity of the hash.  I will use a method that is different from the Bitcoin method, but I still run the block header through the sha256 function. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate_hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(index, prev_hash, data, timestamp, nonce)</span></span></span><span class="hljs-function">:</span></span> header_string = generate_header(index, prev_hash, data, timestamp, nonce) sha = hashlib.sha256() sha.update(header_string) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sha.hexdigest()</code> </pre> <br>  To mine a block, we use the function above to get a hash, put it in a new block and save this block in the chaindata directory. <br><br><pre> <code class="python hljs">node_blocks = sync.sync() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(last_block)</span></span></span><span class="hljs-function">:</span></span> index = int(last_block.index) + <span class="hljs-number"><span class="hljs-number">1</span></span> timestamp = date.datetime.now() data = <span class="hljs-string"><span class="hljs-string">"I block #%s"</span></span> % (int(last_block.index) + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">#random string for now, not transactions prev_hash = last_block.hash block_hash = calculate_hash(index, prev_hash, data, timestamp) block_data = {} block_data['index'] = int(last_block.index) + 1 block_data['timestamp'] = date.datetime.now() block_data['data'] = "I block #%s" % last_block.index block_data['prev_hash'] = last_block.hash block_data['hash'] = block_hash return Block(block_data) def save_block(block): chaindata_dir = 'chaindata' filename = '%s/%s.json' % (chaindata_dir, block.index) with open(filename, 'w') as block_file: print new_block.__dict__() json.dump(block.__dict__(), block_file) if __name__ == '__main__': last_block = node_blocks[-1] new_block = mine(last_block) save_block(new_block)</span></span></code> </pre> <br>  Done!  But with this type of block creation, anyone with the fastest CPU will be able to create the longest circuits that other nodes consider correct.  We need a way to reduce the speed of block creation and confirmation before moving to the next block. <br><br>  <b>Step 5 - Proof of Work</b> <br><br>  To reduce the speed I use Proof of performance, like Bitcoin.  <a href="https://en.wikipedia.org/wiki/Proof-of-stake">Proof of ownership share</a> is another method used in blockchains to achieve consensus, but in this case I will take advantage of the work. <br><br>  The way to do this is to set the requirements for the block hash structure.  As in the case of bitcoin, you need to make sure that the hash starts with a certain number of zeros, before proceeding to the next.  And for this you need to add additional information to the header - a randomly selected number (nonce). <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate_header</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(index, prev_hash, data, timestamp, nonce)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str(index) + prev_hash + data + str(timestamp) + str(nonce)</code> </pre> <br>  Now the mining function is configured to create a hash, but if the block hash does not contain enough zeros, we increase the nonce value, create a new header, calculate a new hash and check if there are enough zeros. <br><br><pre> <code class="python hljs">NUM_ZEROS = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(last_block)</span></span></span><span class="hljs-function">:</span></span> index = int(last_block.index) + <span class="hljs-number"><span class="hljs-number">1</span></span> timestamp = date.datetime.now() data = <span class="hljs-string"><span class="hljs-string">"I block #%s"</span></span> % (int(last_block.index) + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">#random string for now, not transactions prev_hash = last_block.hash nonce = 0 block_hash = calculate_hash(index, prev_hash, data, timestamp, nonce) while str(block_hash[0:NUM_ZEROS]) != '0' * NUM_ZEROS: nonce += 1 block_hash = calculate_hash(index, prev_hash, data, timestamp, nonce) block_data = {} block_data['index'] = int(last_block.index) + 1 block_data['timestamp'] = date.datetime.now() block_data['data'] = "I block #%s" % last_block.index block_data['prev_hash'] = last_block.hash block_data['hash'] = block_hash block_data['nonce'] = nonce return Block(block_data)</span></span></code> </pre> <br>  Fine.  The new block contains a valid nonce value, so other nodes can confirm the hash.  We can generate, save and distribute the rest of the block. <br><br>  <b>Conclusion</b> <br><br>  That's all!  For now.  There are still a lot of questions and features in the blockchains, which I did not explain. <br><br>  For example, how to use other nodes?  How do nodes transfer data when included in a block?  Are there any other ways to store data besides huge rows of data? <br>  The answers to these questions will be found in the following parts of this series of posts, as soon as I find the answers to them myself.  You can write my wishes on the content to me on twitter, in the comments to the post or via the feedback form! <br><br>  Thanks to my sister Sarah for asking questions about the blockchains and help in editing the post! <br><br>  THE END <br><br>  Comments, questions, as always, are welcome both here and at <a href="https://otus.pw/oDNL/">the open door.</a> </div><p>Source: <a href="https://habr.com/ru/post/342974/">https://habr.com/ru/post/342974/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../342962/index.html">BPM in the company: let them decide the processes</a></li>
<li><a href="../342964/index.html">Optimize frontend. Part 2. We repair tree-shaking in the project on webpack</a></li>
<li><a href="../342966/index.html">What rules of English do our foreign colleagues violate? Part 2</a></li>
<li><a href="../342968/index.html">Torskel - simplify the routine in Tornado</a></li>
<li><a href="../342970/index.html">Exonum 0.3 - what we have improved in the new version of the framework for the development of blockchains</a></li>
<li><a href="../342976/index.html">10 obvious steps to prepare the infrastructure of an online store for Black Friday</a></li>
<li><a href="../342978/index.html">From searching to examining documents in network balls and file dumps</a></li>
<li><a href="../342982/index.html">Conan: dependency manager for C / C ++</a></li>
<li><a href="../342984/index.html">Node.js basis for async / await API out of the box</a></li>
<li><a href="../342986/index.html">OWASP Top 10 2017</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>