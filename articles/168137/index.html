<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Load Testing with Selenium</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 In this article I will talk about the application of the tool originally intended for functional testing when testing the load web part...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Load Testing with Selenium</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  In this article I will talk about the application of the tool originally intended for functional testing when testing the load web part of the electronic document management system (EDMS). <br><a name="habracut"></a><br>  Why do you need it at all?  We pursued two goals - the introduction of automated tests for our web applications and the creation of load tests based on functional tests. <br><br>  Why was Selenium used for the test, and not a more suitable tool - LoadRunner, jMeter?  With LoadRunner's, a load test was carried out, but the results were questioned - when emulating two hundred users, the page was loaded in 2 seconds plus or minus 2%, although when opening the same pages from the browser, the display occurred in more than 3 seconds.  So I wanted to carry out load tests as close to reality as possible, and this can be done only with the help of full emulation of user behavior.  Tools for functional testing with their work with browsers were just suitable for this ‚Äî the site would open through a normal browser, i.e.  as the user would do it. <br><br><h4>  About Selenium </h4><br>  For functional testing, Selenium was chosen for a simple reason - it is the best of free tools for functional testing.  More specifically, it has good remote control support (Selenium Server, Selenium Grid), a lot of documentation (including in Russian ( <a href="http://habrahabr.ru/post/151715/">habrahabr.ru/post/151715</a> <a href="http://habrahabr.ru/post/152653/">habrahabr.ru/post/152653</a> ) and support for all major browsers (although this is more the merit of WebDriver). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Common architecture </h4><br><img src="https://habrastorage.org/storage2/898/589/016/898589016e9b6fe300fc5e1b5112773e.png"><br><br>  The application is divided into levels (for clarity on the diagram, the elements of each level have meaningful names, and not just Test 1, Methods 2). <br><br>  The first level - the level of "runner" tests.  It just runs the tests.  The settings configure the number of threads, the number of test runs, test classes. <br><br>  The second level is the tests themselves.  They perform business transactions - they log in, open lists of documents, open documents, go through the document tabs. <br><br>  The third level is the level of work with web-elements.  It contains atomic user operations for working with the system - opening a list of documents, moving to a specific document, working with document tabs. <br><br>  To begin, the above actions will be sufficient to ensure minimal work with the system.  In the future they will be added. <br><br>  The division into these levels gives the following benefit - you can run tests with both the "runner" and without it - just running one test from the development environment.  Bringing atomic user operations to a separate level will allow you to abandon writing tests in Java in the future, and develop your own DSL ( <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25B4%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F">ru.wikipedia.org/wiki/Project-oriented_programming</a> ) so that any people can write tests. <br><br><h4>  Running tests </h4><br>  The program for running jUnit tests is quite simple and consists of three classes - a class that performs the specified tests in its thread;  jUnit test ‚Äúlistener‚Äù class to calculate test run time;  class for the formation of threads and their launch. <br>  Runner code <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> threadCount = readThreadCount(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> invocationCount = readInvocationCount(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;Class&gt; testClasses = readTestClasses(); ExecutorService taskExecutor = Executors.newFixedThreadPool(threadCount); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; threadCount; i++) { taskExecutor.execute(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TestRunner(invocationCount, testClasses)); } taskExecutor.shutdown(); taskExecutor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);</code> </pre> <br><br>  Test class code <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestRunner</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ JUnitCore jUnitRunner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JUnitCore(); jUnitRunner.addListener(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimeListener()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; invocationCount; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Class clazz : testClasses) { jUnitRunner.run(clazz); } Thread.sleep(invocationTimeOut); } } }</code> </pre><br><br>  Listener code <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TimeListener</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RunListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EtmPoint point; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testStarted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Description description)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ point = EtmManager.getEtmMonitor().createPoint(description.getClassName() + <span class="hljs-string"><span class="hljs-string">"."</span></span> + description.getMethodName();); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFinished</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Description description)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ point.collect(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFailure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Failure failure)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ log.error(<span class="hljs-string"><span class="hljs-string">"Error in test."</span></span>, failure.getException()); } }</code> </pre><br><br><h4>  Tests </h4><br>  Tests were written simple, but, nevertheless, reflecting the user's work - opening a list of documents, opening a document card, navigating through the tabs of a card. <br><br>  For writing tests used jUnit.  Although you can also use TestNG, which supports parallel test execution (and this is a mandatory requirement for load testing).  But jUnit was chosen for two reasons: 1) it was widely distributed in the company and used for a long time 2) you still had to write your own ‚Äúrunner‚Äù who would allow, without changing tests, run them in different threads (in TestNG, the parallel launch is configured in the tests themselves) and collect statistics on their implementation. <br><br>  In addition to the tests, additional modules were written - pool webdrivers (here the word webdriver is used in Selenium terminology), pool of users, pool of documents, rule (in jUnit terminology) for taking screenshots in case of error, rule for issuing a webdriver test, rule authorization. <br><br>  Pool webdrivers are the class that manages the receiving of a webdriver from Selenium's server and distributes them between tests.  It is needed in order to abstract work with Selenium - tests will get webdrivers and give them to this pool.  Webdrivers do not close at the same time (the close method is not called).  This is because not to restart the browser.  Those.  Thus, the ‚Äúreuse‚Äù of webdrivers by other tests is obtained.  But reuse has its drawbacks - when you return the webdriver to the pool, you need to ‚Äúclean up‚Äù behind you - delete all cookies or, if this cannot be done, perform a logout. <br>  Just as it turned out later, this pool should restart the webdrivers for which the session ended.  This is possible when an error occurred on the server side. <br><br>  Pool of users is needed mainly during load testing, when you need to run the same tests under different users.  He is only in a circle gives the username / password of the next user. <br>  Pool of documents, as well as users, is needed mainly during load testing - it returns the id of documents of a certain type in a circle. <br><br>  Rule for taking screenshots in case of an error is needed, as the name implies, to take a screenshot when a test fails.  He saves it to a folder and writes to the log the name of the screenshot with the error stacktrace.  It helps to further "see" the error, and not just read it in the logs.  ( <a href="http://internetka.in.ua/selenium-rule-screenshot/">internetka.in.ua/selenium-rule-screenshot</a> ) <br>  Rule for issuing webdriver'a test is needed in order to automate the receipt before the start of the test method and return at the end of the webdriver'a from the pool of webdrivers. <br><br>  Rule authorization is also needed for automation, only now authorization - so that in each test method does not write login \ logout. <br><br><h4>  Statistics collection </h4><br>  To collect statistics, it was decided not to reinvent the wheel, but to use some of the ready-made frameworks.  Search on the Internet, unfortunately, did not give a wide choice - only one tool - JETM (http://jetm.void.fm/), and it has not changed since 2009.  Although it has good documentation and small advantages - remote connection via HTTP to view statistics in real time. <br>  The configuration code for the monitor and the launch of the http console: <br><pre> <code class="java hljs"> BasicEtmConfigurator.configure(); EtmMonitor etmMonitor = EtmManager.getEtmMonitor(); etmMonitor.start(); HttpConsoleServer server = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpConsoleServer(etmMonitor); server.start();</code> </pre><br>  Statistics were collected from two places: the total time was taken for the execution of test methods (from the ‚Äústart-up‚Äù level) and the time for performing atomic user operations (from the third level).  To solve the first problem, a RunListener successor was used, in which the methods for starting and ending the test were redefined and information about execution was collected in them. <br><br>  The solution of the second problem could be carried out ‚Äúin the forehead‚Äù - at the beginning and at the end of each method, the execution time of which needs to be written down, write the code for starting this time.  But since there are already more than five methods now, and in the future they will be much more, I would like to automate this.  For this, I used AOP, specifically AspectJ.  A simple aspect was written that added counting the execution time of all public methods from classes with custom operations.  Time was counted only by successfully executed methods, so that the methods that took off with an error in the middle of the execution did not spoil the statistics.  One drawback was also found when collecting statistics on method names - since the methods for working with user operations were universal and were called by all tests, but the statistics needed to be collected by document types.  Therefore, statistics were collected not only by the name of the methods, but also by their arguments that identify the document type. <br><br>  Aspect Method Code <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Around</span></span>(<span class="hljs-string"><span class="hljs-string">"execution(public static * &lt;    &gt;.*.*(..))"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">profileMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProceedingJoinPoint thisJoinPoint)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ EtmPoint point = EtmManager.getEtmMonitor().createPoint(getPointName(thisJoinPoint)); Object result = thisJoinPoint.proceed(); point.collect(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br><br>  The getPointName method generates the name of the time slice point based on the name of the method and its parameters. <br><br><h4>  Browsers for load testing </h4><br>  After writing all the tests, the question arose on which browsers to run it.  In the case of functional testing, everything is simple here - you need to run tests on those browsers on which users will work.  For us, this is IE 9. Therefore, I tried to run tests on IE with multiple instances of the browser on the machine, so that one computer could emulate the work of several users (In Selenium, one WebDriver is one instance of the browser).  As a result, on my machine (4GB of RAM, 2.3 Core 2 Duo), only 4 IEs worked normally.  That is not very good - to emulate two hundred users will need 50 machines.  It was necessary to look for an alternative.  And these are: a) other desktop browsers b) headless browsers. <br><br>  From desktop browsers, FF and Chrome were tested.  With Chrome, the situation was the same, plus for his work he demanded that WebDriver be launched in a separate process for each Chrome instance.  What increased resource requirements.  With FF, the situation was slightly better - 5 browsers worked normally without an additional launch of WebDrivers.  But this situation is not much improved. <br><br>  Then we would have to test headless browsers - browsers that fully work with the site (build DOM, run JS), but do not display it.  In theory, they should work faster.  Of all the headless browsers stopped at 2 - PhantomJS and HttpUnit.  Prospectively looked like PhantomJS, based on Webkit.  But in fact, he did not differ from FF in terms of resource consumption, but had the following disadvantages - sometimes he didn‚Äôt find the elements on the page and didn‚Äôt display the site correctly on screenshots.  So it was not possible to understand why an error occurred.  With HtmlUnit, everything is much simpler - its webdriver did not support alert, and this was critical for our web application. <br><br>  As a result, returned to the use of FF in load testing.  Although it also had problems with alert'ami - sometimes there were errors java.lang.Boolean cannot be java.lang.String (java.lang.ClassCastException) (here is a link to Google's error code <a href="http://code.google.com/p/selenium/issues/detail%3Fid%3D3565">code.google.com/p / selenium / issues / detail? id = 3565</a> ).  Fix this error did not work, but it turned out to completely abandon the alert.  So in the future you can try again to use HtmlUnit.  Although all headless browsers have one common disadvantage associated with their specificity - they do not display the pages and so simply can not understand why an error occurred.  The ability to take a screenshot does not help much - sometimes it is not informative. <br><br><h4>  Selenium configuration </h4><br>  Selenium's server supports launching in two modes - as a standalone server (default startup mode) and as part of a common network from Selenium servers - Selenium Grid (startup modes with ‚Äìrole hub and ‚Äìrole node).  Since we needed to use a large number of computers, the first mode is not very suitable - in this case, each server will need to be managed separately.  Ie, in fact, write your server manager.  Although, at first, I was impressed by this option - in this case, we will have full control over which browser to run on which machine.  But in the future I refused it - full control over the launch of browsers was not needed, plus Selenium Grid bribed with its ease of use.  (link to Selenium Grid configuration page <a href="http://code.google.com/p/selenium/wiki/Grid2">code.google.com/p/selenium/wiki/Grid2</a> ) <br><br>  As a result, we came to the following configuration: On one computer, Selenium was launched in hub mode with the additional parameter ‚Äìtimeout 0. This was necessary because sometimes the sessions were closed by timeout due to the long inactivity of the tests.  On other computers, Selenium was started in node mode.  For powerful computers capable of running 15 browsers, node Selenium was launched with an additional setting that allows you to run 15 copies of FF and indicating that you can work with 15 sessions at the same time. <br><br><h4>  Testing </h4><br>  The tests were carried out as follows: one instance of the browser was launched on one computer, which executed the test scripts several times and from which the execution time was taken.  On the other computers, the same test scripts were run, but on several browsers.  Such a division for measuring time is necessary in order that simultaneous operation of browsers does not affect the measurement result.  As if doing the same measurements on several running browsers, then the time will be slightly longer. <br><br>  A few words need to be said about the test scenarios and the timing of their execution.  Each scenario included the opening of documents of each type.  Those.  first opened the incoming document, then the outgoing document, etc.  Here you need to take into account the following situation: if you only need to remove the opening time of an incoming document, and only run this script on all the execution machines, then the time will be significantly less (50%) than if you removed the time while all scenarios were executed.  In my case, most likely it was related to caching at the web application and DBMS levels.  And the fact that few unique documents were opened.  Perhaps, with a large number of different documents, the differences will not be so significant. <br><br>  Ideally, I would like to get the distribution of users and documents as it will be in a really working system.  Ie, for example, in a real system there will be 10 people working with incoming and 30 with outgoing.  And in the load test also reflect this ratio - the number of tests for outgoing is three times more than with incoming documents.  But since the system under test has not yet been commissioned and this data is not yet available, testing has taken place without taking them into account. <br><br><h4>  Summarizing </h4><br>  As a result of tests for 1 st, 16, 26 and 70 users, a schedule was drawn up for each scenario.  So far, the number of users is not too large to draw accurate conclusions, but now we can trace the growth rate of time. <br>  Dependence of the opening time of documents on the number of working users: <br><img src="http://habrastorage.org/storage2/821/1d1/08c/8211d108c68da03fb59d556c0b231b0c.png"><br><br>  The dependence of the time of the list of documents on the number of working users: <br><img src="http://habrastorage.org/storage2/6f9/3fe/4c0/6f93fe4c0a9be0c226c04b5189903d40.png"><br>  Further tests will continue to build a schedule for up to 200 users.  The result should be a graph similar to this one (taken from <a href="http://msdn.microsoft.com/en-us/library/bb924375.aspx">msdn.microsoft.com/en-us/library/bb924375.aspx</a> ): <br><img src="http://habrastorage.org/storage2/e01/5ef/067/e015ef06731f065dd98e2c2b7878846a.png"><br><br>  According to it, it will be possible to accurately determine the capabilities of the system and find its bottlenecks. </div><p>Source: <a href="https://habr.com/ru/post/168137/">https://habr.com/ru/post/168137/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../168121/index.html">Mobile subscriptions, AdWords, Vkontakte application and phishing</a></li>
<li><a href="../168123/index.html">More FineReader good and different!</a></li>
<li><a href="../168125/index.html">SALT - configuration management software for Python</a></li>
<li><a href="../168129/index.html">DoubleArrayList is a universal implementation of java.util.List</a></li>
<li><a href="../168133/index.html">Finger topology</a></li>
<li><a href="../168139/index.html">$ 30,000 from Telerik for Windows 8 developers</a></li>
<li><a href="../168141/index.html">Cackle - year results</a></li>
<li><a href="../168143/index.html">Russian football on the "plus". And with a plus? Or we don‚Äôt need such football: Part 1 theoretical</a></li>
<li><a href="../168147/index.html">We open the entry in the cohort of newsmen</a></li>
<li><a href="../168149/index.html">CSS3 generators. The best</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>