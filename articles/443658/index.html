<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Setting up a Kubernetes HA cluster on bare metal, monitoring, logs and usage examples. Part 3/3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 1/3 here . 


 Part 2/3 here . 


 Hello! And here is the third part of the Kubernetes leadership on bare metal! I will focus on monitoring the c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Setting up a Kubernetes HA cluster on bare metal, monitoring, logs and usage examples. Part 3/3</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/oa/xl/av/oaxlavwz_atdglepw3r_vn6hmxm.jpeg"></p><br><p>  Part 1/3 <a href="https://habr.com/ru/company/southbridge/blog/439562/">here</a> . </p><br><p>  Part 2/3 <a href="https://habr.com/ru/company/southbridge/blog/443110/">here</a> . </p><br><p>  Hello!  And here is the third part of the Kubernetes leadership on bare metal!  I will focus on monitoring the cluster and collecting logs, and we will also launch a test application to use pre-configured cluster components.  Then we will conduct several stress tests and check the stability of this cluster scheme. </p><a name="habracut"></a><br><p>  The <a href="https://github.com/kubernetes/dashboard"><strong>Kubernetes Dashboard</strong></a> is the most popular tool that the Kubernetes community offers to provide a web interface and obtain cluster statistics.  In fact, it is still at the development stage, but even now it can provide some additional data for troubleshooting applications and managing cluster resources. </p><br><p>  The topic is somewhat controversial.  Is it true that a web interface is needed to manage the cluster, or is it enough to use the <strong>kubectl</strong> console tool?  Well, sometimes the options mentioned complement each other. </p><br><p>  Let's turn our <strong>Kubernetes Dashboard</strong> and see.  With standard Deploy, this dashboard will start only at the local host address.  Thus, for disclosure, you must use the <strong>kubectl proxy</strong> command, but it is still available only on your local kubectl control device.  Not bad from a security point of view, but I want to have access in the browser, outside the cluster, and I am ready to take a certain risk (after all, ssl with an effective token is used) </p><br><p>  To apply my method, you need to slightly change the standard deployment file in the service section.  To reveal this dashboard to an open address, use our load balancer. </p><br><p>  We log into the machine system with the <strong>kubectl</strong> utility <strong>configured</strong> and create: </p><br><pre><code class="plaintext hljs">control# vi kube-dashboard.yaml # Copyright 2017 The Kubernetes Authors. # # Licensed under the Apache License, Version 2.0 (the "License"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an "AS IS" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # ------------------- Dashboard Secret ------------------- # apiVersion: v1 kind: Secret metadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard-certs namespace: kube-system type: Opaque --- # ------------------- Dashboard Service Account ------------------- # apiVersion: v1 kind: ServiceAccount metadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard namespace: kube-system --- # ------------------- Dashboard Role &amp; Role Binding ------------------- # kind: Role apiVersion: rbac.authorization.k8s.io/v1 metadata: name: kubernetes-dashboard-minimal namespace: kube-system rules: # Allow Dashboard to create 'kubernetes-dashboard-key-holder' secret. - apiGroups: [""] resources: ["secrets"] verbs: ["create"] # Allow Dashboard to create 'kubernetes-dashboard-settings' config map. - apiGroups: [""] resources: ["configmaps"] verbs: ["create"] # Allow Dashboard to get, update and delete Dashboard exclusive secrets. - apiGroups: [""] resources: ["secrets"] resourceNames: ["kubernetes-dashboard-key-holder", "kubernetes-dashboard-certs"] verbs: ["get", "update", "delete"] # Allow Dashboard to get and update 'kubernetes-dashboard-settings' config map. - apiGroups: [""] resources: ["configmaps"] resourceNames: ["kubernetes-dashboard-settings"] verbs: ["get", "update"] # Allow Dashboard to get metrics from heapster. - apiGroups: [""] resources: ["services"] resourceNames: ["heapster"] verbs: ["proxy"] - apiGroups: [""] resources: ["services/proxy"] resourceNames: ["heapster", "http:heapster:", "https:heapster:"] verbs: ["get"] --- apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: kubernetes-dashboard-minimal namespace: kube-system roleRef: apiGroup: rbac.authorization.k8s.io kind: Role name: kubernetes-dashboard-minimal subjects: - kind: ServiceAccount name: kubernetes-dashboard namespace: kube-system --- # ------------------- Dashboard Deployment ------------------- # kind: Deployment apiVersion: apps/v1 metadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard namespace: kube-system spec: replicas: 1 revisionHistoryLimit: 10 selector: matchLabels: k8s-app: kubernetes-dashboard template: metadata: labels: k8s-app: kubernetes-dashboard spec: containers: - name: kubernetes-dashboard image: k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.1 ports: - containerPort: 8443 protocol: TCP args: - --auto-generate-certificates # Uncomment the following line to manually specify Kubernetes API server Host # If not specified, Dashboard will attempt to auto discover the API server and connect # to it. Uncomment only if the default does not work. # - --apiserver-host=http://my-address:port volumeMounts: - name: kubernetes-dashboard-certs mountPath: /certs # Create on-disk volume to store exec logs - mountPath: /tmp name: tmp-volume livenessProbe: httpGet: scheme: HTTPS path: / port: 8443 initialDelaySeconds: 30 timeoutSeconds: 30 volumes: - name: kubernetes-dashboard-certs secret: secretName: kubernetes-dashboard-certs - name: tmp-volume emptyDir: {} serviceAccountName: kubernetes-dashboard # Comment the following tolerations if Dashboard must not be deployed on master tolerations: - key: node-role.kubernetes.io/master effect: NoSchedule --- # ------------------- Dashboard Service ------------------- # kind: Service apiVersion: v1 metadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard namespace: kube-system spec: type: LoadBalancer ports: - port: 443 targetPort: 8443 selector: k8s-app: kubernetes-dashboard</code> </pre> <br><p>  Then run: </p><br><pre> <code class="plaintext hljs">control# kubectl create -f kube-dashboard.yaml control# kubectl get svc --namespace=kube-system kubernetes-dashboard LoadBalancer 10.96.164.141 192.168.0.240 443:31262/TCP 8h</code> </pre> <br><p>  Well, as you can see, our BN added IP 192.168.0.240 for this service.  Now try opening <a href="https://192.168.0.240/">https://192.168.0.240</a> to view the Kubernetes Dashboard. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ml/pc/dh/mlpcdhrwki9fh_pzaa7by9mq7i8.png"></a> </p><br><p>  To gain access, there are 2 ways: use the <code>admin.conf</code> file from our master node, which we used earlier when setting up kubectl, or creating a special service account with a security token. </p><br><p>  Let's create an admin user: </p><br><pre> <code class="plaintext hljs">control# vi kube-dashboard-admin.yaml apiVersion: v1 kind: ServiceAccount metadata: name: admin-user namespace: kube-system --- apiVersion: rbac.authorization.k8s.io/v1beta1 kind: ClusterRoleBinding metadata: name: admin-user roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-admin subjects: - kind: ServiceAccount name: admin-user namespace: kube-system control# kubectl create -f kube-dashboard-admin.yaml serviceaccount/admin-user created clusterrolebinding.rbac.authorization.k8s.io/admin-user created</code> </pre> <br><p>  Now you need a token to log in: </p><br><pre> <code class="plaintext hljs">control# kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk '{print $1}') Name: admin-user-token-vfh66 Namespace: kube-system Labels: &lt;none&gt; Annotations: kubernetes.io/service-account.name: admin-user kubernetes.io/service-account.uid: 3775471a-3620-11e9-9800-763fc8adcb06 Type: kubernetes.io/service-account-token Data ==== ca.crt: 1025 bytes namespace: 11 bytes token: erJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwna3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJr dWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi11c2VmLXRva2VuLXZmaDY2Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZ XJ2aWNlLWFjY291bnQubmFtZSI6ImFkbWluLXVzZXIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiIzNzc1NDcxYS0zNjIwLTExZTktOTgwMC03Nj NmYzhhZGNiMDYiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZS1zeXN0ZW06YWRtaW4tdXNlciJ9.JICASwxAJHFX8mLoSikJU1tbij4Kq2pneqAt6QCcGUizFLeSqr2R5x339ZR8W4 9cIsbZ7hbhFXCATQcVuWnWXe2dgXP5KE8ZdW9uvq96rm_JvsZz0RZO03UFRf8Exsss6GLeRJ5uNJNCAr8No5pmRMJo-_4BKW4OFDFxvSDSS_ZJaLMqJ0LNpwH1Z09SfD8TNW7VZqax4zuTSMX_yVS ts40nzh4-_IxDZ1i7imnNSYPQa_Oq9ieJ56Q-xuOiGu9C3Hs3NmhwV8MNAcniVEzoDyFmx4z9YYcFPCDIoerPfSJIMFIWXcNlUTPSMRA-KfjSb_KYAErVfNctwOVglgCISA</code> </pre> <br><p>  Copy the token and paste it into the token field on the login screen. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/mr/yz/8x/mryz8xkchmzk4mx-wcxd-9jh4c8.png"></a> </p><br><p>  After logging in, you can explore the cluster a little deeper - I like this tool. <br>  The next step towards deepening the monitoring system of our cluster is installing <a href="https://github.com/kubernetes-retired/heapster"><strong>heapster</strong></a> . </p><br><blockquote>  Heapster allows you to monitor container cluster and analyze performance for <a href="https://github.com/kubernetes/kubernetes">Kubernetes</a> (version v1.0.6 and higher).  He offers the appropriate platforms. </blockquote><p>  This tool offers statistics on cluster usage through the console, and also adds more information about node and sub-resources to the Kubernetes Dashboard. </p><br><p>  With its installation on ‚Äúbare iron‚Äù there is a small complexity, and I needed to carry out some investigation: why the tool does not work in the original version - but I found the solution. </p><br><p>  So let's continue and complement this addition: </p><br><pre> <code class="plaintext hljs">control# vi heapster.yaml apiVersion: v1 kind: ServiceAccount metadata: name: heapster namespace: kube-system --- apiVersion: extensions/v1beta1 kind: Deployment metadata: name: heapster namespace: kube-system spec: replicas: 1 template: metadata: labels: task: monitoring k8s-app: heapster spec: serviceAccountName: heapster containers: - name: heapster image: gcr.io/google_containers/heapster-amd64:v1.4.2 imagePullPolicy: IfNotPresent command: - /heapster - --source=kubernetes.summary_api:''?useServiceAccount=true&amp;kubeletHttps=true&amp;kubeletPort=10250&amp;insecure=true --- apiVersion: v1 kind: Service metadata: labels: task: monitoring # For use as a Cluster add-on (https://github.com/kubernetes/kubernetes/tree/master/cluster/addons) # If you are NOT using this as an addon, you should comment out this line. kubernetes.io/cluster-service: 'true' kubernetes.io/name: Heapster name: heapster namespace: kube-system spec: ports: - port: 80 targetPort: 8082 selector: k8s-app: heapster --- kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: heapster roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: system:heapster subjects: - kind: ServiceAccount name: heapster namespace: kube-system</code> </pre> <br><p>  This is the most common standard deployment file from the Heapster community, with only a small difference: in order for it to work on our cluster, the string ‚Äú <strong>source =</strong> ‚Äù in the heapster section is changed as follows: </p><br><pre> <code class="plaintext hljs">--source=kubernetes.summary_api:''?useServiceAccount=true&amp;kubeletHttps=true&amp;kubeletPort=10250&amp;insecure=true</code> </pre> <br><p>  In this <a href="">description</a> you will find all these options.  I changed the kubelet port to 10250 and turned off ssl certificate verification (there was a slight problem with it). </p><br><p>  We also need to add permissions to get node statistics for the Heapster RBAC role;  add these few lines at the end of the role: </p><br><pre> <code class="plaintext hljs">control# kubectl edit clusterrole system:heapster ...... ... - apiGroups: - "" resources: - nodes/stats verbs: - get</code> </pre> <br><p>  As a result, your RBAC role should look like this: </p><br><pre> <code class="plaintext hljs"># Please edit the object below. Lines beginning with a '#' will be ignored, # and an empty file will abort the edit. If an error occurs while saving this file will be # reopened with the relevant failures. # apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: annotations: rbac.authorization.kubernetes.io/autoupdate: "true" creationTimestamp: "2019-02-22T18:58:32Z" labels: kubernetes.io/bootstrapping: rbac-defaults name: system:heapster resourceVersion: "6799431" selfLink: /apis/rbac.authorization.k8s.io/v1/clusterroles/system%3Aheapster uid: d99065b5-36d3-11e9-a7e6-763fc8adcb06 rules: - apiGroups: - "" resources: - events - namespaces - nodes - pods verbs: - get - list - watch - apiGroups: - extensions resources: - deployments verbs: - get - list - watch - apiGroups: - "" resources: - nodes/stats verbs: - get</code> </pre> <br><p>  Well, now we will execute the command to make sure that the heapster deployment was successfully launched. </p><br><pre> <code class="plaintext hljs">control# kubectl top node NAME CPU(cores) CPU% MEMORY(bytes) MEMORY% kube-master1 183m 9% 1161Mi 60% kube-master2 235m 11% 1130Mi 59% kube-worker1 189m 4% 1216Mi 41% kube-worker2 218m 5% 1290Mi 44% kube-worker3 181m 4% 1305Mi 44%</code> </pre> <br><p>  Well, if you got some data at the output, then everything is done correctly.  Go back to our dashboard page and check out the new graphs that are now available. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/gj/rt/wu/gjrtwuo1wlzl0ixrqazhakojfdo.jpeg"></a> <br> <a href=""><img src="https://habrastorage.org/webt/q1/z1/n3/q1z1n3m1jqjmqiid7a2bgdfdra4.jpeg"></a> </p><br><p>  From this point on, we can also track the actual use of resources for the nodes of the cluster, pods, etc. </p><br><p>  If this is not enough, you can further improve the statistics by adding InfluxDB + Grafana.  This will add the ability to draw your own Grafana panels. </p><br><p>  We will use this version of the <a href="https://github.com/kubernetes-retired/heapster/tree/master/deploy/kube-config/influxdb">InfluxDB + Grafana installation</a> from the Heapster Git page, but, as usual, we will make corrections.  Since we previously configured the heapster deploy, we only need to add Grafana and InfluxDB, and then modify the existing heapster so that it also enters the metrics in Influx. </p><br><p>  Well, let's create InfluxDB and Grafana deployments: </p><br><pre> <code class="plaintext hljs">control# vi influxdb.yaml apiVersion: extensions/v1beta1 kind: Deployment metadata: name: monitoring-influxdb namespace: kube-system spec: replicas: 1 template: metadata: labels: task: monitoring k8s-app: influxdb spec: containers: - name: influxdb image: k8s.gcr.io/heapster-influxdb-amd64:v1.5.2 volumeMounts: - mountPath: /data name: influxdb-storage volumes: - name: influxdb-storage emptyDir: {} --- apiVersion: v1 kind: Service metadata: labels: task: monitoring # For use as a Cluster add-on (https://github.com/kubernetes/kubernetes/tree/master/cluster/addons) # If you are NOT using this as an addon, you should comment out this line. kubernetes.io/cluster-service: 'true' kubernetes.io/name: monitoring-influxdb name: monitoring-influxdb namespace: kube-system spec: ports: - port: 8086 targetPort: 8086 selector: k8s-app: influxdb</code> </pre> <br><p>  Next is Grafana, and don't forget to change the service setting to enable the MetaLB load balancer and get an external IP address for the Grafana service. </p><br><pre> <code class="plaintext hljs">control# vi grafana.yaml apiVersion: extensions/v1beta1 kind: Deployment metadata: name: monitoring-grafana namespace: kube-system spec: replicas: 1 template: metadata: labels: task: monitoring k8s-app: grafana spec: containers: - name: grafana image: k8s.gcr.io/heapster-grafana-amd64:v5.0.4 ports: - containerPort: 3000 protocol: TCP volumeMounts: - mountPath: /etc/ssl/certs name: ca-certificates readOnly: true - mountPath: /var name: grafana-storage env: - name: INFLUXDB_HOST value: monitoring-influxdb - name: GF_SERVER_HTTP_PORT value: "3000" # The following env variables are required to make Grafana accessible via # the kubernetes api-server proxy. On production clusters, we recommend # removing these env variables, setup auth for grafana, and expose the grafana # service using a LoadBalancer or a public IP. - name: GF_AUTH_BASIC_ENABLED value: "false" - name: GF_AUTH_ANONYMOUS_ENABLED value: "true" - name: GF_AUTH_ANONYMOUS_ORG_ROLE value: Admin - name: GF_SERVER_ROOT_URL # If you're only using the API Server proxy, set this value instead: # value: /api/v1/namespaces/kube-system/services/monitoring-grafana/proxy value: / volumes: - name: ca-certificates hostPath: path: /etc/ssl/certs - name: grafana-storage emptyDir: {} --- apiVersion: v1 kind: Service metadata: labels: # For use as a Cluster add-on (https://github.com/kubernetes/kubernetes/tree/master/cluster/addons) # If you are NOT using this as an addon, you should comment out this line. kubernetes.io/cluster-service: 'true' kubernetes.io/name: monitoring-grafana name: monitoring-grafana namespace: kube-system spec: # In a production setup, we recommend accessing Grafana through an external Loadbalancer # or through a public IP. # type: LoadBalancer # You could also use NodePort to expose the service at a randomly-generated port # type: NodePort type: LoadBalancer ports: - port: 80 targetPort: 3000 selector: k8s-app: grafana</code> </pre> <br><p>  And create them: </p><br><pre> <code class="plaintext hljs">control# kubectl create -f influxdb.yaml deployment.extensions/monitoring-influxdb created service/monitoring-influxdb created control# kubectl create -f grafana.yaml deployment.extensions/monitoring-grafana created service/monitoring-grafana created</code> </pre> <br><p>  It's time to change the heapster deploy and add the InfluxDB connection to it;  you need to add just one line: </p><br><pre> <code class="plaintext hljs">- --sink=influxdb:http://monitoring-influxdb.kube-system.svc:8086</code> </pre> <br><p>  Edit the heapster patch: </p><br><pre> <code class="plaintext hljs">control# kubectl get deployments --namespace=kube-system NAME READY UP-TO-DATE AVAILABLE AGE coredns 2/2 2 2 49d heapster 1/1 1 1 2d12h kubernetes-dashboard 1/1 1 1 3d21h monitoring-grafana 1/1 1 1 115s monitoring-influxdb 1/1 1 1 2m18s control# kubectl edit deployment heapster --namespace=kube-system ... beginning bla bla bla spec: containers: - command: - /heapster - --source=kubernetes.summary_api:''?useServiceAccount=true&amp;kubeletHttps=true&amp;kubeletPort=10250&amp;insecure=true - --sink=influxdb:http://monitoring-influxdb.kube-system.svc:8086 image: gcr.io/google_containers/heapster-amd64:v1.4.2 imagePullPolicy: IfNotPresent .... end</code> </pre> <br><p>  Now we‚Äôll find the external IP address of the Grafana service and log in to the system inside it: </p><br><pre> <code class="plaintext hljs">control# kubectl get svc --namespace=kube-system NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE ..... some other services here monitoring-grafana LoadBalancer 10.98.111.200 192.168.0.241 80:32148/TCP 18m</code> </pre> <br><p>  Open <a href="http://192.168.0.241/">http://192.168.0.241</a> in the browser, for the first time use the admin / admin credentials: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/mt/l9/lg/mtl9lgxajgzy671ayddlz4hfuku.jpeg"></a> </p><br><p>  When I logged in, my Grafana was empty, but fortunately, we can get all the necessary dashboards from <strong>grafana.com</strong> .  You need to import panels No. 3649 and 3646. When importing, select the correct data source. </p><br><p>  After that, monitor the use of resources of nodes and hearths and, of course, create your own unique dashboard. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/vp/nm/9a/vpnm9awb7sfgn5pv-0qo4-srzxu.jpeg"></a> <br> <a href=""><img src="https://habrastorage.org/webt/1i/pr/yi/1ipryi2agtmgqfm2kwzylfsteay.jpeg"></a> </p><br><p>  Well, on it we will finish with monitoring now;  The following elements that we may need are the logs of the storage of our applications and cluster.  There are several ways to do this, and they are all described in the Kubernetes <a href="https://kubernetes.io/docs/concepts/cluster-administration/logging/">documentation</a> .  Based on my own experience, I prefer to use external installations of the Elasticsearch and Kibana services, as well as only the registration agents that run on each Kubernetes work node.  This will protect the cluster from overloads associated with a large number of logs and other problems, and will allow you to receive logs, even if the cluster becomes completely non-functional. </p><br><p>  The most popular stack for collecting logs for Kubernetes fans is Elasticsearch, Fluentd and Kibana (EFK stack).  In this example, we will run Elasticsearch and Kibana on the external node (you can use the existing ELK stack), and also Fluentd inside our cluster as a daemonset for each node as a log collection agent. </p><br><p>  I‚Äôll skip the part about creating a VM with Elasticsearch and Kibana;  This is quite a popular topic, so you can find a lot of materials on how best to do it.  For example, in my own <a href="https://medium.com/devopslinks/nginx-logs-monitoring-using-elk-stack-docker-4b64f46e989">article</a> .  Simply remove the fragment of the <strong>logstash</strong> configuration from the <strong>docker-compose.yml file</strong> , and also remove 127.0.0.1 from the ports section of elasticsearch. </p><br><p>  After that, you should have a working elasticsearch connected to the VM-IP port: 9200.  For additional security, configure login: pass or security keys between fluentd and elasticsearch.  However, I often protect them simply by using iptables rules. </p><br><p>  All that is left to do is to create a fluentd daemonset in Kubernetes and specify the external address of the elasticsearch <strong>node: port</strong> in the configuration. </p><br><p>  We use the official Kubernetes supplement with the yaml configuration <a href="https://github.com/kubernetes/kubernetes/tree/master/cluster/addons/fluentd-elasticsearch">from here</a> , with a few modifications: </p><br><pre> <code class="plaintext hljs">control# vi fluentd-es-ds.yaml apiVersion: v1 kind: ServiceAccount metadata: name: fluentd-es namespace: kube-system labels: k8s-app: fluentd-es kubernetes.io/cluster-service: "true" addonmanager.kubernetes.io/mode: Reconcile --- kind: ClusterRole apiVersion: rbac.authorization.k8s.io/v1 metadata: name: fluentd-es labels: k8s-app: fluentd-es kubernetes.io/cluster-service: "true" addonmanager.kubernetes.io/mode: Reconcile rules: - apiGroups: - "" resources: - "namespaces" - "pods" verbs: - "get" - "watch" - "list" --- kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: fluentd-es labels: k8s-app: fluentd-es kubernetes.io/cluster-service: "true" addonmanager.kubernetes.io/mode: Reconcile subjects: - kind: ServiceAccount name: fluentd-es namespace: kube-system apiGroup: "" roleRef: kind: ClusterRole name: fluentd-es apiGroup: "" --- apiVersion: apps/v1 kind: DaemonSet metadata: name: fluentd-es-v2.4.0 namespace: kube-system labels: k8s-app: fluentd-es version: v2.4.0 kubernetes.io/cluster-service: "true" addonmanager.kubernetes.io/mode: Reconcile spec: selector: matchLabels: k8s-app: fluentd-es version: v2.4.0 template: metadata: labels: k8s-app: fluentd-es kubernetes.io/cluster-service: "true" version: v2.4.0 # This annotation ensures that fluentd does not get evicted if the node # supports critical pod annotation based priority scheme. # Note that this does not guarantee admission on the nodes (#40573). annotations: scheduler.alpha.kubernetes.io/critical-pod: '' seccomp.security.alpha.kubernetes.io/pod: 'docker/default' spec: priorityClassName: system-node-critical serviceAccountName: fluentd-es containers: - name: fluentd-es image: k8s.gcr.io/fluentd-elasticsearch:v2.4.0 env: - name: FLUENTD_ARGS value: --no-supervisor -q resources: limits: memory: 500Mi requests: cpu: 100m memory: 200Mi volumeMounts: - name: varlog mountPath: /var/log - name: varlibdockercontainers mountPath: /var/lib/docker/containers readOnly: true - name: config-volume mountPath: /etc/fluent/config.d terminationGracePeriodSeconds: 30 volumes: - name: varlog hostPath: path: /var/log - name: varlibdockercontainers hostPath: path: /var/lib/docker/containers - name: config-volume configMap: name: fluentd-es-config-v0.2.0</code> </pre> <br><p>  Then we make a specific configuration of fluentd: </p><br><pre> <code class="plaintext hljs">control# vi fluentd-es-configmap.yaml kind: ConfigMap apiVersion: v1 metadata: name: fluentd-es-config-v0.2.0 namespace: kube-system labels: addonmanager.kubernetes.io/mode: Reconcile data: system.conf: |- &lt;system&gt; root_dir /tmp/fluentd-buffers/ &lt;/system&gt; containers.input.conf: |-</code> </pre> <br><pre> <code class="plaintext hljs"> @id fluentd-containers.log @type tail path /var/log/containers/*.log pos_file /var/log/es-containers.log.pos tag raw.kubernetes.* read_from_head true &lt;parse&gt; @type multi_format &lt;pattern&gt; format json time_key time time_format %Y-%m-%dT%H:%M:%S.%NZ &lt;/pattern&gt; &lt;pattern&gt; format /^(?&lt;time&gt;.+) (?&lt;stream&gt;stdout|stderr) [^ ]* (?&lt;log&gt;.*)$/ time_format %Y-%m-%dT%H:%M:%S.%N%:z &lt;/pattern&gt; &lt;/parse&gt;</code> </pre> <br><pre> <code class="plaintext hljs"># Detect exceptions in the log output and forward them as one log entry. &lt;match raw.kubernetes.**&gt; @id raw.kubernetes @type detect_exceptions remove_tag_prefix raw message log stream stream multiline_flush_interval 5 max_bytes 500000 max_lines 1000 &lt;/match&gt; # Concatenate multi-line logs &lt;filter **&gt; @id filter_concat @type concat key message multiline_end_regexp /\n$/ separator "" &lt;/filter&gt; # Enriches records with Kubernetes metadata &lt;filter kubernetes.**&gt; @id filter_kubernetes_metadata @type kubernetes_metadata &lt;/filter&gt; # Fixes json fields in Elasticsearch &lt;filter kubernetes.**&gt; @id filter_parser @type parser key_name log reserve_data true remove_key_name_field true &lt;parse&gt; @type multi_format &lt;pattern&gt; format json &lt;/pattern&gt; &lt;pattern&gt; format none &lt;/pattern&gt; &lt;/parse&gt; &lt;/filter&gt; output.conf: |- &lt;match **&gt; @id elasticsearch @type elasticsearch @log_level info type_name _doc include_tag_key true host 192.168.1.253 port 9200 logstash_format true &lt;buffer&gt; @type file path /var/log/fluentd-buffers/kubernetes.system.buffer flush_mode interval retry_type exponential_backoff flush_thread_count 2 flush_interval 5s retry_forever retry_max_interval 30 chunk_limit_size 2M queue_limit_length 8 overflow_action block &lt;/buffer&gt; &lt;/match&gt;</code> </pre> <br><p>  The configuration is elementary, but it is quite enough for a quick launch;  it will collect system and application logs.  If you need something more complicated, you can read the official documentation about fluentd plugins and Kubernetes configurations. </p><br><p>  Now let's create a fluentd daemonset in our cluster: </p><br><pre> <code class="plaintext hljs">control# kubectl create -f fluentd-es-ds.yaml serviceaccount/fluentd-es created clusterrole.rbac.authorization.k8s.io/fluentd-es created clusterrolebinding.rbac.authorization.k8s.io/fluentd-es created daemonset.apps/fluentd-es-v2.4.0 created control# kubectl create -f fluentd-es-configmap.yaml configmap/fluentd-es-config-v0.2.0 created</code> </pre> <br><p>  Make sure that all fluentd and other resources are successfully launched, then open Kibana.  In Kibana, find and add a new index from fluentd.  If you find something, then everything is done correctly, if not - check the previous steps and re-create the daemonset or edit the configmap: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/zg/o_/og/zgo_ogau6dqddp69ffnqxtvzhwi.jpeg"></a> <br> <a href=""><img src="https://habrastorage.org/webt/cr/wj/fa/crwjfahq7fsbizu40xvf8_7xf90.jpeg"></a> </p><br><p>  Great, now that we get logs from the cluster, you can create any dashboard.  Of course, the configuration is the simplest, so it should probably be changed for you.  The main goal was to show how this is done. </p><br><p>  After completing all the previous steps, we got a really good Kubernetes cluster ready for work.  It's time to put some test application into it and see what happens. </p><br><p>  For this example, let's take my small Python / Flask Kubyk application, which already has a Docker container, so take it from the open docker registry.  Now we will add an external database file to this application - for this we use the configured GlusterFS repository. </p><br><p>  First, create a new <strong>pvc</strong> volume (permanent volume request) for this application, where we will store the <a href="https://www.sqlite.org/">SQLite</a> database with user credentials.  You can use the previously created memory class from part 2 of this manual. </p><br><pre> <code class="plaintext hljs">control# mkdir kubyk &amp;&amp; cd kubyk control# vi kubyk-pvc.yaml kind: PersistentVolumeClaim apiVersion: v1 metadata: name: kubyk annotations: volume.beta.kubernetes.io/storage-class: "slow" spec: accessModes: - ReadWriteOnce resources: requests: storage: 1Gi control# kubectl create -f kubyk-pvc.yaml</code> </pre> <br><p>  Having created a new PVC for the application, we are ready to deploy. </p><br><pre> <code class="plaintext hljs">control# vi kubyk-deploy.yaml apiVersion: apps/v1 kind: Deployment metadata: name: kubyk-deployment spec: selector: matchLabels: app: kubyk replicas: 1 template: metadata: labels: app: kubyk spec: containers: - name: kubyk image: ratibor78/kubyk ports: - containerPort: 80 volumeMounts: - name: kubyk-db mountPath: /kubyk/sqlite volumes: - name: kubyk-db persistentVolumeClaim: claimName: kubyk control# vi kubyk-service.yaml apiVersion: v1 kind: Service metadata: name: kubyk spec: type: LoadBalancer selector: app: kubyk ports: - port: 80 name: http</code> </pre> <br><p>  Now, let's create the deployment and service: </p><br><pre> <code class="plaintext hljs">control# kubectl create -f kubyk-deploy.yaml deployment.apps/kubyk-deployment created control# kubectl create -f kubyk-service.yaml service/kubyk created</code> </pre> <br><p>  Check the new IP address assigned to the service, as well as the status of the submission: </p><br><pre> <code class="plaintext hljs">control# kubectl get po NAME READY STATUS RESTARTS AGE glusterfs-2wxk7 1/1 Running 1 2d1h glusterfs-5dtdj 1/1 Running 1 41d glusterfs-zqxwt 1/1 Running 0 2d1h heketi-b8c5f6554-f92rn 1/1 Running 0 8d kubyk-deployment-75d5447d46-jrttp 1/1 Running 0 11s control# kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE ... some text.. kubyk LoadBalancer 10.109.105.224 192.168.0.242 80:32384/TCP 10s</code> </pre> <br><p>  So, it seems that we have successfully launched a new application;  If we open the browser's IP address <a href="http://192.168.0.242/">http://192.168.0.242</a> , we should see the login page of this application.  You can use the admin / admin credentials to log in to the system, but if we try to log in at this stage, we will get an error, because there is no available database yet. </p><br><p>  Here is an example of a log error message from the pod on the Kubernetes dashboard: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/st/7c/ne/st7cnedlbkybwhj2k_7v3xviiia.jpeg"></a> </p><br><p>  To fix this, you need to copy the SQlite DB file from my git repository to the previously created pvc volume.  The application will start using this database. </p><br><pre> <code class="plaintext hljs">control# git pull https://github.com/ratibor78/kubyk.git control# kubectl cp ./kubyk/sqlite/database.db kubyk-deployment-75d5447d46-jrttp:/kubyk/sqlite</code> </pre> <br><p>  We use the <strong>kubectl cp</strong> command from under the application to copy this file into the volume. <br>  You must also give the nginx user access to this directory with write access;  My application is launched through the user nginx using <a href="">supervisord</a> . </p><br><pre> <code class="plaintext hljs">control# kubectl exec -ti kubyk-deployment-75d5447d46-jrttp -- chown -R nginx:nginx /kubyk/sqlite/</code> </pre> <br><p>  Try to log in again: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/79/jt/u_/79jtu_nd4nmednpk1nb2ycys9ss.jpeg"></a> </p><br><p>  Great, now our application works correctly, and we can scale kubyk <strong>deploy</strong> to 3 replicas, for example, to put one copy of the application in one working node.  Since we previously created a pvc volume, all our scams with application replicas will use the same database, and the service will thus distribute the traffic between replicas in a round-robin fashion. </p><br><pre> <code class="plaintext hljs">control# kubectl get deployments NAME READY UP-TO-DATE AVAILABLE AGE heketi 1/1 1 1 39d kubyk-deployment 1/1 1 1 4h5m control# kubectl scale deployments kubyk-deployment --replicas=3 deployment.extensions/kubyk-deployment scaled control# kubectl get po NAME READY STATUS RESTARTS AGE glusterfs-2wxk7 1/1 Running 1 2d5h glusterfs-5dtdj 1/1 Running 21 41d glusterfs-zqxwt 1/1 Running 0 2d5h heketi-b8c5f6554-f92rn 1/1 Running 0 8d kubyk-deployment-75d5447d46-bdnqx 1/1 Running 0 26s kubyk-deployment-75d5447d46-jrttp 1/1 Running 0 4h7m kubyk-deployment-75d5447d46-wz9xz 1/1 Running 0 26s</code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/oq/3l/6k/oq3l6kxibffrw5_gwa1d5edarh8.jpeg"></a> </p><br><p>  Now we have application replicas for each working node, so the application, if it loses some nodes, will not stop working.  In addition, we get a simple way to load balance, as I said earlier.  Not bad for a start. </p><br><p>  Let's create a new user in our application: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/94/d4/a1/94d4a1414x2ksjt9c8qzzxd_szw.jpeg"></a> <br> <a href=""><img src="https://habrastorage.org/webt/rz/sl/pc/rzslpcgucf593ooo2cetibyfdra.jpeg"></a> </p><br><p>  All new requests will be processed in the following list.  This can be checked on the logs of the hearth.  For example, a new user is created by the application in one subsea, then the next one responds to the next request, and so on.  Since this application uses a single persistent volume to store the database, all data will be safe even if all replicas are lost. </p><br><p>  In large and complex applications, you will need not just a designated volume for the database, but various volumes to accommodate permanent information and many other elements. </p><br><p>  Well, we are almost done.  You can add many more aspects, because Kubernetes is a voluminous topic and it is developing dynamically, but we will stop at this.  The main purpose of this series of articles was to show how to create your own Kubernetes cluster, and I hope this information was useful to you. </p><br><h3 id="p-s">  PS </h3><br><p>  Stability check and stress tests, of course. </p><br><p>  The cluster scheme from our example works without 2 working nodes, 1 master node and 1 etcd node.  If you want to - disable them and check whether the test application will function. </p><br><p>  By compiling these guides, I prepared a cluster of a nearly analogous scheme for production.  Once, having created a cluster and having appended it, I ran into a major power failure;  absolutely all the servers of the cluster were crashed - a lively nightmare of the system administrator.  Some servers shut down for a long time, and after they have file system errors.  But the restart surprised me a lot: the Kubernetes cluster was fully recovered.  All volumes of GlusterFS and Deploy were launched.  As for me, this is a demonstration of the great potential of this technology. </p><br><p>  All the best and hopefully see you soon! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/443658/">https://habr.com/ru/post/443658/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443644/index.html">We roll eggs together with Unity</a></li>
<li><a href="../443648/index.html">User documentation: what makes it bad, and how to fix it</a></li>
<li><a href="../443650/index.html">So-So-So and no Tika. What is the difference between Intel Core processors of different generations based on the same architecture?</a></li>
<li><a href="../443652/index.html">Every day by Outlook I have just flour ...</a></li>
<li><a href="../443654/index.html">In the wake of calculators: Qalculate</a></li>
<li><a href="../443660/index.html">Experts: "3D-scanner will cost 10 times cheaper than the error in the traditional quality control"</a></li>
<li><a href="../443662/index.html">Understanding Clean Code in Android</a></li>
<li><a href="../443664/index.html">Weather Station Arduino</a></li>
<li><a href="../443666/index.html">Our approach to coloring the flow</a></li>
<li><a href="../443670/index.html">Error in new version of Google Chrome (73.0.3683.75)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>