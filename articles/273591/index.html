<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pro workflow organization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 
 In this article, we will describe how the development process of the 1C: Enterprise platform is built, how we work on quality assurance, a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pro workflow organization</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br>  In this article, we will describe how the development process of the 1C: Enterprise platform is built, how we work on quality assurance, and share the lessons we have gained by creating one of the largest Russian software systems. <br><br><a name="habracut"></a><br><h3>  People and processes </h3><br>  The platform employs several groups of up to 10 programmers each, three-quarters of which are written in C ++, and the rest in Java and JavaScript. <br>  Each group works on a separate direction of development, for example: <br><ul><li>  Development Tools (Configurator) </li><li>  Web client </li><li>  Server infrastructure and failover cluster </li><li>  etc. </li></ul><br>  Total groups more than a dozen.  Separately, there is a quality assurance team. <br>  Of course, on a project of this size (more than 10 million lines of code) we are not talking about general ownership of the code, it‚Äôs impossible to keep such a volume in mind.  We are trying to move towards ensuring the ‚Äú <a href="https://ru.wikipedia.org/wiki/Bus_factor">bus factor</a> ‚Äù in a group of at least two. <br>  We try to maintain a balance between the independence of teams, which gives flexibility and increases the speed of development, and homogeneity, allowing teams to effectively interact with each other and the outside world.  So, we have a common version control system, build server and task tracker (we‚Äôll talk about them below), as well as the C ++ coding standard, design documentation templates, error handling rules from users and some other aspects.  The rules that all teams must comply with are developed and adopted by a common decision of the team leaders. <br><br>  On the other hand, in the practices that are directed ‚Äúinward‚Äù, the commands are quite autonomous.  For example, code inspections are now applied in all teams (and there are general rules defining the obligatory passage of a review), but they were implemented at different times and the process is structured according to different rules. <br>  The same applies to the organization of the process - someone practicing Agile options, someone using other styles of project management.  There seems to be no canonical SCRUM anywhere ‚Äî the specifics of the boxed product imposes its limitations.  For example, the wonderful practice of demonstration is not applicable unchanged.  Other practices, for example, the role of Product Owner, have our own counterparts.  As the Product Owner in its direction is usually the team leader.  In addition to technical leadership in the team, one of its most important tasks is to determine the future directions of development.  The process of developing a strategy and tactics for the development of a platform is a complex and interesting topic, to which we will devote a separate article. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Work on tasks </h4><br>  When a decision is made on the implementation of a particular functional, its appearance is determined in a series of discussions involving, at a minimum, the developer responsible for the task and the team leader.  Often, other team members or staff from other groups are involved with the necessary expertise.  The final version is approved by the management of the development of the 1C: Enterprise platform. <br><br>  In such discussions decisions are made: <br><ul><li>  what is included and what is not included in the scope of the task </li><li>  what we imagine usage scenarios.  It is even more important to understand which possible scenarios we will not support. </li><li>  what the user interfaces will look like </li><li>  what the API for the application developer will look like </li><li>  how the new mechanism will be combined with existing ones </li><li>  what will happen to security </li><li>  etc. </li></ul><br>  In addition, recently we are trying to discuss the problem with a wider range of potential consumers - for example, at the last <a href="http://habrahabr.ru/company/1c/blog/267877/">open seminar</a> we talked about the new possibilities for working with binary data that were in the process of designing, answered the questions and managed to pick out several possible applications from the discussion, who have not thought before. <br><br>  When you start working on a new function, a task is created for it in the task tracker.  The tracker, by the way, is written in "1C: Enterprise" and is artlessly called the "Task Base".  For each task in the task tracker is stored a project document - in fact, the specification for the task.  It consists of three main parts: <br><ul><li>  Problem analysis and solutions </li><li>  Description of the selected solution </li><li>  Descriptions of technical implementation details </li></ul><br>  Preparation of the project document may begin before implementation, and may start later, if for the task some research or prototype is done first.  In any case, this iterative process, unlike the waterfall model, the development and refinement of the project document is done in parallel with the implementation.  The main thing is that by the time when the task is ready, the project document has been approved in detail.  And there may be many such details, for example: <br><ul><li>  The unity of the terms used.  If the term ‚Äúwrite‚Äù was used in one place of the Platform in a similar situation, then the use of ‚Äúsave‚Äù should be very seriously justified. </li><li>  Unity of approaches.  Sometimes, in order to simplify learning and a common experience of use, old approaches have to be repeated in new tasks, even if their disadvantages are obvious. </li><li>  Compatibility.  In cases where the old behavior can not be saved, you still need to think about compatibility.  It often happens that application solutions can be tied to an error and a drastic change will lead to inoperability on the side of end users.  Therefore, we often leave the old behavior "in compatibility mode".  Existing configurations running on a new release of the platform will use the ‚Äúcompatibility mode‚Äù until a conscious decision is made by the developer to disable it. </li></ul><br>  In addition, the draft teaches the discussion of the problem, so that later it can be understood why certain options were adopted or rejected. <br>  After the project is approved and the developer has implemented a new feature in the task branch (feature branch) in SVN (and when developing a new IDE - in Git), the task is inspected by code and manually checked by other team members.  In addition, automatic tests are run on the task branch, which are described below.  At the same stage, another technical document is created - a task description, which is intended for testers and technical writers.  Unlike the project, the document does not contain technical implementation details, but it is structured in such a way that it helps to quickly understand which sections of the documentation need to be supplemented, whether the new function introduces incompatible changes, etc. <br>  The checked and corrected task joins the main branch of the release and becomes available to the testing group. <br><br><h4>  Lessons and recipes </h4><br><ul><li>  The value of a project document, like any documentation, is not always obvious.  For us, it is as follows: <br><ul><li>  During design, it helps all participants to quickly restore the discussion context and to make sure that the decisions made will not be forgotten or distorted. </li><li>  Later, in doubtful situations, when we are not sure of the correct behavior, the project document helps to remember the decision itself and the motivation that was behind its adoption. </li><li>  The project document serves as a starting point for user documentation.  The developer does not need to write something from scratch or verbally explain to technical writers - there is already a ready basis. </li></ul></li><li>  It is always necessary to describe scenarios for using the created functional, and not with general phrases, but the more detailed, the better.  If this is not done, then decisions can be made that will be either inconvenient or impossible, and the cause may be some small detail.  In Agile-development, such details are easily corrected at the next iteration, and in our case, the fix can reach the user in years (full cycle: until the final version of the platform is released-&gt; configurations are released, using innovations -&gt; feedback from users is collected -&gt; made a fix -&gt; a new version is released -&gt; updated configurations taking into account a fix -&gt; the user will install a new version of the configuration for himself). </li><li>  Even better than scripts, the use of the prototype by real users (configuration developers) before the official release of the version and fixing the behavior helps.  This practice is just beginning to be widely used in our country, and in almost all cases it brought valuable knowledge.  Often this knowledge could not be related to the functional capabilities, but related to non-functional behavioral features (for example, the presence of logging or the ease of diagnosing errors). </li><li>  In the same way, it is necessary to determine in advance the performance criteria and check their implementation.  While these requirements were not added to the checklist when the task was submitted, this was not always done. </li></ul><br><br><h4>  Quality assurance </h4><br>  In general, ‚Äúquality‚Äù and ‚Äúquality assurance‚Äù are very broad terms.  At a minimum, two processes can be distinguished - verification and validation.  Verification is usually understood as conformance of software behavior to specifications and the absence of other obvious errors, and validation as verification of compliance with user needs.  This section focuses on quality assurance in terms of verification. <br><br>  Testers get access to the task after it has been injected, but the quality assurance process starts much earlier.  Recently we had to make significant efforts to improve it, because  it became obvious that the existing mechanisms were not adequately adequate to the increased volume of functionality and noticeably increased complexity.  These efforts, in the opinion of partners about the new version 8.3.6, it seems to us, have already had an effect, but a lot of work, of course, is still ahead. <br>  Existing quality assurance mechanisms can be divided into organizational and technological ones.  Let's start with the last. <br><br><h4>  Tests </h4><br>  When it comes to quality assurance mechanisms, tests immediately come to mind.  Of course, we also use them, and in several versions: <br><br><h5>  Unit tests </h5><br>  In C ++, we write unit tests.  As mentioned in the <a href="http://habrahabr.ru/company/1c/blog/269611/">previous article</a> , we use modified versions of the <a href="https://code.google.com/p/googletest/">Google Test</a> and <a href="https://github.com/google/googlemock">Google Mock</a> .  For example, a typical test that checks the ampersand character escaping ("&amp;") when writing JSON might look like this: <br><pre><code class="cpp hljs">TEST(TestEscaping, EscapeAmpersand) { <span class="hljs-comment"><span class="hljs-comment">// Arrange IFileExPtr file = create_instance&lt;ITempFile&gt;(SCOM_CLSIDOF(TempFile)); JSONWriterSettings settings; settings.escapeAmpersand = true; settings.newLineSymbols = eJSONNewLineSymbolsNone; JSONStreamWriter::Ptr writer = create_json_writer(file, &amp;settings); // Act writer-&gt;writeStartObject(); writer-&gt;writePropertyName(L"_&amp;_Prop"); writer-&gt;writeStringValue(L"_&amp;_Value"); writer-&gt;writeEndObject(); writer-&gt;close(); // Assert std::wstring result = helpers::read_from_file(file); std::wstring expected = std::wstring(L"{\"_\\u0026_Prop\":\"_\\u0026_Value\"}"); ASSERT_EQ(expected, result); }</span></span></code> </pre> <br><br><h5>  Integration tests </h5><br>  The next level of testing is integration tests written in 1C: Enterprise.  They form the main part of our tests.  A typical set of tests is a separate information base stored in a * .dt file.  The test infrastructure loads this database and calls in it a previously known method, which already calls individual tests written by developers, and formats their results so that the CI ( <a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B5%25D0%25BF%25D1%2580%25D0%25B5%25D1%2580%25D1%258B%25D0%25B2%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B5%25D0%25B3%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">Continuous Integration</a> ) infrastructure can interpret them. <br><pre> <code class="1c hljs"><span class="hljs-meta"><span class="hljs-meta">&amp;</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">  __() </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">  = ("json");  = "__";  = .(); JSON = JSON(); JSON(JSON, ); JSON.(); .(, ); </span></span></code> </pre><br>  In this case, if the result of the recording diverges from the standard, an exception will be thrown, which the infrastructure will intercept and interpret as a test failure. <br><br>  Our CI system itself performs these tests for various versions of the OS and DBMS, including 32-bit and 64-bit Windows and Linux, and from the DBMS - MS SQL Server, Oracle, PostgreSQL, IBM DB2, as well as our own file database. <br><br><h5>  Custom test systems </h5><br>  The third and most cumbersome type of tests is the so-called.  "Custom test systems."  They are used when the checked scenario goes beyond the limits of one base on 1C, for example, when testing interaction with external systems through web services.  For each group of tests, one or several virtual machines are allocated, on each of which a special agent program is installed.  Otherwise, the test developer has complete freedom, limited only by the requirement to issue the result as a file in the Google Test format, which can be read by CI. <br><br>  For example, a service written in C # is used to test a SOAP web services client, and a volumetric test framework written in python is used to test various features of the configurator. <br>  The flip side of this freedom is the need to manually configure tests for each OS, manage a fleet of virtual machines and other overhead costs.  Therefore, as our integration tests (described in the previous section) evolve, we plan to limit the use of custom test systems. <br><br>  The above-mentioned tests are written by the platform developers themselves, in C ++ or by creating small configurations (application solutions), sharpened for testing a specific functional.  This is a necessary condition for the absence of errors, but not sufficient, especially in such a system as the 1C: Enterprise platform, where most of the possibilities are not applied (used by the user directly), but serve as the basis for building application programs.  Therefore, there is one more echelon of testing: automated and manual scenario tests on real application solutions.  To the same group can be attributed, and load tests.  This is an interesting and big topic about which we are planning a separate article. <br><br>  In this case, all types of tests are performed on the CI.  <a href="https://en.wikipedia.org/wiki/Jenkins_(software)">Jenkins is</a> used as a continuous integration server.  Here is what it looks like at the time of this writing: <br><img src="https://habrastorage.org/files/f1e/78c/187/f1e78c187466421e92b16e21679f6dd4.png"><br><br>  For each configuration of the assembly (Windows x86 and x64, Linux x86 and x64), their own assembly tasks were started, which are run in parallel on different machines.  Building one configuration takes a long time - even on powerful hardware, compiling and linking large volumes of C ++ is not an easy task.  In addition, the creation of packages for Linux (deb and rpm), as it turned out, takes time comparable to compilation. <br>  Therefore, during the day, the ‚Äúshortened build‚Äù works, which checks compilability under Windows x86 and Linux x64 and performs a minimal set of tests, and the regular build runs every night, collecting all the configurations and running all the tests.  Each assembled and tested nightly assembly is marked with a tag - so that the developer, creating a branch for the task or infusing changes from the main branch, was sure to work with a compiled and workable copy.  Now we are working to ensure that the regular build runs more often and includes more tests.  The ultimate goal of this work is to detect an error with tests (if it can be detected by tests) for no more than two hours after the commit, so that the error found is corrected before the end of the working day.  Such a reaction time dramatically increases efficiency: firstly, the developer himself does not need to restore the context with which he worked while introducing an error, secondly, there is less chance that the error will block someone else‚Äôs work. <br><br><h3>  Static and dynamic analysis </h3><br>  But man does not live by tests alone!  We also use static code analysis, which has proven its effectiveness over many years.  Once a week there is at least one mistake, and often there is one that surface testing would not catch. <br>  We use three different analyzers: <br><ul><li>  Cppcheck </li><li>  PVS-Studio </li><li>  Built in Microsoft Visual Studio </li></ul><br>  They all work a little differently, find different types of errors and we like how they complement each other. <br><br>  In addition to static tools, we also check the system behavior at runtime using the <a href="http://clang.llvm.org/docs/AddressSanitizer.html">Address Sanitizer</a> tools (part of the CLang project) and <a href="http://valgrind.org/">Valgrind</a> . <br>  These two very different methods of operation are used approximately for the same thing - searching for situations of incorrect memory handling, for example <br><ul><li>  uninitialized memory accesses </li><li>  recourse to freed memory </li><li>  overruns of an array, etc. </li></ul><br>  Several times the dynamic analysis found errors that had been trying to investigate for a long time manually.  This served as a stimulus for organizing the automated periodic launch of some groups of tests with dynamic analysis enabled.  Constantly using dynamic analysis for all groups of tests does not allow for performance limitations - when using Memory Sanitizer, performance decreases by about 3 times, and when using Valgrind - by 1-2 orders of magnitude!  But even their limited use yields quite good results. <br><br><h3>  Organizational quality assurance measures </h3><br>  In addition to the automatic checks performed by the machines, we try to build quality assurance into the daily development process. <br>  The most widely used practice for this is peer code review.  As our experience shows, constant code inspections do not catch specific errors (although this happens periodically), but prevent their occurrence by providing more readable and well-organized code, i.e.  provide quality "in long." <br>  Other goals are pursued by manual testing of each other's work by programmers within the group ‚Äî it turns out that even superficial testing by a person who is not immersed in a task helps to identify errors at an early stage, even before the task is infused into the trunk. <br><br><h4>  <a href="https://en.wikipedia.org/wiki/Eating_your_own_dog_food">Eat your own dogfood</a> </h4><br>  But the most effective of all organizational measures is the approach that at Microsoft is called ‚Äúeat your own dogfood‚Äù, in which product developers are its first users.  In our case, the ‚Äúproduct‚Äù is our task tracker (the ‚ÄúTask Database‚Äù mentioned above), with which the developer works during the day.  Every day, this configuration is transferred to the latest version of the platform compiled on the CI, and all the shortcomings and shortcomings immediately affect their authors. <br>  I would like to emphasize that the ‚ÄúTask Database‚Äù is a serious information system that stores information about tens of thousands of tasks and errors, and the number of users exceeds a hundred.  This is not comparable with <a href="http://v8.1c.ru/applied-solutions/top500.jsp">the largest implementations of 1C: Enterprise</a> , but is quite comparable with a medium-sized firm.  Of course, not all mechanisms can be checked in this way (for example, the accounting subsystem is not involved), but in order to increase the coverage of the functional being tested, it is agreed that different groups of developers use different connection methods, for example, someone uses a web client. , someone thin client on Windows, and someone on Linux.  In addition, several instances of the task database server are used, operating in different configurations (different versions, different operating systems, etc.), which are synchronized with each other using the mechanisms included in the platform. <br>  In addition to the Task Base, there are other ‚Äúexperimental‚Äù bases, but less functional and less loaded. <br><br><h4>  Lessons learned </h4><br>  The development of the quality assurance system will continue (and indeed, it is hardly ever possible to put an end to this path), and now we are ready to share some conclusions: <br><ul><li>  In such a large and massively used product it is cheaper to write a test than not to write.  If there is an error in the functionality and it will be missed - the costs for end users, partners, support services and even one development department associated with reproducing, correcting and then checking the error will be much more. </li><li>  Even if writing automated tests is difficult, you can ask the developer to prepare a formalized description of the manual tests.  After reading it, it will be possible to find lacunae in the way the developer checked his brainchild, and thus potential errors. </li><li>  Creating an infrastructure for CI and tests is a costly business, both in finance and in time.  Especially if you have to do this for an already mature project.  So start as early as possible! </li></ul><br><br>  And one more conclusion, which does not follow directly from the articles, but will serve as an announcement of the following: the best testing framework is the testing of the application built on it.  But how we test the Platform using application solutions, such as 1C: Accounting, we will tell in one of the following articles. </div><p>Source: <a href="https://habr.com/ru/post/273591/">https://habr.com/ru/post/273591/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273579/index.html">History 30 places in the final Russian AI Cup 2015</a></li>
<li><a href="../273581/index.html">Handlebars. Guide to action</a></li>
<li><a href="../273583/index.html">How the Airbnb engineering team ‚Äúcrashed‚Äù the main project database in a couple of weeks</a></li>
<li><a href="../273585/index.html">Parallelizing the Strassen Algorithm on Intel¬Æ Xeon Phi (TM)</a></li>
<li><a href="../273589/index.html">Custom EditText with three buttons on the right</a></li>
<li><a href="../273593/index.html">ACS: from sadness to joy. History of Russian Automation</a></li>
<li><a href="../273595/index.html">How we unpacked the game automated</a></li>
<li><a href="../273597/index.html">"Countdown by simple means - or the rule" 3-2-1 "for disk storages"</a></li>
<li><a href="../273599/index.html">Capital Projects: from idea to specifications and drawings</a></li>
<li><a href="../273601/index.html">Stephen Wolfram‚Äôs Book An Elementary Introduction to the Wolfram Language</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>