<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>[PF] Print PDF under .NET, vector approach, practice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As promised, I continue the theme ( one , two ) of managed PDF printing from under .NET in vector format. I talked about the theoretical aspects of wo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>[PF] Print PDF under .NET, vector approach, practice</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/b93/19a/868/b9319a86896f45a6aa0c801cd613a029.jpg"></div><br>  As promised, I continue the theme ( <a href="https://habrahabr.ru/company/tcsbank/blog/279361/">one</a> , <a href="https://habrahabr.ru/company/tcsbank/blog/283278/">two</a> ) of managed PDF printing from under .NET in <b>vector</b> format.  I talked about the theoretical aspects of working with PCL in a <a href="https://habrahabr.ru/company/tcsbank/blog/283278/">previous article</a> , it‚Äôs time to parse the program for printing a PDF file in a vector to a printer.  Our application will be useful, for example, when you need to print a pack of multipage forms or questionnaires on paper of different colors and different densities.  If we learn <b>to manage the trays of the printer</b> , we will save ourselves from manually laying pages;) The template will contain the number of the tray from which the printer will take the paper for the current page.  Moreover, the template will be applied to the document cyclically: if there are 32 pages in the document and 4 in the template, then the template will repeat 8 times for the Simplex mode and 4 times for Duplex. <a name="habracut"></a><br><br>  Let me remind you the <a href="https://habrahabr.ru/company/tcsbank/blog/283278/">procedure</a> : <br><ul><li>  convert PDF to PCL; </li><li>  modify PCL by pattern; </li><li>  send PCL byte stream to printer. </li></ul><br>  From the dependencies, the application will only have <a href="https://ghostscriptnet.codeplex.com/">Ghostscript.NET</a> , with which we will convert PDF to PCL.  What is Ghostscript.NET and how to use it can be <a href="https://habrahabr.ru/company/tcsbank/blog/279361/">found in the first article of the</a> cycle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/cdf/e6d/934/cdfe6d9344e9454b8300ddd2cdc81671.jpg"></div><br>  To work with Ghostscript, we will use a wrapper for .NET, which is called Ghostscript.NET.  The .NET wrapper implements the universal GhostscriptProcessor class, which allows using Ghostscript with arbitrary settings.  Create a Pdf2Pcl class with a single ConvertPcl2Pdf method, it accepts the path to the PDF file as input and returns the PCL stream as an array of bytes. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Pdf2Pcl</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertPcl2Pdf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pdfFileName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] rawDocumentData = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gsPipedOutput = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GhostscriptPipedOutput(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> outputPipeHandle = <span class="hljs-string"><span class="hljs-string">"%handle%"</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(gsPipedOutput.ClientHandle).ToString(<span class="hljs-string"><span class="hljs-string">"X2"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> processor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GhostscriptProcessor()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> switches = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(); switches.Add(<span class="hljs-string"><span class="hljs-string">"-dQUIET"</span></span>); switches.Add(<span class="hljs-string"><span class="hljs-string">"-dSAFER"</span></span>); switches.Add(<span class="hljs-string"><span class="hljs-string">"-dBATCH"</span></span>); switches.Add(<span class="hljs-string"><span class="hljs-string">"-dNOPAUSE"</span></span>); switches.Add(<span class="hljs-string"><span class="hljs-string">"-dNOPROMPT"</span></span>); switches.Add(<span class="hljs-string"><span class="hljs-string">"-sDEVICE=pxlmono"</span></span>); switches.Add(<span class="hljs-string"><span class="hljs-string">"-dNumRenderingThreads=20"</span></span>); switches.Add(<span class="hljs-string"><span class="hljs-string">"-o"</span></span> + outputPipeHandle); switches.Add(<span class="hljs-string"><span class="hljs-string">"-f"</span></span>); switches.Add(pdfFileName); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { processor.StartProcessing(switches.ToArray(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GsIoHandler()); rawDocumentData = gsPipedOutput.Data; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { Console.WriteLine(ex.Message); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { gsPipedOutput.Dispose(); gsPipedOutput = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rawDocumentData; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GsIoHandler</span></span> : <span class="hljs-title"><span class="hljs-title">GhostscriptStdIO</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GsIoHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StdIn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count</span></span></span><span class="hljs-function">)</span></span> { input = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Empty; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StdOut</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> output</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(output)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; output = output.Trim(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"GS: {0}"</span></span>,output); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StdError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(error)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; error = error.Trim(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"GS: {0}"</span></span>, error); } } }</code> </pre> <br><br>  The GsIoHandler class is needed solely for displaying messages from GhostScript to the console, it is not required.  Instead of the GsIoHandler object, the second StartProcessing argument can be null. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a30/c5d/776/a30c5d7760644a9c80364ebb34949f0e.png"></div><br>  In the PCl stream that the converter returned to us, we need to find the places where the document pages are declared.  GhostScript generates such ads the same, so you can find the right places on a single template. <br><br>  To describe the template, we define constants: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> SkipTheByte = <span class="hljs-number"><span class="hljs-number">0xff</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> UByte = <span class="hljs-number"><span class="hljs-number">0xc0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> AttrUByte = <span class="hljs-number"><span class="hljs-number">0xf8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> Orientation = <span class="hljs-number"><span class="hljs-number">0x28</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> MediaSize = <span class="hljs-number"><span class="hljs-number">0x25</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> MediaSource = <span class="hljs-number"><span class="hljs-number">0x26</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> SimplexPageMode = <span class="hljs-number"><span class="hljs-number">0x34</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> DuplexPageMode = <span class="hljs-number"><span class="hljs-number">0x35</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> DuplexHorizontalBinding = <span class="hljs-number"><span class="hljs-number">0x00</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> SimplexFrontSide = <span class="hljs-number"><span class="hljs-number">0x00</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> DuplexVerticalBinding = <span class="hljs-number"><span class="hljs-number">0x01</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> BeginPage = <span class="hljs-number"><span class="hljs-number">0x43</span></span>;</code> </pre><br><br>  Some bytes of a pattern can take different values, to exclude them, use the SkipTheByte constant.  Page template will look like: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pagePattern = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] { UByte, SkipTheByte, AttrUByte, Orientation, UByte, SkipTheByte, AttrUByte, MediaSize, UByte, SkipTheByte, AttrUByte, MediaSource, UByte, SkipTheByte, AttrUByte, SimplexPageMode, BeginPage };</code> </pre><br><br>  In the byte stream, this will correspond to the following fragment: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3e4/30f/0e4/3e430f0e430f4aee929845e33cb74f9e.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/fb3/c99/8f3/fb3c998f35844be7ba46b422806bc77e.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/01f/75a/0b4/01f75a0b4d914848b96fdafb083ef48a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/8bd/a17/e06/8bda17e065ad4c8ba6e5e8368f9ec49d.jpg"></div><br><br>  Not the most effective, but rather visual algorithm for searching PatternMatching looks like this: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PatternMatching</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] pattern</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pageShiftLst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; data.Count(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsOnPattern(data, i, pattern)) { pageShiftLst.Add(i); Console.Write(<span class="hljs-string"><span class="hljs-string">"{0:X8} | "</span></span>, i); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; pattern.Count(); j++) { Console.Write(<span class="hljs-string"><span class="hljs-string">"{0:X} "</span></span>, data[i + j]); } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">""</span></span>); i += pattern.Count() - <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pageShiftLst.ToArray(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsOnPattern</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shift, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] pattern</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; pattern.Count() ; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!((shift + i) &lt; data.Count())) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pattern[i] != SkipTheByte) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pattern[i] != data[shift + i]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><br>  The PatternMatching function will return an array of offsets for the pages.  Now you can modify the page on the template, specifying the print mode Duplex / Simplex, and the tray for the current page.  These changes do not change the file size.  We change the values ‚Äã‚Äãof bytes but not their number, so you can not be afraid that subsequent offsets will be irrelevant. <br><br>  To modify the page arguments, you will need offset bytes to be modified relative to the offset of the beginning of the page description.  To do this, we set the corresponding constants: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MediaSourceValueShift = <span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> DuplexBindingShift = <span class="hljs-number"><span class="hljs-number">13</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PageModeShift = <span class="hljs-number"><span class="hljs-number">15</span></span>;</code> </pre><br><br>  Having page offsets in the byte stream and offset bytes to be changed relative to the page offset, you can modify the PCL data stream, for example, by using the following function: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplyPattern</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] pageIndexes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] extraPattern, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isDuplex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; pageIndexes.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pageIndex = pageIndexes[i]; data[pageIndex + PageModeShift] = isDuplex ? DuplexPageMode : SimplexPageMode; data[pageIndex + DuplexBindingShift] = isDuplex ? DuplexVerticalBinding : SimplexFrontSide; data[pageIndex + MediaSourceValueShift] = extraPattern[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data; }</code> </pre><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/279/2d7/5f4/2792d75f4e034739be4cc97c0818a8a3.jpg"></div><br>  .Net has no built-in means for sending a byte array to the printer.  But on <a href="https://support.microsoft.com/en-us/kb/322091">support.microsoft.com there is an example of how to do this</a> .  To be more precise, it describes how to send a string or file as RawData.  An example would suit us if we were working with PostScript, and it doesn‚Äôt work well for sending a PCL data stream.  Let's finish the example so that we can send a byte array to the printer.  For this, you need to add a method to the RawPrinterHelper class: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendRawDataToPrinter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> szPrinterName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> docName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bSuccess = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; IntPtr pUnmanagedBytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntPtr(<span class="hljs-number"><span class="hljs-number">0</span></span>); pUnmanagedBytes = Marshal.AllocCoTaskMem(data.Length); Marshal.Copy(data, <span class="hljs-number"><span class="hljs-number">0</span></span>, pUnmanagedBytes, data.Length); bSuccess = SendBytesToPrinter(szPrinterName, pUnmanagedBytes, data.Length, docName); Marshal.FreeCoTaskMem(pUnmanagedBytes); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bSuccess; }</code> </pre><br><br>  The printer name szPrinterName can be obtained by standard means through the class PrinterSettings.InstalledPrinters.  The docName argument contains the name that will be displayed in the print queue. <br><br>  We have sorted out the main points of the program for printing PDF documents in a pattern that will be 100% efficient on modern HP printers.  For printers from other manufacturers it is better to look into the documentation for PCL support.  But as many manufacturers now embed a PCL processor, problems are unlikely to arise.  If PCL doesn‚Äôt work on typing, then for this case we have the approach described in the <a href="https://habrahabr.ru/company/tcsbank/blog/279361/">first article of the</a> cycle. <br><br>  Describing in detail the key points, while deliberately omitted some of the details, since they have no direct relationship to the topic.  However, without them, the application does not take off, so I will give the full source of the console program.  It is far from perfect (although it copes with its task), since it was developed only to test the idea: <br><br><div class="spoiler">  <b class="spoiler_title">Program.cs</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Drawing.Printing; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">PCL_processing</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> SkipTheByte = <span class="hljs-number"><span class="hljs-number">0xff</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 0xfc - 0xff Reserved for future use. private const byte UByte = 0xc0; private const byte AttrUByte = 0xf8; private const byte Orientation = 0x28; private const byte MediaSize = 0x25; private const byte MediaSource = 0x26; private const byte SimplexPageMode = 0x34; private const byte DuplexPageMode = 0x35; private const byte DuplexHorizontalBinding = 0x00; private const byte SimplexFrontSide = 0x00; private const byte DuplexVerticalBinding = 0x01; private const byte BeginPage = 0x43; private const int MediaSourceValueShift = 9; private const int DuplexBindingShift = 13; private const int PageModeShift = 15; static void Main(string[] args) { var pagePattern = new byte[] { UByte, SkipTheByte, AttrUByte, Orientation, UByte, SkipTheByte, AttrUByte, MediaSize, UByte, SkipTheByte, AttrUByte, MediaSource, UByte, SkipTheByte, AttrUByte, SimplexPageMode, BeginPage }; var fileName = ""; if (!args.Any()) { while (true) { Console.WriteLine("Please write pdf file name:"); fileName = Console.ReadLine(); if (string.IsNullOrWhiteSpace(fileName)) { Console.WriteLine("You have wrote empty string"); continue; } break; } } else { fileName = args[0]; } if (!File.Exists(fileName)) { Console.WriteLine("File \"{0}\" not found", fileName); return; } var data = Pdf2Pcl.ConvertPcl2Pdf(fileName); var pageIndexes = PatternMatching(data, pagePattern); Console.WriteLine("Found {0} pages", pageIndexes.Length); var printPattern = GetSourecPattern(); var isDuplex = Menu(new[] {"Simplex", "Duplex"}, "Selec mode:") &gt; 0; var extraPattern = ExtractPattern(printPattern, pageIndexes.Length, isDuplex); data = ApplyPattern(data, pageIndexes, extraPattern, isDuplex); for (int i = 0; i &lt; pageIndexes.Length; i++) { Console.Write("{0:X8} | ", pageIndexes[i]); for (var j = 0; j &lt; pagePattern.Count(); j++) { Console.Write("{0:X} ", data[pageIndexes[i] + j]); } Console.WriteLine(""); } var printer = GetPrinter(); RawPrinter.SendRawDataToPrinter(printer, data, fileName); Console.WriteLine("*** DONE ***"); Console.ReadLine(); } static byte[] ApplyPattern(byte[] data, int[] pageIndexes, byte[] extraPattern, bool isDuplex) { for (int i = 0; i &lt; pageIndexes.Length; i++) { var pageIndex = pageIndexes[i]; data[pageIndex + PageModeShift] = isDuplex ? DuplexPageMode : SimplexPageMode; data[pageIndex + DuplexBindingShift] = isDuplex ? DuplexVerticalBinding : SimplexFrontSide; data[pageIndex + MediaSourceValueShift] = extraPattern[i]; } return data; } static int[] PatternMatching(byte[] data, byte[] pattern) { var pageShiftLst = new List&lt;int&gt;(); for (var i = 0; i &lt; data.Count(); i++) { if (IsOnPattern(data, i, pattern)) { pageShiftLst.Add(i); Console.Write("{0:X8} | ", i); for (var j = 0; j &lt; pattern.Count(); j++) { Console.Write("{0:X} ", data[i + j]); } Console.WriteLine(""); i += pattern.Count() - 1; } } return pageShiftLst.ToArray(); } static bool IsOnPattern(byte[] data, int shift, byte[] pattern) { for (var i = 0; i &lt; pattern.Count() ; i++) { if (!((shift + i) &lt; data.Count())) return false; if (pattern[i] != SkipTheByte) { if (pattern[i] != data[shift + i]) { return false; } } } return true; } private static byte[] ExtractPattern(int[] pattern, int pageCount, bool isDublex) { var srcPoint = 0; var expandedPattern = new List&lt;byte&gt;(); for (var pageNumber = 0; pageNumber &lt; pageCount; pageNumber++) { // expand-pattern expandedPattern.Add((byte)pattern[srcPoint]); if (isDublex) { if (pageNumber % 2 != 0) { srcPoint++; } } else { srcPoint++; } srcPoint = srcPoint &lt; pattern.Count() ? srcPoint : 0; } return expandedPattern.ToArray(); } private static int[] GetSourecPattern() { var bindingsFile = "source-bindings.kv"; var patternsFile = "patterns.csv"; var Bindings = GetBindings(bindingsFile); var Patterns = GetPatterns(patternsFile, Bindings); var patternindex = Menu(Patterns.Keys.ToArray(), "Please select pattern:"); var pattern = Patterns.ElementAt(patternindex).Value; var srcPattern = pattern.Select(i =&gt; Bindings[i]).ToList(); return srcPattern.ToArray(); } private static int Menu(string[] items, string message) { var selectedIndex = -1; while (true) { Console.WriteLine(message); for (int i = 0; i &lt; items.Length; i++) { Console.WriteLine("[{0}] -- \"{1}\"", i, items[i]); } var str = Console.ReadLine(); if (Int32.TryParse(str, out selectedIndex)) { if (selectedIndex &gt;= 0 &amp;&amp; selectedIndex &lt; items.Length) { break; } } } return selectedIndex; } private static Dictionary&lt;int, int&gt; GetBindings(string fileName) { if (!File.Exists(fileName)) { Console.WriteLine("    \"{0}\"", fileName); return new Dictionary&lt;int, int&gt;(); } var res = new Dictionary&lt;int, int&gt;(); var lines = File.ReadAllLines(fileName, Encoding.Default); foreach (var line in lines) { var kv = line.Split('='); if (kv.Count() != 2) { Console.WriteLine("   : \"{0}\"", line); return new Dictionary&lt;int, int&gt;(); } int k = 0; int v = 0; if (!int.TryParse(kv[0], out k)) { Console.WriteLine("     : \"{0}\"", line); return new Dictionary&lt;int, int&gt;(); } if (!int.TryParse(kv[1], out v)) { Console.WriteLine("     : \"{0}\"", line); return new Dictionary&lt;int, int&gt;(); } res[k] = v; } return res; } private static Dictionary&lt;string, int[]&gt; GetPatterns(string fileName, Dictionary&lt;int, int&gt; bindings) { if (!File.Exists(fileName)) { Console.WriteLine("    \"{0}\"", fileName); return new Dictionary&lt;string, int[]&gt;(); } var lines = File.ReadAllLines(fileName, Encoding.Default); var res = new Dictionary&lt;string, int[]&gt;(); foreach (var line in lines) { var splt = line.Split(';'); if (!splt.Any()) { Console.WriteLine("  \"{0}\"", line); return new Dictionary&lt;string, int[]&gt;(); } var patternName = splt[0]; var patternBody = new List&lt;int&gt;(); for (var i = 1; i &lt; splt.Count(); i++) { int item = 0; if (!int.TryParse(splt[i], out item)) { Console.WriteLine("     \"{0}\"", line); break; } if (!bindings.ContainsKey(item)) { Console.WriteLine("      \"{0}\"", line); break; } patternBody.Add(item); } res[patternName] = patternBody.ToArray(); } return res; } static string GetPrinter() { var printers = new string[PrinterSettings.InstalledPrinters.Count]; PrinterSettings.InstalledPrinters.CopyTo(printers, 0); var printerIndex = Menu(printers, "Please select printer:"); return printers[printerIndex]; } } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Pdf2Pcl.cs</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Ghostscript.NET; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Ghostscript.NET.Processor; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">PCL_processing</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Pdf2Pcl</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertPcl2Pdf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pdfFileName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] rawDocumentData = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gsPipedOutput = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GhostscriptPipedOutput(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> outputPipeHandle = <span class="hljs-string"><span class="hljs-string">"%handle%"</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(gsPipedOutput.ClientHandle).ToString(<span class="hljs-string"><span class="hljs-string">"X2"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> processor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GhostscriptProcessor()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> switches = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(); switches.Add(<span class="hljs-string"><span class="hljs-string">"-dQUIET"</span></span>); switches.Add(<span class="hljs-string"><span class="hljs-string">"-dSAFER"</span></span>); switches.Add(<span class="hljs-string"><span class="hljs-string">"-dBATCH"</span></span>); switches.Add(<span class="hljs-string"><span class="hljs-string">"-dNOPAUSE"</span></span>); switches.Add(<span class="hljs-string"><span class="hljs-string">"-dNOPROMPT"</span></span>); switches.Add(<span class="hljs-string"><span class="hljs-string">"-sDEVICE=pxlmono"</span></span>); switches.Add(<span class="hljs-string"><span class="hljs-string">"-o"</span></span> + outputPipeHandle); switches.Add(<span class="hljs-string"><span class="hljs-string">"-f"</span></span>); switches.Add(pdfFileName); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { processor.StartProcessing(switches.ToArray(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GsIoHandler()); rawDocumentData = gsPipedOutput.Data; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { Console.WriteLine(ex.Message); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { gsPipedOutput.Dispose(); gsPipedOutput = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rawDocumentData; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GsIoHandler</span></span> : <span class="hljs-title"><span class="hljs-title">GhostscriptStdIO</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GsIoHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StdIn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count</span></span></span><span class="hljs-function">)</span></span> { input = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Empty; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StdOut</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> output</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(output)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; output = output.Trim(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"GS: {0}"</span></span>,output); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StdError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(error)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; error = error.Trim(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"GS: {0}"</span></span>, error); } } } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">RawPrinter.cs</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Runtime.InteropServices; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">PCL_processing</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RawPrinter</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Structure and API declarions: [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)] private class DOCINFOA { [MarshalAs(UnmanagedType.LPStr)] public string pDocName; [MarshalAs(UnmanagedType.LPStr)] public string pOutputFile; [MarshalAs(UnmanagedType.LPStr)] public string pDataType; } [DllImport("winspool.Drv", EntryPoint = "OpenPrinterA", SetLastError = true, CharSet = CharSet.Ansi, ExactSpelling = true, CallingConvention = CallingConvention.StdCall)] private static extern bool OpenPrinter([MarshalAs(UnmanagedType.LPStr)] string szPrinter, out IntPtr hPrinter, IntPtr pd); [DllImport("winspool.Drv", EntryPoint = "ClosePrinter", SetLastError = true, ExactSpelling = true, CallingConvention = CallingConvention.StdCall)] private static extern bool ClosePrinter(IntPtr hPrinter); [DllImport("winspool.Drv", EntryPoint = "StartDocPrinterA", SetLastError = true, CharSet = CharSet.Ansi, ExactSpelling = true, CallingConvention = CallingConvention.StdCall)] private static extern bool StartDocPrinter(IntPtr hPrinter, Int32 level, [In, MarshalAs(UnmanagedType.LPStruct)] DOCINFOA di); [DllImport("winspool.Drv", EntryPoint = "EndDocPrinter", SetLastError = true, ExactSpelling = true, CallingConvention = CallingConvention.StdCall)] private static extern bool EndDocPrinter(IntPtr hPrinter); [DllImport("winspool.Drv", EntryPoint = "StartPagePrinter", SetLastError = true, ExactSpelling = true, CallingConvention = CallingConvention.StdCall)] private static extern bool StartPagePrinter(IntPtr hPrinter); [DllImport("winspool.Drv", EntryPoint = "EndPagePrinter", SetLastError = true, ExactSpelling = true, CallingConvention = CallingConvention.StdCall)] private static extern bool EndPagePrinter(IntPtr hPrinter); [DllImport("winspool.Drv", EntryPoint = "WritePrinter", SetLastError = true, ExactSpelling = true, CallingConvention = CallingConvention.StdCall)] private static extern bool WritePrinter(IntPtr hPrinter, IntPtr pBytes, Int32 dwCount, out Int32 dwWritten); private static bool SendBytesToPrinter(string szPrinterName, IntPtr pBytes, Int32 dwCount, string docName) { Int32 dwError = 0, dwWritten = 0; IntPtr hPrinter = new IntPtr(0); DOCINFOA di = new DOCINFOA(); bool bSuccess = false; // Assume failure unless you specifically succeed. di.pDocName = docName; di.pDataType = "RAW"; // Open the printer. if (OpenPrinter(szPrinterName.Normalize(), out hPrinter, IntPtr.Zero)) { // Start a document. if (StartDocPrinter(hPrinter, 1, di)) { // Start a page. if (StartPagePrinter(hPrinter)) { // Write your bytes. bSuccess = WritePrinter(hPrinter, pBytes, dwCount, out dwWritten); EndPagePrinter(hPrinter); } EndDocPrinter(hPrinter); } ClosePrinter(hPrinter); } // If you did not succeed, GetLastError may give more information // about why not. if (bSuccess == false) { dwError = Marshal.GetLastWin32Error(); } return bSuccess; } public static bool SendRawDataToPrinter(string szPrinterName, byte[] data, string docName) { bool bSuccess = false; // Your unmanaged pointer. IntPtr pUnmanagedBytes = new IntPtr(0); // Allocate some unmanaged memory for those bytes. pUnmanagedBytes = Marshal.AllocCoTaskMem(data.Length); // Copy the managed byte array into the unmanaged array. Marshal.Copy(data, 0, pUnmanagedBytes, data.Length); // Send the unmanaged bytes to the printer. bSuccess = SendBytesToPrinter(szPrinterName, pUnmanagedBytes, data.Length, docName); // Free the unmanaged memory that you allocated earlier. Marshal.FreeCoTaskMem(pUnmanagedBytes); return bSuccess; } } }</span></span></code> </pre><br></div></div><br><br>  For work, you will need template files: <br><br>  patterns.csv <br> <code> ;2;3;3;4;4 <br>  ;2;3;4 <br>  ;2;3;3;4 <br>  ;2;4 <br>  ;2 <br></code> <br><br>  The first column is the name of the template, the rest are tray numbers. <br><br>  To create templates, it is convenient to operate with the tray number, and not the source Id from the manual: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/19c/676/0df/19c6760df83f46deb772bffabdf2744c.jpg"></div><br><br>  Create a binding file that contains the matching tray number and source id: <br><br>  source-bindings.kv <br> <code>1=3 <br> 2=4 <br> 3=5 <br> 4=7 <br></code> <br><br>  I hope, in the article I managed to fill the informational gap, which concerns the managed printing, and the printing in general from under .Net. <br><br>  One of the goals of the article is to draw the attention of developers, who in one way or another encounter tasks for printing documents, to the PCL language.  Although PCL is not as readable and convenient as PostScript, it allows you to finely control the printer.  And this is vital for some projects and not realizable in PostScript. <br><br>  If you have any suggestions or you notice inaccuracies, please write in the comments. <br><br>  Cycle of articles: <br>  <a href="https://habrahabr.ru/company/tcsbank/blog/279361/">Raster approach</a> <br>  <a href="https://habrahabr.ru/company/tcsbank/blog/283278/">Vector approach theory</a> <br>  <a href="https://habrahabr.ru/company/tcsbank/blog/302062/">Vector approach practice</a> </div><p>Source: <a href="https://habr.com/ru/post/302062/">https://habr.com/ru/post/302062/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../302044/index.html">ReactOS 0.4.2 will be excellent</a></li>
<li><a href="../302046/index.html">Dash Financing and Management System</a></li>
<li><a href="../302050/index.html">Embedding PyPy Code in C Applications</a></li>
<li><a href="../302056/index.html">Telegram Site Helper 2.0 - chat assistant for a site based on Telegram</a></li>
<li><a href="../302060/index.html">IT & Security Forum 2016 is over</a></li>
<li><a href="../302066/index.html">Vacation programmatically, or as I did not participate in the competition for programming on JS. Part two</a></li>
<li><a href="../302068/index.html">Overview of options for organizing access to corporate network services from the Internet</a></li>
<li><a href="../302070/index.html">Cross-platform mobile development: questions for adults</a></li>
<li><a href="../302072/index.html">CTCrypt 2016 - cryptography for every taste</a></li>
<li><a href="../302074/index.html">Analysis of the tasks of the second qualifying round of the RCC 2016</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>