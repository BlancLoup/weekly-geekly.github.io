<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The book "Security in PHP" (Part 5). Lack of entropy for random values</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The book "Security in PHP" (part 1) 
 The book "Security in PHP" (part 2) 
 The book "Security in PHP" (part 3) 
 The book "Security in PHP" (part 4) ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The book "Security in PHP" (Part 5). Lack of entropy for random values</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/storage2/930/571/c14/930571c142e5a454827cca64cd0855be.png"></div><br><p>  <a href="https://habrahabr.ru/company/mailru/blog/310726/">The book "Security in PHP" (part 1)</a> <br>  <a href="https://habrahabr.ru/company/mailru/blog/352440/">The book "Security in PHP" (part 2)</a> <br>  <a href="https://habrahabr.ru/company/mailru/blog/352442/">The book "Security in PHP" (part 3)</a> <br>  <a href="https://habrahabr.ru/company/mailru/blog/352444/">The book "Security in PHP" (part 4)</a> </p><br><p>  Random values ‚Äã‚Äãin PHP everywhere.  In all frameworks, in many libraries.  Probably, you yourself wrote a bunch of code that uses random values ‚Äã‚Äãto generate tokens and salts, as well as input data for functions.  Also, random values ‚Äã‚Äãplay an important role in solving various problems: </p><br><ol><li>  For random selection of options from a pool or a range of known options. </li><li>  To generate initialization vectors for encryption. </li><li>  To generate unpredictable tokens or one-time values ‚Äã‚Äãduring authorization. </li><li>  To generate unique identifiers, such as session IDs. <a name="habracut"></a></li></ol><br><p>  In all these cases, there is a characteristic vulnerability.  If an attacker guesses or predicts the output of your random number generator (RNG, Random Number Generator) or pseudo-random number generator (PRNG, Pseudo-Random Number Generator), then he will be able to calculate tokens, salts, one-time values ‚Äã‚Äãand cryptographic initialization vectors created using this generator.  Therefore, it is very important to generate high-quality random values, i.e., those that are extremely difficult to predict.  Do not allow the predictability of password reset tokens, CSRF tokens, API keys, one-time values ‚Äã‚Äãand authorization tokens! </p><br><p>  Two other potential vulnerabilities are associated with random values ‚Äã‚Äãin PHP: </p><br><ol><li>  Information Disclosure. </li><li>  Lack of entropy (Insufficient Entropy). </li></ol><br><p>  In this context, ‚Äúdisclosure of information‚Äù refers to the leakage of the internal state of the pseudo-random number generator - its initial value (seed value).  Such leaks can greatly facilitate the prediction of future PRNG output. </p><br><p>  The ‚Äúlack of entropy‚Äù describes a situation where the variability of the initial internal state (seed) of a PRNG or its output is so small that the whole range of possible values ‚Äã‚Äãis relatively easily picked up by brute force.  Not too good news for PHP programmers. </p><br><p>  We take a closer look at both vulnerabilities with examples of attack scenarios.  But first, let's see what is actually a random value when it comes to programming in PHP. </p><br><h2 id="chto-delayut-sluchaynye-znacheniya">  What do random values ‚Äã‚Äãdo? </h2><br><p>  Confusion about the purpose of random variables is exacerbated by general misunderstanding.  You've undoubtedly heard about the difference between cryptographically strong random values ‚Äã‚Äãand vague ‚Äúunique‚Äù values ‚Äã‚Äã‚Äúfor other uses‚Äù.  The main impression is that random values ‚Äã‚Äãused in cryptography require high-quality randomness (or, more precisely, high entropy), and values ‚Äã‚Äãfor other applications can do with less entropy.  I find this impression false and counterproductive.  The real difference between unpredictable random values ‚Äã‚Äãand those needed for trivial tasks is that the predictability of the second does not entail harmful consequences.  This generally excludes cryptography from consideration of the issue.  In other words, if you use a random value in a nontrivial problem, then you should automatically select a much stronger RNG. </p><br><p>  The strength of random values ‚Äã‚Äãis determined by the entropy expended to generate them.  Entropy is a measure of uncertainty expressed in bits.  For example, if I take a binary bit, its value may be 0 or 1. If the attacker does not know the exact value, then we have entropy 2 bits (i.e. coin flip).  If the attacker knows that the value is always 1, then we have an entropy of 0 bits, since predictability is the opposite of uncertainty.  Also, the number of bits can be in the range from 0 to 2. For example, if 99% of the time a binary bit is 1, then the entropy can be a little higher than 0. So the more unspecified binary bits we choose, the better. </p><br><p> In PHP, this can be seen more clearly.  The <code>mt_rand()</code> function generates random values, these are always numbers.  It does not produce letters, special characters or other values.  This means that for each byte, the attacker has far fewer guesses, that is, the entropy is low.  If we replace <code>mt_rand()</code> reading bytes from the Linux source <code>/dev/random</code> , then we get really random bytes: they are generated based on the noise generated by the system device drivers and other sources.  Obviously, this option is much better, because it provides significantly more bits of entropy. </p><br><p>  The undesirability of <code>mt_rand()</code> is also indicated by the fact that this generator is not true random, but pseudo-random numbers, or, as it is also called, a deterministic random binary sequence generator (Deterministic Random Bit Generator, DRBG).  It implements an algorithm called ‚ÄúMersenne Twister‚Äù (Mersenne Twister), which generates numbers that are distributed in such a way that the result will be close to the result of the operation of a true random number generator.  <code>mt_rand()</code> uses only one random value - the initial one (seed), on its basis a fixed algorithm generates pseudo-random values. </p><br><p>  Take a look at this example, you can test it yourself: </p><br><pre> <code class="php hljs">mt_srand(<span class="hljs-number"><span class="hljs-number">1361152757.2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i=<span class="hljs-number"><span class="hljs-number">1</span></span>; $i &lt; <span class="hljs-number"><span class="hljs-number">25</span></span>; $i++) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> mt_rand(), PHP_EOL; }</code> </pre> <br><p>  This is a simple loop that is executed after the Mersenne Vortex PHP function has received an initial, predetermined value.  It was obtained at the output of the function cited as an example in the documentation for <code>mt_srand()</code> and using current seconds and microseconds.  If you execute the given code, it will display 25 pseudo-random numbers.  They look random, no coincidences, everything is beautiful.  Run the code again.  Did you notice anything?  Namely: the SAME NUMBERS are output.  Run the third, fourth, fifth time.  In older versions of PHP, the result may be different, but this does not apply to the problem, since it is typical of all modern versions of PHP. </p><br><p>  If the attacker receives the initial value of such a PRNG, then he will be able to predict all the output of <code>mt_rand()</code> .  So the protection of the initial value is of paramount importance.  If you lose it, then you no longer have the right to generate random values ‚Äã‚Äã... </p><br><p>  You can generate an initial value in one of two ways: </p><br><ul><li>  manually using the <code>mt_srand()</code> function </li><li>  you will ignore <code>mt_srand()</code> and let PHP generate it automatically. </li></ul><br><p>  The second option is preferable, but today legacy applications often inherit the use of <code>mt_srand()</code> , even after porting to more modern versions of PHP. </p><br><p>  This increases the risk that the attacker will restore the initial value (Seed Recovery Attack), which will give him enough information to predict future values.  As a result, any application after such a leak becomes vulnerable to attack information disclosure.  This is a real vulnerability, despite its obviously passive nature.  Leakage of information about the local system can help the attacker in subsequent attacks, which violates the principle of echeloned defense. </p><br><h2 id="sluchaynye-znacheniya-v-php">  PHP random values </h2><br><p>  PHP uses three PRNGs, and if an attacker gains access to the initial values ‚Äã‚Äãused in their algorithms, he will be able to predict the results of their work: </p><br><ol><li>  Linear Congruential Generator (LCG), <code>lcg_value()</code> . </li><li>  Mersenne's whirlwind, <code>mt_rand()</code> . </li><li>  The locally supported C function <code>rand()</code> . </li></ol><br><p>  Also, these generators are used for internal needs, for functions like <code>array_rand()</code> and <code>uniqid()</code> .  This means that an attacker can predict the output of these and other functions that use the internal PRNG of the PHP language, if they acquire all the necessary initial values.  It also means that it will not be possible to improve protection by confusing the attacker through numerous appeals to the generators.  This is especially true of open source applications.  An attacker is able to predict ALL the output for any initial value known to him. </p><br><p>  To improve the quality of random values ‚Äã‚Äãgenerated for non-trivial tasks, PHP needs external sources of entropy provided by the operating system.  Linux usually uses <code>/dev/urandom</code> , you can read it directly or contact it indirectly, using the <code>openssl_pseudo_random_bytes()</code> or <code>mcrypt_create_iv()</code> functions.  Both of them can use a cryptographically safe pseudo-random number generator (CSPRNG) on Windows, but in PHP, there is no direct method in the user space to get data from this generator without the extensions provided by these functions.  In other words, make sure that the OpenSSL or Mcrypt extension is enabled in your PHP server version. </p><br><p>  <code>/dev/urandom</code> - PRNG, but often it gets new initial values ‚Äã‚Äãfrom a high- <code>/dev/random</code> source <code>/dev/random</code> .  This makes it an uninteresting target for an intruder.  We try to avoid direct reading from <code>/dev/random</code> , because it is a blocking resource.  If he exhausts entropy, then all readings will be blocked until enough entropy from the system environment is gathered again.  Although for the most important tasks you should use <code>/dev/random</code> . </p><br><p>  All this leads us to the rule: </p><br><pre> <code class="hljs 1c"> ,     ,   openssl_pseudo_random_bytes().          <span class="hljs-keyword"><span class="hljs-keyword"></span></span> /dev/urandom. <span class="hljs-keyword"><span class="hljs-keyword"></span></span>    <span class="hljs-keyword"><span class="hljs-keyword"></span></span>      ,                <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  .</code> </pre> <br><p>  The basic implementation of this rule can be found in <a href="https://github.com/padraic/SecurityMultiTool/blob/master/library/SecurityMultiTool/Random/Generator.php">the SecurityMultiTool reference library</a> .  As usual, PHP internals prefer to make life harder for programmers instead of directly incorporating secure solutions into the PHP core. </p><br><p>  Enough theory, now let's see how you can attack the application, armed with the above. </p><br><h2 id="ataka-na-generatory-sluchaynyh-chisel-v-php">  Attack to random number generators in PHP </h2><br><p>  For several reasons, PHP uses PRNG to solve non-trivial tasks. </p><br><p>  The <code>openssl_pseudo_random_bytes()</code> function was available only in PHP 5.3.  On Windows, it caused problems with locking until version 5.3.4 was released.  Also in PHP 5.3, the <code>mcrypt_create_iv()</code> function in Windows began to support the MCRYPT_DEV_URANDOM source.  Prior to this, only MCRYPT_RAND was supported in Windows - in fact, the same system PRNG used for internal needs by the <code>rand()</code> function.  As you can see, before the advent of PHP 5.3, there were quite a few spaces, so many legacy applications written in previous versions could not switch to stronger PRNGs. </p><br><p>  The choice of extensions Openssl and Mcrypt - at your discretion.  Because you cannot rely on their availability even on servers running PHP 5.3, applications often use PRNGs built into PHP as a fallback for generating non-trivial random values. </p><br><p>  But in both cases we have nontrivial tasks that apply random values ‚Äã‚Äãgenerated by PRNG with low entropy initial values.  This makes us vulnerable to initial value attacks.  Let's look at a simple example. </p><br><p>  Imagine that we found an online application that uses the following code to generate tokens that are used in different tasks throughout the application: </p><br><pre> <code class="hljs bash"><span class="hljs-variable"><span class="hljs-variable">$token</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>(<span class="hljs-string"><span class="hljs-string">'sha512'</span></span>, mt_rand());</code> </pre> <br><p>  There are more complex means of generating tokens, but this is a good option.  Here, only one <code>mt_rand()</code> call is <code>mt_rand()</code> , hashed using SHA512.  In practice, if the programmer decides that the functions of random values ‚Äã‚Äãin PHP are ‚Äúfairly random‚Äù, then he will certainly choose a simplified approach until the word ‚Äúcryptography‚Äù is heard.  For example, non-cryptographic cases include access tokens, CSRF tokens, one-time API values, and password reset tokens.  Before proceeding, I will describe in detail the entire vulnerability of this application, so that you can better understand what makes applications vulnerable at all. </p><br><h3 id="harakteristiki-uyazvimogo-prilozheniya">  Characteristics of the vulnerable application </h3><br><p>  This is not an exhaustive list.  In practice, the list of characteristics may differ! </p><br><h3 id="1-server-primenyaet-mod_php-kotoryy-pri-ispolzovanii-keepalive-pozvolyaet-obsluzhivat-neskolko-zaprosov-odnim-i-tem-zhe-php-processom">  1. <em>The server uses mod_php, which, when used with KeepAlive, allows you to handle several requests with the same PHP process</em> </h3><br><p>  This is important because random number generators in PHP receive initial values ‚Äã‚Äãonce per process.  If we can make two queries to the process or more, then it will use the same initial value.  The essence of the attack is to apply the disclosure of one token to extract the initial value, which is needed to predict another token generated on the basis of the SAME initial value (i.e. in the same process).  Since mod_php is ideal for using multiple queries to get related random values, sometimes with just one query you can extract multiple values ‚Äã‚Äãrelated to <code>mt_rand()</code> .  This makes redundant any mod_php requirements.  For example, part of the entropy used to generate the initial value for <code>mt_rand()</code> may leak through session IDs or output values ‚Äã‚Äãin the same request. </p><br><h3 id="2-server-raskryvaet-csrf-tokeny-tokeny-sbrosa-paroley-ili-podtverzhdeniya-akkauntov-sgenerirovannye-na-osnove-mt_rand-tokenov">  <em>2. The server reveals CSRF tokens, password reset tokens or account confirmation tokens generated based on mt_rand () - tokens</em> </h3><br><p>  To extract the initial value, we need to directly check the number generated by the generators in PHP.  And even it does not matter how it is used.  We can extract it from any available value, whether it is <code>mt_rand()</code> output, or a CSRF hashed, or account verification token.  Even indirect sources will be suitable, for which a random value determines a different output behavior, which reveals this very value.  The main limitation is that it must be from the same process that generates the second token that we are trying to predict.  And this is a ‚Äúinformation disclosure‚Äù vulnerability.  As we will see soon, PRNG output leakage can be extremely dangerous.  Note that the vulnerability is not limited to a single application: you can read the PRNG output in one application on the server and use it to define the output in another application on the same server if they both use the same PHP process. </p><br><h3 id="3-izvestnyy-slabyy-algoritm-generirovaniya-tokenov">  <em>3. Known weak token generation algorithm</em> </h3><br><p>  You can calculate it: </p><br><ul><li>  having rummaged in source codes of open source of the application, </li><li>  bribing an employee with access to personal source code, </li><li>  having found a former employee who harbored a grievance against a former employer, </li><li>  or just guessing what kind of algorithm it might be. </li></ul><br><p>  Some methods of generating tokens are more obvious, some are more popular.  <code>mt_rand()</code> weak generation tools are distinguished by using one of the PHP random number generators (for example, <code>mt_rand()</code> ), weak entropy (no other sources of undefined data), and / or weak hashing (for example, MD5 or no hashing at all).  The above code example just shows signs of a weak generation method.  I also used SHA512 hashing to demonstrate that masking is always an unsatisfactory solution.  SHA512 is a weak hash because it is quickly calculated, i.e. an attacker can brutally input data to any CPU or GPU at an incredible speed.  And do not forget that Moore's law also still works, which means that the speed of the brute force will grow with each new generation of CPU / GPU.  Therefore, passwords must be hashed using tools that crack the results of which take a fixed time, regardless of processor performance or Moore's law. </p><br><h3 id="vypolnenie-ataki">  Execution attack </h3><br><p>  Our attack is quite simple.  As part of the connection to the PHP process, we will conduct a quick session and send two separate HTTP requests (request A and request B).  A session will be held by the server until a second request is received.  Request A is aimed at getting some kind of available token like CSRF, a password reset token (sent to the attacker by mail) or something like that.  Do not forget about other features like inline markup used in queries of arbitrary IDs, etc. We will torture the original token until it gives us its initial value.  All of this is part of an attack with the restoration of the initial value: when the initial value has such a small entropy that it can be bruteformed or searched in a previously calculated <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D0%25B4%25D1%2583%25D0%25B6%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2582%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25B8%25D1%2586%25D0%25B0">rainbow table</a> . </p><br><p>  Request B will solve a more interesting problem.  Let's make a request to reset the local admin password.  This will start the token generation (using a random number based on the same initial value, which we pull out using request A, if both requests are successfully sent to the same PHP process).  This token will be stored in the database, awaiting the moment when the administrator uses the password reset link sent to him in the mail.  If we can retrieve the initial value for the token from query A, then, knowing how the token is generated from query B, we will predict the password reset token.  So, we can follow the reset link before the administrator reads the letter! </p><br><p>  Here is the sequence of events: </p><br><ol><li>  Using query A, we get a token and reverse engineer it to calculate the initial value. </li><li>  Using query B, we get a token generated based on the same initial value.  This token is stored in the application database for future password reset. </li><li>  Break the SHA512 hash to get the random number generated by the server. </li><li>  With the help of the obtained random value, a brutal force is the initial value that was generated with its help. </li><li>  We use the initial value to compute a series of random values ‚Äã‚Äãthat can probably underlie the password reset token. </li><li>  Use this token (s) to reset the admin password. </li><li>  We get access to the administrator account, have fun and get benefits.  Well, at least we have fun. </li></ol><br><p>  Tackling hacking ... </p><br><h3 id="poshagovyy-vzlom-prilozheniya">  Step hacking application </h3><br><h3 id="shag-1-osuschestvlyaem-zapros-a-dlya-izvlecheniya-tokena">  <em>Step 1. Execute request A to retrieve the token.</em> </h3><br><p>  We assume that the target token and the password reset token depend on the output of <code>mt_rand()</code> .  Therefore, you need to choose it.  In the application in our imaginary scenario, all the tokens are generated in the same way, so you can simply remove the CSRF token and save it for the future. </p><br><h3 id="shag-2-osuschestvlyaem-zapros-b-dlya-polucheniya-tokena-sbrosa-parolya-sgenerirovannogo-dlya-administratorskogo-akkaunta">  <em>Step 2. Execute query B to get a password reset token generated for the administrator account</em> </h3><br><p>  This request is a simple send password reset form.  The token will be saved in the database and sent to the user by mail.  We need to correctly calculate this token.  If server characteristics are accurate, then query B uses the same PHP process as query A. Therefore, in both cases, the <code>mt_rand()</code> calls will use the same initial value.  You can even use query A to capture the CSRF token of the reset form to enable data entry (submission) to streamline the procedure (we exclude the intermediate round trip). </p><br><h3 id="shag-3-vzlamyvaem-heshirovanie-sha512-tokena-poluchennogo-po-zaprosu-a">  <em>Step 3. We crack the hash of the SHA512 token received on request A</em> </h3><br><p>  SHA512 inspires awe at programmers: it has the largest number in the entire <a href="https://ru.wikipedia.org/wiki/SHA-2">family of SHA-2 algorithms</a> .  However, in the method of generating tokens chosen by our victim, there is one problem - random values ‚Äã‚Äãare limited only by numbers (that is, the degree of uncertainty, or entropy, is negligible).  If you check the output of <code>mt_getrandmax()</code> , you will find that the largest random number that <code>mt_rand()</code> can generate is 2.147 billion with a trifle.  This limited number of features makes SHA512 vulnerable to brute force. </p><br><p>  Just do not take my word for it.  If you have a discrete video card of one of the last generations, then you can go the following way.  Since we are looking for a single hash, I decided to use a great tool for brute force - <a href="http://hashcat.net/oclhashcat-lite/">hashcat-lite</a> .  This is one of the fastest versions of hashcat, it is for all major operating systems, including Windows. </p><br><p>  Using this code, generate a token: </p><br><pre> <code class="php hljs">$rand = mt_rand(); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Random Number: "</span></span>, $rand, PHP_EOL; $token = hash(<span class="hljs-string"><span class="hljs-string">'sha512'</span></span>, $rand); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Token: "</span></span>, $token, PHP_EOL;</code> </pre> <br><p>  This code reproduces the token from request A (it contains the random number we need and is hidden in the SHA512 hash) and runs through hashcat: </p><br><pre> <code class="hljs mel">./oclHashcat-lite64 -m1700 --pw-<span class="hljs-keyword"><span class="hljs-keyword">min</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span> --pw-<span class="hljs-keyword"><span class="hljs-keyword">max</span></span>=<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>?d -o ./<span class="hljs-keyword"><span class="hljs-keyword">seed</span></span>.txt &lt;SHA512 Hash&gt; ?d?d?d?d?d?d?d?d?d?d</code> </pre> <br><p>  This is what all these options mean: </p><br><ul><li>  -m1700: specifies the hash algorithm, where 1700 is SHA512. </li><li>  --pw-min = 1: specifies the minimum input length of the hashed value. </li><li>  --pw-max = 10: defines the maximum input length of the hashed value (10 for <code>mt_rand()</code> ). </li><li>  -1? D: determines that we need a custom dictionary of numbers only (i.e., 0-9). </li><li>  -o ./seed.txt: file for recording results.  Nothing is displayed on the screen, so be sure to set this parameter! </li><li>  ? d? d? d? d? d? d? d? d? d? d: mask that specifies the format to use (all digits up to a maximum of 10). </li></ul><br><p>  If everything works correctly and your GPU does not melt, Hashcat will calculate the hashed random number in a couple of minutes.  Yes, minutes.  I have already explained how entropy works.  See for yourself.  The <code>mt_rand()</code> function <code>mt_rand()</code> so few possibilities that it‚Äôs realistic to calculate SHA512 hashes of all values ‚Äã‚Äãin a very short time.  So it was pointless to hash the output of <code>mt_rand()</code> . </p><br><h3 id="shag-4-vosstanavlivaem-nachalnoe-znachenie-s-pomoschyu-svezhevzlomannogo-sluchaynogo-chisla">  <em>Step 4. Restoring the initial value using a freshly broken random number</em> </h3><br><p>  As we saw above, it takes only a couple of minutes to extract any generated <code>mt_rand()</code> value from SHA512.  Armed with a random value, we can run another tool for brute force - <a href="http://download.openwall.net/pub/projects/php_mt_seed/">php_mt_seed</a> .  This small utility takes the output <code>mt_rand()</code> and after bruteforce calculates the initial value, based on which the analyte could be generated.  Download the current version, compile and run.  If there are problems with compiling, try an older version (with the new ones I had problems with virtual environments). </p><br><pre> <code class="hljs xml">./php_mt_seed <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">RANDOM</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">NUMBER</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  This may take a little longer than hacking SHA512, since it is executed on the CPU.  On a decent processor, the utility will find the entire possible range of the initial value in a few minutes.  ‚Äî      (. . ,         ). :     ,         PHP      .   ,     ,    ,      . </p><br><p> ,       ,   .     <code>mt_rand()</code> ,    ,         (,   <code>mt_rand()</code>   ).    ,        ,      .   <a href="https://github.com/GeorgeArgyros/Snowflake"> </a> ,   <code>mt_rand()</code>    Python. </p><br><h3 id="shag-5-generiruem-vozmozhnye-tokeny-sbrosa-parolya-administratorskogo-akkaunta"> <em> 5.       </em> </h3><br><p> ,              <code>mt_rand()</code> .    ,      : </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">predict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($seed)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** *   PRNG   */</span></span> mt_srand($seed); <span class="hljs-comment"><span class="hljs-comment">/** *       */</span></span> mt_rand(); <span class="hljs-comment"><span class="hljs-comment">/** *         */</span></span> $token = hash(<span class="hljs-string"><span class="hljs-string">'sha512'</span></span>, mt_rand()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $token; }</code> </pre> <br><p>          . </p><br><h3 id="shagi-6-i-7-sbrasyvaem-parol-administratorskogo-akkaunta-i-veselimsya"> <em> 6  7.      !</em> </h3><br><p>    URL,  ,             . , ,          HTML (    ).      XSS-     ,        ¬´  ¬ª (Man-In-The-Browser). ,       ?  ,   ,         ,      ,        .  ‚Äî      ,       ,     . </p><br><h3 id="analiz-posle-ataki">    </h3><br><p>           <code>mt_rand()</code> .   ,           <code>mt_rand()</code> ,     ,  ¬´ ¬ª. </p><br><p>  ,       . ,     ,    <code>mt_rand()</code>  -  ,      , ,     ¬´¬ª ,    .   ,              .        <code>mt_rand()</code> ‚Äî    ,        ? </p><br><p>      .     <code>mt_rand()</code> (      )         .      ,     <code>mt_rand()</code> .   ‚Äî ,          <code>mt_rand()</code> ,        . </p><br><p>         .       ,       ,    ,      ,       . </p><br><h2 id="a-teper-vsyo-to-zhe-samoe">       </h2><br><p>   ,   PRNG,   PHP,     (. .    ).    : </p><br><pre> <code class="php hljs">$token = hash(<span class="hljs-string"><span class="hljs-string">'sha512'</span></span>, uniqid(mt_rand()));</code> </pre> <br><p>          .   ,     PHP- <code>uniqid()</code> .  : </p><br><p> <em>        -.</em> </p><br><p>   ,  ‚Äî   . -      ,  <code>mt_rand()</code> ,    <code>mt_rand()</code>    -   .          <code>uniqid()</code> ‚Äî  .      .     .       . </p><br><p> ,    ¬´¬ª, . .    .    1 000 000  .      1 ,        (,  HTTP Date  ),      .     ,    <code>uniqid()</code>     -: </p><br><pre> <code class="php hljs">gettimeofday((struct timeval *) &amp;tv, (struct timezone *) <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); sec = (int) tv.tv_sec; usec = (int) (tv.tv_usec % <span class="hljs-number"><span class="hljs-number">0x100000</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* usec     0xF423F,     * usecs    . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (more_entropy) { spprintf(&amp;uniqid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"%s%08x%05x%.8F"</span></span>, prefix, sec, usec, php_combined_lcg(TSRMLS_C) * <span class="hljs-number"><span class="hljs-number">10</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { spprintf(&amp;uniqid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"%s%08x%05x"</span></span>, prefix, sec, usec); } RETURN_STRING(uniqid, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>     ,        PHP: </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unique_id</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($prefix = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">, $more_entropy = false)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>($usec, $sec) = explode(<span class="hljs-string"><span class="hljs-string">' '</span></span>, microtime()); $usec *= <span class="hljs-number"><span class="hljs-number">1000000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span> === $more_entropy) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sprintf(<span class="hljs-string"><span class="hljs-string">'%s%08x%05x%.8F'</span></span>, $prefix, $sec, $usec, lcg_value()*<span class="hljs-number"><span class="hljs-number">10</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sprintf(<span class="hljs-string"><span class="hljs-string">'%s%08x%05x'</span></span>, $prefix, $sec, $usec); } }</code> </pre> <br><p>    ,    <code>uniqid()</code>       13 .  8  ‚Äî     Unix ( ),    .  5  ‚Äî     .  ,   <code>uniqid()</code>      ,       <code>uniqid()</code>    : </p><br><pre> <code class="php hljs">$id = uniqid(); $time = str_split($id, <span class="hljs-number"><span class="hljs-number">8</span></span>); $sec = hexdec(<span class="hljs-string"><span class="hljs-string">'0x'</span></span> . $time[<span class="hljs-number"><span class="hljs-number">0</span></span>]); $usec = hexdec(<span class="hljs-string"><span class="hljs-string">'0x'</span></span> . $time[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Seconds: '</span></span>, $sec, PHP_EOL, <span class="hljs-string"><span class="hljs-string">'Microseconds: '</span></span>, $usec, PHP_EOL;</code> </pre> <br><p>   -.          ,    : </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> uniqid(), PHP_EOL; <span class="hljs-comment"><span class="hljs-comment">// 514ee7f81c4b8 echo uniqid('prefix-'), PHP_EOL; // prefix-514ee7f81c746 echo uniqid('prefix-', true), PHP_EOL; // prefix-514ee7f81c8993.39593322</span></span></code> </pre> <br><h2 id="brutfors-unikalnyh-identifikatorov">    </h2><br><p>  ,   ,      <code>uniqid()</code> ‚Äî       .      ,           <code>uniqid()</code> .     ,     ,    1 000 000     .        ,        .        <code>uniqid()</code> : </p><br><pre> <code class="hljs bash"><span class="hljs-variable"><span class="hljs-variable">$token</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>(<span class="hljs-string"><span class="hljs-string">'sha512'</span></span>, uniqid(mt_rand()));</code> </pre> <br><p>     , ,   <code>mt_rand()</code>            <code>uniqid()</code> ,      SHA512-,         .              <code>uniqid()</code> ,    ,     HTTP Date.       .            ,       ! </p><br><pre> <code class="hljs xml"><span class="php"><span class="hljs-meta"><span class="php"><span class="hljs-meta">&lt;?php</span></span></span><span class="php">php </span><span class="hljs-keyword"><span class="php"><span class="hljs-keyword">echo</span></span></span><span class="php"> PHP_EOL; </span><span class="hljs-comment"><span class="php"><span class="hljs-comment">/** *        */</span></span></span><span class="php"> mt_srand(</span><span class="hljs-number"><span class="php"><span class="hljs-number">1361723136.7</span></span></span><span class="php">); $token = hash(</span><span class="hljs-string"><span class="php"><span class="hljs-string">'sha512'</span></span></span><span class="php">, uniqid(mt_rand())); </span><span class="hljs-comment"><span class="php"><span class="hljs-comment">/** *      , *  ,      HTTP Date    *  mt_rand()       ;) */</span></span></span><span class="php"> $httpDateSeconds = time(); $bruteForcedSeed = </span><span class="hljs-number"><span class="php"><span class="hljs-number">1361723136.7</span></span></span><span class="php">; mt_srand($bruteForcedSeed); $prefix = mt_rand(); </span><span class="hljs-comment"><span class="php"><span class="hljs-comment">/** *  HTTP Date   ,    *    (second tick)   uniqid()  time(). */</span></span></span><span class="php"> </span><span class="hljs-keyword"><span class="php"><span class="hljs-keyword">for</span></span></span><span class="php"> ($j=$httpDateSeconds; $j &lt; $httpDateSeconds+</span><span class="hljs-number"><span class="php"><span class="hljs-number">2</span></span></span><span class="php">; $j++) { </span><span class="hljs-keyword"><span class="php"><span class="hljs-keyword">for</span></span></span><span class="php"> ($i=</span><span class="hljs-number"><span class="php"><span class="hljs-number">0</span></span></span><span class="php">; $i &lt; </span><span class="hljs-number"><span class="php"><span class="hljs-number">1000000</span></span></span><span class="php">; $i++) { </span><span class="hljs-comment"><span class="php"><span class="hljs-comment">/** Replicate uniqid() token generator in PHP */</span></span></span><span class="php"> $guess = hash(</span><span class="hljs-string"><span class="php"><span class="hljs-string">'sha512'</span></span></span><span class="php">, sprintf(</span><span class="hljs-string"><span class="php"><span class="hljs-string">'%s%8x%5x'</span></span></span><span class="php">, $prefix, $j, $i)); </span><span class="hljs-keyword"><span class="php"><span class="hljs-keyword">if</span></span></span><span class="php"> ($token == $guess) { </span><span class="hljs-keyword"><span class="php"><span class="hljs-keyword">echo</span></span></span><span class="php"> PHP_EOL, </span><span class="hljs-string"><span class="php"><span class="hljs-string">'Actual Token: '</span></span></span><span class="php">, $token, PHP_EOL, </span><span class="hljs-string"><span class="php"><span class="hljs-string">'Forced Token: '</span></span></span><span class="php">, $guess, PHP_EOL; </span><span class="hljs-keyword"><span class="php"><span class="hljs-keyword">exit</span></span></span><span class="php">(</span><span class="hljs-number"><span class="php"><span class="hljs-number">0</span></span></span><span class="php">); } </span><span class="hljs-keyword"><span class="php"><span class="hljs-keyword">if</span></span></span><span class="php"> (($i % </span><span class="hljs-number"><span class="php"><span class="hljs-number">20000</span></span></span><span class="php">) == </span><span class="hljs-number"><span class="php"><span class="hljs-number">0</span></span></span><span class="php">) { </span><span class="hljs-keyword"><span class="php"><span class="hljs-keyword">echo</span></span></span><span class="php"> </span><span class="hljs-string"><span class="php"><span class="hljs-string">'~'</span></span></span><span class="php">; } } }</span></span></code> </pre> <br><h3 id="spasyot-li-nas-uvelichenie-entropii">     ? </h3><br><p> ,      uniqid()       TRUE: </p><br><pre> <code class="php hljs">$token = hash(<span class="hljs-string"><span class="hljs-string">'sha512'</span></span>, uniqid(mt_rand(), <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>));</code> </pre> <br><p>   -,         <code>php_combined_lcg()</code> .         <code>lcg_value()</code> ,      PHP-  <code>uniqid()</code> .  ,    ,       ,    .   ,      .     <code>mt_rand()</code> ,       PHP-       . </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lcg_seed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TSRMLS_D)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/* {{{ */</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeval</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tv</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gettimeofday(&amp;tv, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { LCG(s1) = tv.tv_sec ^ (tv.tv_usec&lt;&lt;<span class="hljs-number"><span class="hljs-number">11</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { LCG(s1) = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> ZTS LCG(s2) = (long) tsrm_thread_id(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> LCG(s2) = (long) getpid(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Add entropy to s2 by calling gettimeofday() again */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (gettimeofday(&amp;tv, NULL) == 0) { LCG(s2) ^= (tv.tv_usec&lt;&lt;11); } LCG(seeded) = 1; }</span></span></code> </pre> <br><p>            -  ,    .   . </p><br><p>        <code>gettimeofday()</code>           Unix Epoch (   ).  ,       ,     <code>microsecond()</code>    ,    .        ID  ,      Linux   32 768. ,       4 ,  <code>/proc/sys/kernel/pid_max</code> ,    . </p><br><p> ,    ,   LCG,  .  ,     <code>mt_rand()</code> ? ,   . </p><br><pre> <code class="hljs lisp">#ifdef PHP_WIN32 #define GENERATE_SEED() (((<span class="hljs-name"><span class="hljs-name">long</span></span>) (<span class="hljs-name"><span class="hljs-name">time</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) * GetCurrentProcessId())) ^ ((long) (1000000.0 * php_combined_lcg(<span class="hljs-name"><span class="hljs-name">TSRMLS_C</span></span>)))) #else #define GENERATE_SEED() (((<span class="hljs-name"><span class="hljs-name">long</span></span>) (<span class="hljs-name"><span class="hljs-name">time</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) * getpid())) ^ ((long) (1000000.0 * php_combined_lcg(<span class="hljs-name"><span class="hljs-name">TSRMLS_C</span></span>)))) #endif</code> </pre> <br><p>  ,     PHP   .       . ,     ,     :    ,       (    0 +    - <code>gettimeofday())</code> .           <code>gettimeofday()</code> ,      (  PHP   ).     ,     <code>mt_rand()</code>     ,    . </p><br><p>      <code>php_combined_lcg()</code> .     <code>lcg_value()</code>   ,         PHP-.      ,      .     ‚Äî  ,  . </p><br><h3 id="dlya-etogo-est-prilozhenie">    ... </h3><br><p>      ,       .       ,  <code>php_combined_lcg()</code> , ‚Äî ,     .  <code>lcg_value()</code>  ,      <code>mt_rand()</code> ,    PRNG,   PHP.        <code>lcg_value()</code> ,    .   LCG        (        <code>mt_srand()</code> ,       ,   - -).    ,       :    PHP. </p><br><pre> <code class="hljs lisp">spprintf(<span class="hljs-name"><span class="hljs-name">&amp;buf</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"%.15s%ld%ld%0.8F"</span></span>, remote_addr ? remote_addr : <span class="hljs-string"><span class="hljs-string">""</span></span>, tv.tv_sec, (<span class="hljs-name"><span class="hljs-name">long</span></span> int)tv.tv_usec, php_combined_lcg(<span class="hljs-name"><span class="hljs-name">TSRMLS_C</span></span>) * 10);</code> </pre> <br><p>     (pre-hash)   ID ,  IP,  ,  ‚Ä¶   <code>php_combined_lcg()</code> .       (   1   ID  2  <code>php_combined_lcg()</code> ,       ),     . , . </p><br><p>  , , , PHP       session.entropy_file  session.entropy_length.      ID ,      (   )         <code>php_combined_lcg()</code> LCG-.    PHP 5.3  , , ,    .         ,    ID       LCG. </p><br><p>     <a href="http://blog.ptsecurity.com/2012/08/not-so-random-numbers-take-two.html">Windows-</a> ,   LCG-. </p><br><p> ,   LCG  ,  <code>mt_rand()</code>   ,           <code>mt_rand()</code> . </p><br><p>             <code>uniqid()</code> ? </p><br><pre> <code class="php hljs">$token = hash(<span class="hljs-string"><span class="hljs-string">'sha512'</span></span>, uniqid(mt_rand(), <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>));</code> </pre> <br><p>       .       (      !).     ID        ,       ID. </p><br><p>  ,  ?      <code>uniqid()</code> ,              LCG,       .    ,  ID     ,     ,         ,        (      !). </p><br><h2 id="v-poiskah-entropii">    </h2><br><p> PHP        .     API     PRNG-   ,     .         openssl  mcrypt.   ,     , ,  . </p><br><p>  ,    ,        ,            .   ,     <code>mt_rand()</code>     ,      ,      .   ,    ,   <a href="http://blog.ircmaxell.com/"> </a>    <a href="https://github.com/ircmaxell/RandomLib">RandomLib</a> .       . </p><br><p>            .    ,       .         .  :   ,   ;   ,     .    ‚Äî        . </p><br><p>  RandomLib             ,      . ,     <code>mt_rand()</code> , <code>uniqid()</code>  <code>lcg_value()</code> ,  PID,  ,  -  ,  $_ENV, posix_times()  . .    ,    RandomLib. ,  -    (. . ,    -          <code>hash()</code> ). </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** *  32-  .     : * ‚Äî generateInt()      PHP_INT_MAX * ‚Äî generateString()        */</span></span> $factory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \RandomLib\Factory; $generator = $factory-&gt;getMediumStrengthGenerator(); $token = hash(<span class="hljs-string"><span class="hljs-string">'sha512'</span></span>, $generator-&gt;generate(<span class="hljs-number"><span class="hljs-number">32</span></span>));</code> </pre> <br><p> ,      OpenSSL  Mcrypt    (footprint)  RandomLib    RandomLib    ,   <a href="https://github.com/padraic/SecurityMultiTool/blob/master/library/SecurityMultiTool/Random/Generator.php"> PRNG- SecurityMultiToo</a> l. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/352446/">https://habr.com/ru/post/352446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352436/index.html">Blondes, monsters and artificial intelligence addictions</a></li>
<li><a href="../352438/index.html">Java Puzzlers NG S02: Wonderful and Wonderful</a></li>
<li><a href="../352440/index.html">The book "Security in PHP" (part 2). Code injection attacks</a></li>
<li><a href="../352442/index.html">The book "Security in PHP" (part 3). Cross-site scripting (XSS)</a></li>
<li><a href="../352444/index.html">The book Security in PHP (part 4). The lack of security at the transport level (HTTPS, TLS and SSL)</a></li>
<li><a href="../352448/index.html">Manual cipher LS47</a></li>
<li><a href="../352450/index.html">The history of the mobile Internet: 1991 - our days</a></li>
<li><a href="../352452/index.html">How to become a frontend developer in 2018</a></li>
<li><a href="../352454/index.html">Issue # 16: IT training - current issues and challenges from leading companies</a></li>
<li><a href="../352456/index.html">Belarus: blockchain and crypt regulation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>