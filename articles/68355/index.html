<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Laptops Market Analysis with Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 

 In this article I will talk about the state in today's Russian notebook market. We will carry out all analytics with the help of pytho...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Laptops Market Analysis with Python</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br><br>  In this article I will talk about the state in today's Russian notebook market.  We will carry out all analytics with the help of python code.  I think it will be useful both to those who are looking for a laptop, and those who want to practice writing in python. <br><br><h2>  Let's start </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <a href=""><img title="diy-03-425 [1]" alt="diy-03-425[1]" align="left" src="https://habrastorage.org/getpro/habr/post_images/fc2/f39/bf4/fc2f39bf4d47ef799715d2d7073b2fef.jpg" width="244" height="184"></a>  For the analysis, we need a data set, unfortunately I could not find <a href="http://developer.ebay.com/">web services</a> at the Russian online laptop stores, so I had to download the price list of one of them (I will not call it) and pull prices and basic parameters from it ( in my opinion, such are: processor frequency, monitor diagonal, RAM size, hard disk size and memory size on a video card).  Next, I conducted some analysis on the following issues: <br><a name="habracut"></a><br><ol><li>  The average cost of a laptop </li><li>  Iron Average Parameters on Laptops </li><li>  The most expensive / cheap laptop configuration </li><li>  Which configuration option has the most effect on its price? </li><li>  Predicting the price of the specified configuration </li><li>  Schedule of distribution of configurations and prices </li></ol><br><br><h2>  Lead code </h2><br><br>  The price list, which I managed to get, I saved in CSV format, to work with it you need to connect the csv module: <br><br>  <font color="#AA22FF"><b>import</b></font> <font color="#0000FF"><b>csv</b></font> <br>  <font color="#AA22FF"><b>import</b></font> <font color="#0000FF"><b>re</b></font> <br>  <font color="#AA22FF"><b>import</b></font> <font color="#0000FF"><b>random</b></font> <br><br><br><br>  Also we will connect the module for work with random numbers and regular expressions, which we will need later. <br><br>  Next, create a method for reading and retrieving laptops: <br><br>  <font color="#AA22FF"><b>def</b></font> <font color="#00A000">get_notebooks</font> (): <br>  reader <font color="#666666">=</font> csv.reader ( <font color="#AA22FF">open</font> ( <font color="#BB4444">'data.csv'</font> ), delimiter <font color="#666666">=</font> <font color="#BB4444">';'</font> , quotechar <font color="#666666">=</font> <font color="#BB4444">'|'</font> ) <br>  <font color="#AA22FF"><b>return</b></font> filter ( <b>lambda</b> x: x <font color="#666666">! =</font> <font color="#AA22FF">None</font> , map (create_notebook, reader)) <br><br><br><br>  everything is simple here, we read the file with data.csv data and filter it by the result of the create_notebook function, since  Not all positions in the price list are laptops, but by the way, and it: <br><br>  <font color="#AA22FF"><b>def</b></font> <font color="#00A000">create_notebook</font> (raw): <br>  <font color="#AA22FF"><b>try</b></font> : <br>  notebook <font color="#666666">=</font> Notebook () <br>  notebook.vendor = raw [0] .split ( <font color="#BB4444">''</font> ) [ <font color="#666666">0</font> ] <br>  notebook.model = raw [0] .split ( <font color="#BB4444">''</font> ) [ <font color="#666666">1</font> ] <br>  notebook.cpu = getFloat ( <font color="#BB4444">r "(\ d +) \, (\ d +) \ s \ G"</font> , raw [ <font color="#666666">0</font> ] .split ( <font color="#BB4444">'/'</font> ) [ <font color="#666666">0</font> ]) <br>  notebook.monitor = getFloat ( <font color="#BB4444">r "(\ d +) \. (\ d +) \ ''"</font> , raw [ <font color="#666666">0</font> ] .split ( <font color="#BB4444">'/'</font> ) [ <font color="#666666">1</font> ]) <br>  notebook.ram = getInt ( <font color="#BB4444">r "(\ d +) \ Mb"</font> , raw [ <font color="#666666">0</font> ] .split ( <font color="#BB4444">'/'</font> ) [ <font color="#666666">2</font> ]) <br>  notebook.hdd = getInt ( <font color="#BB4444">r "(\ d +) Gb"</font> , raw [ <font color="#666666">0</font> ] .split ( <font color="#BB4444">'/'</font> ) [ <font color="#666666">3</font> ]) <br>  notebook.video = getInt ( <font color="#BB4444">r "(\ d +) Mb"</font> , raw [ <font color="#666666">0</font> ] .split ( <font color="#BB4444">'/'</font> ) [ <font color="#666666">4</font> ]) <br>  notebook.price = getInt ( <font color="#BB4444">r "(\ d +) \ s \ rub."</font> , raw [ <font color="#666666">1</font> ]) <br>  <font color="#AA22FF"><b>return</b></font> notebook <br>  <b>except</b> <font color="#D2413A"><b>Exception</b></font> , e: <br>  <font color="#AA22FF"><b>return</b></font> none <br><br><br><br>  As you can see, I decided not to pay attention to the vendor, model and processor type (of course, not everything is so simple, but nonetheless), but also - this method contains my custom helper functions: <br><br>  <font color="#AA22FF"><b>def</b></font> <font color="#00A000">getFloat</font> (regex, raw): <br>  m <font color="#666666">=</font> re.search (regex, raw) .groups () <br>  <font color="#AA22FF"><b>return</b></font> float (m [ <font color="#666666">0</font> ] + <font color="#BB4444">'.'</font> <font color="#666666">+</font> m [1]) <br><br>  <font color="#AA22FF"><b>def</b></font> <font color="#00A000">getInt</font> (regex, raw): <br>  m <font color="#666666">=</font> re.search (regex, raw) .groups () <br>  <font color="#AA22FF"><b>return</b></font> int (m [ <font color="#666666">0</font> ]) <br><br><br><br>  I want to note that writing for python is best in the style of data sets, rather than OOP structures, due to the fact that the language has more to this style, but to restore some order in our domain domain (laptops), I introduced a class like You may have noticed above (notebook = Notebook ()) <br><br>  <font color="#AA22FF"><b>class</b></font> <font color="#0000FF">Notebook</font> : <br>  <font color="#AA22FF"><b>pass</b></font> <br><br><br><br>  Great, now we have a structure in memory and it is ready for analysis ( <em>2005 different configurations and their cost</em> ), what do we start: <br><br>  <strong>Average laptop cost:</strong> <br><br>  <font color="#AA22FF"><b>def</b></font> <font color="#00A000">get_avg_price</font> (): <br>  <font color="#AA22FF"><b>print</b></font> sum ([n <font color="#666666">.</font> price <font color="#AA22FF"><b>for</b></font> n <b>in</b> get_notebooks ()]) <font color="#666666">/</font> <font color="#AA22FF">len</font> (get_notebooks ()) <br><br><br><br>  We execute the code and see that 1K $, as a standard for a computer, is still valid: <br><br>  &gt;&gt; get_avg_price () <br>  <font color="#009999">34574</font> <br><br><br><br>  <strong>Iron Average Parameters on Laptops</strong> <br><br>  <font color="#AA22FF"><b>def</b></font> <font color="#00A000">get_avg_parameters</font> (): <br>  <font color="#AA22FF"><b>print</b></font> <font color="#BB4444">"cpu {0}"</font> <font color="#666666">.</font>  format ( <font color="#AA22FF">sum</font> ([n <font color="#666666">.</font> cpu <font color="#AA22FF"><b>for</b></font> n <b>in</b> get_notebooks ()]) <font color="#666666">/</font> <font color="#AA22FF">len</font> (get_notebooks ())) <br>  <b>print</b> <font color="#BB4444">"monitor {0}"</font> <font color="#666666">.</font>  format ( <font color="#AA22FF">sum</font> ([n <font color="#666666">.</font> monitor <font color="#AA22FF"><b>for</b></font> n <b>in</b> get_notebooks ()]) <font color="#666666">/</font> <font color="#AA22FF">len</font> (get_notebooks ())) <br>  <b>print</b> <font color="#BB4444">"ram {0}"</font> <font color="#666666">.</font>  format ( <font color="#AA22FF">sum</font> ([n <font color="#666666">.</font> ram <font color="#AA22FF"><b>for</b></font> n <b>in</b> get_notebooks ()]) <font color="#666666">/</font> <font color="#AA22FF">len</font> (get_notebooks ())) <br>  <b>print</b> <font color="#BB4444">"hdd {0}"</font> <font color="#666666">.</font>  format ( <font color="#AA22FF">sum</font> ([n <font color="#666666">.</font> hdd <font color="#AA22FF"><b>for</b></font> n <b>in</b> get_notebooks ()]) <font color="#666666">/</font> <font color="#AA22FF">len</font> (get_notebooks ())) <br>  <b>print</b> <font color="#BB4444">"video {0}"</font> <font color="#666666">.</font>  format ( <font color="#AA22FF">sum</font> ([n <font color="#666666">.</font> video <font color="#AA22FF"><b>for</b></font> n <b>in</b> get_notebooks ()]) <font color="#666666">/</font> <font color="#AA22FF">len</font> (get_notebooks ())) <br><br><br><br>  Ta-da, and in our hands averaged configuration: <br><br>  &gt;&gt; get_avg_parameters () <br>  cpu <font color="#009999">2.0460798005</font> <br>  monitor 14.6333167082 <br>  ram 2448 <br>  hdd 243 <br>  video 289 <br><br><br><br>  <strong>The most expensive / cheap laptop configuration:</strong> <br><br>  Functions are identical except for min / max functions. <br><br>  <font color="#AA22FF"><b>def</b></font> <font color="#00A000">get_max_priced_notebook</font> (): <br>  maxprice <font color="#666666">=</font> <font color="#AA22FF">max</font> ([n <font color="#666666">.</font> price <font color="#AA22FF"><b>for</b></font> n <b>in</b> get_notebooks ()]) <br>  maxconfig <font color="#666666">=</font> <font color="#AA22FF">filter</font> ( <b>lambda</b> x: x <font color="#666666">.</font> price == maxprice, get_notebooks ()) [0] <br>  <font color="#AA22FF"><b>print</b></font> <font color="#BB4444">"cpu {0}"</font> <font color="#666666">.</font>  format (maxconfig.cpu) <br>  <font color="#AA22FF"><b>print</b></font> <font color="#BB4444">"monitor {0}"</font> <font color="#666666">.</font>  format (maxconfig.monitor) <br>  <font color="#AA22FF"><b>print</b></font> <font color="#BB4444">"ram {0}"</font> <font color="#666666">.</font>  format (maxconfig.ram) <br>  <font color="#AA22FF"><b>print</b></font> <font color="#BB4444">"hdd {0}"</font> <font color="#666666">.</font>  format (maxconfig.hdd) <br>  <font color="#AA22FF"><b>print</b></font> <font color="#BB4444">"video {0}"</font> <font color="#666666">.</font>  format (maxconfig.video) <br>  <font color="#AA22FF"><b>print</b></font> <font color="#BB4444">"price {0}"</font> <font color="#666666">.</font>  format (maxconfig.price) <br><br><br><br>  &gt;&gt; get_max_priced_notebook () <br>  cpu <font color="#009999">2.26</font> <br>  monitor 18.4 <br>  ram 4096 <br>  hdd 500 <br>  video 1024 <br>  price 181660 <br><br><br><br>  &gt;&gt; get_min_priced_notebook () <br>  cpu <font color="#009999">1.6</font> <br>  monitor 8.9 <br>  ram 512 <br>  hdd 8 <br>  video 128 <br>  price 8090 <br><br><br><br>  <strong>Which configuration option has the most effect on its price?</strong> <br><br>  It would be very interesting to find out for which of the configuration parameters we pay the most money.  Having estimated, I assumed that most likely it is a monitor diagonal and a processor frequency, well, I think that it is worth checking it out. <br><br>  To begin with, our set of configuration parameters is worth a bit of modification.  Due to the fact that the units of measurement of different parameters are different in their order, we need to bring them to the same denominator, i.e.  normalize them.  So let's get started: <br><br>  <font color="#AA22FF"><b>def</b></font> <font color="#00A000">normalized_set_of_notebooks</font> (): <br>  notebooks <font color="#666666">=</font> get_notebooks () <br>  cpu = <font color="#AA22FF">max</font> ([n <font color="#666666">.</font> cpu <font color="#AA22FF"><b>for</b></font> n <b>in</b> notebooks]) <br>  monitor <font color="#666666">=</font> <font color="#AA22FF">max</font> ([n <font color="#666666">.</font> monitor <font color="#AA22FF"><b>for</b></font> n <b>in</b> notebooks]) <br>  ram <font color="#666666">=</font> <font color="#AA22FF">max</font> ([n <font color="#666666">.</font> ram <font color="#AA22FF"><b>for</b></font> n <b>in</b> notebooks]) <br>  hdd <font color="#666666">=</font> <font color="#AA22FF">max</font> ([n <font color="#666666">.</font> hdd <font color="#AA22FF"><b>for</b></font> n <b>in</b> notebooks]) <br>  video <font color="#666666">=</font> <font color="#AA22FF">max</font> ([n <font color="#666666">.</font> video <font color="#AA22FF"><b>for</b></font> n <b>in</b> notebooks]) <br>  rows <font color="#666666">=</font> <font color="#AA22FF">map</font> ( <b>lambda</b> n: [n <font color="#666666">.</font> cpu / cpu, n.monitor / monitor, <font color="#AA22FF">float</font> (n <font color="#666666">.</font> ram) / ram, <font color="#AA22FF">float</font> (n <font color="#666666">.</font> hdd) / hdd, <font color="#AA22FF">float</font> (n <font color="#666666">.</font> video) / video, n.price ], notebooks) <br>  <font color="#AA22FF"><b>return</b></font> rows <br><br><br><br>  In this function, I find the maximum values ‚Äã‚Äãfor each of the parameters, then form the resulting list of laptops, in which each of the parameters is represented as a coefficient (its value will vary from 0 to 1), showing the ratio of its parameter to the maximum value in the set, to For example, a memory of 2048Mb will give the configuration a coefficient of ram = 0.5 (2048/4056). <br><br>  The contribution of each of the parameters we will consider in rubles, for clarity, we will store these weights in the set: <br><br>  <font color="#008800"><i>#cpu, monitor, ram, hdd, video</i></font> <br>  koes <font color="#666666">=</font> [0, 0, 0, 0, 0] <br><br><br><br>  I propose to calculate these coefficients for each configuration, and then determine the average value of all coefficients, which will give us averaged data on the weight of each of the configuration elements. <br><br>  <font color="#AA22FF"><b>def</b></font> <font color="#00A000">analyze_params</font> (parameters): <br>  koeshistory <font color="#666666">=</font> [] <br>  <font color="#008800"><i># our laptops</i></font> <br>  notes <font color="#666666">=</font> normalized_set_of_notebooks () <br>  <font color="#AA22FF"><b>for</b></font> i <b>in</b> range (len (notes)): <br>  koes <font color="#666666">=</font> [0, 0, 0, 0, 0] <br>  <font color="#008800"><i># set coefficients</i></font> <br>  set_koes (notes [i], koes) <br>  <i># save history of coefficients</i> <br>  koeshistory <font color="#666666">.</font>  extend (koes) <br>  <font color="#008800"><i># show progress</i></font> <br>  <font color="#AA22FF"><b>if</b></font> (i <font color="#666666">%</font> 100 == 0): <br>  <font color="#AA22FF"><b>print</b></font> i <br>  <b>print</b> koes <br><br><br><br>  How will we set the coefficients for each configuration item?  My way is as follows: <br><br><ul><li>  <em>we need to randomly increase or decrease the value of one of the coefficients</em> </li><li>  <em>after which we analyze whether we have approached the price per configuration when multiplying the vector of parameters by the vector of coefficients (let me remind you that in our case these are rubles)</em> </li><li>  <em>if the approach took place, you we repeat this action, if not, then cancel it</em> </li><li>  <em>repeat this order to the extent until we get close to our price with the accuracy we set</em> </li></ul><br><br>  Here is the implementation of this algorithm: <br><br>  <font color="#AA22FF"><b>def</b></font> <font color="#00A000">set_koes</font> (note, koes, error <font color="#666666">=</font> 500): <br>  price = get_price (note, koes) <br>  lasterror = <font color="#AA22FF">abs</font> (note [ <font color="#666666">5</font> ] - price) <br>  <font color="#AA22FF"><b>while</b></font> (lasterror <font color="#666666">&gt;</font> error): <br>  k = random.randint (0.4) <br>  <font color="#008800"><i># we change the coefficient</i></font> <br>  inc <font color="#666666">=</font> (random.random () * 2 - 1) * (error * (1 - error / lasterror)) <br>  koes [k] + = inc <br>  <font color="#008800"><i># do not let the coefficient become less than zero</i></font> <br>  <font color="#AA22FF"><b>if</b></font> (koes [k] <font color="#666666">&lt;</font> 0): koes [k] = 0 <br>  <font color="#008800"><i># get the price when taking into account coefficients</i></font> <br>  price <font color="#666666">=</font> get_price (note, koes) <br>  <font color="#008800"><i># get the current error</i></font> <br>  curerror <font color="#666666">=</font> <font color="#AA22FF">abs</font> (note [ <font color="#666666">5</font> ] - price) <br>  <font color="#008800"><i># check if we are close to the price shown in the price list</i></font> <br>  <font color="#AA22FF"><b>if</b></font> (lasterror <font color="#666666">&lt;</font> curerror): <br>  koes [k] - = inc <br>  <font color="#AA22FF"><b>else</b></font> : <br>  lasterror <font color="#666666">=</font> curerror <br><br><br><br>  inc is a variable responsible for the increase / decrease of the coefficient; the method of its calculation is explained by the fact that this value should be the greater, the greater the difference in error, in order to quickly and more accurately approach the desired result. <br><br>  The multiplication of vectors to get the price is as follows: <br><br>  <font color="#AA22FF"><b>def</b></font> <font color="#00A000">get_price</font> (note, koes): <br>  <font color="#AA22FF"><b>return</b></font> sum ([note [i] <font color="#666666">*</font> koes [i] <font color="#AA22FF"><b>for</b></font> i <b>in</b> range ( <font color="#666666">5</font> )]) <br><br><br><br>  The time has come to perform the analysis: <br><br>  &gt;&gt; analyze_params () <br>  cpu, monitor, ram, hdd, video <br><br>  [ <font color="#009999">15455.60675667684</font> , 20980.560483811361, 12782.535270304281, 17819.904629585861, 14677.889529808042] <br><br><br><br>  We obtained this set due to averaging of the coefficients obtained for each of the configurations: <br><br>  <font color="#AA22FF"><b>def</b></font> <font color="#00A000">get_avg_koes</font> (koeshistory): <br>  koes <font color="#666666">=</font> [0, 0, 0, 0, 0] <br>  <font color="#AA22FF"><b>for</b></font> row <b>in</b> koeshistory: <br>  <b>for</b> i <b>in</b> range ( <font color="#666666">5</font> ): <br>  koes [i] + = koeshistory [i] <br>  <font color="#AA22FF"><b>for</b></font> i <b>in</b> range ( <font color="#666666">5</font> ): <br>  koes [i] / = <font color="#AA22FF">len</font> (koeshistory) <br>  <b>return</b> koes <br><br><br><br>  So, we have the desired set, what can we say from these figures, and can we make a rating of the parameters: <br><br><ol><li>  Monitor diagonal </li><li>  Hard disk capacity </li><li>  CPU frequency </li><li>  Video Card Volume </li><li>  RAM size </li></ol><br><br>  I would like to note that this is far from ideal, and you may have different results, however, my assumption that the frequency of the processor and the diagonal of the display, the most important parameters in the configuration, were partially confirmed. <br><br>  <strong>Forecasting the price of the specified configuration</strong> <br><br>  It would be nice to have such a rich set of data to be able to predict the price for a given configuration.  This is what we will do. <br><br>  To begin with we will transform our collection of laptops into the list: <br><br>  <font color="#AA22FF"><b>def</b></font> <font color="#00A000">get_notebooks_list</font> (): <br>  <font color="#AA22FF"><b>return</b></font> map ( <b>lambda</b> n: [n <font color="#666666">.</font> cpu, n.monitor, n.ram, n.hdd, n.video, n.price], get_notebooks ()) <br><br><br><br>  Next, we need a function that can determine the distance between two vectors, a good option I see the function of the Euclidean distance: <br><br>  <font color="#AA22FF"><b>def</b></font> <font color="#00A000">euclidean</font> (v1, v2): <br>  d <font color="#666666">=</font> 0.0 <br>  <font color="#AA22FF"><b>for</b></font> i <b>in</b> range (len (v1)): <br>  d <font color="#666666">+ =</font> (v1 [i] - v2 [i]) ** 2; <br>  <font color="#AA22FF"><b>return</b></font> math <font color="#666666">.</font>  sqrt (d) <br><br><br><br>  The root of the sum of squares of differences pretty clearly and effectively shows us how one vector is different from another.  What is this feature useful for us?  Everything is simple, when we get a vector, with parameters that interest us, we will go over the entire collection of our set and find the nearest neighbor, and we already know its value, great!  Here's how we do it: <br><br>  <font color="#AA22FF"><b>def</b></font> <font color="#00A000">getdistances</font> (data, vec1): <br>  distancelist <font color="#666666">=</font> [] <br>  <font color="#AA22FF"><b>for</b></font> i <b>in</b> range (len (data)): <br>  vec2 <font color="#666666">=</font> data [i] <br>  distancelist.append ((euclidean (vec1, vec2), i)) <br>  distancelist.sort () <br>  <font color="#AA22FF"><b>return</b></font> distancelist <br><br><br><br>  Further, it is possible to complicate the task a little, as well as the accuracy of the data provided.  To do this, we introduce a function that uses the classification <a href="http://www.machinelearning.ru/wiki/index.php%3Ftitle%3D%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_k_%25D0%25B2%25D0%25B7%25D0%25B2%25D0%25B5%25D1%2588%25D0%25B5%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585_%25D0%25B1%25D0%25BB%25D0%25B8%25D0%25B6%25D0%25B0%25D0%25B9%25D1%2588%25D0%25B8%25D1%2585_%25D1%2581%25D0%25BE%25D1%2581%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25B9_(%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BC%25D0%25B5%25D1%2580)">method k weighted nearest neighbors</a> : <br><br><blockquote><img alt="K" src="https://habrastorage.org/getpro/habr/post_images/4a8/06b/a6c/4a806ba6c3096d4f8c71422f179542d8.gif">  weighted nearest neighbors is a <a href="http://www.machinelearning.ru/wiki/index.php%3Ftitle%3D%25D0%259C%25D0%25B5%25D1%2582%25D1%2580%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25BA%25D0%25BB%25D0%25B0%25D1%2581%25D1%2581%25D0%25B8%25D1%2584%25D0%25B8%25D0%25BA%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580">metric classification algorithm</a> based on evaluating the similarity of objects.  The object being classified belongs to the class to which the objects of the <a href="http://www.machinelearning.ru/wiki/index.php%3Ftitle%3D%25D0%2592%25D1%258B%25D0%25B1%25D0%25BE%25D1%2580%25D0%25BA%25D0%25B0">training set</a> that belong to it belong. <br></blockquote><br><br>  Well, take the average value among a certain number of nearest neighbors, which will negate the influence of vendor prices, or configuration specificity: <br><br>  <font color="#AA22FF"><b>def</b></font> <font color="#00A000">knnestimate</font> (data, vec1, k <font color="#666666">=</font> 3): <br>  dlist = getdistances (data, vec1) <br>  avg = 0.0 <br>  <font color="#AA22FF"><b>for</b></font> i <b>in</b> range (k): <br>  idx <font color="#666666">=</font> dlist [i] [1] <br>  avg + = data [idx] [5] <br>  avg / = k <br>  <font color="#AA22FF"><b>return</b></font> avg <br><br><br><br>  * the last 3 algorithms are taken from <a href="http://www.books.ru/shop/books/586615%3Fpartner%3Dbutaji">Segeran Toby</a> ‚Äôs book <a href="http://www.books.ru/shop/books/586615%3Fpartner%3Dbutaji">‚ÄúProgramming Collective Intelligence‚Äù</a> <br><br>  And what do we get: <br><br>  &gt;&gt; knnestimate (get_notebooks_list (), [ <font color="#009999">2.4</font> , 17, 3062, 250, 512]) <br>  31521.0 <br><br>  &gt;&gt; knnestimate (get_notebooks_list (), [2.0, 15, 2048, 160, 256]) <br>  27259.0 <br>  &gt;&gt; knnestimate (get_notebooks_list (), [2.0, 15, 2048, 160, 128]) <br>  20848.0 <br><br><br><br>  Prices are market prices and this is quite enough, although we absolutely do not take into account in this implementation, for example, the processor frequency and monitor diagonal (for this we need to add to the function of comparing their weight vectors, which we calculated in the previous paragraph) <br><br>  <strong>Schedule of distribution of configurations and prices</strong> <br><br>  I would like to embrace the whole distribution picture, i.e.  draw the distribution of configurations and prices in the market.  Ok, let's do it. <br><br>  First you need to put the <a href="http://matplotlib.sourceforge.net/users/installing.html">matplotlib</a> library.  Next, connect it to our project: <br><br>  <font color="#AA22FF"><b>from</b></font> <font color="#0000FF"><b>pylab</b></font> <font color="#AA22FF"><b>import</b></font> <font color="#666666">*</font> <br><br><br><br>  We also need to create two data sets for the abscissa and ordinate: <br><br>  <font color="#AA22FF"><b>def</b></font> <font color="#00A000">power_of_notebooks_config</font> (): <br>  <font color="#AA22FF"><b>return</b></font> map ( <b>lambda</b> x: x [ <font color="#666666">0</font> ] * x [1] * x [2] * x [3] * x [4], normalized_set_of_notebooks ()) <br>  <font color="#AA22FF"><b>def</b></font> <font color="#00A000">config_prices</font> (): <br>  <font color="#AA22FF"><b>return</b></font> map ( <b>lambda</b> x: x [ <font color="#666666">5</font> ], normalized_set_of_notebooks ()) <br><br><br><br>  And the function in which we build the distribution graph: <br><br>  <font color="#AA22FF"><b>def</b></font> <font color="#00A000">draw_market</font> (): <br>  plot (config_prices (), power_of_notebooks_config (), <font color="#BB4444">'bo'</font> , linewidth <font color="#666666">=</font> 1.0) <br><br>  xlabel ( <font color="#BB4444">'price (Rub)'</font> ) <br>  ylabel ('config_power') <br>  title ('Russian Notebooks Market') <br>  grid ( <font color="#AA22FF">true</font> ) <br>  show () <br><br><br><br>  And what do we get: <br><br> <a href=""><img title="notes" alt="notes" src="https://habrastorage.org/getpro/habr/post_images/9d9/e22/dfb/9d9e22dfbd31c527577e70cc36c3ba95.png" width="495" height="378"></a> <br><br><h2>  In conclusion </h2><br><br>  So, we managed to conduct a small analysis of the Russian laptop market, as well as lose a little with python. <br><br>  The source code of the project is available at: <br><br>  <a href="http://code.google.com/p/runm/source/checkout">http://code.google.com/p/runm/source/checkout</a> <br><br>  I apologize for a little important syntax highlighting, my engine ( <a href="http://pygments.org/">pygments</a> ) did not want to be perceived as a habr. </div><p>Source: <a href="https://habr.com/ru/post/68355/">https://habr.com/ru/post/68355/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../68349/index.html">Full review of Snow Leopard. Part 2</a></li>
<li><a href="../68350/index.html">Setting up a DNS server on FreeBSD</a></li>
<li><a href="../68352/index.html">Intel predicts netbook sales boom</a></li>
<li><a href="../68353/index.html">And Mars will have apple trees ... to graze?</a></li>
<li><a href="../68354/index.html">A lamp in the form of a lamp (actually it is an alarm clock)</a></li>
<li><a href="../68356/index.html">How to save yourself for children?</a></li>
<li><a href="../68357/index.html">Software Configuration Management // tracking change requests</a></li>
<li><a href="../68358/index.html">PROLiNK Glee TA-009 - netbook from Singapore</a></li>
<li><a href="../68360/index.html">AU Optronics one and a half times increases the production of screens for e-books</a></li>
<li><a href="../68362/index.html">netboot.me - download everything!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>