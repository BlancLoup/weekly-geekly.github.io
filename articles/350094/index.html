<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Guide to background work in Android. Part 2: Loaders</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the second of a series of articles on Android background tools and techniques. AsyncTask has already been reviewed earlier, in the following r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Guide to background work in Android. Part 2: Loaders</h1><div class="post__text post__text-html js-mediator-article">  This is the second of a series of articles on Android background tools and techniques.  AsyncTask has already <a href="https://habrahabr.ru/company/epam_systems/blog/348894/">been reviewed</a> earlier, in the following releases - ThreadPools with EventBus, RxJava 2 and Kortelins in Kotlin. <br><br><img src="https://habrastorage.org/webt/od/m6/al/odm6alpw_8kk0z4qz4kzf3irrtw.jpeg"><br><a name="habracut"></a><br>  In the <a href="https://habrahabr.ru/company/epam_systems/blog/348894/">previous</a> text, we mentioned that AsyncTasks have several problems.  Let's recall two of them: <br><br><ul><li>  AsyncTasks know nothing about the Activity Life Cycle.  If mishandled, you will at best get a memory leak, and at worst a failure. </li><li>  AsyncTask does not support the preservation of state of progress and the reuse of download results. </li></ul><br>  The meaning of the first problem is this: in order to update the UI in the onPostExecute method, we need a link to a specific view or to the whole Activity it belongs to.  A naive approach is to store this link inside AsyncTask itself: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> LoadWeatherForecastTask extends AsyncTask&lt;String, Void, WeatherForecast&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Activity activity; LoadWeatherForecastTask(Activity activity) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.activity = activity; } }</code> </pre> <br>  The problem is that as soon as the user rotates the device, the Activity is destroyed and the link becomes outdated.  This leads to a memory leak.  Why?  Recall that our doInBackground method is called inside the Future, executed on an executor - a static member of the AsyncTask class.  This makes our AsyncTask object, as well as an Activity, strictly achievable (because statics is one of the roots of GC), and therefore unsuitable for garbage collection.  This in turn means that several screen rotations can cause OutOfMemoryError, because the Activity takes up a decent amount of memory. <br><br>  You can fix this error using WeakReference: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> LoadWeatherForecastTask extends AsyncTask&lt;String, Void, WeatherForecast&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> WeakReference&lt;Activity&gt; activityRef; LoadWeatherForecastTask(Activity activity) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.activityRef = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WeakReference&lt;&gt;(activity); } }</code> </pre><br>  Well, we got rid of OOM, but the result of AsyncTask is lost in any case, and we are doomed to re-launch it, discharging the phone and expending traffic. <br><br><hr><br>  In order to fix this, the Android team several years ago proposed the Loaders API (‚ÄúBoot Loaders‚Äù).  Let's see how to use this <a href="https://developer.android.com/guide/components/loaders.html">API</a> .  We need to implement the Loader.Callbacks interface: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WeatherForecastLoaderCallbacks</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LoaderManager.LoaderCallbacks</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WeatherForecast</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onLoaderReset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(loader: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Loader</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">WeatherForecast</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;?)</span></span></span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreateLoader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: Loader&lt;WeatherForecast&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WeatherForecastLoader(applicationContext) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onLoadFinished</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(loader: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Loader</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">WeatherForecast</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;?, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">WeatherForecast</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { temperatureTextView.text = <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>!!.temp.toString(); } }</code> </pre><br>  As you can see, the <i>onLoadFinished</i> method <i>is</i> very similar to <i>onPostExecute</i> , which we implemented in AsyncTask. <br><br>  We need to create Loader itself: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WeatherForecastLoader</span></span></span></span>(context: Context) : AsyncTaskLoader&lt;WeatherForecast&gt;(context) { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadInBackground</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: WeatherForecast { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Thread.sleep(<span class="hljs-number"><span class="hljs-number">5000</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: InterruptedException) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WeatherForecast(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">0F</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WeatherForecast(<span class="hljs-string"><span class="hljs-string">"Saint-Petersburg"</span></span>, <span class="hljs-number"><span class="hljs-number">20F</span></span>, <span class="hljs-string"><span class="hljs-string">"Sunny"</span></span>) } }</code> </pre><br>  And call initLoader () with our Loader id: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) ... <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> weatherForecastLoader = WeatherForecastLoaderCallbacks() loaderManager .initLoader(forecastLoaderId, Bundle(), weatherForecastLoader) }</code> </pre><br>  <b>Please note: WeatherForecastLoaderCallbacks is a nested class of our Activity;</b>  <b>LoaderManager stores a link to this Callbacks object - and this means to the Activity itself.</b> <br><br>  A lot of code, right?  But we get an important advantage here.  First, the Loader is reused when the screen is rotated (or other configuration changes).  If the screen is rotated, onLoadFinished will be called with the transfer of the result we loaded earlier. <br><br>  Another advantage is that we don‚Äôt have a memory leak, although we still have access to the Activity, allowing us to update the interface. <br><br>  Cool, AsyncTask did not have both of these advantages!  Let's now figure out how it all works. <br><br><hr><br>  This is where the main fun begins.  I thought that LoaderManager is stored somewhere inside Application, but the actual implementation was much more interesting. <br><br>  LoaderManager is created when creating an instance of an Activity: <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> FragmentController mFragments = FragmentController.createController(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HostCallbacks()); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LoaderManager </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLoaderManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mFragments.getLoaderManager(); } }</code> </pre><br>  FragmentController.createController is simply the named constructor for the FragmentController class.  FragmentController delegates the creation of LoaderManager to HostCallbacks (a nested class of our Activity), the implementation looks like this: <br><br><pre> <code class="hljs kotlin">LoaderManagerImpl getLoaderManagerImpl() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mLoaderManager != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mLoaderManager; } mCheckedForLoaderManager = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; mLoaderManager = getLoaderManager(<span class="hljs-string"><span class="hljs-string">"(root)"</span></span>, mLoadersStarted, <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-comment"><span class="hljs-comment">/*create*/</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mLoaderManager;</code> </pre><br>  As you can see, LoaderManager for the Activity itself is lazily initialized;  An instance of LoaderManager is not created until it is first needed.  LoaderManager access to our Activity occurs via the '(root)' key in Map LoadersManagers.  Access to this Map is implemented as follows: <br><br><pre> <code class="hljs pgsql">LoaderManagerImpl getLoaderManager(String who, <span class="hljs-type"><span class="hljs-type">boolean</span></span> started, <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mAllLoaderManagers == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { mAllLoaderManagers = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArrayMap&lt;String, LoaderManager&gt;(); } LoaderManagerImpl lm = (LoaderManagerImpl) mAllLoaderManagers.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(who); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lm == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span>) { lm = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> LoaderManagerImpl(who, this, started); mAllLoaderManagers.put(who, lm); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (started &amp;&amp; lm != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; !lm.mStarted){ lm.doStart(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lm; }</code> </pre><br>  However, this is not the last entry in the LoaderManager field.  Let's look at the Activity # onCreate method: <br><br><pre> <code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@MainThread</span></span> <span class="hljs-meta"><span class="hljs-meta">@CallSuper</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mLastNonConfigurationInstances != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { mFragments.restoreLoaderNonConfig( mLastNonConfigurationInstances.loaders); } ... }</code> </pre><br>  The restoreLoaderNonConfig method ultimately simply updates the host controller, which is now a member of the class of the new Activity instance created after the configuration change. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  When calling the initLoader () method, LoaderManager already has all the information about Loaders that was created in the destroyed Activity.  So he can publish the downloaded result immediately: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LoaderManager</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;D&gt; <span class="hljs-function"><span class="hljs-function">Loader&lt;D&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initLoader</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, Bundle args, LoaderManager.LoaderCallbacks&lt;D&gt; callback</span></span></span><span class="hljs-function">)</span></span> { ... LoaderInfo info = mLoaders.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(id); ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { info = createAndInstallLoader(id, args, (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// override old callbacks reference here to new one info.mCallbacks = (LoaderManager.LoaderCallbacks&lt;Object&gt;) callback; } if (info.mHaveData &amp;&amp; mStarted) { // deliver the result we already have info.callOnLoadFinished(info.mLoader, info.mData); } return (Loader&lt;D&gt;)info.mLoader; }</span></span></code> </pre><br>  It's great that we dealt with two things at once: how we avoid memory leaks (replacing the LoaderCallback instance) and how we deliver the result to a new Activity! <br><br>  Perhaps you are wondering what else this beast is for mLastNonConfigurationInstances.  This is an instance of the NonConfigurationInstances class, defined inside the Activity class: <br><br><pre> <code class="hljs javascript">public <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> final <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NonConfigurationInstances</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span> activity; HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>&gt; children; FragmentManagerNonConfig fragments; ArrayMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, LoaderManager&gt; loaders; VoiceInteractor voiceInteractor; } NonConfigurationInstances mLastNonConfigurationInstances; }</code> </pre><br>  The object is created using the retainNonConfigurationInstance () method, and then it is directly accessed by the Android OS.  And it becomes available for Activity in the Activity # attach () method (and this is the internal Activity API): <br><br><pre> <code class="hljs vbscript">final void attach(Context context, ActivityThread aThread, Instrumentation <span class="hljs-built_in"><span class="hljs-built_in">instr</span></span>, IBinder token, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback) { attachBaseContext(context); ... mLastNonConfigurationInstances = lastNonConfigurationInstances; ... }</code> </pre><br>  So, unfortunately, the main magic remains inside the Android OS.  But no one will forbid us to learn from her example! <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Let's summarize what we found: <br><br><ol><li>  Loaders have a non-obvious API, but they allow you to save the download result when the configuration changes </li><li>  Loaders do not cause memory leaks: just don't make them nested classes. Activity </li><li>  Loaders allow you to reuse AsyncTask in a background job, but you can also implement your own Loader </li><li>  LoaderManager is reused between deleted and newly created Activity due to saving to a special object. </li></ol><br>  In the next article we will talk about how to organize background work on Executors, and mix in a bit of EventBus.  Stay tuned! <br><blockquote>  Minute advertising. <br>  From the author of the text: <br><br>  As you noticed, this is a translation of my English-language <a href="https://proandroiddev.com/android-background-in-a-nutshell-part-ii-loaders-f763f70fdd15">article</a> .  If the article seemed valuable to you, pay attention - in April there will be a <b>Mobius</b> conference, in whose program committee I enter, and I can promise that this year the program will be particularly rich.  Only a part of the program has been published on <a href="https://mobiusconf.com/">the conference site</a> so far, because it is extremely difficult for us to choose the best ones - the competition is more acute than ever.  You can already study the existing descriptions of the reports, and soon new ones will be added to them! <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/350094/">https://habr.com/ru/post/350094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350082/index.html">Hana kitten. Why do employees hate CRM?</a></li>
<li><a href="../350084/index.html">Designing reliable databases. Chapter 1. Introduction</a></li>
<li><a href="../350086/index.html">Epic Growth Conference 2018 - grocery marketing conference in Moscow</a></li>
<li><a href="../350090/index.html">3D Facebook posts: what and how</a></li>
<li><a href="../350092/index.html">How the implementation of trading systems with artificial intelligence will affect investment management</a></li>
<li><a href="../350096/index.html">Parallel Programming in Swift: Operations</a></li>
<li><a href="../350098/index.html">Second breath multimode</a></li>
<li><a href="../350100/index.html">How to come up with ideas for patents</a></li>
<li><a href="../350102/index.html">How we searched for a translator in the section "Songs"</a></li>
<li><a href="../350104/index.html">Innovative 3D XPoint memory: technology potential and development prospects</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>