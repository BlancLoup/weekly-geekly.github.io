<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using the Chromium project codebase as an SDK for developing cross-platform applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In addition to fully understandable official documentation ( Chromium Wiki ), there are articles on how to get the source code and build the Chromium ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using the Chromium project codebase as an SDK for developing cross-platform applications</h1><div class="post__text post__text-html js-mediator-article">  In addition to fully understandable official documentation ( <a href="https://www.chromium.org/developers/how-tos">Chromium Wiki</a> ), there are articles on how to get the source code and build the Chromium project ( <a href="https://habrahabr.ru/post/165193/">for example</a> ). <br><br>  I wanted to talk about how, based on this code, you can create C ++ applications that can be compiled and run on several operating systems and architectures.  Of course, libraries already exist for this purpose, such as <a href="http://www.qt.io/">Qt</a> and <a href="http://www.boost.org/">boost</a> .  But this is precisely why this article is related to the 'abnormal programming' section, because no one seriously considers Chromium code as the basis for a cross-platform application. <br><a name="habracut"></a><br>  However, if you think about it, it becomes clear that this is quite possible, and not even very difficult. <br>  After all, in the Chromium project there is an assembly system, with the help of which both the project itself and all <br>  the necessary dependencies.  Libraries like <a href="https://boringssl.googlesource.com/boringssl/">boringssl</a> , <a href="https://www.ffmpeg.org/">ffmpeg</a> , <a href="http://www.freetype.org/">freetype2</a> , <a href="https://hunspell.github.io/">hunspell</a> , <a href="http://site.icu-project.org/">ICU</a> , <a href="https://github.com/open-source-parsers/jsoncpp">jsoncpp</a> , <a href="http://libjpeg.sourceforge.net/">libjpeg</a> , libxml, <a href="http://www.openh264.org/">openh264</a> , <a href="https://developers.google.com/protocol-buffers/">protobuf</a> , <a href="https://github.com/google/googletest">gtest</a> , <a href="https://www.sqlite.org/">sqlite</a> and, of course, <a href="https://developers.google.com/v8/">v8</a> , are delivered, updated and easily connected for use. <br><br>  The Chromium team has written such components as logging, strings and internationalization, working with application resources (strings, images, binary data), working with networks and files, graphics, including 3D, IPC, UI framework for several platforms, and much more. still.  All this is covered by a large number of tests (although not one hundred percent), including performance tests. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I note, I am not trying to prove that this is better than any library you know, faster, more convenient, or just clear your karma.  No, this is just an experiment and to some extent a story about what makes up such a complex and large project as a modern browser. <br><br>  So I decided to show how you can create a small application that demonstrates working with some entities from <a href="https://code.google.com/p/chromium/codesearch">the Chromium core library</a> . <br>  If this material seems interesting, it will be possible to take a closer look at working with the network, graphics, UI and others.  This is not a reference to the existing API in Chromium, but rather a demonstration of how to work with the basic things that are needed in almost any program. <br>  It is necessary to take into account the fact that the code base is constantly changing, some parts are more subject to change, some less.  This is still not a fixed public API. <br><br>  I will not dwell on how to download the code and set up the environment, all this is described in detail in the articles on the links provided.  We assume that we already have depot_tools in our $ PATH (we need the gn and ninja utilities), the source code has been received and is ready for assembly in the chromium / directory.  Build the entire project Chromium we do not need, at least in the first stage. <br><br>  Create the chromium / src directory of our application, sample_app and sample_app / src. <br>  The application code will be placed in sample_app / src, and I will list all the commands relative to the current chromium / src / sample_app directory. <br><br>  To get all the application code from the article at once, you can clone the repository <a href="">https://github.com/dreamer-dead/chromium-sample-app.git</a> <br><br><pre><code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">pwd</span></span> /Users/username/chromium/src $ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/dreamer-dead/chromium-sample-app.git sample_app $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> sample_app/</code> </pre> <br>  Let's start with the entry point of our application and the base config for the build system. <br><br>  <a href="">src / sample_app.cc</a> <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  <a href="">src / BUILD.gn</a> <br><br><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta"># SampleApp executable(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sample_app"</span></span></span><span class="hljs-meta">) { output_name = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sample_app"</span></span></span><span class="hljs-meta"> sources = [ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sample_app.cc"</span></span></span><span class="hljs-meta">, ] }</span></span></code> </pre> <br>  Chromium uses tools such as <a href="https://gyp.gsrc.io/">GYP</a> and <a href="https://chromium.googlesource.com/chromium/src/tools/gn/">GN</a> to generate <a href="https://ninja-build.org/">ninja</a> files describing the steps involved in building a project.  GN is the next stage in the development of the ninja file generator, it is much faster than GYP, written in C ++ instead of Python, and its syntax is friendlier to humans.  So we‚Äôll use it, although at the moment Chromium supports building with GYP too. <br><br>  In your build config sample_app / src / BUILD.gn we set the name of the target, the final name of the executable file and enumerate the files with the source code.  Looks pretty clear, right? <br>  Though all small files of configs look clear, even CMake, though Makefile. <br><br>  In order for GN to see the configuration of our project, you need to refer to it in the root file chromium / src / BUILD.gn, putting such a patch <br><br><div class="spoiler">  <b class="spoiler_title">Diff for root patch BUILD.gn</b> <div class="spoiler_text">  <a href="https://github.com/dreamer-dead/chromium-sample-app/blob/436cd3beadcf4bfd82c9c174eebe6d95310b809b/src/root_BUILD_gn.patch">src / root_BUILD_gn.patch</a> <br><br><pre> <code class="diff hljs">diff --git a/BUILD.gn b/BUILD.gn index 0fa2013..729157d 100644 --- a/BUILD.gn +++ b/BUILD.gn @@ -906,3 +906,7 @@ template("assert_valid_out_dir") { assert_valid_out_dir("_unused") { actual_sources = [ "$root_build_dir/foo" ] } + +group("sample_app") { + deps = [ "//sample_app/src:sample_app" ] +}</code> </pre> <br></div></div><br>  If a repository checkout has been made, then you can run the command <br><br><pre> <code class="bash hljs">$ (<span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> .. &amp;&amp; git apply sample_app/src/root_BUILD_gn.patch)</code> </pre> <br>  After adding our target to the general build config we can build our application. <br><br><pre> <code class="bash hljs">$ gn gen --args=is_debug=<span class="hljs-literal"><span class="hljs-literal">true</span></span> --root=../ ../out/gn $ ninja -C ../out/gn sample_app</code> </pre> <br>  Thus, we have indicated that we are assembling a debug build, we generate ninja build files in the chromium / src / out / gn / directory and the root build config is located in chromium / src / <br><br>  Let's add console output to our application and show that at least the standard C ++ library is available to us. <br><br>  <a href="">src / sample_app.cc</a> <br><br><pre> <code class="hljs go">#include &lt;iostream&gt; #include &lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argc, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> char* argv[]) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from SampleApp!"</span></span> &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Repeating the build command and running the application, we should see our greeting: <br><br><pre> <code class="bash hljs">$ ninja -C ../out/gn sample_app $ ../out/gn/sample_app Hello from SampleApp!</code> </pre> <br>  One of the base classes in any application is a string.  Chromium uses the class string from the C ++ library, std :: basic_string &lt;&gt;, UTF16 strings are used to a large extent ( <a href="https://code.google.com/p/chromium/codesearch">base :: string16</a> , this is typedef for std :: basic_string) and lightweight string-view class <a href="https://code.google.com/p/chromium/codesearch">base :: StringPiece</a> . <br>  Let's try using strings and conversions between different encodings. <br><br>  <a href="">src / sample_app.cc</a> <br><br><pre> <code class="hljs rust">#include &lt;iostream&gt; #include &lt;string&gt; #include <span class="hljs-string"><span class="hljs-string">"base/strings/utf_string_conversions.h"</span></span> namespace { void StringsSample() { std::cout &lt;&lt; base::WideToUTF8(L<span class="hljs-string"><span class="hljs-string">"This is a wide string."</span></span>) &lt;&lt; std::endl; std::wcout &lt;&lt; base::UTF8ToWide(<span class="hljs-string"><span class="hljs-string">"This is an UTF8 string."</span></span>) &lt;&lt; std::endl; std::cout &lt;&lt; base::UTF16ToUTF8(base::UTF8ToUTF16( <span class="hljs-string"><span class="hljs-string">"This is an UTF8 string converted to UTF16 and back."</span></span>)) &lt;&lt; std::endl; } } <span class="hljs-comment"><span class="hljs-comment">// namespace int main(int argc, const char* argv[]) { std::cout &lt;&lt; "Hello from SampleApp!" &lt;&lt; std::endl; StringsSample(); return 0; }</span></span></code> </pre> <br>  <a href="https://github.com/dreamer-dead/chromium-sample-app/commit/bc6516173752fc9959fabbba54aedf99e330b417">src / BUILD.gn</a> <br><br><pre> <code class="hljs objectivec">executable(<span class="hljs-string"><span class="hljs-string">"sample_app"</span></span>) { output_name = <span class="hljs-string"><span class="hljs-string">"sample_app"</span></span> sources = [ <span class="hljs-string"><span class="hljs-string">"sample_app.cc"</span></span>, ] deps = [ <span class="hljs-string"><span class="hljs-string">"//base"</span></span> ] }</code> </pre> <br>  We have added the desired dependence on target <code>//base</code> in BUILD.gn and were able to use the necessary functions. <br>  As you can see, nothing complicated, the <a href="http://site.icu-project.org/">ICU</a> library is responsible for all the work under the hood, which is available to us without any additional actions. <br><br>  The build command doesn't change, <br><br><pre> <code class="bash hljs">$ ninja -C ../out/gn sample_app</code> </pre> <br>  Ninja automatically rebuilds files when changing .gn config. <br><br>  From the lines you can go to the command line of the application and parse it. <br>  Please keep in mind that the entire class code in src / base was written exactly for the needs that the Chromium team had.  If it seems strange to you that there is no functionality, or, on the contrary, that redundant code is written, consider this. <br><br>  <a href="">src / sample_app.cc</a> <br><br><pre> <code class="hljs rust">#include <span class="hljs-string"><span class="hljs-string">"base/command_line.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"base/files/file_path.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"base/logging.h"</span></span> void CommandLineSample() { using base::CommandLine; DCHECK(CommandLine::ForCurrentProcess()) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Command line for process wasn't initialized."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CommandLine&amp; command_line = *CommandLine::ForCurrentProcess(); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Application program name is "</span></span> &lt;&lt; command_line.GetProgram().AsUTF8Unsafe() &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (command_line.HasSwitch(<span class="hljs-string"><span class="hljs-string">"bool-switch"</span></span>)) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Detected a boolean switch!"</span></span> &lt;&lt; std::endl; } std::string string_switch = command_line.GetSwitchValueASCII(<span class="hljs-string"><span class="hljs-string">"string-switch"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!string_switch.empty()) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Got a string switch value: "</span></span> &lt;&lt; string_switch &lt;&lt; std::endl; } } int main(int argc, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>* argv[]) { CHECK(base::CommandLine::Init(argc, argv)) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Failed to parse a command line argument."</span></span>; std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from SampleApp!"</span></span> &lt;&lt; std::endl; StringsSample(); CommandLineSample(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Now we can run the compiled program with keys and look at the output: <br><br><div class="spoiler">  <b class="spoiler_title">Run with different command line keys</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ ninja -C ../out/gn sample_app $ ../out/gn/sample_app --bool-switch --string-switch=SOME_VALUE Hello from SampleApp! This is a wide string. This is an UTF8 string. This is an UTF8 string converted to UTF16 and back. Application program name is ../out/gn/sample_app Detected a boolean switch! Got a string switch value: SOME_VALUE</code> </pre> <br></div></div><br>  It demonstrates simultaneously classes for working with the command line, an abstraction for file paths and a little with the logging library.  So, the call <a href="https://code.google.com/p/chromium/codesearch">CHECK ()</a> will check the result of the call <a href="https://code.google.com/p/chromium/codesearch">CommandLine :: Init</a> and in case of failure it will print the line "Failed to parse a command line argument."  and complete the application.  In this case, if successful, the <code>operator &lt;&lt;</code> for the log stream will not be called and there will be no overhead costs for printing.  This is important if such logging is associated with calling non-trivial functions. <br><br>  The <a href="https://code.google.com/p/chromium/codesearch">DCHECK (debug check) check</a> will be performed only in the debug build and will not affect the program execution in the release. <br><br>  Continuing to talk about the program log, consider the following code, including and using logging <br><br>  <a href="https://github.com/dreamer-dead/chromium-sample-app/commit/8f1177e5380385c86bdbc7d17417c3291ecf5a34">src / sample_app.cc</a> <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> LoggingSample() { logging::LoggingSettings settings; // <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">log</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> STDERR <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> POSIX <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> OutputDebugString <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> Windows. settings.logging_dest = logging::LOG_TO_SYSTEM_DEBUG_LOG; <span class="hljs-keyword"><span class="hljs-keyword">CHECK</span></span>(logging::InitLogging(settings)); // <span class="hljs-keyword"><span class="hljs-keyword">Log</span></span> messages visible <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>. LOG(<span class="hljs-keyword"><span class="hljs-keyword">INFO</span></span>) &lt;&lt; "This is INFO log message."; LOG(<span class="hljs-built_in"><span class="hljs-built_in">WARNING</span></span>) &lt;&lt; "This is WARNING log message."; // <span class="hljs-keyword"><span class="hljs-keyword">Verbose</span></span> <span class="hljs-keyword"><span class="hljs-keyword">log</span></span> messages, disabled <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>. VLOG(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; "This is a log message with verbosity == 1"; VLOG(<span class="hljs-number"><span class="hljs-number">2</span></span>) &lt;&lt; "This is a log message with verbosity == 2"; // <span class="hljs-keyword"><span class="hljs-keyword">Verbose</span></span> messages, can be enabled <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">debug</span></span> build. DVLOG(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; "This is a DEBUG log message with verbosity == 1"; DVLOG(<span class="hljs-number"><span class="hljs-number">2</span></span>) &lt;&lt; "This is a DEBUG log message with verbosity == 2"; // FATAL <span class="hljs-keyword"><span class="hljs-keyword">log</span></span> message will terminate our app. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (base::CommandLine::ForCurrentProcess()-&gt;HasSwitch("log-fatal")) { LOG(FATAL) &lt;&lt; "Program will terminate now!"; } }</code> </pre> <br>  Here we first initialize the logging subsystem for recording in STDERR, and then output the messages to the log with different levels. <br>  The last message with the FATAL level will terminate the execution of the program, and display the stack-trace if it can. <br>  Add a call to the <code>LoggingSample()</code> function in <code>main()</code> and check the operation of the program with the specified logging level (output is on Mac OS X): <br><br><div class="spoiler">  <b class="spoiler_title">Run with different logging levels</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ ninja -C ../out/gn sample_app $ ../out/gn/sample_app --v=2 --<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>-fatal Hello from SampleApp! This is a wide string. This is an UTF8 string. This is an UTF8 string converted to UTF16 and back. Application program name is ../out/gn/sample_app [0303/202541:INFO:sample_app.cc(51)] This is INFO <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> message. [0303/202541:WARNING:sample_app.cc(52)] This is WARNING <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> message. [0303/202541:VERBOSE1:sample_app.cc(55)] This is a <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> message with verbosity == 1 [0303/202541:VERBOSE2:sample_app.cc(56)] This is a <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> message with verbosity == 2 [0303/202541:VERBOSE1:sample_app.cc(59)] This is a DEBUG <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> message with verbosity == 1 [0303/202541:VERBOSE2:sample_app.cc(60)] This is a DEBUG <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> message with verbosity == 2 [0303/202541:FATAL:sample_app.cc(64)] Program will terminate now! 0 sample_app 0x000000010f276def _ZN4base5debug10StackTraceC2Ev + 47 1 sample_app 0x000000010f276f93 _ZN4base5debug10StackTraceC1Ev + 35 2 sample_app 0x000000010f2b53a0 _ZN7logging10LogMessageD2Ev + 80 3 sample_app 0x000000010f2b2c43 _ZN7logging10LogMessageD1Ev + 35 4 sample_app 0x000000010f235072 _ZN12_GLOBAL__N_113LoggingSampleEv + 1346 5 sample_app 0x000000010f2342e0 main + 288 6 sample_app 0x000000010f2341b4 start + 52 7 ??? 0x0000000000000003 0x0 + 3 Trace/BPT <span class="hljs-built_in"><span class="hljs-built_in">trap</span></span>: 5 $ ../out/gn/sample_app Hello from SampleApp! This is a wide string. This is an UTF8 string. This is an UTF8 string converted to UTF16 and back. Application program name is ../out/gn/sample_app [0303/203145:INFO:sample_app.cc(51)] This is INFO <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> message. [0303/203145:WARNING:sample_app.cc(52)] This is WARNING <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> message.</code> </pre> <br></div></div><br>  You can also see that there is a rather tough, but useful rule - for each entity / class there is one file whose name corresponds to files with code.  So, the FilePath class should be searched in the header file <a href="https://code.google.com/p/chromium/codesearch">base / files / file_path.h</a> , and its implementation is in <a href="https://code.google.com/p/chromium/codesearch">base / files / file_path.cc</a> . <br>  This makes it very easy to navigate through the code and find the necessary classes and functions. <br><br>  Let's look at more complex code, for example, to list the contents of the current directory. <br><br>  <a href="https://github.com/dreamer-dead/chromium-sample-app/commit/35fc08630869c08f4baa52fa5b3445212fc48926">src / sample_app.cc</a> <br><br><pre> <code class="hljs rust">#include <span class="hljs-string"><span class="hljs-string">"base/files/file_enumerator.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"base/files/file_util.h"</span></span> void FilesSample() { base::FilePath current_dir; CHECK(base::GetCurrentDirectory(&amp;current_dir)); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Enumerating files and directories in path: "</span></span> &lt;&lt; current_dir.AsUTF8Unsafe() &lt;&lt; std::endl; base::FileEnumerator file_enumerator( current_dir, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, base::FileEnumerator::FILES | base::FileEnumerator::DIRECTORIES); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (base::FilePath name = file_enumerator.Next(); !name.empty(); name = file_enumerator.Next()) { std::cout &lt;&lt; (file_enumerator.GetInfo().IsDirectory() ? <span class="hljs-string"><span class="hljs-string">"[dir ] "</span></span> : <span class="hljs-string"><span class="hljs-string">"[file] "</span></span>) &lt;&lt; name.AsUTF8Unsafe() &lt;&lt; std::endl; } }</code> </pre> <br>  And just add to <code>main()</code> . <br>  As you can see, using the <a href="https://code.google.com/p/chromium/codesearch">base :: FileEnumerator class is</a> not difficult, and as a result we were able to get a list of files in the current directory: <br><br><div class="spoiler">  <b class="spoiler_title">Application output</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ ninja -C ../out/gn sample_app $ (<span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> src/ &amp;&amp; ../../out/gn/sample_app) Hello from SampleApp! This is a wide string. This is an UTF8 string. This is an UTF8 string converted to UTF16 and back. Application program name is ../../out/gn/sample_app [0303/203629:INFO:sample_app.cc(51)] This is INFO <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> message. [0303/203629:WARNING:sample_app.cc(52)] This is WARNING <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> message. Enumerating files and directories <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> path: /Users/username/chromium/src/sample_app/src [file] /Users/username/chromium/src/sample_app/src/BUILD.gn [file] /Users/username/chromium/src/sample_app/src/sample_app.cc</code> </pre> <br></div></div><br>  Usually the program consists not only of the main.cc file, so let's add a standalone module for a certain API to our project.  The essence of the code in the new module is not so important now, it's a demonstration, you can always return true, for example. <br>  Create a header file and a file with the implementation of our new function: <br><br>  <a href="">src / sample_api.h</a> <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SAMPLE_APP_SAMPLE_API_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SAMPLE_APP_SAMPLE_API_H_ namespace sample_api { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Do some black magic. bool CallApiFunction(); } // namespace sample_api #endif // SAMPLE_APP_SAMPLE_API_H_</span></span></span></span></code> </pre> <br>  <a href="">src / sample_api.cc</a> <br><br><pre> <code class="hljs kotlin">#include <span class="hljs-string"><span class="hljs-string">"sample_app/src/sample_api.h"</span></span> namespace sample_api { bool CallApiFunction() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">// namespace sample_api</span></span></code> </pre> <br>  After that you can write unit tests for our function. <br>  Do this and add new files to our project. <br><br><div class="spoiler">  <b class="spoiler_title">Our test code</b> <div class="spoiler_text">  <a href="">src / sample_api_unittest.cc</a> <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sample_app/src/sample_api.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"testing/gtest/include/gtest/gtest.h"</span></span></span><span class="hljs-meta"> namespace sample_api { namespace { TEST(SampleApi, ApiFunctionTest) { EXPECT_TRUE(CallApiFunction()); } } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// namespace } // namespace sample_api</span></span></span></span></code> </pre> <br>  <a href="">src / BUILD.gn</a> <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">"//testing/test.gni"</span></span>) executable(<span class="hljs-string"><span class="hljs-string">"sample_app"</span></span>) { output_name = <span class="hljs-string"><span class="hljs-string">"sample_app"</span></span> sources = [ <span class="hljs-string"><span class="hljs-string">"sample_app.cc"</span></span>, <span class="hljs-string"><span class="hljs-string">"sample_api.cc"</span></span>, <span class="hljs-string"><span class="hljs-string">"sample_api.h"</span></span>, ] deps = [ <span class="hljs-string"><span class="hljs-string">"//base"</span></span>, ] } test(<span class="hljs-string"><span class="hljs-string">"sample_app_unittests"</span></span>) { sources = [ # TODO: Extract these API files <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> a library. <span class="hljs-string"><span class="hljs-string">"sample_api.cc"</span></span>, <span class="hljs-string"><span class="hljs-string">"sample_api.h"</span></span>, <span class="hljs-string"><span class="hljs-string">"sample_api_unittest.cc"</span></span>, ] deps = [ <span class="hljs-string"><span class="hljs-string">"//base/test:run_all_unittests"</span></span>, <span class="hljs-string"><span class="hljs-string">"//testing/gtest"</span></span>, ] }</code> </pre> <br></div></div><br>  Using the GTest library is fairly straightforward, but you need to add the dependency "// testing / gtest" to the project, and for convenience also the "// base / test: run_all_unittests".  This will save us from having to write code to run the project tests, the code in src / base / test / run_all_unittests.cc will be responsible for this. <br><br>  Re-generate ninja files for the project and collect our tests: <br><br><pre> <code class="bash hljs">$ ninja -C ../out/gn sample_app_unittests</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Run the tests:</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ ../out/gn/sample_app_unittests IMPORTANT DEBUGGING NOTE: batches of tests are run inside their own process. For debugging a <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> inside a debugger, use the --gtest_filter=&lt;your_test_name&gt; flag along with --single-process-tests. Using sharding settings from environment. This is shard 0/1 Using 8 parallel <span class="hljs-built_in"><span class="hljs-built_in">jobs</span></span>. [1/1] SampleApi.ApiFunctionTest (0 ms) SUCCESS: all tests passed. Tests took 0 seconds.</code> </pre> <br></div></div><br>  Great, all tests passed! <br>  After the tests are written, and the code of our API is added to the project, you can use it. <br><br>  <a href="https://github.com/dreamer-dead/chromium-sample-app/commit/7d11c6f89810596fa3f855ae71c3f5838ab8cd92">src / sample_app.cc</a> <br><br><pre> <code class="hljs rust">#include <span class="hljs-string"><span class="hljs-string">"sample_app/src/sample_api.h"</span></span> void UseSampleAPI() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sample_api::CallApiFunction()) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Magick!"</span></span> &lt;&lt; std::endl; } }</code> </pre> <br>  Just like that. <br>  As a result, our program can work with different encodings, with the file system, parses its command line, is able to report in the error log and uses the new code with test coverage approaching 100%. <br>  At the same time, the build-config of the project is very small and readable, and compiled and executed <br>  the code can on different platforms, and without a single #ifdef in our code. <br>  Isn't it great? <br><br>  Of course, to use the whole arsenal of classes available in the project, you will need to read a lot <br>  code and documentation (which is sometimes the same thing), or ask in mailings, because no special <br>  There are no training materials, API reference books and ready-made examples. <br>  Moreover, the code base is alive and constantly changing, albeit for the better. <br>  So again, everything you read should be used at your own risk =) <br><br>  The article and so it turned out much longer than I expected, so that's all for now. <br>  Thank you for reading! <br><br><h6>  Links </h6><br><ul><li>  <a href="https://www.chromium.org/developers/how-tos">Chromium Dev How-To</a> </li><li>  <a href="https://habrahabr.ru/post/165193/">Article on Habrahabr how to collect Chromium</a> </li><li>  <a href="">Repository with article code</a> <br></li></ul><br></div><p>Source: <a href="https://habr.com/ru/post/278579/">https://habr.com/ru/post/278579/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278569/index.html">Critical vulnerability of Cisco Nexus 3000 Series Switches and 3500 Platform allows remote access to them</a></li>
<li><a href="../278571/index.html">Preparing an ASP.NET 5 (Core) project and DNX environment to participate in the hackathon as part of hack.summit () 2016 at Koding.com</a></li>
<li><a href="../278573/index.html">Adaptive Split View Controller and Popover in iOS 9 (Swift). Part 1</a></li>
<li><a href="../278575/index.html">Superscalar Stacking Processor: We Cross Horror And Hedgehog</a></li>
<li><a href="../278577/index.html">Automation of easy database 1C list management</a></li>
<li><a href="../278581/index.html">History of Chatto</a></li>
<li><a href="../278583/index.html">Work with FireBird from 1C. Collection of proven recipes</a></li>
<li><a href="../278585/index.html">Margaret Hamilton: "Guys, I'll send you to the moon"</a></li>
<li><a href="../278589/index.html">libuniset2 is a library for creating ACS. It‚Äôs better to see once ... Part 4 (Adjustment)</a></li>
<li><a href="../278593/index.html">We get acquainted with web standards. Work with audio. - Video and creation history</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>