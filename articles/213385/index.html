<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tai'Dzen: first steps</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dear habrasoobschestvu, welcome! 
 In this article I would like to share a bit of my modest experience on the path of learning Tai'Dzen (or Tizen). Ho...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tai'Dzen: first steps</h1><div class="post__text post__text-html js-mediator-article"> Dear habrasoobschestvu, welcome! <br>  In this article I would like to share a bit of my modest experience on the path of learning Tai'Dzen (or Tizen).  How to join the Truth, I, to the best of my understanding, tried to describe in a <a href="http://habrahabr.ru/post/205046/">previous publication</a> .  Being true to my promises, I continue the series of articles. <br>  The article is divided into three parts and is built as a step-by-step guide to the development of a simple native application for maintaining a shopping list.  In the first part, the structure of a typical Tizen project, some approaches to the design of the application architecture, as well as the peculiarities of working with a WYSIWYG GUI editor are examined in detail.  In the <a href="http://habrahabr.ru/company/kamagames/blog/213605/">second</a> part, work with scenes and the scene editor, with lists of graphic controls (controls), their customization and event handling are considered.  The third part shows the organization of the search and use of the database.  The article provides a link to the git-repository, the text shows the labels on the corresponding commits.  The material is intended for readers who are familiar with C ++ and have no experience with the Tizen SDK.  For those who hear about Tizen for the first time, I recommend to get acquainted with the article mentioned above (it describes in detail the process of installing IDE and launching ‚ÄúHello, world!‚Äù On the target device / emulator).  Experience with mobile platforms does not hurt, but is not required, so welcome under cat. <br><a name="habracut"></a><br>  <b>PART ONE</b> <br><br>  Before embarking on developing an application for a new platform, it is necessary to become familiar with the main guidelines from its creators.  In the case of Tizen, the vast majority of those are in the documentation supplied as part of the SDK.  Thus, there is a chance to achieve enlightenment in Tai'Dzen even without the help of Google.  However, in practice, the neophyte is faced with a number of features that are a serious test of his willpower and determination.  These features are not so complicated, they just become apparent after all the available rakes have been put into action.  Actually, as soon as the adept deals with another surprise, he immediately finds its description in the documentation.  Or does not find.  To comprehend Tai'Dzen you can only cease to strive for his comprehension.  Therefore, we proceed directly to the practice. <br><img src="https://habrastorage.org/getpro/habr/post_images/483/b85/654/483b8565490cdd3f5b667c49c621a64b.jpg"><br>  Fig.  by Leka <br><br>  Launch the Tizen IDE, create a new Tizen Native Project: on the Template tab, select Tab-based Application, a subtype With SceneManager. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/891/b62/e0f/891b62e0fd95d1e811c87505ba67a37f.png"><br><br>  For the current task, the Form-based Application is also suitable, we use it if more complicated customization of the GUI is required (that is, in most commercial projects, ours is a training one).  SceneManager allows you to conveniently manage forms (screens): activate / delete forms, transition history between them, determine the current form, etc.  SceneManager naturally integrates into the MVC design pattern, where the form is just a feedback control panel, i.e.  View. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c3/93c/2ee/7c393c2ee4b9caf936784c51fcc88d32.png"><br><br>  With the help of SceneManager, the Controller (Controller) activates the ‚Äúconsole‚Äù, then receives and processes its signals, and stores the results of the calculations in the Model.  After making the calculations, the Controller sends a ‚Äúrefresh this‚Äù message to View, in response to which the View requests its status from the Model and displays it on the screen.  The model in this scheme is the most ‚Äúpowerless‚Äù element: its task is only to provide data to the controller and View in a convenient form (controller for modification, View is read-only).  It is possible that such a free interpretation of the MVC pattern will not find support in academic circles, but I successfully use it in practice. <br><br>  We assemble the project and run it on the target device / emulator (the process is described in my <a href="http://habrahabr.ru/post/205046/">previous</a> article).  Do not forget about <a href="http://habrahabr.ru/post/196594/">setting up</a> security <a href="http://habrahabr.ru/post/196594/">certificates</a> , otherwise you will not be able to start the application. <br><br>  Consider the structure of the project that the IDE generated from the Tab-based Application pattern.  To navigate through the project files, use the Project Explorer window (Window -&gt; Show View -&gt; Project Explorer). <br><br>  I gave the project the name ShoppingList. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c9b/0d5/893/c9b0d5893194184bedec1d67b61efe73.png"><br><br>  The application / shared icon is stored in the shared / res directory.  The icon for HD screens is contained in the subdirectory screen-density-xhigh.  Its size should be 117x117 pixels, the lighting is necessarily top, only round (PNG 32 bits with alpha channel).  If these requirements are violated, the application will not be certified by the Tizen Store.  The documentation also states that for WVGA screens, the icon size should be 78x78 pixels, but there are no devices with such screens yet.  I once tried to make a separate icon for WVGA devices, put it in a separate subdirectory of screen-density-wvga, checked it on the emulator, and ... the application did not pass certification due to the ‚Äúincorrect icon size‚Äù.  Therefore, in the near future, we can limit ourselves to one icon for HD screens. <br><br>  Spaces in the names of projects are not allowed, however, it is possible to insert a space into the displayed application name in the project settings.  Settings are stored in a special project file manifest.xml, which by default is automatically opened using the Tizen Manifest Editor utility. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/78c/fac/9ae/78cfac9aeee04452e3856f5a9b9eadb6.png"><br><br>  For each locale, you can specify a separate name in the appropriate language.  Also, among other things, the manifest indicates the permissions (privileges) that the application requests from the OS.  Attempts by the application to call the ‚Äúundeclared‚Äù functions of the OS are harshly suppressed at all levels, starting from a local launch on the target device and ending with the moderation process in the Tizen Store. <br><br>  The res directory stores application resources: images, audio recordings, as well as GUI description xml files.  When the application is running, these xml files are used by the GUI framework to build forms, panels, buttons, and other GUI components (controls).  They are formed using the Tizen UI Builder WYSIWYG editor, it also links up the process of visual building interfaces with the automatic code generation system (more later in the article). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/006/a20/78f/006a2078f8be9889228f5734a7fa23e8.png"><br><br>  The <a href="https://developer.tizen.org/dev-guide/2.2.1/org.tizen.native.appprogramming/html/multiple_screen/autoscale_resource_fallback.htm">documentation</a> contains a lot of text on the subject in which subdirectories to allocate resources.  The text makes a depressing impression: the choice of a subdirectory is influenced by pixel density, screen size, type of coordinate system (logical or physical, indicated in the manifest), etc.  However, at the moment in the Tizen Store it is proposed to indicate in the list of supported single resolution 720x1280 (ie HD), which in practice means using the screen-size-normal subdirectory.  The type of the coordinate system does not matter. <br><br>  In the data directory, we will store local data, since the application is read-only without any restrictions by the OS.  The lib directory, as the name implies, is intended for storing libraries, the Debug directory contains object files, appears after compilation (if compiled in Release mode, a directory named Release will be added). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b9/fc9/11d/7b9fc911dad4529d463d6fb51da99032.png"><br><br>  The inc and src directories contain header files and source code respectively.  At the same time, they can store both their own files and links to files from other places of the workstation's file system.  The link is convenient if several projects use the same source code, which often changes (i.e. there is no point in collecting it into the library).  Add a link conveniently by dragging files from Explorer / Finder / etc.  in the Project Explorer. <br><br>  Consider the process of deploying an application in RAM. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/021/5dd/9a3/0215dd9a31727b6b7ac5f9c9764bf88d.png"><br><br>  The application entry point is contained in the file ShoppingListEntry.cpp, in the OspMain function. <br><br><pre><code class="cpp hljs">_<span class="hljs-function"><span class="hljs-function">EXPORT_ </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OspMain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pArgv[])</span></span></span><span class="hljs-function"> </span></span>{ AppLog(<span class="hljs-string"><span class="hljs-string">"Application started."</span></span>); <span class="hljs-function"><span class="hljs-function">ArrayList </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SingleObjectDeleter)</span></span></span></span>; args.Construct(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; argc; i++) { args.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::nothrow) String(pArgv[i])); } result r = Tizen::App::UiApp::Execute(ShoppingListApp::CreateInstance, &amp;args); TryLog(r == E_SUCCESS, <span class="hljs-string"><span class="hljs-string">"[%s] Application execution failed."</span></span>, GetErrorMessage(r)); AppLog(<span class="hljs-string"><span class="hljs-string">"Application finished."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt;(r); }</code> </pre> <br><br>  In this function, the main object of the application is formed, which contains the loop for processing system events and user interface events.  The class of this object in our case is called ShoppingListApp and is inherited from the system class Tizen :: App :: UiApp, which encapsulates the mentioned event-loop.  One of the events whose handlers are overridden in the ShoppingListApp class is the OnAppInitialized () event. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ShoppingListApp::OnAppInitialized(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { ShoppingListFrame* pShoppingListFrame = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::nothrow) ShoppingListFrame; TryReturn(pShoppingListFrame != null, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"The memory is insufficient."</span></span>); pShoppingListFrame-&gt;Construct(); pShoppingListFrame-&gt;SetName(<span class="hljs-string"><span class="hljs-string">L"ShoppingList"</span></span>); AddFrame(*pShoppingListFrame); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><br>  It occurs immediately after the launch of the application and means that the system is ready to start executing custom code.  The root unit of the main GUI, the frame, is formed in the handler of this event.  Generally, since pop-up panels and notifications are at the same level of hierarchy.  The frame is customized according to the same scheme as the heir to the App class, in turn, is called ShoppingListFrame.  In the OnInitializing () frame initialization event handler, a SceneManager is formed. <br><br><pre> <code class="cpp hljs">result ShoppingListFrame::OnInitializing(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { SceneManager* pSceneManager = SceneManager::GetInstance(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ShoppingListFormFactory formFactory; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ShoppingListPanelFactory panelFactory; pSceneManager-&gt;RegisterFormFactory(formFactory); pSceneManager-&gt;RegisterPanelFactory(panelFactory); pSceneManager-&gt;RegisterScene(<span class="hljs-string"><span class="hljs-string">L"workflow"</span></span>); result r = pSceneManager-&gt;GoForward(SceneTransitionId(IDSCNT_START)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre><br><br>  SceneManager requires access to factories of GUI components (forms and panels), as well as a list of ‚Äúscenes‚Äù.  A scene is a combination of a form and a panel displayed on the screen at a single moment.  Each scene has its own string identifier, the presence of a form for the scene is necessary, but the panel is optional. <br>  Scene registration can occur directly by calling the <code>SceneManager::RegisterScene(const SceneId &amp;sceneId, const Tizen::Base::String &amp;formId, Tizen::Base::String &amp;panelId)</code> method <code>SceneManager::RegisterScene(const SceneId &amp;sceneId, const Tizen::Base::String &amp;formId, Tizen::Base::String &amp;panelId)</code> and indirectly, through loading the SceneManager xml-file with the description of the scenes <code>SceneManager::RegisterScene(const Tizen::Base::String &amp;resourceId)</code> . <br><br>  In this case, it is the workflow.xml file, which is contained in the res / screen-size-normal directory.  When using this method, not only scenes are recorded, but also transitions between scenes, which is somewhat unclear.  The <code>SceneManager::GoForward</code> method just activates such a transition (transaction) through its string identifier IDSCNT_START. <br>  Identifiers for transition commands, scenes, forms, panels, etc.  are formed using the UI Builder and placed by the code generation system in the AppResourceId file.  It would be logical to expect that the name of the resource scene description file workflow.xml will also automatically be placed in the AppResourceId, but this does not happen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ca/4af/776/6ca4af7762427b3c2abefa8a2a1d7fb3.png"><br><br>  SceneManager obtains transition identifiers from user code and determines form and panel identifiers on their basis.  Form and panel factories issue a ‚Äúproduct‚Äù to SceneManager using these identifiers.  Then SceneManager mounts the form into a frame, the panel onto the form and starts rendering. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d39/389/53d/d3938953d7bd7dc76e6e49b71012f04b.png"><br><br>  Thus, as a result of the transition IDSCNT_START, the main form ShoppingListMainForm is displayed on the screen, with the tab open with the number 1 (Tab1). <br><br>  Consider what happens in ShoppingListMainForm. <br><br>  The first after the completion of the constructor‚Äôs work will be the Initialize method: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ShoppingListMainForm::Initialize(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { result r = Construct(IDL_FORM); TryReturn(r == E_SUCCESS, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Failed to construct form"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><br>  As the name implies, it initializes the form, calling the inherited Construct method.  The construction of the form is based on the data contained in the GUI description file.  The IDL_FORM string is the identifier for this file. <br><br>  The remaining methods are event handlers, in particular, the event of pressing the back / cancel button of the touch button. <br><br>  In a typical Tizen-device on the front side under the screen there are three buttons: two touch and one mechanical.  A mechanical button is called ‚ÄúHome‚Äù and takes the user to HomeScreen, with a long press, launches Task Manager.  We cannot influence her behavior in any way.  But pressing the touch buttons generate events that can be processed.  As a rule, the left button ( <a href="https://developer.tizen.org/dev-guide/2.2.1/org.tizen.native.appprogramming/html/basics_tizen_programming/menu_key.htm">Menu Key</a> ) brings up the context menu, and the right ( <a href="https://developer.tizen.org/dev-guide/2.2.1/org.tizen.native.appprogramming/html/basics_tizen_programming/back_key.htm">Back Key</a> ) means cancel, return, exit the application, etc.  (depending on context). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e73/672/222/e736722226331b20139ee3a4e673ba28.png"><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ShoppingListMainForm::OnFormBackRequested(Tizen::Ui::Controls::Form&amp; source) { UiApp* pApp = UiApp::GetInstance(); AppAssert(pApp); pApp-&gt;Terminate(); }</code> </pre><br><br>  The static method GetInstance returns a pointer to a ShoppingListApp object.  Calling the Terminate method means that it is time for the heir Tizen :: App :: UiApp to reel the fishing rods, i.e.  complete the event-loop and at the same time call the ShoppingListApp :: OnAppTerminating method.  In this method, you need to close all resources, but it is not recommended to do this for a long time: the system will forcibly shut down the application after about 2 seconds (1950 ms, according to the profiler). <br><br>  Of course, in order for the OnFormBackRequested handler to be called at all, you need to subscribe to this event by registering a pointer to the object that these events will listen to.  In this case, this object is the form itself - it implements the IFormBackEventListener interface and signs itself in the OnInitializing handler: <br><br><pre> <code class="cpp hljs">result ShoppingListMainForm::OnInitializing(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { result r = E_SUCCESS; Header* pHeader = GetHeader(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pHeader) { pHeader-&gt;AddActionEventListener(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } SetFormBackEventListener(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre><br><br>  This event occurs at the beginning of the form activation, is called by the SceneManager.  In this case, in the same handler, the form subscribes to Header events, a panel that switches tabs.  For this form, you need to implement the interface IActionEventListener, i.e.  describe the reaction to the OnActionPerformed event: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ShoppingListMainForm::OnActionPerformed(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Tizen::Ui::Control&amp; source, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> actionId) { SceneManager* pSceneManager = SceneManager::GetInstance(); AppAssert(pSceneManager); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(actionId) { caseID_HEADER_ITEM1: pSceneManager-&gt;GoForward(SceneTransitionId(IDSCNT_1)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; caseID_HEADER_ITEM2: pSceneManager-&gt;GoForward(SceneTransitionId(IDSCNT_2)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; caseID_HEADER_ITEM3: pSceneManager-&gt;GoForward(SceneTransitionId(IDSCNT_3)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br><br>  Everything is pretty obvious here: depending on which button is pressed on the Header, we ask SceneManager to show this or that panel. <br><br>  Now let's take a quick look at the process of generating resource xml description files for the GUI using the UI Builder utility.  In short, because the tool is very raw, and a review of all its ‚Äúfeatures‚Äù can serve as a material for a separate article.  In the meantime, I can say that when working with the UI Builder, you need to use the ‚Äúall or nothing‚Äù principle.  This means that either using it, you need to come to terms with all the oddities and not to change anything (regarding the structure and names of directories, files, source codes), or not to use at all.  Save time and nerves. <br><br>  First, open the IDL_FORM.xml - GUI description file.  By default, it should be opened via the UI Builder: if this did not happen, then through the context menu in the Project Explorer, specify Open with -&gt; Native UI Builder ( <a href="https://developer.tizen.org/dev-guide/2.2.1/org.tizen.native.appprogramming/html/app_dev_process/launch_ui_builder.htm">example</a> ). <br><br>  The structure and principles of the editor are similar to the generally accepted ones: the working area is located in the center, the navigation and properties windows are located along the edges, and the main menu is on the top.  Unusually located only the panel with graphic elements;  Moreover, it can be accidentally rolled up and then searched for a long time: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b8e/48e/a0d/b8e48ea0d4ffe7fc82a53a373db17faf.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c6e/cf1/e0d/c6ecf1e0d55e1d5271d5bddec1b0274f.png"><br><br>  A workspace can contain several tabs, each of which displays an editable GUI element.  Working with elements is described in detail in the <a href="https://developer.tizen.org/dev-guide/2.2.1/org.tizen.native.appprogramming/html/app_dev_process/using_ui_controls.htm">documentation</a> , examples of the operation of the code generation mechanism are also given there.  Opening a tab and navigating to it is done using the Resources window: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a4/cb2/917/2a4cb291740b006838fe0eb7183a9ec0.png"><br><br>  You can edit 5 types of GUI containers: Forms, Panels, Popups, QuickPanelFrames and ScrollPanels.  At the same time, as mentioned above, SceneManager works only with forms and panels (and their factories).  ScrollPanel can also be attributed to them, since it is inherited from the Panel.  The purpose of QuickPanelFrames is not entirely clear - you can just as well use a regular panel, with the only difference that QuickPanelFrames is formed in a separate window, along with the frame (but it is still mounted on the form).  With Popup everything is clear - this is a pop-up panel, guaranteed to be displayed over the form and its controls. <br><br>  When opening the IDL_FORM.xml file, we observe only the form and its Header with buttons ‚Äî the Tab1, Tab 2 and Tab3 panels are separately editable elements.  They are mounted on a form not in the process of its creation, but with the participation of SceneManager.  This is done so that you can control the lifetime of the panels from the outside (in the usual mode, the lifetime of the GUI component is controlled by the parent container).  For example, if it is required that in the course of the application's operation, at any one time, there is only one panel in memory.  It should be remembered that the application will work on a mobile platform, while each loaded panel consumes RAM and, more importantly, video memory (where textures are loaded). <br><br>  The next type of resources are strings.  Intended for application localization.  They do not depend on the screen resolution, so they are immediately located in the res directory.  The mechanism of operation does not differ much from analogs, for example in iOS, if it were not for one BUT: as an identifier for a string, one has to set not the English analogue of the phrase, but the unintelligible IDS_STRING + index.  They can be changed, but at the same time both the editor and the parser of the obtained resource begin to fail.  As a result, we have two problems: <br>  1) It is easy to make a mistake in the code, since it is much easier to confuse indices than readable phrases; <br>  2) If a phrase is not specified for any language, then instead of the English text in the application, we get this same IDS_STRING. <br>  Of course, adherents who have attained a certain level of enlightenment do not confuse indices and easily fill localization tables by several thousand values, but this path still has to be covered ... <br><br>  The last in the list is the Workflow resource: responsible for the formation of scenes and transactions (transitions between scenes).  When working with it, the editor produces a record number of glitches, so in work projects I prefer scenes and transitions (especially transitions!) To form directly in the code.  From a sense of self-preservation, nerves are more expensive. <br><br>  Anyway, with the new SDK version, the proposed tools are improved, they slow down less, and in the last edition you can even work with them a little (if you don‚Äôt turn up complex custom structures and abandon code generation altogether). <br><br>  <a href="http://habrahabr.ru/company/kamagames/blog/213605/">Part two</a> </div><p>Source: <a href="https://habr.com/ru/post/213385/">https://habr.com/ru/post/213385/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../213373/index.html">Micron: A little more detailed about the production of 65nm microcircuits in Russia</a></li>
<li><a href="../213375/index.html">Congratulations to all 1C developers from February 23</a></li>
<li><a href="../213377/index.html">Incorrect work of the Yandex.Money API when accepting payments by card</a></li>
<li><a href="../213379/index.html">Likely future of microelectronics production: Mapper Lithography bezmashochnaya multipath electron lithography</a></li>
<li><a href="../213381/index.html">Project Tango from Google: a smartphone with a 3D space scanner</a></li>
<li><a href="../213389/index.html">How ServiceStack helps put the development of web services on stream</a></li>
<li><a href="../213391/index.html">Tame ZoG (Part 4: Beware of the Mines!)</a></li>
<li><a href="../213395/index.html">Announcement! DevCon 2014 becomes an international conference</a></li>
<li><a href="../213397/index.html">How I intercepted the traffic of the poker room or "Writing my MitM SSL proxy in C #"</a></li>
<li><a href="../213403/index.html">Applying a Poisson transform for seamless image overlay</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>