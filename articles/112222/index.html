<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Data structures: binary heap</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Binary heap (binary heap) - simply implemented data structure that allows you to quickly (in logarithmic time) add elements and extract the element wi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Data structures: binary heap</h1><div class="post__text post__text-html js-mediator-article">  Binary heap (binary heap) - simply implemented data structure that allows you to quickly (in logarithmic time) add elements and extract the element with the maximum priority (for example, the maximum value). <br><br>  For further reading it is necessary to have an idea about the <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">trees</a> , and also it is desirable to know about the <a href="http://habrahabr.ru/blogs/algorithm/78728/">estimation of the complexity of the algorithms</a> .  Algorithms in this article will be accompanied by a C # code. <br><br><h2>  Introduction </h2><br>  Binary heap is a complete binary tree, for which the <i>main property of the heap</i> is fulfilled: the priority of each vertex is higher than the priorities of its descendants.  In the simplest case, the priority of each vertex can be considered equal to its value.  In this case, the structure is called <i>max-heap</i> , since the root of the subtree is the maximum of the values ‚Äã‚Äãof the elements of the subtree.  For simplicity, this article is used in this article.  I also recall that a tree is called <i>complete binary</i> if each vertex has no more than two descendants, and the filling of the vertex levels goes from top to bottom (within one level, from left to right). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage/habraeffect/da/ae/daaefbcebe7ff642c26088a2415b5b0b.png"><br><br><a name="habracut"></a>  It is convenient to store a binary heap as a one-dimensional array, with the left descendant of a vertex with index <b><code>i</code></b> having the index <b><code>2*i+1</code></b> , and the right <b><code>2*i+2</code></b> .  The root of the tree is an element with index 0. The height of the binary heap is equal to the height of the tree, that is, log <sub>2</sub> N, where <b><code>N</code></b> is the number of elements in the array. <br><br>  I will result preparation of a class on C #: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BinaryHeap</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> heapSize { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>.Count(); } } }</code> </pre><br><h2>  Add item </h2><br>  A new element is added to the last place in the array, that is, the position with the index <b><code>heapSize</code></b> : <br><br><img src="https://habrastorage.org/storage/habraeffect/5a/ca/5aca447974533ef325339122c6fac5ed.png"><br><br>  It is possible that this will violate the main property of the heap, since the new element may be larger than the parent.  In this case, you should "raise" the new element by one level (change with the top-parent) until the main property of the heap is observed: <br><br><img src="https://habrastorage.org/storage/habraeffect/b3/c5/b3c5d3552532ca8e45b2177d872a0500.png"><br><br><img src="https://habrastorage.org/storage/habraeffect/ec/80/ec806746f46a00acf7a8ef7bbfbe2d55.png"><br><br>  In other words, the new element ‚Äúpops up‚Äù, ‚Äúpushes‚Äù upward until it takes its place.  The complexity of the algorithm does not exceed the height of the binary heap (since the number of ‚Äúrises‚Äù is not greater than the height of the tree), that is, it is equal to O (log <sub>2</sub> N). <br><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> void add(int value) { <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>.Add(value); int i = heapSize - <span class="hljs-number"><span class="hljs-number">1</span></span>; int <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> = (i - <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>] &lt; <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>[i]) { int temp = <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>[i]; <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>[i] = <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>] = temp; i = <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> = (i - <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>; } }</code> </pre><br><h2>  Binary heap ordering </h2><br>  In the course of other operations with an already constructed binary heap, the main property of the heap may also be violated: the vertex may become smaller than its descendant. <br><br><img src="http://habrastorage.org/storage/habraeffect/57/6f/576f72a4e117f24a2ddb77b5cf7ecb11.png"><br><br>  The <b><code>heapify</code></b> method restores the main heap property for a tree with a root in the i-th vertex, provided that both subtrees satisfy it.  To do this, it is necessary to ‚Äúlower‚Äù the i-th vertex (change places with the largest of descendants) until the main property is restored (the process will be completed when there is no descendant larger than its parent).  It is easy to understand that the complexity of this algorithm is also equal to O (log <sub>2</sub> N). <br><br><img src="http://habrastorage.org/storage/habraeffect/1b/2f/1b2f313a5ab4f7137bcbc72f7a29f3b6.png"><br><br><img src="http://habrastorage.org/storage/habraeffect/37/79/37798ff1492bc90950f84a9c8e4f3136.png"><br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">heapify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> leftChild; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rightChild; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> largestChild; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; ; ) { leftChild = <span class="hljs-number"><span class="hljs-number">2</span></span> * i + <span class="hljs-number"><span class="hljs-number">1</span></span>; rightChild = <span class="hljs-number"><span class="hljs-number">2</span></span> * i + <span class="hljs-number"><span class="hljs-number">2</span></span>; largestChild = i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftChild &lt; heapSize &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>[leftChild] &gt; <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>[largestChild]) { largestChild = leftChild; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightChild &lt; heapSize &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>[rightChild] &gt; <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>[largestChild]) { largestChild = rightChild; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (largestChild == i) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> temp = <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>[i]; <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>[i] = <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>[largestChild]; <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>[largestChild] = temp; i = largestChild; } }</code> </pre><br><h2>  Build a binary heap </h2><br>  The most obvious way to build a bunch from an unordered array is to add in turn all its elements.  The time estimate of such an algorithm is O (N log <sub>2</sub> N).  However, you can build a bunch even faster - for O (N).  First, you should build a tree from all elements of the array, not caring about the basic heap property, and then call the <b><code>heapify</code></b> method for all vertices that have at least one descendant (since the subtrees, consisting of one vertex without descendants, are already ordered).  Descendants are guaranteed to have the first <b><code>heapSize/2</code></b> vertices. <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildHeap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] sourceArray)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> = sourceArray.ToList(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = heapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i--) { heapify(i); } }</code> </pre><br><h2>  Extraction (deletion) of the maximum element </h2><br>  In an ordered <b><code>max-heap</code></b> maximum element is always stored in the root.  Restore the order of the binary heap after removing the maximum element by placing the last element in its place and calling <b><code>heapify</code></b> for the root, that is, ordering the entire tree. <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMax</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>[heapSize - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>.RemoveAt(heapSize - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br><h2>  Binary Heap Sorting </h2><br>  Note that you can sort an array by first building a binary heap from it, and then sequentially extracting the maximum elements.  Let us estimate the time complexity of such an element: the construction of the heap is O (N), the extraction of <b><code>N</code></b> elements is O (N log <sub>2</sub> N).  Therefore, the final estimate is O (N log <sub>2</sub> N).  In this case, additional memory for the array is not used. <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">heapSort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ buildHeap(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i--) { <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[i] = getMax(); heapify(<span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre><br><h2>  Conclusion </h2><br>  Thus, a binary heap has a logarithmic height tree structure (relative to the number of vertices), allowing for the logarithmic time to add elements and extract the element with the maximum priority in constant time.  At the same time, the binary heap is simple to implement and does not require additional memory. </div><p>Source: <a href="https://habr.com/ru/post/112222/">https://habr.com/ru/post/112222/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../112210/index.html">Names for metavariables</a></li>
<li><a href="../112215/index.html">Windows Phone 7 Games Review (Part 1)</a></li>
<li><a href="../112216/index.html">Simple things with difficult AppEngine</a></li>
<li><a href="../112217/index.html">The book "Branding and identification of the present and the future"</a></li>
<li><a href="../112221/index.html">Reflections on the implementation of the social graph</a></li>
<li><a href="../112227/index.html">Weekday cloud development, part one</a></li>
<li><a href="../112229/index.html">The amendment to allow free copying of books for libraries really gave a red light</a></li>
<li><a href="../112230/index.html">Search Trends at Euronews</a></li>
<li><a href="../112232/index.html">Americans bought 15% of Kaspersky Lab shares</a></li>
<li><a href="../112233/index.html">If I lived in another country ...</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>