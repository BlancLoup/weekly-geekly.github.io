<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Programming & Music: Buttervo Frequency Filter. Part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! You are reading the third part of an article about creating a VST synthesizer in C #. In the previous sections, the SDK and libraries for creat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Programming & Music: Buttervo Frequency Filter. Part 3</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello!  You are reading the third part of an article about creating a VST synthesizer in C #.  In the previous sections, the SDK and libraries for creating <a href="https://ru.wikipedia.org/wiki/Virtual_Studio_Technology">VST</a> plug <a href="https://ru.wikipedia.org/wiki/Virtual_Studio_Technology">-</a> ins were considered, the programming of an oscillator and an ADSR envelope for controlling the amplitude of a signal were considered. </p><br><p>  In this part, I will tell you how to calculate and code the frequency filter, without which no synthesizer can do.  And without equalizer sound processing is inconceivable. </p><br><p>  The source code and the use of an equalizer from the <a href="https://naudio.codeplex.com/">NAudio</a> library (a library for working with sound under .NET) will be reviewed. </p><br><p>  Attention - there will be a lot of <a href="">matan</a> - we will calculate the formulas for the filter coefficients. </p><br><p>  The source code for the <a href="https://www.youtube.com/watch%3Fv%3D6zAVMEtIb2w">synthesizer I've written</a> is available on <a href="https://github.com/lis355/Syntage">GitHub</a> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/967/d2a/486/967d2a486df44a90aa2dcf89f0c90ad9.png"></div><br><p>  <em>Screenshot VST plug-in equalizer Fab Filter Pro Q</em> </p><br><a name="habracut"></a><br><h2 id="cikl-statey">  Cycle of articles </h2><br><ol><li>  <a href="https://habrahabr.ru/post/311220/">We understand and write VSTi synthesizer on C # WPF</a> </li><li>  <a href="https://habrahabr.ru/post/311750/">ADSR signal envelope</a> </li><li>  Buttervo Frequency Filter </li><li>  <a href="https://habrahabr.ru/post/313338/">Delay, Distortion and Parameter Modulation</a> </li></ol><br><h2 id="oglavlenie">  Table of contents </h2><br><ol><li>  <a href="https://habr.com/ru/post/313062/">Equalizer</a> </li><li>  <a href="https://habr.com/ru/post/313062/">Fourier Transform Filtering</a> </li><li>  <a href="https://habr.com/ru/post/313062/">Digital filters</a> </li><li>  <a href="https://habr.com/ru/post/313062/">Why filter Buttervota?</a> </li><li>  <a href="https://habr.com/ru/post/313062/">The output of the low-pass filter formula</a> </li><li>  <a href="https://habr.com/ru/post/313062/">The output of the formula of the filter RF and bandpass filter</a> </li><li>  <a href="https://habr.com/ru/post/313062/">Programming the Butterwater filter using the formulas obtained</a> </li><li>  <a href="https://habr.com/ru/post/313062/">Band equalizer in NAudio library</a> </li><li>  <a href="https://habr.com/ru/post/313062/">Programs for calculating filters</a> </li><li>  <a href="https://habr.com/ru/post/313062/">Bibliography</a> </li></ol><br><a name="Part1"></a><br><h2 id="ekvalayzer">  Equalizer </h2><br><p>  Often when processing sound we want to change its character / color / timbre.  Make the sound more bass, remove the upper frequencies, or vice versa, make the sound "transparent", leaving only the middle and the top.  I am sure many people who have not worked with sound processing know what <a href="http://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BA%25D0%25B2%25D0%25B0%25D0%25BB%25D0%25B0%25D0%25B9%25D0%25B7%25D0%25B5%25D1%2580">equalizer</a> is - they are acoustic speakers, music centers, tape recorders, music players, etc.  An equalizer is a set of filters, each of which changes the amplitude of a signal in its selected frequency band.  On household speakers, these are usually 2-3 spins - low frequencies, mid and top, with fixed frequency bands. </p><br><p>  There are already 10 pre-defined bands in Winamp EQ. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b5c/aa6/bd6/b5caa6bd682e4ac4950ab17723868252.png"></div><br><p>  <em>Screenshot Equalizer Player Winamp</em> </p><br><p>  In the world of sound processing, there are many equalizer plug-ins, for every taste and color.  The Fab Filter Pro Q plug-in (screenshot at the beginning of the article) is a graphic equalizer that allows you to create a large number of <em>bands</em> and edit their parameters. </p><br><p>  Each <em>band</em> in the equalizer is, in fact, a frequency filter.  Frequency filters change the timbre / frequency characteristics of a signal.  In electronics, there are many types and classifications of filters, with the corresponding characteristics and parameters - <a href="http://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580_(%25D1%258D%25D0%25BB%25D0%25B5%25D0%25BA%25D1%2582%25D1%2580%25D0%25BE%25D0%25BD%25D0%25B8%25D0%25BA%25D0%25B0)">look Wikipedia</a> . <br>  We will consider and program the simplest filters: low-pass, high-pass and band-pass filters. </p><br><a name="Part2"></a><br><h2 id="filtraciya-cherez-preobrazovanie-fure">  Fourier Transform Filtering </h2><br><p>  In theory, no one bothers you to do a <a href="https://habrahabr.ru/post/196374/">discrete Fourier transform</a> with the signal, process the frequencies and then do the inverse transform. </p><br><p>  If you do not think about the implementation of the DFT, then I would call such an approach quite intuitive and easy to program (again, if you take the DFT from any of them and do not code it yourself). </p><br><p>  The disadvantages of the approach are, first, the DFT accepts an array of samples as input, the size of which is a power of two.  This means that the output signal will be delayed.  Secondly, every 512th sample we will produce this algorithm: DFT, signal frequency processing, inverse DFT.  This is not a small calculation.  Thirdly, there are still minuses and subtleties that adherents of digital signal processing know. </p><br><p>  We will not consider the use of DFT, but look at the theory of digital filters;  write a filter that processes the <em>values ‚Äã‚Äãof the samples</em> and has a linear <a href="http://ru.wikipedia.org/wiki/%25D0%2592%25D1%258B%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25BB%25D0%25BE%25D0%25B6%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C">computational complexity</a> depending on the length of the incoming sample array. </p><br><a name="Part3"></a><br><h2 id="cifrovye-filtry">  Digital filters </h2><br><p>  Most of the information and the derivation of formulas I took from the book <a href="https://www.amazon.com/Digital-Signal-Processing-Practical-Approach/dp/0201596199">Digital Signal Processing: A Practical Approach</a> - I highly recommend it, it is in the Russian version - <a href="https://www.ozon.ru/context/detail/id/5689080/">Digital Signal Processing.</a>  <a href="https://www.ozon.ru/context/detail/id/5689080/">Practical approach</a> , interested will find PDF on the net. </p><br><p>  I want to make <strong>an important note</strong> .  The topic of building and calculating a filter is really very complex, it contains a lot of subtleties and nuances, it requires knowledge and understanding of the theory.  In this article, I will show how to calculate the Butterwater filter formulas so that the reader has an understanding of where these formulas are derived from.  But why exactly <em>such</em> initial formulas, why exactly <em>such</em> replacements can be understood only by immersing ourselves in the deep theory of digital signal processing. </p><br><p>  When I started to google the filter code, I immediately found a lot of incomprehensible mathematical code, and I wanted to at least a little bit understand where such calculation formulas come from.  Oscillator, envelope, delay - understanding and programming the work of these components seems to me intuitive, but not filters.  In this article I want to arouse an interest in digital signal processing) I would be glad if there is a desire to understand this topic more thoroughly. </p><br><p>  You need to know (at least a little) terms such as <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B2%25D1%2591%25D1%2580%25D1%2582%25D0%25BA%25D0%25B0_(%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25B0%25D0%25BD%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7)">convolution</a> , <a href="http://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BC%25D0%25BF%25D1%2583%25D0%25BB%25D1%258C%25D1%2581%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B5%25D1%2585%25D0%25BE%25D0%25B4%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F">filter impulse response, filter</a> <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B0%25D1%2582%25D0%25BE%25D1%2587%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F">transfer function</a> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/7e6/689/af5/7e6689af5ce544f69c1149b8f689c1d8.png"></div><br><p>  <i>Approximation of the <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BC%25D0%25BF%25D0%25BB%25D0%25B8%25D1%2582%25D1%2583%25D0%25B4%25D0%25BD%25D0%25BE-%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25BE%25D1%2582%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2585%25D0%25B0%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25B5%25D1%2580%25D0%25B8%25D1%2581%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0">frequency response of the</a> ideal filter (picture from the Soviet textbook, did not find the source)</i> </p><br><p>  The filter changes the signal, "removing" in it the selected frequency.  Existing filters are not perfect.  Bandwidth is a frequency band that the filter "does not affect" (there is some <img src="https://habrastorage.org/files/560/f1f/94e/560f1f94ef9248dc92ccb650e6f7a4c8.gif">  changes are a feature of the imperfect filter presented).  Band of suppression - the band of unwanted frequencies.  Frequency decay occurs in the transition band.  Naturally, the filter is closer to the ‚Äúideal‚Äù one by how much less it distorts the bandwidth, how much it suppresses the frequencies in the suppression band and how narrow the transition band is.  There are various "approximations" of filters - the Chebyshev, Buttervota filter, and so on - you will find them in books and in the open spaces of the network. </p><br><a name="Part4"></a><br><h2 id="pochemu-filtr-battervota">  Why filter Buttervota? </h2><br><p>  It's very simple, the Butterworth frequency response of the filter is as smooth as possible at the passband frequencies - IMHO, the most important thing is not to spoil the signal in the passband. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/883/f4d/c20/883f4dc200c242fdb1f39f6038d64198.png"></div><br><p>  <em>Logarithmic frequency response for Butterworth filters of low frequencies of different orders (screenshot taken from Wikipedia)</em> </p><br><a name="Part5"></a><br><h2 id="vyvod-formuly-filtra-nch">  The output of the low-pass filter formula </h2><br><p> <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B0%25D1%2582%25D0%25BE%25D1%2587%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F">The transfer function</a> for the Butterwater filter on the <a href="http://ru.wikipedia.org/wiki/S-%25D0%25BF%25D0%25BB%25D0%25BE%25D1%2581%25D0%25BA%25D0%25BE%25D1%2581%25D1%2582%25D1%258C">s-plane is</a> written by the following formulas: </p><br><p><img src="https://habrastorage.org/files/674/627/24d/67462724dce34ec693a6d8eacf966d8d.gif">  with even n and <br><img src="https://habrastorage.org/files/ee9/9c2/504/ee99c25044164a40a1b8c72ed61dc066.gif">  with odd n </p><br><p>  Here n is the order of the filter: the amplitude at the cut-off frequency w is -3n dB, the amplitude-frequency characteristic decays by ‚àí6n dB per octave. </p><br><p>  To obtain convolution coefficients, one must obtain the transfer function on the <a href="http://ru.wikipedia.org/wiki/Z-%25D0%25BF%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">z-plane</a> in the form </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/688/59a/7fc/68859a7fc2f54f108821261177b933b1.gif"></div><br><p>  Find the transfer function for the filter of the second order (attenuation by -6 dB per octave), substitute in the formula for H (s) n = 2: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/317/57e/375/31757e375991473e9d2211782f62ff3f.gif"></div><br><p>  Then the convolution for the filter will look like this: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/cbe/5f7/264/cbe5f72647c34144890b8216a4ed522c.gif"></div><br><p>  Let us set the cut-off frequency w (at which the signal amplitude will be -3 dB) and Fc - the sampling frequency (number of samples per second), in hertz. </p><br><p>  In the formula, one should use denormalized frequencies, i.e.  to replace (in the bandpass filter there will be two frequencies w1 and w2, which determine the bandwidth): </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/97f/a6d/225/97fa6d22549542d7be46cf2c700d6580.gif"></div><br><p>  If we want to calculate the low-pass filter, then we need to do a conversion ‚Äî replace the parameter s in the transfer function: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/642/435/2c2/6424352c283a4ee280b1b5fcaaddf01a.gif"></div><br><p>  To calculate other types of filters (HF, bandpass, notch) you need to do other replacements.  They are discussed in the book <a href="https://www.ozon.ru/context/detail/id/5689080/">Digital Signal Processing.</a>  <a href="https://www.ozon.ru/context/detail/id/5689080/">A practical approach</a> in part 8.8.2 and further in the article. </p><br><p>  Further, in order to go to the z-plane, we make a replacement: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/541/ee3/690/541ee3690fdc4823a72ea82d948efcf3.gif"></div><br><p>  For analytical calculations, I used the Mathematica package. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/88f/0d2/2c3/88f0d22c39bb4792b01ce8506cfc9f7a.png"></div><br><p>  You need to get the numerator and denominator in the form of polynomials from z.  We give the terms of the denominator H (z) to a common denominator.  To do this, we find the <a href="http://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B0%25D0%25B8%25D0%25B1%25D0%25BE%25D0%25BB%25D1%258C%25D1%2588%25D0%25B8%25D0%25B9_%25D0%25BE%25D0%25B1%25D1%2589%25D0%25B8%25D0%25B9_%25D0%25B4%25D0%25B5%25D0%25BB%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C">greatest common divisor (GCD, GCD) of the</a> terms of the denominator and divide into it the numerator and denominator of the original function H (z). </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/53e/8c3/6e8/53e8c36e89174be5a549cc9f9c3a9d82.png"></div><br><p>  Find the coefficients in powers of the polynomials obtained using the CoefficientList function: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ee7/db4/88c/ee7db488c2b241378ba12f2a00085752.png"></div><br><p>  If we do everything honestly, then, by the condition, a0 must be equal to 1 - divide all coefficients by a0 (for coding, we will use the previous formulas without division): </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/262/00c/475/26200c47543648bbb8368d847f40aa58.png"></div><br><a name="Part6"></a><br><h2 id="vyvod-formuly-filtra-vch-i-polosovogo-filtra">  The output of the formula of the filter RF and bandpass filter </h2><br><p>  The derivation of formulas for the high-pass filter is similar to the low-pass filter with a different conversion: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/7fe/6a2/e89/7fe6a2e89aa5404dbf5338527f38078e.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e88/ec8/ff5/e88ec8ff52b04dad8b4139ffa56576b9.png"></div><br><p>  To output the band-pass filter formulas, a transformation is applied: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a37/621/4fa/a376214faa374441a2893c7b6d8762b2.gif"></div><br><p>  If a replacement is made, then the degree of polynomials in the numerator and denominator H (z) will double (the replacement is s ^ 2), which means that the order of the filter will double.  Therefore, we initially use the function H (s) for n = 1: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/9ee/afb/deb/9eeafbdebd634a09962fc1138efacd6a.png"></div><br><a name="Part7"></a><br><h2 id="programmirovanie-filtra-battervota-po-poluchennym-formulam">  Programming the Butterwater filter using the formulas obtained </h2><br><p>  The filter will have 2 parameters: filter type (LF, HF, bandpass) and cut-off frequency w.  For a bandpass filter, we will consider the cutoff frequency as the frequency in the middle of the passband.  The bandwidth is defined as the frequency interval [w - w / 4, w + w / 4] (you can think of a more complex and logical logarithmic law here, at your discretion). </p><br><p>  Suppose that we determined the coefficients b0, b1, b2, a1 and a2 (a0 is equal to 1 by the condition) by the calculated formulas.  The filter operation algorithm is reduced to convolution, which is done sequentially for each sample: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/cbe/5f7/264/cbe5f72647c34144890b8216a4ed522c.gif"></div><br><p>  y (n) is the new value of the sample to be calculated.  x (n) is the current value of the sample, respectively, y (n-1) and y (n-2) are the previous 2 calculated samples, and x (n-1) and x (n-2) are the previous input values ‚Äã‚Äãof the samples. </p><br><p>  It is necessary to organize the memorization of previous samples.  Let's not be wise with cyclic buffers, let's make it simple and clear: two arrays of three elements.  Each time we will "push" the new values ‚Äã‚Äãinto this array, sequentially copying the older values ‚Äã‚Äãof the samples. </p><br><p>  We get a simple class: </p><br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BiquadConvolutionTable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> B0, B1, B2, A1, A2; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] _x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] _y = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ""   _x[2] = _x[1]; _x[1] = _x[0]; _x[0] = s; _y[2] = _y[1]; _y[1] = _y[0]; //  _y[0] = B0 * _x[0] + B1 * _x[1] + B2 * _x[2] - A1 * _y[1] - A2 * _y[2]; return _y[0]; } }</span></span></code> </pre> <br><p>  Let's write a frame class for the filter (see the synthesizer architecture in the <a href="https://habrahabr.ru/post/311220/">first article</a> ).  The class BiquadConvolutionTable works with one signal, i.e.  with one channel - mono.  Therefore, we need two BiquadConvolutionTable - for the left and right channels. </p><br><p>  To apply the filter correctly, you need to apply the function BiquadConvolutionTable.Process for all samples of the incoming sequence and fill the resulting array of samples. </p><br><p>  The calculation of the coefficients for the BiquadConvolutionTable will be handled by the CalculateCoefficients function. </p><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> enum EFilterPass { None, LowPass, HiPass, BandPass } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButterworthFilter</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SyntageAudioProcessorComponentWithParameters</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AudioProcessor</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly BiquadConvolutionTable _tablel; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly BiquadConvolutionTable _tabler; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EnumParameter&lt;EFilterPass&gt; FilterType { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FrequencyParameter CutoffFrequency { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ButterworthFilter(AudioProcessor audioProcessor) : base(audioProcessor) { _tablel = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BiquadConvolutionTable(); _tabler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BiquadConvolutionTable(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> IEnumerable&lt;Parameter&gt; CreateParameters(string parameterPrefix) { FilterType = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnumParameter&lt;EFilterPass&gt;(parameterPrefix + <span class="hljs-string"><span class="hljs-string">"Pass"</span></span>, <span class="hljs-string"><span class="hljs-string">"Filter Type"</span></span>, <span class="hljs-string"><span class="hljs-string">"Filter"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); CutoffFrequency = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrequencyParameter(parameterPrefix + <span class="hljs-string"><span class="hljs-string">"Cutoff"</span></span>, <span class="hljs-string"><span class="hljs-string">"Filter Cutoff Frequency"</span></span>, <span class="hljs-string"><span class="hljs-string">"Cutoff"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Parameter&gt; {FilterType, CutoffFrequency}; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Process(IAudioStream stream) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FilterType.Value == EFilterPass.None) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count = Processor.CurrentStreamLenght; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lc = stream.Channels[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rc = stream.Channels[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cutoff = CutoffFrequency.Value; CalculateCoefficients(cutoff); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ls = _tablel.Process(lc.Samples[i]); lc.Samples[i] = ls; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rs = _tabler.Process(rc.Samples[i]); rc.Samples[i] = rs; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CalculateCoefficients(double cutoff) { ... } }</code> </pre> <br><p>  The CalculateCoefficients function is called every time in the loop - why?  In the next article I will talk about the modulation (change over time) of parameters, and therefore, the cutoff frequency may change, which means that you need to recalculate the coefficients.  Of course, in a scrappy way, you need to subscribe to a change in the cutoff frequency and already in the handler calculate the coefficients.  But in these articles I will not deal with optimizations, the goal is to code the filter. </p><br><p>  It remains to code the CalculateCoefficients function using the calculated formulas for the coefficients. <br>  Recall that you need to use denormal frequencies, i.e.  replace: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/97f/a6d/225/97fa6d22549542d7be46cf2c700d6580.gif"></div><br><p>  Write off all the formulas for the coefficients b0, b1, b2, a0, a1, a2.  After the calculations, all coefficients must be divided by a0 so that a0 becomes equal to 1. </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TransformFrequency</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> w</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math.Tan(Math.PI * w / Processor.SampleRate); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalculateCoefficients</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cutoff</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> b0, b1, b2, a0, a1, a2; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (FilterType.Value) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EFilterPass.LowPass: { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> w = TransformFrequency(cutoff); a0 = <span class="hljs-number"><span class="hljs-number">1</span></span> + Math.Sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>) * w + w * w; a1 = <span class="hljs-number"><span class="hljs-number">-2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> * w * w; a2 = <span class="hljs-number"><span class="hljs-number">1</span></span> - Math.Sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>) * w + w * w; b0 = w * w; b1 = <span class="hljs-number"><span class="hljs-number">2</span></span> * w * w; b2 = w * w; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EFilterPass.HiPass: { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> w = TransformFrequency(cutoff); a0 = <span class="hljs-number"><span class="hljs-number">1</span></span> + Math.Sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>) * w + w * w; a1 = <span class="hljs-number"><span class="hljs-number">-2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> * w * w; a2 = <span class="hljs-number"><span class="hljs-number">1</span></span> - Math.Sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>) * w + w * w; b0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; b1 = <span class="hljs-number"><span class="hljs-number">-2</span></span>; b2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EFilterPass.BandPass: { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> w = cutoff; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = w / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     [w * 3 / 4, w * 5 / 4] var w1 = Math.Max(w - d, CutoffFrequency.Min); var w2 = Math.Min(w + d, CutoffFrequency.Max); w1 = TransformFrequency(w1); w2 = TransformFrequency(w2); var w0Sqr = w2 * w1; // w0^2 var wd = w2 - w1; // W a0 = -1 - wd - w0Sqr; a1 = 2 - 2 * w0Sqr; a2 = -1 + wd - w0Sqr; b0 = -wd; b1 = 0; b2 = wd; } break; default: throw new ArgumentOutOfRangeException(); } _tablel.B0 = _tabler.B0 = b0 / a0; _tablel.B1 = _tabler.B1 = b1 / a0; _tablel.B2 = _tabler.B2 = b2 / a0; _tablel.A1 = _tabler.A1 = a1 / a0; _tablel.A2 = _tabler.A2 = a2 / a0; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Full code of the class ButterworthFilter</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> enum EFilterPass { <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, LowPass, HiPass, BandPass } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ButterworthFilter : SyntageAudioProcessorComponentWithParameters&lt;AudioProcessor&gt;, IProcessor { private <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> BiquadConvolutionTable { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span> B0, B1, B2, A1, A2; private readonly <span class="hljs-type"><span class="hljs-type">double</span></span>[] _x = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>]; private readonly <span class="hljs-type"><span class="hljs-type">double</span></span>[] _y = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span> Process(<span class="hljs-type"><span class="hljs-type">double</span></span> s) { // ""   _x[<span class="hljs-number"><span class="hljs-number">2</span></span>] = _x[<span class="hljs-number"><span class="hljs-number">1</span></span>]; _x[<span class="hljs-number"><span class="hljs-number">1</span></span>] = _x[<span class="hljs-number"><span class="hljs-number">0</span></span>]; _x[<span class="hljs-number"><span class="hljs-number">0</span></span>] = s; _y[<span class="hljs-number"><span class="hljs-number">2</span></span>] = _y[<span class="hljs-number"><span class="hljs-number">1</span></span>]; _y[<span class="hljs-number"><span class="hljs-number">1</span></span>] = _y[<span class="hljs-number"><span class="hljs-number">0</span></span>]; //  _y[<span class="hljs-number"><span class="hljs-number">0</span></span>] = B0 * _x[<span class="hljs-number"><span class="hljs-number">0</span></span>] + B1 * _x[<span class="hljs-number"><span class="hljs-number">1</span></span>] + B2 * _x[<span class="hljs-number"><span class="hljs-number">2</span></span>] - A1 * _y[<span class="hljs-number"><span class="hljs-number">1</span></span>] - A2 * _y[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _y[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } } private readonly BiquadConvolutionTable _tablel; private readonly BiquadConvolutionTable _tabler; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> EnumParameter&lt;EFilterPass&gt; FilterType { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; private <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> FrequencyParameter CutoffFrequency { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; private <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> ButterworthFilter(AudioProcessor audioProcessor) : base(audioProcessor) { _tablel = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> BiquadConvolutionTable(); _tabler = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> BiquadConvolutionTable(); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> override IEnumerable&lt;Parameter&gt; CreateParameters(string parameterPrefix) { FilterType = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> EnumParameter&lt;EFilterPass&gt;(parameterPrefix + "Pass", "Filter Type", "Filter", <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); CutoffFrequency = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> FrequencyParameter(parameterPrefix + "Cutoff", "Filter Cutoff Frequency", "Cutoff"); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> List&lt;Parameter&gt; {FilterType, CutoffFrequency}; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Process(IAudioStream stream) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FilterType.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> == EFilterPass.<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; var count = Processor.CurrentStreamLenght; var lc = stream.Channels[<span class="hljs-number"><span class="hljs-number">0</span></span>]; var rc = stream.Channels[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; ++i) { var cutoff = CutoffFrequency.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; CalculateCoefficients(cutoff); var ls = _tablel.Process(lc.Samples[i]); lc.Samples[i] = ls; var rs = _tabler.Process(rc.Samples[i]); rc.Samples[i] = rs; } } private <span class="hljs-type"><span class="hljs-type">double</span></span> TransformFrequency(<span class="hljs-type"><span class="hljs-type">double</span></span> w) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math.Tan(Math.PI * w / Processor.SampleRate); } private <span class="hljs-type"><span class="hljs-type">void</span></span> CalculateCoefficients(<span class="hljs-type"><span class="hljs-type">double</span></span> cutoff) { <span class="hljs-type"><span class="hljs-type">double</span></span> b0, b1, b2, a0, a1, a2; switch (FilterType.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EFilterPass.LowPass: { var w = TransformFrequency(cutoff); a0 = <span class="hljs-number"><span class="hljs-number">1</span></span> + Math.Sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>) * w + w * w; a1 = <span class="hljs-number"><span class="hljs-number">-2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> * w * w; a2 = <span class="hljs-number"><span class="hljs-number">1</span></span> - Math.Sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>) * w + w * w; b0 = w * w; b1 = <span class="hljs-number"><span class="hljs-number">2</span></span> * w * w; b2 = w * w; } break; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EFilterPass.HiPass: { var w = TransformFrequency(cutoff); a0 = <span class="hljs-number"><span class="hljs-number">1</span></span> + Math.Sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>) * w + w * w; a1 = <span class="hljs-number"><span class="hljs-number">-2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> * w * w; a2 = <span class="hljs-number"><span class="hljs-number">1</span></span> - Math.Sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>) * w + w * w; b0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; b1 = <span class="hljs-number"><span class="hljs-number">-2</span></span>; b2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; } break; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EFilterPass.BandPass: { var w = cutoff; var d = w / <span class="hljs-number"><span class="hljs-number">4</span></span>; //     [w * <span class="hljs-number"><span class="hljs-number">3</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>, w * <span class="hljs-number"><span class="hljs-number">5</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>] var w1 = Math.Max(w - d, CutoffFrequency.Min); var w2 = Math.Min(w + d, CutoffFrequency.Max); w1 = TransformFrequency(w1); w2 = TransformFrequency(w2); var w0Sqr = w2 * w1; // w0^<span class="hljs-number"><span class="hljs-number">2</span></span> var wd = w2 - w1; // W a0 = <span class="hljs-number"><span class="hljs-number">-1</span></span> - wd - w0Sqr; a1 = <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">2</span></span> * w0Sqr; a2 = <span class="hljs-number"><span class="hljs-number">-1</span></span> + wd - w0Sqr; b0 = -wd; b1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; b2 = wd; } break; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArgumentOutOfRangeException(); } _tablel.B0 = _tabler.B0 = b0 / a0; _tablel.B1 = _tabler.B1 = b1 / a0; _tablel.B2 = _tabler.B2 = b2 / a0; _tablel.A1 = _tabler.A1 = a1 / a0; _tablel.A2 = _tabler.A2 = a2 / a0; } }</code> </pre> </div></div><br><a name="Part8"></a><br><h2 id="polosovoy-ekvalayzer-v-biblioteke-naudio">  Band equalizer in NAudio library </h2><br><p>  For working with sound, sound files of various formats on .NET there is a good <a href="https://naudio.codeplex.com/">NAudio</a> library. </p><br><p>  It contains the NAudio.Dsp namespace with functionality for filtering, <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B2%25D1%2591%25D1%2580%25D1%2582%25D0%25BA%25D0%25B0_(%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25B0%25D0%25BD%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7)">convolution</a> , <a href="http://wikisound.org/%25D0%2593%25D0%25B5%25D0%25B9%25D1%2582">gate</a> , <a href="https://habrahabr.ru/post/311750/">envelope</a> , <a href="http://ru.wikipedia.org/wiki/%25D0%2591%25D1%258B%25D1%2581%25D1%2582%25D1%2580%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25A4%25D1%2583%25D1%2580%25D1%258C%25D0%25B5">FFT,</a> and other interesting pieces. </p><br><p>  Consider the Equalizer class (from examples, the NAudioWpfDemo.EqualizationDemo namespace), which allows equalization of the signal.  The class implements ISampleProvider, which, in the Read (float [] buffer, int offset, int count) function, processes (changes) the buffer samples array. </p><br><p>  The constructor accepts an array of EqualizerBand structures that describe the equalizer bands: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EqualizerBand</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Frequency { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Gain { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Bandwidth { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br><p>  Here Frequency is the center frequency of the band with the parameter Q (Bandwidth, <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25BE%25D0%25B1%25D1%2580%25D0%25BE%25D1%2582%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C">filter Q</a> ), with gain Gain dB. </p><br><p>  If you look at the implementation, then each band EqualizerBand corresponds to the class BiQuadFilter which is used as a bandpass (Peaking) filter.  All filters change the signal used in series. </p><br><p>  The EqualizerBand class is a implementation of the Butterwater filter, with a large selection of filter types and parameters.  If you look at the implementation, you can see similar formulas and coefficients. </p><br><p>  An example of using the Equalizer class can be found in the NAudioWpfDemo project in the EqualizationDemoViewModel class. </p><br><a name="Part9"></a><br><h2 id="programmy-dlya-rasscheta-filtrov">  Programs for calculating filters </h2><br><p>  The progenitor of digital filters were analog filters.  The theory for analog circuits and analog signal processing later developed into the theory of digital signal processing. </p><br><p>  For the considered Butterwater filter and the calculated formulas for the coefficients, an analog circuit can be assembled. </p><br><p>  There are many programs for calculating and constructing schemes, parameters of elements for them, convolution coefficients of various filters. <br>  You can google by "filter calculation software". </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/48f/fc2/7ff/48ffc27ff4cb49048870eed0f4278829.png"></div><br><p>  <em>Iowa Hills Software RF Filter Designer</em> </p><br><p>  In the next article I will talk about the <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D0%25BB%25D1%258D%25D0%25B9">effect of delay</a> , <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D1%2581%25D1%2582%25D0%25BE%25D1%2580%25D1%2588%25D0%25BD">distortion</a> and parameter modulation. </p><br><p>  <em>All good!</em>  <em>Good luck in programming!</em> </p><br><a name="Part10"></a><br><h2 id="spisok-literatury">  Bibliography </h2><br><p>  Do not forget to look at the lists of articles and books in previous articles. </p><br><ol><li>  <a href="https://www.amazon.com/Digital-Signal-Processing-Practical-Approach/dp/0201596199">Digital Signal Processing: A Practical Approach</a> .  Russian version - <a href="https://www.ozon.ru/context/detail/id/5689080/">Digital signal processing.</a>  <a href="https://www.ozon.ru/context/detail/id/5689080/">Practical approach</a> . </li><li>  <a href="https://habrahabr.ru/post/196374/">Habr article "Simple words about Fourier transform"</a> </li><li>  <a href="http://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580_%25D0%2591%25D0%25B0%25D1%2582%25D1%2582%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D1%2580%25D1%2582%25D0%25B0">Filter Butterworth on wiki</a> </li><li>  <a href="https://github.com/ruohoruotsi/Butterworth-Filter-Design">Github repository with code to calculate Butterwater filters</a> </li><li>  <a href="http://abut.sdsu.edu/TE302/Chap7.pdf">DISCRETE SIGNALS AND SYSTEMS, Chapter 7. FIR and IIR Filters</a> </li><li>  <a href="http://dsp.stackexchange.com/questions/8693/how-does-a-low-pass-filter-programmatically-work">How does a low-pass filter programmatically work?</a>  <a href="http://dsp.stackexchange.com/questions/8693/how-does-a-low-pass-filter-programmatically-work">(dsp.stackexchange.com/)</a> </li><li>  <a href="http://mymbs.mbs.net/~pfisher/FOV2-0010016C/FOV2-0010016E/FOV2-001001A3/chapters/25katsianos/index.html">Designing Digital Butterworth and Chebyshev Filters</a> </li><li>  <a href="http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt">Audio EQ Cookbook</a> </li><li>  <a href="http://www.iowahills.com/8DownloadPage.html">Iowa Hills Software - Digital and Analog Filters</a> </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/313062/">https://habr.com/ru/post/313062/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../313048/index.html">Personal experience of receiving the Blue Card in Germany 2015-2016. Part 1: Job Search</a></li>
<li><a href="../313052/index.html">Dissect OpenVPN. Part 1. Static keys</a></li>
<li><a href="../313054/index.html">RailsClub 2016: podcasts with Ivan Nemytchenko and Ilya Zykin</a></li>
<li><a href="../313056/index.html">Translation of excerpts from Robert Heinlein‚Äôs book, Take Your Government Back - part 17</a></li>
<li><a href="../313058/index.html">Architecture and programming computer Texas Instruments TI-99 / 4a</a></li>
<li><a href="../313064/index.html">Customer support operator, manager, programmer</a></li>
<li><a href="../313066/index.html">Overview of options for implementing failover clusters: Stratus, VMware, VMmanager Cloud</a></li>
<li><a href="../313068/index.html">Media: German military hacked into the network of the Afghan mobile operator to find out the whereabouts of the hostage</a></li>
<li><a href="../313070/index.html">Java Continuations</a></li>
<li><a href="../313072/index.html">New podcast about computer science</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>