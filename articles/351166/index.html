<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Guide to background work in Android. Part 3: Executors and EventBus</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings, colleagues. I am glad to see you again in the third part of the ‚ÄúBackground manual for Android‚Äù. If you have not seen the previous parts, h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Guide to background work in Android. Part 3: Executors and EventBus</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/cb/z1/t3/cbz1t3_wnikaonewuoukl9gazzm.jpeg"><br><br>  Greetings, colleagues.  I am glad to see you again in the third part of the ‚ÄúBackground manual for Android‚Äù.  If you have not seen the previous parts, here they are: <br><br><ul><li>  <a href="https://habrahabr.ru/company/epam_systems/blog/348894/">Part 1: AsyncTask</a> </li><li>  <a href="https://habrahabr.ru/company/jugru/blog/350094/">Part 2: Loaders</a> </li></ul><br>  Last time, we figured out how Loaders work, and right after that, Google took it and said that they had completely rewritten LoaderManager.  Apparently, I need to return to this topic later, but for the time being I will follow the plan and share the details of how to organize background work in Android exclusively using java thread pool executors, as well as how EventBus can help with this, and how it all works under the hood. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Let's remember what the main snag is: time-consuming operations like network calls should be carried out in a background thread, but the result can only be published in the main UI thread.</b> <br><br>  It would also be great to save the result of a lengthy operation when the configuration changes. <br><br>  In the previous texts we figured out how to do this with AsyncTasks and Loaders.  However, these APIs have their drawbacks, due to which you have to implement rather complex interfaces and abstract classes.  In addition, they do not allow us to write modules with asynchronous work in pure Java due to the use of Android-specific APIs. <br><br>  Because of these limitations, an approach based on executors has emerged.  Let's look at it.  For a start, of course, we need to get hold of streams, where we can send our tasks for background work.  Let's create the Background class for this: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Background</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ExecutorService mService = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ScheduledThreadPoolExecutor(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Future&lt;?&gt; execute(Runnable runnable) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mService.submit(runnable); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">Future&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">submit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Callable&lt;T&gt; runnable)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mService.submit(runnable); } }</code> </pre> <br>  So, we have an executor, and there is a method to run some code asynchronously, wrapping it in Runnable or Callable. <br><br>  Great, let's try to shove the result of the operation into the UI thread.  Not a problem, we know that we only need a Handler: <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Background</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Handler mUiHandler; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postOnUiThread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Runnable runnable)</span></span></span><span class="hljs-function"> </span></span>{ mUiHandler.post(runnable); } }</code> </pre><br>  But wait, we don‚Äôt know if our UI exists at all, and if so, how does it know that something needs to be changed? <br><br>  Here an approach called the ‚Äúevent bus‚Äù or event bus comes to the rescue.  The general idea is that there is some kind of common bus (or even several) where events are published.  Anyone can start listening to the tire at any time, receive events, and then stop listening (sounds like RxJava, huh? Wait for the next article!) <br><br>  In general, we need three components: <br><br>  Tire itself <br>  Source (s) of events <br>  Listener (or listeners) of events <br><br>  You can reflect this structure with such a diagram: <br><br><img src="https://habrastorage.org/webt/ce/ap/lh/ceaplhv9ciyyvz_l5sqm88nbmlo.png"><br>  <i><sup>Schematic diagram of the transmission of events on the bus</sup></i> <br><br><h2>  Event tire </h2><br>  No one requires self-implement tire from scratch.  You can choose one of the existing implementations: <a href="https://github.com/google/guava/tree/master/guava/src/com/google/common/eventbus">Google Guava</a> , <a href="http://square.github.io/otto/">Otto</a> or <a href="https://github.com/greenrobot/EventBus">EventBus</a> from greenrobot (the latter has stylish support for sending events to different streams using annotations). <br><br>  We can use the bus object directly in our presenters, activities, fragments, and so on, but I prefer to encapsulate it in the same class Background: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Background</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final Bus mEventBus; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">final Object </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">)</span></span> { mEventBus.post(<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>); } }</code> </pre><br>  Let's write client code using the construct we built.  Suppose we want to initialize the database before using the application, and this, of course, takes time.  So inside the application we launch initialization in the background and publish the event that the initialization of the database has completed: <br><br><pre> <code class="hljs java"> mBackground.execute(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Runnable() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { initDatabaseInternal(); mBackground.post(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DatabaseLoadedEvent()); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { Log.e(<span class="hljs-string"><span class="hljs-string">"Failed to init db"</span></span>, e); } } });</code> </pre><br>  So, for example, we can hide the progress bar and go to our MainActivity: <br><br><pre> <code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SplashActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> void onStart() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onStart(); eventBus.register(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> void onStop() { eventBus.unregister(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onStop(); } <span class="hljs-meta"><span class="hljs-meta">@Subscribe</span></span> public void on(<span class="hljs-type"><span class="hljs-type">DatabaseLoadedEvent</span></span> event) { progressBar.setVisibility(<span class="hljs-type"><span class="hljs-type">View</span></span>.<span class="hljs-type"><span class="hljs-type">GONE</span></span>); showMainActivity(); } }</code> </pre><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  The problem here is already well known to us: you cannot modify the UI from the background thread, and the code above tries to do just that. <br><br>  So we need to either take advantage of the possibilities of working with the stream from the greenrobot library, or do everything ourselves.  You should not reinvent the wheel in a production application, but for the purposes of training, let's try to do it with our bare hands, especially since it is very simple. <br><br>  But before that, let's dig in a little bit and see how the method marked with the <a href="https://habrahabr.ru/users/subscribe/" class="user_link">Subscribe</a> annotation is called when the event is published. <br><br>  Let's look at the source code of the Google Guava event bus: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EventBus</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final SubscriberRegistry subscribers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SubscriberRegistry(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Object </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span></span><span class="hljs-function">)</span></span> { subscribers.register(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unregister</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Object </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span></span><span class="hljs-function">)</span></span> { subscribers.unregister(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">post</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Object </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">)</span></span> { Iterator&lt;Subscriber&gt; eventSubscribers = subscribers.getSubscribers(<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (eventSubscribers.hasNext()) { dispatcher.dispatch(<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>, eventSubscribers); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(<span class="hljs-keyword"><span class="hljs-keyword">event</span></span> instanceof DeadEvent)) { <span class="hljs-comment"><span class="hljs-comment">// the event had no subscribers and was not itself a DeadEvent post(new DeadEvent(this, event)); } } }</span></span></code> </pre><br>  As you can see, the event bus stores subscribers in the <b>SubscriberRegistry</b> and tries to pass each event to the subscriber of this particular event (the key here is the name of the object class).  The list of subscribers can be thought of as <b>Map &lt;EventType, Subscriber&gt;</b> . <br><br>  Handling of threads depends on the dispatcher object, which by default is set to <b>Dispatcher.perThreadDispatchQueue ()</b> . <br><br>  What happens inside the dispatcher: <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PerThreadQueuedDispatcher</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dispatcher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">ThreadLocal</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Queue</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Event</span></span>&gt;&gt; queue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">ThreadLocal</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Queue</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Event</span></span>&gt;&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-type"><span class="hljs-type">Queue</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Event</span></span>&gt; initialValue() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">Queues</span></span>.newArrayDeque(); } }; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> void dispatch(<span class="hljs-type"><span class="hljs-type">Object</span></span> event, <span class="hljs-type"><span class="hljs-type">Iterator</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Subscriber</span></span>&gt; subscribers) { <span class="hljs-type"><span class="hljs-type">Queue</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Event</span></span>&gt; queueForThread = queue.get(); queueForThread.offer(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Event</span></span>(event, subscribers)); <span class="hljs-type"><span class="hljs-type">Event</span></span> nextEvent; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((nextEvent = queueForThread.poll()) != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (nextEvent.subscribers.hasNext()) { nextEvent.subscribers.next().dispatchEvent(nextEvent.event); } } }</code> </pre><br>  The main <b>thing</b> here: <b>PerThreadQueuedDispatcher</b> uses ThreadLocal to store the event queue.  In essence, this means that the subscriber method will be called on the same thread that the event was posted on. <br><br>  And what should we do about it?  The solution is simple - just publish events in the stream in which you want to process them: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postEventOnUiThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">final Object </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">)</span></span> { mUiHandler.post(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Runnable() { @<span class="hljs-function"><span class="hljs-function">Override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { mEventBus.post(<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>); } }); }</code> </pre><br>  This works, but introduces the problem that the event bus seems to be solving: reducing connectivity through the separation of publication and event handling.  With this solution, we oblige the code publishing the events to know in which thread the client would like to process the code. <br><br>  Another solution would be to use Handlers directly in the UI: <br><br><pre> <code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SplashActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Subscribe</span></span> public void on(<span class="hljs-type"><span class="hljs-type">DatabaseLoadedEvent</span></span> event) { runOnUiThread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Runnable</span></span>() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> public void run() { progressBar.setVisibility(<span class="hljs-type"><span class="hljs-type">View</span></span>.<span class="hljs-type"><span class="hljs-type">GONE</span></span>); showMainActivity(); } }) } }</code> </pre><br>  It also does not look like a complete solution.  And this is the limitation of the event bus.  How can this be handled?  Of course, using RxJava!  But about this - in the next part. <br><blockquote>  From the author: I am a member of the program committee of the Mobius conference, and its program is 90% complete.  Rather, see what the <a href="https://mobiusconf.com/">conference has prepared for</a> you, and wait for news about the finalization of the program! </blockquote></div><p>Source: <a href="https://habr.com/ru/post/351166/">https://habr.com/ru/post/351166/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351156/index.html">No need to complicate! Or how can redpolitika help promote your solutions to users?</a></li>
<li><a href="../351158/index.html">Family tree inside git</a></li>
<li><a href="../351160/index.html">#PostgreSQL. We accelerate the deployment seven times with the help of "multithreads"</a></li>
<li><a href="../351162/index.html">Alexey Ragozin on Java Mission Control on jug.msk.ru</a></li>
<li><a href="../351164/index.html">Welcome to the Whatever Hack hackathon March 16</a></li>
<li><a href="../351168/index.html">Understanding redux-saga: From action generators to sagas</a></li>
<li><a href="../351170/index.html">How Red Hat killed its main product and became a multi-billion dollar corporation</a></li>
<li><a href="../351172/index.html">Modbus protocol extension options: polling acceleration and a bit of security</a></li>
<li><a href="../351174/index.html">Oculus Rift helmets did not work for almost a day due to an overdue code signature certificate.</a></li>
<li><a href="../351176/index.html">Personal recommendations in ivi: Hydra</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>