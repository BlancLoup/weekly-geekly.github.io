<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to add realism to path tracing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, dear habrovchane. It would seem: where it is already more real, but still, I have an idea. In order. 

 Introduction 
 Path tracing is a virtua...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to add realism to path tracing</h1><div class="post__text post__text-html js-mediator-article">  Hello, dear habrovchane.  It would seem: where it is already more real, but still, I have an idea.  In order. <br><br><h4>  Introduction </h4><br>  Path tracing is a virtual reality scene creation method based on optics. <br><br>  In three-dimensional space, a lot of rays are emitted from a light source (ideally how many, how many photons are in reality) and the stories of each ray are traced.  When a beam meets an obstacle, several events are possible: absorption, reflection, refraction.  The probability of each of them depends on the material of the barrier and the color of the beam.  Those rays that hit the camera are drawn on the screen.  In general, it can be read in more detail in Wikipedia. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I will add only that in optics time is isotropic, it means that both directions of time are equal.  It turns out that you can follow the rays not from the source to the eye, but from the eye to the source.  It is more practical, path tracing and so very expensive, you can not waste time on tracing rays, in which there is no chance to be painted. <br><a name="habracut"></a><br><h4>  Idea </h4><br>  And what if to trace not rays, but photons.  This is the same!  I will clarify.  In one direction, emit at once many <b>monochromatic</b> photons.  Where there used to be a single beam, now 16, 32, 64 ... how many do not mind photons with a wavelength of 720, 700, ..., 450 nm.  And each of them may have their own story.  This will have meaning only when the material changes the direction of the photons at different frequencies in different ways. <br><br>  From school physics it is known that this is the cause of the dispersion of light.  Light dispersion occurs when the refractive index depends on the photon frequency.  It turns out that with the old approach it is impossible to realize this very variance.  It is impossible to "honestly" draw, for example, a diamond. <br><br>  On pseudocode, it somehow looks like this: <br><pre><code class="cpp hljs">i = <span class="hljs-number"><span class="hljs-number">0.</span></span>.screen_h<span class="hljs-number"><span class="hljs-number">-1</span></span> j = <span class="hljs-number"><span class="hljs-number">0.</span></span>.screen_w<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x = <span class="hljs-number"><span class="hljs-number">2</span></span>*j/screen_w<span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> y = <span class="hljs-number"><span class="hljs-number">2</span></span>*i/screen_h<span class="hljs-number"><span class="hljs-number">-1</span></span>; table[i, j] = norm(center+x*left+y*up); n = <span class="hljs-number"><span class="hljs-number">0.</span></span>.samples_num<span class="hljs-number"><span class="hljs-number">-1</span></span> i = <span class="hljs-number"><span class="hljs-number">0.</span></span>.screen_h<span class="hljs-number"><span class="hljs-number">-1</span></span> j = <span class="hljs-number"><span class="hljs-number">0.</span></span>.screen_w<span class="hljs-number"><span class="hljs-number">-1</span></span> freq = <span class="hljs-number"><span class="hljs-number">0.</span></span>.color_quality<span class="hljs-number"><span class="hljs-number">-1</span></span> power = <span class="hljs-number"><span class="hljs-number">0</span></span>; Ray r = ray_from_vecs(eye, table[i, j]); trace(&amp;r, &amp;power, freq); screen[i*w+j] = screen[i*w+j]+power*rgb_from_freq(freq); i = <span class="hljs-number"><span class="hljs-number">0.</span></span>.screen_h<span class="hljs-number"><span class="hljs-number">-1</span></span> j = <span class="hljs-number"><span class="hljs-number">0.</span></span>.screen_w<span class="hljs-number"><span class="hljs-number">-1</span></span> screen[i*w+j] /= samples_num;</code> </pre> <br><br>  Here, I think, everything is clear.  freq is the light wave frequency, screen_w, screen_h is the width and height of the screen in pixels, samples_num is the number of samples.  True color is the arithmetic average of all samples when the number of samples tends to infinity.  The vectors of the directions of photons are best stored in the table (table), so as not to count each time.  They are calculated by a simple formula, in which also participate the vectors pointing to the center of the screen, the left and the upper border of the screen.  For example, if the aspect ratio is 4: 3, then you can choose <br><br><pre> <code class="cpp hljs">center = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) left = (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) up = (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre><br><br>  Of course, it all depends on the implementation. <br><br>  Now about the trace function, ‚Äúmagic‚Äù happens in it.  It takes the position and direction of the beam, as well as its frequency, power (power) must be equal to zero.  It returns a new position and direction and power.  We are not interested in the position and direction, and it appears only so that the trace function can be called recursively. <br><br>  Color - an array whose size coincides with the number of gradations of frequencies. <br><br>  Again pseudocode <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Vec n; <span class="hljs-comment"><span class="hljs-comment">//      Vec p; //   Color dif; //      Color rfl; //      Color ems; //    Color koef; //       find_intersekt(); double f = random(); // (fade)   double a = dif[freq]; double b = a+rfl[freq]; r-&gt;pos = p; double k = n*r-&gt;dir; //       if (f &lt; a) //   { r-&gt;dir = ____; } if ((f &gt;= a) &amp;&amp; f &lt; b) //   { //      Vec a_ = cross(n, r-&gt;d); Vec b_ = cross(a_, koef*n); double d = 1-b_*b_; if (d &lt; 0) //    (  ),   r-&gt;dir = r-&gt;dir+2*k*n; else //   { double l = sqrt(d); r-&gt;dir = b_-l*n; } } if (f &lt; b) //    ,     trace(r, power, freq); power = power+ems[freq]*k; //      ,   }</span></span></code> </pre><br><br>  Of course, this pseudocode does not claim anything.  You can for example save different probabilities for refraction and specular reflection.  Or even complicate the model.  The main thing here - the probabilities and the refractive index depend on the frequency and each photon has its own. <br><br>  I looked through the pictures on request path tracing in Google and did not see the dispersion of light.  A search for the monochromatic path tracing did not show anything interesting.  I reviewed the whole first page, everywhere these words are divided by others and in the article itself there is no my idea. <br><br>  Of course, most likely it has already been implemented and described in books that I have not reached yet. <br><br><h4>  Consequences </h4><br>  There is no need to be a genius to understand: the tracing of monochromatic photons will cost 16, 32, ... more expensive than the standard algorithm (depending on the color quality).  Now tracing the path in real time on the hardware of a regular user is impossible and incomprehensible when this can be done.  A "monochromatic" tracing is even more expensive. </div><p>Source: <a href="https://habr.com/ru/post/164727/">https://habr.com/ru/post/164727/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../164709/index.html">Work with Freebase from .NET</a></li>
<li><a href="../164711/index.html">Simulation of life in the Darwinbots system. I. First acquaintance</a></li>
<li><a href="../164717/index.html">Optimize SQL Server performance using indexes</a></li>
<li><a href="../164721/index.html">Porting Qt4 application to Qt5</a></li>
<li><a href="../164725/index.html">Experience creating a game for smartphones</a></li>
<li><a href="../164729/index.html">Tricks sysadmins</a></li>
<li><a href="../164731/index.html">Solve 9 Windows Server 2008 management tasks using PowerShell. Part 1</a></li>
<li><a href="../164733/index.html">Creating a captcha with your own hands.</a></li>
<li><a href="../164735/index.html">Will it rain?</a></li>
<li><a href="../164737/index.html">Nexus 7 as a navigator in -32. Minitest</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>