<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parsing function calls in PHP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post is dedicated to optimizing PHP using a Blackfire profiler in a PHP script. The text below is a detailed technical explanation of a Blackfire...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parsing function calls in PHP</h1><div class="post__text post__text-html js-mediator-article">  This post is dedicated to optimizing PHP using a <a href="https://blackfire.io/">Blackfire profiler</a> in a PHP script.  The text below is a detailed technical explanation of a <a href="http://blog.blackfire.io/owncloud.html">Blackfire blog article</a> . <br><br>  The strlen method is usually used: <br><br><pre><code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (strlen($name) &gt; <span class="hljs-number"><span class="hljs-number">49</span></span>) { ... }</code> </pre> <br>  However, this option is about 20% slower than this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>($name[<span class="hljs-number"><span class="hljs-number">49</span></span>])) { ... }</code> </pre><br>  Looks good.  Surely you are ready to open your source code and replace all calls to <i>strlen ()</i> with <i>isset ()</i> .  But if you carefully read the <a href="http://blog.blackfire.io/owncloud.html">original article</a> , you can see that the reason for the 20% difference in performance is multiple calls to <i>strlen ()</i> , about 60-80 thousand iterations. <br><a name="habracut"></a><br><h1>  Why? </h1><br>  It's not about how <i>strlen ()</i> calculates the lengths of strings in PHP, because all of them are already known by the time this method is called.  Most, if possible, are computed at compile time.  The length of a PHP string sent to memory is encapsulated in a C-structure containing this same string.  Therefore, <i>strlen ()</i> simply reads this information and returns as is.  This is probably the fastest of the PHP functions, because it doesn't compute anything at all.  Here is its source code: <br><br><pre> <code class="php hljs">ZEND_FUNCTION(strlen) { char *s1; int s1_len; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="hljs-string"><span class="hljs-string">"s"</span></span>, &amp;s1, &amp;s1_len) == FAILURE) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } RETVAL_LONG(s1_len); }</code> </pre><br>  Considering that <i>isset () is</i> not a function, the reason for the 20% performance loss of <i>strlen () is</i> for the most part the attendant delays when calling a function in the Zend engine. <br><br>  There is one more thing: when comparing the performance of <i>strlen ()</i> with something else, an additional opcode is added.  And in the case of <i>isset ()</i> , only one unique opcode is used. <br><br>  An example of a disassembled <i>if (strlen ())</i> structure: <br><br><pre> <code class="php hljs">line <span class="hljs-comment"><span class="hljs-comment">#* IO op fetch ext return operands ----------------------------------------------------------------------------------- 3 0 &gt; SEND_VAR !0 1 DO_FCALL 1 $0 'strlen' 2 IS_SMALLER ~1 42, $0 3 &gt; JMPZ ~1, -&gt;5 5 4 &gt; &gt; JMP -&gt;5 6 5 &gt; &gt; RETURN 1</span></span></code> </pre><br>  And here is a semantically equivalent <i>if (isset ())</i> structure: <br><br><pre> <code class="php hljs">line <span class="hljs-comment"><span class="hljs-comment">#* IO op fetch ext return operands ----------------------------------------------------------------------------------- 3 0 &gt; ISSET_ISEMPTY_DIM_OBJ 33554432 ~0 !0, 42 1 &gt; JMPZ ~0, -&gt;3 5 2 &gt; &gt; JMP -&gt;3 6 3 &gt; &gt; RETURN 1</span></span></code> </pre><br>  As you can see, the <i>isset ()</i> code does not activate any function call (DO_FCALL).  Also, there is no opcode IS_SMALLER (just ignore the RETURN statements);  <i>isset ()</i> directly returns a boolean value;  <i>strlen ()</i> first returns a temporary variable, then it is passed to opcode IS_SMALLER, and the final result is calculated using <i>if ()</i> .  That is, the <i>strlen ()</i> structure uses two opcode, and the <i>isset ()</i> structure uses one.  Therefore, <i>isset ()</i> demonstrates better performance, because one operation is usually performed faster than two. <br><br>  Let's now figure out how function calls work in PHP and how they differ from <i>isset ()</i> . <br><br><h1>  Function calls in php </h1><br>  The most difficult thing to analyze is that part of the virtual machine (the moment the PHP code is executed) that is associated with the function calls.  I will try to state the essence, without going deep into the moments concerning function calls. <br><br>  First, let's analyze <b>the runtime (runtime)</b> calls.  <b>Compile time</b> requires a lot of resources to perform operations related to PHP functions.  But if you use the opcode cache, then at compile time you will have no problems. <br><br>  Suppose we have compiled a script.  Let's analyze only what happens at <b>run time</b> .  Here is the dump of the opcode call to the inner function (in this case, <i>strlen ()</i> ): <br><br><pre> <code class="php hljs">strlen($a); line <span class="hljs-comment"><span class="hljs-comment">#* IO op fetch ext return operands ----------------------------------------------------------------------------------- 3 0 &gt; SEND_VAR !0 1 DO_FCALL 1 'strlen'</span></span></code> </pre><br>  To understand the mechanism for calling a function, you need to know two things: <br><br><ul><li>  function call and method call are the same </li><li>  a call to a user function and a call to an internal function are handled differently </li></ul><br>  That's why the last example talks about calling an ‚Äúinternal‚Äù function: <i>strlen ()</i> is a PHP function that is part of the C code.  If we had dumped the opcode ‚Äúuser-defined‚Äù PHP function (that is, a function that is written in PHP), we could get either the exact same or some other opcode. <br><br>  The fact is that regardless of whether PHP knows this function or not, it does not generate the same opcode at compile time.  Obviously, internal PHP functions are known at compile time, since they are declared before the compiler runs.  But there can be no clarity regarding user-defined functions, because they can be called before they are declared.  If we talk about execution, then internal PHP functions are more efficient than user ones, and moreover they have more validation mechanisms available. <br><br>  From the example above, it can be seen that more than one opcode is used to control function calls.  You also need to remember that functions have their own stack.  In PHP, as in any other language, to call a function, you first need to create a stack frame and pass function arguments to it.  Then you call the function that pulls these arguments from the stack for your needs.  Upon completion of the call you have to destroy the frame created earlier. <br><br>  So in general, the scheme of working with function calls looks like.  However, PHP provides for optimizing the procedures for creating and deleting a stack frame;  in addition, you can postpone their execution so that you do not have to do all these movements with each call of the function. <br><br>  Opcode SEND_VAR is responsible for sending arguments to the stack frame.  The compiler necessarily generates such an opcode before calling the function.  And for each variable it creates its own: <br><br><pre> <code class="php hljs">$a = <span class="hljs-string"><span class="hljs-string">'/'</span></span>; setcookie(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>, $a); line <span class="hljs-comment"><span class="hljs-comment">#* IO op fetch ext return operands ----------------------------------------------------------------------------------- 3 0 &gt; ASSIGN !0, '%2F' 4 1 SEND_VAL 'foo' 2 SEND_VAL 'bar' 3 SEND_VAL 128 4 SEND_VAR !0 5 DO_FCALL 4 'setcookie'</span></span></code> </pre><br>  Here you see another opcode - SEND_VAL.  In total there are 4 types of opcode to send something to the function stack: <br><br><ul><li>  <b>SEND_VAL</b> : sends constant value (string, integer, etc.) </li><li>  <b>SEND_VAR</b> : send PHP variable ($ a) </li><li>  <b>SEND_REF</b> : sends a PHP variable as a link to a function that takes an argument as a link. </li><li>  <b>SEND_VAR_NO_REF</b> : optimized handler used in cases with nested functions </li></ul><br><br>  What does SEND_VAR do? <br><br><pre> <code class="cpp hljs">ZEND_VM_HELPER(zend_send_by_var_helper, VAR|CV, ANY) { USE_OPLINE zval *varptr; zend_free_op free_op1; varptr = GET_OP1_ZVAL_PTR(BP_VAR_R); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (varptr == &amp;EG(uninitialized_zval)) { ALLOC_ZVAL(varptr); INIT_ZVAL(*varptr); Z_SET_REFCOUNT_P(varptr, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PZVAL_IS_REF(varptr)) { zval *original_var = varptr; ALLOC_ZVAL(varptr); ZVAL_COPY_VALUE(varptr, original_var); Z_UNSET_ISREF_P(varptr); Z_SET_REFCOUNT_P(varptr, <span class="hljs-number"><span class="hljs-number">0</span></span>); zval_copy_ctor(varptr); } Z_ADDREF_P(varptr); zend_vm_stack_push(varptr TSRMLS_CC); FREE_OP1(); <span class="hljs-comment"><span class="hljs-comment">/* for string offsets */</span></span> CHECK_EXCEPTION(); ZEND_VM_NEXT_OPCODE(); }</code> </pre><br>  SEND_VAR checks if a variable is a link.  If yes, then it separates it, thereby creating a disparity of the link.  Why this is very bad, you can read in my other <a href="http://jpauli.github.io/2014/06/27/references-mismatch.html">article</a> .  Then SEND_VAR adds the number of links to it (the link here is not a link in terms of PHP, that is, not that &amp;, but just an indicator of how many people use this value) to the variable and sends it to the virtual machine stack: <br><br><pre> <code class="php hljs">Z_ADDREF_P(varptr); zend_vm_stack_push(varptr TSRMLS_CC);</code> </pre><br>  Each time you call a function, you increment by one the refcount of each variable argument in the stack.  This is because the variable will not be referenced by the function code, but by its stack.  Sending a variable to the stack has little effect on performance, but the stack takes up memory.  It is placed in it at runtime, but its size is calculated at compile time.  After we send the variable to the stack, run DO_FCALL.  Below is an example of how much code and checks are used only so that we consider calls to PHP functions to be "slow" statements (slow statement): <br><br><pre> <code class="php hljs">ZEND_VM_HANDLER(<span class="hljs-number"><span class="hljs-number">60</span></span>, ZEND_DO_FCALL, <span class="hljs-keyword"><span class="hljs-keyword">CONST</span></span>, ANY) { USE_OPLINE zend_free_op free_op1; zval *fname = GET_OP1_ZVAL_PTR(BP_VAR_R); call_slot *call = EX(call_slots) + opline-&gt;op2.num; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CACHED_PTR(opline-&gt;op1.literal-&gt;cache_slot)) { EX(function_state).function = CACHED_PTR(opline-&gt;op1.literal-&gt;cache_slot); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UNEXPECTED(zend_hash_quick_find(EG(function_table), Z_STRVAL_P(fname), Z_STRLEN_P(fname)+<span class="hljs-number"><span class="hljs-number">1</span></span>, Z_HASH_P(fname), (void **) &amp;EX(function_state).function)==FAILURE)) { SAVE_OPLINE(); zend_error_noreturn(E_ERROR, <span class="hljs-string"><span class="hljs-string">"Call to undefined function %s()"</span></span>, fname-&gt;value.str.val); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CACHE_PTR(opline-&gt;op1.literal-&gt;cache_slot, EX(function_state).function); } call-&gt;fbc = EX(function_state).function; call-&gt;object = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; call-&gt;called_scope = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; call-&gt;is_ctor_call = <span class="hljs-number"><span class="hljs-number">0</span></span>; EX(call) = call; FREE_OP1(); ZEND_VM_DISPATCH_TO_HELPER(zend_do_fcall_common_helper); }</code> </pre><br>  As you can see, small checks are carried out here and various caches are used.  For example, the handler pointer found the very first call, and then was cached into the main frame of the virtual machine so that each subsequent call could use this pointer. <br><br>  Next we call <b>zend_do_fcall_common_helper ()</b> .  I will not post here the code of this function, it is too voluminous.  I will show only those operations that were performed there.  In short, this is a variety of different checks made during execution.  PHP is a dynamic language, at runtime it can declare new functions and classes, simultaneously downloading files automatically.  Therefore, PHP is forced to perform many checks at runtime, which has a bad effect on performance.  But this is not going anywhere. <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UNEXPECTED((fbc-&gt;common.fn_flags &amp; (ZEND_ACC_ABSTRACT|ZEND_ACC_DEPRECATED)) != <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UNEXPECTED((fbc-&gt;common.fn_flags &amp; ZEND_ACC_ABSTRACT) != <span class="hljs-number"><span class="hljs-number">0</span></span>)) { zend_error_noreturn(E_ERROR, <span class="hljs-string"><span class="hljs-string">"Cannot call abstract method %s::%s()"</span></span>, fbc-&gt;common.scope-&gt;name, fbc-&gt;common.function_name); CHECK_EXCEPTION(); ZEND_VM_NEXT_OPCODE(); <span class="hljs-comment"><span class="hljs-comment">/* Never reached */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UNEXPECTED((fbc-&gt;common.fn_flags &amp; ZEND_ACC_DEPRECATED) != <span class="hljs-number"><span class="hljs-number">0</span></span>)) { zend_error(E_DEPRECATED, <span class="hljs-string"><span class="hljs-string">"Function %s%s%s() is deprecated"</span></span>, fbc-&gt;common.scope ? fbc-&gt;common.scope-&gt;name : <span class="hljs-string"><span class="hljs-string">""</span></span>, fbc-&gt;common.scope ? <span class="hljs-string"><span class="hljs-string">"::"</span></span> : <span class="hljs-string"><span class="hljs-string">""</span></span>, fbc-&gt;common.function_name); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fbc-&gt;common.scope &amp;&amp; !(fbc-&gt;common.fn_flags &amp; ZEND_ACC_STATIC) &amp;&amp; !EX(object)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fbc-&gt;common.fn_flags &amp; ZEND_ACC_ALLOW_STATIC) { <span class="hljs-comment"><span class="hljs-comment">/* </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">FIXME:</span></span></span><span class="hljs-comment"> output identifiers properly */</span></span> zend_error(E_STRICT, <span class="hljs-string"><span class="hljs-string">"Non-static method %s::%s() should not be called statically"</span></span>, fbc-&gt;common.scope-&gt;name, fbc-&gt;common.function_name); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">FIXME:</span></span></span><span class="hljs-comment"> output identifiers properly */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */</span></span> zend_error_noreturn(E_ERROR, <span class="hljs-string"><span class="hljs-string">"Non-static method %s::%s() cannot be called statically"</span></span>, fbc-&gt;common.scope-&gt;name, fbc-&gt;common.function_name); } }</code> </pre><br>  See how many checks?  Go ahead: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fbc-&gt;type == ZEND_USER_FUNCTION || fbc-&gt;common.scope) { should_change_scope = <span class="hljs-number"><span class="hljs-number">1</span></span>; EX(current_this) = EG(This); EX(current_scope) = EG(scope); EX(current_called_scope) = EG(called_scope); EG(This) = EX(object); EG(scope) = (fbc-&gt;type == ZEND_USER_FUNCTION || !EX(object)) ? fbc-&gt;common.scope : <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; EG(called_scope) = EX(call)-&gt;called_scope; }</code> </pre><br>  You know that each function body has its own variable scope.  The engine switches visibility tables before calling the function code, so if it requests a variable, it will be found in the corresponding table.  And since the functions and methods are essentially the same, you can read about how to bind the <i>$ this</i> pointer to the method. <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fbc-&gt;type == ZEND_INTERNAL_FUNCTION) {</code> </pre><br>  As I said above, internal functions (which are part of C) have a different execution path, not the same as user functions.  It is usually shorter and better optimized, because we can tell the engine information about internal functions, which is not the case with user-defined ones. <br><br><pre> <code class="php hljs">fbc-&gt;internal_function.handler(opline-&gt;extended_value, ret-&gt;var.ptr, (fbc-&gt;common.fn_flags &amp; ZEND_ACC_RETURN_REFERENCE) ? &amp;ret-&gt;var.ptr : <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, EX(object), RETURN_VALUE_USED(opline) TSRMLS_CC);</code> </pre><br>  The line above calls the internal function handler.  In the case of our example regarding <i>strlen (),</i> this line will call the code: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/* PHP's strlen() source code */</span></span> ZEND_FUNCTION(strlen) { char *s1; int s1_len; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="hljs-string"><span class="hljs-string">"s"</span></span>, &amp;s1, &amp;s1_len) == FAILURE) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } RETVAL_LONG(s1_len); }</code> </pre><br>  What does <i>strlen ()</i> do?  It retrieves the argument from the stack using <i>zend_parse_parameters ()</i> .  This is a ‚Äúslow‚Äù function, because it has to raise the stack and convert the argument to the type expected by the function (in our case, to string).  Therefore, no matter what you pass to the stack for <i>strlen ()</i> , it may need to convert the argument, and this is not the easiest process in terms of performance.  The source code <i><a href="">zend_parse_parameters ()</a></i> gives a good idea of ‚Äã‚Äãhow many operations the processor has to perform during the extraction of arguments from the stack frame of the function. <br><br>  Go to the next step.  We have just executed the code of the function body, now we need to ‚Äúclean up‚Äù.  Let's start with the restoration of the scope: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (should_change_scope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (EG(This)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UNEXPECTED(EG(<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span>) != <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>) &amp;&amp; EX(call)-&gt;is_ctor_call) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (EX(call)-&gt;is_ctor_result_used) { Z_DELREF_P(EG(This)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Z_REFCOUNT_P(EG(This)) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { zend_object_store_ctor_failed(EG(This) TSRMLS_CC); } } zval_ptr_dtor(&amp;EG(This)); } EG(This) = EX(current_this); EG(scope) = EX(current_scope); EG(called_scope) = EX(current_called_scope); }</code> </pre><br>  Then clear the stack: <br><br><pre> <code class="php hljs">zend_vm_stack_clear_multiple(<span class="hljs-number"><span class="hljs-number">1</span></span> TSRMLS_CC);</code> </pre><br>  And finally, if any exceptions were made during the execution of the function, you need to send the virtual machine to the block to catch this exception: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UNEXPECTED(EG(<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span>) != <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>)) { zend_throw_exception_internal(<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> TSRMLS_CC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RETURN_VALUE_USED(opline) &amp;&amp; EX_T(opline-&gt;result.<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.ptr) { zval_ptr_dtor(&amp;EX_T(opline-&gt;result.<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.ptr); } HANDLE_EXCEPTION(); }</code> </pre><br><h1>  About PHP function calls </h1><br>  Now you can imagine how much time your computer spends on calling the ‚Äúvery small and simple‚Äù function <i>strlen ()</i> .  And since it is called repeatedly, increase this time, say, 25,000 times.  This is how micro and milliseconds turn into full seconds ... Please note that I demonstrated only the most important instructions for us during each call to a PHP function.  After that, a lot of interesting things happen.  Also keep in mind that in the case of <i>strlen ()</i> , only one line performs ‚Äúuseful work‚Äù, and the accompanying procedures for preparing a function call are larger in volume than the ‚Äúuseful‚Äù part of the code.  However, in most cases, the own function code still affects performance more than the ‚Äúauxiliary‚Äù engine code. <br><br>  That part of the PHP code that refers to the function call in PHP 7 has been reworked to improve performance.  However, this is not the end, and the PHP source code will be optimized more than once with each new release.  Older versions were not forgotten, function calls were optimized in versions from 5.3 to 5.5.  For example, in versions from 5.4 to 5.5, the method of calculating and creating a stack frame was changed (while maintaining compatibility).  For the sake of interest, you can compare the changes in the execution module and the method of calling functions <a href="https://github.com/php/php-src/blob/PHP-5.5/UPGRADING.INTERNALS">made in version 5.5</a> compared to 5.4. <br><br>  I want to emphasize: all of the above does not mean that PHP is bad.  This language has been developing for 20 years, a lot of very talented programmers worked on its source code.  During this period, it has been reworked, optimized and improved many times.  Proof of this is the fact that you are using PHP today and it demonstrates good overall performance in a wide variety of projects. <br><br><h1>  What about isset ()? </h1><br>  This is not a function, parentheses do not necessarily mean ‚Äúfunction call‚Äù.  <i>isset () is</i> included in the special opcode of the Zend virtual machine (ISSET_ISEMPTY), which does not initialize the function call and is not subject to the associated delays.  Since <i>isset ()</i> can use parameters of several types, its code in the Zend virtual machine is quite long.  But if you leave only the part related to the offset parameter, you get something like this: <br><br><pre> <code class="php hljs">ZEND_VM_HELPER_EX(zend_isset_isempty_dim_prop_obj_handler, <span class="hljs-keyword"><span class="hljs-keyword">VAR</span></span>|UNUSED|CV, <span class="hljs-keyword"><span class="hljs-keyword">CONST</span></span>|TMP|<span class="hljs-keyword"><span class="hljs-keyword">VAR</span></span>|CV, int prop_dim) { USE_OPLINE zend_free_op free_op1, free_op2; zval *container; zval **value = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; int result = <span class="hljs-number"><span class="hljs-number">0</span></span>; ulong hval; zval *offset; SAVE_OPLINE(); container = GET_OP1_OBJ_ZVAL_PTR(BP_VAR_IS); offset = GET_OP2_ZVAL_PTR(BP_VAR_R); <span class="hljs-comment"><span class="hljs-comment">/* ... code pruned ... */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Z_TYPE_P(container) == IS_STRING &amp;&amp; !prop_dim) { <span class="hljs-comment"><span class="hljs-comment">/* string offsets */</span></span> zval tmp; <span class="hljs-comment"><span class="hljs-comment">/* ... code pruned ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Z_TYPE_P(offset) == IS_LONG) { <span class="hljs-comment"><span class="hljs-comment">/* we passed an integer as offset */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opline-&gt;extended_value &amp; ZEND_ISSET) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (offset-&gt;value.lval &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; offset-&gt;value.lval &lt; Z_STRLEN_P(container)) { result = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">/* if (opline-&gt;extended_value &amp; ZEND_ISEMPTY) */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (offset-&gt;value.lval &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; offset-&gt;value.lval &lt; Z_STRLEN_P(container) &amp;&amp; Z_STRVAL_P(container)[offset-&gt;value.lval] != <span class="hljs-string"><span class="hljs-string">'0'</span></span>) { result = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } } FREE_OP2(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { FREE_OP2(); } Z_TYPE(EX_T(opline-&gt;result.<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>).tmp_var) = IS_BOOL; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opline-&gt;extended_value &amp; ZEND_ISSET) { Z_LVAL(EX_T(opline-&gt;result.<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>).tmp_var) = result; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Z_LVAL(EX_T(opline-&gt;result.<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>).tmp_var) = !result; } FREE_OP1_VAR_PTR(); CHECK_EXCEPTION(); ZEND_VM_NEXT_OPCODE(); }</code> </pre><br>  If you remove the numerous decision points ( <i>if</i> constructions), then the ‚Äúmain‚Äù computational algorithm can be expressed as: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (offset-&gt;value.lval &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; offset-&gt;value.lval &lt; Z_STRLEN_P(container))</code> </pre><br>  If offset is greater than zero (you did not mean <i>isset ($ a [-42])</i> ) and strictly less than the length of the string, the result will be taken as 1. Then the result of the operation will be a boolean TRUE.  Do not worry about the length calculation, <i>Z_STRLEN_P (container)</i> does not calculate anything.  Remember that PHP already knows the length of your string.  <i>Z_STRLEN_P (container)</i> simply reads this value into memory, which consumes very little processor resources. <br><br>  Now you understand why, from the point of view of using line offset, processing a call to the <i>strlen ()</i> function requires MUCH more computational resources than <i>isset ()</i> processing.  The latter is essentially "easier."  Do not be afraid of a large number of conditional if statements, this is not the hardest part of the C-code.  In addition, they can be optimized using the C-compiler.  The handler code <i>isset ()</i> does not search in hash tables, does not perform complex checks, does not assign a pointer to one of the stack frames, in order to later retrieve it.  The code is much easier than the general code of the function call, and much less often accesses memory (this is the most important point).  And if you loop up the repeated execution of such a line, you can achieve a big performance improvement.  Of course, the results of one iteration of <i>strlen ()</i> and <i>isset ()</i> will differ slightly - by about 5 ms.  But if you spend 50,000 iterations ... <br><br>  Also note that <i>isset ()</i> and <i>empty () have</i> almost the <a href="">same source code</a> .  In the case of a line offset, <i>empty ()</i> will differ from <i>isset ()</i> only by additional reading, if the first character of the line is not 0. Since the codes <i>empty ()</i> and <i>isset ()</i> do not differ much from each other, then <i>empty ()</i> will show the same performance as <i>isset ()</i> (considering that both are used with the same parameters). <br><br><h1>  How can OPCache help us? </h1><br>  In short - nothing. <br><br>  OPCache optimizes code.  This can be <a href="http://fr.slideshare.net/jpauli/yoopee-cache-op-cache-internals">read in the presentation</a> .  It is often asked whether it is possible to add an optimization pass, in which <i>strlen ()</i> switches to <i>isset ()</i> .  No, It is Immpossible. <br><br>  OPCache optimization passes are performed in OPArray before it is placed in shared memory.  <b>This happens at compile time, not at run time.</b>  How do we know at compile time that the variable that is passed to <i>strlen ()</i> is a <i>string</i> ?  This is a known PHP problem, and it is partly solved by HHVM / Hack.  If we wrote down our variables with strong typing in PHP, then during the compiler passes one could optimize a lot more things (like in a virtual machine).  Since PHP is a dynamic language, almost nothing is known at compile time.  OPCache can only optimize static things known by the time a compilation starts.  For example, this: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (strlen(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* do domething */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* do something else */</span></span> }</code> </pre><br>  During compilation it is known that the length of the string ‚Äúfoo‚Äù is no more than 8, so you can throw out all the opcode if (), and leave only the part with the if construct with the else. <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (strlen($a) &gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* do domething */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* do something else */</span></span> }</code> </pre><br>  But what is <i>$ a</i> ?  Does it even exist?  Is it a string?  By the time of the passage of the optimizer, we still can not answer all these questions - this is the task for the execution module of the virtual machine.  At compile time, we process the abstract structure, and the type and amount of memory we need will be known at run time. <br><br>  OPCache optimizes many things, but because of the very nature of PHP, it cannot optimize everything.     ,    Java  . , PHP       .            read-only: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> read-only $a = <span class="hljs-string"><span class="hljs-string">"foo"</span></span>; }</code> </pre><br>    ,         .     ,    <i>$a</i> .  ,    ,    - ,                OPCache.     ,                ,   OPCache  ,      ,   . <br><br><h1>       </h1><br>           ,     - .    .    Blackfire        ,      ,   .  ,    .     ,     .     ,      ,  ,   ,     . <br><br>  : PHP   ,   .   PHP-    ‚Äî ,  ,       .               .      ,  ,    .        ,        .  PHP   ,   <i>foreach()</i> ,        opcode.    <i>while</i>  <i>for</i> ,     . <br><br>    ,   ,        ,     - . <br><br><pre> <code class="php hljs">phpversion() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">the</span></span> <span class="hljs-title"><span class="hljs-title">PHP_VERSION</span></span> <span class="hljs-title"><span class="hljs-title">constant</span></span> <span class="hljs-title"><span class="hljs-title">php_uname</span></span>() =&gt; <span class="hljs-title"><span class="hljs-title">use</span></span> <span class="hljs-title"><span class="hljs-title">the</span></span> <span class="hljs-title"><span class="hljs-title">PHP_OS</span></span> <span class="hljs-title"><span class="hljs-title">constant</span></span> <span class="hljs-title"><span class="hljs-title">php_sapi_name</span></span>() =&gt; <span class="hljs-title"><span class="hljs-title">use</span></span> <span class="hljs-title"><span class="hljs-title">the</span></span> <span class="hljs-title"><span class="hljs-title">PHP_SAPI</span></span> <span class="hljs-title"><span class="hljs-title">constant</span></span> <span class="hljs-title"><span class="hljs-title">time</span></span>() =&gt; <span class="hljs-title"><span class="hljs-title">read</span></span> $<span class="hljs-title"><span class="hljs-title">_SERVER</span></span>['<span class="hljs-title"><span class="hljs-title">REQUEST_TIME</span></span>'] <span class="hljs-title"><span class="hljs-title">session_id</span></span>() =&gt; <span class="hljs-title"><span class="hljs-title">use</span></span> <span class="hljs-title"><span class="hljs-title">the</span></span> <span class="hljs-title"><span class="hljs-title">SID</span></span> <span class="hljs-title"><span class="hljs-title">constant</span></span></code> </pre><br>      ,     . <br><br> ,     , : <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ bar(); }</code> </pre><br>   : <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ call_user_func_array(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>, func_get_args()); }</code> </pre><br>     ,     ,   - -     - .        ,          . <br><br>        ,     .   . <br><br>   Blackfire        ,      .    ( GUI    ): ,    ,   ,   /  ,         ,  ,   <i>foreach()</i>  ..  etc. <br><br>   ,          . ,     - . PHP     ORM, , HTTP-    .     ,    .          ,      : Java, Go , ,      ‚Äî C/C++ (Java  Go    ). </div><p>Source: <a href="https://habr.com/ru/post/250861/">https://habr.com/ru/post/250861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../250851/index.html">Why Bittorent via Tor is a Bad Idea</a></li>
<li><a href="../250853/index.html">Simple webdev in java 8</a></li>
<li><a href="../250855/index.html">Applied optimization practice and some history</a></li>
<li><a href="../250857/index.html">MailChimp UX Team: Collaboration [Part 2 of the Book]</a></li>
<li><a href="../250859/index.html">VPN everywhere: IPsec without L2TP with strongSwan</a></li>
<li><a href="../250867/index.html">When the site can be more than 1Mb?</a></li>
<li><a href="../250873/index.html">Unity: Build under Android or "size matters"</a></li>
<li><a href="../250875/index.html">What is Business Intelligence?</a></li>
<li><a href="../250879/index.html">Everything has been stolen before us.</a></li>
<li><a href="../250881/index.html">Optimizing ASP.NET - practical tips for working with IIS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>