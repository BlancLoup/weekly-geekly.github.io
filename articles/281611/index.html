<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Nix as a dependency manager for C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, a lot of talk has been going on that for C ++ you need your own package manager like pip, npm, maven, cargo, etc. All competitors have a sim...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Nix as a dependency manager for C ++</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/e64/89f/55e/e6489f55ec7e4b8fa0ff3121178404a8.png" alt="Nix loves C ++"></p><br><p>  Recently, a lot of talk has been going on that for C ++ you need your own package manager like pip, npm, maven, cargo, etc.  All competitors have a simple and standardized mechanism for connecting a non-standard library.  In C ++, everyone acts as they can: someone registers a list of packages for Ubuntu, CentOS and other distributions in README, someone uses git submodule and scripts to build them, someone uses CMake ExternalProject, someone copies all the sources into one giant repository, someone doing the Docker or Vagrant image. </p><br><p>  To solve the problem, a startup <a href="https://github.com/biicode/">biicode</a> was even created, but he went bankrupt and his future is unknown.  <a href="https://conan.io/">Conan</a> appeared in <a href="https://conan.io/">return</a> , complementing the competitors' zoo ‚Äî <a href="http://nuget.org/">nuget</a> , <a href="https://github.com/pfultz2/cget">cget</a> , <a href="https://github.com/ruslo/hunter">hunter</a> , <a href="https://cpm.rocks/">cpm</a> , <a href="https://qpm.io/">qpm</a> , <a href="http://cppget.org/">cppget</a> , <a href="http://sourcey.com/pacm">pacm,</a> and even <a href="http://gradle.org/getting-started-native/">gradle for c ++</a> . </p><br><p>  I was not satisfied with any of these methods.  I started writing packages for Conan, but I encountered a large number of hacks, an undeveloped API, a lack of guidelines and, as a result, a low probability of reusing other people's packages.  And then I remembered that once I really liked the ideas of the package manager in <a href="http://nixos.org/">NixOS</a> .  And I thought, why bother to produce a package manager specifically for C ++, if the same tasks are solved by a regular package manager?  It is only necessary that it be sufficiently flexible and simple in the description of the package.  And Nix was perfect for this role. </p><a name="habracut"></a><br><p>  So, what gave us Nix: </p><br><ul><li> The ability to get ready for the assembly of the project environment with one command - <code>nix-shell</code> ; </li><li>  7344 ready and supported packages from <code>nixpkgs</code> ; </li><li>  The ability to create a derived package from a package from the repository (without copying its code); </li><li>  Ability to specify in dependencies not only C / C ++ libraries, but also the necessary tools (CMake, GCC), projects from other ecosystems (npm, pip), services (redis); </li><li>  Ability to bind environment to commit.  This means that, for example, the master branch can use boost 1.55, and devel - 1.60.  When switching from branch to branch, Nix will automatically set up the environment for the required version, and this will take less than a second (if the assembly is already in the cache); </li><li>  Non-intrusiveness - the project does not depend on Nix, its use is a personal matter of everyone.  You can collect all dependencies manually (or by your favorite package manager), specifying all the correct options for cmake. </li></ul><br><h1>  What is Nix </h1><br><p>  Nix is ‚Äã‚Äãa functional programming language, tailored to the needs of the package manager (not surprisingly, it gained popularity in the Haskell community).  Build a package is a function calculation in Nix.  And as it should be for a functional programming language, repeated calls to a function with the same arguments produce the same result (binary package).  This means that packages can be cached, which Nix does - all assemblies are stored in <code>/nix/store/$HASH-$PKGNAME</code> .  In addition, you can check if someone else has a package with the same hash on the network, and if there is, download the binary package from it. </p><br><p>  Thus, a ‚Äúpackage‚Äù (here called derivation) in Nix is ‚Äã‚Äãa function, and ‚Äúdependencies‚Äù are the arguments of this function.  What is a repository ( <code>NixPkgs</code> )?  This is also a function that has no arguments, which returns multiple packages.  Is it possible that to use the repository you need to collect all 7344 packages?  Not!  Nix is ‚Äã‚Äãa lazy language, which means nothing will be calculated until it is explicitly required.  A "request" package can be utilities. </p><br><h1>  Minimal environment </h1><br><p>  So, before you use Nix, you need to install it.  To do this, you can either use the whole Linux distribution (NixOS), or install the <a href="https://nixos.org/nix/">package manager</a> separately for your favorite OS (supported by Linux and MacOS).  All Nix impacts will be limited to the <code>/nix</code> directory and files in the home directory ( <code>~/.nix-channel</code> , <code>.nix-defexpr</code> , <code>.nix-profile</code> ). </p><br><p>  <code>~/.nix-profile</code> stores symlinks for the packages requested by the user.  We need to configure the environment not for the user, but for the project.  To do this, use the <code>nix-shell</code> utility: it executes the given Nix input and launches the bash shell, in which the result is available (and only it).  Checking: </p><br><pre> <code class="hljs ruby">bash-<span class="hljs-number"><span class="hljs-number">3.2</span></span>$ nix-shell -p stdenv [nix-<span class="hljs-symbol"><span class="hljs-symbol">shell:</span></span>~]$</code> </pre> <br><p>  Here we use the ( <code>-p</code> ) <code>stdenv</code> package as an expression.  <code>stdenv</code> is the minimal environment that contains the compiler, make, and other essential things. </p><br><h1>  Build Environment </h1><br><p>  If you run <code>nix-shell</code> with no arguments, the expression is read from the <code>default.nix</code> file.  Create it: </p><br><pre> <code class="hljs pgsql">{ pkgs ? <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> &lt;nixpkgs&gt; {} }: let stdenv = pkgs.stdenv; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rec { myProject = stdenv.mkDerivation { <span class="hljs-type"><span class="hljs-type">name</span></span> = "my-project"; }; }</code> </pre> <br><p>  Here we wrote a function that accepts a repository as an input (and if the parameter is not set, it imports the standard <code>nixpkgs</code> ) and returns the "package" of the environment of our project.  Add to it fresh CMake, Boost and Google Test from the NixOS repository: </p><br><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta"># ... myProject = stdenv.mkDerivation { name = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"my-project"</span></span></span><span class="hljs-meta">; nativeBuildInputs = [ pkgs.cmake ]; buildInputs = [ pkgs.boost pkgs.gtest ]; };</span></span></code> </pre> <br><p>  Here, buildInputs are dependencies that are required for building.  Why else nativeBuildInputs?  The fact is that Nix supports cross-compiling.  And here we say that the buildInputs packages should be built by the target toolbar, and the nativeBuildInputs should be compiled with the usual host toolbar.  There is still <code>propagatedBuildInputs</code> - it adds dependency to all users of the package. </p><br><p>  Now the next time you call <code>nix-shell</code> , Nix will extort the necessary binary packages and set the environment variables so that the libraries are found by standard means, for example, CMake: </p><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">find_package</span></span>(Boost <span class="hljs-number"><span class="hljs-number">1.60</span></span> REQUIRED COMPONENTS system thread) <span class="hljs-keyword"><span class="hljs-keyword">find_path</span></span>(GTEST_INCLUDE_DIRS NAMES gtest/gtest.h PATH_SUFFIXES gtest)</code> </pre> <br><p>  The developer can only run <code>cmake . &amp;&amp; make</code>  <code>cmake . &amp;&amp; make</code> , which we will inform him about when entering the <code>nix-shell</code> : </p><br><pre> <code class="hljs dos"> myProject = stdenv.mkDerivation { # ... shellHook = ['' <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Welcome to myproject! <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Run \'<span class="hljs-built_in"><span class="hljs-built_in">mkdir</span></span> build &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> build &amp;&amp; cmake .. &amp;&amp; make -j\' to build it. '']; };</code> </pre> <br><h1>  We collect dependence which is not in <code>nixpkgs</code> </h1><br><p>  Now we want to add <a href="http://cppformat.github.io/latest/index.html">cppformat</a> to our project.  First we look for it in <code>nixpkgs</code> : </p><br><pre> <code class="hljs perl">$ nix-env -qaP | <span class="hljs-keyword"><span class="hljs-keyword">grep</span></span> cppformat $ nix-env -qaP | <span class="hljs-keyword"><span class="hljs-keyword">grep</span></span> cpp-<span class="hljs-keyword"><span class="hljs-keyword">format</span></span></code> </pre> <br><p>  Is empty.  You have to write your own expression.  The benefit is only 10 lines.  Add them to the "let": </p><br><pre> <code class="hljs kotlin"># ... let stdenv = pkgs.stdenv; fetchurl = pkgs.fetchurl; cppformat = stdenv.mkDerivation rec { version = <span class="hljs-string"><span class="hljs-string">"2.1.0"</span></span>; name = <span class="hljs-string"><span class="hljs-string">"cppformat-</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${version}</span></span></span><span class="hljs-string">"</span></span>; src = fetchurl { url = <span class="hljs-string"><span class="hljs-string">"https://github.com/cppformat/cppformat/archive/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${version}</span></span></span><span class="hljs-string">.tar.gz"</span></span>; sha256 = <span class="hljs-string"><span class="hljs-string">"0h8rydgwbm5gwwblx7jzpb43a9ap0dk2d9dbrswnbfmw50v5s7an"</span></span>; }; buildInputs = [ pkgs.cmake ]; enableParallelBuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rec { # ... buildInputs = [ # ... cppformat ]; # ...</code> </pre> <br><p>  Now the next time you start <code>nix-shell</code> , Nix will download the cppformat sources, build them using cmake (he sees that the project uses cmake, so instead of the standard " <code>./configure &amp;&amp; make install</code> ", " <code>cmake . &amp;&amp; make install</code> " is used) and caches the result builds in <code>/nix/store</code> .  It is noteworthy that, unlike the utilities of most other package managers: </p><br><ul><li>  If you fail to build the source will not be re-downloaded; </li><li>  If we change the expression, the package will be recompiled.  If you later decide to roll back the expression, the old packet from the cache will be used automatically, even if the file modification date has changed (conveniently when changing the branch / commit). </li></ul><br><h1>  Modifying the package from the repository </h1><br><p>  Sometimes the necessary package in the repository is, but not assembled the way we want.  You need to build a specific version of it, apply a patch, use certain flags.  Nix allows you to do this without having to copy-paste code from the repository: </p><br><pre> <code class="hljs cs"> cpp-netlib = pkgs.cpp-netlib.overrideDerivation(oldAttrs: { postPatch = <span class="hljs-string"><span class="hljs-string">''</span></span> substituteInPlace CMakeLists.txt \ --replace <span class="hljs-string"><span class="hljs-string">"CPPNETLIB_VERSION_PATCH 1"</span></span> <span class="hljs-string"><span class="hljs-string">"CPPNETLIB_VERSION_PATCH 3"</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>; cmakeFlags = oldAttrs.cmakeFlags ++ [ <span class="hljs-string"><span class="hljs-string">"-DCMAKE_CXX_STANDARD=11"</span></span> ]; src = fetchFromGitHub { owner = <span class="hljs-string"><span class="hljs-string">"cpp-netlib"</span></span>; repo = <span class="hljs-string"><span class="hljs-string">"cpp-netlib"</span></span>; rev = <span class="hljs-string"><span class="hljs-string">"9bcbde758952813bf87c2ff6cc16679509a40e06"</span></span>; <span class="hljs-meta"><span class="hljs-meta"># 0.11-devel sha256 = "0abcb2x0wc992s5j99bjc01al49ax4jw7m9d0522nkd11nzmiacy"; }; });</span></span></code> </pre> <br><h1>  Modifying the package in the repository </h1><br><p>  We can build a derived package X 'based on the original X from the repository and use it in our own.  Moreover, if some package Y in the repository was dependent on X, then it will continue to use its old version.  But what if you need to change the package inside the repository, i.e.  so that 100,500 other packages start using it?  And for this case in Nix there are tools.  Rebuilding a boost from <code>nixpkgs</code> using GCC5 instead of the standard GCC 4.9: </p><br><pre> <code class="hljs scala">{ nixpkgs ? <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> &lt;nixpkgs&gt; {} }: let overrideCC = nixpkgs.overrideCC; stdenv = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ! nixpkgs.stdenv.isLinux then nixpkgs.stdenv <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> overrideCC nixpkgs.stdenv nixpkgs.gcc5; pkgs = nixpkgs.overridePackages (self: <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>: { boost = <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.boost.<span class="hljs-keyword"><span class="hljs-keyword">override</span></span> { stdenv = stdenv; }; });</code> </pre> <br><p>  Here we changed the name of the argument from <code>pkgs</code> to <code>nixpkgs</code> and create a derivative repository <code>pkgs</code> , in which the booster is assembled as we want.  Now all other boost-dependent packages need to be rebuilt to enable our build.  Of course, only those packages that are used inside our expression will be (recursively) rebuilt - after all, Nix is ‚Äã‚Äãlazy. </p><br><h1>  Integration with third-party package managers and platforms </h1><br><p>  Everything is simple again - Nix has support for building packages for .NET, Emacs, Go, Haskell, Lua, Node, Perl, PHP, Python and Rust.  For some of them, the integration is that Nix can use packages directly from the native package manager: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">nativeBuildInputs</span></span> = [ pkgs.cmake pkgs.pkgconfig nodePackages.uglify-js ];</code> </pre> <br><h1>  Integrating Nix into YouCompleteMe </h1><br><p>  YouCompleteMe is perhaps the most popular code completion engine for C ++, which is not part of the IDE.  It came out of Vim, but there are already ports for Atom and, possibly, other editors.  If earlier developers had to configure it independently for their system, then now we can do it universally: </p><br><pre> <code class="hljs pgsql">def ExportFromNix(): <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> subprocess <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Popen, PIPE <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> shlex cmd = "nix-shell -Q --pure --readonly-mode --run 'echo $NIX_CFLAGS_COMPILE'"; proc = Popen(cmd, shell=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, stdout=PIPE) <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> = proc.stdout.<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>().decode("utf-8") <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shlex.split(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span>) flags += ExportFromNix()</code> </pre> <br><h1>  Conclusion </h1><br><p>  Nix is ‚Äã‚Äãat the same time flexible, convenient and simple package manager, which is built on the principles of functional programming and claims to be a package manager for everything.  Especially it can be convenient for C / C ++ programmers, since  allows you to fill in the empty niche of the language.  Using it, you can patch and add libraries to the project without causing pain and hating your colleagues.  A newcomer who arrives in the team will not spend their first working days on building the project. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/281611/">https://habr.com/ru/post/281611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../281601/index.html">bash + logger application warrants</a></li>
<li><a href="../281603/index.html">Machine learning: what you need to know about creating strategies for trading on the exchange. Part IV</a></li>
<li><a href="../281605/index.html">RESTful Visual Editor</a></li>
<li><a href="../281607/index.html">Develop HTML5 games in Intel XDK. Part 4. The system of coordinates and moving objects</a></li>
<li><a href="../281609/index.html">Create 3D CSS effects on hover using jQuery</a></li>
<li><a href="../281615/index.html">Oracle PaaS - present and future cloud platform</a></li>
<li><a href="../281617/index.html">Filter properly, or bad filtering tips in Angular.Js</a></li>
<li><a href="../281619/index.html">Internet of things (IoT) - challenges of new reality</a></li>
<li><a href="../281621/index.html">Storydesk - my non-existent wonder designer</a></li>
<li><a href="../281627/index.html">Welcome to the RISSPA seminar on April 20</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>