<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Blue. Not! Yellow! - or - Do new programming languages ‚Äã‚Äãincrease development speed?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What language was used to write the very first programs for the very first computers with a stored program? 
 Binary machine language, of course. 

 W...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Blue. Not! Yellow! - or - Do new programming languages ‚Äã‚Äãincrease development speed?</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  What language was used to write the very first programs for the very first computers with a stored program? </blockquote><br>  Binary machine language, of course. <br><br><blockquote>  Why? </blockquote><br>  Obviously because there was no symbolic assembler.  The first programs needed to be written in binary code. <br><br><blockquote>  How much easier is it to write programs in assembler than in binary machine language? </blockquote><br>  <em>Much</em> easier. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  Can I figure it out?  How many times easier? </blockquote><br>  Well, damn, the assembler does all the hard "routine" work for you.  Those.  it calculates all physical addresses.  He makes up all the physical machine commands.  It ensures that it is impossible to issue physically unrealizable commands, for example, addressing outside the address space.  And then it creates easy-loading binary output. <br><br>  Saving workloads is <em>huge</em> . <br><a name="habracut"></a><br><blockquote>  How much?  Can I figure it out? </blockquote><br>  OK  If I had to write a simple program, such as printing the squares of the first 25 integers, in an assembler on an old PDP-8 machine, then it would take me about two hours.  If I had to write the same program in binary machine language, it would take twice as long. <br><br>  I speak <em>twice</em> , because I would first write the program in symbolic syntax on paper, and then assemble the machine language by hand on paper.  After which I would have to enter this binary code into the computer also manually.  And all this additional work required about the same amount of time from me as writing a program in the first case.  Perhaps more. <br><br><blockquote>  Ok, enough.  So, using symbolic assembler reduces the amount of work by half? </blockquote><br>  In fact, I think a lot more.  Raising integers to a square is a fairly simple program.  The larger the program, the harder it is to manually assemble and load it.  I suppose, in fact, the gain in complexity depends on the size of the program.  For large programs, the time savings are <em>significant</em> . <br><br><blockquote>  Please explain. </blockquote><br>  Well, suppose you need to change one line in a program in a character assembler.  It will take me 20 minutes on an old PDP-8 with punched tape.  But when manually assembling, I must then recalculate all addresses and re-assemble all machine instructions manually.  Depending on the size of the original program will take hours.  Subsequent manual entry will take no less time. <br><br>  I could save time by segmenting the program into modules loaded into fixed addresses that have free intervals between them.  You can save a little more time by writing a small program that will help you download a large program.  However, such a "routine" load will still be very, very high. <br><br><blockquote>  Good.  But, nevertheless, is it possible to figure?  On average, how much does the use of assembler make it easier to work compared to writing a program in binary code? </blockquote><br>  Okay.  I suppose you can say about 10 times. <br><br><blockquote>  In other words, a character assembler allows one programmer to do the work of ten programmers working in binary code? </blockquote><br>  Yes, it is probably close to the truth. <br><br><blockquote>  If the character assembler reduced labor intensity by about 10 times, how much did Fortran do? </blockquote><br>  Very decent.  If we are talking about the 50s, then Fortran was then simple.  In other words, it was somewhat more than a character assembler for a symbolic layout ‚Äî I'm not sure if you understand what I mean. <br><br><blockquote>  Does this mean that he has reduced the labor intensity by another ten times? </blockquote><br>  What you surely are not!  The ‚Äúroutine‚Äù load of the symbolic assembler was not so high.  I would say that Fortran has reduced the labor intensity relatively little.  Perhaps about 30%. <br><br><blockquote>  In other words, 10 programmers in FORTRAN can replace 13 programmers in assembler? </blockquote><br>  If you want to consider the process from this position, then yes, it seems. <br><br><blockquote>  We continue - how much can a language like C help save time compared to Fortran? </blockquote><br>  Well, C spends a little less time on "routine" work than Fortran.  In the old Fortran, things like line numbers and the order of common operators needed to be remembered.  There was also an incredible number of transition operators throughout the text.  The C language is much more comfortable for programming than Fortran 1. I would say that it reduced the workload by about 20%. <br><br><blockquote>  Good.  That is, 10 C programmers can replace 12 Fortran programmers? </blockquote><br>  Well, this, of course, is only an assumption, but I would say a reasonable assumption. <br><br><blockquote>  Good.  Now: how much did C ++ reduce the workload with respect to C? </blockquote><br>  Listen, let's stop.  We do not recall much greater impact now. <br><br><blockquote>  Is it?  What exactly? </blockquote><br>  Development environment.  This means that in the 50s we used punched cards and paper tapes.  Compiling a simple program took at least half an hour.  And thats if you could access the car.  But in the late 80s, when C ++ became popular, programmers kept their programs on disks, and the compilation of a simple program lasted only two or three minutes. <br><br><blockquote>  Is this a reduction in labor intensity?  Or just reducing the waiting time? </blockquote><br>  A. So that's it.  The question is clear.  Yes, then the car had to wait a long time. <br><br><blockquote>  Request: when you give your estimates of labor intensity, please exclude the waiting time.  I am interested in saving time, associated only with the language itself. </blockquote><br>  Understand, I understand.  So you asked about C ++.  Actually, honestly, I do not think that C ++ somehow significantly reduced the complexity.  Of course, <em>there was something</em> , but I suppose no more than 5%.  This means that the routine load in C was simply small, and therefore the comparative saving of time when working in C ++ could not be significant. <br><br><blockquote>  If you use 5%, then this means that 100 C ++ programmers can replace 105 C programmers. Is this really so? </blockquote><br>  In general, yes.  But only for small and medium-sized programs.  For <em>large</em> C ++ programs, there are some additional benefits. <br><br><blockquote>  What kind? </blockquote><br>  It is quite difficult to explain.  But the point is that the object-oriented characteristics of C ++, in particular, polymorphism, made it possible to divide large programs into independently developed and deployable modules.  And this - for very large programs - significantly reduces the routine load. <br><br><blockquote>  Can I figure it out? </blockquote><br>  Well, you seem to be going to twist my arms further ... Considering the number of really large programs that were created in the 80s and 90s, I would say that, in general, C ++ reduced the workload, perhaps by 7%. <br><br><blockquote>  It did not sound particularly confident. </blockquote><br>  Yes.  But let's use this value.  7%. <br><br><blockquote>  Good.  So, 100 C ++ programmers can replace 107 C programmers? </blockquote><br>  Looks like I said that.  Let's use this value. <br><br><blockquote>  How long does Java save compared to C ++? </blockquote><br>  Hard to say.  <em>For a</em> while saves.  Java is a simpler language.  It has an automatic management of the release of dynamic memory ("garbage collection").  It does not have header files.  It works in a virtual machine.  He has many virtues.  And a few flaws. <br><br><blockquote>  What about numbers? </blockquote><br>  I have a feeling that we are skipping ... But since you are pressing me like that, you would say that all other things being equal (which is never the case), working with Java, you can get a 5% reduction in labor intensity compared to C ++. <br><br><blockquote>  So, 100 Java programmers can replace 105 C ++ programmers? </blockquote><br>  Yes!  However, no.  This is not true.  Scatter too large.  If we randomly select 100 Java programmers and compare them with the 105 selected C ++ programmers, I would not have dared to predict the result.  To get a real win, you need a lot more programmers. <br><br><blockquote>  How much more? </blockquote><br>  At least two orders of magnitude. <br><br><blockquote>  In other words, 10,000 randomly selected Java programmers can replace 10,500 also selected C ++ programmers? </blockquote><br>  Perhaps so. <br><br><blockquote>  Very good.  How much does a language like Ruby reduce the workload compared to Java? </blockquote><br>  Well, dear!  (sighs).  What are you speaking about?  See, Ruby is, indeed, a wonderful language.  It is both simple and sophisticated, elegant and quirky.  It is much slower than Java, but the computers are so cheap now that ... <br><br><blockquote>  Sorry, but I'm not asking about that. </blockquote><br>  You're right.  I know.  So, the main direction in which Ruby‚Äôs workload is less compared to a language like Java is <em>Types</em> .  In Java, you need to create a formal type structure and maintain its consistency.  Ruby can be played with types fairly quickly and freely. <br><br><blockquote>  Sounds like productivity gains. </blockquote><br>  In general, no.  It turns out that the ability to play quickly and freely with the structure of the type leads to the appearance of a runtime error class that is missing when programming in Java.  Therefore, Ruby programmers have a higher load on testing and debugging programs. <br><br><blockquote>  In other words, are these effects balanced? </blockquote><br>  It depends on who you ask. <br><br><blockquote>  I ask you. </blockquote><br>  Okay.  I would say that the effects do not balance each other.  The complexity of working with Ruby is lower than with Java. <br><br><blockquote>  How much?  20%? </blockquote><br>  People used to think so.  Indeed, in the 90s, many thought that Smalltalk programmers work many times more productive than C ++. <br><br><blockquote>  You are confusing me.  Why remember those languages? </blockquote><br>  Because C ++ is pretty close to Java, and Smalltalk to Ruby. <br><br><blockquote>  Clear.  So, does Ruby reduce the workload several times over Java? </blockquote><br>  No, most likely not.  If you look at the 90s, the problem with the waiting time was still quite pronounced.  The compilation time for a typical C ++ program was a few minutes.  The compile time for the Smalltalk program was almost <em>zero</em> . <br><br><blockquote>  Zero? </blockquote><br>  Almost yes.  The problem is that when using languages ‚Äã‚Äãsuch as Java and C ++, you need to perform a lot of work on the coordination of all types.  There is no such problem when using Smaltalk and Ruby.  Therefore, in the 90s it took time from minutes to milliseconds. <br><br><blockquote>  Clear.  But since all this is just a waiting time, we can not consider it. </blockquote><br>  Not certainly in that way.  You see, if the compile time is almost <em>zero</em> , then it generates other programming style and discipline.  You can work with a <em>very</em> short cycle - <em>seconds</em> instead of minutes.  This gives <em>extremely</em> fast feedback.  With a long compilation time, fast feedback is not possible. <br><br><blockquote>  Fast feedback reduces labor intensity? </blockquote><br>  Yes, to a certain extent.  When your cycles are extremely short, the ‚Äúroutine‚Äù load in each cycle is very small.  Your employment caused by the need for tracking is reduced.  Lengthening cycles increases the ‚Äúroutine‚Äù load, and nonlinearly. <br><br><blockquote>  Nonlinear? </blockquote><br>  Yes, the "routine" load increases disproportionately to the duration of the cycle.  It can grow as, for example, O (N ^ 2).  I dont know.  But I‚Äôm pretty sure that the relationship is non-linear. <br><br><blockquote>  Wonderful!  So Ruby is the leader! </blockquote><br>  Not.  And that's the point.  Thanks to the improvement of our hardware over the past twenty years, the compilation duration for Java has become almost <em>zero</em> .  The cycle time for a Java programmer is no more (or <em>should be</em> no more) than a Ruby programmer. <br><br><blockquote>  Please clarify. </blockquote><br>  I say that programmers using the short cycle discipline will see only a small difference in labor intensity (or, in general, will not see it), working with Java and Ruby.  The difference will be so small that it will be difficult to measure. <br><br><blockquote>  Unmeasured difference? </blockquote><br>  I believe that in order to obtain a statistically reliable result on this distinction, it will be necessary to experiment with thousands of programmers. <br><br><blockquote>  But you said earlier that Ruby reduces the workload compared to Java. </blockquote><br>  I think that this is the case, but only if the cycle time is long.  If the editing / compilation / testing cycle is kept very short, the effect will be negligible. <br><br><blockquote>  Zero? </blockquote><br>  Of course not - more likely about 5%.  But the spread will be gigantic. <br><br><blockquote>  So, 10,500 programmers working in a short loop in Java do the same work as 10,000 programmers in a short loop in Ruby? </blockquote><br>  If we add another order for the sample size, then I would venture to agree. <br><br><blockquote>  Are there languages ‚Äã‚Äãsuperior to Ruby? </blockquote><br>  You can get another 5% using a language like Clojure, since it is, on the one hand, quite simple and, on the other hand, functional. <br><br><blockquote>  Do you give only 5% of functional language? </blockquote><br>  No, I say that the discipline of a short cycle practically erases the differences in performance in modern languages. <br><br>  If you work with short cycles, it hardly matters what modern language you use. <br><br><blockquote>  That is: Swift?  Dart?  Go? </blockquote><br>  Irrelevant. <br><br><blockquote>  Scala?  F #? </blockquote><br>  Irrelevant. <br><br><blockquote>  In other words, we reached the top.  No future language will be better than what we have now. </blockquote><br>  Not certainly in that way.  I say only that we are on the path of declining efficiency.  No future language will give a gain of 10 times, as it was with the assembler in relation to the binary code.  No future language will reduce labor intensity by 50% or 20% or even 10% in comparison with existing languages.  The discipline of a short cycle has reduced the differences to practical immeasurability. <br><br><blockquote>  Then why are all new languages ‚Äã‚Äãappearing? </blockquote><br>  This is the search for the <em>Holy Grail</em> . <br><br><blockquote>  And, so this is just a matter of the level of your favorite color. </blockquote><br><hr><br>  <em>Translator's note: The</em> title of the post and its subject matter are a reference to a <a href="https://www.youtube.com/watch%3Fv%3DwTuojHso3YA">fragment of the film</a> ‚ÄúMonty Python and the Holy Grail‚Äù in which the Knights of the Round Table <a href="https://www.youtube.com/watch%3Fv%3DQJ26q_x80Cc">answer</a> <s>five</s> three questions to cross the Death Bridge </div><p>Source: <a href="https://habr.com/ru/post/308550/">https://habr.com/ru/post/308550/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308536/index.html">Announcement of the conference Linux Piter 2016 - the second international Linux conference in Russia</a></li>
<li><a href="../308538/index.html">Crosswalk Project - replacement of Android WebView. Project development</a></li>
<li><a href="../308540/index.html">Serena releases version 11.1 of its BPM platform.</a></li>
<li><a href="../308546/index.html">Creator of the World Wide Web Tim Berners-Lee changed the world, but he himself remained the same</a></li>
<li><a href="../308548/index.html">Reverse engineering test crackme from Kaspersky Lab</a></li>
<li><a href="../308552/index.html">Friday format: Mental models or approach to solving complex problems</a></li>
<li><a href="../308554/index.html">Starting programming is never too early: the look of a nine-year-old.</a></li>
<li><a href="../308556/index.html">Lua Meetup on September 2 at the Mail.Ru Group office</a></li>
<li><a href="../308558/index.html">Apple has released an emergency update for iOS</a></li>
<li><a href="../308560/index.html">iOS 9.3.5: security fixes and unsuccessful attack against a human rights defender from the United Arab Emirates</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>