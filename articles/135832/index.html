<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Strings up to 23 characters in Ruby are processed 1.92 times faster</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="An interesting fact: in Ruby 1.9.3 with a 64-bit interpreter, processing lines of 23 or less characters is almost twice as fast as lines of 24 or more...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Strings up to 23 characters in Ruby are processed 1.92 times faster</h1><div class="post__text post__text-html js-mediator-article">  An interesting fact: in Ruby 1.9.3 with a 64-bit interpreter, processing lines of 23 or less characters is <a href="http://patshaughnessy.net/2012/1/4/never-create-ruby-strings-longer-than-23-characters">almost twice as fast</a> as lines of 24 or more characters.  In other words, this Ruby code: <br><br><pre><code class="ruby hljs">str = <span class="hljs-string"><span class="hljs-string">"1234567890123456789012"</span></span> + <span class="hljs-string"><span class="hljs-string">"x"</span></span></code> </pre> <br>  ... will be processed 1.92 times faster than this: <br><br><pre> <code class="ruby hljs">str = <span class="hljs-string"><span class="hljs-string">"12345678901234567890123"</span></span> + <span class="hljs-string"><span class="hljs-string">"x"</span></span></code> </pre> <br>  For a 32-bit Ruby interpreter, the performance limit is around <a href="http://patshaughnessy.net/2012/1/4/never-create-ruby-strings-longer-than-23-characters">11/12 characters</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Of course, it's pretty silly to study your code and reduce all lines to 11 or 23 characters.  The difference in performance appears only on hundreds of thousands of lines.  However, those wishing to delve into the insides of the wonderful Ruby language may be wondering why this is happening. <br><a name="habracut"></a><br>  The performance difference can be seen using a simple benchmark: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'benchmark'</span></span> ITERATIONS = <span class="hljs-number"><span class="hljs-number">1000000</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(str, bench)</span></span></span></span> bench.report(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{str.length + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string"> chars"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ITERATIONS.times <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> new_string = str + <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  This is what the result is on strings of different lengths. <br><pre>  user system total real
 21 chars 0.250000 0.000000 0.250000 (0.247459)
 22 chars 0.250000 0.000000 0.250000 (0.246954)
 23 chars 0.250000 0.000000 0.250000 (0.248440)
 24 chars 0.480000 0.000000 0.480000 (0.478391)
 25 chars 0.480000 0.000000 0.480000 (0.479662)
 26 chars 0.480000 0.000000 0.480000 (0.481211)
 27 chars 0.490000 0.000000 0.490000 (0.490404) </pre><br>  In the tablet - a little more data, but the trend is clear. <br><br><img src="https://habrastorage.org/storage2/192/dcc/513/192dcc513a940992fa39572d8a6ae61d.png"><br>  <sup>The creation time of 1 million lines (ms), depending on the length of the string (characters).</sup> <br><br>  Add that focus only works with the Ruby 1.9.3 interpreter, but not 1.8. <br><br>  To understand this, Ruby-developer Pat Shaughnessy (Pat Shaughnessy) studied a handbook on the inner workings of <a href="http://rhg.rubyforge.org/">Ruby Hacking Guide</a> interpreters, including <a href="http://rhg.rubyforge.org/chapter02.html">Chapter 2</a> , which deals with basic Ruby data types, including strings.  After that, he decided to delve into the source code ruby.h (description of data types) and string.c (implementation of strings).  In code C, and there was a solution. <br><br>  It‚Äôs all about <code>malloc</code> , the standard C function that does dynamic memory allocation.  In fact, this is a rather resource-intensive operation, because you need to find free memory blocks of the right size in the heap, as well as track the release of this block after the operation is completed. <br><br>  The Ruby interpreter distinguishes between three kinds of strings, which can be called like this: <br><ul><li>  Heap Strings (heap strings) </li><li>  Shared Strings (same strings) </li><li>  Embedded Strings (embedded strings) </li></ul>  For all types of strings, a C <code>RString</code> structure is created, but the <code>malloc</code> function applies only to the first type of strings (heaps), but it does not apply to identical strings and embedded strings, thereby saving resources and improving performance.  How does this optimization occur?  The Ruby interpreter first checks the string for uniqueness: if it is a copy of an existing string, then there is no need to allocate a new memory for it.  This structure <code>RString</code> is created the fastest. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RString</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> len; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr; VALUE shared; };</code> </pre> <br>  Next, the interpreter checks the size of the string.  If the value is 23 characters or less, then again no memory from the heap is allocated for it and <code>malloc</code> is not called, and the value is embedded directly into the <code>RString</code> structure via <code>char ary[]</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RString</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ary[RSTRING_EMBED_LEN_MAX + <span class="hljs-number"><span class="hljs-number">1</span></span>]; }</code> </pre> <br>  Here lies the clue.  A detailed description of the structure of <code>RString</code> looks like this. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RString</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RBasic</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">basic</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> len; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> capa; VALUE shared; } aux; } heap; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ary[RSTRING_EMBED_LEN_MAX + <span class="hljs-number"><span class="hljs-number">1</span></span>]; } as; };</code> </pre> <br>  Here, the size of the <code>RSTRING_EMBED_LEN_MAX</code> array <code>RSTRING_EMBED_LEN_MAX</code> set as the sum of the len / ptr / capa values, that is, just 24 bytes.  Here is a line from ruby.h that defines the value of <code>RSTRING_EMBED_LEN_MAX</code> . <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#define RSTRING_EMBED_LEN_MAX ((int)((sizeof(VALUE)*3)/sizeof(char)-1))</span></span></code> </pre> <br>  On a 64-bit machine, sizeof (VALUE) is 8, which leads to a limit of 23 characters. <br><br>  This means that, without transferring to memory directly into the <code>RString</code> structure, only 23 characters from the string value can fit.  If the string exceeds this value, only then the data is placed in the "heap", for which <code>malloc</code> is called and the corresponding resource-intensive procedures occur.  That is why the "long" lines are processed more slowly. </div><p>Source: <a href="https://habr.com/ru/post/135832/">https://habr.com/ru/post/135832/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../135824/index.html">Numbers Competently write numbers in words on the iPhone</a></li>
<li><a href="../135825/index.html">RE: Icons of popular services in runet</a></li>
<li><a href="../135827/index.html">Korean wagon. Zalman HDD pocket review</a></li>
<li><a href="../135830/index.html">Victorinox will release a 1TB flash drive with 256AES and LCD display</a></li>
<li><a href="../135831/index.html">Choosing an e-book for English learners</a></li>
<li><a href="../135833/index.html">Playing Tic-Tac-Toe with Python and GTK</a></li>
<li><a href="../135835/index.html">Audio mixer from two or more sound cards on realtime Linux and Reaper</a></li>
<li><a href="../135837/index.html">Micro ORM do-it-yourself (part one)</a></li>
<li><a href="../135838/index.html">Let's play snowballs?</a></li>
<li><a href="../135840/index.html">PyS60: Tale of how to write a notepad for Symbian</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>