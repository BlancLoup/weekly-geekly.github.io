<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Convenient binary data source instead of Stream</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="How do your .NET components normally get binary data? If we discard the primitive case when all data is already in a byte array, then I am sure that i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Convenient binary data source instead of Stream</h1><div class="post__text post__text-html js-mediator-article">  How do your .NET components normally get binary data?  If we discard the primitive case when all data is already in a byte array, then I am sure that in the form of <b>System.IO.Stream</b> .  In general, it allows actually only one operation - to read the specified number of bytes into the specified byte array (buffer).  When reading with this operation, there are two types of difficulties and one inefficient use of resources. <br><br>  Problem number one: if the data of the same source is needed in several components, then after one component counted some data from the <b>Stream</b> , then it ‚Äúconsumed‚Äù it, and the other components could not be reached.  Problem number two: we need the data in the form of some blocks, and as a result of reading the block can only be partially in the buffer (only three bytes of a 32-bit number, only half of the letters of a word, etc.).  Irrational use of resources arises from the fact that each component reading the data must create its own buffer for reading.  Next, I propose an easy-to-use solution to these difficulties, which will allow you to clean up your code, get high reading performance and get versatile components. <br><a name="habracut"></a><br>  First, consider how we can solve these difficulties without refusing to use <b>Stream</b> . <br><br>  The problem of incomplete availability of blocks of information is fundamentally solvable, but at the cost of other problems.  The first solution is to read the data one byte until we get the right amount, which is fraught with a critical drop in performance.  The second solution is to check before each access to the buffer whether we have reached its limits and, if we have reached, then repeat the reading.  Checks, reading the <b>Stream</b> and the subsequent correction of the index in the buffer before each call strongly litter the code and provoke numerous errors.  This can be carried out in a separate method, clearing the sense code, but each component will still have to be separately supplied with this method. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The problem of joint reading of one <b>Stream by</b> several components is unsolvable in principle, especially in conditions when reading for high performance occurs at once in large chunks.  All you can think of is to feed the <b>Stream</b> to the input of only one component, and transfer the rest of the data in other, non-standard ways.  This approach does not allow creating universal components and kills any composition or replacement of them in the bud. <br><br>  Judging by the analysis of some projects, a significant part of the code is devoted to bypassing these two difficulties.  Moreover, the semantic load of projects is sometimes lost in the wilds of the code that provides reading of the data source. <br><br>  Clarification required by the analysis of comments on the article.  My proposed next solution does not change the data source usage model.  Other models, when not the consumer requests the data, but the source pushes them in the form of notifications, are not relevant to the topic of the article, and can be implemented and used regardless of my decision or in conjunction with it. <br><br>  For a fundamental solution of these difficulties, it is necessary to take a fundamental decision: to abandon the <b>Stream</b> , replacing it with an analog (let's call it BufferedSource), which will be provided with a buffer that is accessible to all components. <br>  In our BufferedSource, the read method is replaced by two: the actual filling of the buffer and the omission (consumption, deletion) of the used data from the buffer.  And, of course, we add a method that makes sure that the source buffer contains at least the specified amount of data and, if necessary, reads them into the buffer. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IBufferedSource</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      ,       byte[] Buffer { get; } int Offset { get; } int Count { get; } //      ,       . void EnsureBuffer (int size); //       void SkipBuffer (int size); }</span></span></code> </pre> <br><br>  Immediately after I started using such an interface in practice, there was a need to add more properties and methods to it.  For sources that supply data in portions of a certain size (for example, cryptographic transformations), there is a need for a method of reading the maximum possible amount of data into the buffer, not knowing which portions the source can provide them.  To reduce the number of method calls unnecessarily (especially true for asynchronous methods), it was necessary to add a property indicating that the source counted all the available data in the buffer and could not add anything else.  To optimize reading in the case when a large amount of data is not used, but simply skipped, a skip method was needed, which transmits not only buffer data, but also further data.  This skip allows you to save on data processing by the source when reading, as well as use the fast positioning feature that sources like file or memory have. <br><br>  After the implementation of many sources of different types and consumers for them, I came to this kind of interface, which contains only the necessary that can not be implemented outside the source.  All additional requirements as they arise are met in the extension methods. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IBufferedSource</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      ,       byte[] Buffer { get; } int Offset { get; } int Count { get; } //   . bool IsExhausted { get; } //    ,     .      . int FillBuffer (); //        .       . void EnsureBuffer (int size); //         . void SkipBuffer (int size); //      ,     .     . long TrySkip (long size); }</span></span></code> </pre> <br><br>  The EnsureBuffer () and SkipBuffer () methods are critical in speed, because the data consumer will call them frequently.  In the overwhelming majority of calls, they should only do primitive arithmetic with the index and size in the buffer.  Therefore, we do not combine them with FillBuffer () and TrySkip (), which, on the contrary, in most cases will initiate a resource-intensive reading of new data. <br><br>  Some necessary principles of operation of a source implementing IBufferedSource cannot be described in terms of an interface, therefore I describe them in XML comments and contracts.  The most important principle - the property Buffer is unchanged the entire lifetime of the source.  According to the second principle, the IsExhausted property changes its value from False to True only once during the lifetime of the source, and the value of True cannot change.  The third principle allows the FillBuffer () method to return zero only when IsExhausted = True and Count = 0.  An additional wish that corresponds to the original goals of saving on duplicate buffers: data sources do not create any buffers, but accept ready-made ones in the designer. <br><br>  Considering all the requirements, we turn to specific implementations.  Initially, we replace the <b>Stream</b> , so the first implementation was a very simple <a href="">ArrayBufferedSource</a> , which is an analogue of the <b>MemoryStream</b> .  The following interface implementations are BufferedSource-source, which receives data from the <b>Stream</b> ( <a href="">StreamBufferedSource</a> ) and vice versa: <b>Stream</b> , which receives data from the BufferedSource-source ( <a href="">BufferedSourceStream</a> ).  In the continuation of the replacement theme, <b>Stream</b> created the <a href="">CryptoTransformingBufferedSource</a> , which is an analogue of the <b>CryptoStream</b> , that is, takes data from another source and applies the specified crypto transformation to them.  Then I created the source-translator <a href="">ObservableBufferedSource</a> , which simply duplicates another source, but at each data consumption sends notifications to the <b>IProgress</b> recipient, which allows you to create an indication of consumption processes.  A more complex translator has become <a href="">SizeLimitedBufferedSource</a> , which limits the other source to the specified size.  For more convenient migration from <b>Stream, I</b> added the following extensions: Read (byte_array), CopyTo (stream_for_array), ReadAllBytes (), and ReadAllText (encoding) for IBufferedSource.  All this is laid out in an open <a href="https://github.com/novar0/BufferedSource">repository on github</a> . <br><br>  How to create an iBufferedSource source consumer?  Here, for example, parsing of an AVI video clip, which is stored in a file in the encoding "base-64". <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.IO.FileStream (<span class="hljs-string"><span class="hljs-string">@"c:\test.avi.base64"</span></span>, FileMode.Open, FileAccess.Read)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fileSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamBufferedSource (stream, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">1024</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transform = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Security.Cryptography.FromBase64Transform (); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> aviSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CryptoTransformingBufferedSource (fileSource, transform, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">1024</span></span>]); ParseAvi (aviSource); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseAvi</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBufferedSource source</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { source.EnsureBuffer (<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id = System.Text.Encoding.ASCII.GetString (source.Buffer, source.Offset, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> size = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)BitConverter.ToUInt32 (source.Buffer, source.Offset + <span class="hljs-number"><span class="hljs-number">4</span></span>); source.SkipBuffer (<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id == <span class="hljs-string"><span class="hljs-string">"avih"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chunkSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SizeLimitedBufferedSource (source, size); ParseAvihChunk (chunkSource); } source.TrySkip (size); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!source.IsEmpty ()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseAvihChunk</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBufferedSource source</span></span></span><span class="hljs-function">)</span></span> { source.EnsureBuffer (<span class="hljs-number"><span class="hljs-number">56</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> microSecPerFrame = BitConverter.ToUInt32 (source.Buffer, source.Offset); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> flags = BitConverter.ToUInt32 (source.Buffer, source.Offset + <span class="hljs-number"><span class="hljs-number">12</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalFrames = BitConverter.ToUInt32 (source.Buffer, source.Offset + <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> width = BitConverter.ToUInt32 (source.Buffer, source.Offset + <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> height = BitConverter.ToUInt32 (source.Buffer, source.Offset + <span class="hljs-number"><span class="hljs-number">36</span></span>); }</code> </pre> <br><br>  Without stopping at what has been accomplished, I propose the further development of IBufferedSource for sources, which are a collection of blocks of information.  For example, AVI or MKV files are separate chunks, each of which is conveniently considered as a separate data source.  Implementing the IPartitionedBufferedSource interface will make it possible to view a single source as a source of one portion with the possibility of transition to the next. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IPartitionedBufferedSource</span></span> : <span class="hljs-title"><span class="hljs-title">IBufferedSource</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     ,   ,      . bool TrySkipPart (); }</span></span></code> </pre> <br><br>  I draw your attention to the fact that in IPartitionedBufferedSource the semantics of the IsExhausted inherited property change.  Now it means the exhaustion of one part / portion / block, which does not exclude the transition to the next. <br><br>  Immediately present two implementations of IPartitionedBufferedSource.  <a href="">TemplateSeparatedBufferedSource</a> allows you to read the source as separate parts, which are separated from each other by a fixed separator.  For example, the individual fields of the HTTP header are separated from each other by two bytes 13 and 10. The base abstract class <a href="">EvaluatorPartitionedBufferedSourceBase</a> allows you to define your function by inheriting it, which arbitrarily finds the boundary between the parts.  For example, I used it to read individual parts in a composite mail MIME message.  Both of the mentioned implementations can be found in <a href="https://github.com/novar0/BufferedSource">the same repository on github</a> . <br><br>  Now let's try using all the created classes to create a parse of a rather complex structure: an e-mail message.  The message contains a collection of headers and a collection of parts, each of which begins with a collection of its own headers.  Please note that to implement parsing of different entities, you get completely independent methods that receive an IBufferedSource-source as input. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.IO.FileStream (<span class="hljs-string"><span class="hljs-string">@"c:\message.eml"</span></span>, FileMode.Open, FileAccess.Read)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fileSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamBufferedSource (fs, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">1024</span></span>]); ParseMultipartMessage (fileSource); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseMultipartMessage</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBufferedSource source</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> headerSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TemplateSeparatedBufferedSource (source, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] { <span class="hljs-number"><span class="hljs-number">0x0d</span></span>, <span class="hljs-number"><span class="hljs-number">0x0a</span></span>, <span class="hljs-number"><span class="hljs-number">0x0d</span></span>, <span class="hljs-number"><span class="hljs-number">0x0a</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fieldSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HeaderFieldSource (headerSource); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> field = ParseField (fieldSource); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (fieldSource.TrySkipPart ()); headerSource.TrySkipPart (); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bodyPartsSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BodyPartSource (<span class="hljs-string"><span class="hljs-string">"boundary--"</span></span>, source); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (bodyPartsSource.TrySkipPart ()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entity = ParseEntity (bodyPartsSource); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseEntity</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBufferedSource source</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> headerSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TemplateSeparatedBufferedSource (source, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] { <span class="hljs-number"><span class="hljs-number">0x0d</span></span>, <span class="hljs-number"><span class="hljs-number">0x0a</span></span>, <span class="hljs-number"><span class="hljs-number">0x0d</span></span>, <span class="hljs-number"><span class="hljs-number">0x0a</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fieldSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HeaderFieldSource (headerSource); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> field = ParseField (fieldSource); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (fieldSource.TrySkipPart ()); headerSource.TrySkipPart (); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = source.ReadAllBytes (); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">code explanations</b> <div class="spoiler_text">  The HeaderFieldSource and BodyPartSource classes are descendants of EvaluatorPartitionedBufferedSourceBase because it is impossible to use a TemplateSeparatedBufferedSource due to the ambiguity of the separator of individual parts.  In particular, for a header, the delimiters of individual fields are not any newline, but only the one followed by non-blank characters.  For individual parts of the message, the part of the separator (specified in the header bounday) may or may not be followed by line feeds. </div></div><br><br>  The next step is to add asynchronous methods to our BufferedSource, but this topic is not simple, so I will leave it for the next articles. <br><br>  Summing up, let me express satisfaction with the result.  The created BufferedSource successfully replaces and solves all the problems of working with <b>Stream</b> .  In this case, the alteration of existing components using <b>Stream</b> can be carried out gradually, using similar methods BufferedSource and adapter classes. <br><br>  Later, the <a href="https://github.com/novar0/BufferedSource">project was</a> reconfigured as a Portable Class Library Profile328 (.NET Framework 4, Silverlight 5, Windows 8, Windows Phone 8.1, Windows Phone Silverlight 8), tests were added and a <a href="https://www.nuget.org/packages/BufferedSource">nuget package was created</a> . </div><p>Source: <a href="https://habr.com/ru/post/231275/">https://habr.com/ru/post/231275/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../231265/index.html">"Roskosmos" briefly lost control over the satellite with geckos on board</a></li>
<li><a href="../231267/index.html">A tale about a white bull or how to stay invisible behind glass</a></li>
<li><a href="../231269/index.html">Fast creation of graphic resources from mdpi to xxhdpi</a></li>
<li><a href="../231271/index.html">Stanford is experimenting with carbon coating for lithium batteries</a></li>
<li><a href="../231273/index.html">Batteries leaked? Do not worry, we will refund your money!</a></li>
<li><a href="../231277/index.html">We open possibilities of map in nginx</a></li>
<li><a href="../231279/index.html">‚ÄúNo complications‚Äù home video surveillance: AdvoCam-HappyCam review</a></li>
<li><a href="../231281/index.html">Sass maps: responsive design without routine computing</a></li>
<li><a href="../231285/index.html">Financing innovation. Introduction</a></li>
<li><a href="../231287/index.html">Aspect oriented programming in Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>