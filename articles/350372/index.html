<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rust: Type States</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Previously, in Rust, there were states of types that were removed from the language even before the official release of the first version. In this art...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rust: Type States</h1><div class="post__text post__text-html js-mediator-article"><p>  Previously, in Rust, there were states of types that were removed from the language even before the official release of the first version.  In this article I will reveal to you the secret: Rust supports type states. </p><br><p>  I ask under the cat. </p><a name="habracut"></a><br><h2 id="postoyte-chto-takoe-sostoyaniya-tipov">  Wait, what are "state types"? </h2><br><p> Let's look at the object that represents the file ‚Äî let's call it, say, <code>MyFile</code> .  Before <code>MyFile</code> is opened, it cannot be read from.  After <code>MyFile</code> is closed, you cannot read from it.  Type states are a mechanism that allows the borrowing analyzer to prevent the following errors: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_contents_of_file</span></span></span></span>(path: &amp;Path) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> my_file = MyFile::new(path); my_file.open(); <span class="hljs-comment"><span class="hljs-comment">// :   . // ,   `my_file.open()`  . let result = my_file.read_all(); my_file.close(); my_file.seek(Seek::Start); // :   `my_file`. result }</span></span></code> </pre> <br><p>  In this example, we made two errors: </p><br><ul><li>  read from a file that may not have been successfully opened; </li><li>  moved the pointer to the current location in the file that is closed. <br>  In most programming languages, we can easily create an API for <code>MyFile</code> , which will make the first error impossible by throwing an exception when the file cannot be successfully opened.  Some standard libraries have decided to deviate from this rule for flexibility, but this possibility exists in the language itself. </li></ul><br><p>  The second error, however, is much more difficult to catch.  Most programming languages ‚Äã‚Äãsupport features that make it difficult to make such an error.  This is most often done by closing the file at the end of the object's area of ‚Äã‚Äãlife.  The only non-academic language I know that can prevent this error is Rust. </p><br><h2 id="prostye-sostoyaniya-tipov-v-rust">  Simple "type states" in Rust </h2><br><p>  How do we implement this in Rust? </p><br><p>  The easiest way is to introduce the appropriate types to represent operations on <code>MyFile</code> . </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> MyFile { <span class="hljs-comment"><span class="hljs-comment">// `open` -    `MyFile`. pub fn open(path: &amp;Path) -&gt; Result&lt;MyFile, Error&gt; { ... } //   `seek`   `MyFile`. pub fn seek(&amp;mut self, pos: Seek) -&gt; Result&lt;(), Error&gt; { ... } //   `read_all`   `MyFile`. pub fn read_all(&amp;mut self) -&gt; Result&lt;String, Error&gt; { ... } // `close`  `self`,  `&amp;self`   `&amp;mut self`, //  ,   ""  (  // (moves)  ). pub fn close(self) -&gt; Result&lt;(), Error&gt; { ... } } impl Drop for MyFile { // ,     `MyFile`,   //    . fn drop(&amp;mut self) { ... } }</span></span></code> </pre> <br><p>  Rewrite the top example: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_contents_of_file</span></span></span></span>(path: &amp;Path) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, Error&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> my_file = MyFile::open(path)?; <span class="hljs-comment"><span class="hljs-comment">//    `?` .   ,  //   ,    . // **    `MyFile`  //   `MyFile::open`. //  `my_file`    `MyFile`,  , //     . let result = my_file.read_all()?; // . my_file.close(); // . //   `my_file.close()` "" `my_file`,   //   . my_file.seek(Seek::Start)?; // :  . result }</span></span></code> </pre> <br><p>  This also works in more complex cases: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_contents_of_file</span></span></span></span>(path: &amp;Path) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, Error&gt; { <span class="hljs-comment"><span class="hljs-comment">//  . let mut my_file = MyFile::open(path)?; let result = my_file.read_all()?; // . if are_we_happy_yet() { my_file.close(); // . } //   `my_file.close()` "" `my_file`,    //       ( `are_we_happy_yet()` //  true). my_file.seek(Seek::Start)?; // :  . result //     `my_file`,    . }</span></span></code> </pre> <br><p>  The Rust type system checks to make sure that the variable is not used after it has been "consumed" (consumed, moved).  For example, <code>my_file.close()</code> eaten a variable. </p><br><p>  Even if we tried to hide the variable somewhere and try to use it again after calling <code>my_file.close()</code> , we would be stopped by the compiler: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_contents_of_file</span></span></span></span>(path: &amp;Path) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, Error&gt; { <span class="hljs-comment"><span class="hljs-comment">//  . let mut my_file = MyFile::open(path)?; let result = my_file.read_all()?; let mut my_file_sneaky_backup = my_file; //   `my_file`  `my_file_sneaky_backup`,   //       `my_file`. my_file.close(); // :  . my_file_sneaky_backup.seek(Seek::Start)?; result //     `my_file`,    . }</span></span></code> </pre> <br><p>  Let's try to trick the compiler by making the file available after it has been closed: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_contents_of_file</span></span></span></span>(path: &amp;Path) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, Error&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_shared_file = Rc::new(RefCell::new(MyFile::open(path)?)); <span class="hljs-comment"><span class="hljs-comment">// `my_shared_file` -  (shared)     // `MyFile`,      Java, C#, Python. let result = my_shared_file.borrow_mut() .read_all()?; // Valid let my_shared_file_sneaky_backup = my_shared_file.clone(); //   ,     // `my_shared_file`  . // ,       . my_shared_file_sneaky_backup.seek(Seek::Start)?; // . my_shared_file.seek(Seek::Start)?; //  . // ,      `my_shared_file`, //    `my_shared_file_sneaky_backup`  , //       Java, C#, Python! //      `my_shared_file.close()`,   //  `MyFile`     ,  , //     "" . my_shared_file.close(); // Error, detected by the compiler my_shared_file_sneaky_backup.seek(Seek::Start)?; result //     ,    . }</span></span></code> </pre> <br><p>  We were once again stopped by the compiler: without using <code>unsafe</code> , we cannot bypass the invariant - <code>seek</code> cannot be called after <code>close</code> . </p><br><p>  This example shows the first brick of type states in Rust: a <strong>typed move operation</strong> .  So far so good.  However, we have considered only the simple case in which files can only be <strong>opened</strong> or <strong>closed</strong> . </p><br><p>  Let's see if we can work with more complex cases. </p><br><h2 id="slozhnye-sostoyaniya-tipov">  Difficult "type states" </h2><br><p>  Instead of files, consider the following network protocol: </p><br><ol><li>  The sender sends "HELLO". </li><li>  The recipient receives "HELLO", responds with the message "HELLO, YOU". </li><li>  The sender receives "HELLO, YOU", responds with a random number. </li><li>  The recipient receives the number of the sender, responds with the same number. </li><li>  The sender receives the same number from the recipient, responds with "BYE". </li><li>  The recipient receives the "BYE" of the sender, replies "BYE, YOU". </li><li>  Return to step 1. </li></ol><br><p>  All other messages are ignored. </p><br><p>  We can come up with <code>Sender</code> (and <code>Receiver</code> ) to make sure that the operations take place in the correct order.  At the moment we are not worried about the definition of a correspondent or number. </p><br><p>  Let's unite the <strong>typified movements</strong> with other equipment - <strong>phantom types</strong> - this technique is common in strictly-typed functional programming languages. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,    ,   . //    ,   ( " "). struct SenderReadyToSendHello; struct SenderHasSentHello; struct SenderHasSentNumber; struct SenderHasReceivedNumber; struct Sender&lt;S&gt; { ///    I/O. inner: SenderImpl; ///    ,      . state: S; } ///        . impl&lt;S&gt; Sender&lt;S&gt; { ///    . fn port(&amp;self) -&gt; usize; ///  . fn close(self); } ///        ///  SenderReadyToSendHello. impl Sender&lt;SenderReadyToSendHello&gt; { ///        , ///     . fn send_hello(mut self) -&gt; Sender&lt;SenderHasSentHello&gt; { self.inner.send_message("HELLO"); Sender { ///    I/O. ///    ,  , ///        . inner: self.inner, ///     . ///      . state: SenderHasSentHello } } } ///         SenderHasSentHello. impl Sender&lt;SenderHasSentHello&gt; { /// ,     "HELLO, YOU", ///  . /// ///     `SenderHasSentNumber`. fn wait_respond_to_hello_you(mut self) -&gt; Sender&lt;SenderHasSentNumber&gt; { // ... } /// If the receiver has sent "HELLO, YOU", respond with number and /// return the sender in state `SenderHasSentNumber`. /// /// Otherwise, return the unchanged state. fn try_respond_to_hello_you(mut self) -&gt; Resuklt&lt;Sender&lt;SenderHasSentNumber&gt;, Self&gt; { // ... } } /// The following method may be called only in a state SenderHasSentNumber. impl Sender&lt;SenderHasSentNumber&gt; { /// Wait until the receiver has sent number, respond "BYE". /// /// Return the sender in state `SenderReadyToSendHello` fn wait_respond_to_hello_you(mut self) -&gt; Sender&lt;SenderReadyToSendHello&gt; { // ... } ///    ,     ///   `SenderReadyToSendHello`. /// ///    . fn try_respond_to_hello_you(mut self) -&gt; Result&lt;Sender&lt;SenderReadyToSendHello&gt;, Self&gt; { // ... } }</span></span></code> </pre> <br><p>  It is clear that <code>Sender</code> can only work according to the following protocol: </p><br><ul><li>  from step 1 ( <code>SenderReadyToSendHello</code> , can proceed to step 3); </li><li>  from step 3 ( <code>SenderHasSentHello</code> , can only remain in step 3 or <br>  go to step 5); </li><li>  from step 5 ( <code>SenderHasSentNumber</code> , can only remain in step 5 or <br>  go back to step 1). <br>  Any attempts to deviate from the protocol will be blocked by the type system. </li></ul><br><p>  When you need to work with network protocols, device drivers, industrial devices with specific security instructions or OpenGL / DirectX / other ‚Äî in a word, with everything that involves complex interaction with the hardware ‚Äî you will appreciate this mechanism and the guarantees it provides. </p><br><p>  Welcome to the world of type states. </p><br><h2 id="bystraya-zametka-za-sostoyaniyami-tipov">  Quick note: behind "type states" </h2><br><p>  By the way, continuing our example with the network, what if we want to save the number sent by <code>Server</code> to check that the answer matches?  We can save the number in <code>SenderHasSentNumber</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SenderHasSentNumber</span></span></span></span> { number_sent: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, }</code> </pre> <br><p>  The compiler will check that the code will access <code>number_sent</code> only when the sender is in the <code>SenderHasSentNumber</code> state. </p><br><p>  We will lose (slightly) in performance.  The compiler will not be able to optimize the transformation of <code>Sender</code> between identical representations, but this is usually worth it. </p><br><h2 id="zavershayuschie-slova">  Closing words </h2><br><p>  I hope that this quick demonstration has convinced you of the power provided by <strong>typed movement</strong> combined with <strong>phantom types</strong> .  This is a great tool to keep your code safe.  It is used in many places in the standard Rust library and in many well-designed third-party libraries. </p><br><p>  Now I do not know another PL, which would provide the semantics of typed movements (I note, C ++ has <em>untyped</em> semantics of movement), I think that other languages ‚Äã‚Äãwill eventually include the same mechanism if it is in demand.  By the way, I can not do without it :) </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/350372/">https://habr.com/ru/post/350372/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350362/index.html">About Encoders, Programmers, and Software Engineers</a></li>
<li><a href="../350364/index.html">agile gestalt</a></li>
<li><a href="../350366/index.html">Why network engineers need programming</a></li>
<li><a href="../350368/index.html">CSS selectors and their use in test automation software</a></li>
<li><a href="../350370/index.html">Webpack 4 and code splitting</a></li>
<li><a href="../350374/index.html">Why I left Google and started working for myself</a></li>
<li><a href="../350378/index.html">ITSM chatbots: what it is and why they are needed</a></li>
<li><a href="../350380/index.html">FastTrack Training. "Network Basics". "Basics of a wireless LAN". Part one. Eddie Martin December 2012</a></li>
<li><a href="../350382/index.html">Testing Services API and RSpec</a></li>
<li><a href="../350384/index.html">Selection: 12 services to protect against DDoS-attacks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>