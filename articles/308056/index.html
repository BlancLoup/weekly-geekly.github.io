<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Trello Clone on Phoenix and React. Parts 1-3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Trello is one of my favorite apps. I have been using it since its inception, and I really like the way it works, its simplicity and flexibility. Every...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Trello Clone on Phoenix and React. Parts 1-3</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/84c/b91/477/84cb91477441404da1e9398fcd9b44c5.png" alt="image"></div><br><p>  <a href="https://trello.com/">Trello</a> is one of my favorite apps.  I have been using it since its inception, and I really like the way it works, its simplicity and flexibility.  Every time, starting to learn a new technology, I prefer to create a full-fledged application in which I can put into practice everything that I learned to solve real problems and test these solutions.  So, starting to learn <a href="http://elixir-lang.org/">Elixir</a> and its <a href="http://www.phoenixframework.org/">Phoenix</a> Framework, I realized: I have to practice using all this amazing material I have met and share it in the form of a guide on how to implement the simple but functional <strong>Trello</strong> dedication. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Table of Contents (current material is highlighted)</b> <div class="spoiler_text"><ol><li>  <strong>Introduction and selection of technology stack</strong> </li><li>  <strong>Initial setup of the Phoenix Framework project</strong> </li><li>  <strong>User Model and JWT Authentication</strong> </li><li>  <a href="https://habrahabr.ru/post/308100/">Front-end for registration on React and Redux</a> </li><li>  <a href="https://habrahabr.ru/post/308100/">Initial database population and controller to enter the application</a> </li><li>  <a href="https://habrahabr.ru/post/308248/">Front-end authentication on React and Redux</a> </li><li>  <a href="https://habrahabr.ru/post/308248/">We configure sockets and channels</a> </li><li>  <a href="https://habrahabr.ru/post/308382/">We display the list and create new boards</a> </li><li>  <a href="https://habrahabr.ru/post/308382/">Add new board users</a> </li><li>  <a href="https://habrahabr.ru/post/316108/">We trace the connected users of boards</a> </li><li>  <a href="https://habrahabr.ru/post/316108/">Add lists and cards</a> </li><li>  <a href="https://habrahabr.ru/post/316108/">We spread the project on Heroku</a> </li></ol></div></div><br><a name="1"></a><br><div class="spoiler">  <b class="spoiler_title">Note from the translator</b> <div class="spoiler_text"><p>  <em>At the beginning of the year, having decided to get acquainted with Elixir and the Phoenix Framework, I came across an interesting series of articles on the web devoted to the implementation of the Trello clone using Elixir, Phoenix and React.</em>  <em>It seemed to me quite interesting, I did not find a Russian translation, but I wanted to share it.</em>  <em>Finally, the hands reached the translation.</em> </p><br><p>  <em>I should note that I am completely unfamiliar with the React ecosystem, this part will be given as is;</em>  <em>In addition, some moments in Elixir / Phoenix have changed over this time - projects are not in place.</em>  <em>I also hope to find time in the future to implement the front-end with Angular2 and publish an article about it, since I‚Äôm doing a bunch of Angular2 &lt;-&gt; Phoenix Channels &lt;-&gt; Elixir / Phoenix Framework.</em> </p><br><p>  <em>In my opinion, in the original cycle of the article, the blocks are too short, so one publication here will contain several parts, links to the original will be next to the subtitles.</em> </p><br><p>  <em>In controversial cases, I will give the original names of the terms, in case of discrepancies in the translations, please forgive and send alternative suggestions.</em>  <em>Corrections of any errors, typos and inaccuracies are also welcome.</em> </p><br><p>  <em>And I apologize for the duplication of the entry - even under the spoiler, it was not possible to post both the note and the introduction from the author before the kat.</em>  <em>Decided that the introduction is more important.</em> </p></div></div><br><h2 id="vvedenie-i-vybor-steka-tehnologiy">  Introduction and selection of technology stack </h2><br><p>  <a href="https://blog.diacode.com/trello-clone-with-phoenix-and-react-pt-1">Original</a> </p><br><p>  <a href="https://trello.com/">Trello</a> is one of my favorite apps.  I have been using it since its inception, and I really like the way it works, its simplicity and flexibility.  Every time, starting to learn a new technology, I prefer to create a full-fledged application in which I can put into practice everything that I learned to solve real problems and test these solutions.  So, starting to learn <a href="http://elixir-lang.org/">Elixir</a> and its <a href="http://www.phoenixframework.org/">Phoenix</a> Framework, I realized: I have to practice using all this amazing material I have met and share it in the form of a guide on how to implement the simple but functional <strong>Trello</strong> dedication. </p><br><h3 id="chto-my-sobiraemsya-sdelat">  What are we going to do </h3><br><p>  In fact, we will create a one-page application in which existing users can log in, create several boards, share them with other users and add lists and cards to them.  Connected users will be shown when viewing the board, and any changes automatically immediately - in the style of Trello - will be reflected in the browser of each such user. </p><br><h4 id="tekuschiy-stek-tehnologiy">  Current technology stack </h4><br><p>  <strong>Phoenix</strong> manages static resources with <strong>npm</strong> and collects them out of the box using <strong>Brunch</strong> or <strong>Webpack</strong> , so it's pretty easy to really separate the front-end and back-end, while maintaining a single code base.  So, for the back-end we will use: </p><br><ul><li>  Elixir </li><li>  Phoenix Framework </li><li>  Ecto </li><li>  PostgreSQL </li></ul><br><p>  And to create a one-page application for the front-end: </p><br><ul><li>  Webpack </li><li>  Sass for style sheets </li><li>  React </li><li>  React router </li><li>  Redux </li><li>  ES6 / ES7 JavaScript </li></ul><br><p>  We will use a few more dependencies of Elixir and npm packages, but I‚Äôll talk about them later in the process. </p><br><h4 id="pochemu-etot-stek">  Why this stack? </h4><br><p>  Elixir is a very fast and powerful functional language based on <strong>Erlang</strong> and having a friendly syntax very similar to Ruby.  It is very reliable and specializes in parallelism, and thanks to the Erlang virtual machine ( <strong>Erlang VM</strong> , <em>BEAM - approx. Translator</em> ) can cope with thousands of parallel processes.  I am new to Elixir, so I still have a lot to learn, but based on what has already been learned, I can say that it is very impressive. </p><br><p>  We will use <strong>Phoenix</strong> - currently the most popular web framework for Elixir, which not only implements some of the points and standards introduced into <strong>Rails</strong> web development, but also offers many other cool features like the static resource management method I mentioned above, and, most importantly for me, the built-in <strong>realtime</strong> functionality using <strong>websockets</strong> without any difficulties and additional external dependencies (and trust me - it works like a clock). </p><br><p>  At the same time, we will use <strong>React</strong> , <strong>react-router</strong> and <strong>Redux</strong> , because I just love using this combination to create one-page applications and manage their state.  Instead of using CoffieScript as usual, in the new year (the <em>article was written in early January 2016 - note of the translator</em> ) I want to work with ES6 and ES7, so this is a great opportunity to start and get involved. </p><br><h4 id="konechnyy-rezultat">  Final result </h4><br><p>  The app will consist of four different views.  The first two are registration and login screens: </p><br><p><img src="https://habrastorage.org/files/e1e/f18/9e1/e1ef189e1b424e7f8ebe934d88bc6a86.jpg" alt="Login"></p><br><p>  The main screen will contain a list of the user's own boards and boards to which it has been connected by other users: </p><br><p><img src="https://habrastorage.org/files/69c/4f0/dd7/69c4f0dd76a84847a5a9fef6e27857eb.jpg" alt="Board list"></p><br><p>  And finally, the board view, where all users will be able to see who is connected to it, as well as manage lists and cards: </p><br><p><img src="https://habrastorage.org/files/6c8/ffe/1af/6c8ffe1af009408d913a706026513c8b.jpg" alt="Board content"></p><br><p>  But enough talk.  Let us stop here so that I can start preparing the second part, in which we will see how to create a new Phoenix project, what needs to be changed to use Webpack instead of Brunch, and how to set up the base for the front-end. </p><br><a name="2"></a><br><h2 id="nachalnaya-nastroyka-proekta-phoenix-framework">  Initial setup of the Phoenix Framework project </h2><br><p>  <a href="https://blog.diacode.com/trello-clone-with-phoenix-and-react-pt-2">Original</a> </p><br><p>  So, after we chose the current technology stack, let's start by creating a new Phoenix project.  Before this, you must have <a href="http://elixir-lang.org/">Elixir</a> and <a href="http://www.phoenixframework.org/">Phoenix</a> already installed, so use the official websites for <a href="http://www.phoenixframework.org/docs/installation">installation instructions</a> . </p><br><h3 id="staticheskie-resursy-s-pomoschyu-webpack">  Static resources using Webpack </h3><br><p>  In contrast to Ruby on Rails, <strong>Phoenix</strong> does not have its own resource processing pipeline (asset pipeline, <em>some Russian-language Rails resources translate the term as file file - translator</em> ), instead using <a href="http://brunch.io/"><strong>Brunch</strong></a> as a means to build resources, which I personally consider more modern and flexible.  Cool, that there is no need to use and <strong>Brunch</strong> , if you do not want, you can use <a href="https://webpack.github.io/"><strong>Webpack</strong></a> .  I have never dealt with <strong>Brunch</strong> , so we‚Äôll use <strong>Webpack</strong> instead. </p><br><p>  Phoenix includes <strong>node.js</strong> as <a href="http://www.phoenixframework.org/docs/installation">an optional dependency</a> , since it is required for Brunch, but since Webpack also needs node.js, make sure you have the latest one installed. </p><br><p>  Create a new Phoenix project without Brunch: </p><br><pre><code class="hljs pgsql">$ mix phoenix.<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-comment"><span class="hljs-comment">--no-brunch phoenix_trello ... ... ... $ cd phoenix_trello</span></span></code> </pre> <br><p>  Well, now we have a new project without the means of assembling resources.  Create a new <code>package.json</code> file and install <strong>Webpack</strong> as a dependency for development ( <em>dev dependency - approx. Translator</em> ): </p><br><pre> <code class="hljs ruby">$ npm init ... (   Enter         ) ... ... $ npm i webpack --save-dev</code> </pre> <br><p>  Now our <code>package.json</code> should look something like this: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"phoenix_trello"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"devDependencies"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"webpack"</span></span>: <span class="hljs-string"><span class="hljs-string">"^1.12.9"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"dependencies"</span></span>: { }, }</code> </pre> <br><p>  For the project, we need a lot of dependencies, so instead of scrolling all of them here, please look at the <a href="">source file</a> in the project repository and copy them from there to your <code>package.json</code> .  Now you need to run the following command to install all the packages: </p><br><pre> <code class="hljs sql">$ npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span></code> </pre> <br><p>  We also need to add the <code>webpack.config.js</code> configuration file to tell Webpack how to collect resources: </p><br><pre> <code class="hljs javascript"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ExtractTextPlugin = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'extract-text-webpack-plugin'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> webpack = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'webpack'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dest</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path.resolve(__dirname, dest); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">web</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dest</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> join(<span class="hljs-string"><span class="hljs-string">'web/static/'</span></span> + dest); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> config = <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-attr"><span class="hljs-attr">entry</span></span>: { <span class="hljs-attr"><span class="hljs-attr">application</span></span>: [ web(<span class="hljs-string"><span class="hljs-string">'css/application.sass'</span></span>), web(<span class="hljs-string"><span class="hljs-string">'js/application.js'</span></span>), ], }, <span class="hljs-attr"><span class="hljs-attr">output</span></span>: { <span class="hljs-attr"><span class="hljs-attr">path</span></span>: join(<span class="hljs-string"><span class="hljs-string">'priv/static'</span></span>), <span class="hljs-attr"><span class="hljs-attr">filename</span></span>: <span class="hljs-string"><span class="hljs-string">'js/application.js'</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">resolve</span></span>: { <span class="hljs-attr"><span class="hljs-attr">extesions</span></span>: [<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'.js'</span></span>, <span class="hljs-string"><span class="hljs-string">'.sass'</span></span>], <span class="hljs-attr"><span class="hljs-attr">modulesDirectories</span></span>: [<span class="hljs-string"><span class="hljs-string">'node_modules'</span></span>], }, <span class="hljs-attr"><span class="hljs-attr">module</span></span>: { <span class="hljs-attr"><span class="hljs-attr">noParse</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/vendor\/phoenix/</span></span>, <span class="hljs-attr"><span class="hljs-attr">loaders</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\.js$/</span></span>, <span class="hljs-attr"><span class="hljs-attr">exclude</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/node_modules/</span></span>, <span class="hljs-attr"><span class="hljs-attr">loader</span></span>: <span class="hljs-string"><span class="hljs-string">'babel'</span></span>, <span class="hljs-attr"><span class="hljs-attr">query</span></span>: { <span class="hljs-attr"><span class="hljs-attr">cacheDirectory</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">plugins</span></span>: [<span class="hljs-string"><span class="hljs-string">'transform-decorators-legacy'</span></span>], <span class="hljs-attr"><span class="hljs-attr">presets</span></span>: [<span class="hljs-string"><span class="hljs-string">'react'</span></span>, <span class="hljs-string"><span class="hljs-string">'es2015'</span></span>, <span class="hljs-string"><span class="hljs-string">'stage-2'</span></span>, <span class="hljs-string"><span class="hljs-string">'stage-0'</span></span>], }, }, { <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\.sass$/</span></span>, <span class="hljs-attr"><span class="hljs-attr">loader</span></span>: ExtractTextPlugin.extract(<span class="hljs-string"><span class="hljs-string">'style'</span></span>, <span class="hljs-string"><span class="hljs-string">'css!sass?indentedSyntax&amp;includePaths[]='</span></span> + __dirname + <span class="hljs-string"><span class="hljs-string">'/node_modules'</span></span>), }, ], }, <span class="hljs-attr"><span class="hljs-attr">plugins</span></span>: [ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExtractTextPlugin(<span class="hljs-string"><span class="hljs-string">'css/application.css'</span></span>), ], }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (process.env.NODE_ENV === <span class="hljs-string"><span class="hljs-string">'production'</span></span>) { config.plugins.push( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> webpack.optimize.DedupePlugin(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> webpack.optimize.UglifyJsPlugin({ <span class="hljs-attr"><span class="hljs-attr">minimize</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) ); }</code> </pre> <br><p>  Here we indicate that we need two <a href="https://webpack.github.io/docs/multiple-entry-points.html">webpack entry points</a> , one for JavaScript and the other for style sheets, both located in the <code>web/static</code> directory.  Output files will be created in <code>priv/static</code> .  Since we are going to take advantage of some of the features of <strong>ES6 / 7</strong> and <strong>JSX</strong> , we will use <strong>Babel</strong> with some presets created for this purpose. </p><br><p>  The last step is to tell <strong>Phoenix to</strong> start the <strong>Webpack</strong> each time the development server starts, so that Webpack tracks changes in the development process and generates the corresponding resource files referenced by the front-end view.  To do this, add the description of the "observer" to the <code>config/dev.exs</code> : </p><br><pre> <code class="hljs lua"><span class="hljs-built_in"><span class="hljs-built_in">config</span></span> :phoenix_trello, PhoenixTrello.Endpoint, http: [port: <span class="hljs-number"><span class="hljs-number">4000</span></span>], debug_errors: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, code_reloader: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, cache_static_lookup: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, check_origin: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, watchers: [ node: [<span class="hljs-string"><span class="hljs-string">"node_modules/webpack/bin/webpack.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"--watch"</span></span>, <span class="hljs-string"><span class="hljs-string">"--color"</span></span>] ] ...</code> </pre> <br><p>  If we now start the development server, we can see that the <strong>Webpack is</strong> also working and tracking changes: </p><br><pre> <code class="hljs sql">$ mix phoenix.server [info] Running PhoenixTrello.Endpoint <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> Cowboy <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">http</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> port <span class="hljs-number"><span class="hljs-number">4000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Hash</span></span>: <span class="hljs-number"><span class="hljs-number">93</span></span>bc1d4743159d9afc35 <span class="hljs-keyword"><span class="hljs-keyword">Version</span></span>: webpack <span class="hljs-number"><span class="hljs-number">1.12</span></span><span class="hljs-number"><span class="hljs-number">.10</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Time</span></span>: <span class="hljs-number"><span class="hljs-number">6488</span></span>ms Asset <span class="hljs-keyword"><span class="hljs-keyword">Size</span></span> Chunks <span class="hljs-keyword"><span class="hljs-keyword">Chunk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Names</span></span> js/application.js <span class="hljs-number"><span class="hljs-number">1.28</span></span> MB <span class="hljs-number"><span class="hljs-number">0</span></span> [emitted] application css/application.css <span class="hljs-number"><span class="hljs-number">49.3</span></span> kB <span class="hljs-number"><span class="hljs-number">0</span></span> [emitted] application [<span class="hljs-number"><span class="hljs-number">0</span></span>] multi application <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bytes</span></span> {<span class="hljs-number"><span class="hljs-number">0</span></span>} [built] + <span class="hljs-number"><span class="hljs-number">397</span></span> hidden modules <span class="hljs-keyword"><span class="hljs-keyword">Child</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>-webpack-<span class="hljs-keyword"><span class="hljs-keyword">plugin</span></span>: + <span class="hljs-number"><span class="hljs-number">2</span></span> hidden modules</code> </pre> <br><p>  One more thing to do.  If we look in the <code>priv/static/js</code> directory, we find the <code>phoenix.js</code> file.  This file contains everything we need to use <code>websocket</code> and <code>channels</code> , so let's move it to our base directory with <code>web/static/js</code> sources so that we can connect it at the moment it is needed. </p><br><h3 id="osnovnaya-struktura-front-end">  Main structure front-end </h3><br><p>  Now we have everything to start programming;  Let's start by creating the structure of the front-end application, which, among others, will need the following packages: </p><br><ul><li>  <strong>bourbon</strong> and <strong>bourbon-neat</strong> , my favorite library of inclusions (mixin) for Sass </li><li>  <strong>history</strong> to manage history from javascript </li><li>  <strong>react</strong> and <strong>react-dom</strong> </li><li>  <strong>redux</strong> and <strong>react-redux</strong> for state control </li><li>  <strong>react-router</strong> as a library for routing (routing) </li><li>  <strong>redux-simple-router</strong> to save changes to routes in the (state) state </li></ul><br><p>  I'm not going to waste time discussing style sheets, because I still correct them, but I would like to note that I usually use <a href="http://css-burrito.com/">css-buritto</a> , which, in my personal opinion, is very useful for creating a suitable structure for <strong>Sass</strong> files. </p><br><p>  We need to configure the <strong>Redux</strong> storage (redux store), so create the following file: </p><br><pre> <code class="hljs pgsql">//web/static/js/store/<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>.js <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createStore, applyMiddleware } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> createLogger <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux-logger'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> thunkMiddleware <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux-thunk'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { syncHistory } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-router-redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> reducers <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../reducers'</span></span>; const loggerMiddleware = createLogger({ <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>: <span class="hljs-string"><span class="hljs-string">'info'</span></span>, collapsed: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, }); export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> configureStore(browserHistory) { const reduxRouterMiddleware = syncHistory(browserHistory); const createStoreWithMiddleware = applyMiddleware(reduxRouterMiddleware, thunkMiddleware, loggerMiddleware)(createStore); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> createStoreWithMiddleware(reducers); }</code> </pre><br><p>  In fact, we set up a store (Store) with three intermediate layers (middleware): </p><br><ul><li>  <strong>reduxRouterMiddleware</strong> for sending router actions to the storage </li><li>  <strong>redux-thunk</strong> to transmit asynchronous action </li><li>  <strong>redux-logger</strong> for logging any actions and state changes in the browser console </li></ul><br><p>  We also need to pass a combination of state reducers (state reducers), so create a basic version of this file: </p><br><pre> <code class="hljs pgsql">//web/static/js/reducers/<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>.js <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { combineReducers } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { routeReducer } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux-simple-router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">session</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./session'</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> combineReducers({ routing: routeReducer, <span class="hljs-keyword"><span class="hljs-keyword">session</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">session</span></span>, });</code> </pre> <br><p>  As a starting point, we will need only two converters (reducer): the <code>routerReducer</code> , which will automatically transfer the routing changes to the state, and the <code>session</code> that looks something like this: </p><br><pre> <code class="hljs pgsql">//web/static/js/reducers/<span class="hljs-keyword"><span class="hljs-keyword">session</span></span>.js const initialState = { currentUser: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, socket: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, error: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, }; export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> reducer(state = initialState, action = {}) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; }</code> </pre> <br><p>  The initial state of the latter will contain the <code>currentUser</code> objects, which we will transmit after authenticating visitors, the <code>socket</code> that we will use to connect to the channels (channels), and <code>error</code> to track any problems during user authentication. </p><br><p>  When finished with this, we can go to our main <code>application.js</code> file and draw the <code>Root</code> component: </p><br><pre> <code class="hljs pgsql">//web/static/js/application.js <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-dom'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { browserHistory } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> configureStore <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./store'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Root <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./containers/root'</span></span>; const store = configureStore(browserHistory); const target = document.getElementById(<span class="hljs-string"><span class="hljs-string">'main_container'</span></span>); const node = &lt;Root routerHistory={browserHistory} store={store}/&gt;; ReactDOM.render(node, target);</code> </pre> <br><p>  We create an object containing the browser history, set up the storages, and finally draw the <code>Root</code> component in the main application template, which will be the <strong>Redux</strong> routing <code>Provider</code> for the <code>routes</code> : </p><br><pre> <code class="hljs pgsql">//web/static/js/containers/root.js <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Provider } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Router } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> invariant <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'invariant'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> routes <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../routes'</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Root extends React.Component { _renderRouter() { invariant( this.props.routerHistory, <span class="hljs-string"><span class="hljs-string">'&lt;Root /&gt; needs either a routingContext or routerHistory to render.'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;Router history={this.props.routerHistory}&gt; {routes} &lt;/Router&gt; ); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;Provider store={this.props.store}&gt; {this._renderRouter()} &lt;/Provider&gt; ); } }</code> </pre> <br><p>  Now let's describe a very simple route file: </p><br><pre> <code class="hljs pgsql">//web/static/js/routes/<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>.js <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { IndexRoute, Route } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MainLayout <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../layouts/main'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> RegistrationsNew <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../views/registrations/new'</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> ( &lt;Route component={MainLayout}&gt; &lt;Route <span class="hljs-type"><span class="hljs-type">path</span></span>="/" component={RegistrationsNew} /&gt; &lt;/Route&gt; );</code> </pre> <br><p>  Our application will be wrapped inside the <code>MainLayout</code> component, and the root path will draw the registration screen.  The final version of this file will become somewhat more complicated due to the authentication mechanism, which we will implement later, but we will talk about this later. </p><br><p>  Finally, we need to add an html-container in which we will draw the <code>Root</code> component in the main template of the Phoenix application: </p><br><pre> <code class="hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- web/templates/layout/app.html.eex --&gt;</span></span> <span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">lang</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"en"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">charset</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"utf-8"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">http-equiv</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"X-UA-Compatible"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">content</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"IE=edge"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"viewport"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">content</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"width=device-width, initial-scale=1"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"description"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">content</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">""</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"author"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">content</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ricardo@codeloveandboards.com"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>Phoenix Trello<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">link</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">rel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"stylesheet"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"&lt;%= static_path(@conn, "</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">css</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">application.css</span></span></span><span class="hljs-tag">") %&gt;</span></span>"&gt; <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">main</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"main_container"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">role</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"main"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">main</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"&lt;%= static_path(@conn, "</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">js</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">application.js</span></span></span><span class="hljs-tag">") %&gt;</span></span><span class="undefined"><span class="undefined">"&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Notice that the link and script tags link to static resources generated by the <strong>webpack</strong> . </p><br><p>  Since we are going to manage the routing on the front-end, we need to tell Phoenix to send any http requests to the Page event of the (action) <code>index</code> <code>PageController</code> controller, which will only draw the main template and the <code>Root</code> component: </p><br><pre> <code class="hljs pgsql"># master/web/router.ex defmodule PhoenixTrello.Router <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use PhoenixTrello.Web, :router pipeline :browser <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> plug :accepts, ["html"] plug :fetch_session plug :fetch_flash plug :protect_from_forgery plug :put_secure_browser_headers <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> scope "/", PhoenixTrello <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> pipe_through :browser # Use the <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> browser stack <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> "*path", PageController, :<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  That's all for now.  In the next post we will look at how to create the first migration for the database, the <code>User</code> model, and the functionality to create a new user account. </p><br><a name="3"></a><br><h2 id="model-user-i-jwt-autentifikaciya">  User Model and JWT Authentication </h2><br><p>  <a href="https://blog.diacode.com/trello-clone-with-phoenix-and-react-pt-3">Original</a> </p><br><h3 id="registraciya-polzovatelya">  User registration </h3><br><p>  Now that our project is fully configured, we are ready to create a <code>User</code> model and instructions for migrating the database.  In this part we will see how to do this, as well as allow the visitor to create a new user account. </p><br><h3 id="model-i-migraciya-user">  User Model and Migration </h3><br><p>  Phoenix uses Ecto as an intermediary for any interaction with the database.  In the case of Rails, we can say that Ecto would be something similar to ActiveRecords, although it shares similar functionality across modules. </p><br><p>  Before proceeding, you need to create a database ( <em>but before that you need to configure the database connection settings in <code>config/dev.exs</code> - comment of the translator</em> ): </p><br><pre> <code class="hljs pgsql">$ mix ecto.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span></code> </pre> <br><p>  Now create a new migration and model Ecto.  The model generator receives as parameters the name of the module, its plural form for naming the scheme, and the required fields in the form <code>:</code> , so let's execute: </p><br><pre> <code class="hljs cs">$ mix phoenix.gen.model User users first_name:<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> last_name:<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> email:<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> encrypted_password:<span class="hljs-keyword"><span class="hljs-keyword">string</span></span></code> </pre> <br><p>  If we look at the resulting migration file, we immediately note its similarity to the Rails migration file: </p><br><pre> <code class="hljs pgsql"># priv/repo/migrations/<span class="hljs-number"><span class="hljs-number">20151224075404</span></span>_create_user.exs defmodule PhoenixTrello.Repo.Migrations.CreateUser <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use Ecto.Migration def change <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>(:users) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> :first_name, :string, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> :last_name, :string, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> :email, :string, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> :crypted_password, :string, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> timestamps <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> unique_index(:users, [:email]) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  I added a ban on <code>null</code> in the field contents and even a unique index for the email field.  I do this because I prefer to shift the responsibility for data integrity to the database instead of relying on the application, as many other developers do.  I think it's just a matter of personal preference. </p><br><p>  Now let's create a <code>users</code> table in the database: </p><br><pre> <code class="hljs ruby">$ mix ecto.migrate</code> </pre> <br><p>  It is time to look at the <code>User</code> model closer: </p><br><pre> <code class="hljs pgsql"># web/models/<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.ex defmodule PhoenixTrello.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use Ecto.<span class="hljs-keyword"><span class="hljs-keyword">Schema</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Ecto.Changeset <span class="hljs-keyword"><span class="hljs-keyword">schema</span></span> "users" <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> field :first_name, :string field :last_name, :string field :email, :string field :encrypted_password, :string timestamps <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> @required_fields ~w(first_name last_name email) @optional_fields ~w(encrypted_password) def changeset(model, params \\ :empty) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> model |&gt; cast(params, @required_fields, @optional_fields) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  In it you can see two main sections: </p><br><ul><li>  A schema block in which all the metadata related to the table fields is located </li><li>  The <strong>changeset</strong> function, in which you can define all the checks and transformations applied to the data before they are ready for use in our application. </li></ul><br><p>  <em>Note</em>  <em>translator:</em> <em><br></em>  <em>Some changes have been made to the latest versions of Ecto.</em>  <em>For example, the atom: empty is marked as deprecated, an empty associative array (map) <code>%{}</code> must be used instead, and the cast / 4 function is <a href="https://hexdocs.pm/ecto/Ecto.Changeset.html">recommended to be replaced</a> with a bunch of cast / 3 and validate_required / 3.</em>  <em>Naturally, the latest Phoenix version generator follows these guidelines.</em> </p><br><h3 id="proverki-i-transformacii-nabora-izmeneniy-changeset">  Checks and transformations of a changeset </h3><br><p>  So, when a user is registered, we would like to additionally introduce some checks, since we have previously added a ban on using null as a field value and introduced a requirement for email uniqueness.  We are obligated to reflect this in the <code>User</code> model in order to handle possible errors caused by incorrect data.  I would also like to encrypt the encrypted_field field so that even despite the use of an unencrypted string as a password, it is recorded in a protected form. </p><br><p>  Let's update the model and first add some checks: </p><br><pre> <code class="hljs mel"># web/models/user.ex defmodule PhoenixTrello.User <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> # ... schema <span class="hljs-string"><span class="hljs-string">"users"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> # ... field :password, :<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, virtual: true # ... end @required_fields ~w(first_name last_name email password) @optional_fields ~w(encrypted_password) def changeset(model, params \\ :empty) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> model |&gt; cast(params, @required_fields, @optional_fields) |&gt; validate_format(:email, ~r/@/) |&gt; validate_length(:password, <span class="hljs-keyword"><span class="hljs-keyword">min</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>) |&gt; validate_confirmation(:password, message: <span class="hljs-string"><span class="hljs-string">"Password does not match"</span></span>) |&gt; unique_constraint(:email, message: <span class="hljs-string"><span class="hljs-string">"Email already taken"</span></span>) end end</code> </pre> <br><p>  Basically, we made the following modifications: </p><br><ul><li>  added a new virtual <code>password</code> field that will not be written to the database, but can be used like any other field for any other purposes.  In our case, we will fill it out from the registration form. </li><li>  <code>password</code> field is required </li><li>  added <code>email</code> format check </li><li>  added password checking, requiring its length of at least 5 characters;  an array of parameters will also be checked for password identity with the <code>password_confirmation</code> field </li><li>  added a unique restriction to check for the presence of an existing email </li></ul><br><p>  With these changes we covered all the required checks.  However, before writing data, you must also fill in the <code>encrypted_password</code> field.  To do this, use the <a href="https://github.com/elixircnx/comeonin">comeonin</a> password hashing library, adding it to mix.exs as an application and dependency: </p><br><pre> <code class="hljs lua"># mix.exs defmodule PhoenixTrello.Mixfile <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use Mix.Project # ... def application <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">mod</span></span>: {PhoenixTrello, []}, applications: [ # ... :comeonin ] ] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> #... defp deps <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> [ # ... {:comeonin, <span class="hljs-string"><span class="hljs-string">"~&gt; 2.0"</span></span>}, # ... ] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Do not forget to install the library with the command: </p><br><pre> <code class="hljs swift">$ mix deps.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span></code> </pre> <br><p>  After installing comeonin, let's go back to the <code>User</code> model and to generate <code>encrypted_password</code> add a new step to the <strong>changeset</strong> chain: </p><br><pre> <code class="hljs vbscript"># web/models/user.ex defmodule PhoenixTrello.User <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> # ... def changeset(model, params \\ :<span class="hljs-literal"><span class="hljs-literal">empty</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> model # ...     |&gt; generate_encrypted_password <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> defp generate_encrypted_password(current_changeset) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> current_changeset <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> %Ecto.Changeset{valid?: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, changes: %{password: password}} -&gt; put_change(current_changeset, :encrypted_password, Comeonin.Bcrypt.hashpwsalt(password)) _ -&gt; current_changeset <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  In this new method, we first check if the changes in the set are correct and if the password has changed.  If so, we encrypt the password using comeonin and put the result in the set_of_keyword field of our set, otherwise we return the set as is. </p><br><h3 id="marshrutizator">  Router </h3><br><p>  Now that the <code>User</code> model is ready, we <code>router.ex</code> continue the registration process by adding a chain to the file <code>router.ex</code> <code>:api</code> and our first route: </p><br><pre> <code class="hljs lua"># web/router.ex defmodule PhoenixTrello.Router <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use PhoenixTrello.Web, :router #... pipeline :api <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> plug :accepts, [<span class="hljs-string"><span class="hljs-string">"json"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> scope <span class="hljs-string"><span class="hljs-string">"/api"</span></span>, PhoenixTrello <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> pipe_through :api scope <span class="hljs-string"><span class="hljs-string">"/v1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> post <span class="hljs-string"><span class="hljs-string">"/registrations"</span></span>, RegistrationController, :<span class="hljs-built_in"><span class="hljs-built_in">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> #... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  So, any <code>POST</code> request to <code>/api/v1/registrations</code> will be processed by the processor: action <code>:create</code> <code>RegistrationController</code> controller that accepts data in <strong>json</strong> format ... in general, everything is pretty obvious :) </p><br><h3 id="kontroller">  Controller </h3><br><p>  Before starting the implementation of the controller, let's think about what we need.  The visitor will go to the registration page, fill out the form and send it.  If the data received by the controller is correct, we will need to add a new user to the database, enter it into the system and return to the front-end in <strong>json</strong> data about the user along with the authentication token <a href="https://en.wikipedia.org/wiki/JSON_Web_Token">jwt</a> as a result of the login.  This token is what is required not only for sending with each request for user authentication, but also for user access to the application's secure screens. </p><br><p>  To implement authentication and jwt generation, we will use the Guardian library, which copes with this task quite well.  Just add the following to mix.exs: </p><br><pre> <code class="hljs vbscript"># mix.exs defmodule PhoenixTrello.Mixfile <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use Mix.Project #... defp deps <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> [ # ... {:guardian, <span class="hljs-string"><span class="hljs-string">"~&gt; 0.9.0"</span></span>}, # ... ] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  After running <code>mix deps.get</code> will need to make the library settings in config.exs: </p><br><pre> <code class="hljs lua"># <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>/confg.exs #... <span class="hljs-built_in"><span class="hljs-built_in">config</span></span> :guardian, Guardian, issuer: <span class="hljs-string"><span class="hljs-string">"PhoenixTrello"</span></span>, ttl: { <span class="hljs-number"><span class="hljs-number">3</span></span>, :days }, verify_issuer: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, secret_key: &lt;your guardian secret key&gt;, serializer: PhoenixTrello.GuardianSerializer</code> </pre> <br><p>  You will also need to create the <code>GuardianSerializer</code> , which tells the Guardian how to encode and decode information about the user to the token and from the token: </p><br><pre> <code class="hljs vbscript"># lib/phoenix_trello/guardian_serializer.ex defmodule PhoenixTrello.GuardianSerializer <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> @behaviour Guardian.Serializer alias PhoenixTrello.{Repo, User} def for_token(user = %User{}), <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: { :ok, <span class="hljs-string"><span class="hljs-string">"User:#{user.id}"</span></span> } def for_token(_), <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: { :<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>, <span class="hljs-string"><span class="hljs-string">"Unknown resource type"</span></span> } def from_token(<span class="hljs-string"><span class="hljs-string">"User:"</span></span> &lt;&gt; id), <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: { :ok, Repo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(User, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>.to_integer(id)) } def from_token(_), <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: { :<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>, <span class="hljs-string"><span class="hljs-string">"Unknown resource type"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Now everything is ready to implement the <code>RegistrationController</code> : </p><br><pre> <code class="hljs pgsql"># web/controllers/api/v1/registration_controller.ex defmodule PhoenixTrello.RegistrationController <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use PhoenixTrello.Web, :controller <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> PhoenixTrello.{Repo, <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>} plug :scrub_params, "user" <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> action <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [:<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>] def <span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(conn, %{"user" =&gt; user_params}) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> changeset = <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>.changeset(%<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>{}, user_params) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Repo.<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(changeset) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>} -&gt; {:ok, jwt, _full_claims} = Guardian.encode_and_sign(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, :token) conn |&gt; put_status(:created) |&gt; render(PhoenixTrello.SessionView, "show.json", jwt: jwt, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) {:error, changeset} -&gt; conn |&gt; put_status(:unprocessable_entity) |&gt; render(PhoenixTrello.RegistrationView, "error.json", changeset: changeset) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Thanks to the pattern matching <a href="http://elixir-lang.org/getting-started/pattern-matching.html">mechanism</a> (pattern matching), the <code>create</code> handler expects the <code>"user"</code> key in the parameters.  With these parameters, we will create a User set and add it to the database.  If all goes well, we will use the <strong>Guardian</strong> to encode and sign ( <code>encode_and_sign</code> method) the data of the new user, get the jwt token and convert it along with the user data to <strong>json</strong> .  Otherwise, if the data set is incorrect, we will display errors in the form of <strong>json</strong> so that we can show them to the user in the registration form. </p><br><h3 id="serializaciya-json">  JSON serialization </h3><br><p>  Phoenix uses <a href="https://github.com/devinus/poison">Poison</a> as the default JSON library.  Since this is one of the dependencies of Phoenix, we will not need to do something special to install it.  What really needs to be done is to update the <code>User</code> model and indicate which fields need to be serialized: </p><br><pre> <code class="hljs vbscript"># web/models/user.ex defmodule PhoenixTrello.User <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use PhoenixTrello.Web, :model # ... @derive {Poison.Encoder, only: [:id, :first_name, :last_name, :email]} # ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  From this point on, when converting user data or a list of users into <strong>json</strong> format in response to an event in the controller or channel, the library simply returns the specified fields.  Simply steamed turnips! </p><br><p>  Having received a back-end, ready for registration of new users, in the next publication we will move to the front-end, and in order to complete the registration process, we will program some cool pieces on <strong>React</strong> and <strong>Redux</strong> .  In the meantime, do not forget to take a look at the <a href="https://phoenix-trello.herokuapp.com/">live demo</a> and <a href="https://github.com/bigardone/phoenix-trello">source code of the</a> final result. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/308056/">https://habr.com/ru/post/308056/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308040/index.html">Friendly introduction to Dagger 2. Part 2</a></li>
<li><a href="../308042/index.html">We found 10,000 bugs in various open source projects.</a></li>
<li><a href="../308044/index.html">How does the MTS Mobile Network Operations Center work?</a></li>
<li><a href="../308050/index.html">Questions Heilmeyer, Pierce and our developers answers</a></li>
<li><a href="../308054/index.html">Planning usability testing. Part 2</a></li>
<li><a href="../308058/index.html">"Let's talk about it": The work of the designer</a></li>
<li><a href="../308060/index.html">"In one basket": A little about the storage code</a></li>
<li><a href="../308062/index.html">About the risks of using clouds</a></li>
<li><a href="../308064/index.html">Cisco and Fortinet confirmed the presence of vulnerabilities published by The Shadow Brokers hackers</a></li>
<li><a href="../308066/index.html">What do experts and users think about the new design of VKontakte?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>