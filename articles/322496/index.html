<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The world's easiest lock-free hash table</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A non-blocking hash table is a two-sided medal. In some cases, they allow to achieve such performance, which is not obtained in other ways. On the oth...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The world's easiest lock-free hash table</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/513/646/c17/513646c1755fe24a09374229daf6b5d9.jpg" alt="image"><br><br>  A non-blocking hash table is a two-sided medal.  In some cases, they allow to achieve such performance, which is not obtained in other ways.  On the other hand, they are quite complex. <br><a name="habracut"></a><br>  The first working non-blocking table I heard about was written in Java by Dr. Cliff Click.  His <a href="http://www.azulsystems.com/blog/cliff/2007-04-23-nonblocking-hashtable-source-code">code was released</a> in 2007, the same year the author <a href="http://www.youtube.com/watch%3Fv%3DHJ-719EGIts">made a presentation</a> on Google.  I admit, when I first watched this presentation, I did not understand most of it.  The main thing that I have learned is that Dr. Cliff Click must be some kind of magician. <br><br> <a href="http://www.youtube.com/watch%3Fv%3DHJ-719EGIts"><img src="https://habrastorage.org/files/d84/b03/d16/d84b03d1627d4a74b64f860b8f6cdb22.jpg"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Fortunately, six years was enough for me to (almost) catch Cliff in this matter.  As it turned out, one does not need to be a wizard in order to understand and implement the simplest, but at the same time ideally working, non-blocking hash table.  Here I will share the source code of one of them.  I am sure that anyone who has experience in multi-threading development in C ++ and who is willing to carefully study the previous posts of this blog will understand it without any problems. <br><br>  The hash table was written using <a href="http://mintomic.github.io/">Mintomic</a> , a portable library for non-blocking development in C / C ++, which I <a href="http://preshing.com/20130505/introducing-mintomic-a-small-portable-lock-free-api">released last month</a> .  It is built and run out of the box on several x86 / 64, PowerPC and ARM platforms.  And since each Mintomic function has an equivalent in C ++ 11, translating this table into C ++ 11 is a trivial task. <br><br><h2>  <font color="#c75733">Restrictions</font> </h2><br>  We, programmers, have the instinct to write data structures immediately as universal as possible, so that they are easy to reuse.  This is not bad, but it can serve us a bad service, if from the very beginning we turn it into a goal.  For this post, I went to the other extreme, creating a limited and highly specialized non-blocking hash table as I could.  Here are its limitations: <br><br><ul><li>  Stores only 32-bit integer keys and 32-bit integer values. </li><li>  All keys must be non-zero. </li><li>  All values ‚Äã‚Äãmust be non-zero. </li><li>  The table has a fixed maximum number of records that it can store, and this number must be a power of two. </li><li>  There are only two operations: SetItem and GetItem. </li><li>  No delete operation. </li></ul><br>  Be sure that when you master a limited version of this hash table, it will be possible to consistently remove all restrictions without changing the approach drastically. <br><br><h2>  <font color="#c75733">An approach</font> </h2><br>  There are many ways to implement hash tables.  The approach I chose is just a simple modification of the <code>ArrayOfItems</code> class, described in my previous post, <a href="http://preshing.com/20130529/a-lock-free-linear-search">A Lock-Free ... Linear Search?</a>  I strongly recommend that you read it before continuing. <br><br>  Similar to <code>ArrayOfItems</code> , this hash table class, which I called <code>HashTable1</code> , is implemented using a simple giant array of key / value pairs. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Entry</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mint_atomic32_t</span></span> key; <span class="hljs-keyword"><span class="hljs-keyword">mint_atomic32_t</span></span> value; }; Entry *m_entries;</code> </pre> <br>  <code>HashTable1</code> no linked lists for resolving hash collisions outside the table;  there is only the array itself.  The zero key in the array indicates an empty entry, and the array itself is initialized with zeros.  And just like in <code>ArrayOfItems</code> , the values ‚Äã‚Äãare added and arranged in <code>HashTable1</code> using a linear search. <br><br>  The only difference between <code>ArrayOfItems</code> and <code>HashTable1</code> is that <code>ArrayOfItems</code> always starts a linear search with a zero index, while <code>HashTable1</code> starts each linear search with an index calculated as a <i>hash of a key</i> .  I chose <a href="https://code.google.com/p/smhasher/wiki/MurmurHash3">MurmurHash3's integer finalizer</a> as a hash function, since it is fast enough and well encodes integer data. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">integerHash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> h)</span></span></span><span class="hljs-function"> </span></span>{ h ^= h &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>; h *= <span class="hljs-number"><span class="hljs-number">0x85ebca6b</span></span>; h ^= h &gt;&gt; <span class="hljs-number"><span class="hljs-number">13</span></span>; h *= <span class="hljs-number"><span class="hljs-number">0xc2b2ae35</span></span>; h ^= h &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> h; }</code> </pre> <br>  As a result, each time we call <code>SetItem</code> or <code>GetItem</code> with the same key, the linear search will start with the same index, but when we pass different keys, the search will, in most cases, begin with completely different indexes.  Thus, the values ‚Äã‚Äãare much better distributed over the array than in <code>ArrayOfItems</code> , and it is <code>SetItem</code> call <code>SetItem</code> and <code>GetItem</code> from several parallel threads. <br><br><img src="https://habrastorage.org/files/9c7/f35/384/9c7f3538424a4ff8af3333ddf55610aa.png"><br><br>  <code>HashTable1</code> uses a circular search, which means that when a <code>SetItem</code> or <code>GetItem</code> reaches the end of the array, it simply returns to zero index and continues the search.  Since the array will never be filled, each search is guaranteed to end either by detecting the required key or by detecting a record with key 0, which means that the required key does not exist in the hash table.  This technique is called <a href="http://en.wikipedia.org/wiki/Open_addressing">open addressing</a> with <a href="http://en.wikipedia.org/wiki/Linear_probing">linear probing</a> , and in my opinion, this is the most lock-free-friendly hash table of the existing ones.  In fact, Dr. Click uses the same technique in his Java-free security table. <br><br><h2>  <font color="#c75733">Code</font> </h2><br>  Here is the function that implements <code>SetItem</code> .  It passes through an array and stores the value in the first record, the key of which is 0 or coincides with the desired key.  Its code is almost identical to the <code>ArrayOfItems::SetItem</code> code <a href="http://preshing.com/20130529/a-lock-free-linear-search">described in the previous post</a> .  The differences are only the integer hash and bitwise ‚Äúand‚Äù applied to <code>idx</code> , which does not allow it to go beyond the bounds of the array. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> HashTable1::SetItem(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> key, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> value) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> idx = integerHash(key);; idx++) { idx &amp;= m_arraySize - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> prevKey = mint_compare_exchange_strong_32_relaxed(&amp;m_entries[idx].key, <span class="hljs-number"><span class="hljs-number">0</span></span>, key); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((prevKey == <span class="hljs-number"><span class="hljs-number">0</span></span>) || (prevKey == key)) { mint_store_32_relaxed(&amp;m_entries[idx].value, value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } }</code> </pre> <br>  The <code>GetItem</code> code also almost coincides with <code>ArrayOfItems::GetItem</code> except for minor modifications. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> HashTable1::GetItem(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> key) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> idx = integerHash(key);; idx++) { idx &amp;= m_arraySize - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> probedKey = mint_load_32_relaxed(&amp;m_entries[idx].key); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (probedKey == key) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mint_load_32_relaxed(&amp;m_entries[idx].value); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (probedKey == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br>  Both of the above functions are thread-safe and <code>ArrayOfItems</code> for the same reasons as their counterparts in <code>ArrayOfItems</code> : all operations with array elements are performed using atomic library functions, values ‚Äã‚Äãare assigned to keys using compare-and-swap (CAS) on keys, and all code is resilient against memory reordering.  And again, for a better understanding, I advise you to refer to the <a href="http://preshing.com/20130529/a-lock-free-linear-search">previous post</a> . <br><br>  And finally, just like in the previous article, we optimize <code>SetItem</code> , first checking whether a CAS is really necessary, and if not, not applying it.  Thanks to this optimization, an example of the application that you find below works almost 20% faster. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> HashTable1::SetItem(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> key, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> value) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> idx = integerHash(key);; idx++) { idx &amp;= m_arraySize - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Load the key that was there. uint32_t probedKey = mint_load_32_relaxed(&amp;m_entries[idx].key); if (probedKey != key) { // The entry was either free, or contains another key. if (probedKey != 0) continue; // Usually, it contains another key. Keep probing. // The entry was free. Now let's try to take it using a CAS. uint32_t prevKey = mint_compare_exchange_strong_32_relaxed(&amp;m_entries[idx].key, 0, key); if ((prevKey != 0) &amp;&amp; (prevKey != key)) continue; // Another thread just stole it from underneath us. // Either we just added the key, or another thread did. } // Store the value in this array entry. mint_store_32_relaxed(&amp;m_entries[idx].value, value); return; } }</span></span></code> </pre> <br>  All is ready!  Now you have the simplest non-blocking hash table in the world.  Here are the links to the <a href="">source code</a> and the <a href="">header file</a> . <br><br>  A short warning: as in <code>ArrayOfItems</code> , all operations with <code>HashTable1</code> performed with weak (relaxed) memory ordering constraints.  Therefore, if you want to make any data available to other threads by writing a flag in <code>HashTable1</code> , it is necessary that this record has ‚Äú <a href="http://preshing.com/20120913/acquire-and-release-semantics">release semantics</a> ‚Äù, which can be guaranteed by putting release fence (‚Äúrelease barrier‚Äù) immediately before instruction.  Similarly, accessing <code>GetItem</code> in the stream that wants to receive data needs to acquire a acquire fence (‚Äúacquisition barrier‚Äù). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Shared variables char message[256]; HashTable1 collection; void PublishMessage() { // Write to shared memory non-atomically. strcpy(message, "I pity the fool!"); // Release fence: The only way to safely pass non-atomic data between threads using Mintomic. mint_thread_fence_release(); // Set a flag to indicate to other threads that the message is ready. collection.SetItem(SHARED_FLAG_KEY, 1) }</span></span></code> </pre> <br><h2>  <font color="#c75733">Sample application</font> </h2><br>  To evaluate <code>HashTable1</code> at work, I created another simplest application, very similar to the example from the previous post.  Each time it chooses from two experiments: <br><br><ul><li>  Each of the two threads adds 6,000 values ‚Äã‚Äãwith unique keys. </li><li>  Each stream adds 12,000 different values ‚Äã‚Äãwith the same keys. </li></ul><br><img src="https://habrastorage.org/files/6a6/5c3/066/6a65c30661684cbcadd4d2db090f16cf.png"><br><br>  The code is on GitHub, so you can build it and run it yourself.  For assembly instructions, see <a href="https://github.com/mintomic/samples">README.md</a> . <br><br> <a href="https://github.com/mintomic/samples"><img src="https://habrastorage.org/files/344/3ae/ec8/3443aeec837e4e6388b7bc5bcdcca64f.png"></a> <br><br>  Since the hash table never overflows - say, less than 80% of the array will be used - <code>HashTable1</code> will show remarkable performance.  Perhaps, I should confirm this with measurements, but based on previous experience in measuring <a href="http://preshing.com/20130107/this-hash-table-is-faster-than-a-judy-array">single</a> <a href="http://preshing.com/20110603/hash-table-performance-tests">-</a> <a href="http://preshing.com/20130107/this-hash-table-is-faster-than-a-judy-array">threaded</a> <a href="http://preshing.com/20110603/hash-table-performance-tests">hash-table</a> performance, I can argue that you will not be able to create a faster, non-blocking hash table than <code>HashTable1</code> .  It may seem surprising, but the <code>ArrayOfItems</code> that underlies it shows awful performance.  Of course, as with any hash table, there is a non-zero risk to hash a large number of keys into one array index, and then the performance will be equal to the speed of <code>ArrayOfItems</code> .  But with a fairly large table and a good hash function, such as MurmurHash3, the likelihood of such a scenario is negligible. <br><br>  I used non-blocking tables, similar to this, in real projects.  In one case, in the game I was working on, the severe competition of threads for shared locks created a bottleneck every time memory monitoring was turned on.  After switching to lock-free hash tables, the frame rate in the worst case improved from 4 FPS to 10 FPS. </div><p>Source: <a href="https://habr.com/ru/post/322496/">https://habr.com/ru/post/322496/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322482/index.html">On the application of the scientific method in real life and activities</a></li>
<li><a href="../322484/index.html">MVC programming pattern as a way to implement the design process in Revit</a></li>
<li><a href="../322486/index.html">Detectable virtual machine in C #: 1 level</a></li>
<li><a href="../322492/index.html">The exclusive role of the boss</a></li>
<li><a href="../322494/index.html">The simplest way to avoid routine</a></li>
<li><a href="../322498/index.html">11 steps to high email deliverability</a></li>
<li><a href="../322500/index.html">The CDN provider Cloudflare has injected the contents of its server‚Äôs memory into arbitrary webpage code.</a></li>
<li><a href="../322502/index.html">Downloading audio from mail.ru</a></li>
<li><a href="../322504/index.html">Generation of polygonal maps for games</a></li>
<li><a href="../322508/index.html">15 oddities in ruby ‚Äã‚Äãthat you should know</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>