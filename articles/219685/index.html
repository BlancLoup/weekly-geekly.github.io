<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Delphi Interface Tricks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings. 
 Literally today I discussed interfaces with my colleague. He told me about his interesting technique, I told him about mine, but only on ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Delphi Interface Tricks</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/f3d/d8f/d80/f3dd8fd80c60f6e7dbd37dfccd49cdae.jpg" align="left">  Greetings. <br>  Literally today I discussed interfaces with my colleague.  He told me about his interesting technique, I told him about mine, but only on the way home I realized the power of these techniques, especially if I combined them. <br>  Fans of convenient automation and MVC patterns - I ask for cat. <br><a name="habracut"></a><br><h4>  Trick 1. Smart Weak Links </h4><br>  For those who do not know - Weak (weak) links - links that do not increase the counter.  Suppose we have a tree: <br><pre><code class="delphi hljs">INode = <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetParent</span></span></span><span class="hljs-function">:</span></span> INode; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChildCount</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetChild</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Index</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Integer)</span></span></span><span class="hljs-function">:</span></span> INode; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre>  If inside a class that implements the INode interface, the parent and children would be stored as follows: <br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TNode</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TInterfacedObject, INode) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FParent: INode; FChild: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> INode; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre>  that tree would never be destroyed.  The parent keeps references to the children (and thereby increases the counter for them), and the children to the parent.  This is the classic problem of circular references, in which case weak links are resorted to.  In new XE delphs, you can write this: <br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TNode</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TInterfacedObject, INode) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> [weak] FParent: INode; FChild: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> INode; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre>  and in the old - store Pointer: <br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TNode</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TInterfacedObject, INode) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FParent: Pointer; FChild: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> INode; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre>  This allows you to bypass the auto-increment of the counters, and now if we lose the pointer to the parent, the entire tree will be stuck, as required. <br><br>  Weak links have another side.  If suddenly an object was destroyed at you, and someone holds a weak link on it - you cannot track it.  In fact - you just have a junk pointer, when you contact which there will be an error.  And this is terrible.  It is necessary to sculpt some kind of system for cleaning these very links. <br><br>  But there is a very elegant solution.  And this is how it works.  We write the weak links interface and the class that implements it: <br><pre> <code class="delphi hljs"> IWeakRef = <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsAlive</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">:</span></span> IUnknown; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-title"><span class="hljs-title">TWeakRef</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TInterfacedObject, IWeakRef) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FOwner: Pointer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clean</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsAlive</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">:</span></span> IUnknown; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TWeakRef</span></span></span><span class="hljs-function">._</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clean</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FOwner := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TWeakRef</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">:</span></span> IUnknown; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := IUnknown(FOwner); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TWeakRef</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsAlive</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := Assigned(FOwner); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre>  This is the usual typecast to Pointer.  It is the weak link I mentioned above.  But the key method, <b>IsAlive</b> , which returns <b>True</b> ‚Äî if the object referenced by the weak link ‚Äî still exists.  It remains only to understand how beautifully to clean <b>FOwner</b> . <br>  We write the interface: <br><pre> <code class="delphi hljs"> IWeakly = <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> [<span class="hljs-string"><span class="hljs-string">'{F1DFE67A-B796-4B95-ADE1-8AA030A7546D}'</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WeakRef</span></span></span><span class="hljs-function">:</span></span> IWeakRef; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre>  which returns a weak link and write a class that implements this interface: <br><pre> <code class="delphi hljs"> <span class="hljs-title"><span class="hljs-title">TWeaklyInterfacedObject</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TInterfacedObject, IWeakly) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FWeakRef: IWeakRef; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WeakRef</span></span></span><span class="hljs-function">:</span></span> IWeakRef; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TWeaklyInterfacedObject</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span>; FWeakRef._Clean; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TWeaklyInterfacedObject</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WeakRef</span></span></span><span class="hljs-function">:</span></span> IWeakRef; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj: TWeakRef; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FWeakRef = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> obj := TWeakRef.Create; obj.FOwner := Self; FWeakRef := obj; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Result := FWeakRef; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre>  We simply added a method that distributes one weak link to everyone.  And since the object itself is always aware of its weak link, it simply cleans it in its destructor.  It now remains only to inherit from <b>TWeaklyInterfacedObject</b> instead of <b>TInterfacedObject</b> , and that's it.  No more unsafe type casts, leg shots, and foul language. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Trick 2. Subscribers Mechanism </h4><br>  If you haven‚Äôt cycled the plugin system in Delphi and have not used MVC patterns, then you are lucky.  In Delphi, all events are just one or two pointers to a function (and instance).  Therefore, if you created a class, made the <b>OnBlaBla</b> property to it, then only one person can find out that this <b>BlaBla has</b> finally happened.  Therefore, everyone starts to cut their subscription mechanism, and often drown in debugging these same subscriptions. <br>  Interface based events are usually implemented like this.  Make a separate event interface, for example: <br><pre> <code class="delphi hljs">IMouseEvents = <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMouseMove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMouseDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMouseUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre>  and pass it, instead of the classical procedure of object;  for example, in the Subscribe / Unsubscribe method pair: <br><pre> <code class="delphi hljs">IForm = <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SubscribeMouse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> subscriber: IMouseEvents)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnsubscribeMouse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> subscriber: IMouseEvents)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre>  When the code grows, and the interface <b>IMouseEvents</b> changes slightly (for example, they add a method) - it begins to strain the refactoring.  For example, the same <b>IMouseEvents is</b> used in <b>IForm</b> , <b>IButton</b> , <b>IImage</b> and other evil spirits.  Everywhere you need to correctly correct the subscription, add a crawl on subscribers, etc. <br>  I use the following trick.  We write the interface: <br><pre> <code class="delphi hljs"> IPublisher = <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> [<span class="hljs-string"><span class="hljs-string">'{CDE9EE5C-021F-4942-A92A-39FC74395B4B}'</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Subscribe</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ASubscriber: IUnknown)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unsubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ASubscriber: IUnknown)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre>  The class that will implement this interface (let it be <b>TBasePublisher</b> ) can only add and remove some interfaces from the list.  In the following, we write classes that I call Broadcast.  Here we have an event interface: <br><pre> <code class="delphi hljs"> IGraphEvents = <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> [<span class="hljs-string"><span class="hljs-string">'{2C7EF06A-2D63-4F25-80BC-7BA747463DB6}'</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnAddItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ASender: IGraphList; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AItem: TGraphItem)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnClear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ASender: IGraphList)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre>  We inherit from TBasePublisher and implement such a broadcaster: <br><pre> <code class="delphi hljs"> <span class="hljs-title"><span class="hljs-title">TGraphEventsBroadcaster</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TBasePublisher, IGraphEvents) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnAddItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ASender: IGraphList; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AItem: TGraphItem)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnClear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ASender: IGraphList)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGraphEventsBroadcaster</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnAddItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ASender: IGraphList; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AItem: TGraphItem)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr: TInterfacesArray; i: Integer; ev: IGraphEvents; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> arr := GetItems; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Length(arr) - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Supports(arr[i], IGraphEvents, ev) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ev.OnAddItem(ASender, AItem); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGraphEventsBroadcaster</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnClear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ASender: IGraphList)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr: TInterfacesArray; i: Integer; ev: IGraphEvents; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> arr := GetItems; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Length(arr) - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Supports(arr[i], IGraphEvents, ev) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ev.OnClear(ASender); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre>  that is, the broadcaster itself implements an event interface, and in implementation it simply sends out the same event to all subscribers.  Advantage - everything is implemented in one place, it will not compile if you change <b>IGraphEvents</b> even a little.  Now the <b>IForm</b> , <b>IButton</b> , <b>IImage Zoo</b> simply creates a <b>TGraphEventsBroadcaster</b> inside of itself and calls its methods, as if the <b>IForm has</b> only one subscriber. <br><br><h4>  Trick 3: Weak Smart Links + Subscribers Mechanism </h4><br>  But all that I described above about subscribers is bad.  The fact is that here all the time there will be circular references, you will try to deal with the order of finalization and writing.  You add weak links, but you get bogged down in debugging junk links.  This is where the smart weak links described at the very beginning come in handy.  We just write this kind of publisher interface (which takes <b>IWeakly</b> from the beginning of the article): <br><pre> <code class="delphi hljs"> IPublisher = <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> [<span class="hljs-string"><span class="hljs-string">'{CDE9EE5C-021F-4942-A92A-39FC74395B4B}'</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Subscribe</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ASubscriber: IWeakly)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unsubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ASubscriber: IWeakly)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre>  Internally, the publisher TBasePublisher stores an array of weak links TWeakRefArr = array of IWeakRef; <br><pre> <code class="delphi hljs"> <span class="hljs-title"><span class="hljs-title">TBasePublisher</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TInterfacedObject, IPublisher) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FItems: TWeakRefArr; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItems</span></span></span><span class="hljs-function">:</span></span> TWeakRefArr; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Subscribe</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ASubscriber: IWeakly)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unsubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ASubscriber: IWeakly)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre>  And broadcaster now only checks for a weak reference to viability, gets a normal one, and sends the event to it.  Broadcast has exchanged like this: <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGraphEventsBroadcaster</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnAddItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ASender: IGraphList; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AItem: TGraphItem)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr: TWeakRefArr; i: Integer; ev: IGraphEvents; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> arr := GetItems; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Length(arr) - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> IsAlive(arr[i]) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Supports(arr[i].Get, IGraphEvents, ev) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ev.OnAddItem(ASender, AItem); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGraphEventsBroadcaster</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnClear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ASender: IGraphList)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr: TWeakRefArr; i: Integer; ev: IGraphEvents; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> arr := GetItems; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Length(arr) - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> IsAlive(arr[i]) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Supports(arr[i].Get, IGraphEvents, ev) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ev.OnClear(ASender); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre>  Now we absolutely do not care about the order of unsubscribe.  If we forgot to unsubscribe - do not worry.  Everything became transparent, as it should have been before. <br><br><h4>  Trick 4. Overload to help </h4><br>  Finishing touch: <br><pre> <code class="delphi hljs"> TAutoPublisher = <span class="hljs-keyword"><span class="hljs-keyword">packed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> Publisher: IPublisher; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> Add(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> APublisher: TAutoPublisher; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ASubscriber: IWeakly): Boolean; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> Subtract(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> APublisher: TAutoPublisher; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ASubscriber: IWeakly): Boolean; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> TAutoPublisher.Add(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> APublisher: TAutoPublisher; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ASubscriber: IWeakly): Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> APublisher.Publisher.Subscribe(ASubscriber); Result := True; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> TAutoPublisher.Subtract(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> APublisher: TAutoPublisher; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ASubscriber: IWeakly): Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> APublisher.Publisher.Unsubscribe(ASubscriber); Result := True; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre>  I think it is clear without words.  We just do <b>MyForm. MyEvents + MySubscriber</b> ;  - we subscribed.  Subtracted: <b>MyForm.MyEvents - MySubscriber</b> ;  - unsubscribed. <br><br>  The article would not be complete if I did not provide an example of how this works.  Therefore, <a href="">here is an example</a> .  In short: <br>  The program creates 4 windows.  On any of the windows you can draw with the mouse.  Drawn objects are added to the list, and through the subscription mechanism all windows are notified of the change.  Therefore, the drawn figure appears on all forms.  On each form, you can choose your own line thickness using the trackbar. <br><br>  <i>IntfEx.pas</i> - implementation of smart weak links, the base class of the publisher <b>TBasePublisher</b> on weak links + overloading through the structure of <b>TAutoPublisher</b> <br>  <i>Datas.pas</i> - list of drawn objects + event interface when changing this list <br>  <i>DrawForm.pas</i> - a class that implements the form on which to draw.  There is also a subscription to the event. <br>  <i>HiddenForm.pas</i> - hidden main form (only needed for Application to spin the window loop) <br>  Well, the project file is slightly modified (there are created forms on which you can draw) <br><br>  The idea of ‚Äã‚Äãweak links was invented by Dmitry Ilinykh from Maxidix sro and refined by me. </div><p>Source: <a href="https://habr.com/ru/post/219685/">https://habr.com/ru/post/219685/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../219673/index.html">Spreading the open innovation business model using the API</a></li>
<li><a href="../219675/index.html">The value of an online brand: case distributors and industrialists</a></li>
<li><a href="../219677/index.html">Edward Snowden used the TAILS distribution</a></li>
<li><a href="../219679/index.html">Part one, and the second part still nobody reads</a></li>
<li><a href="../219683/index.html">We are going to one of the authors Laravel @laravelphp - Shawn McCool</a></li>
<li><a href="../219687/index.html">We optimize the business process using a simulator</a></li>
<li><a href="../219691/index.html">Data of about 70,000 cards were compromised at the Russian Railways payment gateway.</a></li>
<li><a href="../219695/index.html">Do you know how the Paralympic Games staff connection was organized?</a></li>
<li><a href="../219697/index.html">DBMS InterSystems Cach√© 2014.1. Release notes</a></li>
<li><a href="../219699/index.html">Corridor testing: we get fast feedback on layouts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>