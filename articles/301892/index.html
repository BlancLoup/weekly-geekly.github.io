<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Syncookied - OpenSource ddos ‚Äã‚Äãprotection system</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When our company BeGet LTD got the task of transparent filtering attacks on OSI model level 4, we wrote our Syncookied solution. We would like to shar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Syncookied - OpenSource ddos ‚Äã‚Äãprotection system</h1><div class="post__text post__text-html js-mediator-article">  When our company <a href="https://beget.com/">BeGet LTD</a> got the task of transparent filtering attacks on OSI model level 4, we wrote our Syncookied solution.  We would like to share this decision with the Internet community, since we haven‚Äôt found any analogues to it (or we don‚Äôt know about them).  There are paid solutions like Arbor, F5, SRX, but they cost a completely different money and they use other protection technologies. <br><br>  Why we chose <b>Rust</b> and the <b>NetMap</b> framework for <b>development</b> , what difficulties we encountered in the process - this article will tell you. <br><br>  ¬ª <a href="https://github.com/LTD-Beget/syncookied">Github</a> <br>  ¬ª <a href="https://github.com/LTD-Beget/tcpsecrets">GitHub kernel module</a> <br>  ¬ª <a href="https://beget.com/ru/articles/syncookied">Project Page</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/602/8d1/271/6028d1271f9f43e5aa3c0eaef92014be.png"><br><a name="habracut"></a><br><h2>  <font color="#2196f3">Principle of operation</font> </h2><br>  More information about the principles of TCP and methods of protection against DDOS attacks level L4 can be found on <a href="https://beget.com/ru/articles/syncookied">the</a> project <a href="https://beget.com/ru/articles/syncookied">page</a> .  But, in any case, to describe the scheme of work and its advantages in this article is necessary. <br><br>  Syncookied - is a logical continuation of the development of technology <a href="https://ru.wikipedia.org/wiki/SYN_cookies">Syncookie</a> .  Syncookie technology is removed from the operating system kernel on a separate server.  To do this, we wrote a module to the kernel and a daemon that communicates with the firewall, transmits the secret key and synchronizes the time stamps, and also includes Syncookie on the server if necessary.  That is, a kernel module is installed on the protected server, which deceives the kernel, causing it to think that it sent Syncookie, and creates the file <b>/ proc / tcp_secrets</b> , and a daemon, which sends data from this file to the firewall. <br><br>  Schematic diagram of the work below: <br><br><img src="https://habrastorage.org/files/4e4/a29/f62/4e4a29f621c442c5a3fc096f0e7347f6.png"><br><br>  Explanations: <br><br><ul><li>  <b>A router</b> is a router that processes incoming traffic. </li><li>  <b>Firewall</b> - the server on which the filtering system is running. </li><li>  <b>Protected server</b> - the server, the traffic to which you want to filter. </li></ul><br>  In the normal state, the <b>router</b> and the protected server communicate directly; if an attack is detected on the <b>router, a</b> static binding of the server's IP address to the MAC address of the <b>firewall is</b> registered, after that all traffic going to the protected server goes to the <b>firewall</b> .  When receiving a SYN packet, a <b>firewall</b> sends a packet on behalf of the protected server to the SYN-ACK network from the server‚Äôs IP address and, more importantly, from the protected syncookie server (since it has a secret key and a timestamp from the protected server), in the case of receiving an ACK packet (with a cookie), the <b>firewall</b> checks its validity, then either changes the MAC address in the packet to the MAC address of the <b>protected server</b> and sends the packet back to the network, or deletes it if the cookie is not valid.  <b>The protected server</b> , receiving an ACK packet, opens connections and sends outgoing packets directly to the <b>router</b> . <br><br>  On the server, as well as in the SynProxy technology, connections are monitored (the algorithm of work can be read in more detail on <a href="https://beget.com/ru/articles/syncookied">the project page</a> ), which allows filtering also other non-valid packets - RST, DATA, SYN + ACK, ACK, and so on. <br><br>  The main difference from similar systems: <br><br><ul><li>  <b>Asynchronous</b> filtering traffic - allows you to install the system near the border routers, regardless of the path of the reverse packet.  That is, in places with the maximum size of the channel. <br><br></li><li>  Syncookied <b>does not break the connection</b> after disabling protection.  Since packages, unlike SynProxy technology, SEQ numbers of sequences do not change.  The disconnection itself consists in removing the static binding of the MAC address to the IP address of the protected server on the router, after which the traffic goes directly to the protected server without processing it with a firewall. <br><br></li><li>  <b>The openness of the</b> solution, scalability and the ability to work on a sufficiently low-cost hardware without noticeable delays. <br><br></li><li>  The system is written in <b>Rust</b> using assembler for demanding operations. </li></ul><br>  It is possible to specify additional filters in the host configuration, the filters are written in <b>pcap</b> format. <br><br>  This filtering system is not suitable for everyone, since its advantages also imply disadvantages: <br><br><ul><li>  This is not a solution for installation on a protected server or a solution for protecting a single server. </li><li>  It is assumed that there is access to the protected servers, and they work under the Linux operating system (to install the kernel module) </li></ul><br><h2>  <font color="#2196f3">Implementation</font> </h2><br>  Initially, the system was written in C ++, after creating a working prototype and testing the viability of the ideas, it was decided to rewrite everything in Rust.  Partly because of the simplification of the code, partly because of the desire to minimize the risk of shooting yourself in the leg when working with memory.  Since all resource-intensive operations were implemented on the assembler, a slight loss of performance was not critical.  To work with the network card, the <a href="https://github.com/luigirizzo/netmap">NetMap</a> framework was selected (there are several <a href="https://habrahabr.ru/post/183832/">articles</a> with a description in <a href="https://github.com/luigirizzo/netmap">Habr√©</a> ) as one of the easiest to use and easy to learn (as it turned out, not without problems). <br><br><h3>  Program architecture </h3><br>  The number of running threads is tied to the number of interrupts generated by the network card for incoming and outgoing queues; between queues for incoming and outgoing traffic, two queues are created - for the forwarded traffic and the traffic that needs to be answered.  Incoming traffic flows take packets from the network card, analyze their headers and, based on filtering rules, do one of three actions: <br><br><ul><li>  remove the package. </li><li>  send the packet to the transfer queue. </li><li>  send a packet to the queue for a response. </li></ul><br>  Flows that process sending packets to the network wait for a signal from the network card about the appearance of a place in the queue for sending packets, then polling the queue for forwarding packets and, if it is empty, polling the queue for packets whose answer is needed, creating a SYN + ACK response and sending it to the network. <br><br>  The minimum delay is made for forwarded valid packets, packets that need to be answered go with a lower priority. <br><br>  There was an idea to implement separate processes for processing the queue of packets requiring a response, but, as practice has shown, this is not required on modern processors and adequate network cards, since at the maximum theoretical load the kernels are not loaded 100%.  Yes, and additional queues will lead to slower processing. <br><br><h3>  Problems we encountered in netmap </h3><br>  The library was not as perfect as we thought.  Initially, the prototype implemented a filtering system for a local server.  It turned out in NetMap only one inbound and one outbound queue is used to communicate with the network subsystem of the kernel, which created certain performance difficulties. <br><br>  For the incoming queue, the NS_FORWARD flag was implemented to automatically forward packets from the NIC to HOST RING, for the outgoing this was not implemented.  For the TX queue, this is added quite simply: <br><br><div class="spoiler">  <b class="spoiler_title">Patch to add NS_FORWARD</b> <div class="spoiler_text"><pre><code class="hljs objectivec">diff --git a/sys/dev/netmap/netmap.cb/sys/dev/netmap/netmap.c index c1a0733.<span class="hljs-number"><span class="hljs-number">.2</span></span>bf6a26 <span class="hljs-number"><span class="hljs-number">100644</span></span> --- a/sys/dev/netmap/netmap.c +++ b/sys/dev/netmap/netmap.c @@ <span class="hljs-number"><span class="hljs-number">-548</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span> +<span class="hljs-number"><span class="hljs-number">548</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span> @@ SYSEND; NMG_LOCK_T netmap_global_lock; + +<span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> nm_sync_finalize(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> netmap_kring *kring); + <span class="hljs-comment"><span class="hljs-comment">/* * mark the ring as stopped, and run through the locks * to make sure other users get to see it. @@ -1158,6 +1161,14 @@ netmap_sw_to_nic(struct netmap_adapter *na) rdst-&gt;head = rdst-&gt;cur = nm_next(dst_head, dst_lim); } /* if (sent) XXX txsync ? */</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sent) { + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nm_txsync_prologue(kdst, rdst) &gt;= kdst-&gt;nkr_num_slots) { + netmap_ring_reinit(kdst); + } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (kdst-&gt;nm_sync(kdst, NAF_FORCE_RECLAIM) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { + nm_sync_finalize(kdst); + } + printk(KERN_ERR <span class="hljs-string"><span class="hljs-string">"Synced %d packets to NIC ring %d"</span></span>, sent, i); + }</code> </pre> </div></div><br>  In the future, we refused to work with HOST RING. <br><br>  For testing, we used two cards from Intel - <a href="http://ark.intel.com/ru/products/39776/Intel-Ethernet-Converged-Network-Adapter-X520-DA2">X520</a> and <a href="http://ark.intel.com/ru/products/83964/Intel-Ethernet-Converged-Network-Adapter-X710-DA2">X710</a> .  The X520-based card started up without any problems, but only 4 bits were allocated for interruption in them - as a result, a maximum of 16 interrupts, despite the fact that drivers can show more.  In X710, 8 bits are already allocated for interruption, there is virtualization and a lot of interesting things.  The X710 had to be flashed, since Intel did not bother to add third-party SPF + support through the kernel module option, as is done in the X520 cards: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">insmod</span></span> ./ixgbe/ixgbe.ko allow_unsupported_sfp=<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  The card was stitched according to the instructions below: <br><br><ol><li>  Download <a href="https://github.com/terpstra/xl710-unlocker">github.com/terpstra/xl710-unlocker</a> . </li><li>  Substitute pci values ‚Äã‚Äãin mytool.c </li><li>  Compile </li><li>  Download ./mytool 0 0x8000 </li><li>  Find where this is repeated 4 times: <br><br><pre> <code class="hljs php"><span class="hljs-number"><span class="hljs-number">00006870</span></span> + <span class="hljs-number"><span class="hljs-number">00</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">000</span></span>b <span class="hljs-number"><span class="hljs-number">00006870</span></span> + <span class="hljs-number"><span class="hljs-number">01</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0022</span></span> = external SFP+ <span class="hljs-number"><span class="hljs-number">00006870</span></span> + <span class="hljs-number"><span class="hljs-number">02</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0083</span></span> = int: SFI, <span class="hljs-number"><span class="hljs-number">1000</span></span>BASE-KX, SGMII (???) <span class="hljs-number"><span class="hljs-number">00006870</span></span> + <span class="hljs-number"><span class="hljs-number">03</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1871</span></span> = ext: <span class="hljs-number"><span class="hljs-number">0x70</span></span> = <span class="hljs-number"><span class="hljs-number">10</span></span>GBASE-{SFP+,LR,SR} <span class="hljs-number"><span class="hljs-number">0x1801</span></span>=crap? <span class="hljs-number"><span class="hljs-number">00006870</span></span> + <span class="hljs-number"><span class="hljs-number">04</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0000</span></span> <span class="hljs-number"><span class="hljs-number">00006870</span></span> + <span class="hljs-number"><span class="hljs-number">05</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0000</span></span> <span class="hljs-number"><span class="hljs-number">00006870</span></span> + <span class="hljs-number"><span class="hljs-number">06</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">3303</span></span> = SFP+ copper (passive, active), <span class="hljs-number"><span class="hljs-number">10</span></span>GBase-{SR,LR}, SFP <span class="hljs-number"><span class="hljs-number">00006870</span></span> + <span class="hljs-number"><span class="hljs-number">07</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">000</span></span>b <span class="hljs-number"><span class="hljs-number">00006870</span></span> + <span class="hljs-number"><span class="hljs-number">08</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>b0c *** This is the important register *** (<span class="hljs-number"><span class="hljs-number">0xb</span></span>=bits <span class="hljs-number"><span class="hljs-number">3</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span> = enable qualification (<span class="hljs-number"><span class="hljs-number">3</span></span>), pause TX+RX capable (<span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0xc</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span> = <span class="hljs-number"><span class="hljs-number">10</span></span>GbE + <span class="hljs-number"><span class="hljs-number">1</span></span>GbE) <span class="hljs-number"><span class="hljs-number">00006870</span></span> + <span class="hljs-number"><span class="hljs-number">09</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>a00 <span class="hljs-number"><span class="hljs-number">00006870</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>a =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>a1e = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> LESM values <span class="hljs-number"><span class="hljs-number">00006870</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>b =&gt; <span class="hljs-number"><span class="hljs-number">0003</span></span></code> </pre> <br></li><li>  Shove mypoke.c offset and value </li><li>  Compile, run (it hangs for a long time, it seems ok) </li><li>  Run mytool and see that everything has changed </li><li>  <a href="https://downloadcenter.intel.com/download/24769/NVM-Update-Utility-for-Intel-Ethernet-Converged-Network-Adapter-XL710-and-X710-Series">Download</a> </li><li>  Run nvmupdate64e -u from there (also hangs for a long time) </li><li>  Then either the link appeared, or you killed the card =) </li></ol><br>  A newer (than in the kernel) version of the driver from e1000.sf.net with a patch patch from netmap <a href="https://github.com/polachok/i40e-netmap/tree/master">here</a> . <br><br>  <s>Also leave here a set of <b>magical crutches.</b></s> Our tests showed that with the following settings, optimal performance is achieved: <br><br><pre> <code class="hljs pgsql">  iommu=<span class="hljs-keyword"><span class="hljs-keyword">off</span></span> netmap.ko no_timestamp=<span class="hljs-number"><span class="hljs-number">1</span></span> ixgbe.ko InterruptThrottleRate=<span class="hljs-number"><span class="hljs-number">9560</span></span>,<span class="hljs-number"><span class="hljs-number">9560</span></span> RSS=<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span> DCA=<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span> allow_unsupported_sfp=<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span> VMDQ=<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span> AtrSampleRate=<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span> FdirPballoc=<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span> MDD=<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br><h3>  The problems we have overcome in Rust </h3><br>  Rust, as a programming language, saved us from a lot of difficulties and significantly accelerated development (if there are people willing to rewrite in C ++, it is not difficult), but added a number of specific performance problems with which we successfully struggled during the month.  During the development, we sent 15 pools of requests, of which 12 were accepted by us. <br><br>  In the first implementation, we achieved the performance of 5M packages on 16 cores, at about the same time <b>Google</b> employee Eric Dumazet <a href="http://www.spinics.net/lists/netdev/msg373054.html">wrote</a> to the kernel mailing list that he fixed everything and managed to get the vanilla core to process 6M packets.  As the saying goes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/06e/c9c/616/06ec9c6166f64c53ac6a35371b5ed4b3.jpg"></div><br><div class="spoiler">  <b class="spoiler_title">Main performance issues we encountered:</b> <div class="spoiler_text"><h4>  Netmap generic driver </h4><br>  Initially, we used a generic driver, but it was not the best solution in terms of performance.  When using the generic driver, the package still falls into the kernel's network stack, which is quite sad, since the <b>ksoftirqd</b> picture with red in htop continues: <br><br><img src="https://habrastorage.org/files/e72/d9c/56b/e72d9c56be6240c5a848873b1d410029.png"><br><br>  The solution is to use native drivers.  These are special drivers with added netmap hooks. <br><br>  A newer (than in the kernel) version of the driver from e1000.sf.net with a patch applied by netmap: <br>  <a href="https://github.com/polachok/i40e-netmap/tree/master">github.com/polachok/i40e-netmap/tree/master</a> <br><br><h4>  Using Host Ring </h4><br>  In the native drivers, we are faced with new problems - they did not work.  I had to understand the source code, read the documentation, and it turned out that the drivers are working, the Host Ring is not working.  Host Ring has two problems - it does not work with native drivers and it has only one queue, that is, even if the network has 16 queues, the Host Ring will have one queue.  This creates additional synchronization and blocking problems.  We found the right solution in this situation - not to use Host Ring =), but to send packets back to the network.  Alternatively, tap devices could be used, they support multiqueue, but we have not yet implemented this feature. <br><br><h4>  Locks </h4><br>  After abandoning the Host Ring and refusing to install software on each server (as we originally wanted), it turned out that we need to have support for several protected hosts in one daemon, a quick reload of the config without losing states, and other pleasant trifles.  We tried to make it simple - take a global structure to wrap it in mutex - performance dropped to 3M packets.  After finding out, it turned out that <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html">std :: sync :: Mutex</a> from the standard Rust library is just wrappers on pthread mutexes and they work quite slowly, since for each lock you have to go to the kernel, switch the context.  We found a <a href="https://webkit.org/blog/6161/locking-in-webkit/">post</a> on the Internet where people from webkit made more efficient locks, while <a href="https://crates.io/crates/parking_lot">parking_lot</a> was made on the basis of this post.  In parking_lot, locks are organized somewhat differently - they are adaptive, at first they try to spin ( <a href="https://ru.wikipedia.org/wiki/Spinlock">Spinlock</a> ) several times and only then go to the core, they are smaller in size, because the list of threads that are blocked on it is stored separately.  It became a little better, but not much. <br><br>  We decided to use <a href="https://en.wikipedia.org/wiki/Thread-local_storage">Thread Local Storage</a> .  Each stream can have its own storage, to which we can walk without blocking.  We have created a global configuration that is once every 10 seconds copied to Thread Local Storage.  It turns out the almost complete absence of locks, they certainly are, but are spread over time and are not actually noticeable. <br><br><h4>  Channels </h4><br>  One more problem was found out: in Rust there are <a href="https://doc.rust-lang.org/std/sync/mpsc/index.html">std :: sync :: mpsc</a> (channels) - they are about the same as the channels in Go.  We use them to transfer packets from streams that are received to streams that are sent.  In fact, the channel is an array for mutex.  The word mutex in the context of our story is a sad word.  We took the channels and moved them to parking_lot: <a href="https://github.com/polachok/mpsc">github.com/polachok/mpsc</a> . <br><br>  It got a little better.  mpsc is the multiple producer single consumer, in our case, the multiple producer is not needed, since from one RX package goes into one TX. <br><br>  We found the library with the <a href="https://crates.io/crates/bounded-spsc-queue">bounded-spsc-queue</a> functionality we needed - it became much better, the locks were gone - only atomic operations were used, but it turned out that copying was happening - we had to <a href="https://github.com/polachok/bounded-spsc-queue">finish the</a> library a little. <br><br><h4>  Build the package every time </h4><br>  The next problem we encountered: in the case of an answer, a packet is collected from scratch every time.  This was displayed in reds in perf, and I had to optimize this with a one-time build of the package template, after copying it, we replace the necessary fields in it.  The performance gain was about 30%. </div></div><br>  From more or less interesting pull requests you can note: <br><br>  <b>libpnet</b> <br><blockquote>  <a href="https://github.com/libpnet/libpnet/pull/178">github.com/libpnet/libpnet/pull/178</a> - TCP protocol support <br>  <a href="https://github.com/libpnet/libpnet/pull/181">github.com/libpnet/libpnet/pull/181</a> - change package without allocation <br>  <a href="https://github.com/libpnet/libpnet/pull/183">github.com/libpnet/libpnet/pull/183</a> - reading package without allocations <br>  <a href="https://github.com/libpnet/libpnet/pull/187">github.com/libpnet/libpnet/pull/187</a> - ARP support </blockquote><br>  <b>rust-lang</b> <br><blockquote>  <a href="https://github.com/rust-lang/rust/pull/33891">github.com/rust-lang/rust/pull/33891</a> - accelerating the comparison of ip-addresses </blockquote><br>  <b>concurrent-hash-map</b> <br><blockquote>  <a href="https://github.com/AlisdairO/concurrent-hash-map/pull/4">github.com/AlisdairO/concurrent-hash-map/pull/4</a> - adds support for custom hashing algorithms </blockquote><br>  <b>bpfjit for Rust</b> <br><blockquote>  <a href="https://github.com/polachok/bpfjit">github.com/polachok/bpfjit</a> - bindings of the pcap JIT compiler for Rust </blockquote><br><div class="spoiler">  <b class="spoiler_title">Full list of our pull requests</b> <div class="spoiler_text">  <a href="https://github.com/gobwas/influent.rs/pull/9">github.com/gobwas/influent.rs/pull/9</a> <br>  <a href="https://github.com/gobwas/influent.rs/pull/8">github.com/gobwas/influent.rs/pull/8</a> <br>  <a href="https://github.com/terminalcloud/rust-scheduler/pull/4">github.com/terminalcloud/rust-scheduler/pull/4</a> <br>  <a href="https://github.com/rust-lang/rust/pull/33891">github.com/rust-lang/rust/pull/33891</a> <br>  <a href="https://github.com/libpnet/libpnet/pull/187">github.com/libpnet/libpnet/pull/187</a> <br>  <a href="https://github.com/libpnet/libpnet/pull/183">github.com/libpnet/libpnet/pull/183</a> <br>  <a href="https://github.com/libpnet/libpnet/pull/182">github.com/libpnet/libpnet/pull/182</a> <br>  <a href="https://github.com/libpnet/libpnet/pull/181">github.com/libpnet/libpnet/pull/181</a> <br>  <a href="https://github.com/libpnet/libpnet/pull/178">github.com/libpnet/libpnet/pull/178</a> <br>  <a href="https://github.com/libpnet/netmap_sys/pull/10">github.com/libpnet/netmap_sys/pull/10</a> <br>  <a href="https://github.com/libpnet/netmap_sys/pull/4">github.com/libpnet/netmap_sys/pull/4</a> <br>  <a href="https://github.com/libpnet/netmap_sys/pull/3">github.com/libpnet/netmap_sys/pull/3</a> <br>  <a href="https://github.com/AlisdairO/concurrent-hash-map/pull/4">github.com/AlisdairO/concurrent-hash-map/pull/4</a> <br>  <a href="https://github.com/ebfull/pcap/pull/56">github.com/ebfull/pcap/pull/56</a> <br>  <a href="https://github.com/polachok/xl710-unlocker/pull/1">github.com/polachok/xl710-unlocker/pull/1</a> </div></div><br><h2>  <font color="#2196f3">Performance</font> </h2><br>  In the absence of traffic, syncookied to reduce delays constantly polls the network card, which creates a small load.  Parasitic load decreases with increasing number of incoming packets: <br><br><img src="https://habrastorage.org/files/5c3/281/6f6/5c32816f68874741b8f30471dc3b2eea.png"><br><br>  The load generated by traffic filtering is 12.755pps ( <a href="http://www.cisco.com/c/en/us/about/security-center/network-performance-metrics.html">theoretical limit</a> for a packet size of 74 bytes + 4 bytes of ethernet header) <br><br><img src="https://habrastorage.org/files/755/499/107/755499107bd14ea3ae5c707fdce2c357.png"><br><br>  When UDP filtering or port / protocol rules are applied, the load will be indistinguishable from the load in the absence of traffic. <br><br>  In fact, the 12 cores of the Intel Xeon E5-2680v3 processor can handle 10 gigabit of syn / ack / data flooding traffic.  One physical server can handle more than 40 gigabit of traffic. <br><br><h2>  <font color="#2196f3">Todo</font> </h2><br>  At the moment, we have almost completed the implementation of SynCookied on the entire infrastructure of our hosting, repulsed several not very strong attacks and, if possible, are improving the product.  Plans to add protection Out of Seq (with this, I hope, our colleagues will help us), almost implemented full-fledged SynProxy, add beautiful metrics to Influx, we think to add Auto mode to the implementation of Syncooked protection (similar to net.ipv4.tcp_syncookies = 1, Cook is sent when too many Syn arrives (packets). <br><br><h2>  <font color="#2196f3">Conclusion</font> </h2><br>  We very much hope that our work will benefit the Internet community. <br><br>  If the DDOS protection companies had put their practices into OpenSource, and every provider / administrator / client could use them, the problem of exploiting the imperfections of the Internet would be solved much faster. <br><br>  We tested our system on synthetic tests and weak DDOS attacks (As an evil one, no normal attack has arrived for 4 months).  For our tasks, the system turned out to be quite convenient.  I would also like to note that the project at Rust was actually implemented by one person, a very talented programmer Alexander Polyakov, in a short time, after implementing the C ++ prototype and checking the idea for efficiency before the working version 5 weeks passed. <br><br>  ¬ª <a href="https://github.com/LTD-Beget/syncookied">Source Code</a> <br>  ¬ª <a href="https://github.com/LTD-Beget/tcpsecrets">Kernel Module Source Code</a> <br>  ¬ª <a href="https://beget.com/ru/articles/syncookied">Project Page</a> <br><br><blockquote>  The author of the idea and the implementation of the prototype: Manikin <a href="https://habrahabr.ru/users/redfenix/" class="user_link">redfenix</a> Alexey <br>  Implementation option on Rust: Polyakov <a href="https://habrahabr.ru/users/polachok/" class="user_link">polachok</a> Alexander <br>  Infrastructure creation and testing: Losev <a href="https://habrahabr.ru/users/moosy/" class="user_link">moosy</a> Maxim </blockquote></div><p>Source: <a href="https://habr.com/ru/post/301892/">https://habr.com/ru/post/301892/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../301874/index.html">Bootstrapping is a business from scratch. Part 2. Money</a></li>
<li><a href="../301878/index.html">Small spool, yes roads: in a nutshell about the VMware Host Client</a></li>
<li><a href="../301880/index.html">Overcoming user incompetence as a key service problem</a></li>
<li><a href="../301882/index.html">Assembler / disassembler of Windows keyboard layouts using flat assembler</a></li>
<li><a href="../301890/index.html">How to promote business on the Internet? What should be the selling site? Free internet marketing seminar</a></li>
<li><a href="../301894/index.html">Domain distribution statistics by AS, IP, NS, MX and other parameters</a></li>
<li><a href="../301898/index.html">Wind River Rocket: Getting Started</a></li>
<li><a href="../301900/index.html">Methods of generating random numbers with a uniform distribution law. Part 1</a></li>
<li><a href="../301904/index.html">Google I / O 2016: Android N and Android Ecosystem Details</a></li>
<li><a href="../301906/index.html">Why is summer good for brands?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>