<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Project generator</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article will discuss a specific software product designed for the development of large software and information systems. This product is called ‚Äú...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Project generator</h1><div class="post__text post__text-html js-mediator-article">  This article will discuss a specific software product designed for the development of large software and information systems.  This product is called ‚ÄúProject Generator‚Äù, and it is based on an instrumental approach to programming, when the process of developing software systems is considered as an object of automation.  This topic was quite fashionable somewhere in the 70-80s of the last century, but in our opinion, this approach is not outdated today.  At least, for many years our creative team managed to develop industrial automated systems for various purposes with the help of <a href="https://www.ustech.ru/ostcgi/ostagn%3Fsection%3Dprojects%26project%3Dall%26comp%3Dall">our own tools</a> . <br><br>  In the subsequent sections of the article, we will consider some technical aspects of our approach to the instrumental support for the development of large software and information systems, taking into account the historical development of our own views on this issue.  That part of the audience, which is our ‚Äúself-digging‚Äù seems too diligent, we suggest immediately proceed to the section ‚ÄúThe current situation‚Äù, where we, summing up all the material, we will try to articulate as clearly as possible what we offer to evaluate and discuss to the wide developer community. <br><a name="habracut"></a><br><h3>  Historical background for understanding the motivation of developers </h3><br>  The project generator was laid more than a quarter of a century ago, when the development team was forced for obvious reasons to complete work on projects in aviation design bureaus and start looking for the use of acquired experience in other areas. <br><br>  Working on several projects in the banking sector, it turned out that we had to write several systems consisting of many similar elements, differing only in the composition of parameters.  The developed systems were built on the then new technology two-tier client-server: workplace - server - database.  Each element of the system at the client workstation in general implemented a screen with a data entry form, several tables and several buttons or menu items to perform some actions and, possibly, switch to another screen.  In the client-server protocol, it was necessary to program the transmission of the corresponding data and the reception of the server's response.  The server had a procedure for receiving the request parameters, analyzing them, performing the required database queries, sending the results in the form of a response to a client request. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Thus, the work was carried out as if in two dimensions.  One of them is the development of new such fragments, which we have called procedures.  New procedures appeared as they were developed, as well as when the task was clarified.  Old procedures have been modified. <br><br>  Here the word ‚Äúprocedure‚Äù is used not in the sense, for example, of the Pascal language, i.e.  something like subroutines, functions, etc. Rather, it is a kind of code pattern. <br><br>  The second dimension is the process implementation technology itself.  The protocol was changed, various security subsystems were connected, which led to the need to change the program code of all the procedures implemented previously, both in client and server programs. <br><br>  In addition, with a large number of procedures, it became a problem to maintain the integrity of the project in terms of compliance of client and server programs with their interaction protocol.  For example, if in some query a new parameter was added, then the corresponding edits should be performed consistently in two different programs - in the client and in the server. <br><br>  In connection with the above, an idea arose to automate this process.  By that time, we had experience in implementing programs for the parsing of complex languages ‚Äã‚Äã(the Fakir conceptual programming system with a hierarchical description of algebraic models, analytical formula calculations, and other irrelevant tasks now). <br><br>  As a result, a project description language was developed, consisting of a header with various project parameters and a set of procedure descriptions.  Each procedure had a unique name, a list of input parameters, a list of server requests with a specification of input and output parameters and a response type ‚Äî a table or one set, and a list of envisaged actions that can be performed in the context of this procedure. <br><br>  The named data types used in the procedures were specified as part of the project in its description.  The description was naturally monitored for compliance with the different components in composition. <br><br>  Such a description was fed to the input of the project generator, which built the project model in memory, its analysis for integrity.  Further, on the basis of the model, the texts of programs that implement client and server program modules were generated. <br><br>  In the simplest case, client programs were generated in a complete form, but in special cases it was possible to order hand-made software inserts for performing special actions not provided for in the described simple project model. <br><br>  Project programs themselves were implemented in C language.  The server at that time was on the VAX VMS platform, client programs on an IBM PC running MS DOS (but also provided on VAX VMS).  Server requests were written on the C preprocessor, which understood the SQL queries embedded in the C program text. <br><br>  The project description also included a description of the database tables in terms of the types described.  This made it possible in the project description to formulate simplified queries to the database on some subset of the SQL language with full syntactic analysis of them for compliance with the given base scheme.  More complex queries were implemented in the server programs by means of the preprocessor. <br><br>  The described technology took root and stood the test of time for a decade.  With its help, a fair number of projects in various fields were made. <br><br>  The model of the project was improved, complicated.  Changed software and hardware platforms.  Clients and servers began to function in MS Windows and Linux. <br><br>  The development of the two dimensions mentioned above made it possible to separate the work of analysts from the work of system programmers.  The analyst focused on applied tasks, and the system programmer on operating systems, protocols, languages, etc. <br><br>  The main advantage of this technology is a significant reduction in the code that the system developer writes.  The description of one procedure can take several dozen lines, and the generated C program code is usually an order of magnitude more.  A change in system software affects the application developer code a little, such changes are taken into account in new versions of the generator. <br><br>  The use of the project generator made it possible to implement complex volumetric projects with a minimum number of developers, often by one person, and this was done by people who were not well versed in the intricacies of programming, but had a mathematical background and experience in developing systems.  Those.  not a programmer, but an analyst could independently set up a complex project and bring it to working condition without the involvement of system programmers. <br><br>  To ensure the convenience of development in the generator, various auxiliary functions of the project design have been constantly improved.  In addition to the text of the programs, numerous command files were generated to perform the translation and assembly of all program components for different platforms.  The utilities for creating and modifying the database were generated.  Automated procedure for the formation of installation packages for transmission to the customer. <br><br>  It should be noted a little terminological confusion.  The project description language described above was often designated as a non-procedural language, in the sense that there were no program operators in it, as in C, Pascal, etc. And the procedures mentioned in the project language are completely different concepts. <br><br><h3>  Transition from a non-procedural project model to a universal programming language </h3><br>  As the appetite grew during the meal in the early 2000s, it became clear that it was necessary to improve the technology used in developing projects further. <br><br>  First, the framework of the project model itself, as a set of types, a database and a set of procedures with queries, became close. <br><br>  Secondly, the use of the C language in the server, and sometimes in client programs, has become boring.  The analyst level is too low - to delve into the details and intricacies of passing parameters, pointers, zero bytes, etc. <br><br>  On the other hand, there were projects in which it was necessary to write not simple requests to the database for the needs of banking accounting, but rather voluminous programs with complex data structures.  In such projects, the effect of automatic generation of software text was reduced, since you had to write a lot of manual code. <br><br>  With the transition to the window interface, it became possible, and, as a result, the need to depict not only tables with texts and numbers in client programs, but also all other content in the form of pictures and drawings. <br><br>  In this connection, it was necessary to complicate the client-server interaction protocol.  All this has become an incentive to develop a completely new project generator. <br><br>  The basis of the new development was the concept of a structured document.  The document in the context of the project generator occupies one of the central concepts.  At the conversational level, a document is a database of a network structure in the program's memory. <br><br>  The network structure of the document (database) assumes that tables are stored in it, between the rows of which one-to-many relationships are established.  This is the old, forgotten concept of databases of the network structure, which we used in the old developments. <br><br>  The main idea was that the client program receives information from the server not in the form of several tuples and tables, but in the form of an arbitrary document fixed for the given request structure.  And, symmetrically, the client, fulfilling the request, also sends a document in general form. <br><br>  Thus, on the server it is necessary to be able to read the input document from the protocol, having restored its structure in memory.  Further, on the basis of the received document, execute a certain program, now called business logic, in which interaction with the database (real, out of memory) is assumed.  As a result, the program must generate an output document for transmission to the client program via the protocol. <br><br>  The client program should provide a program for generating the contents of the application window based on the data received. <br><br>  The initial project assumed, as well as previous versions of the generator, the use of the C language for writing server request bodies, as well as programs for generating the contents of the application window.  As an experimental tool, a relatively simple programming language was developed, designed in the simplest cases to replace the C language.  This language was part of the project description language as a whole and received the conditional name of the basic generator language. <br><br>  The following are the basic concepts of the base language. <br><br>  The description of the named data type is a string of a given fixed length, numbers of different widths, an enumerated type, a mask type (a bitmask with named components), a structure, and, finally, the document mentioned above. <br><br>  Procedure (analogue of a function in C) with parameters of the specified types, including documents. <br><br>  The main standard operators are assignment, conditional, for loop, while loop, procedure call, expression.  Everything is very similar to ordinary standard languages.  Procedures for manipulating its components are automatically available for the document type. <br><br>  The result was devastating - after some time in current projects the share of C programs has rapidly decreased to insignificant sizes.  Somehow it turned out by itself that project developers began to write exclusively in this language not only the project model, but all the programs both on the client and on the server. <br><br>  The apotheosis of this unexpected process was the writing of the generator itself in its basic language. <br><br><h3>  Architecture project generator at different stages of its development </h3><br>  Initially, the structure of the generator assumed at the input a description of the project, a set of texts of manual programs in the C language and a database preprocessor for C.  The output is a set of resulting C programs and scripts for translation, assembly, distribution kit formation and other useful actions. <br><br>  The structure of the generator at this stage of development had the form in the figure below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/19e/e91/fc4/19ee91fc42534c53820f2b137617f0e7.png"></div><br>  With the advent of the base language, the structure of the generator was as follows.  Two components stood out in the generator - the C-code generator from the project model and the C-code generator from texts in the base language. <br><br>  A project model contains high-level entities, such as a server, an application, a server port, a security subsystem, an application window type, a dialog, and many other useful things.  All these model entities in the process of generating a project generate programs that implement them in the C language. <br><br>  The developer also writes his pieces of C-programs, which according to certain rules are included in the resulting set of C-programs of the project. <br><br>  Now part of the manual C-programs has become possible to replace with equivalent programs in the basic language, which are easier to integrate with the project model. <br><br>  Thus, with the advent of the basic language, the structure of the generator acquired the form shown in the following figure. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/df0/6d5/7e6/df06d57e620c42d3b5b82fe171bdbbb5.png"></div><br>  In the process of developing a basic language, the volume of input texts on it grew, and in C it decreased.  And as the model description language evolved, the amount of code in the base language decreased, being replaced by short and succinct descriptions of model entities. <br><br>  Due to the complication of the model component of the project description, the idea arose to generate the model immediately after the C code, and the code in the base language.  This simplified the generator itself, since there was no need to follow the subtleties of addressing in C to implement model entities.  The translator of the base language in C follows all this. <br><br>  As a result, the structure of the generator was as follows. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/859/427/5a3/8594275a350f4f34a65098bcf30fa773.png"></div><br><h3>  Basic Concepts of the Generator Base Language </h3><br>  The base language is a part of the generator project description language that implements a universal programming language.  The developer using the project generator has the ability to write ordinary programs in this language, but as part of some project. <br><br>  Unlike C, there is no possibility to write and broadcast a separate program in the basic language.  Even if your program consists of several dozen operators, you still need to describe a project in which your program will be the only component, as a utility-type package - a console application. <br><br>  In a more complicated case, a program in the base language may consist of several packages. <br><br>  A package is one of the basic concepts of a generator (and basic) language.  The package has a unique name within the project, is declared as a package of some type and, as a rule, is presented as a separate file with the text of the program of the package. <br><br>  A project description is a project description file with a header and an ordered list of packages. <br><br>  The generator has a large set of so-called system packages of various types, which are written by the developers of the generator and can be used explicitly or implicitly through model entities in your projects.  Developer packages do not have to match names with system packages. <br><br>  Let us give an example of the simplest project of the ‚ÄúHello world‚Äù type.  We will not consider the project directory structure here.  In our case, we have to create two files - a description of the project and a description of the utility as part of the project, inventing names for them. <br><br>  Let the project name be hello, the utility name in the project be world.  Then we need to create two text files hello.gen and world.utility. <br><br>  File hello.gen: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre><code class="cpp hljs">project hello /version=<span class="hljs-string"><span class="hljs-string">"01.001"</span></span> utility world</code> </pre> <br></div></div><br>  World.utility file: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs">utility world:<span class="hljs-string"><span class="hljs-string">"world"</span></span> main { dprint(<span class="hljs-string"><span class="hljs-string">"Hello world!"</span></span>); }</code> </pre><br></div></div><br>  As a result of the generation and assembly of such a project, the executable world.exe (for MS Window) or world (for Unix) will be obtained.  When launched, the program prints the string ‚ÄúHello world!‚Äù In the console. <br><br>  Consider a more complex example in which, in addition to the utility package, a simple package of the type package is used. <br><br>  Pkgexample.gen file: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs">project pkgexample /version=<span class="hljs-string"><span class="hljs-string">"01.001"</span></span> package mypkg utility myutl</code> </pre><br></div></div><br>  File mypkg.package: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs">package mypkg type t_myint : <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>; <span class="hljs-function"><span class="hljs-function">fprocdecl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t_myint a,t_myint b,out t_myint c)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">implementation fproc </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">localsum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t_myint x,t_myint y,out t_myint z)</span></span></span><span class="hljs-function"> </span></span>{ z := x+y; } <span class="hljs-function"><span class="hljs-function">fprocdecl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t_myint a,t_myint b,out t_myint c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">call </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">localsum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a,b,c)</span></span></span></span>; }</code> </pre><br></div></div><br>  File myutl.utility: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs">utility myutl:<span class="hljs-string"><span class="hljs-string">"myutl"</span></span> main { var mypkg.t_myint p := <span class="hljs-number"><span class="hljs-number">3</span></span>, mypkg.t_myint q := <span class="hljs-number"><span class="hljs-number">5</span></span>, mypkg.t_myint r; call mypkg.sum(p,q,r); dprint(<span class="hljs-string"><span class="hljs-string">"p="</span></span>,p,<span class="hljs-string"><span class="hljs-string">" q="</span></span>,q,<span class="hljs-string"><span class="hljs-string">" r="</span></span>,r,<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); }</code> </pre><br></div></div><br>  In this case, we have two packages as part of the project - the mypkg software package and the myutl utility. <br><br>  The mypkg package in the external specifications section (before the implementation keyword) describes the type of t_myint derived from the base type int (a 32-bit integer), and the specification of the sum procedure with two input parameters a, b of type t_myint and one output parameter with the same type. <br><br>  All that is written after the implementaion keyword is available only inside the package. <br><br>  The procedure localsum has a similar header like the external procedure sum, but it starts with the keyword fproc, which means that it is a local object.  After the header, instead of a semicolon, there is a block of operators in curly brackets, very similar to that in the C language.  Inside the block there is one assignment operator.  In contrast to the vulgar equality, the assignment here is given by the characters ": =". <br><br>  Generator developers, as people with basic mathematical education, were in pain to look at such constructions in C-like languages, like a = a + 1.  It was decided to use algo-pascal notation in such operators. <br><br>  After the local procedure localsum, the body of the external procedure sum declared in the specifications section is located.  The description of the previously specified procedure is similar to the description of the local procedure, but with the fprocdecl keyword and an exact copy of the parameters.  Next comes the procedure body block, in which the local procedure call localsum is located. <br><br>  In the myutl package, there is still a single main section with an operator block in curly braces.  The main section must be in the utility exactly in one instance at the end of the package.  This is an analogue of the main function in the C language.  Operators of this block are executed when the utility is started. <br><br>  In the block there are three operators.  The first statement is a description of the three variables p, q, r, the first two being initialized by constant expressions.  Variable types are specified as a package name, followed by a type name defined in this package after a period. <br><br>  The second statement is a call to the sum procedure from the mypkg package, given, like the types, by a dotted expression. <br><br>  The third operator is a debug print to the console. <br><br>  Such an elaborate programming for calculating the sum of two integer constants was done solely in order to demonstrate as much as possible the capabilities of the basic language with the minimum size of the text presented to the public. <br><br>  A more complex example demonstrates how to work with a document type. <br><br>  File docexample.gen: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs">project docexample /version=<span class="hljs-string"><span class="hljs-string">"01.001"</span></span> package doc utility doctest</code> </pre><br></div></div><br>  Doc.package file: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs">package doc type t_orgname : char8[<span class="hljs-number"><span class="hljs-number">100</span></span>]; type t_addr : char8[<span class="hljs-number"><span class="hljs-number">100</span></span>]; type t_phone : char8[<span class="hljs-number"><span class="hljs-number">30</span></span>]; type t_empname : char8[<span class="hljs-number"><span class="hljs-number">100</span></span>]; type orgs : dqueue ( record org ( t_orgname orgname, t_addr addr, t_phone phone ); record emp ( t_empname empname1, t_empname empname2, t_empname empname3, t_addr addr, t_phone phone ); <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> orgs_org member org;/oper=(mem,next) <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> org_emp owner org member emp;/oper=(mem,next) ); <span class="hljs-function"><span class="hljs-function">procdecl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fill</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(orgs porgs)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">implementation procdecl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fill</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(orgs porgs)</span></span></span><span class="hljs-function"> </span></span>{ var <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iorg; rand.init(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( iorg := <span class="hljs-number"><span class="hljs-number">0</span></span>; iorg &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>; iorg += <span class="hljs-number"><span class="hljs-number">1</span></span> ) { var org xorg, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iemp; org_cre(porgs,xorg); rand_test.firm8(xorg.orgname); rand_test.addr8(<span class="hljs-literal"><span class="hljs-literal">false</span></span>,xorg.addr); rand_test.phone(xorg.phone); orgs_org_ins(porgs,xorg,<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( iemp := <span class="hljs-number"><span class="hljs-number">0</span></span>; iemp &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; iemp += <span class="hljs-number"><span class="hljs-number">1</span></span> ) { var emp xemp; emp_cre(xorg.xdoc,xemp); rand_test.name8(xemp.empname1,xemp.empname2,xemp.empname3); rand_test.addr8(<span class="hljs-literal"><span class="hljs-literal">true</span></span>,xemp.addr); rand_test.phone(xemp.phone); org_emp_ins(xorg,xemp,<span class="hljs-number"><span class="hljs-number">-1</span></span>); } } }</code> </pre><br></div></div><br>  File doctest.utility: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs">utility doctest:<span class="hljs-string"><span class="hljs-string">"doctest"</span></span> <span class="hljs-function"><span class="hljs-function">proc </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(doc.orgs porgs)</span></span></span><span class="hljs-function"> </span></span>{ call doc.fill(porgs); { var doc.org xorg; doc.orgs_org_mem(porgs,<span class="hljs-number"><span class="hljs-number">0</span></span>,xorg); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( isnotnull(xorg) ) { dprint(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); dprint(<span class="hljs-string"><span class="hljs-string">U": "</span></span>,xorg.orgname,<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); dprint(<span class="hljs-string"><span class="hljs-string">U": "</span></span>,xorg.addr,<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); dprint(<span class="hljs-string"><span class="hljs-string">U": "</span></span>,xorg.phone,<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); var doc.emp xemp; doc.org_emp_mem(xorg,<span class="hljs-number"><span class="hljs-number">0</span></span>,xemp); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( isnotnull(xemp) ) { dprint(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); dprint(<span class="hljs-string"><span class="hljs-string">U" : "</span></span>,xemp.empname1,<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); dprint(<span class="hljs-string"><span class="hljs-string">U" : "</span></span>,xemp.empname2,<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); dprint(<span class="hljs-string"><span class="hljs-string">U" : "</span></span>,xemp.empname3,<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); dprint(<span class="hljs-string"><span class="hljs-string">U" : "</span></span>,xemp.addr,<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); dprint(<span class="hljs-string"><span class="hljs-string">U" : "</span></span>,xemp.phone,<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); doc.org_emp_next(xemp); } doc.orgs_org_next(xorg); } } } main { varobj doc.orgs porgs; <span class="hljs-function"><span class="hljs-function">call </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(porgs)</span></span></span></span>; }</code> </pre><br></div></div><br>  In the docexample project, there are two packages - doc.package and doctest.utility. <br><br>  The doc package describes the character types t_orgname, t_addr, t_phone, t_empname in UTF-8 encoding with the specified lengths. <br><br>  The orgs type is a document (dqueue keyword).  It describes two types of org and emp entries - organization and employee.  In brackets the listed components of records of the specified types.  In essence, this is similar to the description of a database with two tables and specified columns in them. <br><br>  The network structure is defined by the relationship between one-to-many records.  Such links are entered as sets.  So, the set org_emp introduces a connection between an organization and an employee, many employees can work in an organization, but each employee works in no more than one organization.  The keyword owner (set owner) sets the type of record owner of the set.  The member keyword sets the type of the member of the set. <br><br>  A set without an owner (in our case, orgs_org) is called singular, it exists in a single copy in the document (it is conditionally owned by the entire document / database). <br><br>  The document type declaration automatically declares the record types of such a document with the same name as the record names.  At the same time, one should remember about the uniqueness of type names within a package. <br><br>  In addition, procedures for manipulating these objects are automatically generated and available for each record and for each set. <br><br>  So, for the org record, the org_cre procedure is created with two parameters: a link to the document, an output variable of the record type to get a link to the created record instance. <br><br>  For the org_emp set, a org_emp_ins procedure is created with three parameters: a reference to the org instance ‚Äî the record owner of the set, a reference to the emp type instance ‚Äî the member record of the set, an integer ‚Äî the position in the set (negative numbers ‚Äî numbering from the end of the set). <br><br>  For the org_emp set, a org_emp_mem procedure is also created with three parameters: a reference to an instance of the org type ‚Äî the record owner of the set; an integer number ‚Äî the position in the set; an output parameter ‚Äîa reference to an instance of the emp type ‚Äî the member record of the set. <br><br>  For the set org_emp, a procedure org_emp_next is created with one parameter of type emp (input and output) to move to the next element of the set. <br><br>  The multifunctional expressions isnull (...) and isnotnull (...) apply to document type variables. <br><br>  In this project, the rand and rand_test system packages are used to generate random test data. <br><br>  To demonstrate the possibilities of parsing, consider another example of the project. <br><br>  File calc.gen: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs">project calc /version=<span class="hljs-string"><span class="hljs-string">"01.001"</span></span> utility calc</code> </pre><br></div></div><br>  File calc.utility: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs">utility calc:<span class="hljs-string"><span class="hljs-string">"Calculator"</span></span> type t_double : <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>; /frac=<span class="hljs-number"><span class="hljs-number">6</span></span> procspec syn_add(string7 buf,tlex.t_lex xlex,out t_double dval); <span class="hljs-function"><span class="hljs-function">proc </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">syn_fact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string7 buf,tlex.t_lex xlex,out t_double dval)</span></span></span><span class="hljs-function"> </span></span>{ dval := <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( tlex.sample(buf,xlex,<span class="hljs-string"><span class="hljs-string">"("</span></span>) ) { <span class="hljs-function"><span class="hljs-function">call </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">syn_add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buf,xlex,dval)</span></span></span></span>; tlex.sample_err(buf,xlex,<span class="hljs-string"><span class="hljs-string">")"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( tlex.<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>(buf,xlex,NOSIGN,NOFRAC,NOEXPON,dval) ) ; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> tlex.message(buf,xlex,<span class="hljs-string"><span class="hljs-string">"syntax error"</span></span>); } <span class="hljs-function"><span class="hljs-function">proc </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">syn_mul</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string7 buf,tlex.t_lex xlex,out t_double dval)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">call </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">syn_fact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buf,xlex,dval)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ; ; ) { var t_double dval1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( tlex.sample(buf,xlex,<span class="hljs-string"><span class="hljs-string">"*"</span></span>) ) { <span class="hljs-function"><span class="hljs-function">call </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">syn_fact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buf,xlex,dval1)</span></span></span></span>; dval *= dval1; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( tlex.sample(buf,xlex,<span class="hljs-string"><span class="hljs-string">"/"</span></span>) ) { call syn_fact(buf,xlex,dval1); dval /= dval1; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-function"><span class="hljs-function">proc </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">syn_add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string7 buf,tlex.t_lex xlex,out t_double dval)</span></span></span><span class="hljs-function"> </span></span>{ var <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> minus; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( tlex.sample(buf,xlex,<span class="hljs-string"><span class="hljs-string">"+"</span></span>) ) ; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( tlex.sample(buf,xlex,<span class="hljs-string"><span class="hljs-string">"-"</span></span>) ) minus := <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-function"><span class="hljs-function">call </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">syn_mul</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buf,xlex,dval)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( minus ) dval := -dval; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ; ; ) { var t_double dval1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( tlex.sample(buf,xlex,<span class="hljs-string"><span class="hljs-string">"+"</span></span>) ) { <span class="hljs-function"><span class="hljs-function">call </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">syn_mul</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buf,xlex,dval1)</span></span></span></span>; dval += dval1; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( tlex.sample(buf,xlex,<span class="hljs-string"><span class="hljs-string">"-"</span></span>) ) { call syn_mul(buf,xlex,dval1); dval -= dval1; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-function"><span class="hljs-function">proc </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">syn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string7 buf,tlex.t_lex xlex,out t_double dval)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">call </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">syn_add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buf,xlex,dval)</span></span></span></span>; tlex.eof_err(buf,xlex); } main { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( utl.argc(xutl.yutl) &lt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span> ) error <span class="hljs-string"><span class="hljs-string">U"  "</span></span>; var tlex.t_lex xlex, t_double dval; <span class="hljs-function"><span class="hljs-function">call </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">syn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(utl.argv7(xutl.yutl,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">),xlex,dval)</span></span></span></span>; dprint(<span class="hljs-string"><span class="hljs-string">"result="</span></span>,dval,<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); }</code> </pre><br></div></div><br>  The development of a calculator utility is demonstrated, to which the expression is input, the output is the calculated value of the expression. <br><br>  Using the system package tlex parse allows you to solve the problem of parsing the expression is very simple and the minimum amount of code, using the extensive built-in features of this package.  In this example, you can see how easily and compactly it is possible to solve problems of syntactic analysis. <br><br>  The project involved a system package tlex - lexical parsing in a line.  The syntactic parsing is performed by the method of recursive descent.  Each non-terminal grammar symbol corresponds to a procedure in the parsing program. <br><br>  The grammar should be brought to such a form that, by the results of finding out which terminal symbol is located in the reading position, it was possible to decide what rule of grammar to apply for parsing.  Bringing to this form for most existing languages ‚Äã‚Äãis not difficult.  To do this, it suffices to define a suply language, which allows incorrect texts from the point of view of the original grammar.  Further, on the basis of the constructed parse tree (in one form or another), you can verify the correctness. <br><br>  In fact, this is always done in real translators, since real programs are not described by context-free grammars.  KS grammar can hardly describe a language in which the use of various objects (types, procedures, variables) is prohibited without their description.  So these kinds of checks are done anyway. <br><br>  In our case, parsing is performed in the calc utility for the input parameter string of a program call in the console.  If exactly one parameter is not specified, an error message is displayed.  If the parameter is set, then it is parsed with the calculation of the result.  Upon successful analysis, the result of the calculation is printed in the console.  In case of an error, a diagnostic message is displayed with information on which position of the text an error was detected. <br><br>  Grammar in words.  An additive expression is a sequence of multiplicative expressions separated by the signs of operations + or -.  A multiplicative expression is a sequence of multipliers separated by signs of operations * or /.  The multiplier is an additive expression in parentheses or a number. <br><br>  The additive expression corresponds to the syn_add procedure, the multiplicative expression is syn_mul, and the multiplier is syn_fact. <br><br>  Parameters of syntax procedures: buf - the analyzed text, xlex - the context of lexical analysis (including the reading position), dval - the output parameter - the calculated value. <br><br>  Used lexical procedures of the tlex package. <br><br>  Function tlex.sample - checks in the current position the presence of the sample presented in the parameter.  If the pattern starts with a letter, then the recognized text should completely coincide with the pattern, and not contain the pattern as a substring.  Those.  if we check the presence of a sample proc, then the text procdecl in the reading position will not give an affirmative result.  When recognizing any lexeme, all space characters, line breaks, tabs, etc. are skipped. C and C ++ style comments are also skipped. <br><br>  Tlex.sample_err procedure - checks the tlex.sample procedure for the presence of a sample; if absent, it triggers a fatal error with the message text containing information about the reading position of the analyzed line. <br><br>  Such function / procedure pairs are present in the tlex package for many kinds of tokens.  The function allows you to check for the presence of a token, the procedure checks and fails to trigger an error. <br><br>  Procedure tlex.double - checks in the current position the presence of a decimal number in the form 123.456.  The NOSIGN parameter prohibits the + - sign at the vocabulary level; we recognize these signs at the grammar level.  The NOFRAC parameter allows numbers with or without a decimal point. <br><br><h3>  Subtotals </h3><br>  The previous section provides examples of projects that demonstrate some of the capabilities of the base language.  Note that this is not a reference book, not a language manual, or even a set of examples for learning.  This is just an introductory text. <br><br>  If the reader has reached this place, he has a quite logical question: what is in this basic language what is not in other languages, and why did it take time and effort to implement it? <br><br>  First, the base language is part of a complete generating language for project description.  In the generator language there are many different constructs for describing such model entities as a database, sql query, server, server port, application, application screen layout, dialog, configuration file, json conversion for arbitrary data types, abstract set of related tables for mappings in different environments (dom-model, gtk, qt), etc. This list is constantly updated, outdated entities die, new ones appear.  And all these constructions are implemented mainly in the base language.  In the early stages of the development of the generator, model structures were implemented directly in C.  The use of a base language facilitated the integration of models and language. <br><br>  Secondly, the generator is intended (and only then gives significant advantages) for the implementation of large projects, when the amount of program code is measured in hundreds of thousands of lines.  The work of volume projects is fundamentally different from the development of small programs of up to several thousand lines.  In a small program, the developer can keep in mind all the information about its structure.  In a large program this is not possible.  In the process of modifying such programs, redundant unused code inevitably increases.  To counteract this process, numerous means and code checks are being undertaken in the generator. <br><br>  In the procedure headers, formal parameters are specified as input, input and output, only output.  During the translation of the procedure body, this specification is checked for correctness.  For example, if a certain parameter is declared a holiday, and in the body of the procedure there is a path in the operator tree in which the variable is used for reading earlier than the value is assigned to it, then this situation leads to an error diagnosis.  It uses information on the inputs and outputs of other procedures called in this procedure.  If a variable has a structure type, then such an analysis is carried out for each of its components at any level. <br><br>  For structured documents, you can order a complete set of all operations envisaged for all its records and sets.  This will result in significant redundancy code.  It is possible (and necessary) to explicitly specify a list of all the required operations for each record and set.  In this case, operations that were not used in the project will be identified, and appropriate diagnostics will be issued.  Moreover, if, for example, the operation of creating a record is not used, then this is also interpreted as an error.  Or for a set there is an operation of inclusion in the set and no more are used, then an error is also generated. <br><br>  At the time of this writing, there was just the process of deleting some obsolete entities in the project model (old servers and applications are being replaced with new ones).  In the document representing the project model in the generator code at the time of the simultaneous existence of old and new objects there were about 250 record types and more than 800 set types.  After deleting old entities, the number of records decreased to 190, sets to 580. It is clear that it is extremely difficult to track the usage of so many objects and operations with them manually. <br><br>  As an illustration, we present data on one real, but already completed, project in the field of financial activity.  The project on the generator contained 1294 files with a total of 203,829 lines.  In the resulting C program code, there were 4,605 ‚Äã‚Äãfiles with 260,8,812 lines.  There are 23 different types of servers in the project, 29 ports through which they receive requests, 11 applications, 27 utilities (console programs), and this is only in one, but the largest project within the whole system.  As part of this system, there were 7 projects combined by means of export and import of individual packages.  The division of the system into 7 different generating projects was done to reduce their volume.  Managing such an economy without paranoid integrity checks is very problematic. <br><br><h3>  Current situation </h3><br>  The project generator during the whole period of work on it developed as an internal project in the development team.  In the process of working on applied projects, our customers in some cases had the opportunity to use the generator for their own development, one way or another connected with our project (or maybe not only, it is difficult to control).  As work on the projects clarified the formulation of the problem, new tool needs arose that were implemented in the next versions of the generator.  As it was said at the beginning, it was a two-dimensional development, applied and instrumental.  Those.  the generator developed along with the next (s) project.  Periodically, there was talk about making the generator itself a software product for the general public.  This text is in a sense an attempt to present our system to this very public. <br><br>  Currently, the generator has tools for working with database management systems Oracle, Postgres, MySql, MS Sql, Sqlite of different versions.  Working with databases involves describing the database schema using generator tools, writing sql queries in a special language (using a representative enough subset of sql) with full syntactic and semantic control of the query text to the database schema.  There are tools for specifying alternatives for different types of databases.  And you can write the so-called dynamic queries that will be transferred to the database without control. <br><br>  Servers are transferred to modern network tools - Epoll on Unix and I / O Completion on MS Windows. <br><br>  Until recently, applications were developed using a single interface model (the so-called window layouts), which had two implementations - Microsoft WIN32 GUI and GTK-3 for Unix.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintaining one model for these two systems has become increasingly difficult due to insufficiently developed tools in the WIN32 GUI. Therefore, two different approaches are being developed now - GTK-3 and Qt-5. Models are different, but very similar. It is not yet decided to separate them, or try to combine them with individual exceptions in different implementations. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The export of Java Script packages for use in WEB-development is actively developing. In the browser, you can receive data from the server in json-format and use the functions generated for Java Script with the types described in the project, for example, with a structured document.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For WEB-development, a fairly representative subset of the HTML language is implemented with inserts in the base language (similar to PHP). </font><font style="vertical-align: inherit;">At the same time, HTML markup is controlled for correct nesting of tags. </font><font style="vertical-align: inherit;">And, of course, inserts in the base language are subject to total control, as is customary throughout the generator. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Package export to Java language implemented mainly for developing components of systems on mobile platforms (Android).</font></font></div><p>Source: <a href="https://habr.com/ru/post/326564/">https://habr.com/ru/post/326564/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326546/index.html">How to make the most? Five key points of an effective site</a></li>
<li><a href="../326550/index.html">How we made a completely new KOMPAS-3D: History in seven chapters ‚Üí part 1</a></li>
<li><a href="../326552/index.html">An article about static code analysis for managers that should not be read by programmers.</a></li>
<li><a href="../326554/index.html">Security Week 15: Leaky Modem in Huawei, VirusTotal as a data breach channel, Microsoft patches from Dridex</a></li>
<li><a href="../326556/index.html">Schr√∂dinger's trusted download. Intel Boot Guard</a></li>
<li><a href="../326566/index.html">Interesting prioritization of voice traffic in Telegram</a></li>
<li><a href="../326568/index.html">Autonumber in four languages. Part 1</a></li>
<li><a href="../326570/index.html">How to talk with artificial intelligence?</a></li>
<li><a href="../326572/index.html">Creating a single-player game: from idea to prototype</a></li>
<li><a href="../326574/index.html">TCP / IP basics for future dilettantes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>