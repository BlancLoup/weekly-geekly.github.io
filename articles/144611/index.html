<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Three key software principles you need to understand</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When developing applications, we are constantly confronted with new approaches, languages ‚Äã‚Äãand concepts. And constantly we rush about doubts ‚Äúcan I b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Three key software principles you need to understand</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/storage2/7d9/d0a/192/7d9d0a192abbefb794688aaade4df316.png"><br>  When developing applications, we are constantly confronted with new approaches, languages ‚Äã‚Äãand concepts.  And constantly we rush about doubts ‚Äúcan I be on the wave, remain competitive, considering all the changes and trends?‚Äù.  Let's think for a moment, remembering the phrase from my favorite film ‚ÄúCasablanca‚Äù - there are no new laws in love - that's how the light was created. <br><br>  Everything related to love applies to the code.  There are no new laws in the code.  If you clearly understand the basic ideas of development, you are able to quickly adapt to new approaches.  In this article I will tell you about three basic principles that, along with others, allow you to adjust the complexity of development.  I will share my vision of the question, which I hope will help you in your daily work. <br><a name="habracut"></a><br><h4>  DRY - Do not repeat yourself (do not repeat yourself) </h4><br>  This principle is so important that it does not require repetition!  It is usually referred to by the acronym DRY, which first appeared in the infamous book <a href="http://www.amazon.com/gp/product/020161622X/ref%3Das_li_ss_tl%3Fie%3DUTF8%26tag%3Dnett02-20%26linkCode%3Das2%26camp%3D1789%26creative%3D390957%26creativeASIN%3D020161622X">The Pragmatic Programmer</a> , but the concept itself was known for a long time.  It belongs to the smallest parts of your software. <br><br>  When you develop a large project, you often have to deal with redundant overall implementation complexity.  People do poorly in managing complex systems, they are better able to find unusual solutions to certain problems.  The easiest solution to reduce complexity is to divide the system into smaller, independent modules that are easier to manage. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage2/aae/b95/f50/aaeb95f5004c75ec4f73bdd87aebb1fe.png" align="left"><h5>  <i>The simplest approach to reducing complexity is to divide the system into manageable parts.</i> <img src="https://habrastorage.org/storage2/733/369/d57/733369d5745308bfbfeb9d8e23a925e5.png" align="right"></h5><br>  For example, a part of any CMS is the component responsible for managing users.  This component can be divided into other components, for example, the management of access levels that can work with other components of the security system. <br><br>  In this way, by dividing the system into components deeper and deeper, you will reach the moment when each part of the system will be responsible for clearly defined actions.  Such actions can be organized into classes.  Classes will contain methods and properties.  Methods represent algorithms that build the business logic of your system. <br><br><img src="https://habrastorage.org/storage2/aae/b95/f50/aaeb95f5004c75ec4f73bdd87aebb1fe.png" align="left"><h5>  <i>The principle of DRY requires that such pieces of information be met only once in your code.</i> <img src="https://habrastorage.org/storage2/733/369/d57/733369d5745308bfbfeb9d8e23a925e5.png" align="right"></h5><br><br>  These parts should have one presentation. <br><br>  Note the difference between the information (data) and its presentation.  When we organize a connection to the database in our CMS, we will have a code that will raise the required driver, accept authorization, and store the pointer to the connection in a variable.  Here, the code is information describing how we get something (connection).  A variable with a connection pointer is a representation of this information that can be used anywhere in the system.  If suddenly we change the authorization, we will need to change only the ‚Äúdata‚Äù, but not their presentation. <br><br><img src="https://habrastorage.org/storage2/aae/b95/f50/aaeb95f5004c75ec4f73bdd87aebb1fe.png" align="left"><h5>  <i>Each piece of data must have a clear, reliable representation in the system.</i> <img src="https://habrastorage.org/storage2/733/369/d57/733369d5745308bfbfeb9d8e23a925e5.png" align="right"></h5><br>  In an ideal system, each part of the business logic encapsulates its data into a view ‚Äî a variable or a class property.  This variable is encapsulated in a class responsible for part of the architecture.  A class is a part of a component that is an implementation of a part of the system functional. <br><br>  Thus, we can get to the top of the system - a complex set of functional implementations.  This approach of the organization is called a modular architecture, and, in turn, DRY, is an important part of it. <br><br><img src="https://habrastorage.org/storage2/3cf/f05/c1a/3cff05c1a636fc6b83768953bd25f24f.png"><br><h6>  The task of the architecture is to manage complexity. </h6><br><br><h5>  Stop repeating </h5><br>  There are quite a few ways to eliminate repetition.  Hunt and Thomas offer code generators and data transformations.  But DRY, as a result, is the philosophy of issuing logic through representations. <br>  Each part of your application can be a view, each part provides a certain logic - the authorization control module gives access to your users, the user class contains information about the current user with a set of its properties.  This class, in turn, receives data through the database view. <br><br><img src="https://habrastorage.org/storage2/aae/b95/f50/aaeb95f5004c75ec4f73bdd87aebb1fe.png" align="left"><h5>  <i>DRY is a philosophy that breaks the logic into representations.</i> <img src="https://habrastorage.org/storage2/733/369/d57/733369d5745308bfbfeb9d8e23a925e5.png" align="right"></h5><br>  DRY and modular architecture require good planning.  For the proper organization of the hierarchy of views, divide your system into small parts that can work together.  If you are to manage a large project, you should consider the idea of ‚Äã‚Äãorganizing it with components using DRY.  Try to follow these rules: <br><br><ul><li>  Make a graphical diagram of your system, divide it into visual components.  Complex projects may require such hierarchies for each component. </li><li>  If you are merging into an adjacent level of implementations (part of a common system), you can try using UML diagrams (or similar ones) </li><li>  Before writing code mark it in your graphic scheme, determine its role among other components of the system. </li><li>  Clearly define the views that your code will issue to other parts of the system, and which it must hide (private / public). </li><li>  Make sure your code is loosely coupled to other system views ‚Äî hard links have a very bad effect on the overall architecture. </li></ul><br>  The database driver is a slightly lightened example, since it can contain many other levels of logic in real projects, and it has many more areas that can be divided into smaller components, especially with regard to modern design patterns.  But even if you have only broken the implementation, do not forget about the important thing: <br><br><img src="https://habrastorage.org/storage2/aae/b95/f50/aaeb95f5004c75ec4f73bdd87aebb1fe.png" align="left"><h5>  <i>If suddenly you catch yourself on the fact that you have already written / met this code before, stop, think, and do not repeat yourself.</i> <img src="https://habrastorage.org/storage2/733/369/d57/733369d5745308bfbfeb9d8e23a925e5.png" align="right"></h5><br>  In real projects to achieve 100% DRY is almost impossible.  But, in turn, there are quite a lot of projects that are not-DRY at an unacceptable level and which are difficult to manage.  And perhaps it will be a surprise for you - 50% of all our projects fail, if you look at their code. <br><br>  Many people tend to think that bad programmers write bad code.  My experience says that it is rather an exception.  A little more often than always bad code is written by accountants.  And yet, incorrectly set process management in companies, too, produces bad code. <br><br><h5>  Example </h5><br>  As an example, let's imagine that you were invited by a technical consultant to a company that has problems with the quality of the code and its management.  You looked through the code and found out that there are a lot of hacks in it, and the code is not DRY.  This is the first symptom of a bad code, but it is not its cause.  You look at the history of komitov, you most likely find that these hacks are used in the later stages of the project - deadlines, milestones.  After analyzing the story, you understand that some changes in the requirements caused these same hacks. <br><br><img src="https://habrastorage.org/storage2/aae/b95/f50/aaeb95f5004c75ec4f73bdd87aebb1fe.png" align="left"><h5>  <i>Rarely bad code is written by bad programmers.</i> <img src="https://habrastorage.org/storage2/733/369/d57/733369d5745308bfbfeb9d8e23a925e5.png" align="right"></h5><br>  We remember that repeatability is eliminated by good planning.  Urgent changes in the system entail urgent, non-optimal solutions in the code.  As soon as the code undergoes bad decisions, the whole DRY principle for this solution stops working, until future changes. <br><br>  If you look at the history of the most successful IT companies, many of them were created by people with an understanding of the problem - Bill Gates, Mark Zuckerberg, Steve Wozniak, Steve Jobs, Larry Page, Sergey Brin, Larry Ellison - these people knew that they had to overcome for solutions of a particular problem.  But there are companies that transfer system management into the hands of accountants, and conceptual management into the hands of consultants.  Neither can control these areas. <br><br><img src="https://habrastorage.org/storage2/aae/b95/f50/aaeb95f5004c75ec4f73bdd87aebb1fe.png" align="left"><h5>  <i>DRY is achieved by joint planning.</i> <img src="https://habrastorage.org/storage2/733/369/d57/733369d5745308bfbfeb9d8e23a925e5.png" align="right"></h5><br>  That is why many solutions work only in Powerpoint, Photoshop, and 27 ‚Äùscreens.  It kind of worked in more or less static sites.  But not today, in a world where a bunch of different interactive applications and devices. <br><br>  And programmers who are the last in the chain are required to promptly correct errors in the system.  If they are seasoned with accountants who are unable to resist the customer's every minute whims, all planning goes to hell and bad, very bad code is written.  The code is no longer DRY. <br><br>  This example is a bit pessimistic (although I often come across it), but it clearly shows that DRY is a concept that depends on many people.  If suddenly you work in a company that is just as start-up, I advise you to suggest changes in the processes (for example, technical evaluation in the early stages of projects). <br><br>  If you are asked not to stick your nose where you do not need, read on - the principle of YAGNI will save you! <br><br><h4>  KISS - keep it simple stupid (make things easier) </h4><br>  At the end of the 19th century, physicists were trying to find an explanation of how gravity, magnetic fields, and optics work at large distances ‚Äî distances within our solar system.  A theory was derived about the existence of a certain ether that acts on all those forces, and it cannot be explained.  Later this theory was expanded by some experiments, but none of them explained the problem. <br><br><img src="https://habrastorage.org/storage2/aae/b95/f50/aaeb95f5004c75ec4f73bdd87aebb1fe.png" align="left"><h5>  <i>Often the simplest explanation is the right solution.</i> <img src="https://habrastorage.org/storage2/733/369/d57/733369d5745308bfbfeb9d8e23a925e5.png" align="right"></h5><br>  A little later, Albert Einstein, an employee of the Swiss Patent Office, suggested to abandon this theory, neglect all distance calculations, and simply assume that time is not a constant ‚Äî it is relative.  Such a solution to the problem with the minimum number of dependencies is explained by the principle of "Occam's razor". <br><br>  And similar concepts are found in many areas.  In software development (and some others) we call it KISS.  This acronym has many meanings, but they all boil down to one thing - you should try to make things as simple as possible. <br><br><img src="https://habrastorage.org/storage2/366/5d5/b4f/3665d5b4f53b92b72c6f1dd3083d9902.jpg"><br><h6>  <i>Most of the progress in the history of mankind was achieved thanks to extraordinary thinkers.</i> </h6><br><br><h5>  HTTP </h5><br>  The HTTP protocol is often cited as an example of an ideal, simple solution - originally created for the transfer of hypertext documents, today it is the basis for many interactive applications.  It is possible that sometimes we have to look for workarounds for the problems associated with the limitations of this protocol, and maybe in the future it will be replaced by another protocol.  But today the fact remains: based on several methods of requests (GET / POST), status codes and simple text arguments, HTTP is quite flexible and reliable.  That is why web developers are trying to squeeze the maximum out of it, and that is why this protocol is still in service. <br><br>  The approach to making things easier is pretty obvious, but the history of software development is full of various bad, raw solutions.  They are often called a separate word - bloatware, or DOA (dead on arrival) - dead at birth.  Relative to such software, you can apply a theory similar to the theory of non-DRY code ... However, the success of the Internet can be explained by simple, effective solutions. <br><br>  So how to achieve the highest possible, simple solution?  It all comes down to the possibility of support, and detail in software development.  That is why KISS should be applied at the requirements definition stage.  Trying to implement customer requirements in your code, try to highlight the following: <br><br><ul><li>  A functional that has an inappropriate relationship between costs and profit. </li><li>  Functional, which is strictly dependent on another. </li><li>  Functionality, which, with a high probability, tends to grow, and become more difficult. </li></ul><br>  Somehow I took part in a project where a client wanted to import Excel spreadsheets into his personnel management program.  Good example.  Excel is a proprietary application with a complex format.  The format of the documents is complicated, because  It implements a rich functionality - for example, you can add graphs and other chips that, in fact, were not needed by the client.  He needed just numbers from the table.  Thus, introducing imports from Excel, would have to spend a lot of time on unnecessary functionality.  In addition, there are several versions of Excel, which every year more and more.  Those.  all this would be difficult to manage, and there were risks of additional costs in the future. <br><br>  And we decided to implement import from CSV format.  The solution took a few lines of code, was not overloaded with data (if you compare CSV and Excel formats), it was easy to manage and maintain.  Excel can easily export data in CSV format (like many other programs that the client could use in the future).  And, given the minimum cost of implementing this requirement, this solution is an excellent example of KISS. <br><br>  Moral - try to consider things from the simple side if they look complicated.  If a client tells you his requirements, the implementation of which seems difficult to you, you are right in any case.  Even considering that some things are really difficult to implement, we often face solutions that are overloaded unreasonably.  This happens because  The development process involves some people who do not have the technical experience to correctly calculate the cost / benefit.  And they just do not see the whole problem.  Therefore, always double check customer requirements and make sure that this is exactly what they need.  Discuss critical moments, explain to him why other solutions might be better suited. <br><br><h4>  You ain't gonna need it - you won't need it. </h4><br>  When Google launched Google+, Mark Zuckerberg, the founder of Facebook, was one of the first registered in the social network, which was designed to surpass its network.  He wrote just one line in the ‚ÄúAbout Me‚Äù section - ‚ÄúI build things‚Äù.  Personally, I think this is a brilliant proposal, revealing the whole essence of programming.  Why did you choose the coder path?  Enthusiasm in technical solutions?  The beauty of efficiency?  So that you do not answer, most likely it will not be ‚Äúto build a 100,500th corporate website with standard functionality.‚Äù  And yet, many of us earn precisely this.  Wherever you work, you occasionally have to deal with boring, routine tasks. <br><br><img src="https://habrastorage.org/storage2/aae/b95/f50/aaeb95f5004c75ec4f73bdd87aebb1fe.png" align="left"><h5>  <i>I am programming.</i>  <i>I build things.</i> <img src="https://habrastorage.org/storage2/733/369/d57/733369d5745308bfbfeb9d8e23a925e5.png" align="right"></h5><br>  The principle ‚ÄúYou will not need this‚Äù (YAGNI - you ain't gonna need it) is just meant to solve such problems. <br><br>  This means that what is not conceived in the system should not appear in the code.  For example, quite often access to the database is carried out through abstraction, which can be implemented for different drivers - MySQL, PostgreSQL, Oracle.  If you are working on a site that is hosted on a LAMP stack - what is the likelihood that a client will change the database?  Do not forget that the concept is always written under the budget - right? <br><br>  If the budget does not provide an abstraction for the database - this abstraction should not be in the system.  If suddenly the client needs to move to another database, it is quite obvious that this will entail the costs of changing the system. <br><br>  You must have noticed the difference between YAGNI and DRY systems.  The latter is designed to reduce complexity by dividing the system into manageable components, while the former reduces complexity by reducing the number of these components.  The principle of YAGNI is similar to KISS - it tries to make things as simple as possible.  But KISS is trying to find simple solutions, and YAGNI simply does not make any decisions! <br><br>  Theodore Sturgeon, American science fiction, put forward the <a href="http://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25BA%25D0%25BE%25D0%25BD_%25D0%25A1%25D1%2582%25D0%25B0%25D1%2580%25D0%25B4%25D0%25B6%25D0%25BE%25D0%25BD%25D0%25B0">law</a> - "90% of everything is complete nonsense."  Quite a radical statement, and not always applicable in real projects.  Do not forget that "nonsense" can take a lot of time.  There is an unspoken rule: approximately 80% of the time spent on development is spent on implementing only 20% of the system's functionality.  Remember your projects.  Every time I review my own, I am constantly convinced how the 80/20 rule works. <br><img src="https://habrastorage.org/storage2/fb1/0f4/8c6/fb10f48c621109f326570f511ea8e027.png"><br><h6>  <i>80% of the time spent on development is spent on the implementation of only 20% of the functionality of the system.</i> </h6><br>  This strategy is very well applicable in a company where it is customary to keep deadlines mixed with not very clear concepts.  No one will appreciate your database abstraction.  There is even a chance that your boss has no idea what an abstraction database is. <br><br>  Nevertheless, even if this approach may seem rather simple, it is often not so easy to separate the necessary parts from the unnecessary parts.  For example, even if you have implemented an abstraction, it will not give you any gain when dumping the database.  The key point is how we look at the software - we were taught to write code that is easy to maintain and will be profitable in the future.  Those.  we were taught to look ahead, considering all possible changes.  Sometimes it is critical for large projects, but not for small ones.  Stop thinking about the future!  If suddenly a small site requires radical changes, it would be better to start from scratch.  And this is not such a problem, given the overall investment. <br><br><h4>  Project planning </h4><br>  Starting planning a new project, try to consider the following: <br><br><ul><li>  To achieve less complexity by reducing the level of abstractions </li><li>  Separate functionality from features </li><li>  Consider small non-functional requirements. </li><li>  Identify time-consuming tasks to get rid of them. </li></ul><br>  Let's break it down.  On the first point, I already gave an example - you should not implement an abstraction to the database driver.  Try to carefully evaluate everything that can add complexity to your system.  Note that often many abstractions are implemented in third-party products and libraries.  For example, depending on what language you write, Hibernate (Java), Doctrine (PHP) or Active Record (Ruby) all come with a level of abstraction around the database, and ORM.  Each of these libraries adds complexity.  And she will have to manage.  Updates, patches, security fixes - all you have to do / apply in the future. <br><br>  Every day we introduce new features that we think will be useful.  Consequently, we think ahead and realize too much.  For example, many customers want to have mobile versions of their sites.  Mobility can be represented by many values, it is not necessarily a design decision.  This is a usage scenario!  People who use mobile sites are mobile.  This means that they may need other information or functionality than those who use the desktop version.  Imagine the cinema site - users on the way to the cinema, on the bus, will most likely want to see the start time of the session, rather than a 50-meter trailer. <br><br>  With an adequate budget, you will try to make a separate analysis of the requirements for the mobile version.  Without such an analysis, you simply give out the same information as for the desktop.  And this may be enough for many projects.  Because today, many mobile browsers are able to properly configure the look of the site, and here you can apply the radical approach of YAGNI - do not make a mobile version at all! <br><br><img src="https://habrastorage.org/storage2/aae/b95/f50/aaeb95f5004c75ec4f73bdd87aebb1fe.png" align="left"><h5>  <i>Bad concepts can often be identified by the absence of non-functional requirements.</i> <img src="https://habrastorage.org/storage2/733/369/d57/733369d5745308bfbfeb9d8e23a925e5.png" align="right"></h5><br>  Non-functional requirements do not describe the behavior of the system, they describe additional properties by which you can evaluate the quality of the product.  Because  quality description implies product knowledge, bad concepts can often be identified by the absence of non-functional requirements.  The ability to support, the level of documentation, the ease of integration are all examples of non-functional requirements.  These requirements must be measurable.  Those.  ‚ÄúThe site should load quickly‚Äù - too generalized, but ‚ÄúThe site should load in 2 seconds during the performance test‚Äù - very concretely and clearly.  If you want to apply the YAGNI approach, try to take into account some non-functional requirements, even if they are not included in the concept (or taken into account, but not very clear).  When you write such a requirement, be realistic - a small site, with 20-50 visits per day, does not require a three-day performance tuning, because  the site will load quickly and so, if the server is not overloaded.  Even if the company will be able to increase its attendance, buy a more powerful hosting should not be a problem. <br><br>  And finally, always remember the 80/20 rule.  Try to identify time-consuming tasks.  If such a task is mandatory for implementation, it will have to be done.  The question will be just how to do it.  Do we need another framework with a small community?  Will you have to upgrade to the just-released version of the library if its documentation is still not updated?  Is there a need to use a new CMS, if not all extensions to it workable?  How deep analysis will have to spend to realize your task?  The ‚Äúalways have to do this‚Äù approach is not very exciting, but it will help you solve the problem without surprises. <br><br>  It is also important to understand that all this does not mean that you can sit down and write bad code flavored with hacks.  You just write a <b>small</b> application, not a <b>bad one</b> !  However, the ‚Äúyou don't need it‚Äù approach is quite practical.  If it helps to reduce several lines of code, I personally think that it is possible to bring this work into the budget, and a small non-DRY is quite acceptable.  Those.  one can agree not to slightly increased support costs - we live in the real world. <br><br>  Let's go back to our main idea - we build things.  Beethoven wrote ‚ÄúDiabelli Variations‚Äù on a contract.  I do not think that he was going to compromise on the budget.  He spent more time, but did not release bad music - he wanted to write the perfect one. <br><br>  Of course, I do not mean that we are all geniuses, and that our genius should appear in every line of code, but I like to think of software architecture as a composition.  I am a passionate developer, because I want to build perfect compositions, and I want to be proud of the things that I build. <br><br><img src="https://habrastorage.org/storage2/aae/b95/f50/aaeb95f5004c75ec4f73bdd87aebb1fe.png" align="left"><h5>  <i>If you want to be an experienced and sought-after developer, you need to hone your skills in principle YAGNI.</i>  <i>If you want to keep your passion, you have to constantly resist it.</i> <img src="https://habrastorage.org/storage2/733/369/d57/733369d5745308bfbfeb9d8e23a925e5.png" align="right"></h5><br><br><h4>  Conclusion </h4><br>  Software principles are points of view on this software.  For me, a good principle should be based on a simple concept that should evolve into a complex construction of ideas, colliding with other approaches and philosophies.  What are your favorite software guidelines? </div><p>Source: <a href="https://habr.com/ru/post/144611/">https://habr.com/ru/post/144611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../144604/index.html">Full length documentary on the demoscene: The Art Of The Algorithms</a></li>
<li><a href="../144605/index.html">SmartTripod - Robot Operator</a></li>
<li><a href="../144606/index.html">MetaWatch smart watches for gadget lovers</a></li>
<li><a href="../144607/index.html">Always there, or why I left Sberbank</a></li>
<li><a href="../144609/index.html">Impact analysis</a></li>
<li><a href="../144612/index.html">How does InstaCRT application work?</a></li>
<li><a href="../144613/index.html">Department of database logic, as well as the display of generalized methods</a></li>
<li><a href="../144614/index.html">Things to remember when programming in Python</a></li>
<li><a href="../144615/index.html">Do you work for the profession that you received in higher education? institution, etc.?</a></li>
<li><a href="../144616/index.html">PT-3 phonograph: review, characteristics and demonstration of work. Year of release - 1935</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>