<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Easy ‚ÄúFrontend‚Äù on Golang for manual testing of Ethereum smart contract without JavaScript and Web3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 


 I had an idea to develop, I hope, a simple solution for manual testing of smart contracts Ethereum. It became interesting to do something s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Easy ‚ÄúFrontend‚Äù on Golang for manual testing of Ethereum smart contract without JavaScript and Web3</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello! </p><br><p>  I had an idea to develop, I hope, a simple solution for manual testing of smart contracts Ethereum.  It became interesting to do something similar to the functionality of the Run tab in Remix. </p><a name="habracut"></a><br><h4 id="chto-umeet-prilozhenie">  What can the application: </h4><br><p>  It turned out to be a simple, yet backend, on Golang, which can: </p><br><ul><li>  generate static html pages on their endpoints and send them to the browser; </li><li>  take settings from toml config; </li><li>  connect to Ethereum node by RPC; </li><li>  turn into a simulator Ethereum; </li><li>  compile .sol files; </li><li>  expand contracts; </li><li>  write to the contract and read information from the contract; </li><li>  transfer ETH to any Ethereum address; </li><li>  receive information about Ethereum network, information from the last block; </li><li>  load for work several contracts from one directory, then you can choose with which specific contract you want to work; </li><li>  preserves unencrypted information in cookies; </li><li>  requests a private key once every 15 minutes and operations are performed on behalf of this user; </li><li>  show information about the current session: current address, current balance, selected sol file and contract in it; </li><li>  build a table of all contract methods; </li></ul><br><h4 id="teper-po-poryadku">  Now in order: </h4><br><p>  The choice fell on Golang due to the fact that I really liked the go- <a href="https://github.com/ethereum/go-ethereum">ethereum codebase</a> , on which <a href="https://github.com/ethereum/go-ethereum">Geth</a> is built. </p><br><p>  To generate static html, the standard Golang package "html / template" is used.  Here I will not paint anything, all templates can be found in the project templates package. <br>  To work with Ethereum, as I wrote above, I chose the go-ethereum version 1.7.3 code base. <br>  I really wanted to use the mobile package from go-ethereum, but mobile has not been updated for some time and is currently not working correctly with the current Abi format.  When processing data, you will receive a similar error: </p><br><pre><code class="go hljs">abi: cannot unmarshal *big.Int in to []<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> {}</code> </pre> <br><p>  The error has already been <a href="https://github.com/ethereum/go-ethereum/pull/15402">corrected</a> , but the fix has not yet been added to the main branch at the time I am writing this. </p><br><p>  I nevertheless chose another solution, flawless, since  The functions in the mobile package are in essence a convenient wrapper over the main functionality. </p><br><p>  In the end, I took the package to work with abi (+ some more packages that depend on abi) from go-ethereum to my project and added code from pull request. </p><br><p>  Since I needed to work with any smart contracts, the abigen utility, which can form a go package for working with a specific contract from a sol file, did not suit me. </p><br><p>  I created a structure, and the methods for which this structure is a receiver (if I'm not mistaken in the terminology of Golang): </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> EthWorker <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Container <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-comment"><span class="hljs-comment">//   sol,     Contract string //  Endpoint string //   Key string //   ContractAddress string //  FormValues url.Values //map    ,  POST form New bool //    }</span></span></code> </pre> <br><p>  The full interface looks like this: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ReadWriterEth <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Transact() (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, error) <span class="hljs-comment"><span class="hljs-comment">//    Call() (string, error) //    Deploy() (string, string, error) //    Info() (*Info, error) //   ,      ParseInput() ([]interface{}, error) //  POST         ParseOutput([]interface{}) (string, error) //      }</span></span></code> </pre> <br><p>  The function to write information to a contract: </p><br><div class="spoiler">  <b class="spoiler_title">Transact</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w *EthWorker)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Transact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// POST ,      inputs, err := w.ParseInput() if err != nil { return "", errors.Wrap(err, "parse input") } //    EthWorker       pk := strings.TrimPrefix(w.Key, "0x") key, err := crypto.HexToECDSA(pk) if err != nil { return "", errors.Wrap(err, "hex to ECDSA") } auth := bind.NewKeyedTransactor(key) if !common.IsHexAddress(w.ContractAddress) { return "", errors.New("New Address From Hex") } addr := common.HexToAddress(w.ContractAddress) //    contract := bind.NewBoundContract( addr, Containers.Containers[w.Container].Contracts[w.Contract].Abi, Client, Client, ) //    Gas gasprice, err := Client.SuggestGasPrice(context.Background()) if err != nil { return "", errors.Wrap(err, "suggest gas price") } //      opt := &amp;bind.TransactOpts{ From: auth.From, Signer: auth.Signer, GasPrice: gasprice, GasLimit: GasLimit, Value: auth.Value, } //   tr, err := contract.Transact(opt, w.Endpoint, inputs...) if err != nil { return "", errors.Wrap(err, "transact") } var receipt *types.Receipt //    ,       ,       switch v := Client.(type) { case *backends.SimulatedBackend: v.Commit() receipt, err = v.TransactionReceipt(context.Background(), tr.Hash()) if err != nil { return "", errors.Wrap(err, "transaction receipt") } case *ethclient.Client: receipt, err = bind.WaitMined(context.Background(), v, tr) if err != nil { return "", errors.Wrap(err, "transaction receipt") } } if err != nil { return "", errors.Errorf("error transact %s: %s", tr.Hash().String(), err.Error(), ) } //     responce := fmt.Sprintf(templates.WriteResult, tr.Nonce(), auth.From.String(), tr.To().String(), tr.Value().String(), tr.GasPrice().String(), receipt.GasUsed.String(), new(big.Int).Mul(receipt.GasUsed, tr.GasPrice()), receipt.Status, receipt.TxHash.String(), ) return responce, nil }</span></span></code> </pre> </div></div><br><p>  The function to read information from the contract: </p><br><div class="spoiler">  <b class="spoiler_title">Call</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w *EthWorker)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { inputs, err := w.ParseInput() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"parse input"</span></span>) } key, _ := crypto.GenerateKey() auth := bind.NewKeyedTransactor(key) contract := bind.NewBoundContract( common.HexToAddress(w.ContractAddress), Containers.Containers[w.Container].Contracts[w.Contract].Abi, Client, Client, ) opt := &amp;bind.CallOpts{ Pending: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, From: auth.From, } outputs := Containers.Containers[w.Container].Contracts[w.Contract].OutputsInterfaces[w.Endpoint] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := contract.Call( opt, &amp;outputs, w.Endpoint, inputs..., ); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"call contract"</span></span>) } result, err := w.ParseOutput(outputs) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"parse output"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result, err }</code> </pre> </div></div><br><p>  Function to deploy contracts: </p><br><div class="spoiler">  <b class="spoiler_title">Deploy</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w *EthWorker)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deploy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { inputs, err := w.ParseInput() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"parse input"</span></span>) } pk := strings.TrimPrefix(w.Key, <span class="hljs-string"><span class="hljs-string">"0x"</span></span>) key, err := crypto.HexToECDSA(pk) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"hex to ECDSA"</span></span>) } auth := bind.NewKeyedTransactor(key) current_bytecode := Containers.Containers[w.Container].Contracts[w.Contract].Bin current_abi := Containers.Containers[w.Container].Contracts[w.Contract].Abi addr, tr, _, err := bind.DeployContract(auth, current_abi, common.FromHex(current_bytecode), Client, inputs...) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"error %s"</span></span>, err.Error()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"deploy contract"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> receipt *types.Receipt <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> v := Client.(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *backends.SimulatedBackend: v.Commit() receipt, err = v.TransactionReceipt(context.Background(), tr.Hash()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"transaction receipt"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *ethclient.Client: receipt, err = bind.WaitMined(context.Background(), v, tr) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"transaction receipt"</span></span>) } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, errors.Errorf(<span class="hljs-string"><span class="hljs-string">"error transact %s: %s"</span></span>, tr.Hash().String(), err.Error(), ) } responce := fmt.Sprintf(templates.DeployResult, tr.Nonce(), auth.From.String(), addr.String(), tr.GasPrice().String(), receipt.GasUsed.String(), <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(big.Int).Mul(receipt.GasUsed, tr.GasPrice()).String(), receipt.Status, receipt.TxHash.String(), ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> responce, addr.String(), <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> </div></div><br><p>  It was necessary to solve the problem of how to obtain data from the data entered by the user in a form on a web page, which can be passed to the Call and Transact functions. </p><br><p>  I didn‚Äôt think of anything better than to find out from the contract method abi the necessary data type for a specific field, and to bring to it what the user entered into a form on a web page.  Those.  If I forgot some data type, then my solution will not work with this data type.  It is necessary to make changes to the code.  Implemented in ParseInput function </p><br><div class="spoiler">  <b class="spoiler_title">ParseInput</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w *EthWorker)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseInput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//           ,        if w.New &amp;&amp; len(Containers.Containers[w.Container].Contracts[w.Contract].Abi.Constructor.Inputs) == 0 { return nil, nil } //           ,        if !w.New &amp;&amp; len(Containers.Containers[w.Container].Contracts[w.Contract].Abi.Methods[w.Endpoint].Inputs) == 0 { return nil, nil } //  Form Values inputsMap := make(map[int]string) var inputsArray []int var inputsSort []string for k, v := range w.FormValues { if k == "endpoint" { continue } if len(v) != 1 { return nil, errors.Errorf("incorrect %s field", k) } i, err := strconv.Atoi(k) if err != nil { continue //return nil, errors.Wrap(err, "incorrect inputs: strconv.Atoi") } inputsMap[i] = v[0] } //    ,   ,    if Containers.Containers[w.Container] == nil || Containers.Containers[w.Container].Contracts[w.Contract] == nil { return nil, errors.New("input values incorrect") } //  , ..  Containers  .      if !w.New &amp;&amp; len(Containers.Containers[w.Container].Contracts[w.Contract].Abi.Methods[w.Endpoint].Inputs) != 0 &amp;&amp; Containers.Containers[w.Container].Contracts[w.Contract].InputsInterfaces[w.Endpoint] == nil { return nil, errors.New("input values incorrect") } //       .     ABI var inputs_args []abi.Argument if w.New { inputs_args = Containers.Containers[w.Container].Contracts[w.Contract].Abi.Constructor.Inputs } else { inputs_args = Containers.Containers[w.Container].Contracts[w.Contract].Abi.Methods[w.Endpoint].Inputs } if len(inputsMap) != len(inputs_args) { return nil, errors.New("len inputs_args != inputsMap: incorrect inputs") } for k := range inputsMap { inputsArray = append(inputsArray, k) } sort.Ints(inputsArray) for k := range inputsArray { inputsSort = append(inputsSort, inputsMap[k]) } var inputs_interfaces []interface{} for i := 0; i &lt; len(inputs_args); i++ { arg_value := inputsMap[i] switch inputs_args[i].Type.Type.String() { case "bool": var result bool result, err := strconv.ParseBool(arg_value) if err != nil { return nil, errors.New("incorrect inputs") } inputs_interfaces = append(inputs_interfaces, result) case "[]bool": var result []bool result_array := strings.Split(arg_value, ",") for _, bool_value := range result_array { item, err := strconv.ParseBool(bool_value) if err != nil { return nil, errors.Wrap(err, "incorrect inputs") } result = append(result, item) } inputs_interfaces = append(inputs_interfaces, result) case "string": inputs_interfaces = append(inputs_interfaces, arg_value) case "[]string": result_array := strings.Split(arg_value, ",") //</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> NEED REF inputs_interfaces = append(inputs_interfaces, result_array) case "[]byte": inputs_interfaces = append(inputs_interfaces, []byte(arg_value)) case "[][]byte": var result [][]byte result_array := strings.Split(arg_value, ",") for _, byte_value := range result_array { result = append(result, []byte(byte_value)) } inputs_interfaces = append(inputs_interfaces, result) case "common.Address": if !common.IsHexAddress(arg_value) { return nil, errors.New("incorrect inputs: arg_value is not address") } inputs_interfaces = append(inputs_interfaces, common.HexToAddress(arg_value)) case "[]common.Address": var result []common.Address result_array := strings.Split(arg_value, ",") for _, addr_value := range result_array { if !common.IsHexAddress(arg_value) { return nil, errors.New("incorrect inputs: arg_value is not address") } addr := common.HexToAddress(addr_value) result = append(result, addr) } inputs_interfaces = append(inputs_interfaces, result) case "common.Hash": if !common.IsHex(arg_value) { return nil, errors.New("incorrect inputs: arg_value is not hex") } inputs_interfaces = append(inputs_interfaces, common.HexToHash(arg_value)) case "[]common.Hash": var result []common.Hash result_array := strings.Split(arg_value, ",") for _, addr_value := range result_array { if !common.IsHex(arg_value) { return nil, errors.New("incorrect inputs: arg_value is not hex") } hash := common.HexToHash(addr_value) result = append(result, hash) } inputs_interfaces = append(inputs_interfaces, result) case "int8": i, err := strconv.ParseInt(arg_value, 10, 8) if err != nil { return nil, errors.New("incorrect inputs: arg_value is not int8") } inputs_interfaces = append(inputs_interfaces, int8(i)) case "int16": i, err := strconv.ParseInt(arg_value, 10, 16) if err != nil { return nil, errors.New("incorrect inputs: arg_value is not int16") } inputs_interfaces = append(inputs_interfaces, int16(i)) case "int32": i, err := strconv.ParseInt(arg_value, 10, 32) if err != nil { return nil, errors.New("incorrect inputs: arg_value is not int32") } inputs_interfaces = append(inputs_interfaces, int32(i)) case "int64": i, err := strconv.ParseInt(arg_value, 10, 64) if err != nil { return nil, errors.New("incorrect inputs: arg_value is not int64") } inputs_interfaces = append(inputs_interfaces, int64(i)) case "uint8": i, err := strconv.ParseInt(arg_value, 10, 8) if err != nil { return nil, errors.New("incorrect inputs: arg_value is not uint8") } inputs_interfaces = append(inputs_interfaces, big.NewInt(i)) case "uint16": i, err := strconv.ParseInt(arg_value, 10, 16) if err != nil { return nil, errors.New("incorrect inputs: arg_value is not uint16") } inputs_interfaces = append(inputs_interfaces, big.NewInt(i)) case "uint32": i, err := strconv.ParseInt(arg_value, 10, 32) if err != nil { return nil, errors.New("incorrect inputs: arg_value is not uint32") } inputs_interfaces = append(inputs_interfaces, big.NewInt(i)) case "uint64": i, err := strconv.ParseInt(arg_value, 10, 64) if err != nil { return nil, errors.New("incorrect inputs: arg_value is not uint64") } inputs_interfaces = append(inputs_interfaces, big.NewInt(i)) case "*big.Int": bi := new(big.Int) bi, _ = bi.SetString(arg_value, 10) if bi == nil { return nil, errors.New("incorrect inputs: " + arg_value + " not " + inputs_args[i].Type.String()) } inputs_interfaces = append(inputs_interfaces, bi) case "[]*big.Int": var result []*big.Int result_array := strings.Split(arg_value, ",") for _, big_value := range result_array { bi := new(big.Int) bi, _ = bi.SetString(big_value, 10) if bi == nil { return nil, errors.New("incorrect inputs: " + arg_value + " not " + inputs_args[i].Type.String()) } result = append(result, bi) } inputs_interfaces = append(inputs_interfaces, result) } } //    return inputs_interfaces, nil }</span></span></code> </pre> </div></div><br><p>  I did a similar conversion for the data we get from Ethereum in the ParseOutput function </p><br><div class="spoiler">  <b class="spoiler_title">Parseoutput</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w *EthWorker)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseOutput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(outputs []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(Containers.Containers[w.Container].Contracts[w.Contract].Abi.Methods[w.Endpoint].Outputs) == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Containers.Containers[w.Container] == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> || Containers.Containers[w.Container].Contracts[w.Contract] == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, errors.New(<span class="hljs-string"><span class="hljs-string">"input values incorrect"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(Containers.Containers[w.Container].Contracts[w.Contract].Abi.Methods[w.Endpoint].Outputs) != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; Containers.Containers[w.Container].Contracts[w.Contract].OutputsInterfaces[w.Endpoint] == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, errors.New(<span class="hljs-string"><span class="hljs-string">"input values incorrect"</span></span>) } output_args := Containers.Containers[w.Container].Contracts[w.Contract].Abi.Methods[w.Endpoint].Outputs <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(outputs) != <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(output_args) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, errors.New(<span class="hljs-string"><span class="hljs-string">"incorrect inputs"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item_array []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(outputs); i++ { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> output_args[i].Type.Type.String() { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: item := strconv.FormatBool(*outputs[i].(*<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>)) item_array = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(item_array, item) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"[]bool"</span></span>: boolArray := *outputs[i].(*[]<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boolItems []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, bool_value := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> boolArray { item := strconv.FormatBool(bool_value) boolItems = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(boolItems, item) } item := <span class="hljs-string"><span class="hljs-string">"[ "</span></span> + strings.Join(boolItems, <span class="hljs-string"><span class="hljs-string">","</span></span>) + <span class="hljs-string"><span class="hljs-string">" ]"</span></span> item_array = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(item_array, item) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"string"</span></span>: item_array = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(item_array, *outputs[i].(*<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"[]string"</span></span>: array := *outputs[i].(*[]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, value := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> array { items = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(items, value) } item := <span class="hljs-string"><span class="hljs-string">"[ "</span></span> + strings.Join(items, <span class="hljs-string"><span class="hljs-string">","</span></span>) + <span class="hljs-string"><span class="hljs-string">" ]"</span></span> item_array = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(item_array, item) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"[]byte"</span></span>: array := *outputs[i].(*[]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, value := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> array { items = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(items, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(value)) } item := <span class="hljs-string"><span class="hljs-string">"[ "</span></span> + strings.Join(items, <span class="hljs-string"><span class="hljs-string">","</span></span>) + <span class="hljs-string"><span class="hljs-string">" ]"</span></span> item_array = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(item_array, item) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"[][]byte"</span></span>: array := *outputs[i].(*[][]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, array2 := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> array { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items2 []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, value := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> array2 { items2 = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(items2, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(value)) } item2 := <span class="hljs-string"><span class="hljs-string">"[ "</span></span> + strings.Join(items2, <span class="hljs-string"><span class="hljs-string">","</span></span>) + <span class="hljs-string"><span class="hljs-string">" ]"</span></span> items = items + <span class="hljs-string"><span class="hljs-string">","</span></span> + item2 } item_array = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(item_array, items) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"common.Address"</span></span>: item := *outputs[i].(*common.Address) item_array = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(item_array, item.String()) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"[]common.Address"</span></span>: addrArray := *outputs[i].(*[]common.Address) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> addrItems []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, value := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> addrArray { addrItems = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(addrItems, value.String()) } item := <span class="hljs-string"><span class="hljs-string">"[ "</span></span> + strings.Join(addrItems, <span class="hljs-string"><span class="hljs-string">","</span></span>) + <span class="hljs-string"><span class="hljs-string">" ]"</span></span> item_array = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(item_array, item) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"common.Hash"</span></span>: item := *outputs[i].(*common.Hash) item_array = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(item_array, item.String()) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"[]common.Hash"</span></span>: hashArray := *outputs[i].(*[]common.Hash) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hashItems []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, value := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> hashArray { hashItems = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(hashItems, value.String()) } item := <span class="hljs-string"><span class="hljs-string">"[ "</span></span> + strings.Join(hashItems, <span class="hljs-string"><span class="hljs-string">","</span></span>) + <span class="hljs-string"><span class="hljs-string">" ]"</span></span> item_array = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(item_array, item) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"int8"</span></span>: item := *outputs[i].(*<span class="hljs-keyword"><span class="hljs-keyword">int8</span></span>) str := strconv.FormatInt(<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>(item), <span class="hljs-number"><span class="hljs-number">10</span></span>) item_array = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(item_array, str) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"int16"</span></span>: item := *outputs[i].(*<span class="hljs-keyword"><span class="hljs-keyword">int16</span></span>) str := strconv.FormatInt(<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>(item), <span class="hljs-number"><span class="hljs-number">10</span></span>) item_array = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(item_array, str) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"int32"</span></span>: item := *outputs[i].(*<span class="hljs-keyword"><span class="hljs-keyword">int32</span></span>) str := strconv.FormatInt(<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>(item), <span class="hljs-number"><span class="hljs-number">10</span></span>) item_array = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(item_array, str) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"int64"</span></span>: item := *outputs[i].(*<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>) str := strconv.FormatInt(item, <span class="hljs-number"><span class="hljs-number">10</span></span>) item_array = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(item_array, str) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"uint8"</span></span>: item := *outputs[i].(*<span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span>) str := strconv.FormatInt(<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>(item), <span class="hljs-number"><span class="hljs-number">10</span></span>) item_array = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(item_array, str) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"uint16"</span></span>: item := *outputs[i].(*<span class="hljs-keyword"><span class="hljs-keyword">uint16</span></span>) str := strconv.FormatInt(<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>(item), <span class="hljs-number"><span class="hljs-number">10</span></span>) item_array = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(item_array, str) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"uint32"</span></span>: item := *outputs[i].(*<span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span>) str := strconv.FormatInt(<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>(item), <span class="hljs-number"><span class="hljs-number">10</span></span>) item_array = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(item_array, str) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"uint64"</span></span>: item := *outputs[i].(*<span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>) str := strconv.FormatInt(<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>(item), <span class="hljs-number"><span class="hljs-number">10</span></span>) item_array = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(item_array, str) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"*big.Int"</span></span>: item := *outputs[i].(**big.Int) item_array = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(item_array, item.String()) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"[]*big.Int"</span></span>: bigArray := *outputs[i].(*[]*big.Int) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, v := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> bigArray { items = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(items, v.String()) } item := <span class="hljs-string"><span class="hljs-string">"[ "</span></span> + strings.Join(items, <span class="hljs-string"><span class="hljs-string">","</span></span>) + <span class="hljs-string"><span class="hljs-string">" ]"</span></span> item_array = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(item_array, item) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strings.Join(item_array, <span class="hljs-string"><span class="hljs-string">" , "</span></span>), <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> </div></div><br><p>  From the code base of the abigen utility I mentioned earlier, I tore the functionality for working with the Solidity compiler.  In the end, I got abi and bytecode for almost any contract.  Implemented in a Bind function. </p><br><div class="spoiler">  <b class="spoiler_title">Bind</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dirname, solcfile </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*ContractContainers, error)</span></span></span></span> { result := &amp;ContractContainers{ Containers: <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*ContractContainer), } allfiles, err := ioutil.ReadDir(dirname) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"error ioutil.ReadDir"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, v := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> allfiles { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v.IsDir() { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hasSuffixCaseInsensitive(v.Name(), <span class="hljs-string"><span class="hljs-string">".sol"</span></span>) { contracts, err := compiler.CompileSolidity(solcfile, dirname+<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(os.PathSeparator)+v.Name()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"CompileSolidity"</span></span>) } c := &amp;ContractContainer{ ContainerName: v.Name(), Contracts: <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*Contract), } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> name, contract := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> contracts { a, _ := json.Marshal(contract.Info.AbiDefinition) ab, err := abi.JSON(strings.NewReader(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(a))) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"abi.JSON"</span></span>) } nameParts := strings.Split(name, <span class="hljs-string"><span class="hljs-string">":"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ab_keys []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ouputs_map := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>][]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) inputs_map := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>][]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key, method := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ab.Methods { ab_keys = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(ab_keys, key) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o []<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i []<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, v := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> method.Outputs { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ar <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> v.Type.Type.String() { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"[]bool"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"string"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"[]string"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"[]byte"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"[][]byte"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>([][]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"common.Address"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(common.Address) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"[]common.Address"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>([]common.Address) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"common.Hash"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(common.Hash) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"[]common.Hash"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>([]common.Hash) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"int8"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int8</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"int16"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"int32"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int32</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"int64"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"uint8"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"uint16"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"uint32"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"uint64"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"*big.Int"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(*big.Int) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"[]*big.Int"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>([]*big.Int) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Errorf(<span class="hljs-string"><span class="hljs-string">"unsupported type: %s"</span></span>, v.Type.Type.String()) } o = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(o, ar) } ouputs_map[method.Name] = o <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, v := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> method.Inputs { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ar <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> v.Type.Type.String() { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"[]bool"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"string"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"[]string"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"[]byte"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"[][]byte"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>([][]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"common.Address"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(common.Address) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"[]common.Address"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>([]common.Address) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"common.Hash"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(common.Hash) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"[]common.Hash"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>([]common.Hash) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"int8"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int8</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"int16"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"int32"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int32</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"int64"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"uint8"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"uint16"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"uint32"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"uint64"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"*big.Int"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(*big.Int) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"[]*big.Int"</span></span>: ar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>([]*big.Int) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Errorf(<span class="hljs-string"><span class="hljs-string">"unsupported type: %s"</span></span>, v.Type.Type.String()) } i = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(i, ar) } inputs_map[method.Name] = i } sort.Strings(ab_keys) con := &amp;Contract{ Name: nameParts[<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(nameParts)<span class="hljs-number"><span class="hljs-number">-1</span></span>], Abi: ab, AbiJson: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(a), Bin: contract.Code, SortKeys: ab_keys, OutputsInterfaces: ouputs_map, InputsInterfaces: inputs_map, } c.ContractNames = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(c.ContractNames, nameParts[<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(nameParts)<span class="hljs-number"><span class="hljs-number">-1</span></span>]) c.Contracts[nameParts[<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(nameParts)<span class="hljs-number"><span class="hljs-number">-1</span></span>]] = con } sort.Strings(c.ContractNames) result.ContainerNames = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(result.ContainerNames, c.ContainerName) result.Containers[c.ContainerName] = c } } sort.Strings(result.ContainerNames) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result, err }</code> </pre> </div></div><br><p>  In the function, there remained a large block of code from experiments with the mobile package, which I have not yet removed, but simply made a refactor. </p><br><p>  I created a fairly large ContractContainers structure in which I put all the information about current contracts, and in the future the application takes all the information from it. </p><br><h4 id="nakonec-rasskazhu-kak-eto-rabotaet">  Finally I will tell how it works: </h4><br><p>  I ran the program only on Linux.  I have no other operating systems nearby. <br>  Although assembled executable files for Windows and Mac. </p><br><p>  First you need a Solidity compiler for your platform.  This is probably the most difficult item. </p><br><p>  You can take the compiled binary or source code <a href="https://github.com/ethereum/solidity/releases">here</a> or see the details <a href="http://solidity.readthedocs.io/en/latest/installing-solidity.html">here</a> .  Versions 0.4.18 and 0.4.19 for linux and Windows I put in the solc directory of the project.  You can also use the compiler already installed in the system.  To check whether the Solidity compiler is on the system, type the following at the command prompt: </p><br><pre> <code class="hljs pgsql">solc ‚Äî<span class="hljs-keyword"><span class="hljs-keyword">version</span></span></code> </pre> <br><p>  If the answer is: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">solc</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">the</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">solidity</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">compiler</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">commandline</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">interface</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Version</span></span>: 0<span class="hljs-selector-class"><span class="hljs-selector-class">.4</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.18</span></span>+<span class="hljs-selector-tag"><span class="hljs-selector-tag">commit</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.9cf6e910</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Linux</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.g</span></span>++</code> </pre> <br><p>  then all is well. <br>  If it will require some libraries, then just install them, for example, if Ubuntu asks for it: </p><br><pre> <code class="hljs vhdl">./solc: <span class="hljs-literal"><span class="hljs-literal">error</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> loading <span class="hljs-keyword"><span class="hljs-keyword">shared</span></span> libraries: libz3.so.<span class="hljs-number"><span class="hljs-number">4</span></span>: cannot <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shared</span></span> object <span class="hljs-keyword"><span class="hljs-keyword">file</span></span>: No such <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> directory</code> </pre> <br><p>  then put libz3-dev </p><br><p>  Next you need to decide in which mode we will work with Ethereum.  There are two ways: </p><br><ul><li>  we connect via RPC to the Ethereum node and work through it with the network with which the node is synchronized.  This is convenient if you have a private Ethereum network or you already have a synchronized node; </li><li>  Ethereum block chain emulator.  If you work in emulator mode, then you definitely need to put in the keystore directory UTC files in the JSON Keystore File format, where the passwords for decrypting these files will be empty; </li></ul><br><p>  You can certainly make it much more beautiful, but for an example the existing solution is quite suitable.  The application takes Ethereum addresses from these files and makes a non-zero balance for them. <br>  I put 5 files in the keystore directory for an example.  They can be used in a test environment. </p><br><p>  Fill in config.yaml config: </p><br><ul><li>  connect_url - url to connect to the Ethereum rpc server of the node.  If this field is left blank, the application will start in Ethereum emulation mode, this is exactly what I wrote about above; </li><li>  sol_path is the smart contract folder in which the application will search for them.  The application will search for .sol files that will be located in the directory.  Subdirectories are ignored.  But if your contracts with which you work will refer to the contracts in the subdirectories, that's okay, they will also be added through top-level contracts; </li><li>  keystore_path - directory with UTC JSON Keystore File files.  Let me remind you that passwords for decryption must be empty; </li><li>  gaslimit - Gas limit for a transaction or contract deployment; </li><li>  port - the port for the local http server; </li><li>  solc - the path to the Solidity compiler, if left empty, the application will take the compiler installed in the system; </li></ul><br><p>  Run the application.  The path to the directory with the configuration file can be specified via the -config flag </p><br><pre> <code class="hljs perl">./efront-v<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>-linux-amd64 -config $GOPATH/src/ethereum-front/</code> </pre> <br><p>  Follow the link in the browser: the default is <a href="http://localhost:8085/">http: // localhost: 8085</a> <br>  You need to enter a private key.  Private keys for five test addresses can be found in keys.txt.  This private key will live in cookies of our browser for 15 minutes.  Next will be a new request.  Now nothing is encrypted. </p><br><img src="https://habrastorage.org/webt/vk/rn/ki/vkrnkild4xtmhbs31lk1dh5vny4.png"><br><p>  select th select the container (.sol file) and the contract that the application has found in it. </p><br><img src="https://habrastorage.org/webt/sv/xn/kl/svxnklout8dw7nun-ynbaacnfti.png"><br><p>  Next, you can enter the address of the once-expanded contract or deploy a new one by checking the corresponding checkbox.  If checkbox Deploy is on, then the address field is ignored. </p><br><p>  If everything went well then you will see a similar picture in the browser. </p><br><img src="https://habrastorage.org/webt/aj/nn/aa/ajnnaaqwob-ufyb-ol3iua-32cu.png"><br><p>  If there are errors, they will be displayed in the textarea at the top of the interface. <br>  At the top of the page are two links, login and upload. </p><br><p>  Login redirects to enter a new private key.  Upload redirects to contract selection. </p><br><p>  Next is the current session information: </p><br><img src="https://habrastorage.org/webt/6x/1r/ok/6x1rokwx_sljqwg6tgfu5msxqvk.png"><br><ul><li>  you address: - Ethereum address that corresponds to the current private key. </li><li>  balance - Eth balance at this address in the current network.  Requested with every page refresh. </li><li>  file and contract - this is respectively the selected sol file and the contract in it.  It is stored in cookies and taken from there. </li><li>  The contract address is the address of the deployed contract on the current network.  It is stored in cookies and taken from there. </li></ul><br><p>  Next come two tables: <br>  Left table for working with current contract methods.  It changes dynamically, depending on the selected contract. </p><br><p>  The right table is common functions for working with Ethereum: </p><br><ul><li>  Balance - check the balance on the selected Ethereum address in the current network; </li><li>  Gas price - the current Gas price in Wei; </li><li>  Last block - the number of the current block.  Does not work in the simulator; </li><li>  Ethereum network gas limit - The limit of gas in the last block.  Does not work in the simulator; </li><li>  Ethereum network time - The mining time of the last block.  Does not work in the simulator; </li><li>  Ethereum network difficulty - the complexity of the last block.  Does not work in the simulator; </li><li>  Transfer - to whom and how much Wai transfer; </li><li>  Adjust time - Time management in the simulator.  It is necessary to enter a positive number.  And so many seconds will increase the time in the simulator; </li></ul><br><p>  <em>Note: When performing transactions (operations on the blockchain), wait for the page to load, it can take several seconds.</em> <em>        .</em> </p><br><p>    ,    textarea     (     ): </p><br><img src="https://habrastorage.org/webt/y7/aw/39/y7aw39v_mawjitiifii12kctuoi.png"><br><br><ul><li> Nonce ‚Äî   </li><li> From ‚Äî    </li><li> Contract Address ‚Äî    </li><li> Gas price ‚Äî  Gas </li><li> Gas Used ‚Äî    Gas </li><li> Cost/Fee:    Wai </li><li> Status ‚Äî   1,         ,  0,          . </li><li> Transaction Hash ‚Äî   </li></ul><br><p>               . <br> C     OS.     bin. </p><br><h4 id="iz-yavnyh-minusov-hochu-otmetit">     : </h4><br><ul><li>   html   5.      </li><li>   front      Ethereum,         ether,         </li><li>         , -   </li></ul><br><p>  <a href="https://github.com/dzeckelev/ethereum-front">Source</a> <br>  Thanks to all. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/346432/">https://habr.com/ru/post/346432/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346422/index.html">Daniel Lerch: ‚ÄúSteganography is a tool of great interest to cyber criminals‚Äù</a></li>
<li><a href="../346424/index.html">Issue # 6: IT training - current issues and challenges from leading companies</a></li>
<li><a href="../346426/index.html">How to implement Secure Development Lifecycle and not turn gray. The story of Yandex on ZeroNights 2017</a></li>
<li><a href="../346428/index.html">How does the capital domain zone .MOSCOW live three years after its launch?</a></li>
<li><a href="../346430/index.html">Docker in production: update</a></li>
<li><a href="../346434/index.html">Nvidia drivers and telemetry</a></li>
<li><a href="../346436/index.html">S3 Storage Balancing with GoBetween + VRRP</a></li>
<li><a href="../346438/index.html">Twenty years with user experience: squeezing practical experience</a></li>
<li><a href="../346440/index.html">Just about the graphs. Attempt to popularize</a></li>
<li><a href="../346442/index.html">The story of how I steal credit card numbers and passwords from visitors to your sites</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>