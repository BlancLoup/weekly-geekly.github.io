<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Houdini: one of the most impressive CSS projects you've never heard of</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Have you ever wanted to use any feature from the CSS standard, but you didn‚Äôt, because it is not supported by all browsers ? Or even worse: it is supp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Houdini: one of the most impressive CSS projects you've never heard of</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/5a7/dcc/2f7/5a7dcc2f71844e16906e416109928fa5.jpeg"><br><br>  Have you ever wanted to use any feature from the CSS standard, but you didn‚Äôt, because it <b>is not supported by all browsers</b> ?  Or even worse: it is supported by all browsers, but is the support buggy, controversial or even incompatible?  Surely you are faced with this, and therefore I recommend you look at <a href="https://wiki.css-houdini.org/">Houdini</a> . <br><br>  This is a new W3C working group that has an ambitious task to solve the problem described above forever.  This is planned to be done using a new set of APIs, which for the first time will give developers the opportunity to independently expand CSS, as well as provide tools for <b>connecting to the process of creating a layout and applying styles in the course of the browser engine</b> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But what exactly is behind these promises?  Is this even a good idea?  And how will all of the above help us, developers, create websites today and tomorrow? <br><br>  I will try to answer all these questions.  But first I will clarify the current problems of today and the need to solve them.  And then we will talk about how Houdini can help us with them, and consider some of his most impressive features that are under development.  And in conclusion, I will make a number of suggestions on how the developer community can help the project Houdini. <br><a name="habracut"></a><br><h1>  What problems is Houdini trying to solve? </h1><br>  Every time I write an article or create a demo application to popularize some new CSS feature, I will inevitably receive comments like: ‚ÄúThis is great!  What a pity we won't be able to use it for another ten years. ‚Äù  Although such comments are non-constructive and very annoying, I can understand the mood of the developers.  It so happened that the wide dissemination of innovations takes years.  And the main reason for this, as the web history teaches us, is to get new CSS capabilities exclusively through the standardization process. <br><br><img src="https://habrastorage.org/files/fb8/3e8/1ce/fb83e81ce70948eca381aeae8f9dead9.png"><br>  <sup><i>Stages of the standardization process</i></sup> <br><br>  I have nothing against standardization, but it takes too much time!  For example, <a href="https://drafts.csswg.org/css-flexbox/">flexbox</a> was proposed in 2009, and developers still explain that they still cannot use it due to insufficient browser support.  Fortunately, this problem is gradually disappearing, since almost all modern browsers are updated automatically.  But even in this case, there is always a delay between the offering of functionality and the general readiness for its use.  It is curious that this situation is not observed in all areas of the web.  Compare, for example, with JavaScript: <br><br><img src="https://habrastorage.org/files/8aa/8fe/4c6/8aa8fe4c600047a3b4abf5d0ec6089e4.png"><br>  <sup><i>The stages of the introduction of polyfill</i></sup> <br><br>  In this case, days may pass from the moment an idea arises to its use in work.  For example, I already use the <code>async/await</code> functions in production, but this functionality has not yet been implemented in any browser! <br><br>  Surely you have noticed a huge difference in the moods of both communities.  In the JS community, you are reading an article in which someone complains that things are changing too quickly.  And in CSS, everyone is moaning about the futility of learning new products, since it will take a lot of time before they can be used. <br><br><h3>  <i>So why don't we just write more CSS polyfills?</i> </h3><br>  At first glance, this is an obvious solution.  Thanks to good polyfills, CSS could be as fast-paced as JavaScript, right?  Alas, not so simple.  Embedding polyfills in CSS is incredibly difficult, and in many cases this cannot be done without collapsing performance completely. <br><br>  JavaScript is a dynamic language, so you can create JS polyfills on JS.  Its incredible extensibility is due to its dynamic nature.  And CSS is rarely used to create your own polyfills.  Sometimes at the build stage, you can compile CSS code into CSS code (transpile) (this is what <a href="https://github.com/postcss/postcss">PostCSS</a> does).  But if you want to use polyfills for something that depends on the DOM structure, or for the position or layout of the element, then the logic of the polyfill will have to be executed on the client side.  Unfortunately, browsers do not make this task easier. <br><br>  Below is a basic diagram of the browser operation process, from receiving an HTML document to displaying pixels on the screen.  Blue highlights the stages in which JavaScript can affect the result: <br><br><img src="https://habrastorage.org/files/4b7/dbe/dbd/4b7dbedbdd4f4cb4a0d6a38758837243.png"><br>  <sup><i>JavaScript access to browser visualization pipeline</i></sup> <br><br>  Pretty dark picture.  You, as a developer, do not control the process of parsing HTML and CSS, and then turn it into <a href="https://dom.spec.whatwg.org/">DOM</a> and <a href="https://drafts.csswg.org/cssom/">CSS object model</a> (CSSOM).  You do not control the cascade.  You do not control the process of choosing the layout of elements in the DOM, do not control their color (paint) when displayed on the screen.  Finally, you have no effect on the work of the compositor (composite).  Only the DOM is completely under your control.  You have some influence on CSSOM, but according to the Houdini website, this stage is ‚Äúnot sufficiently defined, it differs depending on the browser, and is also devoid of a number of critical features.‚Äù  For example, today CSSOM will not show you the rules from cross-origin style sheets, while it will simply drop them if it does not understand.  And this means that if you want to write a polyfill that adds functionality, you will be forced to bypass CSSOM.  You will have to find the <code>&lt;style&gt;</code> and / or <code>&lt;link rel="stylesheet"&gt;</code> tags through DOM, then get the CSS yourself, parse it, convert it and then add it back to the DOM. <br><br>  Of course, a DOM update usually means that the browser will then have to go through all the steps again: the cascade, the template, the coloring, and the layout. <br><br><img src="https://habrastorage.org/files/cf9/86b/a73/cf986ba73e58443abb5a220bfd9c8589.png"><br>  <sup><i>Using JavaScript Polyfills in the Browser Visualization Pipeline</i></sup> <br><br>  If you think that a complete redrawing of the page doesn‚Äôt have a big impact on performance, then remember how often this can happen.  If the logic of polyfills has to be executed depending on such events as scrolling, window resizing, mouse movement, keystrokes ‚Äî that is, with any change ‚Äî then your site will run much slower, perhaps even indecently slowly.  Everything looks even darker if you imagine that all modern CSS polyfills include their own CSS parser and cascade logic.  And since these are very complex components, the polyfills turn out to be either very large or too large. <br><br>  Summing up what has been said: if you want to force the browser to do something for which it, in its opinion, is not intended (including the CSS fed to it by you), you will have to think how to trick it using self-modifying the DOM.  You do not have access to other pipeline stages. <br><br><h3>  <i>But why would I even want to modify the internal browser engine?</i> </h3><br>  In my opinion, this is the most important question of the whole article.  So, if you have reached this point, then read on slowly and thoughtfully! <br><br>  After the previous section, one of you thought: ‚ÄúI don‚Äôt need it!  I'm just doing regular web pages, and not trying to hack the insides of the browser or do something extremely extravagant, experimental, or super modern. ‚Äù  If you have been visited by such thoughts, then I insist that you postpone this text for now and carefully study the technologies you have used to create websites in recent years.  The desire to access the process of applying styles in the browser is connected not with creating fancy demos, but with giving developers and framework authors the ability to do two things: <br><br><ul><li>  smooth the differences between browsers </li><li>  come up with new features or add them using polyfills so that people can use them today. </li></ul><br>  If you have ever used jQuery, then immediately got the benefit of using its features!  This is one of the main arguments in favor of almost all modern frontend libraries and frameworks.  For example, the five most popular JS and DOM repositories on GitHub ‚Äî AngularJS, D3, jQuery, React, and Ember ‚Äî are working hard to smooth the differences between browsers so that you and I don't have to think about it.  Each of these projects offers a single API that works like a clock. <br><br>  And now think of CSS and all these cross-browser problems.  Even popular frameworks, like Bootstrap and Foundation, claiming their broad compatibility do not really solve the problem of cross-browser bugs - they just avoid them.  But all these CSS bugs are not just pieces of the past.  Even today, despite the use of new template modules like <a href="https://drafts.csswg.org/css-flexbox/">flexbox</a> , we are constantly <a href="https://github.com/philipwalton/flexbugs">confronted with incompatibilities</a> .  Imagine how much easier it would be for developers if we could use any CSS properties and were confident that they work the same in every browser.  Or remember all the great new items that you read about on blogs or heard at conferences and meetings ‚Äî for example, <a href="https://drafts.csswg.org/css-grid/">grids</a> , <a href="https://drafts.csswg.org/css-snappoints/">anchor points,</a> and <a href="https://drafts.csswg.org/css-position-3/">sticky positioning</a> .  Imagine how you could use them now, as easily as the native CSS features.  And for that, you just need to copy a piece of code from GitHub. <br><br>  All this is the dream of the Houdini development team.  This is the future they are trying to create.  And even if you do not plan to write CSS polyfills or develop experimental functionalities, you probably want others to do this.  After all, if there are such polyfills, then everyone will benefit from it. <br><br><h1>  What functionality is Houdini currently in development? </h1><br>  I mentioned above that we have very few entry points to the browser page pipeline.  In essence, this is just a DOM and, with a stretch, CSSOM.  The Houdini development team introduced several new specifications that, for the first time, will provide developers with access to the other stages of the pipeline.  These specifications are reflected in the diagram (the planned ones, but not yet implemented) are highlighted in gray. <br><br><img src="https://habrastorage.org/files/abd/1b5/850/abd1b5850824455a911091b2bad04920.png"><br>  <sup><i>New Houdini specifications for working with the visualization pipeline</i></sup> <br><br>  In the following sections, we will briefly review each of these new specifications, analyze the possibilities they provide.  A number of specifications in this article are not mentioned; you can find a complete list <a href="https://github.com/w3c/css-houdini-drafts">in the project repository</a> . <br><br><h3>  <i>CSS Parsing API</i> </h3><br>  <a href="https://drafts.css-houdini.org/css-parser-api/">This specification</a> has not yet been implemented, so everything mentioned below may change.  The basic idea is to allow developers to extend the CSS parser and inform it about new designs.  For example, about new media rules, new pseudo-classes, nesting, <code>@extends</code> , <code>@apply</code> , etc. As soon as the parser finds out about them, it will be able to place them in the right place in the CSSOM, and not drop it. <br><br><h3>  <i>CSS properties and values ‚Äã‚ÄãAPI</i> </h3><br>  CSS already has custom properties, and I really like the features they provide.  The new API takes this functionality to a higher level by adding types.  This gives many advantages, the most important of which is that with the help of types, developers will be able to implement color transition and animation of custom properties (it is not possible to do this today). <br><br>  See an example: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">body</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">--primary-theme-color</span></span>: tomato; <span class="hljs-attribute"><span class="hljs-attribute">transition</span></span>: --primary-theme-color <span class="hljs-number"><span class="hljs-number">1s</span></span> ease-in-out; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">body</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.night-theme</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">--primary-theme-color</span></span>: darkred; }</code> </pre><br>  The <code>night-theme</code> class is added to the <code>&lt;body&gt;</code> element, and now the color of all the individual elements on the page that refer to the value of the property <code>--primary-theme-color</code> will slowly move from <code>tomato</code> to <code>darkred</code> .  So far, for this, you have to manually register the color transition for each element, since you cannot describe the transition for the property itself. <br><br>  Another promising feature of this API is to register hooks (apply hook), which allows developers to modify the final value of the custom property of an element after the end of the cascading step.  This is very useful in terms of using polyfills. <br><br><h3>  <i>CSS typed OM</i> </h3><br>  <a href="https://drafts.css-houdini.org/css-typed-om/">This functionality</a> can be considered as the second version of the current CSSOM.  It is designed to solve numerous problems associated with the current model, and includes features added by the new parsing API and the properties and values ‚Äã‚ÄãAPI.  Also typed OM is designed to improve performance.  Converting CSSOM string values ‚Äã‚Äãto typed JS representations can lead to significant performance failures. <br><br><h3>  <i>CSS Layout API</i> </h3><br>  <a href="https://drafts.css-houdini.org/css-layout-api/">This API</a> allows developers to write their own layout modules.  And by the ‚Äúmockup module‚Äù I mean everything that can be transferred to the <code>display</code> property.  This will allow you to create a layout as quickly as with native modules, like <code>display</code> : <code>flex</code> and <code>display</code> : <code>table</code> .  An example is the Masonry library.  Developers have to resort to such tools if they want to create complex layouts that cannot be implemented by means of CSS alone.  And although all these layouts look very impressive, their performance leaves much to be desired, especially not on the most powerful devices. <br><br>  The layout API provides the <code>registerLayout</code> method, which gets the layout name (later used in CSS) and the JS class, which includes all the layout logic.  Here is a simple example of how you can define masonry via <code>registerLayout</code> : <br><br><pre> <code class="javascript hljs">registerLayout(<span class="hljs-string"><span class="hljs-string">'masonry'</span></span>, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get inputProperties() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'width'</span></span>, <span class="hljs-string"><span class="hljs-string">'height'</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get childrenInputProperties() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'x'</span></span>, <span class="hljs-string"><span class="hljs-string">'y'</span></span>, <span class="hljs-string"><span class="hljs-string">'position'</span></span>] } layout(children, constraintSpace, styleMap, breakToken) { <span class="hljs-comment"><span class="hljs-comment">// Layout logic goes here. } }</span></span></code> </pre><br>  If here everything looks incomprehensible to you, do not worry.  The main thing is to look at the code for the following example.  After downloading the <code>masonry.js</code> file and adding it to the site, you can write CSS in a similar style, and everything will work. <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">body</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">layout</span></span>(<span class="hljs-string"><span class="hljs-string">'masonry'</span></span>); }</code> </pre><br><h3>  <i>CSS Painting API</i> </h3><br>  This API is very similar to the previous one.  It provides a <code>registerPaint</code> method that works in the same way as <code>registerLayout</code> .  After that, you can use the <code>paint()</code> function in CSS wherever the parser needs the expected image, passing the registered name. <br><br>  A simple example of drawing a colored circle: <br><br><pre> <code class="javascript hljs">registerPaint(<span class="hljs-string"><span class="hljs-string">'circle'</span></span>, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get inputProperties() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'--circle-color'</span></span>]; } paint(ctx, geom, properties) { <span class="hljs-comment"><span class="hljs-comment">// Change the fill color. const color = properties.get('--circle-color'); ctx.fillStyle = color; // Determine the center point and radius. const x = geom.width / 2; const y = geom.height / 2; const radius = Math.min(x, y); // Draw the circle \o/ ctx.beginPath(); ctx.arc(x, y, radius, 0, 2 * Math.PI, false); ctx.fill(); } });</span></span></code> </pre><br>  And in CSS you can use it like this: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.bubble</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">--circle-color</span></span>: blue; <span class="hljs-attribute"><span class="hljs-attribute">background-image</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">paint</span></span>(<span class="hljs-string"><span class="hljs-string">'circle'</span></span>); }</code> </pre><br>  Now the element <code>.bubble</code> will be displayed on the background of the blue circle.  This circle will be centered on the element and adjusted to its size, no matter what happens. <br><br><h3>  <i>Worklets</i> </h3><br>  For many of the specifications described, sample code is provided (for example, <code>registerLayout</code> and <code>registerPaint</code> ).  This code will need to be placed in scripts - <a href="https://drafts.css-houdini.org/worklets/">worklet</a> 's.  These are analogs of ‚Äúweb workers‚Äù (web workers), which allow you to import script files and execute JS code that can be executed at different stages of the visualization pipeline independently of the main stream. <br><br>  Permissible types of operations in worksets will be tightly restricted for the sake of maintaining high performance. <br><br><h3>  <i>Composited Scrolling and Animation</i> </h3><br>  Although the official specification does not yet exist, but this is already <a href="">one of the most well-known and expected</a> features of Houdini.  Probably, these APIs will allow the logic to be executed in the linker vorklet, outside the main thread, with support for modifying a limited set of properties of the DOM element.  This set will include only those properties that can be read or changed without having to force the engine to recalculate the layout or styles (for example, transformation, transparency, scroll shift).  All this will allow to implement very fast animation, based on scrolling or user input, like sticking when scrolling headers and parallax effect.  You can read more about <a href="">how to use</a> these APIs on GitHub. <br><br>  Despite the lack of official specifications, the Chrome development team has already begun to experiment.  Using the primitives provided by these APIs, they implemented <a href="https://drafts.csswg.org/css-snappoints/">CSS anchor points</a> and <a href="https://drafts.csswg.org/css-position-3/">sticky positioning</a> .  This means that the Houdini APIs work fast enough to create new functionality in Chrome based on them.  This fact should finally dispel your possible doubts about the performance of Houdini in comparison with the native tools. <br><br>  You can watch a <a href="https://www.youtube.com/watch%3Fv%3DEUlIxr8mk7s">video</a> made using the internal assembly of Chrome.  It shows the header behavior when scrolling, similar to that implemented in the native Twitter mobile application.  Also available <a href="https://github.com/GoogleChrome/houdini-samples/tree/master/twitter-header">source code</a> . <br><br><h1>  What can be done now? </h1><br>  As I said, it seems to me that Houdini will be of interest to anyone involved in web development.  This project is capable of making our life much easier in the future.  Even if you never begin to directly use these specifications, you will certainly use tools built on their basis.  And although tomorrow a bright future will not come, yet it is closer than many of you think.  Representatives of all the major browser developers this year met to meet with the Houdini team in Sydney, and among them there was almost no disagreement on what or how to implement.  As far as I know, the question is only in the timing of the completion of the work on Houdini. <br><br>  Like all software developers, browser creators should pay particular attention to the new features of their products.  And such priorities often depend on the degree of demand for new functions.  So if you care about the extensibility of website styles and layouts, if you want to live in a world where you can take advantage of new CSS features without many years of waiting for standardization, inform those who are associated with the development teams of the browsers you use. <br><br>  You can also help the cause by sharing with the community the possible ways of applying new products.  Tell us what you would like to do with styles and layouts that today is difficult or impossible to do.  For some drafts <a href="https://github.com/w3c/css-houdini-drafts">on GitHub</a> , use-case descriptions are available, but you can, of course, create a pull request by sharing your ideas.  If there is no suitable document, you can create a new one. <br><br>  The Houdini development team (and the W3C as a whole) is really important to get an informative response from the web development community.  Many of those involved in the specification process are engineers working on browsers.  Often they are not professional web developers and do not always know about our immediate needs and difficulties. <br><br>  Give them your opinion. <br><br><h3>  <i>useful links</i> </h3><br><ul><li>  <a href="https://drafts.css-houdini.org/">CSS-TAG Houdini Editor Drafts</a> , W3C <br>  The latest public version of the Houdini draft. </li><li>  <a href="https://github.com/w3c/css-houdini-drafts">CSS-TAG Houdini Task Force Specifications</a> , GitHub <br>  The official GitHub repository, which is under development. </li><li>  <a href="https://github.com/GoogleChrome/houdini-samples">Houdini Samples</a> , GitHub <br>  Code examples. </li><li>  <a href="http://lists.w3.org/Archives/Public/public-houdini/">Houdini mailing list</a> , W3C <br>  Here you can ask general questions. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/282027/">https://habr.com/ru/post/282027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282017/index.html">Cloud Digest # 4: OS, Infrastructure, and Virtualization</a></li>
<li><a href="../282019/index.html">About conferences</a></li>
<li><a href="../282021/index.html">Why should a book engineer when there is internet</a></li>
<li><a href="../282023/index.html">Microsoft Edge Web Summit 2016 Entries Available - Part 1</a></li>
<li><a href="../282025/index.html">Increase Magento Performance</a></li>
<li><a href="../282029/index.html">IDS / IPS Suricata rule appearance statistics for new threats</a></li>
<li><a href="../282031/index.html">8 mistakes when developing a mobile application</a></li>
<li><a href="../282033/index.html">April 23-24, from 12:00 to 12:00, we invite you to # 1 Global Chatbots Hackathon from Webinar.ru</a></li>
<li><a href="../282035/index.html">Weak [weak] links in the new version of Delphi</a></li>
<li><a href="../282037/index.html">We do multitasking</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>