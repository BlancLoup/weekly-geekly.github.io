<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to stop forgetting about indexes and start checking the execution plan in tests</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some time ago, an unpleasant story happened to me, which served as a trigger for a small project on the githaba and turned into this article. 

 An or...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to stop forgetting about indexes and start checking the execution plan in tests</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/cb/kk/ps/cbkkpswi947gczpzqmwkyh2pwmm.jpeg" alt="cdpv"><br><br>  Some time ago, an unpleasant story happened to me, which served as a trigger for a small project on the githaba and turned into this article. <br><br>  An ordinary day, a regular release: all tasks are checked up and down by our QA-engineer, so with the calmness of a sacred cow we ‚Äúroll up‚Äù to the stage.  The application behaves well, in the logs - silence.  We decide to make a switch (stage &lt;-&gt; prod).  Switch, look at the devices ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It takes a couple of minutes, the flight is stable.  A QA engineer does a smoke test, notices that the application somehow slows down unnaturally.  Write off on warming up the caches. <br><br>  It takes another couple of minutes, the first complaint from the first line: the data is loaded for customers for a very long time, the application slows down, it takes a long time to respond, etc.  We start to worry ... we look at logs, we look for the possible reasons. <br><a name="habracut"></a><br>  It takes another couple of minutes, a letter arrives from DB-admins.  They write that the execution time of queries to the database (hereinafter referred to as the DB) has broken all possible boundaries and tends to infinity. <br><br>  I open monitoring (I use <a href="https://github.com/javamelody/javamelody/wiki">JavaMelody</a> ), I find these requests.  I launch PGAdmin, I reproduce.  Really long.  I add ‚Äúexplain‚Äù, I look at the execution plan ... so it is, we forgot about the indexes. <br><br><h2>  Why is code review not enough? </h2><br>  That case taught me a lot.  Yes, I ‚Äúput out the fire‚Äù for an hour, having created the necessary index directly on the sale, something like this (do not forget about the CONCURRENTLY option): <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> CONCURRENTLY <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> ix_pets_name <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> pets_table (name_column);</code> </pre> <br>  Agree, this was tantamount to deployment with downtime.  For the application on which I work, this is unacceptable. <br><br>  I made conclusions and added a special bold item to the checklist for code review: if I see that one of the Repository classes was added / changed during the development process, I check the sql migrations for the presence of a script that creates and modifies the index.  If it is not there, I write the author a question: is he sure that an index is not needed here? <br><br>  It is likely that the index is not needed if there is little data, but if we work with a table in which the number of rows is counted in millions, the error of the index can become fatal and lead to the history outlined at the beginning of the article. <br><br>  In this case, I ask the author of the pull request (hereinafter PR) 100% to make sure that the request he wrote in HQL is at least partially covered by the index (Index Scan is used).  For this developer: <br><br><ol><li>  starts the application </li><li>  searches for converted (HQL -&gt; SQL) query in logs </li><li>  opens PGAdmin or another database administration tool </li><li>  generates in the local database, so that no one interferes with his experiments, the amount of data acceptable for tests (minimum 10K - 20K records) </li><li>  executes request </li><li>  requests execution plan </li><li>  carefully examines it and draws appropriate conclusions </li><li>  Adds / changes an index, achieving that the execution plan arranged it </li><li>  is written to the PR that the request coverage is checked </li><li>  expertly assessing the risks and the seriousness of the request, I can double-check his actions </li></ol><br>  A lot of routine actions and the human factor, but for a while it suited me, and I lived with it. <br><br><h2>  On the way home </h2><br>  They say it is very useful to at least occasionally walk from work, without listening to music / podcasts along the way.  At this time, just thinking about life, you can come to interesting conclusions and ideas. <br><br>  One day I went home and thought about what was that day.  There were several reviews, each one I checked with the checklist and did a number of actions described above.  I was so tired that time I thought, what the hell?  Is it impossible to do this automatically? .. I quickened my step, wanting to ‚Äúsmash‚Äù this idea as soon as possible. <br><br><h2>  Formulation of the problem </h2><br>  What is the most important thing for a developer in execution plan? <br>  Of course, seq scan on large amounts of data, caused by the lack of an index. <br><br>  Thus, it was necessary to make a test that: <br><br><ol><li>  It is executed on a DB with a configuration similar to Prodovsk </li><li>  Intercepts a database query made by the JPA repository (Hibernate) </li><li>  Get it Execution Plan </li><li>  Parsing Execution Plan, decomposing it into a convenient data structure for checks </li><li>  Using a convenient set of Assert methods, checks for expectations.  For example, that seq scan is not used. </li></ol><br><br>  It was necessary to test this hypothesis rather by making a prototype. <br><br><h2>  Solution architecture </h2><br><img src="https://habrastorage.org/webt/6e/2i/bz/6e2ibz7cl8roycahqee4yb1lqqq.png" alt="checkinx architecture"><br><br>  The first problem that had to be solved was the launch of a test on a real database, which coincides in the version and settings with the one used in the sale. <br><br>  Thanks to <a href="https://mvnrepository.com/artifact/org.testcontainers/postgresql">Docker &amp; TestContainers</a> , they solve this problem. <br><br>  SqlInterceptor, ExecutionPlanQuery, ExecutionPlanParse, and AssertService are the interfaces I currently implement for Postgres.  Plans to implement for other databases.  If you want to participate - welcome.  The code is written in Kotlin. <br><br>  I put all this together on GitHub and called <a href="https://github.com/TinkoffCreditSystems/checkinx-utils">checkinx-utils</a> .  You do not need to repeat this, it is enough to connect dependency to checkinx in maven / gradle and use convenient asserts.  How to do this, I will describe in more detail below. <br><br><h3>  Description of the interaction of components CheckInx </h3><br><h4>  ProxyDataSource </h4><br>  The first problem to be solved is interception of queries ready to be executed to the database.  Already with the set parameters, without questions, etc. <br><br>  To do this, you need to wrap the real dataSource into a certain Proxy, which would allow you to integrate into the query execution pipeline and, accordingly, intercept them. <br><br>  Such ProxyDataSource has already been implemented by many.  I used the <a href="https://github.com/ttddyy/datasource-proxy">ttddyy</a> ready-made solution, which allows me to set my Listener to intercept the request I need. <br><br>  I substitute the original DataSource using the DataSourceWrapper class (BeanPostProcessor). <br><br><h4>  SqlInterceptor </h4><br>  In essence, its start () method sets its Listener to the proxyDataSource and starts intercepting queries, saving them in the internal list of statements.  The stop () method, respectively, removes the installed Listener. <br><br><h4>  ExecutionPlanQuery </h4><br>  Here, the original request is transformed into a request for a execution plan.  In the case of Postgres, this is the addition to the query of the keyword "EXPLAIN". <br><br>  Further, this request is executed on the same database from testcontainders and a ‚Äúraw‚Äù execution plan (list of lines) is returned. <br><br><h4>  ExecutionPlanParser </h4><br>  It is inconvenient to work with a ‚Äúraw‚Äù execution plan.  Therefore, I parse it into a tree consisting of nodes (PlanNode). <br><br>  Let us analyze the PlanNode fields using the example of a real ExecutionPlan: <br><br><pre> <code class="sql hljs">Index Scan using ix_pets_age on pets  (cost=0.29..8.77 rows=1 width=36) Index Cond: (age &lt; 10) Filter: ((name)::text = 'Jack'::text)</code> </pre> <br><div class="scrollable-table"><table><tbody><tr><th>  Property </th><th>  Example </th><th>  Description </th></tr><tr><td>  raw: string </td><td>  Index Scan using ix_pets_age on pets (cost = 0.29..8.77 rows = 1 width = 36) </td><td>  source line </td></tr><tr><td>  table: String? </td><td>  pets <br></td><td>  table name </td></tr><tr><td>  target: String? </td><td>  ix_pets_age </td><td>  index name </td></tr><tr><td>  coverage: String? </td><td>  Index Scan </td><td>  coating </td></tr><tr><td>  coverageLevel </td><td>  HALF </td><td>  abstraction over the coating (ZERO, HALF, FULL) </td></tr><tr><td>  children: MutableList &lt;PlanNode&gt; </td><td>  - </td><td>  child nodes </td></tr><tr><td>  properties: MutableList &lt;Pair &lt;String, String &gt;&gt; </td><td>  <i>key</i> : Index Cond, <i>value</i> : (age &lt;10); <br>  <i>key</i> : Filter, <i>value</i> : ((name) :: text = 'Jack' :: text) <br></td><td>  properties </td></tr><tr><td>  others: MutableList &lt;String&gt; </td><td>  - </td><td>  All that could not be recognized in the current version of checkinx </td></tr></tbody></table></div><br><h4>  Assertservice </h4><br>  With the data structure returned by the parser it is already possible to work normally.  CheckInxAssertService is a set of checks for the PlanNode tree described above.  It allows you to set your own lambda checks or use the pre-specified, from my point of view, the most popular.  For example, so that your request does not have a Seq Scan, or you want to make sure that a specific index is used / not used. <br><br><h4>  CoverageLevel </h4><br>  Very important Enum, I will describe it separately: <br><div class="scrollable-table"><table><tbody><tr><th>  Value </th><th>  Description </th></tr><tr><td>  NOT_USING <br></td><td>  checks that a specific target (index) is not used <br></td></tr><tr><td>  ZERO <br></td><td>  index is not used (Seq Scan) <br></td></tr><tr><td>  HALF <br></td><td>  partial scan of the query index (Index Scan).  For example, the search is performed by index, but for the resulting data refers to the table <br></td></tr><tr><td>  FULL <br></td><td>  full index query (Index Only Scan) <br></td></tr><tr><td>  UNKNOWN <br></td><td>  unknown cover.  For some reason, it was not possible to install it. <br></td></tr></tbody></table></div><br>  Further we will sort some examples of use. <br><br><h2>  Test examples using CheckInx </h2><br>  I made a separate project on the GitHub <a href="https://github.com/dsemyriazhko/checkinx-demo">checkinx-demo</a> , where I implemented the JPA repository to the table pets and tests to this repository that check coverage, indexes, etc.  It will be useful to look there as a starting point. <br><br>  You may have such a test: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFindByLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {  <span class="hljs-comment"><span class="hljs-comment">// ARRANGE  val location = "Moscow"  //   ,      10-20.  //   TestNG      @BeforeClass  IntRange(1, 10000).forEach {      val pet = Pet()      pet.id = UUID.randomUUID()      pet.age = it      pet.location = "Saint Petersburg"      pet.name = "Jack-$it"      repository.save(pet)  }  // ACT  //     sqlInterceptor.startInterception()  //    val pets = repository.findByLocation(location)  //    sqlInterceptor.stopInterception()  // ASSERT  //         assertEquals(1, sqlInterceptor.statements.size.toLong())  // ,    ix_pets_location    (Index Scan)  checkInxAssertService.assertCoverage(CoverageLevel.HALF, "ix_pets_location", sqlInterceptor.statements[0])  //        ,      Seq Scan,        checkInxAssertService.assertCoverage(CoverageLevel.HALF, sqlInterceptor.statements[0])  // ...  ,      checkInxAssertService.assertPlan(plan) {          it.coverageLevel.level &lt; CoverageLevel.FULL.level      } }</span></span></code> </pre> <br>  The execution plan could be as follows: <br><br><pre> <code class="sql hljs">Index Scan using ix_pets_location on pets pet0_  (cost=0.29..4.30 rows=1 width=46) Index Cond: ((location)::text = 'Moscow'::text)</code> </pre> <br>  ... or like this, if we forgot about the index (the tests turn red): <br><br><pre> <code class="sql hljs">Seq Scan on pets pet0_  (cost=0.00..19.00 rows=4 width=84) Filter: ((location)::text = 'Moscow'::text)</code> </pre> <br>  In my project, I most of all use the simplest assert, which says that Seq Scan is missing in the execution plan: <br><br><pre> <code class="kotlin hljs">checkInxAssertService.assertCoverage(CoverageLevel.HALF, sqlInterceptor.statements[<span class="hljs-number"><span class="hljs-number">0</span></span>])</code> </pre> <br>  The presence of such a test suggests that I, at a minimum, studied the execution plan. <br>  It also makes project management more explicit, and the code's documentation and predictability increase. <br><br><div class="spoiler">  <b class="spoiler_title">Mode for experienced</b> <div class="spoiler_text">  I recommend using ScheckInxAssertService, but if there is a need, you can bypass the parse tree (ExecutionPlanParser) yourself or, in general, parse the ‚Äúraw‚Äù execution plan (the result of the ExecutionPlanQuery). <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFindByLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {  <span class="hljs-comment"><span class="hljs-comment">// ARRANGE  val location = "Moscow"  // ACT  //     sqlInterceptor.startInterception()  //    val pets = repository.findByLocation(location)  //    sqlInterceptor.stopInterception()  // ASSERT  //  ""    val executionPlan = executionPlanQuery.execute(sqlInterceptor.statements[0])  //    -   val plan = executionPlanParser.parse(executionPlan)  assertNotNull(plan)  // ...     val rootNode = plan.rootPlanNode  assertEquals("Index Scan", rootNode.coverage)  assertEquals("ix_pets_location", rootNode.target)  assertEquals("pets pet0_", rootNode.table) }</span></span></code> </pre> </div></div><br><br><h2>  Connect to the project </h2><br>  In my project, I singled out such tests into a separate group, calling it Intensive Integration Tests. <br><br>  It is easy to connect and start using checkinx-utils.  Let's start with the build script. <br><br>  First connect the repository.  Someday I will load checkinx into maven, but now I can only download artifact from GitHub via jitpack. <br><br><pre> <code class="plaintext hljs">repositories { // ...  maven { url 'https://jitpack.io' } }</code> </pre> <br>  Next, add the dependency: <br><br><pre> <code class="plaintext hljs">dependencies { // ...  implementation 'com.github.tinkoffcreditsystems:checkinx-utils:0.2.0' }</code> </pre> <br>  We finish the connection by adding a configuration.  Now only Postgres is supported. <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Profile(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"test"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-meta"><span class="hljs-meta">@ImportAutoConfiguration(classes = [PostgresConfig::class])</span></span> <span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CheckInxConfig</span></span></span></span></code> </pre> <br>  Pay attention to the test profile.  Otherwise, you will find the ProxyDataSource in your product. <br><br>  PostgresConfig connects several bins: <br><br><ol><li>  DataSourceWrapper </li><li>  PostgresInterceptor </li><li>  PostgresExecutionPlanParser </li><li>  PostgresExecutionPlanQuery </li><li>  CheckInxAssertServiceImpl </li></ol><br>  If you need some kind of customization that the current API does not provide, you can always replace one of the beans with your implementation. <br><br><h2>  Known Issues </h2><br>  Sometimes the DataSourceWrapper fails to spoof the original dataSource due to the Spring CGLIB proxy.  In BeanPostProcessor, in this case, it is not the DataSource that comes, but the ScopedProxyFactoryBean and there are problems with type checking. <br><br>  The easiest solution would be to create a HikariDataSource for tests manually.  Then your configuration will be as follows: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Profile(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"test"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-meta"><span class="hljs-meta">@ImportAutoConfiguration(classes = [PostgresConfig::class])</span></span> <span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CheckInxConfig</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-meta"><span class="hljs-meta">@Primary</span></span>  <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span>  <span class="hljs-meta"><span class="hljs-meta">@ConfigurationProperties(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"spring.datasource"</span></span></span><span class="hljs-meta">)</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dataSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: DataSource {      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DataSourceBuilder.create()          .type(HikariDataSource::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">i</span></span></span><span class="hljs-class">&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">/i</span></span></span><span class="hljs-class">&gt;)          .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">build</span></span></span></span>()  }  <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span>  <span class="hljs-meta"><span class="hljs-meta">@ConfigurationProperties(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"spring.datasource.configuration"</span></span></span><span class="hljs-meta">)</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dataSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(properties: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">DataSourceProperties</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: HikariDataSource {      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> properties.initializeDataSourceBuilder()          .type(HikariDataSource::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">i</span></span></span><span class="hljs-class">&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">/i</span></span></span><span class="hljs-class">&gt;)          .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">build</span></span></span></span>()  } }</code> </pre> <br><br><h2>  Development plans </h2><br><ol><li>  I would like to understand whether it is necessary for someone other than me?  To do this, create a survey.  I will be glad to answer honestly. </li><li>  See what you really need and expand the standard list of assert methods. </li><li>  Write implementations for other databases. </li><li>  The construction of sqlInterceptor.statements [0] does not look very obvious, I want to improve. </li></ol><br>  I would be glad if someone wants to join and log out, playing in Kotlin. <br><br><h2>  Conclusion </h2><br>  I am sure that there will be comments: <i>it is impossible to predict how the query planner will behave on the sale, it all depends on the collected statistics</i> . <br><br>  Indeed, the planner.  using the statistics collected earlier, can build a different plan from the one being tested.  Meaning a little different. <br><br>  The task of the scheduler is to improve rather than worsen the request.  Therefore, for no apparent reason, he will not suddenly use Seq Scan, but you can unknowingly. <br><br>  CheckInx you need to write a test, do not forget about studying the query execution plan and consider the possibility of creating an index, or vice versa, the test clearly shows that no indexes are needed here and you are satisfied with Seq Scan.  This would save you from unnecessary questions on code review. <br><br><h2>  Links </h2><br><ol><li>  <a href="https://github.com/TinkoffCreditSystems/checkinx-utils">https://github.com/TinkoffCreditSystems/checkinx-utils</a> </li><li>  <a href="https://github.com/dsemyriazhko/checkinx-demo">https://github.com/dsemyriazhko/checkinx-demo</a> </li><li>  <a href="https://github.com/ttddyy/datasource-proxy">https://github.com/ttddyy/datasource-proxy</a> </li><li>  <a href="https://mvnrepository.com/artifact/org.testcontainers/postgresql">https://mvnrepository.com/artifact/org.testcontainers/postgresql</a> </li><li>  <a href="https://github.com/javamelody/javamelody/wiki">https://github.com/javamelody/javamelody/wiki</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/454066/">https://habr.com/ru/post/454066/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454052/index.html">‚ÄúAh-ah, boss, talking cap!‚Äù - smart helmet for production</a></li>
<li><a href="../454056/index.html">How to connect Kubernetes clusters in different data centers</a></li>
<li><a href="../454060/index.html">An unexpected look at asynchronous circuits, independent of speed</a></li>
<li><a href="../454062/index.html">Corporate phone - like a Swiss knife: for inventory, chat, support calls and references</a></li>
<li><a href="../454064/index.html">Untold story of AI</a></li>
<li><a href="../454070/index.html">Selection of monocolice for commuting</a></li>
<li><a href="../454072/index.html">The five biggest examples of lies regarding 5G</a></li>
<li><a href="../454076/index.html">DotNext 2019 Piter: small report</a></li>
<li><a href="../45408/index.html">Eclipse PDT - Zend for Eclipse DIY</a></li>
<li><a href="../454082/index.html">Plastic waves: an ecological catastrophe of the World Ocean</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>