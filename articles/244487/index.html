<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Swift Multiple Functions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Russian translation of the very useful article Natasha Murashev The Many Faces of Swift Functions . 

 Although the Objective-C syntax looks a bit str...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Swift Multiple Functions</h1><div class="post__text post__text-html js-mediator-article">  Russian translation of the very useful article <a href="https://twitter.com/NatashaTheRobot">Natasha Murashev</a> <a href="http://www.objc.io/issue-16/swift-functions.html">The Many Faces of Swift Functions</a> . <br><br>  Although the <i>Objective-C</i> syntax looks a bit strange, compared to other programming languages, the <b>method</b> syntax is simple and straightforward.  Here is a brief excursion into the past: <br><br><pre><code class="objectivec hljs">+ (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)mySimpleMethod { <span class="hljs-comment"><span class="hljs-comment">//  "" //   //    } - (NSString *)myMethodNameWithParameter1:(NSString *)param1 parameter2:(NSNumber *)param2 { //  "" //   -  NSString , //   -  NSNumber  //     NSString  return @"hello, world!"; }</span></span></code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In contrast, <i>Swift</i> syntax looks in most cases as well as in other programming languages, but at times it can be more complicated and confusing than in <i>Objective-C</i> . <br><br>  Before I continue, I want to clarify the difference between <b>‚Äúmethods‚Äù</b> and <b>‚Äúfunctions‚Äù</b> in <i>Swift</i> , as I‚Äôll use both of these terms throughout this article.  Here is the definition of ‚Äúmethods‚Äù given in <a href="https://developer.apple.com/library/mac/documentation/Swift/Conceptual/Swift_Programming_Language/Methods.html">Apple‚Äôs Swift Programming Language</a> : <br><br><a name="habracut"></a><br><br><blockquote>  Methods are functions that are associated with a particular ‚Äútype‚Äù.  Classes, structures, and enumerations can define ‚Äúinstance‚Äù methods that encapsulate specific works and functionality for working with an ‚Äúinstance‚Äù of a given ‚Äútype‚Äù.  Classes, structures, and enumerations can also define methods for ‚Äútype‚Äù that are associated with ‚Äútype‚Äù as such.  ‚ÄúType‚Äù methods are similar to ‚Äúclass‚Äù methods in Objective-C. <br></blockquote><br>  <b>Functions are</b> autonomous, while <b>methods</b> are functions embedded in a <code>class, struct</code> or <code>enum</code> . <br><br><h2>  Anatomy of Swift Functions </h2><br><br>  Let's start with a simple ‚ÄúHello, World!‚Äù <i>Swift</i> function: <br><br><pre> <code class="objectivec hljs">func mySimpleFunction() { println(<span class="hljs-string"><span class="hljs-string">"hello, world!"</span></span>) }</code> </pre><br><br>  If you have ever programmed in any language other than <i>Objective-C</i> , this function will seem familiar to you. <br><br>  The <code>func</code> keyword is a function. <br>  The name of this function is <code>mySimpleFunction</code> . <br>  No parameters are passed to this function ‚Äî because it is empty inside parentheses (). <br>  No value is returned. <br>  The executable function code is between curly brackets {}. <br>  Now we turn to more complex functions: <br><br><pre> <code class="objectivec hljs">func myFunctionName(param1: String, param2: Int) -&gt; String { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"hello, world!"</span></span> }</code> </pre><br><br>  This function takes one parameter named <code>param1</code> type <code>String</code> and another parameter named <code>param2</code> type <code>Int</code> and returns a value of type <code>String</code> . <br><br><h2>  Call all functions </h2><br><br>  One of the significant differences between <i>Swift</i> and <i>Objective-C</i> is <b>how</b> parameters work when the <i>Swift</i> function is called.  If you like <i>Objective-C</i> "talkative" as I like, keep in mind that parameter names are not included by default when calling the <i>Swift</i> function: <br><br><pre> <code class="objectivec hljs">func hello(name: String) { println(<span class="hljs-string"><span class="hljs-string">"hello \(name)"</span></span>) } hello(<span class="hljs-string"><span class="hljs-string">"Mr. Roboto"</span></span>)</code> </pre><br><br>  Not so bad, until you want to add some more parameters to your function: <br><br><pre> <code class="objectivec hljs">func hello(name: String, age: Int, location: String) { println(<span class="hljs-string"><span class="hljs-string">"Hello \(name). I live in \(location) too. When is your \(age + 1)th birthday?"</span></span>) } hello(<span class="hljs-string"><span class="hljs-string">"Mr. Roboto"</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">"San Francisco"</span></span>)</code> </pre><br><br>  To simply read <code>hello("Mr. Roboto", 5, "San Francisco")</code> , you will need to know what the parameter means. <br>  In <i>Swift,</i> there is the concept of external parameter names to clarify this confusion: <br><br><pre> <code class="objectivec hljs">func hello(name name: String) { println(<span class="hljs-string"><span class="hljs-string">"hello \(name)"</span></span>) } hello(name: <span class="hljs-string"><span class="hljs-string">"Robot"</span></span>)</code> </pre><br><br>  Instead, simply add # in front of the parameter name to abbreviate: <br><br><pre> <code class="objectivec hljs">func hello(<span class="hljs-meta"><span class="hljs-meta">#name: String) { println(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"hello \(name)"</span></span></span><span class="hljs-meta">) } hello(name: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Robot"</span></span></span><span class="hljs-meta">)</span></span></code> </pre><br><br>  And, of course, the rules by which the parameters for <b>functions</b> work differ slightly from the rules for <b>methods</b> ... <br><br><h2>  Method call </h2><br><br>  If the function is built into a <code>class</code> (or <code>struct</code> , or <code>enum</code> ), the name of the <b>first parameter of the</b> method is <b>not included as external</b> , while all subsequent parameter names are included as external when the method is called: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyFunClass { func hello(name: String, age: Int, location: String) { println(<span class="hljs-string"><span class="hljs-string">"Hello \(name). I live in \(location) too. When is your \(age + 1)th birthday?"</span></span>) } } let myFunClass = MyFunClass() myFunClass.hello(<span class="hljs-string"><span class="hljs-string">"Mr. Roboto"</span></span>, age: <span class="hljs-number"><span class="hljs-number">5</span></span>, location: <span class="hljs-string"><span class="hljs-string">"San Francisco"</span></span>)</code> </pre><br><br>  Therefore, it is best practice to include the name of the first parameter in the name of your method, as in <i>Objective-C</i> : <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyFunClass { func helloWithName(name: String, age: Int, location: String) { println(<span class="hljs-string"><span class="hljs-string">"Hello \(name). I live in \(location) too. When is your \(age + 1)th birthday?"</span></span>) } } let myFunClass = MyFunClass() myFunClass.helloWithName(<span class="hljs-string"><span class="hljs-string">"Mr. Roboto"</span></span>, age: <span class="hljs-number"><span class="hljs-number">5</span></span>, location: <span class="hljs-string"><span class="hljs-string">"San Francisco"</span></span>)</code> </pre><br><br>  Instead of calling my <code>‚Äúhello‚Äù</code> function, I renamed it <code>helloWithName</code> to make the name of the first parameter of the method more understandable. <br><br>  If for some reason you want to omit the external parameter names in your function (I would recommend doing this only for very significant reasons), use the _ symbol for the external parameter name: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyFunClass { func helloWithName(name: String, _ age: Int, _ location: String) { println(<span class="hljs-string"><span class="hljs-string">"Hello \(name). I live in \(location) too. When is your \(age + 1)th birthday?"</span></span>) } } let myFunClass = MyFunClass() myFunClass.helloWithName(<span class="hljs-string"><span class="hljs-string">"Mr. Roboto"</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">"San Francisco"</span></span>)</code> </pre><br><br><h2>  Instance methods are curried functions. </h2><br><br>  One very remarkable thing to note is that the ‚Äúinstance methods‚Äù are actually <a href="http://oleb.net/blog/2014/07/swift-instance-methods-curried-functions/">curried functions in <i>Swift</i></a> : <br><br><blockquote>  The basic idea of ‚Äã‚Äãcurrying is that the function can be partially applied, which means that some of the parameter values ‚Äã‚Äãcan be defined before the function is called.  Partial function application produces a new function. </blockquote><br>  So, I have a class: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyHelloWorldClass { func helloWithName(name: String) -&gt; String { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"hello, \(name)"</span></span> } }</code> </pre><br><br>  I can create a variable that points to a function of the <code>helloWithName</code> class: <br><br><pre> <code class="objectivec hljs">let helloWithNameFunc = MyHelloWorldClass.helloWithName <span class="hljs-comment"><span class="hljs-comment">// MyHelloWorldClass -&gt; (String) -&gt; String</span></span></code> </pre><br><br>  My new <code>helloWithNameFunc</code> function is a function of type <code>MyHelloWorldClass -&gt; (String) -&gt; Sting</code> , which takes an ‚Äúinstance‚Äù of my class and returns another function, which in turn takes a string value and returns a string value. <br>  Now I can call my function like this: <br><br><pre> <code class="objectivec hljs">let myHelloWorldClassInstance = MyHelloWorldClass() helloWithNameFunc(myHelloWorldClassInstance)(<span class="hljs-string"><span class="hljs-string">"Mr. Roboto"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// hello, Mr. Roboto</span></span></code> </pre><br><br><h2>  <code>Init</code> : Special Notes </h2><br><br>  The special <code>init</code> method is called when the <code>class, struct</code> , or <code>enum</code> is initialized.  In <i>Swift</i> , you can define initialization parameters, like any other method: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Person { init(name: String) { <span class="hljs-comment"><span class="hljs-comment">//   init } } Person(name: "Mr. Roboto")</span></span></code> </pre><br><br>  Note that, in contrast to other methods, the name of the <b>first</b> parameter of the <code>init</code> method always <b>requires an external name</b> when obtaining an instance of a class. <br>  A good practice is to add a parameter other than the internal, external name ‚Äî in our case <code>fromName</code> ‚Äî to make getting an instance of the class more readable: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Person { init(fromName name: String) { <span class="hljs-comment"><span class="hljs-comment">// your init implementation } } Person(fromName: "Mr. Roboto")</span></span></code> </pre><br><br>  And, of course, as with other methods, you can add the _ character if you want your <code>init</code> method to skip the external name of the parameter.  I like the readability and power of the following initialization example from the book <a href="https://developer.apple.com/library/mac/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html">Swift Programming Language</a> : <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Celsius { var temperatureInCelsius: Double init(fromFahrenheit fahrenheit: Double) { temperatureInCelsius = (fahrenheit - <span class="hljs-number"><span class="hljs-number">32.0</span></span>) / <span class="hljs-number"><span class="hljs-number">1.8</span></span> } init(fromKelvin kelvin: Double) { temperatureInCelsius = kelvin - <span class="hljs-number"><span class="hljs-number">273.15</span></span> } init(_ celsius: Double) { temperatureInCelsius = celsius } } let boilingPointOfWater = Celsius(fromFahrenheit: <span class="hljs-number"><span class="hljs-number">212.0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// boilingPointOfWater.temperatureInCelsius is 100.0 let freezingPointOfWater = Celsius(fromKelvin: 273.15) // freezingPointOfWater.temperatureInCelsius is 0.0 let bodyTemperature = Celsius(37.0) // bodyTemperature.temperatureInCelsius is 37.0</span></span></code> </pre><br><br>  Skipping the external name of a parameter can also be useful if you want to abstract away from <b>how</b> your <code>class / enum / struct</code> initialized.  I really like using <a href="https://github.com/owensd/json-swift/blob/master/src/JSValue.swift">David Owen‚Äôs json-swift library:</a> <br><br><pre> <code class="objectivec hljs">public <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> JSValue : Equatable { <span class="hljs-comment"><span class="hljs-comment">// ...   ///   `JSValue`  `JSArrayType` . public init(_ value: JSArrayType) { self.value = JSBackingValue.JSArray(value) } ///   `JSValue`  `JSObjectType` . public init(_ value: JSObjectType) { self.value = JSBackingValue.JSObject(value) } ///   `JSValue`  `JSStringType` . public init(_ value: JSStringType) { self.value = JSBackingValue.JSString(value) } ///   `JSValue`  `JSNumberType` . public init(_ value: JSNumberType) { self.value = JSBackingValue.JSNumber(value) } ///  `JSValue`  `JSBoolType` . public init(_ value: JSBoolType) { self.value = JSBackingValue.JSBool(value) } ///  `JSValue`  `Error` . init(_ error: Error) { self.value = JSBackingValue.Invalid(error) } ///  `JSValue`  `JSBackingValue` . init(_ value: JSBackingValue) { self.value = value } }</span></span></code> </pre><br><br><h2>  "Special" options </h2><br><br>  Compared to <i>Objective-C</i> , <i>Swift</i> has additional options regarding which parameters can be passed to functions / methods.  Here are some examples. <br><br><h3>  Parameters of type Optional </h3><br><br>  Swift introduces a new concept of type <code>Optional</code> : <br><br><blockquote>  Optionals say that either ‚Äúthis value and it is equal to x‚Äù, or ‚Äúthere is no value at all.‚Äù Optionals are similar to using nil with pointers in Objective-C, but they work for any type, not just for classes.  Optionals are safer and more expressive than nil pointers in Objective-C, and they are the center of many powerful features of Swift. </blockquote><br>  To show that this parameter is <code>Optional</code> (i.e., maybe <code>nil</code> ), just add a question mark?  Following type specification: <br><br><pre> <code class="objectivec hljs">func myFuncWithOptionalType(parameter: String?) { <span class="hljs-comment"><span class="hljs-comment">// function execution } myFuncWithOptionalType("someString") myFuncWithOptionalType(nil)</span></span></code> </pre><br><br>  When you work with <code>Optionals</code> , do not forget to "deploy" it! <br><br><pre> <code class="objectivec hljs">func myFuncWithOptionalType(optionalParameter: String?) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let unwrappedOptional = optionalParameter { println(<span class="hljs-string"><span class="hljs-string">"The optional has a value! It's \(unwrappedOptional)"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { println(<span class="hljs-string"><span class="hljs-string">"The optional is nil!"</span></span>) } } myFuncWithOptionalType(<span class="hljs-string"><span class="hljs-string">"someString"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// The optional has a value! It's someString myFuncWithOptionalType(nil) // The optional is nil</span></span></code> </pre><br><br>  If you come from <i>Objective-C</i> , it will take you some time to adapt when working with <code>Optionals</code> ! <br><br><h3>  Parameters with <code>Default</code> Values </h3><br><br><pre> <code class="objectivec hljs">func hello(name: String = <span class="hljs-string"><span class="hljs-string">"you"</span></span>) { println(<span class="hljs-string"><span class="hljs-string">"hello, \(name)"</span></span>) } hello(name: <span class="hljs-string"><span class="hljs-string">"Mr. Roboto"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// hello, Mr. Roboto hello() // hello, you</span></span></code> </pre><br><br>  Note that the parameter with a default value automatically has <b>an external</b> name. <br><br>  Since parameters with a <code>default</code> value can be skipped when calling a function, it is good practice to place all parameters with <code>default</code> values ‚Äã‚Äãat the end of the parameter list.  Here is a quote from the book <a href="https://developer.apple.com/library/mac/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html">"Swift Programming Language"</a> on this topic: <br><blockquote>  Place the parameters with default values ‚Äã‚Äãat the end of the function parameter list.  This ensures that all function calls use the same order of parameters for their non default arguments.  Therefore, in all cases the same function is called. </blockquote><br>  I‚Äôm a big fan of using <code>default</code> parameters, mainly because it makes it easy to change code and provide backward compatibility.  You can, for example, start with two parameters that you need at the moment, for example, to configure a custom ‚Äútable cell‚Äù <code>UITableViewCell</code> , and if you need additional configuration when another parameter is needed (for example, a different color for your text label cells), then you simply add a new parameter with a default value - and all other places where this function has already been called can be left unchanged, and you can send a pair to a new part of your code that requires a new parameter.  empl with a value other than the default values! <br><br><h3>  Variadic parameters (variable number of parameters) </h3><br><br>  <code>Variadic</code> parameters are simply a more readable version of the transmission of an array of elements.  In fact, if you look at the type of the internal parameter <code>name</code> in the example below, you will see that it is of the type [String]: <br><br><pre> <code class="objectivec hljs">func helloWithNames(names: String...) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> names { println(<span class="hljs-string"><span class="hljs-string">"Hello, \(name)"</span></span>) } } <span class="hljs-comment"><span class="hljs-comment">// 2 names helloWithNames("Mr. Robot", "Mr. Potato") // Hello, Mr. Robot // Hello, Mr. Potato // 4 names helloWithNames("Batman", "Superman", "Wonder Woman", "Catwoman") // Hello, Batman // Hello, Superman // Hello, Wonder Woman // Hello, Catwoman</span></span></code> </pre><br><br>  Remember that it is possible to transfer 0 values, which corresponds to an empty array, so do not forget to check whether an empty array is being transmitted, if necessary: <br><br><pre> <code class="objectivec hljs">func helloWithNames(names: String...) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> names.count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> names { println(<span class="hljs-string"><span class="hljs-string">"Hello, \(name)"</span></span>) } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { println(<span class="hljs-string"><span class="hljs-string">"Nobody here!"</span></span>) } } helloWithNames() <span class="hljs-comment"><span class="hljs-comment">// Nobody here!</span></span></code> </pre><br><br>  Another note about the <code>variadic</code> parameters: the <code>variadic</code> parameter should be the last parameter in your parameter list! <br><br><h3>  Inout parameters </h3><br><br>  With <code>inout</code> parameters we get the ability to manipulate external variables passed by reference: <br><br><pre> <code class="objectivec hljs">var name1 = <span class="hljs-string"><span class="hljs-string">"Mr. Potato"</span></span> var name2 = <span class="hljs-string"><span class="hljs-string">"Mr. Roboto"</span></span> func nameSwap(<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> name1: String, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> name2: String) { let oldName1 = name1 name1 = name2 name2 = oldName1 } nameSwap(&amp;name1, &amp;name2) name1 <span class="hljs-comment"><span class="hljs-comment">// Mr. Roboto name2 // Mr. Potato</span></span></code> </pre><br><br>  This is a very common <i>Objective-C</i> pattern for the error management script. <br><br>  <code>NSJSONSerialization</code> is one such example: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)parseJSONData:(<span class="hljs-built_in"><span class="hljs-built_in">NSData</span></span> *)jsonData { <span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span> *error = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> jsonResult = [<span class="hljs-built_in"><span class="hljs-built_in">NSJSONSerialization</span></span> JSONObjectWithData:jsonData options:<span class="hljs-number"><span class="hljs-number">0</span></span> error:&amp;error]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!jsonResult) { <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"ERROR: %@"</span></span>, error.description); } }</code> </pre><br><br>  Since <i>Swift</i> is still a very young programming language, so there are still no clear error handling conventions, but there are definitely many other ways besides <code>inout</code> parameters!  Take a look at <a href="http://owensd.io/2014/08/22/error-handling-take-two.html">Swift's David Owen</a> recent blog post about <a href="http://owensd.io/2014/08/22/error-handling-take-two.html">error handling</a> .  A lot of material on this topic in the book <a href="http://www.objc.io/books/">"Functional Programming in Swift"</a> . <br><br><h3>  Generic options </h3><br><br>  I'm not going to pay too much attention in this post <b>generics</b> , but I‚Äôll show a very simple example of a function that accepts parameters of different types, but at the same time both parameters are of the same type: <br><br><pre> <code class="objectivec hljs">func valueSwap&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> value1: T, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> value2: T) { let oldValue1 = value1 value1 = value2 value2 = oldValue1 } var name1 = <span class="hljs-string"><span class="hljs-string">"Mr. Potato"</span></span> var name2 = <span class="hljs-string"><span class="hljs-string">"Mr. Roboto"</span></span> valueSwap(&amp;name1, &amp;name2) name1 <span class="hljs-comment"><span class="hljs-comment">// Mr. Roboto name2 // Mr. Potato var number1 = 2 var number2 = 5 valueSwap(&amp;number1, &amp;number2) number1 // 5 number2 // 2</span></span></code> </pre><br><br>  For more information on <code>generics</code> , I recommend taking a look at <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html">the ‚ÄúGenerics‚Äù section</a> in the Apple book, Swift Programming Language. <br><br><h3>  Parameters - Variables </h3><br><br>  By default, the parameters passed to the function are constants, therefore they cannot be manipulated in the scope of the function.  If you want to change this behavior, simply use the <b>var</b> keyword: <br><br><pre> <code class="objectivec hljs">var name = <span class="hljs-string"><span class="hljs-string">"Mr. Roboto"</span></span> func appendNumbersToName(var name: String, <span class="hljs-meta"><span class="hljs-meta">#maxNumber: Int) -&gt; String { for i in 0..</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;maxNumber { name += String(i + 1) } return name } appendNumbersToName(name, maxNumber:5) // Mr. Robot12345 name // Mr. Roboto</span></span></span></span></code> </pre><br><br>  Notice that this is completely different than the <code>inout</code> parameter ‚Äî the variable parameters do not change the externally passed variable! <br><br><h3>  Functions as parameters </h3><br><br>  In <i>Swift,</i> functions can be passed as regular variables.  For example, a function may have another function as a passed parameter: <br><br><pre> <code class="objectivec hljs">func luckyNumberForName(name: String, <span class="hljs-meta"><span class="hljs-meta">#lotteryHandler: (String, Int) -&gt; String) -&gt; String { let luckyNumber = Int(arc4random() % 100) return lotteryHandler(name, luckyNumber) } func defaultLotteryHandler(name: String, luckyNumber: Int) -&gt; String { return </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\(name), your lucky number is \(luckyNumber)"</span></span></span><span class="hljs-meta"> } luckyNumberForName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Mr. Roboto"</span></span></span><span class="hljs-meta">, lotteryHandler: defaultLotteryHandler) // Mr. Roboto, your lucky number is 38</span></span></code> </pre><br><br>  Note that only the function reference is passed as a parameter - in our case, the <code>defaultLotteryHandler</code> function.  The function is executed later when the function that the parameter is passed to decides. <br><br>  The ‚Äúinstance‚Äù methods can be passed in the same way: <br><br><pre> <code class="objectivec hljs">func luckyNumberForName(name: String, <span class="hljs-meta"><span class="hljs-meta">#lotteryHandler: (String, Int) -&gt; String) -&gt; String { let luckyNumber = Int(arc4random() % 100) return lotteryHandler(name, luckyNumber) } class FunLottery { func defaultLotteryHandler(name: String, luckyNumber: Int) -&gt; String { return </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\(name), your lucky number is \(luckyNumber)"</span></span></span><span class="hljs-meta"> } } let funLottery = FunLottery() luckyNumberForName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Mr. Roboto"</span></span></span><span class="hljs-meta">, lotteryHandler: funLottery.defaultLotteryHandler) // Mr. Roboto, your lucky number is 38</span></span></code> </pre><br><br>  To make the definition of a function a little more readable, consider creating an alias of type (type-aliasing) for our function (like a <code>typedef</code> in <i>Objective-C</i> ): <br><br><pre> <code class="objectivec hljs">typealias lotteryOutputHandler = (String, Int) -&gt; String func luckyNumberForName(name: String, <span class="hljs-meta"><span class="hljs-meta">#lotteryHandler: lotteryOutputHandler) -&gt; String { let luckyNumber = Int(arc4random() % 100) return lotteryHandler(name, luckyNumber) }</span></span></code> </pre><br><br>  As a parameter type, there can also be a function without a name (like a block in <i>Objective-C</i> ): <br><br><pre> <code class="objectivec hljs">func luckyNumberForName(name: String, <span class="hljs-meta"><span class="hljs-meta">#lotteryHandler: (String, Int) -&gt; String) -&gt; String { let luckyNumber = Int(arc4random() % 100) return lotteryHandler(name, luckyNumber) } luckyNumberForName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Mr. Roboto"</span></span></span><span class="hljs-meta">, lotteryHandler: {name, number in return </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\(name)'s' lucky number is \(number)"</span></span></span><span class="hljs-meta"> }) // Mr. Roboto's lucky number is 74</span></span></code> </pre><br><br>  In <i>Objective-C, the</i> use of blocks as parameters is very popular for <code>completion handler</code> management and <code>error handler</code> in methods with asynchronous operations.  It will also be popular in <i>Swift</i> . <br><br><h2>  Access Controls </h2><br><br>  Swift has three levels of access control: <br><br>  <b>Public</b> access makes it possible to use entities within any source file from a module in which these entities are defined, as well as in any source file from another module that imports a module in which these entities are defined.  Usually you use <b>public</b> access with the specification of the <b>public</b> interface for the framework. <br>  <b>Internal</b> access makes it possible to use entities inside any source file from a module in which these entities are defined, but in no other source file outside the module in which they are defined.  Usually you use <b>internal</b> access when defining the internal structure of an application or framework. <br>  <b>Private</b> access restricts the use of an entity to a file with the source code in which this entity is defined.  Using <b>private</b> access hides the implementation details of a specific piece of functionality. <br>  By default, each function and variable is <b>internal</b> - if you want to change this, you must use the keyword <b>private</b> or <b>public</b> before each individual method or variable: <br><br><pre> <code class="objectivec hljs">public func myPublicFunc() { } func myInternalFunc() { } private func myPrivateFunc() { } private func myOtherPrivateFunc() { }</code> </pre><br><br>  Coming from Ruby, I prefer to place my <b>private</b> functions at the bottom of my class, separated by a marker: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyFunClass { func myInternalFunc() { } <span class="hljs-comment"><span class="hljs-comment">// MARK: Private Helper Methods private func myPrivateFunc() { } private func myOtherPrivateFunc() { } }</span></span></code> </pre><br><br>  I hope that future releases of <i>Swift</i> will include the option of using one <b>private</b> keyword to indicate all of the methods below as <b>private</b> , just as access controls work in other programming languages. <br><br><h2>  "Special" types of return values </h2><br><br>  In <i>Swift</i> , function return types and values ‚Äã‚Äãcan be a bit more complex than we use in <i>Objective-C</i> , especially with the introduction of <code>Optionals</code> and multiple return types. <br><br><h3>  Optional return types </h3><br><br>  If there is a possibility that your function may return <code>nil</code> , you need to define the return type as <code>Optional</code> : <br><br><pre> <code class="objectivec hljs">func myFuncWithOptonalReturnType() -&gt; String? { let someNumber = arc4random() % <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> someNumber &gt; <span class="hljs-number"><span class="hljs-number">50</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"someString"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } myFuncWithOptonalReturnType()</code> </pre><br><br>  And, of course, if you use the <code>Optional</code> return value, then do not forget to "expand" it: <br><br><pre> <code class="objectivec hljs">let optionalString = myFuncWithOptonalReturnType() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let someString = optionalString { println(<span class="hljs-string"><span class="hljs-string">"The function returned a value: \(someString)"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { println(<span class="hljs-string"><span class="hljs-string">"The function returned nil"</span></span>) }</code> </pre><br><br>  The best explanation I have seen for the Optionals was taken from <a href="https://twitter.com/WestonHanners/status/496444128490967041">@Kronusdark:</a> <br><blockquote>  I finally got the @SwiftLang optionals that resemble <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D1%2582_%25D0%25A8%25D1%2580%25D1%2591%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25B3%25D0%25B5%25D1%2580%25D0%25B0">Schr√∂dinger</a> 's <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D1%2582_%25D0%25A8%25D1%2580%25D1%2591%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25B3%25D0%25B5%25D1%2580%25D0%25B0">cat</a> !  You should see if the cat is alive before you use it. </blockquote><br><br><h3>  Multiple return values </h3><br><br>  One of the most impressive features of <i>Swift</i> is the ability of a function to have multiple return values: <br><br><pre> <code class="objectivec hljs">func findRangeFromNumbers(numbers: Int...) -&gt; (min: Int, max: Int) { var min = numbers[<span class="hljs-number"><span class="hljs-number">0</span></span>] var max = numbers[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> numbers { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> number &gt; max { max = number } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> number &lt; min { min = number } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (min, max) } findRangeFromNumbers(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">234</span></span>, <span class="hljs-number"><span class="hljs-number">555</span></span>, <span class="hljs-number"><span class="hljs-number">345</span></span>, <span class="hljs-number"><span class="hljs-number">423</span></span>) <span class="hljs-comment"><span class="hljs-comment">// (1, 555)</span></span></code> </pre><br><br>  As we can see, the set of return values ‚Äã‚Äãis returned as a tuple, a very simple structure of grouped values.  There are two ways to use multiple return values ‚Äã‚Äãin a tuple: <br><br><pre> <code class="objectivec hljs">let range = findRangeFromNumbers(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">234</span></span>, <span class="hljs-number"><span class="hljs-number">555</span></span>, <span class="hljs-number"><span class="hljs-number">345</span></span>, <span class="hljs-number"><span class="hljs-number">423</span></span>) println(<span class="hljs-string"><span class="hljs-string">"From numbers: 1, 234, 555, 345, 423. The min is \(range.min). The max is \(range.max)."</span></span>) <span class="hljs-comment"><span class="hljs-comment">// From numbers: 1, 234, 555, 345, 423. The min is 1. The max is 555. let (min, max) = findRangeFromNumbers(236, 8, 38, 937, 328) println("From numbers: 236, 8, 38, 937, 328. The min is \(min). The max is \(max)") // From numbers: 236, 8, 38, 937, 328. The min is 8. The max is 937</span></span></code> </pre><br><br><h3>  Many Return Values ‚Äã‚Äãand Optionals </h3><br><br>  Confusion when returning a set of values ‚Äã‚Äãoccurs if the returned values ‚Äã‚Äãcan be <code>Optional</code> , but there are two ways to control this situation. <br><br>  My logic gives a "misfire" regarding the above function - if nothing is passed to the input, then my program will crash. <br>  If the values ‚Äã‚Äãto the input of the function are not passed, then I can make the entire return value Optional: <br><br><pre> <code class="objectivec hljs"> func findRangeFromNumbers(numbers: Int...) -&gt; (min: Int, max: Int)? { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> numbers.count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { var min = numbers[<span class="hljs-number"><span class="hljs-number">0</span></span>] var max = numbers[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> numbers { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> number &gt; max { max = number } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> number &lt; min { min = number } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (min, max) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let range = findRangeFromNumbers() { println(<span class="hljs-string"><span class="hljs-string">"Max: \(range.max). Min: \(range.min)"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { println(<span class="hljs-string"><span class="hljs-string">"No numbers!"</span></span>) } <span class="hljs-comment"><span class="hljs-comment">// No numbers!</span></span></code> </pre><br><br>   ,         (tuple) <code>Optional</code> ,  ,   <code>Optional</code>   : <br><br><pre> <code class="objectivec hljs">func componentsFromUrlString(urlString: String) -&gt; (host: String?, path: String?) { let url = <span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span>(string: urlString) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (url.host, url.path) }</code> </pre><br><br>   ,        <code>Optional</code> ,     ¬´¬ª,         <code>Optional</code> : <br><br><pre> <code class="objectivec hljs">let urlComponents = componentsFromUrlString(<span class="hljs-string"><span class="hljs-string">"http://name.com/12345;param?foo=1&amp;baa=2#fragment"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (urlComponents.host, urlComponents.path) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> let (.Some(host), .Some(path)): println(<span class="hljs-string"><span class="hljs-string">"This url consists of host \(host) and path \(path)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> let (.Some(host), .None): println(<span class="hljs-string"><span class="hljs-string">"This url only has a host \(host)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> let (.None, .Some(path)): println(<span class="hljs-string"><span class="hljs-string">"This url only has path \(path). Make sure to add a host!"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> let (.None, .None): println(<span class="hljs-string"><span class="hljs-string">"This is not a url!"</span></span>) } <span class="hljs-comment"><span class="hljs-comment">// This url consists of host name.com and path /12345</span></span></code> </pre><br><br>  Do you see?    ,   <i>Objective-C</i> ! <br><br><h3>   </h3><br><br>  <i>Swift</i>     : <br><br><pre> <code class="objectivec hljs">func myFuncThatReturnsAFunc() -&gt; (Int) -&gt; String { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"The lucky number is \(number)"</span></span> } } let returnedFunction = myFuncThatReturnsAFunc() returnedFunction(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">// The lucky number is 5</span></span></code> </pre><br><br>  ,     ,         : <br><br><pre> <code class="objectivec hljs">typealias returnedFunctionType = (Int) -&gt; String func myFuncThatReturnsAFunc() -&gt; returnedFunctionType { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"The lucky number is \(number)"</span></span> } } let returnedFunction = myFuncThatReturnsAFunc() returnedFunction(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">// The lucky number is 5</span></span></code> </pre><br><br><h3>   </h3><br><br>         ,   ,   <i>Swift</i>       : <br><br><pre> <code class="objectivec hljs">func myFunctionWithNumber(someNumber: Int) { func increment(var someNumber: Int) -&gt; Int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> someNumber + <span class="hljs-number"><span class="hljs-number">10</span></span> } let incrementedNumber = increment(someNumber) println(<span class="hljs-string"><span class="hljs-string">"The incremented number is \(incrementedNumber)"</span></span>) } myFunctionWithNumber(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">// The incremented number is 15</span></span></code> </pre><br><br>  <a href="https://habrahabr.ru/users/end/" class="user_link">end</a> <br>  <i>Swift</i>       .      <i>Swift</i> , :      .      ,      ! <br><br>           <i>Swift</i> ,     ,          .  ,  ,      <i>Swif</i> t,         <i>Swift</i> . <br><br>    <i>Swift</i> ! </div><p>Source: <a href="https://habr.com/ru/post/244487/">https://habr.com/ru/post/244487/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../244475/index.html">RTKLib - GPS / GLONASS centimeter accuracy in post-processing</a></li>
<li><a href="../244477/index.html">Web on pure java. Learn Vaadin - a cool web application framework</a></li>
<li><a href="../244479/index.html">Funny bugs</a></li>
<li><a href="../244481/index.html">A few words about working at home</a></li>
<li><a href="../244485/index.html">Sniff the output Tor node and analyze the resulting content.</a></li>
<li><a href="../244491/index.html">Looking for the perfect file storage</a></li>
<li><a href="../244493/index.html">Creating the game on your eyes - part 8: Visual scripting of cut scenes in Unity (uScript)</a></li>
<li><a href="../244497/index.html">Factory method without placement in dynamic memory</a></li>
<li><a href="../244505/index.html">Vectorization of cycles: diagnosis and control</a></li>
<li><a href="../244507/index.html">Equalization of histograms for image enhancement</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>