<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Kotlin, puzzlers and 2 Kekses: Are you sure you know how Kotlin behaves?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Initially, there was Java (well, not that at the very beginning ... but our story begins right here), time passed, and after about 20 years, the smart...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Kotlin, puzzlers and 2 Kekses: Are you sure you know how Kotlin behaves?</h1><div class="post__text post__text-html js-mediator-article">  Initially, there was Java (well, not that at the very beginning ... but our story begins right here), time passed, and after about 20 years, the smart guys from JetBrains designed and released Kotlin, a ‚Äúbetter‚Äù Java, universal language, understandable, powerful and transparent. <br><br>  At one time, Andrei <a href="https://habrahabr.ru/users/abreslav/" class="user_link">abreslav</a> Breslav said that Kotlin was developed as a convenient and predictable language.  At the same time the opinion was voiced that in this language you will not find puzzlers (short pieces of code, the results of which turn out to be unexpected, frightening or disappointing).  Well, Anton <a href="https://habrahabr.ru/users/antonkeks/" class="user_link">antonkeks</a> Keks conjured into IDEA and dug up some of it, moreover, he told about his findings together with Philip Keks in good examples.  See for yourself: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mKnY_uI3Z9Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Under the cut - a selection of such puzzlers and detailed comments to them.  The material is based on the report by Anton Keks (Codeborne) and Philip Keks (Creative mobile) at the <a href="http://2017.mobiusconf.com/">2017 Mobius</a> conference <a href="http://2017.mobiusconf.com/">(St. Petersburg)</a> . <br><a name="habracut"></a><br>  Let's start with Kotlin.  Everyone says that there are a lot of problems in Java: there are a lot of volcanoes on the island, there are earthquakes.  She needs to be saved. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cc/f5/59ccf540452ce749063272.jpeg"></div><br>  Therefore, another island comes to mind - Kotlin. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cd/00/59cd0075db1af556127505.jpeg"></div><br>  There is calm, nothing happens.  It is very flat, no volcanoes.  Located here nearby.  Therefore, Kotlin is a savior of Java, especially for Android developers like us. <br><br><h2>  A few words about Kotlin </h2><br>  What is Kotlin, here more or less everyone knows.  Because what fool today writes under Android without Kotlin?  This, I think, is masochism.  It works great.  A couple of weeks ago came the first build of Kotlin native.  Soon, perhaps, we will write on Kotlin under iOS. <br><br>  This is a pragmatic language, open-source, a very cool tooling - it was designed to make the IDE work well.  This is a stone in the garden of Apple-ovsky language Swift and others like him.  JetBrains is good push-it Kotlin - specially designed the language for your IDE. <br><br>  We all know that Kotlin was developed for a very long time.  Six years passed before version 1.0 was released.  JetBrains tried very hard, but apparently it‚Äôs not so easy to make a new language.  Over the past years (2010 - 2016), they even managed to change the logo to a more modern one. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/474/499/173/474499173253787f1acdf17f31527df9.png"></div><br>  Considering how long it was developed, the language must be excellent.  It should be the best language in the world, as many other languages ‚Äã‚Äãhave developed much faster.  For example, we all know that JavaScript was made in two weeks.  Although, this, of course, is not rocket science (rocket science is SpaceX, which in four years learned to sit on a platform on a real rocket). <br><br>  And most importantly, you should all be proud, because Kotlin is being developed in St. Petersburg, and this is one of the few Russian programming languages.  Old Russian programming languages ‚Äã‚Äãlooked something like this (right): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cc/581/af0/3cc581af06474030526075ac39ac9cf9.png"></div><br>  Fortunately, this language was aimed at an international audience, so instead of the keyword ‚Äúfu‚Äù, its creators still decided to use keyword fun, over which everything was ‚Äúmaking fun‚Äù.  So this is a fun language. <br><br><h2>  Jigsawners </h2><br>  What are jigsaw puzzles? <br><br>  These are short programs written in Kotlin, with interesting behavior.  And you will guess what they are typing.  You will vote for the suggested answers, and the one who first raises his hand and not only guesses the correct option, but also explains why this happens, will receive a prize. <br><br>  The first half of the gigs are targeted at those who are not very familiar with Kotlin;  the second half is for hardcore Kotlin developers. <br><br>  Kotlin is known for not repeating some well-known Java puzzle gamers.  However, in an ideal programming language there should be no puzlers at all.  It turns out that Kotlin is not perfect either - there are no perfect languages. <br><br>  But Kotlin has already taken off in many mobile applications.  This language was created as pragmatic and convenient in many cases.  It is also convenient in terms of usability.  And it is still developing.  You can talk with Kotlin developers and try to agree on how and what to fix. <br><br>  All of the demonstrated jigsawners run with Kotlin 1.1.1 - with the latest stable version.  The source codes of the gushers are on GitHub - then you can see them: <a href="https://github.com/angryziber/kotlin-puzzlers/tree/mobius">https://github.com/angryziber/kotlin-puzzlers/tree/mobius</a> . <br>  Who will have the ideas of new puzlers, send pull-requests.  We wait. <br><br><h2>  Pasler 1 </h2><br>  Kotlin is good because he supports nullability, more precisely, he is null safe - so to speak. <br><br><pre><code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> p1_nullean <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> s: <span class="hljs-type"><span class="hljs-type">String</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s?.isEmpty()) println(<span class="hljs-string"><span class="hljs-string">"true"</span></span>)</code> </pre> <br>  It has differences between nullable and non-nullable types.  This means that if we want to assign a null somewhere, it must be a nullable type (with a question).  Probably, this idea was proposed by C #, but he did not finish it - there only primitives can be nullable.  And in Kotlin, this is already done normally for all types.  Basically, the language is designed so that you never get a terrible NullPointerException in runtime. <br><br>  In this example, Kotlin took over from Groovy an excellent null-safe operator s ?, which allows you to call some method at zero and not to shake any exceptions right away in runtime. <br><br>  Let's see which of the possible options we get now: <br><br><ul><li>  nothing <br></li><li>  true <br></li><li>  NullPointerException <br></li><li>  Will not compile <br></li></ul><br>  We start.  We look. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/12a/793/cd1/12a793cd12a734f499ca6cddb4b9f8cd.png"><br><br>  Not compiled. <br><br>  Why? <br><br>  Kotlin is a type safe language, so the result of the expression s? .IsEmpty () is null, so it does not cast to false. <br><br>  It is easy to fix (it is necessary to write in such a way that Kotlin behaves in the same way as Groovy): <br><br><pre> <code class="hljs lisp">if (<span class="hljs-name"><span class="hljs-name">s</span></span>?.isEmpty() ?: false) println(<span class="hljs-string"><span class="hljs-string">"true"</span></span>)</code> </pre><br>  It is not very beautiful, but now it is.  In Kotlinovsky tracker, the proposal has nevertheless been taken to still interpret null as false, but there are some nuances there.  It is not yet known whether we will ever get this feature or not.  There are different opinions, but in terms of ease of use of the language is a small joint. <br><br><h2>  Pasler 2 </h2><br>  Pazler is very similar: we have the same nullable string variable and we are trying to call the method on it. <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> p2_nulleanExtended <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: <span class="hljs-type"><span class="hljs-type">String</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> print(x.isNullOrEmpty())</code> </pre><br>  What will be the result? <br><br><ul><li>  true <br></li><li>  false <br></li><li>  NullPointerException <br></li><li>  will not compile <br></li></ul><br>  Running ... <br>  Answer: true. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6be/90a/0f6/6be90a0f6bf444b55d0210b30f8b6561.png"><br><br>  Why?  This is an extension-function from the standard Kotlin library, which is ‚Äúhung‚Äù on the nullable CharSequence.  Therefore, in a similar case, it is processed normally. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/af7/2d1/c7f/af72d1c7fd768383ebb737ee4073cfc8.png"><br><br>  Indeed, in Kotlin, you can run some functions on null.  The compiler knows this and allows it. <br><br>  If we put a question mark, IDEA would tell us that it is not needed here. <br><br><pre> <code class="hljs lisp">print(<span class="hljs-name"><span class="hljs-name">x</span></span>?.isNullOrEmpty())</code> </pre><br>  It is good that the function is named humanly (the result can be guessed by name). <br><br>  If run in the second variant (with a question mark), the result will be null, because the expression in brackets is now given in null, and then this function is not called, despite the fact that it supports null.  This, by the way, is another passer. <br><br><h2>  Pasler 3 </h2><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> p3_platformNulls <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kotlin</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = print(<span class="hljs-string"><span class="hljs-string">"Hello </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$name</span></span></span><span class="hljs-string">"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> prop = System.getProperty(<span class="hljs-string"><span class="hljs-string">"key"</span></span>) Kotlin().hello(prop) }</code> </pre><br>  In Kotlin there is such an interesting feature - the third state of nullability.  Let's see what happens if we call: <br><br><pre> <code class="hljs pgsql">val prop = <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.getProperty("key")</code> </pre><br>  and pass it to the hello method of the Kotlin class, which should print it: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Kotlin</span></span>()<span class="hljs-selector-class"><span class="hljs-selector-class">.hello</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">prop</span></span>)</code> </pre><br>  What will be the output? <br><br><ul><li>  hello <br></li><li>  hello null <br></li><li>  will not compile <br></li><li>  none of the above options <br></li></ul><br>  In general, type inference is a great topic. <br><br>  We start.  We get IllegalStateExeption. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/38a/ae2/a3a/38aae2a3a3731e6386188cfc96133383.png"><br><br>  Why? <br><br>  The value of prop will be null, the type is String! .. It goes to hello, and in runtime there will be a check that it should not be null, but it should be null. <br><br>  In fact, in the initial version of Kotlin they really did that when a String comes from Java, it is always nullable by default. <br><br><pre> <code class="hljs swift">val prop: <span class="hljs-type"><span class="hljs-type">String?</span></span> = <span class="hljs-type"><span class="hljs-type">System</span></span>.getProperty(<span class="hljs-string"><span class="hljs-string">"key"</span></span>)</code> </pre><br><br>  This led to the fact that it became very inconvenient to write code when interop with Java was being implemented.  And they decided to make a virtual type String!  (with an exclamation mark).  This is the third option nullability - called "I do not know." <br><br><pre> <code class="hljs swift">val prop: <span class="hljs-type"><span class="hljs-type">String!</span></span> = <span class="hljs-type"><span class="hljs-type">System</span></span>.getProperty(<span class="hljs-string"><span class="hljs-string">"key"</span></span>)</code> </pre><br>  However, such code is not compiled because the type is String!  can not be declared independently.  It can only come from Java. <br><br>  Therefore, it is better to pre-declare such things as nullable or not nullable (as a rule, you from the API know if null can ever come there or not). <br><br>  But such code will compile, but may fall in runtime: <br><br><pre> <code class="hljs pgsql">val prop: String = <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.getProperty("key")</code> </pre><br>  IDEA always knows where what type.  You can click on the variable Ctrl + q and find out. <br>  But let's finish with nullability, let's move on to another topic. <br><br><h2>  Pasler 4 </h2><br>  We have 2 functions that should print.  We announce and launch them - everything should be simple: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> p4_kotlinVsScala <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = print(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = { print(<span class="hljs-string"><span class="hljs-string">"Hello2"</span></span>) } main1() main2()</code> </pre><br>  What will be the output? <br><br><ul><li>  Hello <br></li><li>  Hello2 <br></li><li>  HelloHello2 <br></li><li>  will not compile <br></li></ul><br>  We start ... We receive Hello. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/56f/11a/ccb/56f11accb80e84979baeed8eb3e9bdfb.png"><br><br>  Why? <br><br>  Main1 will return a unit, but will call print ("Hello").  And main2 just returns the lambda, which will not be executed. <br><br>  You can fix it like this: <br><br><pre> <code class="hljs lisp">main2()()</code> </pre><br>  The second, in my opinion, the best fix is ‚Äã‚Äãto remove the equal sign from main2, because it only confuses everyone: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { print(<span class="hljs-string"><span class="hljs-string">"Hello 2"</span></span>) }</code> </pre><br>  Why did I call this example Kotlin vs Scala?  Those who wrote on Scala know that there this code is an absolutely valid declaration of a function that returns something: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = { }</code> </pre><br>  Poor Scala-developers who will write on Kotlin.  They probably will constantly return lambda without running. <br><br><h2>  Pasler 5 </h2><br>  We have a list of numbers, we iterate over it with the forEach method.  ForEach, as in Groovy, if the lambda parameter is not declared, knows it.  And we check that it is no more than 2, and we print. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> p5_sneakyReturn <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { listOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>).forEach { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> print(it) } print(<span class="hljs-string"><span class="hljs-string">"ok"</span></span>) }</code> </pre><br>  What will be the result? <br><br><ul><li>  123ok <br></li><li>  12ok <br></li><li>  12 <br></li><li>  endless cycle <br></li></ul><br>  Running ... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e30/e89/312/e30e8931299bde0d73915d39fd297663.png"><br><br>  12 <br>  What kind of nonsense? <br><br>  In Kotlin, return returns from a function.  And in order to get out of a specific lambda, inside this function you need to specify the name of the lambda after return: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span><span class="hljs-symbol"><span class="hljs-symbol">@forEach</span></span></code> </pre><br>  So you can get out of the lambda.  If you are writing in Java and you really need to get out of lambda, this is an option to correct the code. <br><br>  In fact, the return in Kotlin works the way it should work.  If we hadn‚Äôt written in C # and Java before, we probably wouldn‚Äôt have made a mistake, because return is returned from the main function.  Everything is logical.  And there are no strange features with lambdas, from which, too, for some reason you need to exit. <br><br>  Why does this work like this? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b79/1e8/5aa/b791e85aa58e71fa8ae0a9aa3544ea22.png"><br><br>  The forEach function is declared as an inline function.  In Kotlin, the compiler does not call this function in the compiled code, but takes the code of this function and inserts it into the place where the call was.  As a result, the usual for-loop is obtained here and, naturally, then return exits the main function. <br><br>  How to understand that this is an inline function?  First, in IDEA there is Ctrl + p.  And secondly, if you call return, and the function is not inline, the compiler will say: "Sorry, you can not do this."  That is, the compiler does not allow us to do some nonsense. <br><br>  There is another option, how to fix this code so that it returns ‚Äú12ok‚Äù.  It is necessary to declare it as a function, not lambda. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { listOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>).forEach(<span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> print(it) }) print(<span class="hljs-string"><span class="hljs-string">"ok"</span></span>) }</code> </pre><br>  The only difference in Kotlin with an anonymous function and lambda is that the first one behaves exactly like a function, which means that return will return from the nearest ‚Äúfun‚Äù (fun).  Therefore, with such a fix, it will work as it should. <br><br>  To make it even more interesting, I prepared several examples.  In Kotlin there are different keywords: <br><br><ul><li>  fun <br></li><li>  inline fun <br></li><li>  inline fun with lambda noinline <br></li><li>  inline fun with lambda crossinline <br></li></ul><br>  Some of them allow you to use return, and some do not. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> p5_sneakyReturn <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: ()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = block() <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">helloInline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: ()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = block() <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">helloNoInline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">noinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> block: ()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = hello(block) <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">helloCrossInline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> block: ()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = runnable { block() }.run() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { hello { println(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//return - impossible } hello(fun() { println("hello") return }) helloInline { println("hello") return } helloNoInline { println("hello") //return - impossible } helloCrossInline { println("hello") //return - impossible }</span></span></code> </pre><br>  With homework we leave the wish to understand what Crossinline is.  I think you will be interested. <br><br>  When I first started writing on Kotlin, I also thought that it was something complicated.  But when you understand what an inline function is (almost all the extension functions for the collection are Inline for performance), everything becomes very logical. <br><br><h2>  Pasler 6 </h2><br>  We need to get John or Jaan. <br><br>  We have a simple Person class.  In Kotlin it is very convenient: you can declare the constructor immediately after the class declaration.  We get the constructor variable name, hammer it into the property.  In Kotlin, there is no field - there is only property, which is very cool, since you do not need to write getters, setters, and all nonsense (or gets and sets, as in C #).  Great beautiful syntax. <br><br>  As a result, we create a Person with the name John and see if it will turn into the Estonian localization of Jaan: <br><br><pre> <code class="hljs pgsql">package p6_getMeJohn <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Person(<span class="hljs-type"><span class="hljs-type">name</span></span>: String) { var <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-type"><span class="hljs-type">name</span></span> == "John") "Jaan" <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> } println(Person("John").name)</code> </pre><br><ul><li>  John <br></li><li>  Jaan <br></li><li>  will not compile <br></li><li>  none of the options <br></li></ul><br>  Running ... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/98f/ace/0c8/98face0c80246ce47a683e4196b919a8.png"><br><br>  This is a stack overflow. <br>  Why? <br>  We take the name, make it an if-else and call it by get.  To fix, you need to refer to the field, and not to the property.  You can use a keyword field: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Person(<span class="hljs-type"><span class="hljs-type">name</span></span>: String) { var <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (field == "John") "Jaan" <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> field }</code> </pre><br>  According to keyword field in Kotlin, you can refer to the field, but the only place where this can be done is inside the getter / setter.  All other calls go only through property - they don‚Äôt apply directly to the field. <br><br>  It is said that the performance is all cool, because the Java Hotspot compiler optimizes this well, unlike the .NET virtual machines, and everything works very fast. <br><br><h2>  Pasler 7 </h2><br>  Again, we look at the awesome feature of the language - type inference - we don‚Äôt care what type of whatAmI we can use it anyway.  But the compiler knows what it is.  See if we know. <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> p7_whatAmI <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> whatAmI = {}() println(whatAmI)</code> </pre><br>  What option will be in the end? <br><br><ul><li>  kotlin.jvm.functions.Function0 <br></li><li>  () -&gt; kotlin.Unit <br></li><li>  kotlin.Unit <br></li><li>  nothing <br></li></ul><br>  Run ... Get kotlin.Unit. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b63/748/62b/b6374862b73ca7f57db3d72fd7922c1e.png"><br><br>  Why? <br><br>  Here lambda is declared, then lambda is called.  Since lambda does not return anything (more precisely, it returns kotlin.Unit), this is exactly what is output.  And the best definition of a unit is void. <br><br>  Where did Unit come from?  In my opinion, even in mathematics (or in computer science) there is such a thing as type theory.  And there it is described that Unit is one element, which means ‚Äúnothing‚Äù.  Therefore, some more academic programming languages ‚Äã‚Äãuse the term Unit.  Kotlin was zadizaynen as a pragmatic language, but, nevertheless, its developers decided to choose not a pragmatic void, but invented to make the Unit. <br><br>  To make it even more interesting, there is one more type in Kotlin: kotlin.Nothing. <br>  What is the difference?  Let the answer to this question be your homework. <br><br><h2>  Pasler 8 </h2><br>  We looked at whatAmI, and now we will have iAmThis. <br><br>  Everything is a little more complicated here: we have the IAm class, it is the data class (this is an awesome feature in Kotlin, which automatically generates equal, hashCode, toString for us, and all this boiler plate, which we all so hate to write in Java).  In Scala, this is the case class - the name is worse for this, although in fact everyone uses it as a data class. <br><br>  The class IAm has a constructor in which we declare the foo field.  Foo is a property at the same time, so it can be used with the hello () function. <br><br>  We pass the String ‚Äúbar‚Äù there, call the hello function and see what it returns to us. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> p8_iAmThis <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAm</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo: String) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = foo.apply { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> } } println(IAm(<span class="hljs-string"><span class="hljs-string">"bar"</span></span>).hello())</code> </pre><br>  What we get at the output? <br><br><ul><li>  IAm <br></li><li>  IAm (foo = bar) <br></li><li>  bar <br></li><li>  will not compile <br></li></ul><br>  Run ... Get the bar <br><br><img src="https://habrastorage.org/getpro/habr/post_images/850/cba/b0e/850cbab0e686bf9b463970c441f84e0b.png"><br><br>  Why? <br><br>  Apply is a clever extension-function.  It takes lambda and allows inside it with the object on which it is called to perform some actions on this.  Accordingly, this is bar.  And Hello is bar. <br><br>  This Kotlin is similar to JavaScript.  As in JavaScript, in Kotlin you can reach the state where you no longer know what this is. <br><br>  Generally there are many useful features: also, let, with. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/957/ffc/599/957ffc5998976612a8e3e56a65ce0d7a.png"><br><br>  In principle, they all differ quite a bit. <br><br>  For example, apply is an extension-function for absolutely any type (not nullable).  It takes lambda, and lambda is very tricky, because it is applied to the inner T, and not to the outer object (it has its T inside this lambda).  Those.  the function calls this lambda with its this and returns this (this is sometimes also useful). <br><br>  There are other features.  The code can be corrected as follows: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> p8_iAmThis <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAm</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo: String) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = foo.let { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> it } } println(IAm(<span class="hljs-string"><span class="hljs-string">"bar"</span></span>).hello())</code> </pre><br>  Then it may be less incomprehensible. <br><br>  For some cases, Apply is a very useful feature.  But if you look at the code very quickly (and at the same time the first variant of the record is used), you can get confused. <br><br>  In the first variant, you can shorten the code like this (the apply function also returns this itself, so nothing changes): <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAm</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo: String) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = foo.apply { } }</code> </pre><br><h4>  Pasler 9 </h4><br>  Let's look at the let function already known to us. <br><br>  This puzzle sent by Kevin Most from Canada.  It has a simple function that prints the sign of the argument (Int). <br><br><pre> <code class="hljs pgsql">package p9_weirdChaining // <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> Kevin Most @kevinmost fun printNumberSign(num; <span class="hljs-type"><span class="hljs-type">Int</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { "negative" } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { "positive" } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { "zero" }.let { println(it) } } printNumberSign(<span class="hljs-number"><span class="hljs-number">-2</span></span>) printNumberSign(<span class="hljs-number"><span class="hljs-number">0</span></span>) printNumberSign(<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre><br>  What kind of code will print? <br><br><ul><li>  negative;  zero;  positive <br></li><li>  negative;  zero <br></li><li>  negative;  positive <br></li><li>  zero;  positive <br></li></ul><br>  We start ... At the exit - zero;  positive. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d5f/219/51e/d5f21951ef6c123b9eab36a338a3a36f.png"><br><br>  What is the matter? <br><br>  If is actually an expression.  That is, two expressions are obtained, and let applies only to the second. <br><br>  I wrote a lot on Kotlin, but this puzzle was not decided by myself.  This is a hell of a topic.  At the previous JPoint conference, we even thought it was a bug in the compiler.  But I asked Andrei Breslav, and it turned out that this is just a parser nuance. <br><br>  How to fix?  Easy - just put the brackets: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printNumberSign</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num; </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-string"><span class="hljs-string">"negative"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-string"><span class="hljs-string">"positive"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-string"><span class="hljs-string">"zero"</span></span> }).let { println(it) } }</code> </pre><br>  Then let is applied to the result of the entire expression.  And in the first case, the code worked like this: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printNumberSign</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num; </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-string"><span class="hljs-string">"negative"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-string"><span class="hljs-string">"positive"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-string"><span class="hljs-string">"zero"</span></span> }).let { println(it) } }</code> </pre><br>  In this case, the top expression goes separately - the let function is not applied to it. <br>  There is no operator elseif in Kotlin (if it were, then this puzzleman wouldn't exist). <br><br>  As with all puzzles, the moral is: don't write such code.  If you want to do something complicated (like here), be sure to put brackets or put it in a variable and then call let. <br><br><h2>  Pasler 10 </h2><br>  Even more interesting puzzler.  There is a lot of code. <br><br>  This passer Zababmittil Daniel Vodopyan.  This is a very cool feature in Kotlin - delegate properties.  In Kotlin, we can declare, for example, that there are several properties in the class, and they are implemented not as a field, but as a lukap from the map. <br><br>  We have a class Population - population.  And cities sends us (var cities: Map &lt;String, Int&gt;) and we delegate them to this map. <br><br>  This actually allows you to turn Kotlin into JavaScript and make more dynamic structures without copying data back and forth.  Such classes reduce a lot of code. <br><br>  Then we create an instance of the class Population and pass it to all cities population. <br><br>  Now imagine that many years have passed.  People have dirtied the Earth - flew to live on Mars.  Therefore, we reset the map with the population. <br><br>  There is a function with, which we looked at before.  It takes the population and resolves the available fields with respect to it (in principle, in the same way as apply). <br><br><pre> <code class="hljs pgsql">package p10_mappedDelegates // <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> Daniil Vodopian @voddan <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Population(var cities: Map&lt;String, <span class="hljs-type"><span class="hljs-type">Int</span></span>&gt;) { val tallinn <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> cities val kronstadt <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> cities val st_petersburg <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> cities } val population = Population(mapOf( "st_petersburg" <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>_281_579, "tallinn" <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">407</span></span>_947, "kronstadt" <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">43</span></span>_005 )) // Many years have passed, now <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> humans live <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> Mars population.cities = emptyMap() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>(population) { println("$tallinn; $kronstadt; $st_petersburg") }</code> </pre><br>  Everything is easy.  It remains only to understand what will happen to our Earth when everyone flies to Mars.  What does this code give out? <br><br><ul><li>  0;  0;  0 <br></li><li>  407947;  43005;  5281579 <br></li><li>  NullPointerException <br></li><li>  NoSuchElementException <br></li></ul><br>  We are launching ... It turns out that humans have not disappeared anywhere (life on Mars is very difficult, so we will most likely stay on Earth). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d91/fcb/514/d91fcb514f33428c0c139fae24bcc07e.png"><br><br>  Why? <br><br>  It is not true to say that population.cities = emptyMap () will make an empty map for the class, but not for its instance.  If we change the code like this (let's make MutableMap and reset Kronstadt - population.kronstadt = 0): <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Population</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cities: MutableMap&lt;String, <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tallinn <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> cities <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> kronstadt <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> cities <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> st_petersburg <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> cities } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> population = Population(mutablemapOf( <span class="hljs-string"><span class="hljs-string">"st_petersburg"</span></span> to <span class="hljs-number"><span class="hljs-number">5_281_579</span></span>, <span class="hljs-string"><span class="hljs-string">"tallinn"</span></span> to <span class="hljs-number"><span class="hljs-number">407_947</span></span>, <span class="hljs-string"><span class="hljs-string">"kronstadt"</span></span> to <span class="hljs-number"><span class="hljs-number">43_005</span></span> )) <span class="hljs-comment"><span class="hljs-comment">// Many years have passed, now all humans live on Mars population.kronstadt = 0</span></span></code> </pre><br>  The code will display: 407947;  0;  5281579 <br><br>  But we are still discussing the first option (c population.cities = emptyMap ()). <br><br>  When we execute the delegate, the reference to the map is remembered inside the getter (for each of them).  And if we change the reference to cities, this does not change the links inside the getters.  But we can even put another in the map in the map, and everything will work, since it still remains a link to the same map.  But if we change the reference to another map, then it ceases to act. <br><br><h2>  Pasler 11 </h2><br>  We in Estonia have an excellent saying: ‚ÄúA good child has many names.‚Äù <br><br>  Let's see how this applies to our classes. <br><br>  In Kotlin there is such a strange nuance: the default classes are final - they cannot be extended.  There is a keyword open, which still allows them to extend. <br><br>  In this C class puzzler, we have an open method (too, so that we can trust it).  Here we take x and y (they have default values ‚Äã‚Äã- this is a very cool feature in the language). <br><br>  We have class D, which extende class C and override the sum function, but in principle does not do anything useful, except for what causes super-implementation. <br><br>  Next we have the variable d - we create an instance of class D;  we have a variable c and there we assign the same instance (we get 2 references to the same instance of class D).  And we call the same method essentially on the same object. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> p11_goodChildHasManyNames <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, y: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = x + y } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.sum(x, y) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> d: D = D() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> c: C = d print(c.sum(x = <span class="hljs-number"><span class="hljs-number">0</span></span>)) print(d.sum(x = <span class="hljs-number"><span class="hljs-number">0</span></span>)) println()</code> </pre><br>  What we get in the end? <br><br><ul><li>  22 <br></li><li>  eleven <br></li><li>  21 <br></li><li>  will not compile <br></li></ul><br>  We start ... The correct answer is 21. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/96d/6d1/5e9/96d6d15e91b57bbece3ed1fb0707dd8b.png"><br><br>  There are still some warning signs that help you understand what is happening. <br><br>  In both cases, an over-defined function is called because of polymorphism.  In runtime, which function is called, because in reality both c and d are instances of class D. But since the JVM does not have such features as nominal parameters, the compiler-time compiler solves them.  Those.  it turns out that the function is selected and called in runtime, and the parameters are selected in the compile-time.  Therefore, what parameters it substitutes depends on the type of the variable, and not on the object resulting in runtime.  This is a cant.  Warning ‚Äî and warn that your names should not be confused ‚Äî when you override a function, it should be called differently. <br><br>  The good news is that for about half of the submitted puzlers in IDEA, there is already a warning.  Due to the fact that JetBrains themselves are also engaged in tools, they are quite good in helping to avoid many mistakes.  But not all.  For some of the puzzlers, warning is simply impossible to do. <br><br>  However, the language develops.  In 2016, when I first started writing on it, there were far fewer inspections at IDEA and it was much easier for these puzzles to get their hands on it.  Now the situation is completely different: version 1.1 has been released, there have been many patch releases, many inspections have been added to IDEA, and it is now very easy to write on Kotlin correctly. <br><br>  Instead of a conclusion I want to say: go to Kotlin. <br><br><ul><li>  Under Android, there is still no normal Java 8, and in Kotlin you get all the features of Java 8 and even more.  You can express yourself much better. <br></li><li>  Kotlin - a language without a big HYIP.  This is also his plus. <br></li><li>  It is often called ‚ÄúSwift‚Äù for Android.  But there is a small problem with Swift - when a new version comes out, you have to constantly rewrite all the code.  With Kotlin, there is no such problem - we are promised backward compatibility, as well as source-level, and binary-level. <br></li><li>  Kotlin compiles much faster than Scala.  It is much easier Scala. <br></li><li>  It is much faster in runtime than Groovy.  If you add your application on Android, the size in my opinion increases by only 600 KB compared to Java - and this is very small compared to Scala.  Therefore, it makes sense to write on it. <br></li><li>  When I switched to it, I started to be productive from day one. <br></li><li>  They say about Kotlin that this is ‚Äúbetter Groovy‚Äù, there are some good features. <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And your most important friend in IDEA is Ctrl + Alt + Shift + K, which will convert any Java class directly into Kotlin (as is). </font><font style="vertical-align: inherit;">There is no Ctrl + Alt + Shift + J, so you can not go back - this is the one way road. </font><font style="vertical-align: inherit;">Yes, you do not want to come back.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Also passes gradle. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Send us new puzzles so that we can have fun at the next conferences. </font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you like the programming interior just as we do, and you want to immerse yourself in Kotlin more thoroughly, we recommend paying attention to these reports that will be at the upcoming </font></font><a href="https://mobiusconf.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mobius 2017 Moscow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> conference </font><font style="vertical-align: inherit;">:</font></font><br><ul><li>  <a href="https://mobiusconf.com/2017/msk/talks/jslrnocqzieusmswmg0w0/">We write Java-friendly Kotlin-code</a> (Sergey Ryabov, Independent) <br></li><li> <a href="https://mobiusconf.com/2017/msk/talks/7tt1i72eu0wkyywykuuuuw/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data Binding in a Kotlin world</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Lisa Wray, New York Times)</font></font><br></li><li> <a href="https://mobiusconf.com/2017/msk/talks/4iprilrwsawge2e488yeis/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Universal links - the palace of the pitfalls</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Konstantin Yakushev, Badoo)</font></font><br></li></ul></div><p>Source: <a href="https://habr.com/ru/post/338924/">https://habr.com/ru/post/338924/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338912/index.html">From the life of werewolves</a></li>
<li><a href="../338914/index.html">Sugar Javascript</a></li>
<li><a href="../338918/index.html">Indeed, what is a CRM system?</a></li>
<li><a href="../338920/index.html">DevFest North in St. Petersburg on September 30</a></li>
<li><a href="../338922/index.html">Simulate Mixed Circuits on System Verilog</a></li>
<li><a href="../338926/index.html">Computer vision. Intel Expert Answers</a></li>
<li><a href="../338928/index.html">In Search of Performance, Part 2: Java Profiling for Linux</a></li>
<li><a href="../338930/index.html">V8 under the hood</a></li>
<li><a href="../338932/index.html">React v16.0 released</a></li>
<li><a href="../338934/index.html">Prototype cheat ASO promotion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>