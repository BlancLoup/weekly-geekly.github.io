<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Do not be afraid of microservice: Alexey Baitov on the use of microservice architecture in practice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For some, microservices are an opportunity to remake and refactor an application into a conditionally modern style. For others, this architectural sol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Do not be afraid of microservice: Alexey Baitov on the use of microservice architecture in practice</h1><div class="post__text post__text-html js-mediator-article">  For some, microservices are an opportunity to remake and refactor an application into a conditionally modern style.  For others, this architectural solution is not suitable because of the peculiarities of interaction between different parts of the application.  In any case, choosing the architecture, it is useful to study someone else's experience of moving from a monolith to a set of services. <br><br>  We asked to share our case study of the development and delivery of microservices Alexey Baitov, a leading engineer of 2GIS.  Let's talk about architectural solutions, deployment and scalability.  Let's ask about trend and just convenient tools for work. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f87/346/860/f8734686085fb6cf3580ff6fa636e8bf.jpg"><br><a name="habracut"></a><br>  <b>- Alexey, please tell us a little about yourself and about your team at <a href="https://habr.com/company/2gis/">2GIS</a> .</b>  <b>What are you working on now?</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/gk/aa/_8/gkaa_8zwcfej8txrfq901zub1qs.jpeg" align="left">  I came to IT back in 2003 as a system administrator, plunged into development in 2011.  During this time, I worked on PHP, JavaScript, implemented a series of RESTful services and a Python driver for Git.  I have been working in 2GIS since 2015. <br><br>  Participated in the development of two microservice architectures.  The first consisted of one service.  It was an asynchronous reverse proxy with a cache.  In fact, he was engaged in sending messages.  I worked on the requirements, the development and construction of DevOps alone, but I was helped by experts from our company 2GIS. <br><br>  The service was written on Go.  The quick compilation made it possible not to wait, and I was able to concentrate on Continuous Deployment.  Then we just started to use <a href="https://about.gitlab.com/features/gitlab-ci-cd/">GitLab CI</a> , <a href="https://prometheus.io/">Prometheus</a> , <a href="https://grafana.com/">Grafana</a> and <a href="http://deis.io/">Deis</a> (open source analogue of <a href="https://www.heroku.com/">Heroku</a> ).  We have the Infrastructure and Operations team, which just at the time of my development brought all these infrastructure solutions to production ready level.  I decided to try all this and successfully implemented an independent microservice. <br><br>  Two years ago, I moved to another team on a new project, where I became involved in functional programming on Scala.  Our team from scratch has developed a microservice architecture for the storage of promotional materials 2GIS on Scala, C # and JavaScript.  I laid the foundation of all the tools and experience for building DevOps (Continuous Deployment and Maintenance) practices.  The architecture has gone from prototype to industrial exploitation.  She swallowed two monoliths, now consists of 15 services and is constantly expanding. <br><br>  <b>- Do you agree that microservices are essentially a set of independently deployed services that have common characteristics, that is, it is a set of certain features that gives them the appearance of microservice?</b>  <b>This definition needs to be expanded?</b>  <b>Or, in fact, companies understand the microservice architecture differently?</b> <br><br>  I like the following <a href="http://microservices.io/">definition</a> .  Microservice architecture is an architectural style that structures an application as a collection of loosely coupled services that implement a certain business logic.  Services in the microservice architecture may not have common characteristics, but are combined within the framework of a common business logic. <br><blockquote>  Of course, each company will have its ‚Äúown‚Äù microservice.  This is a set of practices: distributed architecture, continuous integration and delivery, and so on.  If you expand the concept of practice to the tools used, the implementation of microservices will be very diverse. </blockquote>  <b>- There are different opinions about the composition of the team, which should be involved in the writing and support of microservices.</b>  <b>What do you think about it?</b>  <b>What is the optimal team size and how should the interaction be built inside it when developing a microservice architecture?</b>  <b>Is there a good example of teamwork from your practice?</b> <br><br>  It is considered correct to develop a service so that its entire subject area can fit in the head of one developer.  At the same time several people can participate in the development of this service.  This will help avoid the bus factor when the developer went on vacation or fell ill.  Correct splitting into services allows a new person to quickly enter the context. <br><br>  "Microservice architecture" tells us that it often includes several services.  Thus, one developer can not do.  Microservice architecture is based on the product model (or general business logic).  Developers are selected to implement this model and at the same time focus on the client. <br><br>  Focusing on the client is organized by direct contact of the developer with the client.  Developers need to see how their product is used.  From this already follow the wishes for knowledge in the technological field, the ability to deliver the product to the client as soon as possible and to accompany the product. <br><br>  It‚Äôs hard to say for sure about the number of teams.  Everyone probably already knows the statement of Jeff Bezos, the founder of Amazon, that the size of the team for service-oriented development should be small enough so that everyone can be fed with two pizzas.  In the comments on Habr√© there was a discussion on this topic, and there they wrote that one person may not have enough of one pizza and therefore the team should consist of one or two people.  Martin Fowler, quoting a statement about two pizzas, said that we are talking about big American pizzas, after which he clarified that the team should not be 50, but around 12 people.  I believe that everything depends on the product model.  But the clarification of Fowler about "no more than 12 people" in my practice so far has won.  I noticed that within the team it is desirable to divide by technological interests, find like-minded people. <br><br>  It is not necessary that everyone in the team be well aware of all the technological areas used in the work, but the overall knowledge of the team must be uniformly deep.  For example, two people are engaged in the initial building of deployment, and in the future, most likely, they will also significantly improve it.  But at the same time, the whole team must have a good understanding of the deployment process.  This will allow her to express wishes and make changes.  Why two people?  Because sometimes one person may fall into a creative stupor.  And in the discussion truth is born. <br><br>  We naturally built on this principle, united in technological interests.  In this case, the developer can also engage in setting up a DevOps practice, and the QA engineer can develop an auxiliary, non-production service (for example, a cache warmer or anomalies search service in data in different environments). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c0c/d3d/188/c0cd3d1883cefa481f26765dda16cba2.png"><br><br>  <b>- Almost every report on microservices begins with the story that ‚Äúwe had an iceberg and we sawed, sawed, sawed ... New parts of the application were made on the basis of microservices, and then they began to separate the‚Äú pieces ‚Äùfrom the main engine ... "</b> <b><br><br></b>  <b>Tell me, are you a supporter of development from scratch, or there may be situations when it is worth making a gradual withdrawal from a monolith?</b>  <b>How to correctly determine the strategy of "exit"?</b> <br><br>  I am a supporter of development from scratch.  But it works only in the case of a not too complicated set of functions.  Usually a small MVP monolith is made.  And sometimes you have to change its internal implementation several times.  This can be caused both by a change in the technical task, and by the fact that an understanding of the implementation comes - high-level abstractions appear at the level of the business model.  After that, you can go to the microservice architecture. <br><br>  But if you work out these abstractions well at the very beginning and draw them in different notations (UML, BPMN, IDEF), so that all participants in the process understand what they are working with, then it is quite possible to implement the microservice architecture at once. <br><br>  Our path to microservice architecture was not direct.  At first there was a monolith.  He processed text advertising materials.  Three and a half years ago we needed to work with graphic advertising materials (images, logos).  There was a desire to bring into business logic what was lacking when working with text advertising materials. <br><blockquote>  In order to try out a new business model, we implemented work with graphic advertising materials as a second monolith on another technology stack.  After one and a half years of operation, we realized that this approach was correct. </blockquote>  During this time, we have a lot of hotelok, revealed the roughness of business logic. <br><br>  The implementation of the second monolith was difficult to expand at first.  Therefore, we decided not to conduct development in two monoliths at once, but to unite them within the framework of the third architecture for the very new business model.  A team of seven developers, one QA engineer and two analysts was created.  Two developers from this team previously created and maintained the first monolith, and another one the second monolith.  That is, our team already at the entrance knew well the pitfalls of the previous monoliths. <br><br>  The first monolith was written in C #.  The second is in PHP.  We did not want to lose the debugged large pieces of code from the first monolith and at the same time required multithreading, safe code and strong typing.  PHP-code under these requirements partially did not fall.  Therefore, C # remained as the basis and implemented what it did well in the first monolith - working with the content of promotional materials - but on the basis of another repository: S3-compatible storage and Kafka. <br><br>  This time, Scala and the PostgreSQL database were chosen to work with the very new business model.  Scala met our specifications.  In addition, Scala developers were located on the same floor as C # developers.  This reduced the time for inter-team communications.  Conway's law worked - the structure of the company dictated the structure of the application.  The PHP developer has reassigned to a Scala developer.  I just finished working on an independent microservice on Golang with a full CI / CD cycle, after which I joined the team and also became a Scala developer. <br><br>  It is interesting that I suggested using Scala instead of C # to work with business logic.  The fact is that we didn‚Äôt have enough C # developers.  PHP-person and I wanted to retrain on Scala.  Plus, we had the opportunity to attract an experienced Scala developer.  Another point: if we implemented everything in C #, then we could get either a microservice architecture or another monolith at the output.  The division into Scala and C #, different storage needs and the presence of experienced developers in each of the required areas - all this directly pointed us to the microservice architecture.  And we only benefited from it.  A year ago, the micro-service architecture for working with graphic and textual materials went into commercial operation and is still working successfully. <br><br>  On the question of whether it is possible to create a microservice architecture from scratch.  A year and a half ago, in the process of working on microservice architecture, we were asked to support a new direction in our products - video advertising materials.  It was necessary to test a new sales model in a short time.  Our architecture was in its infancy.  Work with video materials covered a new area of ‚Äã‚Äãtechnology.  We decided not to change the development vector and implemented the MVP on video as a stand-alone microservice architecture in C # and trusted video hosting.  This is a successful experience, and we have a <a href="https://www.youtube.com/watch%3Fv%3DeWrRzOUaSBQ">report</a> on this topic.  Thus, we have two parallel microservice architectures.  MVP didn‚Äôt develop much, Wishlists also accumulated on it and soon we will unite everything within the framework of a single microservice architecture - we‚Äôll have a single repository of advertising text, graphics and video. <br><br>  <b>- Immediately, there are two important factors that speak in favor of microservices.</b>  <b>The first is the ability to output individual parts to the cloud and, as a result, colossal scalability.</b>  <b>The second is the ability to create a separate service in another language.</b>  <b>What else do you see the advantages of switching to microservices?</b>  <b>Well, about the minuses, of course, I also want to hear.</b> <br><br>  If we talk about the technological component, then the advantages, in addition to the above, include the possibility of using another stack of technologies.  And if he does not suit us, choose another one.  New technologies bypass the problems of old solutions.  Microservice architecture also gives stability and independence: degradation of one service should not lead to complete degradation of the entire system.  The composability of services allows re-use of service functionality in other microservice architectures.  From the point of view of the organizational component, the division into services allows to divide the development within distributed teams or one large team. <br><blockquote>  The main disadvantages of microservice architecture: it is much more complicated, and its implementation is more expensive. </blockquote>  You also need to be prepared to support service contracts, choose the right remote access protocol, resolve issues of secure interservice communication, possible failures, as well as deduplication and management of distributed transactions. <br><br>  In general, in the public domain you can find a lot of information and materials on how to work with it.  But in fact it all depends on the task.  In my practice, the pros have always been more significant than the minuses. <br><br>  Another thing to remember is Sam Newman's words: the smaller the service, the more pronounced all the advantages and disadvantages of microservice architecture. <br><br>  <b>- You have some interesting reports about microservices.</b>  <b><a href="https://techno.2gis.ru/lectures/116">Deploying microservices</a> and the <a href="http://www.highload.ru/siberia/2018/abstracts/3308">Approach to Continuous Deployment in microservice architecture</a> .</b>  <b>In one of the slides of the first one, there are ‚Äútemplates‚Äù of deployment, and in the report you say that the trend approach for you is distribution through containers.</b>  <b>During this time, nothing has changed?</b>  <b>Bundle Docker + Kubernetes has not lost its relevance?</b> <br><br>  We are transferring more and more services to this bundle.  I think that we have chosen the right direction and while we are planning to stick to it.  If something changes, I will tell you about it in a new report or interview. <br><br>  <b>- How trouble free is the continuous deployment and transfer of microservices to the prod?</b> <br><br>  It all depends on how you build the process.  At first it seems that everything is simple.  Services are independent, deployed separately.  Weak connectivity is provided by different approaches to work with the evolution of the contract.  And here you have to choose.  For example, you can implement contract versioning or add a service to terminate a contract (contract decoupling). <br><br>  If 10 or more services are in active development in the microservice architecture and everyone has their own versioning, then the problem of version consistency arises.  We must try not to get confused in the compatibility of services of different versions. <br><br>  Continuous deployment means that we can deliver the application at any time to any environment. <br><blockquote>  Application in microservice architecture is a collection of services.  So, at any time we need to know a stable combination of versions of services.  And we must somewhere have a set of domain addresses and other parameters specific to different environments for configuring services and associating them with each other. </blockquote>  All this needs to be stored somewhere, edit changes in several places (microservices are independent) and not be confused. <br><br>  Continuous deployment implies the ability to roll back to any version at any time.  Accordingly, it may be that you need to roll back several services at once and you will need to observe the correct reverse order of the service deployment. <br><br>  In one of my reports, I talk about our approach to the evolution of contracts, about how they solved the problem of consistency of versions and how they built up the deployment process in the micro-service architecture from more than ten services.  Continuous deployment can not be trouble-free, but everything can be solved. <br><br>  <b>- What could be the initial set of tools for continuous deployment of microservices?</b>  <b>What options would you recommend to use for working with microservices?</b> <br><br>  Continuous deploy is a sequence of stages (pipelines) that include continuous integration, integration tests, and service delivery to the orchestration environment.  The most popular tools for successive stages are <a href="https://jenkins.io/2.0/">Jenkins 2 Pipelines</a> , <a href="https://blog.jetbrains.com/teamcity/2016/03/teamcity-take-on-build-pipelines/">TeamCity Build Chains</a> , <a href="https://confluence.atlassian.com/bitbucket/build-test-and-deploy-with-pipelines-792496469.html">Bitbucket Pipelines</a> and <a href="https://docs.gitlab.com/ee/ci/pipelines.html">GitLab CI Pipelines</a> .  First you need to automate continuous integration (Continuous Integration, CI).  We need a remote CI server that would build and run tests on this build. <br><br>  The listed tools offer their solutions.  We use GitLab CI, and GitLab Runners act as such servers.  The build artifact is a <a href="https://www.docker.com/">Docker</a> image.  As part of the integration tests, it is possible to carry out load and capacitive tests using <a href="https://gatling.io/">Gatling</a> , in particular, in order to determine the resources it needs (processor and memory) for operating on the orchestration environment (for example, <a href="https://kubernetes.io/">Kubernetes</a> ).  <a href="https://helm.sh/">Helm</a> is widely used for deployment, it allows you to describe microservice architecture for different environments.  In our company we do not use Helm.  We have our own deployment tool, which was created when Helm was in the Classic version and did not support different environments.  Both of these tools have similar useful qualities, but the implementation and distribution are different.  And our own tool allows you to make improvements to the deploy and adapt everything to our infrastructure. <br><br>  <b>- What technologies are optimal for small and medium-sized companies that want to implement microservices?</b>  <b>Is it too expensive for them?</b> <br><br>  I increasingly find confirmations that it is inappropriate for small and medium-sized companies to raise their own orchestration environment (for example, <a href="https://kubernetes.io/">Kubernetes</a> , <a href="https://docs.docker.com/swarm/">Docker Swarm</a> or <a href="http://mesos.apache.org/">Apache Mesos</a> ).  After all, for this they need to contain their hardware and one or more commands to configure and support it.  It is easier to use popular third-party cloud services (based on the <a href="https://en.wikipedia.org/wiki/Google_Cloud_Platform">Google Cloud Platform</a> , <a href="https://en.wikipedia.org/wiki/Amazon_Web_Services">Amazon Web Services</a> , <a href="https://en.wikipedia.org/wiki/Microsoft_Azure">Microsoft Azure</a> or <a href="https://en.wikipedia.org/wiki/Oracle_Cloud">Oracle Cloud</a> ) and choose the right tariff. <br><br>  We use the free version of GitLab and GitLab CI.  This tool allows you to store the code and see all the information about its deployment in one place.  GitLab is actively integrating with Helm and various cloud services.  I often say Helm and do not bring analogues.  Helm has its drawbacks, but these drawbacks are different for everyone and depend on the scale of development, so you can start with it, and then you will definitely find the necessary tools in addition. <br><br>  I would also recommend our configuration and deployment tool, which I mentioned earlier, but it is not yet available as open source, although work is actively being done in this direction. <br><br>  It is also interesting to look at <a href="https://www.spinnaker.io/">Spinnaker</a> and <a href="https://www.heroku.com/">Heroku</a> - these are different, but proven solutions that allow you to quickly get stuck on cloud services. <br><br>  <b>- On the one hand, version control is needed to ensure communications control and reliability at a level sufficient for industrial operation.</b>  <b>Moreover, with a large number of services, versioning can seriously slow down the development of infrastructure.</b>  <b>How did you solve this problem?</b> <br><br>  Developing microservice architecture from several services, we have gone from a prototype to industrial operation.  We first encountered versioning when we needed to close a unified test environment from all services, and then, in the course of changing each service, maintain the stability of the existing functionality. <br><br>  We didn‚Äôt want to produce versions (and there are a lot of them at the prototype stage) or introduce different services for contract separation.  Microservice architecture allowed replacing one service with another with another implementation or on a different technology stack. <br><br>  When adding or removing services, versioning does not help.  We have proposed our approach to the evolution of the contract.  We combined the most frequently changing services into a single cast of versions, also known as a package.  Then a simple package manager was implemented and they began to use this cast for deploying a collection of frequently changing services. <br><br>  The versions of services (not contracts) are Docker image tags, which in turn are equal to hash commits or tags in Git.  We had to rebuild the continuous deployment, but this only made it easier.  I talked about this in detail in the report, and the dynamics of deployment can be seen on the <a href="http://www.highload.ru/siberia/2018/abstracts/3308">slides</a> .  In general, we were able to abandon the usual versioning of the contract at the prototype stage and significantly accelerated the development. <br><br>  We added the versioning of the contract to services one month before it went into commercial operation, when we needed to integrate with external customers.  And then: we added it only to the public API.  And now we have been in industrial operation for a year and during this time we have raised only three minor versions.  At the same time, we continue to engage in active development: we add and remove functions.  We have client services that use our public API.  We know which API methods external clients use and which ones we use.  If the changes concern only our methods, then in most cases we do not raise the API version, change only the version cast and do not make irreversible changes over short periods of time. <br><br>  Thus, we were able to abandon the many versions of the contract.  If we left them, we would have to test each version;  ask external customers to upgrade to a new version of the public API, although most of the changes do not concern them;  track whether the old version is being used and remove it from the code. <br><br>  <b>I know that you are using an approach in which part of microservices is divided into separate groups.</b>  <b>Can we say that they become an analogue of the application kernel?</b> <br><br>  The core is something internal.  If you look at it as a <a href="https://medium.com/microservices-in-practice/microservices-layered-architecture-88a7fc38d3f1">multi-layer</a> microservice architecture, where there are layers with services for a high-level API, integration services and small atomic services, then the core in this case are just these low-level atomic services.  We have another division.  In a separate group, we allocate frequently changing services on different layers of the microservice architecture. <br><br>  Services that change rarely have their own independent process of continuous deployment.  For the deployment of a separate group, a separate repository was created, where deployment configurations are stored, there is a package manager for the version cast and a continuous deployment for different environments.  At the same time, continuous integration, which is the basic part of continuous deployment, is distributed over repositories of frequently changing services. <br><br>  <b>- It is always interesting to learn not only about the approaches and technologies, but also about the personal experience of companies.</b>  <b>Let's take 2GIS.</b>  <b>Say, the process of transition to microservices took a lot of time?</b>  <b>What is finished now?</b> <br><br>  The transition began more than three years ago.  At first, we conducted a study.  We tried <a href="https://mesosphere.com/">Mesosphere</a> , <a href="https://www.openshift.com/">OpenShift</a> and other PaaS and IaaS solutions available at that time.  The choice fell on Deis and we have a <a href="http://rootconf.ru/2016/abstracts/2053.html">report</a> on this topic, as well as a <a href="https://www.youtube.com/watch%3Fv%3DDnox8MNPmQw">report on the support of Deis</a> for one and a half years.  This is an open source analogue of <a href="https://www.heroku.com/">Heroku</a> , it allowed to deliver its service as Heroku Buildpack, Dockerfile or prepared Docker-image.  He had good documentation and competent architecture.  We wrote a family of make files as a universal set of commands on top of the command console for deploying to Deis.  This was the first implementation for continuous deployment. <br><br>  Next, the company moved to <a href="http://deis.io/">Deis2</a> .  He was backward compatible with Deis, but Kubernetes was already used as an orchestration medium.  <a href="http://rootconf.ru/2017/abstracts/2750.html">The Infrastructure &amp; Operations team</a> , which was engaged in raising these platforms and their further maintenance, developed its tool for deployment to Kubernetes and Deis2.  Those who switched to microservice architectures, in most cases, chose Deis2, but there were also those who chose the low-level path - direct work with Kubernetes.  The latter were right.  Deis2 had a number of flaws: it was not possible to go into a running container, the pod could consist of only one container, and for each pod, its own namespace was created.  This did not give flexibility and complicated the work of the Infrastructure &amp; Operations team.  Kubernetes was devoid of these shortcomings.  As a result, they decided to transfer all services from Deis2 to Kubernetes.  A full rejection of Deis2 in favor of Kubernetes is scheduled for this summer. <br><br>  <b>- Tell me, if you were now to rewrite everything under the microservice architecture, having already had this experience behind you, what would you change in the implementation?</b>  <b>What interesting ideas are already impossible to apply?</b> <br><br>  I would immediately read about Helm.  It has very large documentation and is hard to read in a short period of time.  But Helm builds a good understanding of the practice of deployment of microservice architecture. <br><blockquote>  Helm immediately suggests that the microservice architecture is a collection of services: although they are weakly connected with each other, they are deployed together. </blockquote>  In Helm there is a dependency of charts and you can describe a root chart that would describe the services and link them according to the parameters inherent in a certain environment. <br><br>  The deployment tool developed in 2GIS allows you to combine multiple services at once, but it is great for a collection of no more than 10 services.  We had more than ten services (on test environments for each task we raised additionally our backing services: Postgres, Kafka, Zookeeper, Ceph).  At some point, I realized that yaml programming does not reveal the full potential, it is inconvenient to work with it in the IDE, aliases and anchors do not cover the entire nesting.  I realized that I need a programming language.  I chose Python because a deployment tool was written on it and Python is definitely in the container with this tool.  Described an abstract factory that would generate a family of service descriptions.  This allowed us to add descriptions for abstractions that we do not deploy.  For example, the parameters of access to third services.  They were still represented by classes, like the descriptions of our services, and were still generated by an abstract factory.  Now you can put some descriptions in others and reuse descriptions.  You can inherit environments, for example, load from steding, because you would like to have the same actual description of resources (processor and memory) for both environments.  I realized that I had gone farther than Helm, and I am interested in solutions for describing Kubernetes resources in some programming language, and not on yaml. <br><br>  I would also make the public API split into several services and implement the <a href="http://microservices.io/patterns/apigateway.html">API Gateway</a> .  But the current implementation copes with the task, and the best is the enemy of the good. <br><br>  But whatever I definitely did not change, it is the result of a choice: a monolith or microservice architecture.  Microservice architecture brought us much more advantages than the difficulties that we were able to successfully overcome. <br><blockquote>  The principles of DevOps penetrated tightly into the lives of developers, it‚Äôs time to get together at a large professional conference to share experiences.  Join <a href="https://devopsconf.io/moscow/2018/">DevOpsConf Russia</a> . <br><br>  DevOpsConf Russia will take place <b>on October 1 and 2 in Moscow</b> and will logically continue the RootConf series, the name of which, however, has <a href="https://devopsconf.io/moscow/2018/articles/808">ceased to reflect</a> what we are doing.  We are going to discuss DevOps as a unit from all development, testing and operation processes. <br><br>  If your company DevOps is gaining momentum, or the transformation has just begun, but there is already some success - come share them with the community.  The program committee is waiting for your <a href="https://conf.ontico.ru/lectures/propose%3Fconference%3DRC2018-moscow">applications</a> until August 15. </blockquote></div><p>Source: <a href="https://habr.com/ru/post/418941/">https://habr.com/ru/post/418941/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418929/index.html">Unit Testing and Python</a></li>
<li><a href="../418931/index.html">RubyMine 2018.2: attaching a debugger to remote processes, chruby, improved code analysis, and more</a></li>
<li><a href="../418933/index.html">Review of OnePlus 6. When the Chinese did the same thing as last time</a></li>
<li><a href="../418935/index.html">DZ Online Tech: ABBYY. How not to get lost in neural networks?</a></li>
<li><a href="../418937/index.html">Celebrating the 8th anniversary of the first release at GeekUniversity</a></li>
<li><a href="../418943/index.html">Singing computer, cyborgs and music of the waves - we discuss unusual sounds and audio gadgets</a></li>
<li><a href="../418945/index.html">Best ICO August 2018 (Voting)</a></li>
<li><a href="../418949/index.html">Javascript: tracking variable value changes</a></li>
<li><a href="../418951/index.html">UE4 | Inventory for Multiplayer # 2 | Connect Blueprint to C ++</a></li>
<li><a href="../418953/index.html">Antiquities: vintage antivirus and applied digital archeology</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>