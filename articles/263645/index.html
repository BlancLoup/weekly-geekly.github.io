<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Features of development for Xamarin.Forms</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="About a year ago, a cross-platform framework called Xamarin.Forms appeared. It allows you to create mobile applications for different platforms using ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Features of development for Xamarin.Forms</h1><div class="post__text post__text-html js-mediator-article">  About a year ago, a cross-platform framework called Xamarin.Forms appeared.  It allows you to create mobile applications for different platforms using C # and .NET.  In fact, it is an add-on over the already existing Xamarin.iOS, Xamarin.Android and Xamarin.WinPhone.  And, unlike them, it allows you to create only one project in which you can describe the entire logic of the application and its UI.  And then just compile it for different platforms.  In the end, all this saves a lot of time. <br><br>  We believe that this platform has its prospects and, therefore, could not pass by it.  By tradition, we started with the development of Data Grid controls.  During the work on it we have accumulated an interesting development experience for Xamarin.Forms, and we want to share it with you. <br><a name="habracut"></a><br>  This article is based on my report on DevCon 2015, and those who wish can familiarize themselves with the video version <a href="https://channel9.msdn.com/Events/DevCon/Russia-2015/BlueD2S02">here</a> . <br><br><h1>  Benefits of Xamarin.Forms </h1><br>  To begin, I would like to talk about the benefits of this platform: <br><ul><li>  Firstly, it is well known to all of us C # and. NET.  If you have been writing on sharps for a long time, then you do not need to spend a lot of time learning a few new frameworks, and even languages.  Well, or at least in the beginning is not necessary, and you can quickly start, using your current knowledge. </li><li>  Secondly, the approach to creating and working with the user interface is close to what we are all used to in Windows.  The developers of WPF will be especially pleased, as Xamarin Forms supports working with XAML, binding, templates, styles and other pleasures of life.  I think it is clear that they are somewhat curtailed and you should not expect all the power of WPF, but still it adds convenience. </li><li>  Since this is C #, the next plus is that you can reuse already written code.  For the most part, it will work correctly.  Platforms have limitations, but they are not so great.  We managed to get a large enough piece of XtraGridControl, and it helped us a lot. </li><li>  From the fact that Xamarin.Forms is similar to WPF, the following plus of this platform follows: MVVM.  Indeed, Xamarin.Forms has XAML, visual elements have a BindingContext (analogue to the DataContext in WPF), there is a BindableProperty (analogous to DependencyProperty).  Thus, it is possible to associate a View with a ViewModel in the same way as in WPF. </li><li>  Another advantage of this platform is that since the UI is described only in one place, applications under different systems will look very similar.  What could be important, for example, in corporate developments. </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Features and disadvantages of Xamarin.Forms </h1><br>  Let's now move on to the nuances and disadvantages. <br><br>  For a start, a little technical introduction.  In the following diagram, I‚Äôve roughly shown how Xamarin.Forms works. <br><br><img src="https://habrastorage.org/files/fa4/95c/3f6/fa495c3f6d5042a59e133c2632e54e1e.png"><br><br>  At the top of the circuit is the PCL part.  In essence, this is Xamarin.Forms.  In general terms, it is a set of editors, navigation bars, layout panels and so on.  When developing a UI, you work with them most of the time.  However, these controls are just an abstraction inside the PCL part.  So that they could somehow be displayed on the device, there are so-called renderers.  They are located on the next level of the hierarchy in the Xamarin Platform parts. <br><br>  Under the PCL part we have Xamarin.iOS, Xamarin.Android and Xamarin.WinPhone.  This is essentially the Xamarin that already existed before Xamarin.Forms.  And what is this Xamarin?  These are C # wrappers over native classes for each platform.  So renderers are such wrappers over the corresponding visual components, but which additionally contain references to PCL objects inside themselves, can read the properties they have and apply them to themselves. <br><br>  In the future, these renderers are already deployed to native controls.  We can see them at the bottom level of the scheme. <br><br>  That there was less confusion, I will give an example.  There is a Button class in the PCL part.  Each Xamarin Platform part contains a ButtonRenderer class that stores an instance of the Button class.  In turn, ButtonRenderer's are wrappers over classes of buttons for each platform, for example, UIButton in iOS.  It is along such a chain that work with controls from the PCL part takes place. <br><br>  It is in this mechanism that almost all the problems of this platform are concluded. <br><br>  We can distinguish the following groups of problems encountered in the development of Xamarin.Forms: <br><ul><li>  Incomplete implementation of WPF functionality </li><li>  Tradeoffs in the implementation of functional, which differs on different platforms </li><li>  Different behavior on different platforms </li><li>  Performance </li></ul><br><br>  Now let's look at these problems with specific examples. <br><br><h3>  Incomplete implementation of WPF functionality </h3><br>  This is the first thing we stumbled upon.  Xamarin.Forms has significant limitations in the use of templates during development.  As a person who has worked with WPF for a long time, I really like this tool.  Since it is very convenient when you can arbitrarily change the appearance of the control by simply overlapping the template.  However, it is clear that templates do not fit into the concept of renderers, because on the end platforms this is only possible in WinPhone. <br><br><h3>  Tradeoffs in the implementation of functional, which differs on different platforms </h3><br>  Platforms sometimes differ, and renderers have to reduce all these differences to some kind of unified management mechanism.  Thus, one has to sacrifice some functionality. <br><ul><li>  For example, in Android, a text editor can enable both single-line mode and multi-line mode.  However, in iOS, this can not be done.  There are two different controls for these situations.  Since one PCL object can be linked with only one renderer, and therefore with one control on the platform, Xamarin.Forms left only one behavior, and the editor is always multi-line. </li><li>  Also at all mobile platforms, gestural work is very different.  And it is rather difficult to reduce them to some kind of general abstraction.  Therefore, Xamarin provides the opportunity to catch only the usual tap (and even then not without bugs).  The remaining gestures from the PCL part cannot be caught. </li><li>  Sometimes platforms ideologically do not allow to do something that can C # or. NET.  These limitations are described in the documentation for Xamarin.  However, when you come across this for the first time, it is difficult to deal with the move. <br><br>  For example, iOS requires that all code be static, in the sense that it does not allow generating code in runtime.  In part, we have already made life easier by removing the System.Reflection.Emit namespace.  But sometimes it is quite possible to write code that will compile, run and run on the emulator without any problems, but will fall on the device.  Fortunately, as I already wrote, possible problems are described in the documentation. <br></li></ul><br><br><h3>  Different behavior on different platforms </h3><br>  Sometimes the behavior of controls can vary on different platforms.  As you have already seen, in Xamarin.Forms the user interface is described in a common part for all platforms.  And it is expected that in the end it will look the same on all systems.  Well, or at least very close.  But this is not always the case.  Let's go through the main rake, which we attacked. <br><br><h5>  Margins in WinPhone </h5><br>  In WinPhone, some controls have large margins, which is not available on other platforms (for example, the Switch controls).  Thus, the appearance of the application on it can be very different from the versions on Android and iOS, up to a complete inoperability (when the elements simply do not fit in the visible area). <br><br>  I will show a small example.  If you create a test application with a similar layout: <br><pre><code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Grid</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">RowSpacing</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Grid.RowDefinitions</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">RowDefinition</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Auto"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">RowDefinition</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Auto"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Grid.RowDefinitions</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Switch</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Grid.Row</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0‚Äú /&gt; &lt;Switch Grid.Row=‚Äú1‚Äú /&gt; &lt;/Grid&gt;</span></span></span></span></code> </pre> <br><br>  and then run it under iOS, we get the following appearance: <br><br><img src="https://habrastorage.org/files/00a/ba9/a75/00aba9a75458441a92b16e30bbde1c6f.png"><br><br>  On Android will be the same.  But if we run it under WinPhone, we get the following result: <br><br><img src="https://habrastorage.org/files/636/604/0d1/6366040d1fcf43fe942086130b4aa1ca.png"><br><br>  As you can see, the Switch controls are located at a distance from each other.  The reason for this is that inside the Switch control in WinPhone there is a Grid panel that is too large.  Since this behavior is specific under WinPhone, this should be solved not at the PCL level, but in the switch renderer.  A native solution under WinPhone would be overlapping the default style for Switch controls, or overlapping styles only for the required switches.  It is clear that in the PCL part we will not be able to do this and it is necessary to go one level lower in Xamarin.WinPhone. <br><br>  At the Xamarin.WinPhone level, we can set a new default style, but we cannot apply the style only for the controls we need.  Since we had to change the appearance of only those switches that are inside the grid, and not touch the rest, let's solve this problem. <br><br>  As I wrote above, at the platform level, the controls are represented by their renderers.  So, to make any changes to the control, you need to edit its renderer.  Since now our task is to correct the behavior of our switches only and not to affect the others, the simplest solution is to make the switch heir (and use it later) and write a renderer for it (inherited from the standard ButtonRenderer).  And in this renderer we can change the visual tree of the control as we like.  For example: <br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">Control</span></span> switchControl = <span class="hljs-type"><span class="hljs-type">VisualTreeHelper</span></span>.<span class="hljs-type"><span class="hljs-type">GetChild</span></span>(<span class="hljs-type"><span class="hljs-type">Control</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-type"><span class="hljs-type">Control</span></span>; <span class="hljs-type"><span class="hljs-type">Border</span></span> border = <span class="hljs-type"><span class="hljs-type">VisualTreeHelper</span></span>.<span class="hljs-type"><span class="hljs-type">GetChild</span></span>(switchControl, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-type"><span class="hljs-type">Border</span></span>; <span class="hljs-type"><span class="hljs-type">Grid</span></span> grid = <span class="hljs-type"><span class="hljs-type">VisualTreeHelper</span></span>.<span class="hljs-type"><span class="hljs-type">GetChild</span></span>(border, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-type"><span class="hljs-type">Grid</span></span>; grid.<span class="hljs-type"><span class="hljs-type">Height</span></span> = <span class="hljs-number"><span class="hljs-number">40</span></span>;</code> </pre><br><br>  And you need to remember to return the correct size in the GetDesiredSize method: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> SizeRequest </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDesiredSize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> widthConstraint, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> heightConstraint</span></span></span><span class="hljs-function">)</span></span> { SizeRequest result = <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.GetDesiredSize(widthConstraint, heightConstraint); result.Request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Size(result.Request.Width, <span class="hljs-number"><span class="hljs-number">40</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br><br>  As a result, we get the result: <br><br><img src="https://habrastorage.org/files/0a2/5fd/0d4/0a25fd0d42f340b585e4d1345d46a451.png"><br><br><h5>  Interception of gestures </h5><br>  For the following example, suppose we have a new task: we need to block all gestures over some area of ‚Äã‚Äãthe screen.  There are many controls there, and some of them catch gestures on their own (for example, editors and buttons), so there is no single entry point for locking.  In this case, there is a simple solution: put a transparent panel on top of the required area and set the InputTransparent property to it to false.  This property is just responsible for the fact that gestures cease to prokidyvatsya further along the tree of elements.  So, if we write something like this: <br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Grid</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Switch</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">VerticalOptions</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Center"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">HorizontalOptions</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Center"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ContentView</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">VerticalOptions</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"FillAndExpand"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">HorizontalOptions</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"FillAndExpand"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">InputTransparent</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"false"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Grid</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  then it should work and the Switch should not be pressed.  And indeed in iOS, everything is happening.  But if you check it in Android, then Switch will still be pressed in it.  As you can see, Android ignores setting the InputTransparent property.  To fix this, let's look like in the previous example - create a ContentView heir and write the following renderer for it: <br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyContentViewRenderer</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Xamarin.Forms.Platform.Android.VisualElementRenderer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyContentView</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> bool DispatchTouchEvent(Android.Views.MotionEvent e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !Element.InputTransparent; } }</code> </pre><br><br>  I overlap the DispatchTouchEvent method, which is exactly responsible for making gestures, and return a value on it depending on the PCL object that is set to InputTransparent.  We also solved this problem. <br><br><h5>  Default Difference in Layout </h5><br>  Elements can have default property values ‚Äã‚Äãfor different platforms.  For example, the layout.  If we try to start the application with this panel: <br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ContentPage</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://xamarin.com/schemas/2014/forms"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:x</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.microsoft.com/winfx/2009/xaml"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x:Class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"DefaultLayout.MyContentPage"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Switch</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ContentPage</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  then we will get these results on iOS and WinPhone: <br><br><img src="https://habrastorage.org/files/a2e/94d/2f9/a2e94d2f9a9a42a0b6f1011f403c74ab.png"><br><br>  On Android it will be the same as on WinPhone.  As you can see, controls appeared in different places on the screen.  Therefore, one should not always rely on default values ‚Äã‚Äãof properties.  It is better to protect yourself and set their values ‚Äã‚Äãso that something like this does not work out. <br><br><h3>  Performance </h3><br>  Also, an additional level of abstraction of the PCL part adds new brakes to the application.  According to the speed of the application on Xamarin.Forms can be quite losing native.  Especially since he likes very often to redraw the entire visual tree. <br><br><h1>  How do we live with this? </h1><br>  As I have already shown, in order to circumvent such problems, you have to climb into the native mobile parts and write your renderers for the elements, and they have to decide what the default renderers can't handle. <br><br>  Personally, we wrote our own gesture handler completely, allowing us to subscribe to any gestures from the PCL part, we wrote renderers for all editors, pulling the missing properties there.  The problem with InputTransparent was again solved by the renderer in the android and the blocking of gestures in it.  Well, when you climb into the renderer, you already have to deal with the native API of the system in which you are in the renderer.  And this already requires studying this API.  So I knowingly at the beginning mentioned that it is not necessary to learn it at first, then it will most likely come up against this anyway. <br><br>  But all these problems somehow manage.  And we were finally able to write our GridControl on this framework.  It has a fairly large functionality for display and work with data.  It looks like this: <br><br><img src="https://habrastorage.org/files/966/a40/b27/966a40b27d864435a2904aa6cdabd798.png"><br><br>  Grid turned out quite smart and rich in functionality.  But we will write more about it in our next article about Xamarin.Forms. <br><br>  As an output, I want to say that Xamarin.Forms can be used when you need a quick start on several platforms at once, when performance is not very important, or when there is a lot of old code that you want to reuse in the new application.  Also, it will certainly be very useful for corporate programmers, because there the speed of development is more important than the beauty of the final application. <br><br>  Of course, if any unusual design or high speed of work is important to you, and you are writing applications for sale in stores, then it may be better to write in native or in Xamarin Mobile.  Although currently the Xamarin team is actively developing its product, quite often there are updates.  So one can hope that the scope of Xamarin.Forms will expand. <br><br>  <b>Update:</b> <br>  Get more information about GridControl in our article: <a href="http://habrahabr.ru/company/devexpress/blog/264039/">Free Grid Control for Xamarin from DevExpress</a> </div><p>Source: <a href="https://habr.com/ru/post/263645/">https://habr.com/ru/post/263645/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../263631/index.html">What is internal hakaton, or Rule of five "no"</a></li>
<li><a href="../263633/index.html">Oracle Exadata, or About the Use of Engineered Systems (Part 1)</a></li>
<li><a href="../263635/index.html">How Microsoft Project Oxford Can Make Your Applications Smarter</a></li>
<li><a href="../263641/index.html">Multi-level information security in cloud CRM</a></li>
<li><a href="../263643/index.html">Load Balancing: Firebase + RabbitMQ</a></li>
<li><a href="../263647/index.html">TargetSummit - evening conference on analytics and promotion of mobile applications</a></li>
<li><a href="../263649/index.html">Crosswalk Project - replacement of Android WebView. Project Integration</a></li>
<li><a href="../263651/index.html">Node-RED node for converting locations into what3words addresses</a></li>
<li><a href="../263655/index.html">Crosswalk Project - replacement of Android WebView. Integration issues</a></li>
<li><a href="../263657/index.html">Feel Kotlin (and slightly Gradle) on the example of Posting-long-tweets (open source)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>