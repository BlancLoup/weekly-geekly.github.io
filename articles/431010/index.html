<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The memory of your computer lag every 7,8 ms</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Modern DDR3 SDRAM. Source: BY-SA / 4.0 by Kjerish 

 During a recent visit to the Computer View Museum in Mountain View, my attention was drawn to an ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The memory of your computer lag every 7,8 ms</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc7/f53/c6e/dc7f53c6eb17bfa58db7c138915bce84.jpg"></div><br>  <i><font color="gray">Modern DDR3 SDRAM.</font></i>  <i><font color="gray">Source: <a href="https://en.wikipedia.org/wiki/DDR3_SDRAM">BY-SA / 4.0 by Kjerish</a></font></i> <br><br>  During a recent visit to <a href="http://www.computerhistory.org/">the Computer</a> View <a href="http://www.computerhistory.org/">Museum</a> in Mountain View, my attention was drawn to an ancient sample of <a href="https://en.wikipedia.org/wiki/Magnetic-core_memory">ferrite memory</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b2/d31/5c6/2b2d315c67b80adcd5f0b5bf4dd23e7a.jpg"></div><br>  <i><font color="gray">Source: <a href="https://en.wikipedia.org/wiki/File:KL_CoreMemory.jpg">BY-SA / 3.0 by Konstantin Lanzet</a></font></i> <br><a name="habracut"></a><br>  I quickly came to the conclusion that I have no idea how such things work.  Do the rings rotate (no), and why three wires pass through each ring (I still don‚Äôt understand how they work).  More importantly, I realized that I very poorly understand the principle of operation of modern dynamic RAM! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fc/cb6/f41/7fccb6f418a426c7829b7e9bb1b5d3c3.png"></div><br>  <i><font color="gray">Source: <a href="https://en.wikipedia.org/wiki/File:KL_CoreMemory.jpg">Ulrich Drepper's Memory Cycle</a></font></i> <br><br>  I was particularly interested in one of the consequences of how dynamic RAM works.  It turns out that every bit of data is stored by charge (or its absence) on a tiny capacitor in the RAM chip.  But these capacitors gradually lose charge over time.  To avoid losing stored data, they must be regularly updated to restore charge (if any) to the original level.  This <a href="https://en.wikipedia.org/wiki/Memory_refresh">update process</a> involves reading each bit, and then writing it back.  In the process of such an "update", the memory is occupied and cannot perform normal operations, such as writing or storing bits. <br><br>  It worried me for a long time, and I wondered ... can I notice a delay in updating at the program level? <br><br><h1>  Dynamic RAM Upgrade Training Base </h1><br>  Each DIMM consists of ‚Äúcells‚Äù and ‚Äúrows‚Äù, ‚Äúcolumns‚Äù, ‚Äúsides‚Äù and / or ‚Äúranks‚Äù.  <a href="https://pubweb.eng.utah.edu/~cs7810/pres/11-7810-12.pdf">This presentation</a> from the University of Utah explains the nomenclature.  The configuration of the computer's memory can be checked with the <code>decode-dimms</code> .  Here is an example: <br><br><pre>  $ decode-dimms
 Size 4096 MB
 Banks x Rows x Columns x Bits 8 x 15 x 10 x 64
 Ranks 2 </pre><br>  We do not need to understand the whole DDR DIMM scheme, we want to understand the operation of only one cell storing one bit of information.  Or rather, we are only interested in the update process. <br><br>  Consider two sources: <br><br><ul><li>  <a href="http://utaharch.blogspot.com/2013/11/a-dram-refresh-tutorial.html">DRAM Update Tutorial</a> from the University of Utah </li><li>  And Micron's excellent gigabit chip documentation: <a href="https://www.micron.com/~/media/documents/products/technical-note/dram/tn4609.pdf">‚ÄúDesigning a TN-46-09 for 1Gb DDR SDRAM‚Äù</a> </li></ul><br>  Every bit in the dynamic memory should be updated: it usually happens every 64 ms (the so-called static update).  This is quite an expensive operation.  To avoid one major stop every 64 ms, the process is divided into 8192 smaller update operations.  In each of them, the computer memory controller sends update commands to the DRAM chips.  After receiving the instructions, the chip will update 1/8192 cells.  If you count, then 64 ms / 8192 = 7812.5 ns or 7.81 Œºs.  This means the following: <br><br><ul><li>  The refresh command is executed every 7812.5 ns.  It is called tREFI. </li><li>  The update and restore process takes some time, so the chip can perform normal read and write operations again.  The so-called tRFC is either 75 ns or 120 ns (as in the mentioned Micron documentation). </li></ul><br>  If the memory is hot (more than 85 ¬∞ C), then the storage time of the data in the memory drops, and the static update time is halved to 32 ms.  Accordingly, the tREFI falls to 3906.25 ns. <br><br>  A typical memory chip is busy updating for a considerable part of its work time: from 0.4% to 5%.  In addition, the memory chips are responsible for the non-trivial share of the power consumption of a typical computer, and most of this power is spent on updating. <br><br>  At the time of the update, the entire memory chip is blocked.  That is, each bit in memory is locked for more than 75 ns every 7812 ns.  Let's measure. <br><br><h1>  Preparing the experiment </h1><br>  To measure operations with nanosecond precision, we need a very dense cycle, perhaps at C. It looks like this: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ...; i++) { <span class="hljs-comment"><span class="hljs-comment">//   . *(volatile int *) one_global_var; //   CPU.    _mm_clflush(one_global_var); //   ,     //    (25    160). // , - . asm volatile("mfence"); //     clock_gettime(CLOCK_MONOTONIC, &amp;ts); }</span></span></code> </pre> <br>  <a href="">The full code is available on github.</a> <br><br>  The code is very simple.  We execute reading of memory.  We reset the data from the CPU cache.  We measure time. <br><br>  (Note: in the <a href="">second experiment,</a> I tried to use MOVNTDQA to load data, but this requires a special non-cached memory page and root rights). <br><br>  On my computer, the program gives the following data: <br><br><pre>  # timestamp, cycle time
 3101895733, 134
 3101895865, 132
 3101896002, 137
 3101896134, 132
 3101896268, 134
 3101896403, 135
 3101896762, 359
 3101896901, 139
 3101897038, 137 </pre><br>  Usually a cycle of about 140 ns is obtained, periodically the time jumps to about 360 ns.  Sometimes strange results are popping up more than 3200 ns. <br><br>  Unfortunately, the data is too noisy.  It is very difficult to see if there is a noticeable delay associated with update cycles. <br><br><h1>  Fast Fourier Transform </h1><br>  At some point it dawned on me.  Since we want to find an event with a fixed interval, we can submit the data to the FFT algorithm (fast Fourier transform), which will decode the basic frequencies. <br><br>  I‚Äôm not the first to think about this: Mark Seborn with the famous vulnerability <a href="">Rowhammer</a> implemented this very technique back in 2015.  Even looking at the Mark code, making FFT work was harder than I expected.  But in the end I put all the pieces together. <br><br>  First you need to prepare the data.  FFT requires input with a constant sampling interval.  We also want to trim the data to reduce noise.  Through trial and error, I found that the best result is achieved after preprocessing the data: <br><br><ul><li>  Small values ‚Äã‚Äã(less than 1.8 average) loop iterations are cut off, ignored and replaced with zeros.  We really don't want to introduce noise. </li><li>  All other readings are replaced by units, since we really do not care about the amplitude of the delay caused by some noise. </li><li>  I stopped at a sampling interval of 100 ns, but any number up to <a href="https://en.wikipedia.org/wiki/Nyquist%25E2%2580%2593Shannon_sampling_theorem">the Nyquist frequency (double expected frequency) will do</a> . </li><li>  Data must be selected with a fixed time before submission to the FFT.  All reasonable sampling methods work fine, I stopped at the basic linear interpolation. </li></ul><br>  Algorithm like this: <br><br><pre> <code class="cpp hljs">UNIT=<span class="hljs-number"><span class="hljs-number">100</span></span>ns A = [(timestamp, loop_duration),...] p = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> curr_ts in frange(fist_ts, last_ts, UNIT): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>(A[p<span class="hljs-number"><span class="hljs-number">-1</span></span>].timestamp &lt;= curr_ts &lt; A[p].timestamp): p += <span class="hljs-number"><span class="hljs-number">1</span></span> v1 = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> avg*<span class="hljs-number"><span class="hljs-number">1.8</span></span> &lt;= A[p<span class="hljs-number"><span class="hljs-number">-1</span></span>].duration &lt;= avg*<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> v2 = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> avg*<span class="hljs-number"><span class="hljs-number">1.8</span></span> &lt;= A[p].duration &lt;= avg*<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> v = estimate_linear(v1, v2, A[p<span class="hljs-number"><span class="hljs-number">-1</span></span>].timestamp, curr_ts, A[p].timestamp) B.append( v )</code> </pre> <br>  Which on my data produces a rather boring vector like this: <br><br><pre>  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...] </pre><br>  However, the vector is quite large, usually about 200 thousand data points.  With such data you can use FFT! <br><br><pre> <code class="cpp hljs">C = numpy.fft.fft(B) C = numpy.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(C) F = numpy.fft.fftfreq(len(B)) * (<span class="hljs-number"><span class="hljs-number">1000000000</span></span>/UNIT)</code> </pre> <br>  Pretty simple, right?  It produces two vectors: <br><br><ul><li>  C contains complex numbers of frequency components.  We are not interested in complex numbers, and we can smooth them with the <code>abs()</code> command. </li><li>  F contains labels, which frequency interval lies in which place of the vector C. Normalize the parameter to Hertz by multiplying by the sampling rate of the input vector. </li></ul><br>  The result can be applied to the chart: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/580/d99/6ad/580d996adeb168c27821b2efb11bac2c.png"><br><br>  Y axis without units, since we normalized the delay time.  Despite this, bursts are clearly visible in certain fixed frequency intervals.  Consider them closer: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bf2/d37/2ed/bf2d372ed5483d677e1d775b863c6b76.png"><br><br>  We clearly see the first three peaks.  After a little inexpressive arithmetic, including filtering the reading at least ten times the size of the average, you can extract the base frequencies: <br><br><pre>  127850.0
 127900.0
 127950.0
 255700.0
 255750.0
 255800.0
 255850.0
 255900.0
 255950.0
 383600.0
 383650.0 </pre><br>  We count: 1,000,000,000 (ns / s) / 1,27900 (Hz) = 7,818.6 ns <br><br>  Hooray!  The first frequency jump is really what we were looking for, and it really correlates with the update time. <br><br>  The remaining peaks at 256 kHz, 384 kHz, 512 kHz are the so-called harmonics, multiples of our base frequency of 128 kHz.  This is a completely expected side effect of <a href="https://en.wikipedia.org/wiki/Square_wave">using FFT on something like a square wave</a> . <br><br>  To facilitate experiments, we made a <a href="https://github.com/cloudflare/cloudflare-blog/tree/master/2018-11-memory-refresh">command line version</a> .  You can run the code yourself.  Here is an example of running on my server: <br><br><pre>  ~ / 2018-11-memory-refresh $ make
 gcc -msse4.1 -ggdb -O3 -Wall -Wextra measure-dram.c -o measure-dram
 ./measure-dram |  python3 ./analyze-dram.py
 [*] Verifying ASLR: main = 0x555555554890 stack = 0x7fffffefe22
 [] Fun fact.  I did 40663553 clock_gettime () 's per second
 [*] Measuring MOVQ + CLFLUSH time.  Running 131072 iterations.
 [*] Writing out data
 [*] Input data: min = 117 avg = 176 med = 167 max = 8172 items = 131072
 [*] Cutoff range 212-inf
 [] 127849 items below cutoff, 0 items above cutoff, 3223 items non-zero
 [*] Running FFT
 [*] Top frequency above 2kHz below 250kHz has magnitude of 7716
 [+] Top frequency spikes above 2kHZ are at:
 127906Hz 7716
 255813Hz 7947
 383720Hz 7460
 511626Hz 7141 </pre><br>  I have to admit, the code is not quite stable.  In case of problems, it is recommended to disable Turbo Boost, CPU frequency scaling and performance optimization. <br><br><h1>  Conclusion </h1><br>  From this work there are two main conclusions. <br><br>  We have seen that low-level data is rather difficult to analyze and seems rather noisy.  Instead of evaluating with the naked eye, you can always use the good old FFT.  In preparing the data, it is necessary in some sense to take what was desired. <br><br>  Most importantly, we have shown that it is often possible to measure subtle hardware behavior from a simple process in user space.  This kind of thinking led to the discovery of the <a href="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html">original vulnerability of Rowhammer</a> , it is implemented in the Meltdown / Specter attacks and again shown in the recent <a href="https://arstechnica.com/information-technology/2018/11/potentially-disastrous-rowhammer-bitflips-can-bypass-ecc-protections/">reincarnation of Rowhammer for ECC memory</a> . <br><br>  Much remains beyond the scope of this article.  We barely touched the internal workings of the memory subsystem.  For further reading, I recommend: <br><br><ul><li>  <a href="http://lackingrhoticity.blogspot.com/2015/04/l3-cache-mapping-on-sandy-bridge-cpus.html">L3 cache mapping on Sandy Bridge processors</a> </li><li>  <a href="https://habr.com/post/431102/">How a physical address is matched with strings and banks in DRAM</a> </li><li>  <a href="https://habr.com/post/431128/">Hanna Hartikainen cracked DDR3 SO-DIMM and made him work ... slower</a> </li></ul><br>  Finally, here is a good description of old ferrite memory: <br><br><ul><li>  <a href="http://www.psych.usyd.edu.au/pdp-11/core.html">Explanation of ferrite memory PDP-11 from the University of Sydney</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/431010/">https://habr.com/ru/post/431010/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430990/index.html">Weekend repair or how to fix Saitek Rhino X55 / X56 throttl controller</a></li>
<li><a href="../430996/index.html">Elusive littleBigPlanet bug</a></li>
<li><a href="../430998/index.html">Release XMPP (Jabber) server Prosody 0.11.0</a></li>
<li><a href="../431004/index.html">The Chinese facial recognition system considered the image of a person on the bus as a traffic offender.</a></li>
<li><a href="../431006/index.html">InSight prepares to land on Mars</a></li>
<li><a href="../431012/index.html">Create an eBook reader with PDFKit on Swift</a></li>
<li><a href="../431014/index.html">Flexbox. Technology infographics</a></li>
<li><a href="../431016/index.html">US is asking partners to abandon the use of Huawei equipment</a></li>
<li><a href="../431018/index.html">Are you implementing a CRM system? Take off the rose-colored glasses</a></li>
<li><a href="../431020/index.html">Rome Club Report 2018, Chapter 1.7, Unsustainable Population Growth and Urbanization</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>