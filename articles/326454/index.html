<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Super Strengths WinDbg for .NET Developers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuing the series of publications on the reports at conferences, we stopped at the best report of DotNext 2016 Moscow, in which Sasha goldshtn Gol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Super Strengths WinDbg for .NET Developers</h1><div class="post__text post__text-html js-mediator-article">  Continuing the series of publications on the reports at conferences, we stopped at the best report of DotNext 2016 Moscow, in which Sasha <a href="https://habrahabr.ru/users/goldshtn/" class="user_link">goldshtn</a> Goldstein talks about the capabilities of WinDbg for debugging .NET applications.  This really powerful tool allows you to solve problems that the Visual Studio built-in debugger cannot handle. <br><br>  Especially this material will be useful to those who find it difficult to watch the reports in English, since the transcript is translated into great and mighty! <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/8t1aTbnZ2CE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  Windbg is considered to be a very complex tool that only hardcore C ++ developers can use.  However, in this report, I will show you when it can be useful for .NET developers and where WinDbg can be used to debug .NET applications when solving really complex tasks. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Some of you have already used WinDbg before, but I hope you learn something new from this report.  And to those who have not met with WinDbg, I hope to show what exactly this tool can do for you. <br><br><ul><li>  I'll start with some tips on how to make WinDbg more friendly, a bit more simple for .NET developers. <br><br></li><li>  I will talk about the power of scripts and breakpoints, which in many cases help me solve problems, as it seems to me, are not otherwise solved, especially in Windows. <br><br></li><li>  I'll tell you about some useful extensions.  WinDbg is notable for a good extension model - you can download add-ons that run arbitrary code to help you figure out things that the debugger itself can't handle. <br><br></li><li>  Let's talk a little about remote debugging, since this script is also very simple in WinDbg. <br></li></ul><br>  The Visual Studio debugger, which most of us use every day, cannot cope with approximately 90% of the material that I am going to show.  That is why I show you all this with WinDbg (and not at all because it is such a fun tool).  It does have a power that Visual Studio does not have. <br><br><h2>  When you can not do Visual Studio </h2><br>  Can Visual Studio be called a powerful debugger? <br><br>  He is not bad.  But this is a toy for people who like to use the mouse or hotkeys.  Compared to really powerful debuggers like JDB with IDEA, DDD or WinDbg, Visual Studio is a kind of toy.  It no longer contains macros, as in Visual Studio 2012, so it is very difficult to extend the debugger with your own scripts;  there are virtually no extensions for the debugger mechanism itself.  In addition, Visual Studio is great if you have the source code.  But if you don't have the source code for a particular thing, it will be much more difficult to do something.  You can hardly do anything. <br><br>  Therefore, I like Visual Studio, but there are a number of cases when a more powerful tool is needed. <br><br>  Probably, some of you saw the <a href="https://www.reddit.com/r/ProgrammerHumor/comments/3mun55/evolution_of_linux_neckbeardsxpost/">original of this diagram on Reddit</a> in the edition for Linux distributions. <br><img src="https://habrastorage.org/files/0be/796/2f1/0be7962f1e1644a88049f0f4d387d794.png"><br><br>  Here, Visual Studio is the shortest beard.  Real geeks use WinDbg, cdb, which is the console version of WinDbg, and so on.  In other words, you can always find hardcore to learn. <br><br>  So let's take a look at some of the things that first make WinDbg a little easier to use. <br><br><h2>  Making WinDbg Less Chilling </h2><br><h3>  Interactive menu </h3><br>  One of the reasons why WinDbg is so scary is the need to memorize a huge number of commands.  There are several menus and shortcuts, but more often you have to type a lot of text commands manually. <br><br>  However, WinDbg has a <code>.cmdtree</code> command that creates this nice menu for you: <br><br><img src="https://habrastorage.org/files/ae0/7ce/567/ae07ce567b734caabc212bf57ecf847b.png"><br><br>  You can navigate the menu with the mouse, running useful commands.  In <a href="https://github.com/goldshtn/windbg-extensions/blob/master/cmdtree.txt">one of my repositories</a> there is an example of a file of an interactive tree of useful commands grouped into categories.  Such a menu makes it a little easier to work with WinDbg for beginners. <br><br><h3>  Links in the output </h3><br>  I assume that many do not like WinDbg also because the output of commands is so terrible.  And almost always have to use copy-paste - take the result of the execution of one command and transfer it to another team. <br><br>  For those who don‚Äôt like it, there is an option that has been enabled for a long time by default in the WinDbg versions called DML (DML is a debugger markup language; I‚Äôll show you later).  Thanks to this option, in recent versions of the debugger, the output of the commands has links.  Just click on the link to get something else. <br><br>  In the example below, I ran a command called <code>!name2ee</code> , which takes the name of the class (in this example, the C # class) and gives me some information about the class, in particular, in which assembly it is located. <br><br><img src="https://habrastorage.org/files/eb4/0d1/608/eb40d160836d41b7b642bef7475a2681.png"><br><br>  The command output has links that I can click on.  For example, if I click on the link next to the EEClass field, I‚Äôll get this: <br><br><img src="https://habrastorage.org/files/592/910/632/592910632aa24ef28b96075bfabd3f27.png"><br><br>  The link runs another command that displays information about the type.  As you can see at the bottom of the screenshot, there is a Field, Type and additional information about this field.  And again there are links.  If you click on them, get more information and so on.  When you do not remember all the commands, studying the results of the team‚Äôs work will be more useful if you have this toolkit. <br><br><h3>  Automation </h3><br>  Another feature that scares in WinDbg is that some simple things require you to enter a large amount of text.  But there is another useful thing that many people don‚Äôt know about: you can run WinDbg, execute several commands at once, and at the end just exit (I‚Äôll show you a few examples).  In essence, WinDbg has the -c option, which takes the command line. <br><br>  This feature is easier to demonstrate live using the example of a dump file of a process that failed. <br><br>  In the folder C: \ temp I have saved several dump files.  I also have WinDbg and cdb - as I said, this is the console version of WinDbg.  I will open with WinDbg (cdb) one of the dump files. <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">cdb</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.exe</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-z</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">C</span></span>:\<span class="hljs-selector-tag"><span class="hljs-selector-tag">temp</span></span>\<span class="hljs-selector-tag"><span class="hljs-selector-tag">FileExplorer</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.exe</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.14804</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.dmp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-c</span></span> "<span class="hljs-selector-class"><span class="hljs-selector-class">.logopen</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">C</span></span>:\<span class="hljs-selector-tag"><span class="hljs-selector-tag">temp</span></span>\<span class="hljs-selector-tag"><span class="hljs-selector-tag">crash</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.log</span></span>; !<span class="hljs-selector-tag"><span class="hljs-selector-tag">analyze</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-v</span></span>; <span class="hljs-selector-class"><span class="hljs-selector-class">.logclose</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">q</span></span>"</code> </pre> <br>  <code>-z</code> - switch for dump. <br>  <code>-c</code> - allows you to run the command immediately after opening the dump. <br><br>  The main thing - do not forget to close the file and exit at the end. <br><br>  <code>".logopen C:\temp\crash.log; !analyze -v; .logclose; q"</code> - this command line analyzes the dump file, giving me some useful information. <br><br>  <code>.logopen</code> opens a log file, where output is performed (log files are more convenient to use, since we can analyze it later by applying a search on a string inside the file). <br><br>  Here we have some basic automation of the debugger: I can start the debugger, analyze the dump file, put all this into a log file and exit.  And these actions are repeatable - they can be performed in batch mode. <br><br>  As a result, we get information about what happened in the dump.  At the end of the output contains information about the response, the call stack and other useful details. <br><br>  One more example.  Here I ran <code>findstr</code> in the output results to find the name of the fallen process and which function caused the exception. <br><br><img src="https://habrastorage.org/files/7e9/3a4/9ef/7e93a49efc9d408db30a841ceef545c3.png"><br><br>  There is also information about the operating system, CLR version - in general, a lot of useful things. <br><br>  Again, an example is a method that I often use in searching for memory leaks.  When you have a memory leak, it is clear that the process is getting bigger and bigger.  And you need to periodically connect to it, and then disconnect.  Here's how to do this with WinDbg. <br><br><img src="https://habrastorage.org/files/e0a/2eb/212/e0a2eb21284845b984b705e1bc407219.png"><br><br>  I run cdb (because I like it more) with the <code>-pn</code> for a process that may have a memory leak (which I want to join).  Next, I give the command <code>!dumpheap</code> , which displays statistics for .NET heap objects.  The <code>-min</code> means that in this case I only need objects larger than 10,000 bytes.  At the end, using <code>qd</code> complete the work and disconnect. <br><br>  After running this command, WinDbg connects to the process, displays the top objects in a heap of more than 10,000 bytes in size and disconnects from the process.  In other words, this is an almost instant way to find out what is happening with memory.  The same can be run in batch mode.  Good luck to those who would like to do something similar in Visual Studio. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/af6/3b3/231/af63b323111821ad8f739e1161e4a4ff.png"><br><br><h2>  Script language WinDbg </h2><br>  I hope that the above examples of automation prove that when you have a powerful debugger, you can run it automatically, write the script and use it repeatedly.  But to really take advantage of the reusability, you need to understand how the scripting language works - the most difficult and ‚Äúterrible‚Äù part of WinDbg. <br><br>  WinDbg has a built-in scripting language, but this language has never been purposefully developed.  It is not like C #, which is designed by a separate committee.  This is a language that appeared gradually, someone added something to it, someone else corrected it.  So it turned out that we have. <br><br>  Let's take a look at this script (there are many more examples, there are relevant tutorials, but we will not turn this conversation into a training course on scripts in WinDbg). <br><br><img src="https://habrastorage.org/files/6fa/5cc/26b/6fa5cc26b0ae49ca90c66b3616f98209.PNG"><br><br>  Here, the first line initializes the <code>$t0</code> variable with a value of <code>0</code> .  It is easy.  The second line places a stop point in a specific function.  The <code>NtAllocateVirtualMemory</code> function is a Windows API that allocates memory.  One way or another, memory allocations must go through this API. <br><br>  Whenever we hit a breakpoint (when we call this function), I execute the command inside quotes: I increase the <code>$t0</code> variable with some kind of scary expression (here the <code>rdx</code> variable contains the amount of allocated memory). <br><br>  Then I entered <code>g</code> to keep the application running.  After I use the <code>.printf</code> command to print the current value of the <code>$t0</code> variable, which will tell me the total amount of allocated virtual memory. <br><br>  In other words, we set a breakpoint.  Each breakpoint increases a variable by the number of bytes allocated.  When I need to, I simply output the value of this variable, getting information about how much memory has been allocated. <br><br><h2>  Breakpoints </h2><br>  The general approach, which is to put a breakpoint somewhere and do something for you, is extremely effective.  In Visual Studio, many use breakpoints to simply stop the debugger.  That's great, I do that too.  But the real power of the breakpoint is that it can work for you (and not you at it). <br><br>  Here are a couple of examples of this. <br><br>  Let's say I have an application that creates files, but I don't know where these files come from.  The application continues to create files, but does not delete them, but blocks them.  Thus, while the application is running, I cannot delete these files.  Surely many were faced with a similar situation. <br><br>  Suppose I want to find out where these files come from.  There are several ways to do this.  The easiest is to add a breakpoint.  Let's put a breakpoint where we create the files, and see where they come from. <br><br><img src="https://habrastorage.org/files/9c2/060/eb1/9c2060eb130046bfa3f3fb8f2cea303f.png"><br><br>  The Windows API has two main functions for opening files: <code>CreateFileW</code> and <code>CreateFileA</code> . <br><br>  Whenever I call one of these functions, I display the name of the file being opened. <br>  Here <code>@esp</code> is the stack pointer for 32-bit processes (x86), and <code>@esp+4</code> is the first parameter of the function (you don‚Äôt need to remember this, you can find out all this by going to the debugger).  If you call <code>CreateFileW</code> , the file name is a Unicode string, so I use the <code>%mu</code> format, and if it is <code>CreateFileA</code> , then the file name is an ANSI string, and then I use <code>%ma</code> . <br><br>  Next, I type the file name and three dashes.  The <code>k</code> command shows me the call stack.  As a result, whenever my application opens a file, I get a message in my debugger about which file I open (the call stack shows how we got there).  The example above is the C ++ call stack, but the same can be done for a .NET application.  Consider a couple of additional examples. <br><br>  Suppose my application complains about missing files ‚Äî that a file cannot be opened.  But it does not tell me why and where.  All I get is a stupid ‚Äúcan't open file‚Äù error message or something like that.  This happens quite often. <br><br>  Just put a breakpoint, though a little more complicated.  It should reveal that an error occurred (I could not open the file).  To do this, we put it in <code>CreateFileW</code> (in the example below, a small error: there should not be an offset of <code>0x61</code> , please ignore it). <br><br><img src="https://habrastorage.org/files/945/3d8/d07/9453d8d07aa04906b8385cca394a27cc.png"><br><br>  So, we place breakpoint in <code>CreateFileW</code> .  The <code>gu</code> command will be executed before returning from this function.  After stopping, we check the <code>@eax</code> register.  In 32-bit Windows, <code>@eax</code> stores the result of a function.  On 64-bit Windows, <code>@rax</code> carries essentially the same load.  If the return value is zero, then the file could not be created.  If the debugger sees that the call did not work, I print out which file I was unable to open (and again I can print the call stack where it happened). <br><br>  Again the debugger works for me, and not vice versa.  I'm not trying to find in my code all the places where I could open the file.  I just say to the debugger: "Let me know when the opening of the file fails." <br><br>  Here is a real example from StackOverflow. <br><br><img src="https://habrastorage.org/files/685/b8c/be5/685b8cbe54c54463bfb4f92791bc79eb.png"><br><br>  What a long description of the problem!  This guy is trying to understand something.  And at the end he asks the following question: ‚ÄúThis definition raises the question: who then calls VirtualAlloc?  Is this a heap or .NET runtime? ‚Äù <br><br>  I think you know how to handle this task. <br><br><img src="https://habrastorage.org/files/ab6/91b/15f/ab691b15f7bf4ac1b5fd93c24a86dfce.png"><br><br>  We set a breakpoint in <code>VirtualAlloc</code> and figure out everything you need.  It's pretty obvious - you want to know who is calling a function?  Put a breakpoint there and get the information you need, what could be simpler?  So, we put a breakpoint in <code>VirtualAlloc</code> , and then output how much memory is allocated.  We are also printing - this is an example I‚Äôm talking about - the managed code call stack ( <code>!clrstack</code> ). <br><br>  So, in this example, you see: I allocate virtual memory from the garbage collector.  On the <code>gc_heap</code> stack, <code>grow_heap_segment</code> , <code>virtual_alloc_commit_for_heap</code> , which was called <code>XMLDictionaryReader</code> to read the contents. <br><br>  The technique of placing a breakpoint anywhere with subsequent processing is perhaps the most important thing I give in this report.  This is an incredibly powerful tool that simply does not exist in Visual Studio.  Visual Studio is good when you have the source code into which you want to insert a breakpoint.  But when you have to work with custom actions, conditions, etc., in Visual Studio you will find only basic support.  With WinDbg you can do much more!  WinDbg is also much better if you do not have the source code into which you want to insert a breakpoint (for example, if you plan to put it in Windows API calls or some internal CLR functions).  I can't say that WinDbg is very friendly, but it is definitely very powerful. <br><br>  Switch to another example.  Suppose you have this huge collection of objects in which there is one bad object.  Why is the object bad?  For example, it contains the character a with a small dot breaking the encoding.  I want to find this ‚Äúbroken‚Äù object. <br><br><img src="https://habrastorage.org/files/51d/ff0/6b3/51dff06b33d44cc5aac6993c4eea598a.png"><br><br>  Not very nice, but it works.  Toward the end of the report I will show another way to solve this problem.  So, first we will find where the class is <code>!name2ee OrderService!OrderService.Order</code> . <br><br>  This is the class I'm looking for - <code>Order</code> .  Good.  Next, we do a class dump to find out where the field I need is located (relative to the beginning of the object). <br><br>  I'm interested in the <code>Address</code> field.  As we see, here the offset is 4 relative to the beginning of the object: <br><br><img src="https://habrastorage.org/files/0a0/e02/125/0a0e02125a514a2f88dd756a99cbf3d7.png"><br><br>  All that is left to do is to find <code>Order</code> objects in my heap and find the line with offset 4 from the beginning of the object.  After that I have to look inside the line and see if there is ‚Äúa with a round dot on top‚Äù. <br><br>  I will not rewrite the line once again - this is unnecessary, but I will mention a few key points: <br><br><ul><li>  There is a <code>.foreach</code> loop that runs a debugger.  This is pretty "crazy."  And in this cycle <code>.foreach</code> there is an additional operator <code>.if</code> - i.e.  real program logic.  Not that there was no other way to do this, but perhaps the easiest way to accomplish this with WinDbg is to write your own code to analyze a collection of objects (you can do this if you have access to a system that runs the process) . <br></li><li>  As a result, for some object the address field actually has a with a dot on top. <br></li><li>  This is the object I was looking for: ‚Äú233 H√•mpton Street‚Äù.  The idea is that the debugger executes the program for us. <br></li></ul><br>  In the last example (before moving on to extensions), I will show some cool commands. <br><br>  There is a mysterious team <code>wt</code> , few know what it means.  It traces the execution of the code.  You take a function, run <code>wt</code> and it prints out all the calls that this function performs.  At the same time you can limit the depth of the trace. <br><br>  For example, I was curious about what the garbage collector does during <code>mark_phase</code> .  So let's put a breakpoint in the garbage collector function called <code>mark_phase</code> and run <code>wt</code> . <br><br><img src="https://habrastorage.org/files/317/590/84d/31759084d07a4cadaeb95e4a630c6e9f.png"><br><br>  As a result, you get this beautiful tree (I have limited the depth to unity) - you get all the functions called by <code>mark_phase</code> .  If you're wondering how the garbage collector works, there are a lot of details here (calls <code>generation_size</code> , <code>GcScanRoots</code> , <code>scan_background_roots</code> and heaps of other functions).  Full output includes several pages.  At the end you will find a report with all the functions and the number of commands executed. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/891/478/643/8914786431068db8c1a07a90ee1864dc.png"><br><br>  Thus, you can see the most ‚Äúexpensive‚Äù functions in terms of the number of instructions: <code>mark_through_cards_for_segment</code> , <code>mark_through_cards_for_large_...</code> , etc. <br><br>  It looks like a profiler right inside the debugger.  It is important to emphasize that profiling goes step by step according to the instructions of the program.  It is very slow, i.e.  for profiling as such is not suitable.  But it is very good to understand what is happening in a particular method. <br><br><h2>  Extensions </h2><br>  In this part of the conversation, I'll show you a couple of useful extensions. <br><br><h3>  PyKD </h3><br>  And I'll start with an extension that allows you to write scripts for the debugger using something less awful. <br><br><img src="https://habrastorage.org/files/517/77d/963/51777d963ee44b98861d5457818a8055.png"><br><br>  Not as bad as the script you saw before.  This is a pretty nice extension, called PyKD.  What does PyKD do?  It allows you to run Python to automate WinDbg - i.e.  run WinDbg commands, analyze output, use Python tools with WinDbg. <br><br>  The example above is not very interesting.  Here I‚Äôm just trying to fix the stack if it‚Äôs broken.  However, the idea is that you have a Python API for most things that WinDbg can do.  One way not to write in the terrible language WinDbg is to use Python. <br><br>  I have, it seems to me, a good script created using PyKD, which I called heap_stat.py. <br><br><img src="https://habrastorage.org/files/962/a1f/ad1/962a1fad11b74fd4be58971195798c81.png"><br><br>  In fact, it is not for .NET, but for an application in C ++, but it gives C ++ developers some of the functionality that I showed earlier (viewing the heap and what objects are there).  For .NET, as you have seen, it is quite easy.  For C ++, this is a bit more complicated. <br><br>  This extension is a Python script that works with heap C ++, finds objects and displays the number of objects of this type.  In some cases, it can also display the total size.  It would be very difficult to do this using only the WinDbg scripting language, and using Python it even turns out to be nice.  This is Python, after all. <br><br><h4>  Extension Model </h4><br><br>  Let's look at some other extensions.  In principle, the expansion model is quite simple. <br><br><img src="https://habrastorage.org/files/72f/e59/698/72fe59698c7045f69adb21d2121a4d76.png"><br><br>  Every WinDbg extension is just a dll.  You can write it in C ++ or C # - in any language that supports exporting functions.  And then you pass your extension to the debugger and just run each function as a command. <br><br>  The extension has access to the debugger API.  Suppose if your extension wants to output something, for example, to view objects in memory, it gets access to the debugger interface. <br><br>  Here is a simple extension that I designed to demonstrate how, in principle, they look: <br><br><img src="https://habrastorage.org/files/681/ebb/f0f/681ebbf0fd334ad0bd502048442770c0.png"><br><br>  This extension scans the content by URL.  From the debugger, you can execute an HTTP request and print the resulting HTML code. <br><br>  The extension is written in C #, and it is quite simple, let's see how the result looks.  To do this, I run WinDbg and any process I can join (for example, Notepad).  After that I upload my extension - now I can go, for example, to google.com.  And if the Internet connection works, we get this result. <br><br><img src="https://habrastorage.org/files/83e/031/b1e/83e031b1e0084efa930ba9e8e4639834.png"><br><br>  This is probably the Russian language (I do not have the encoding). <br><br>  Interestingly, the output contains links directly in the debugger.  This makes its use more open to the user.  For example, if I click here on Blogger, at the bottom of the screen you will see that the debugger is performing another query - on another page.  As a result, we have a super simple text browser built into the debugger. <br><br>  Above, I gave a very simple example of extending the debugger, but I hope it will serve as a starting point for you.  If you are interested in creating your own extensions that are doing something really powerful, you can use this approach to design your own extensions.  It is not difficult, and you can create extensions in C #. <br><br>  Let's look at a few existing extensions (it‚Äôs not always necessary to write your own). <br><h4>  CMKD </h4><br>  Here is an example of a typical situation that I have to deal with when debugging 64-bit code. 64-   Windows    , -          . ,       ,        ,      ,       ‚Äî    .     Visual Studio,   WinDbg. <br><br><img src="https://habrastorage.org/files/72e/104/d03/72e104d03af742219df6cebf62152815.png"><br><br>      <code>WaitForMultipleObjects</code> ,    .    ,     .   : ¬´ ,  ,  ,  ¬ª.   4 , , ,  ,   ¬´ ¬ª 4 . <br><br>     ‚Äî <a href="http://www.codemachine.com/cmkd.html">cmkd</a> ,    .      ,    ,    . <br><br><img src="https://habrastorage.org/files/234/42a/b48/23442ab4877b43e38603aeb5d5411374.png"><br><br>      ,     <code>!stack</code> .        <code>WaitForMultipleObjects</code>   . CMKD  ,      . <br><br>   ,    ,      .   , ,  ,       <code>rdx</code>  ,   ,          <code>r13</code> . <code>r13</code> -      ,   .   ,    -  . <br><br>     ,        .    ,       .NET-,   C++  64-   Windows (    ,       ). <br><br><h4> SOSEX </h4><br>        ‚Äî <a href="http://www.stevestechspot.com/">SOSEX</a> .  ,   ,   WinDbg ,   SOSEX ‚Äî   ,     .NET  WinDbg. <br><br>  SOSEX       .        Microsoft,      (   SOSEX     ).     . <br><br>      SOSEX ‚Äî   heap.        heap .NET, ,      ,   heap     ‚Äî , 10  ‚Äî   ,    . <br><br>   ?     heap ‚Äî    ‚Äî        .    : <br><br><img src="https://habrastorage.org/files/264/eab/0aa/264eab0aa2604ff2ab5e14cd6c6b74e1.png"><br><br>     ‚Äî   <code>.foreach</code> ‚Äî     heap   ,     (,    ).  <code>!bhi</code>  ,   <code>!mroot</code>  ,   , ,    <code>Byte</code>   <code>Schedule</code> ,  ,   ,   <code>Employee</code> . <br><br>    .        ‚Äî  SOSEX    <code>!gcroot</code> .    30  ( 30 ) ‚Äî    5 .          ,      ,    (      30 ).      <code>!mroot</code>  30   0  (      ‚Äî ,   ,    ).  ,     .     heap,       WinDbg,   ‚Äî   SOSEX.       ‚Äî        heap.       . <br><br><h4> netext </h4><br>     ,     ,  <a href="https://netext.codeplex.com/">netext</a> .     Microsoft   ‚Äî  .     ,    .       ASP.NET.       ,      heap. <br><br><img src="https://habrastorage.org/files/d2b/4ee/5c8/d2b4ee5c89c645b4ac7ff840dfe9d0c0.png"><br><br>      ,     <code>!wruntime</code> ,       ASP.NET,    .    . <br><br>    <code>!whttp</code> ,    HTTP-,   heap.      HTTP-,       (    ).     ,    ,    , ,    . <br><br><img src="https://habrastorage.org/files/f7d/461/610/f7d4616104674a90825b888a491846f6.png"><br><br>   HTTP-    :     ,    (   )  ..     ASP.NET,      . <br><br> netext    SQL-  .         heap.    SQL,   ,   . <br><br><img src="https://habrastorage.org/files/340/86f/da8/34086fda80544fc986085cce64faca9a.png"><br><br> ,     <code>HttpContext</code>   <code>_request._rawUrl</code>  <code>_response._statusCode</code> .         abc        HTTP-. <br><br>       (   )? <br><br><img src="https://habrastorage.org/files/5e7/9ed/9ab/5e79ed9ab7fc48af95f063d0b48e2bcc.png"><br><br>        netext.   .    <code>Order</code> ,    <code>Address</code>    ,   <code>$addr</code>    .        .           ‚Äî        . <br><br> netext  ,        . <br><h4> tracer </h4><br>   ,     (,   , ) ‚Äî  .   tracer.   WinDbg,      . <br><br> ,       ,   ,   ,   ,    . tracer  ,     (   )  ,    ‚Äî    .       ,     . <br><br><img src="https://habrastorage.org/files/71f/d48/fd7/71fd48fd7668455f8e254500f1e46888.png"><br><br><h2>   </h2><br>            WinDbg,     , ,   ,        ,  Visual Studio. <br><br>   -      Visual Studio,        ,      Windows.     ,     ,             ‚Äî   .  WinDbg   ,    ,     ,   , TCP, SSL,  HTTP ‚Äî   ,    . <br><br>     . <br>   . <br><br><img src="https://habrastorage.org/files/b95/4fc/e3c/b954fce3c0274f089723c906124ed68b.png"><br><br>   cdb    (   TCP- 5050  )     . <br><br><img src="https://habrastorage.org/files/411/ccb/bf8/411ccbbf855e4a12bd4086b38f7f2584.png"><br><br>  ,    .            x86  : <br><pre> <code class="hljs pgsql">cdb -remote tcp:<span class="hljs-keyword"><span class="hljs-keyword">server</span></span>=localhost,port=<span class="hljs-number"><span class="hljs-number">5050</span></span></code> </pre> <br>       : ,         ,   ,  . <br><br>         .  Microsoft       ,  .           .  . <br><br>     WinDbg, ‚Äî   Smart Client. <br><br><img src="https://habrastorage.org/files/5de/566/f43/5de566f4394f46e2bcd88cb7794e66bf.png"><br><br>     ,     WinDbg     WinDbg  .       dbgsrv.exe,     ,     . <br><br>      ,           .  ,    ,   ‚Äî  ASP.NET. <br><br>       .   ,       ,    ‚Äî   . <br><br>      WinDbg. ,       ,   ¬´¬ª            .      -  ,   ¬´¬ª    ,       -  .  ,    ,  .  ,    ,       .      ,       .        ,   Visual Studio. <br><br>    .      WinDbg: <br><br><ul><li> <a href="https://github.com/goldshtn/windbg-extensions">https://github.com/goldshtn/windbg-extensions</a> <br></li></ul><br> CLRMD          : <br><br><ul><li> <a href="https://github.com/Microsoft/clrmd">https://github.com/Microsoft/clrmd</a> <br></li></ul><br>  : <br><br><ul><li> <a href="https://netext.codeplex.com/">https://netext.codeplex.com/</a> <br></li><li> <a href="http://www.stevestechspot.com/">http://www.stevestechspot.com/</a> <br></li><li> <a href="http://www.codemachine.com/tool_cmkd.html">http://www.codemachine.com/tool_cmkd.html</a> <br></li></ul><br> msos ‚Äî CLI-,   C#: <br><br><ul><li> <a href="https://github.com/goldshtn/msos">https://github.com/goldshtn/msos</a> <br></li></ul><br><hr><br> <i>20-         ‚Äî ¬´ <a href="https://dotnext-piter.ru/talks/the-performance-investigators-field-guide/">The Performance Investigator's Field Guide</a> ¬ª,        DotNext 2017 Piter (      ‚Äî 19-20 ). <br><br>        ,        <a href="https://dotnext-piter.ru/trainings/production-performance-and-troubleshooting-of-net-applications/">¬´Production Performance and Troubleshooting of .NET Applications¬ª</a></i> </div><p>Source: <a href="https://habr.com/ru/post/326454/">https://habr.com/ru/post/326454/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326442/index.html">Asynchronous functions 101</a></li>
<li><a href="../326444/index.html">Customer service: people are better than robots</a></li>
<li><a href="../326446/index.html">Recruitment marketing guide for dummies (and not only)</a></li>
<li><a href="../326448/index.html">UX strategy. Part 5 - Exhaust Design</a></li>
<li><a href="../326450/index.html">Icinga2 simple option</a></li>
<li><a href="../326456/index.html">GitLab 9.0 Released: Subgroups and Deploy Boards</a></li>
<li><a href="../326458/index.html">Cloud Server Monitoring: HostTrecker Solutions</a></li>
<li><a href="../326460/index.html">DroidScript - a simple and functional tool for developing mobile applications for Android</a></li>
<li><a href="../326472/index.html">Component library as a tool to maintain website integrity</a></li>
<li><a href="../326476/index.html">Work from home is one of the main bonuses that programmers require.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>