<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Understanding Monads with Javascript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The original article is Understanding Monads With JavaScript ( Ionu»õ G. Stan ). 
 I would be grateful for comments on errors / typos / inaccuracies of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Understanding Monads with Javascript</h1><div class="post__text post__text-html js-mediator-article">  The original article is <a href="http://igstan.ro/posts/2011-05-02-understanding-monads-with-javascript.html">Understanding Monads With JavaScript</a> ( <a href="http://igstan.ro/">Ionu»õ G. Stan</a> ). <br>  I would be grateful for comments on errors / typos / inaccuracies of the translation in PM <br><br><h3>  From the author </h3><br>  For the past few weeks, I've been trying to understand monads.  I'm still learning Haskell, and, to be honest, I thought I knew what it was, but when I wanted to write a small library ‚Äî well, for training ‚Äî I found that although I understand how monadic <code>bind (&gt;&gt;=)</code> works <code>bind (&gt;&gt;=)</code> and <code>return</code> , but I can't imagine where the state comes from.  So, probably, I don‚Äôt understand how it all works.  As a result, I decided to re-examine the monads using the example of Javascript.  The plan was the same when I displayed <a href="http://igstan.ro/posts/2010-12-01-deriving-the-y-combinator-in-7-easy-steps.html">Y Combinator</a> : I took the original task (here it is an interaction with an immutable state clearly), and went all the way to the solution, changing the original code step by step. <br><a name="habracut"></a><br>  I chose Javascript, because it forces me to write everything that Haskell obligingly hides due to its laconic syntax or various semantics (lambda expressions, operators and embedded function currying).  And finally, I'm better at comparing, so I solved this problem also on CoffeeScript and Scheme, here are links to code snippets: <br><br><ul><li>  CoffeeScript: <a href="https://gist.github.com/936519">gist.github.com/936519</a> </li><li>  Scheme: <a href="https://gist.github.com/936695">gist.github.com/936695</a> </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Restrictions </h3><br>  In this article I will confine myself to the monad of state, this is enough to understand what monads are in general.  So here are our limitations: <br><br><ul><li>  <strong>no changeable state</strong> <br>  Haskell uses monads, since it does not have a mutable state. <br></li><li>  <strong>no explicit state</strong> <br>  When you do not have a mutable state, you are forced to pass the resulting state everywhere.  Writing and reading such a code is hardly fun, while monads hide all this ugliness (you will see it later). <br></li><li>  <strong>no duplication of code</strong> <br>  This remark goes hand in hand with the previous one, but I still carry it separately, because removing duplicate code is a powerful tool for exploring new heights. <br></li></ul><br><br><h3>  Mnogoubufniasilya </h3><br>  The article turned out to be quite saturated, so I thought it would be nice to add additional material, and recorded a short video with all the steps that are described below.  This is like the tl; dr version, and should help show all the described transitions, but it looks like watching the video will not be very useful without reading the article. <br>  I recommend watching it directly on <a href="http://vimeo.com/23125621">Vimeo</a> , where it is available in HD. <br><br><h3>  Our guinea pig </h3><br>  I will use the stack as our test subject, because it has an easy-to-understand structure, and its normal implementation uses state changes.  Here is how the javascript stack is usually implemented: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stack = []; stack.push(<span class="hljs-number"><span class="hljs-number">4</span></span>); stack.push(<span class="hljs-number"><span class="hljs-number">5</span></span>); stack.pop(); <span class="hljs-comment"><span class="hljs-comment">// 5 stack.pop(); // 4</span></span></code> </pre><br><br>  An array in Javascript has all the methods we expect to see in the stack: <code>push</code> and <code>pop</code> .  What I don‚Äôt like is that they change a state.  Well, at least I don't like it in this article. <br>  Every step I describe is a worker.  Just open the console of your browser, and refresh this page: you will see several groups of lines <code>5 : 4</code> .  However, in the text of the article I will only bring changes from the previous step. <br><br><h3>  Stack with explicit state handling </h3><br>  The obvious solution for avoiding a changeable state is to create a new state object for each change.  In Javascript, this might look like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// .concat()  .slice() -   ,    ,     ,     var push = function (element, stack) { var newStack = [element].concat(stack); return newStack; }; var pop = function (stack) { var value = stack[0]; var newStack = stack.slice(1); return { value: value, stack: newStack }; }; var stack0 = []; var stack1 = push(4, stack0); var stack2 = push(5, stack1); var result0 = pop(stack2); // {value: 5, stack: [4]} var result1 = pop(result0.stack); // {value: 4, stack: []}</span></span></code> </pre><br><br>  As you can see, <code>pop</code> and <code>push</code> return the resulting stack.  <code>pop</code> also returns the value from the top of the stack.  Each subsequent stack operation uses a previous version of the stack, but this is not so obvious due to the difference in the representation of the returned values.  We can strengthen the duplication of code by normalizing the returned values: make <code>push</code> return <code>undefined</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> push = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element, stack</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newStack = [element].concat(stack); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: value, <span class="hljs-attr"><span class="hljs-attr">stack</span></span>: newStack }; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pop = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stack</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = stack[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newStack = stack.slice(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: value, <span class="hljs-attr"><span class="hljs-attr">stack</span></span>: newStack }; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stack0 = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result0 = push(<span class="hljs-number"><span class="hljs-number">4</span></span>, stack0); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result1 = push(<span class="hljs-number"><span class="hljs-number">5</span></span>, result0.stack); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result2 = pop(result1.stack); <span class="hljs-comment"><span class="hljs-comment">// {value: 5, stack: [4]} var result3 = pop(result2.stack); // {value: 4, stack: []}</span></span></code> </pre><br><br>  This is the same duplication of code, which I mentioned above.  Duplication, which also means explicit state transfer. <br><br><h3>  Rewrite the code in the continue transfer style </h3><br>  Now I will replace these intermediate results with function calls, since it is easier for me to abstract away from functions and parameters than simple variables.  To do this, I will create a <code>bind</code> helper function that simply applies the transferred <em>continuation</em> to the result of the stack operation.  In other words, it <em>binds a</em> continuation to a stack operation. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bind = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value, continuation</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> continuation(value); }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stack0 = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalResult = bind(push(<span class="hljs-number"><span class="hljs-number">4</span></span>, stack0), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result0</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bind(push(<span class="hljs-number"><span class="hljs-number">5</span></span>, result0.stack), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result1</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bind(pop(result1.stack), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bind(pop(result2.stack), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result3</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = result2.value + <span class="hljs-string"><span class="hljs-string">" : "</span></span> + result3.value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: value, <span class="hljs-attr"><span class="hljs-attr">stack</span></span>: result3.stack }; }); }); }); });</code> </pre><br><br>  The value of the entire expression returned in <code>finalResult</code> is of the same type as the value of an individual <code>push</code> or <code>pop</code> operation.  We need a uniform interface. <br><br><h3>  Currying <code>push</code> and <code>pop</code> </h3><br>  Next, we need to detach the stack argument from <code>push</code> and <code>pop</code> , because we want <code>bind</code> pass it implicitly. <br>  To do this, we use another trick of lambda calculus, called <em>currying</em> .  In other words, it could be called procrastination of the use of a function. <br>  Now, instead of calling <code>push(4, stack0)</code> we will call <code>push(4)(stack0)</code> .  In Haskell, we would not need this step, because there the functions are already curried. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> push = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stack</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newStack = [element].concat(stack); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: value, <span class="hljs-attr"><span class="hljs-attr">stack</span></span>: newStack }; }; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pop = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stack</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = stack[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newStack = stack.slice(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: value, <span class="hljs-attr"><span class="hljs-attr">stack</span></span>: newStack }; }; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stack0 = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalResult = bind(push(<span class="hljs-number"><span class="hljs-number">4</span></span>)(stack0), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result0</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bind(push(<span class="hljs-number"><span class="hljs-number">5</span></span>)(result0.stack), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result1</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bind(pop()(result1.stack), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bind(pop()(result2.stack), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result3</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = result2.value + <span class="hljs-string"><span class="hljs-string">" : "</span></span> + result3.value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: value, <span class="hljs-attr"><span class="hljs-attr">stack</span></span>: result3.stack }; }); }); }); });</code> </pre><br><br><h3>  Preparing <code>bind</code> for passing stacks </h3><br>  As I said in the previous part, I would like <code>bind</code> deal with passing an argument with an explicit stack.  To do this, first, let's make it so that <code>bind</code> stack as the last parameter, but in the form of a curried function, i.e.  let <code>bind</code> return a function that takes a stack as an argument.  Also, now <code>push</code> and <code>pop</code> partially applied, that is, we no longer pass them the stack directly, this is now done by <code>bind</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bind = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stackOperation, continuation</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stack</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> continuation(stackOperation(stack)); }; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stack0 = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalResult = bind(push(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result0</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bind(push(<span class="hljs-number"><span class="hljs-number">5</span></span>), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result1</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bind(pop(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bind(pop(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result3</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = result2.value + <span class="hljs-string"><span class="hljs-string">" : "</span></span> + result3.value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: value, <span class="hljs-attr"><span class="hljs-attr">stack</span></span>: result3.stack }; })(result2.stack); })(result1.stack); })(result0.stack); })(stack0);</code> </pre><br><br><h3>  Remove stacks at the end </h3><br>  Now we can hide the intermediate stacks by changing <code>bind</code> so that it analyzes the return value of the <code>stackOperation</code> function, <code>stackOperation</code> out the stack, and <code>stackOperation</code> it to the continuation, which should be a function that accepts the stack.  We must also wrap the return value <code>{ value: value, stack: result3.stack }</code> into an anonymous function. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bind = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stackOperation, continuation</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stack</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = stackOperation(stack); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newStack = result.stack; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> continuation(result)(newStack); }; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> computation = bind(push(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result0</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bind(push(<span class="hljs-number"><span class="hljs-number">5</span></span>), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result1</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bind(pop(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bind(pop(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result3</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = result2.value + <span class="hljs-string"><span class="hljs-string">" : "</span></span> + result3.value; <span class="hljs-comment"><span class="hljs-comment">// We need this anonymous function because we changed the protocol // of the continuation. Now, each continuation must return a // function which accepts a stack. return function (stack) { return { value: value, stack: stack }; }; }); }); }); }); var stack0 = []; var finalResult = computation(stack0);</span></span></code> </pre><br><br><h3>  Hide remaining stack </h3><br>  In the previous implementation, we hid several intermediate stacks, but added another one, in the function that returns the final value.  We can hide this stack trace by writing another <code>result</code> helper function.  In addition, it will hide the view of the state we are storing - a structure with two fields, <code>value</code> and <code>stack</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stack</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: value, <span class="hljs-attr"><span class="hljs-attr">stack</span></span>: stack }; }; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> computation = bind(push(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result0</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bind(push(<span class="hljs-number"><span class="hljs-number">5</span></span>), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result1</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bind(pop(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bind(pop(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result3</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result(result2.value + <span class="hljs-string"><span class="hljs-string">" : "</span></span> + result3.value); }); }); }); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stack0 = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalResult = computation(stack0);</code> </pre><br><br>  This is exactly what the <code>return</code> function in Haskell does.  It wraps the result of the calculation in a monad.  In our case, it wraps the result in a closure that the stack accepts, and this is precisely the monad of computations with a variable state ‚Äî a function that takes its state.  In other words, <code>result/return</code> can be described as a factory function that creates a new context with a state around the value that we give it. <br><br><h3>  We make the state internal </h3><br>  We do not need our <em>continuations</em> to be aware of the structure returned by the <code>push</code> and <code>pop</code> functions, which actually represent the insides of the monad.  So we modify <code>bind</code> to transfer only the necessary minimum of data to callbacks. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bind = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stackOperation, continuation</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stack</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = stackOperation(stack); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> continuation(result.value)(result.stack); }; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> computation = bind(push(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bind(push(<span class="hljs-number"><span class="hljs-number">5</span></span>), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bind(pop(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result1</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bind(pop(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result(result1 + <span class="hljs-string"><span class="hljs-string">" : "</span></span> + result2); }); }); }); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stack0 = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalResult = computation(stack0);</code> </pre><br><br><h3>  Perform a stack calculation </h3><br>  Since we can combine stack operations, we want to perform these calculations and use the result.  This is generally called the evaluation of a monad.  In Haskell, a stateful computation monad provides three functions for computing it: <code>runState</code> , <code>evalState</code> and <code>execState</code> . <br>  For the purposes of this article, I will replace the <code>State</code> suffix with a <code>Stack</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Returns both the result and the final state. var runStack = function (stackOperation, initialStack) { return stackOperation(initialStack); }; // Returns only the computed result. var evalStack = function (stackOperation, initialStack) { return stackOperation(initialStack).value; }; // Returns only the final state. var execStack = function (stackOperation, initialStack) { return stackOperation(initialStack).stack; }; var stack0 = []; console.log(runStack(computation, stack0)); // { value="5 : 4", stack=[]} console.log(evalStack(computation, stack0)); // 5 : 4 console.log(execStack(computation, stack0)); // []</span></span></code> </pre><br><br>  If all we are interested in is the final calculated value, then <code>evalStack</code> is what we need.  It starts the monadic calculation, discards the final state, and returns the calculated value.  Using this function, we can pull the value out of the monadic context. <br>  If you have ever heard that you cannot escape (escape) from a monad, then I will say that this is true only in a small number of cases, such as the IO monad.  But this is another story, the main thing is that you can leave the monad of calculations with a variable state. <br><br><h3>  Is done </h3><br>  If you are still with me, then I will say that the monad in Javascript may look like this.  Not as cool and readable as in Haskell, but this seems like the best thing I could do. <br>  Monads are a rather abstract concept, because it almost does not indicate what to write.  Basically, it says that you have to create a function that takes several arguments (state in the case of a stateful monad) and two additional functions: <code>result</code> and <code>bind</code> .  The first will work as a factory for the function you created, and the second will provide the outside world with only the necessary data on the monad, and do all the boring work, such as passing a state, using the <em>continuation</em> that will receive the value computed by the monad.  Everything that should be inside the monad - remains inside.  Just like in OOP - you can even create monadic getters / setters. <br>  For the record, here‚Äôs what a Haskell <code>computation</code> would look like: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">computation</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> push <span class="hljs-number"><span class="hljs-number">4</span></span> push <span class="hljs-number"><span class="hljs-number">5</span></span> a &lt;- pop b &lt;- pop return $ (show a) ++ <span class="hljs-string"><span class="hljs-string">" : "</span></span> ++ (show b)</code> </pre><br><br>  The main reason why it looks better on Haskell is the support of monads at the syntax level in the form of <code>do</code> notation.  It's just sugar for a version that still looks better than in Javascript.  Haskell, thanks to support for operator redefinition and laconic lambda expressions, allows for a more readable implementation of monads: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">computation</span></span> = push <span class="hljs-number"><span class="hljs-number">4</span></span> &gt;&gt;= \_ -&gt; push <span class="hljs-number"><span class="hljs-number">5</span></span> &gt;&gt;= \_ -&gt; pop &gt;&gt;= \a -&gt; pop &gt;&gt;= \b -&gt; return $ (show a) ++ <span class="hljs-string"><span class="hljs-string">" : "</span></span> ++ (show b)</code> </pre><br><br>  In Haskell <code>&gt;&gt;=</code> , this is what I called <code>bind</code> in Javascript, and <code>return</code> is what I called <code>result</code> .  Yes, <code>return</code> in Haskell is not a keyword, but a function.  In other cases, <code>return</code> is a <code>unit</code> .  Brian Marick called <code>&gt;&gt;=</code> decider in his <a href="http://vimeo.com/20717301">Clojure monad video</a> .  Patcher, of course, he called <code>return</code> . <br><br><h3>  Some sugar for javascript </h3><br>  In fact, it is much better to perform monadic calculations in Javascript using the auxiliary function <code>sequence</code> .  Due to the dynamic nature of Javascript, the <code>sequence</code> can take an arbitrary number of arguments, which are monadic operations that must be executed sequentially, and the last argument an action that must be performed on the result of monadic actions.  All non-undefined monadic calculations will be passed to this callback. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sequence = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/* monadicActions..., continuation */</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> args = [].slice.call(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> monadicActions = args.slice(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> continuation = args.slice(<span class="hljs-number"><span class="hljs-number">-1</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stack</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initialState = { <span class="hljs-attr"><span class="hljs-attr">values</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">stack</span></span>: stack }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state = monadicActions.reduce(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = action(state.stack); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> values = state.values.concat(result.value); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stack = result.stack; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">values</span></span>: values, <span class="hljs-attr"><span class="hljs-attr">stack</span></span>: stack }; }, initialState); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> values = state.values.filter(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> continuation.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, values)(state.stack); }; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> computation = sequence( push(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-comment"><span class="hljs-comment">// &lt;- programmable commas :) push(5), pop(), pop(), function (pop1, pop2) { return result(pop1 + " : " + pop2); } ); var initialStack = []; var result = computation(initialStack); // "5 : 4"</span></span></code> </pre><br><br>  The authors of the book <a href="http://book.realworldhaskell.org/">Real World Haskell</a> compare monads with a software emulated semicolon ( <a href="http://book.realworldhaskell.org/read/monads.html">programmable semicolon</a> ).  In our case, we have a software-emulated comma, since I used it to separate monadic actions in a <code>sequence</code> . <br><br><h3>  Monads, like deferred calculations </h3><br>  Often you have heard how monads were called calculations.  At first I did not understand why.  We can say, they say, because they calculate different things, but no, no one says: ‚Äúmonads calculate‚Äù, they usually say, ‚Äúmonads are calculations‚Äù.  I finally understood (well, or think I understood) what this means after completing a draft article.  All these chains of actions and values ‚Äã‚Äãdo not calculate anything until they are told to do it.  It is simply a large chain of partially applied functions that can be performed after a call with an initial state.  Here is an example. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> computation = sequence( push(<span class="hljs-number"><span class="hljs-number">4</span></span>), push(<span class="hljs-number"><span class="hljs-number">5</span></span>), pop(), pop(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pop1, pop2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result(pop1 + <span class="hljs-string"><span class="hljs-string">" : "</span></span> + pop2); } );</code> </pre><br><br>  Does this piece of code calculate anything after execution?  Not.  You must run it with <code>runStack</code> , <code>evalStack</code> or <code>execStack</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initialStack = []; evalStack(computation, initialStack);</code> </pre><br><br>  It seems that <code>push</code> and <code>pop</code> produce actions on some global value, while in fact they are always waiting for this value to be passed to them.  It's almost like in OOP, when we have <code>this</code> as the context of the calculation.  In our case, this is implemented through currying and partial application, and also indicates a new context in each expression.  And, if in OOP the context is called implicit, then using monads you make it even more implicit (if there is one at all). <br>  The advantage of monads (and functional programming in general) is that you get easily combinable blocks.  And all this thanks to currying.  Each time two monadic actions are performed sequentially, a new function is created that is awaiting execution. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> computation1 = sequence( push(<span class="hljs-number"><span class="hljs-number">4</span></span>), push(<span class="hljs-number"><span class="hljs-number">5</span></span>), pop(), pop(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pop1, pop2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result(pop1 + <span class="hljs-string"><span class="hljs-string">" : "</span></span> + pop2); } ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> computation2 = sequence( push(<span class="hljs-number"><span class="hljs-number">2</span></span>), push(<span class="hljs-number"><span class="hljs-number">3</span></span>), pop(), pop(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pop1, pop2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result(pop1 + <span class="hljs-string"><span class="hljs-string">" : "</span></span> + pop2); } ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> composed = sequence( computation1, computation2, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result(a + <span class="hljs-string"><span class="hljs-string">" : "</span></span> + b); } ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( evalStack(composed, []) ); <span class="hljs-comment"><span class="hljs-comment">// "5 : 4 : 3 : 2"</span></span></code> </pre><br><br>  This may seem of little use when performing operations on a stack, but when designing, for example, a parser combinator library, this becomes quite useful.  This allows the library author to provide only a few primitive functions for the parser monad, and then the library user can mix these primitives as he needs, eventually coming to the built-in DSL. <br><br><h3>  the end </h3><br>  Well, I hope this article has been helpful to you.  Her writing (and translation - <i>note</i> ) definitely helped me to improve the understanding of monads. <br><br><h3>  Links </h3><br><br><h4>  Books </h4><br><ul><li>  <a href="http://www.cs.nott.ac.uk/~gmh/book.html">Programming in haskell</a> </li><li>  <a href="http://learnyouahaskell.com/">Learn You a Haskell For Great Good!</a> </li><li>  <a href="http://book.realworldhaskell.org/">Real world haskell</a> </li></ul><br><br><h4>  Articles and documents </h4><br><ul><li>  <a href="http://www.ccs.neu.edu/home/dherman/research/tutorials/monads-for-schemers.txt">A Schemer's Introduction to Monads</a> </li><li>  <a href="http://www.cs.nott.ac.uk/~gmh/bib.html">Monadic parsing in haskell</a> </li><li>  <a href="http://www.cs.nott.ac.uk/~gmh/bib.html">Monadic Parser Combinators</a> </li><li>  <a href="http://www.valuedlessons.com/2008/01/monads-in-python-with-nice-syntax.html">Monads in Python</a> </li><li>  <a href="http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html">What the hell are monads?</a> </li></ul><br><br><h4>  Video </h4><br><ul><li>  <a href="http://channel9.msdn.com/Shows/Going%2BDeep/C9-Lectures-Dr-Ralf-Lmmel-AFP-The-Quick-Essence-of-Functional-Programming">The Quick Essence of Functional Programming</a> </li><li>  <a href="http://vimeo.com/20717301">Monad Tutorial in Clojure, Part 1</a> </li><li>  <a href="http://vimeo.com/20798376">Monad Tutorial in Clojure, Part 2</a> </li><li>  <a href="http://vimeo.com/20963938">Monad Tutorial in Clojure, Part 3</a> </li><li>  <a href="http://vimeo.com/21307543">Monad Tutorial in Clojure, Part 4</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/238171/">https://habr.com/ru/post/238171/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../238161/index.html">Is it possible to consider the intellect artificial in the film "Superiority"</a></li>
<li><a href="../238163/index.html">Almost complete ruby ‚Äã‚Äãgems writing guide</a></li>
<li><a href="../238165/index.html">"Roskomnadzor" entered "Habrahabr" in the register of information dissemination organizers</a></li>
<li><a href="../238167/index.html">How to get control of Virtual Machine Sprawl: 7 useful reports in the Veeam Availability Suite</a></li>
<li><a href="../238169/index.html">Startup Guide, Part 6: Too Little Investment - How Much? And too much?</a></li>
<li><a href="../238173/index.html">Google Play Books are now available in Ukraine, Estonia, Latvia and Lithuania.</a></li>
<li><a href="../238175/index.html">The term of transfer of servers with personal data to Russia is reduced</a></li>
<li><a href="../238179/index.html">How do we write a web service for a billion users</a></li>
<li><a href="../238181/index.html">Why speak at IT conferences and meetings?</a></li>
<li><a href="../238183/index.html">Not so sat down: Apple responded to messages about the bent iPhone 6 and 6 Plus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>