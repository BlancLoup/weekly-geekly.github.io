<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing a plug-in dissector for Wireshark</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wireshark is one of the indispensable utilities for wiretapping a network when working with network protocols. The program already includes a certain ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing a plug-in dissector for Wireshark</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/f9c/59c/e06/f9c59ce06e1a3e697d174334a3510a70.png" alt="image" align="left">  <b>Wireshark</b> is one of the indispensable utilities for wiretapping a network when working with network protocols.  The program already includes a certain number of dissectors <a href="https://habr.com/ru/post/121990/"><sup>1</sup></a> , which help to examine in detail the packages of basic protocols.  But when working on a Nortel proprietary protocol, I was faced with a lack of a suitable dissector.  And he needed like air.  The solution was obvious - write your own.  What I did. <br>  Thus, having a little experience writing an ‚Äúanatomist‚Äù plug-in under Wireshark, I decided to share my knowledge and experience with the community.  Well, write for yourself, in case you need it in the future. <br><br><h6><a name="anch01"></a>  <b>Dissection</b> - lat.  dissectio, from dissecare, dissect </h6><a name="habracut"></a><br>  <i><b>Note 1:</b> when writing this article, I assumed that the reader is familiar with the Wireshark utility and also knows how to use its basic features.</i> <br><br>  <i><b>Note 2:</b> since I work under Linux, the plugin also wrote for this OS.</i>  <i>Under Windows, my plugin should also be built.</i>  <i>Differences, I think, will be only in make files.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i><b>Note 3:</b> since the protocol I was working on was proprietary and closed, and also because of the million non-disclosure agreements, in this article I consider my own, invented, protocol.</i> <br><br><h3>  Foo protocol </h3><br>  In a nutshell, I will describe an invented protocol, which I will call the plain name <i>Foo</i> .  Let this protocol be over the UDP protocol and have the following structure: <br><ul><li>  1 byte - protocol version </li><li>  1 byte - packet type </li><li>  1 byte - all sorts of flags </li><li>  1 byte - some boolean variable </li><li>  4 bytes - payload length </li><li>  From 0 to 200 bytes - payload </li></ul><h3>  Setting up the environment </h3><br>  Before you start writing a plugin, you need to put something, create something, change something somewhere.  Here is what Wireshark is asking to install: <br><ul><li>  python (I think any 2nd version, but definitely not 3rd) </li><li>  cmake </li><li>  bison </li><li>  flex </li></ul>  A complete list of required libraries and utilities is <a href="http://wiki.wireshark.org/Development">here</a> . <br><br>  After installing everything you need, download the Wireshark source for the version for which we will write the plugin.  In my case, the source code for the stable branch 1.6: <br><pre><code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> <span class="hljs-variable"><span class="hljs-variable">$HOME</span></span> $ svn co http://buildbot.wireshark.org/trunk-1.6/ wireshark</code> </pre> <br>  To make sure that the compilation works, as well as that all the necessary utilities and libraries are installed, run: <br><pre> <code class="bash hljs"> $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> wireshark $ ./autogen.sh $ ./configure</code> </pre> <br>  If everything is in order, then go to the plugins folder and create there your folder with the name of the protocol: <br><pre> <code class="bash hljs"> $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> <span class="hljs-variable"><span class="hljs-variable">$HOME</span></span>/wireshark/plugins $ mkdir foo $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> foo $ touch packet-foo.c</code> </pre> <br><h3>  Frame </h3><br>  Here I would like to start by identifying the framework of the plug-in, the main part of which is enough for Wireshark to pick up the plug-in. <br><br><h6>  packet-foo.c </h6><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> HAVE_CONFIG_H # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"config.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;epan/packet.h&gt; #define FOO_PORT 35000 /*  UDP ,       FOO . */ static int proto_foo = -1; /*       . */ void proto_register_foo(void) { proto_foo = proto_register_protocol ( "FOO Protocol", /*   */ "FOO", /*   */ "foo" /*  */ ); }</span></span></span></span></code> </pre> <br>  At the very beginning, we call the <b>proto_register_protocol ()</b> function, which registers the protocol and issues its unique identifier.  Functions we pass three different names of our protocol, which will be displayed in different parts of the program.  (For example, the names ‚ÄúFOO Protocol‚Äù and ‚ÄúFOO‚Äù are used in the Wireshark Settings, and the abbreviation ‚Äúfoo‚Äù is used in the filter field.) <br><br>  Next, we need to assign a function that will be called if necessary to decrypt the captured foo-package.  This is done by calling the <b>create_dissector_handle ()</b> function. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proto_reg_handoff_foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dissector_handle_t</span></span> foo_handle; foo_handle = create_dissector_handle(dissect_foo, proto_foo); dissector_add_uint(<span class="hljs-string"><span class="hljs-string">"udp.port"</span></span>, FOO_PORT, foo_handle); }</code> </pre> <br>  Here we register the processor-dissector, which performs the dirty work of decomposing the protocol in composition and binds it to the <b>proto_foo</b> protocol.  Then we connect our handler to the UDP port on which we expect traffic to go.  Thus, Wireshark will call ‚Äúus‚Äù when some activity appears on the port we set (35000). <br><br>  There is an agreement that the <b>proto_register_foo ()</b> and <b>proto_reg_handoff_foo () functions</b> must be written at the end of our source file. <br><br>  Now the most important thing is to write the code of the dissector itself. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dissect_foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">tvbuff_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *tvb, packet_info *pinfo, proto_tree *tree)</span></span></span><span class="hljs-function"> </span></span>{ col_set_str(pinfo-&gt;cinfo, COL_PROTOCOL, <span class="hljs-string"><span class="hljs-string">"FOO"</span></span>); col_clear(pinfo-&gt;cinfo, COL_INFO); }</code> </pre> <br>  This function will be called for detailed work on the packet that is passed to it.  Packet data is stored in a special buffer - <b>tvb</b> .  In <b>pinfo we</b> put general information about the protocol.  And in the <b>tree</b> , major changes occur when the final protocol view is determined in the output of Wireshark. <br>  In the first line, we set the value in the <i>Protocol</i> column.  In the second, we clear the <i>Info</i> column.  (Both columns are typically shown during packet capture.) <br><br>  Everything, at the moment there is a minimum of code in order to be able to safely assemble our plugin and upload it to Wireshark. <br><br><h3>  Plugin build </h3><br>  To build (under Linux) we need to get some files in our directory: Makefile.am, Makefile.common and moduleinfo.h. <br><ul><li>  Makefile.am - UNIX / Linux make file </li><li>  Makefile.common - common makefile for UNIX / Linux and Windows, contains plugin file names </li><li>  Makefile.nmake - make file for Windows </li><li>  moduleinfo.h - contains the plugin version </li><li>  moduleinfo.nmake - contains information about the version of the DLL for Windows </li><li>  packet-foo.c - our source code for the dissector </li></ul>  By the way, it is not necessary to bury in so many make files, since Wireshark provides a simpler way - to use cmake.  Due to this, the number of changes in make files is minimized.  To do this, create <i>CMakeLists.txt</i> in the folder with our plugin with the following content: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(DISSECTOR_SRC packet-foo.c ) <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(PLUGIN_FILES plugin.c <span class="hljs-variable"><span class="hljs-variable">${DISSECTOR_SRC}</span></span> ) <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(CLEAN_FILES <span class="hljs-variable"><span class="hljs-variable">${PLUGIN_FILES}</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WERROR) set_source_files_properties( <span class="hljs-variable"><span class="hljs-variable">${CLEAN_FILES}</span></span> PROPERTIES COMPILE_FLAGS -Werror ) endif() include_directories(<span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>) register_dissector_files(plugin.c plugin <span class="hljs-variable"><span class="hljs-variable">${DISSECTOR_SRC}</span></span> ) add_library(foo <span class="hljs-variable"><span class="hljs-variable">${LINK_MODE_MODULE}</span></span> <span class="hljs-variable"><span class="hljs-variable">${PLUGIN_FILES}</span></span> ) set_target_properties(foo PROPERTIES PREFIX <span class="hljs-string"><span class="hljs-string">""</span></span>) set_target_properties(foo PROPERTIES LINK_FLAGS <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${WS_LINK_FLAGS}</span></span></span><span class="hljs-string">"</span></span>) target_link_libraries(foo epan) install(TARGETS foo LIBRARY DESTINATION <span class="hljs-variable"><span class="hljs-variable">${CMAKE_INSTALL_LIBDIR}</span></span>/@CPACK_PACKAGE_NAME@/plugins/<span class="hljs-variable"><span class="hljs-variable">${CPACK_PACKAGE_VERSION}</span></span> NAMELINK_SKIP RUNTIME DESTINATION <span class="hljs-variable"><span class="hljs-variable">${CMAKE_INSTALL_LIBDIR}</span></span>/@CPACK_PACKAGE_NAME@/plugins/<span class="hljs-variable"><span class="hljs-variable">${CPACK_PACKAGE_VERSION}</span></span> ARCHIVE DESTINATION <span class="hljs-variable"><span class="hljs-variable">${CMAKE_INSTALL_LIBDIR}</span></span>/@CPACK_PACKAGE_NAME@/plugins/<span class="hljs-variable"><span class="hljs-variable">${CPACK_PACKAGE_VERSION}</span></span> )</code> </pre> <br>  <i><b>Note:</b> you can not memorize every time what the CMakeLists.txt file looks like, but copy it from the folder of any existing plug-in, for example, interlink.</i>  <i>And then replace all interlink references in this file with foo.</i> <br><br>  Then let us know about our plugin tools for automating the build process. <br><pre> <code class="bash hljs"> $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> <span class="hljs-variable"><span class="hljs-variable">$HOME</span></span>/wireshark/ $ vim CMakeLists.txt</code> </pre> <br>  Add the line "plugins / foo" given the indents: <br><pre> <code class="bash hljs">....... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ENABLE_PLUGINS) <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(HAVE_PLUGINS 1) <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(PLUGIN_DIR=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${DATAFILE_DIR}</span></span></span><span class="hljs-string">/plugins/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${CPACK_PACKAGE_VERSION}</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(PLUGIN_SRC_DIRS plugins/foo plugins/asn1 plugins/docsis .......</code> </pre> <br>  Now we create a directory in which files created during compilation and linking will be stored.  Next run the build process itself.  The following steps are performed from the <i>$ HOME / wireshark /</i> directory <br><pre> <code class="bash hljs"> $ mkdir build $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> build $ cmake .. $ make foo</code> </pre> <br>  If the compilation is successful, we will get the <i>foo.so</i> library in the <i>$ HOME / wireshark / build / lib /</i> folder. <br><br><h3>  Test run </h3><br>  Copy the <i>foo.so</i> file to the <i>/usr/lib/wireshark/plugins/1.6.0/</i> directory and launch Wireshark.  Go to the "Help -&gt; About Wireshark", go to the <i>Plugins</i> tab and in the list that appears we find our plugin - <i>foo.so.</i> <br><br>  To make sure that the plugin recognizes our protocol, we start packet capture and start packets with our protocol over the network.  (For example, I quickly wrote a program that sends the FOO protocol packet over the UDP network. You can find its code <a href="https://habr.com/ru/post/121990/">at the end of the article</a> .) <br><br><h3>  Working dissector </h3><br>  Now, when we have the framework of the plug-in, which is not doing anything useful for us, but at least it starts up, we will ‚Äúwrite‚Äù our protocol to it.  The simplest thing we can do is define the boundaries of our protocol. <br><br>  To do this, first of all, we create a branch on our tree ( <b>tree</b> ), into which we will place the decoding results.  The dissector is called in two different cases: in one case, when it is necessary to obtain summary information about the packet, and in another case, when it is necessary to output detailed information about the same packet.  If the pointer to the <b>tree</b> is NULL, then only the summary information is requested from us.  Otherwise, we are asked to fill the <b>tree with</b> detailed information that will be displayed to the Wireshark user.  With this in mind, our dissector takes the form: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dissect_foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">tvbuff_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *tvb, packet_info *pinfo, proto_tree *tree)</span></span></span><span class="hljs-function"> </span></span>{ col_set_str(pinfo-&gt;cinfo, COL_PROTOCOL, <span class="hljs-string"><span class="hljs-string">"FOO"</span></span>); col_clear(pinfo-&gt;cinfo, COL_INFO); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tree) { proto_item *ti = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; ti = proto_tree_add_item(tree, proto_foo, tvb, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, FALSE); } }</code> </pre> <br>  Here we have added a branch to a tree ( <b>tree</b> ) by calling <b>proto_tree_add_item ()</b> .  This thread will contain all the details about our <i>foo</i> protocol.  We also mark the data area in the packet that our protocol uses.  In our case, this is the entire area beyond the data boundary of the UDP packet, since we do not consider the case when our protocol contains another one. <br><br>  Parameters of the <b>proto_tree_add_item ()</b> function: <br><ul><li>  <b>tree</b> - all tree information about our package </li><li>  <b>proto_foo</b> is our protocol id </li><li>  <b>tvb</b> - data block (data transmitted by our protocol) </li><li>  <b>0</b> - specify the starting position at which the data in the <b>tvb</b> block is the data of our foo protocol </li><li>  <b>-1</b> - the number of bytes occupied by our protocol ("-1" means "to the end of the data block") </li><li>  <b>FALSE</b> - the byte order is specified (TRUE - if the bytes are located in the network order.) </li></ul>  After these changes, Wireshark will begin to determine where the region of our protocol begins and ends and marks it as ‚ÄúFOO Protocol‚Äù. <br><br>  The next step is to add details.  This step will require the creation of several arrays and additional function calls that will help with decoding.  The changes will affect the body of the <b>proto_register_foo ()</b> function shown earlier. <br><br>  Add two static arrays to the beginning of <b>proto_register_foo ()</b> .  Then we register these arrays after calling the <b>proto_register_protocol ()</b> function. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proto_register_foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> hf_register_info hf[] = { { &amp;hf_foo_hdr_version, { <span class="hljs-string"><span class="hljs-string">"FOO Header Version"</span></span>, <span class="hljs-string"><span class="hljs-string">"foo.hdr.version"</span></span>, FT_UINT8, BASE_DEC, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0x0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, HFILL } }, { &amp;hf_foo_hdr_type, { <span class="hljs-string"><span class="hljs-string">"FOO Header Type"</span></span>, <span class="hljs-string"><span class="hljs-string">"foo.hdr.type"</span></span>, FT_UINT8, BASE_DEC, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0x0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, HFILL } } }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> gint *ett[] = { &amp;ett_foo }; proto_foo = proto_register_protocol ( <span class="hljs-string"><span class="hljs-string">"FOO Protocol"</span></span>, <span class="hljs-string"><span class="hljs-string">"FOO"</span></span>, <span class="hljs-string"><span class="hljs-string">"foo"</span></span> ); proto_register_field_array(proto_foo, hf, array_length(hf)); proto_register_subtree_array(ett, array_length(ett)); }</code> </pre> <br>  And immediately after the declaration of the <b>proto_foo</b> global variable <b>,</b> add 3 more declarations: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> gint ett_foo = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hf_foo_hdr_version = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hf_foo_hdr_type = <span class="hljs-number"><span class="hljs-number">-1</span></span>;</code> </pre> <br>  Now we will improve the display of our protocol: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tree) { proto_item *ti = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; proto_tree *foo_tree = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; ti = proto_tree_add_item(tree, proto_foo, tvb, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, FALSE); foo_tree = proto_item_add_subtree(ti, ett_foo); proto_tree_add_item(foo_tree, hf_foo_hdr_version, tvb, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, FALSE); proto_tree_add_item(foo_tree, hf_foo_hdr_type, tvb, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, FALSE); }</code> </pre> <br>  Now Wireshark's knowledge of our protocol is becoming more detailed.  So far we have only recognized the first 2 bytes of our foo protocol, which are responsible for the protocol version and packet type, respectively. <br><br>  The call to the <b>proto_item_add_subtree ()</b> function added an additional branch ( <b>foo_tree</b> ) with details about the foo protocol to the tree ( <b>tree</b> ) of information about the entire incoming packet.  In <b>foo_tree,</b> we will describe our protocol in detail. <br>  The <b>ett_foo</b> variable <b>is</b> controlled by the ‚Äúexpansion‚Äù (expansion) of the protocol information tree in the output of the Wireshark program.  This variable remembers whether our protocol should be deployed while we move through the packets. <br>  <b>proto_tree_add_item ()</b> this time uses the <b>hf_foo_hdr_version</b> variable to output the value in the proper format.  <b>hdr_version</b> - 1 byte from <b>tvb</b> , starting from position 0. <b>hdr_type</b> - 1 byte from <b>tvb</b> , starting from position 1. <br><br>  If we look at the <b>hf_foo_hdr_version declaration</b> in a static array, we will see a detailed field, where <ul><li>  <b>hf_foo_hdr_version</b> - branch index </li><li>  <b>FOO Header Version</b> - field naming </li><li>  <b>foo.hdr.version</b> is the line used to filter packets (this type of line will be in the filter field) </li><li>  <b>FT_UNIT8</b> indicates the type and size of the element that we read from the <b>tvb</b> data <b>block</b> .  In this case, indicates that the "protocol version" field occupies 1 byte of unsigned integer type.  (Other possible types can be found in the file <i>wireshark / epan / ftypes / ftypes.h</i> ) </li><li>  <b>BASE_DEC</b> - for numeric types you specify, in which system to output numbers.  (It can also be BASE_HEX or BASE_OCT. For non-numeric types, use BASE_NONE.) </li></ul>  How the rest is used - see below. <br><br>  Now you can build the plugin again and run it with Wireshark.  We will see that Wireshark's output has become more usable. <br><br>  Well, let's finish the work on decoding our foo-protocol.  To do this, we need to declare a few more global variables and make some additional calls: <br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hf_foo_hdr_flags = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hf_foo_hdr_bool = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hf_foo_pl_len = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hf_foo_payload = <span class="hljs-number"><span class="hljs-number">-1</span></span>; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proto_register_foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ... { &amp;hf_foo_hdr_flags, { <span class="hljs-string"><span class="hljs-string">"FOO Header Flags"</span></span>, <span class="hljs-string"><span class="hljs-string">"foo.hdr.flags"</span></span>, FT_UINT8, BASE_HEX, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0x0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, HFILL } }, { &amp;hf_foo_hdr_bool, { <span class="hljs-string"><span class="hljs-string">"FOO Header Boolean"</span></span>, <span class="hljs-string"><span class="hljs-string">"foo.hdr.bool"</span></span>, FT_BOOLEAN, BASE_NONE, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0x0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, HFILL } }, { &amp;hf_foo_pl_len, { <span class="hljs-string"><span class="hljs-string">"FOO Payload Length"</span></span>, <span class="hljs-string"><span class="hljs-string">"foo.pl_len"</span></span>, FT_UINT8, BASE_DEC, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0x0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, HFILL } }, { &amp;hf_foo_payload, { <span class="hljs-string"><span class="hljs-string">"FOO Payload"</span></span>, <span class="hljs-string"><span class="hljs-string">"foo.payload"</span></span>, FT_STRING, BASE_NONE, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0x0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, HFILL } } ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dissect_foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">tvbuff_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *tvb, packet_info *pinfo, proto_tree *tree)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tree) { gint offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; proto_item *ti = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; proto_tree *foo_tree = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; ti = proto_tree_add_item(tree, proto_foo, tvb, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, FALSE); foo_tree = proto_item_add_subtree(ti, ett_foo); proto_tree_add_item(foo_tree, hf_foo_hdr_version, tvb, offset, <span class="hljs-number"><span class="hljs-number">1</span></span>, FALSE); offset += <span class="hljs-number"><span class="hljs-number">1</span></span>; proto_tree_add_item(foo_tree, hf_foo_hdr_type, tvb, offset, <span class="hljs-number"><span class="hljs-number">1</span></span>, FALSE); offset += <span class="hljs-number"><span class="hljs-number">1</span></span>; proto_tree_add_item(foo_tree, hf_foo_hdr_flags, tvb, offset, <span class="hljs-number"><span class="hljs-number">1</span></span>, FALSE); offset += <span class="hljs-number"><span class="hljs-number">1</span></span>; proto_tree_add_item(foo_tree, hf_foo_hdr_bool, tvb, offset, <span class="hljs-number"><span class="hljs-number">1</span></span>, FALSE); offset += <span class="hljs-number"><span class="hljs-number">1</span></span>; proto_tree_add_item(foo_tree, hf_foo_pl_len, tvb, offset, <span class="hljs-number"><span class="hljs-number">4</span></span>, TRUE); offset += <span class="hljs-number"><span class="hljs-number">4</span></span>; proto_tree_add_item(foo_tree, hf_foo_payload, tvb, offset, <span class="hljs-number"><span class="hljs-number">-1</span></span>, FALSE); } }</code> </pre><br>  So we decrypted all the bits of our invented protocol. <br>  You can see the different types of elements that we used during the decryption: FT_BOOLEAN, FT_STRING and FT_UINT8.  And also, in the case of non-numeric elements, used BASE_NONE. <br><br>  Now Wireshark has a pretty good idea of ‚Äã‚Äãour protocol.  And at this step it would be possible to stop if such detailing was always enough.  We still have the <b>flags</b> field, which will have to be decomposed manually.  And also, if the protocol version is unknown, can you trust the output?  Well, the most important point - the dissector will generate an exception if the packet comes without the <b>payload</b> field and with a zero value of <b>pl_len</b> .  So, there is a place to improve the plugin.  Let's continue ... <br><br><h3>  Add details to the output </h3><br>  There are no boundaries for perfection!  So in our case.  We start by naming the version and type of the incoming package, which will allow us to perceive information much faster when viewing the package.  For this we need two arrays: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value_string packetversions[] = { { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"Version 1"</span></span> }, { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> } }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value_string packettypes[] = { { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"Ping request"</span></span> }, { <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"Ping acknowledgment"</span></span> }, { <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"Print payload"</span></span> }, { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> } };</code> </pre> <br>  Dependence in arrays is very simple - ‚Äúvalue, name of meaning‚Äù.  Thus, when viewing a package, we will see not the bare number of the type of package and remember what it means, but we will immediately see a description of the type.  To access these arrays, we will use VALS macros, which are provided by Wireshark itself. <br><pre> <code class="cpp hljs"> { &amp;hf_foo_hdr_version, { <span class="hljs-string"><span class="hljs-string">"FOO Header Version"</span></span>, <span class="hljs-string"><span class="hljs-string">"foo.hdr.version"</span></span>, FT_UINT8, BASE_DEC, VALS(packetversions), <span class="hljs-number"><span class="hljs-number">0x0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, HFILL } }, { &amp;hf_foo_hdr_type, { <span class="hljs-string"><span class="hljs-string">"FOO Header Type"</span></span>, <span class="hljs-string"><span class="hljs-string">"foo.hdr.type"</span></span>, FT_UINT8, BASE_DEC, VALS(packettypes), <span class="hljs-number"><span class="hljs-number">0x0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, HFILL } }</code> </pre> <br>  With the version and type of package we decided.  Now we will write down the flags in more detail. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FOO_FIRST_FLAG 0x01 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FOO_SECOND_FLAG 0x02 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FOO_ONEMORE_FLAG 0x04 static int hf_foo_flags_first = -1; static int hf_foo_flags_second = -1; static int hf_foo_flags_onemore = -1; void proto_register_foo(void) { ... { &amp;hf_foo_flags_first, { </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FOO first flag"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"foo.hdr.flags.first"</span></span></span><span class="hljs-meta">, FT_BOOLEAN, FT_INT8, NULL, FOO_FIRST_FLAG, NULL, HFILL } }, { &amp;hf_foo_flags_second, { </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FOO second flag"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"foo.hdr.flags.second"</span></span></span><span class="hljs-meta">, FT_BOOLEAN, FT_INT8, NULL, FOO_SECOND_FLAG, NULL, HFILL } }, { &amp;hf_foo_flags_onemore, { </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FOO onemore flag"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"foo.hdr.flags.onemore"</span></span></span><span class="hljs-meta">, FT_BOOLEAN, FT_INT8, NULL, FOO_ONEMORE_FLAG, NULL, HFILL } } ... } static void dissect_foo(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) { ... proto_tree_add_item(foo_tree, hf_foo_hdr_flags, tvb, offset, 1, FALSE); proto_tree_add_item(foo_tree, hf_foo_flags_first, tvb, offset, 1, FALSE); proto_tree_add_item(foo_tree, hf_foo_flags_second, tvb, offset, 1, FALSE); proto_tree_add_item(foo_tree, hf_foo_flags_onemore, tvb, offset, 1, FALSE); offset += 1; ... }</span></span></code> </pre> <br>  Since the flag is one bit of information with the values ‚Äã‚Äã‚Äú1‚Äù or ‚Äú0‚Äù, we use the type <b>FT_BOOLEAN</b> .  We also set a mask for each flag in the sixth parameter (FOO_FIRST_FLAG, FOO_SECOND_FLAG, FOO_ONEMORE_FLAG) to determine which bit of a byte to interpret.  Note that we use the same value for the variable <b>offset</b> for all flags. <br><br>  The conclusion is now much more readable.  But we will not stop and make it even more informative.  Note: Wireshark refers to packets as "FOO Protocol".  We set this name when registering the protocol.  Wireshark provides the ability to add additional information to this name.  We will display in this field information about the type of protocol.  To do this, we need to get the value of the type using <b>tvb_get_guint8 ()</b> <sup><a href="https://habr.com/ru/post/121990/">2</a></sup> .  The resulting value is displayed in two places: immediately after the name of the protocol and in the <i>Info</i> column. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dissect_foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">tvbuff_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *tvb, packet_info *pinfo, proto_tree *tree)</span></span></span><span class="hljs-function"> </span></span>{ guint8 packet_version = tvb_get_guint8(tvb, <span class="hljs-number"><span class="hljs-number">0</span></span>); guint8 packet_type = tvb_get_guint8(tvb, <span class="hljs-number"><span class="hljs-number">1</span></span>); guint32 packet_pl_len = <span class="hljs-number"><span class="hljs-number">0</span></span>; col_set_str(pinfo-&gt;cinfo, COL_PROTOCOL, <span class="hljs-string"><span class="hljs-string">"FOO"</span></span>); col_clear(pinfo-&gt;cinfo, COL_INFO); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tree) { gint offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; proto_item *ti = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; proto_tree *foo_tree = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; ti = proto_tree_add_item(tree, proto_foo, tvb, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, FALSE); foo_tree = proto_item_add_subtree(ti, ett_foo); proto_tree_add_item(foo_tree, hf_foo_hdr_version, tvb, offset, <span class="hljs-number"><span class="hljs-number">1</span></span>, FALSE); offset += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> ( packet_version ) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: col_add_fstr(pinfo-&gt;cinfo, COL_INFO, <span class="hljs-string"><span class="hljs-string">"Type: %s"</span></span>, val_to_str(packet_type, packettypes, <span class="hljs-string"><span class="hljs-string">"Unknown (0x%02x)"</span></span>)); proto_item_append_text(ti, <span class="hljs-string"><span class="hljs-string">", Type: %s"</span></span>, val_to_str(packet_type, packettypes, <span class="hljs-string"><span class="hljs-string">"Unknown (0x%02x)"</span></span>)); proto_tree_add_item(foo_tree, hf_foo_hdr_type, tvb, offset, <span class="hljs-number"><span class="hljs-number">1</span></span>, FALSE); offset += <span class="hljs-number"><span class="hljs-number">1</span></span>; proto_tree_add_item(foo_tree, hf_foo_hdr_flags, tvb, offset, <span class="hljs-number"><span class="hljs-number">1</span></span>, FALSE); proto_tree_add_item(foo_tree, hf_foo_flags_first, tvb, offset, <span class="hljs-number"><span class="hljs-number">1</span></span>, FALSE); proto_tree_add_item(foo_tree, hf_foo_flags_second, tvb, offset, <span class="hljs-number"><span class="hljs-number">1</span></span>, FALSE); proto_tree_add_item(foo_tree, hf_foo_flags_onemore, tvb, offset, <span class="hljs-number"><span class="hljs-number">1</span></span>, FALSE); offset += <span class="hljs-number"><span class="hljs-number">1</span></span>; proto_tree_add_item(foo_tree, hf_foo_hdr_bool, tvb, offset, <span class="hljs-number"><span class="hljs-number">1</span></span>, FALSE); offset += <span class="hljs-number"><span class="hljs-number">1</span></span>; proto_tree_add_item(foo_tree, hf_foo_pl_len, tvb, offset, <span class="hljs-number"><span class="hljs-number">4</span></span>, TRUE); packet_pl_len = tvb_get_ntohl(tvb, offset); offset += <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( packet_pl_len ) proto_tree_add_item(foo_tree, hf_foo_payload, tvb, offset, <span class="hljs-number"><span class="hljs-number">-1</span></span>, FALSE); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: col_add_fstr(pinfo-&gt;cinfo, COL_INFO, <span class="hljs-string"><span class="hljs-string">"Unknown version of Foo protocol (0x%02x)"</span></span>, packet_version); } } }</code> </pre> <br>  We pass the obtained value to the macro <b>val_to_str ()</b> , which for the transferred value returns a description string, or a string specified by us, in case the description is not found. <br>  We also fixed an error when improperly handling <b>payload</b> when an exception was thrown. <br>  And in addition added branching for different protocol versions. <br><br><h3>  Addition </h3><br><h6><a name="anch03"></a>  Example of a working dissector for the Foo protocol </h6><img src="https://habrastorage.org/storage/e5b6e0dd/6d2db241/44524522/35e261e8.png"><br><br><h6><a name="anch02"></a>  tvb_get_guint8 () </h6>  In addition to the <b>tvb_get_guint8 ()</b> function, there are a number of others, which can be found in the file <i>wireshark / epan / tvbuff.h</i> <br><br><h6>  Archive </h6>  <a href="http://depositfiles.com/files/ezdzoj0qw">Archive</a> with working source files.  Includes: <ul><li>  packet-foo.c - source code for the dissector plugin </li><li>  CMakeLists.txt - cmake file for plugin </li><li>  send-foo-packet.c - the source code of the program that sends the foo-packet </li></ul><h6><a name="anch04"></a>  Program listing sending foo packet to port 35000 * </h6><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;arpa/inet.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; #define FOO_PORT 35000 #define BUFFER_SIZE 210 struct _message { unsigned char pck_version; // = argv[1] unsigned char pck_type; // = 1 | 3 unsigned char pck_flags; // = rand unsigned char pck_boolean; // = rand unsigned int pck_payload_len; // = strlen(argv[2]) }; int main(int argc, char ** argv) { if ( argc != 3 ) { printf("Usage: %s &lt;version&gt; &lt;ping|\"text\"&gt;\n", argv[0]); return 1; } struct sockaddr_in cli_addr; int s, cli_len = sizeof(cli_addr); char buf[BUFFER_SIZE]; struct _message msg; msg.pck_version = atoi(argv[1]); msg.pck_payload_len = 0; unsigned int randomData = open("/dev/urandom", O_RDONLY); unsigned int myRandomInteger; read(randomData, &amp;myRandomInteger, sizeof(myRandomInteger)); msg.pck_flags |= myRandomInteger%8; read(randomData, &amp;myRandomInteger, sizeof(myRandomInteger)); msg.pck_boolean = myRandomInteger%2; close(randomData); if ( (s=socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1 ) { perror("socket"); exit(1); } memset((char*)&amp;cli_addr, 0, sizeof(cli_addr)); cli_addr.sin_family = AF_INET; cli_addr.sin_port = htons(FOO_PORT); cli_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK); memset(buf, 0, BUFFER_SIZE); if ( ! strcmp(argv[2], "ping") ) { msg.pck_type = 1; } else { msg.pck_type = 3; msg.pck_payload_len = (strlen(argv[2])&lt;200)?strlen(argv[2]):200; strncpy(buf+sizeof(struct _message), argv[2], (strlen(argv[2])&lt;200)?strlen(argv[2]):199); } memcpy(buf, (char*)&amp;msg, sizeof(struct _message)); if ( sendto(s, buf, sizeof(struct _message)+msg.pck_payload_len, 0, (struct sockaddr*)&amp;cli_addr, cli_len) == -1 ) { perror("sendto"); exit(1); } exit(0); }</span></span></span></span></code> </pre> <pre>  * program without foolproof </pre></div><p>Source: <a href="https://habr.com/ru/post/121990/">https://habr.com/ru/post/121990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../121975/index.html">Take part or become a speaker in Ciklum Web Subbotnik!</a></li>
<li><a href="../121976/index.html">Lambda functions and closures</a></li>
<li><a href="../121985/index.html">Beeline will open your e-wallet</a></li>
<li><a href="../121987/index.html">Ukrainian academicians will write to Wikipedia and have already released their content under the free license Creative Commons BY-SA</a></li>
<li><a href="../121989/index.html">Perl steganography</a></li>
<li><a href="../121991/index.html">Touch Shooting in Video Games: A PlayStation Move Weapon Review</a></li>
<li><a href="../121992/index.html">What if the giant wants to eat your lunch</a></li>
<li><a href="../121993/index.html">Transparent Page Sharing in ESX 4.1 - following the last year‚Äôs article</a></li>
<li><a href="../121995/index.html">Copyrights to non-creative works</a></li>
<li><a href="../121997/index.html">Flash vs JavaScript, V8 Benchmark Suite</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>