<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Let's try to talk about hierarchical finite automata in general and their support in SObjectizer-5 in particular</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Finite automata are perhaps one of the most fundamental and widely used concepts in programming. State machines (SCs) are actively used in a variety o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">🔎</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">📜</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">⬆️</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">⬇️</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Let's try to talk about hierarchical finite automata in general and their support in SObjectizer-5 in particular</h1><div class="post__text post__text-html js-mediator-article">  Finite automata are perhaps one of the most fundamental and widely used concepts in programming.  State machines (SCs) are actively used in a variety of application niches.  In particular, in such niches as the automated process control system and telecom, which have been dealt with, spacecraft are found a little less often than at every step. <br><br>  Therefore, in this article we will try to talk about spacecraft, primarily about hierarchical finite automata and their advanced capabilities.  And to tell a little about the support of spacecraft in <a href="https://stiffstream.com/ru/products/sobjectizer.html">SObjectizer-5</a> , the “actor” framework for C ++.  One of those <s>two</s> few that are open, free, cross-platform, and still alive. <br><br>  Even if you are not interested in SObjectizer, but, say, you have never heard about hierarchical finite automata or about how useful such advanced capabilities of a spacecraft as input / output handlers for states or state history are useful, then it may be interesting to look under the cat and read at least the first part of the article. <br><a name="habracut"></a><br><h1>  General words about state machines </h1><br>  We will not try to carry out in the article a complete educational program on the topic of <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25B2%25D1%2582%25D0%25BE%25D0%25BC%25D0%25B0%25D1%2582">automata</a> and such types of them as <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25B2%25D1%2582%25D0%25BE%25D0%25BC%25D0%25B0%25D1%2582">finite automata</a> .  The reader must have at least a basic understanding of these types of entities. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Advanced state machines and their capabilities </h2><br>  The spacecraft has several “advanced” capabilities that greatly enhance the usability of the spacecraft in the program.  Let's take a quick look at these “advanced” features. <br><br>  Disclaimer: if the reader is well acquainted with state diagrams from UML, then he will not find anything new for himself here. <br><br><h3>  Hierarchical finite automata </h3><br>  Perhaps the most important and valuable opportunity is the organization of hierarchy / nesting of states.  Since it is the ability to nest states into each other eliminates the “explosion” of the number of transitions from state to state as the complexity of the spacecraft increases. <br><br>  It is more difficult to explain this with words than with an example.  Therefore, let's imagine that we have an infokiosk, on the screen of which a welcome message is first displayed.  The user can select the “Services” item and go to the section for selecting the services he needs.  Or, you can select the “Personal Account” item and go to the section of work with your personal data and services.  Or you can select the Help section.  So far everything seems to be simple and can be represented by the following state diagram (as simplified as possible): <br><br><img src="https://habrastorage.org/webt/6e/lv/bm/6elvbm4wcsbmfbjaasp8zynjmtw.png"><br><br>  But let's try to make it so that by clicking on the "Cancel" button the user can return from any section to the start page with a welcome message: <br><br><img src="https://habrastorage.org/webt/ok/hn/u3/okhnu3xrsjiss8u1fl1gygirn9u.png"><br><br>  The scheme is complicated, but still under control.  However, let us recall that in the “Services” section we may have several more subsections, for example, “Popular Services”, “New Services” and “Full List”.  And from each of these sections also need to return to the start page.  Our simple spacecraft is becoming more and more complex: <br><br><img src="https://habrastorage.org/webt/ic/zx/hu/iczxhus-j_5ohrzwdxpbdf5n2qi.png"><br><br>  But that's not all.  After all, we have not yet taken into account the “Back” button, by which we need to return to the previous section.  Let's add another reaction to the “Back” button and see what we get: <br><br><img src="https://habrastorage.org/webt/mn/rq/t7/mnrqt7zjk8kyq6e3i1-jb9fgwya.png"><br><br>  Yes, now we see the way to real fun.  But we have not even considered the subsections in the sections "Personal Account" and "Help" ... If we start, then almost immediately our simple, at first, spacecraft will turn into something unimaginable. <br><br>  This is where nesting of states comes to the rescue.  Let's imagine that we have only two top-level states: WelcomeScreen and UserSelection.  All our sections (ie, “Services”, “My Account” and “Help”) will be “nested” in the UserSelection state.  We can say that the ServicesScreen, ProfileScreen, and HelpScreen states will be children of a UserSelection.  And since they are children, they will inherit the reaction to some signals from their parent state.  Therefore, we can define the reaction to the Cancel button in the UserSelection.  But we have no need to define this reaction in all subsidiary substates.  What makes our spacecraft more concise and understandable: <br><br><img src="https://habrastorage.org/webt/lx/nb/qn/lxnbqn3kqv9rst-fbebmx1kxhi8.png"><br><br>  Here you can note that the reaction for "Cancel" and "Back" we defined in UserSelection.  And this reaction to the Cancel button works for all UserSelection substates without exception (including one more composite substate, ServicesSelection).  But here in the ServicesSelection substate, the reaction to the “Back” button has its own — the return is not in WelcomScreen, but in ServicesScreen. <br><br>  SCs that use state hierarchy / nesting are called hierarchical finite automata (ICA). <br><br><h3>  Reaction to entry / exit to / from state </h3><br>  A very useful feature is the ability to assign a response to the entrance to a particular state, as well as the response to the exit from the state.  So, in the example above with the infokiosk, you can hang a handler at the entrance to each of the states that will change the contents of the infokiosk screen. <br><br>  The previous example can be slightly extended.  Suppose we have two substates in WelcomScreen: BrightWelcomScreen, in which the screen will be highlighted normally, and DarkWelcomScreen, in which the screen brightness will be reduced.  We can make an entry handler in DarkWelcomScreen, which will reduce the screen brightness.  And exit processor from DarkWelcomScreen, which will restore normal brightness. <br><br><img src="https://habrastorage.org/webt/qm/n0/2y/qmn02yrt9xxxmmawcpzufiexrpg.png"><br><br><h3>  Automatic change of state after a specified time </h3><br>  At times, it may be necessary to limit the time the spacecraft stays in a particular state.  So, in the example above, we can limit the time our ICA stays in the BrightWelcomScreen state to one minute.  As soon as the minute expires, the ICA is automatically transferred to the DarkWelcomScreen state. <br><br><h3>  History of the state of spacecraft </h3><br>  Another very useful feature of ICA is the history of the state of spacecraft. <br><br>  Let's imagine that we have some kind of abstract IKA like this: <br><br><img src="https://habrastorage.org/webt/6i/6n/bl/6i6nblfh7l89fzaulpzsa3mo4a4.png"><br><br>  This our ICA can go from TopLevelState1 to TopLevelState2 and back.  But inside TopLevelState1 there are several nested states.  If IKA just goes from TopLevelState2 to TopLevelState1, then two states are activated at once: TopLevelState1 and NestedState1.  NestedState1 is activated because it is the initial substate of the TopLevelState1 state. <br><br>  Now imagine that our ICA further changed its state from NestedState1 to NestedState2.  Inside NestedState2, the substate InternalState1 is activated (because it is the initial state for NestedState2).  And from InternalState1 we went to InternalState2.  Thus, the following states are simultaneously active in us: TopLevelState1, NestedState2 and InternalState2.  And here we go to TopLevelState2 (i.e., we generally left TopLevelState1). <br><br>  TopLevelState2 becomes active.  After that, we want to return to TopLevelState1.  It is in TopLevelState1, and not to any particular substate in TopLevelState1. <br><br>  So, from TopLevelState2, we go to TopLevelState1 and where do we go? <br><br>  If TopLevelState1 does not have a history, then we will arrive in TopLevelState1 and NestedState1 (since NestedState1 is the initial substate for TopLevelState1).  Those.  the whole story about the transitions inside TopLevelState1, which were carried out before going to TopLevelState2, was completely lost. <br><br>  If TopLevelState1 has a so-called.  shallow history, then when returning from TopLevelState2 to TopLevelState1, we end up in NestedState2 and InternalState1.  In NestedState2 we fall because it is recorded in the history of the state TopLevelState1.  And we get into InternalState1 because it is the initial one for NestedState2.  It turns out that in the surface history for TopLevelState1 information is stored only on the substates of the very first level.  The history of nested states in these substates is not preserved. <br><br>  But if TopLevelState1 has a deep history (deep history), then when returning from TopLevelState2 to TopLevelState1 we get to NestedState2 and InternalState2.  Because in deep history, complete information is stored about active substates, regardless of their depth. <br><br><h3>  Orthogonal states </h3><br>  So far, we have considered ICA in which only one of the substates could be active within the state.  But at times there may be situations when there must be several simultaneously active substates in a specific ICA state.  Such substates are called orthogonal states. <br><br>  A classic example that demonstrates orthogonal states is the computer keyboard we are used to and its NumLock, CapsLock and ScrollLock modes.  We can say that working with NumLock / CapsLock / ScrollLock is described by orthogonal substates inside the Active state: <br><br><img src="https://habrastorage.org/webt/hv/kf/8p/hvkf8p_gqijakghmndndhlileag.png"><br><br><h3>  Everything you wanted to know about state machines, but ... </h3><br>  In general, there is a fundamental article on the formal notation for state diagrams from David Harel: <a href="http://www.inf.ed.ac.uk/teaching/courses/seoc/2005_2006/resources/statecharts.pdf">Statecharts: A Visual Formalism For Complex Systems (1987)</a> . <br><br>  They understand the various situations that can occur when working with finite automata on the example of control of a conventional electronic clock.  If someone did not read it, I highly recommend it.  In principle, everything that Harel described was then transferred to the UML notation.  But when you read the description of state diagrams from UML, I don’t always understand what, for what and when.  But in the article by Harel, the presentation goes from simple situations to more complex ones.  And you are better aware of all the power that finite automata hide in you. <br><br><h1>  State machines in SObjectizer </h1><br>  Further we will talk about SObjectizer and its specificity.  If the examples below are not completely clear to you, then it may make sense to learn more about SObjectizer.  For example, from our <a href="https://habr.com/post/304386/">review article about SObjecizer</a> and several subsequent ones, which introduce readers to SObjectizer, moving from simple to complex ( <a href="https://habrahabr.ru/post/306858/">first</a> article, <a href="https://habrahabr.ru/post/307306/">second</a> and <a href="https://habrahabr.ru/post/308084/">third</a> ). <br><br><h2>  Agents in SObjectizer are state machines </h2><br>  The agents in SObjectizer were from the very beginning finite automata with pronounced states.  Even if the agent developer did not describe any eigenstate in his agent class, the agent still had a default state, which was used by default.  For example, if a developer has made such a trivial agent: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simple_demo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//   ,       . struct how_are_you final : public so_5::signal_t {}; //   ,     . struct quit final : public so_5::signal_t {}; // ..   ,      . simple_demo(context_t ctx) : so_5::agent_t{std::move(ctx)} { so_subscribe_self() .event&lt;how_are_you&gt;([]{ std::cout &lt;&lt; "I'm fine!" &lt;&lt; std::endl; }) .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); } };</span></span></code> </pre> <br>  then he may not even suspect that in reality all his subscriptions are made for the default state.  But if the developer adds his own states to the agent, then you have to think about correctly signing the agent in the correct state.  Here, for example, a simple (and, as usual) incorrect modification of the agent shown above: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simple_demo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,  ,   . state_t st_free{this}; // ,  ,   . state_t st_busy{this}; public: //   ,       . struct how_are_you final : public so_5::signal_t {}; //   ,     . struct quit final : public so_5::signal_t {}; // ..   ,      . simple_demo(context_t ctx) : so_5::agent_t{std::move(ctx)} { so_subscribe_self() .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); //   how_are_you   ,    . st_free.event([]{ std::cout &lt;&lt; "I'm free" &lt;&lt; std::endl; }); st_busy.event([]{ std::cout &lt;&lt; "I'm busy" &lt;&lt; std::endl; }); //     st_free. this &gt;&gt;= st_free; } };</span></span></code> </pre> <br>  We defined two different handlers for the how_are_you signal, each for its own state. <br><br>  And the error in this modification of the agent simple_demo is that while in st_free or st_busy the agent will not respond to quit at all, since  we left the quit subscription in the default state, but did not make the appropriate subscriptions for st_free and st_busy.  A simple and obvious way to fix this problem is to add the appropriate subscriptions to st_free and st_busy: <br><pre> <code class="cpp hljs"> simple_demo(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} { <span class="hljs-comment"><span class="hljs-comment">//   how_are_you   ,    . st_free .event([]{ std::cout &lt;&lt; "I'm free" &lt;&lt; std::endl; }) .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); st_busy .event([]{ std::cout &lt;&lt; "I'm busy" &lt;&lt; std::endl; }) .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); //     st_free. this &gt;&gt;= st_free; }</span></span></code> </pre> <br>  True, this method smacks of copy-paste, which is not good.  You can get rid of copy-paste by entering the common parental state for st_free and st_busy: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simple_demo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      . state_t st_basic{this}; // ,  ,   . //      st_basic. state_t st_free{initial_substate_of{st_basic}}; // ,  ,   . //     st_basic. state_t st_busy{substate_of{st_basic}}; public: //   ,       . struct how_are_you final : public so_5::signal_t {}; //   ,     . struct quit final : public so_5::signal_t {}; // ..   ,      . simple_demo(context_t ctx) : so_5::agent_t{std::move(ctx)} { //   quit   st_basic    //  ""  . st_basic.event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); //   how_are_you   ,    . st_free.event([]{ std::cout &lt;&lt; "I'm free" &lt;&lt; std::endl; }); st_busy.event([]{ std::cout &lt;&lt; "I'm busy" &lt;&lt; std::endl; }); //     st_free. this &gt;&gt;= st_free; } };</span></span></code> </pre> <br>  For the sake of justice, it is necessary to add that initially in SObjectizer agents could only be simple finite automata.  Support for hierarchical spacecraft appeared relatively recently, in January 2016. <br><br><h2>  Why in SObjectizer agents are finite automata? </h2><br>  This question has a very simple answer: <s>this is how</s> SObjectizer’s roots grow from the world of automated process control systems, and there finite automata are used very often.  Therefore, we considered it necessary that the agents in SObjectizer were also finite automata.  This is very convenient if in the application for which the SObjectizer is attempted to apply, QA are used.  And the default state, which all agents have, makes it possible not to think about spacecraft if the use of spacecraft is not required. <br><br>  In principle, if you look at the Model Actors itself, and on the principles on which this model is built: <br><br><ul><li>  an actor is an entity with behavior; </li><li>  actors respond to incoming messages; </li><li>  having received the message the actor can: <br><ul><li>  send a certain number of messages to other actors; </li><li>  create a number of new actors; </li><li>  define for yourself a new behavior for processing subsequent messages. </li></ul></li></ul><br>  One can find a strong similarity between simple spacecraft and actors.  It can even be said that the actors are simple finite automata. <br><br><h2>  What features does the advanced SObjectizer state machine support? </h2><br>  Of the above capabilities of the advanced finite automata, SObjectizer supports all but the orthogonal states.  The rest of the goodies, like nested states, input / output handlers, restrictions on the time spent in the state, history for states, are supported. <br><br>  With the support of orthogonal states from the first time did not grow together.  On the one hand, the internal architecture of SObjectizer was not designed to support several independent and simultaneously active states for the agent.  On the other hand, there are ideological questions about how an agent with orthogonal states should behave.  The tangle of these issues was too complicated, and the useful exhaust too small to solve this problem.  Yes, and in our practice we have not yet encountered situations where orthogonal states would necessarily be required, but it would not have been possible to manage, for example, sharing work between several agents tied to one common working context. <br><br>  However, if someone needs such a feature, like orthogonal states, is really needed and you have real examples of problems where it is needed, then let's talk.  Perhaps, having concrete examples before our eyes, we can add this feature to SObjectizer. <br><br><h2>  How support for advanced features of ICA looks in code </h2><br>  In this part of the story we will try to quickly run through the API SObjectizer-5 to work with ICA.  Without a deep immersion in details, just so that the reader has an idea of ​​what is and how it looks.  More detailed information, such a wish, can be found <a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5%2520In-depth%2520-%2520Agent%2520States/">in the official documentation</a> . <br><br><h3>  Nested states </h3><br>  In order to declare a nested state, you must pass to the constructor of the corresponding state_t object the expression initial_substate_of or substate_of: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_parent{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//  . state_t st_first_child{initial_substate_of{st_parent}}; //   . //    . state_t st_second_child{substate_of{st_parent}}; //   . state_t st_third_child{substate_of{st_parent}}; //   . state_t st_first_grandchild{initial_substate_of{st_third_child}}; //    . state_t st_second_grandchild{substate_of{st_third_child]}; ... };</span></span></code> </pre> <br>  If state S has several substates C1, C2, ..., Cn, then one of them (and only one) should be marked as initial_substate_of.  Violation of this rule is diagnosed at run-time. <br><br>  The maximum state nesting depth in SObjectizer-5 is limited.  In versions 5.5 - this is 16 levels.  Violation of this rule is diagnosed at run-time. <br><br>  The main focus with nested states is that when a state is activated which has nested states, several states are activated at once.  Suppose there is a state A, which has substates B and C, and in a substate B there are substates D and E: <br><br><img src="https://habrastorage.org/webt/pf/1n/gb/pf1ngbtknzrf5qxlluht3yfiraq.png"><br><br>  When the state A is activated, then, in fact, three states are activated at once: A, AB and ABD <br><br>  The fact that several states can be active at once has the most serious influence on two extremely important things.  First, on the search handler for the next incoming message.  So, in the example just shown, the handler for the message will first be searched in the ABD state. If there is no suitable handler found, the search will continue in its parent state, i.e.  in AB And already offended, if needed, the search will continue in state A. <br><br>  Secondly, the presence of several active states affects the order in which the I / O handlers for the states are called.  But this will be discussed below. <br><br><h3>  State I / O Handlers </h3><br>  State can be set to enter and exit state.  This is done through the state_t :: on_enter and state_t :: on_exit methods.  Typically, these methods are called in the so_define_agent () method (or directly in the agent's constructor, if the agent is trivial and inheritance from it is not provided). <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_free{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_busy{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// :       , //     . st_free.on_enter([]{ ... }); st_busy.on_exit([]{ ...}); ... this &gt;&gt;= st_free; } ... };</span></span></code> </pre> <br>  Probably the most difficult moment with on_enter / on_exit handlers is using them for nested states.  Let's go back to the example with states A, B, C, D and E. <br><br><img src="https://habrastorage.org/webt/pf/1n/gb/pf1ngbtknzrf5qxlluht3yfiraq.png"><br><br>  Suppose each state has an on_enter and an on_exit handler. <br><br>  Let the current state of the agent be A. That is.  The states A, AB and ABD are activated. During the agent status change process, A.on_enter, ABon_enter and ABDon_enter will be triggered.  And in that order. <br><br>  Suppose then a transition to ABE occurs: ABDon_exit and ABEon_enter will be called. <br><br>  If we then transfer the agent to the AC state, then ABEon_exit, ABon_exit, ACon_enter will be called. <br><br>  If the agent, being in the AC state, is deregistered, immediately after the so_evt_finish () method completes, the ACon_exit and A.on_exit handlers will be called. <br><br><h3>  Time limits </h3><br>  The time limit for the agent's stay in a particular state is set by the state_t :: time_limit method.  As in the case of on_enter / on_exit, time_limit methods are usually called where the agent is configured for its work inside the SObjectizer: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">led_indicator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> inactive{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> active{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        15s. //        inactive. active.time_limit(15s, inactive); ... } ... };</span></span></code> </pre> <br>  If the time limit for the state is set, then as soon as the agent enters this state, the SObjectizer starts counting the time in the state.  If the agent leaves the state and then returns to this state again, then the countdown begins anew. <br><br>  If time limits are set for nested states, then you need to be careful, because  Curious tricks are possible: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   . state_t A{this}, B{this}; //   first . state_t C{initial_substate_of{A}}, st_D{substate_of{A}}; ... void so_define_agent() override { A.time_limit(15s, B); C.time_limit(10s, D); D.time_limit(20s, C); ... } ... };</span></span></code> </pre> <br>  Suppose the agent enters the state A. Ie  states A and C are activated. Both for A and C, the time begins.  Previously, it will end for state C and the agent will go to state D. This will start the countdown for being in state D. But the countdown will continue for A!  Since during the transition from C to D, the agent continued to remain in state A. And five seconds after the forced transition from C to D, the agent will go to state B. <br><br><h3>  History for the state </h3><br>  By default, agent states do not have a history.  To activate history saving for a state, you need to pass a shallow_history constant to the state_t constructor (the state will have a shallow history) or deep_history (the state will have a deep history).  For example: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> A{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, shallow_history}; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> B{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, deep_history}; ... };</code> </pre> <br>  History for states is a difficult topic, especially when a decent depth of nesting of states is used and substates have their own history.  Therefore, for more complete information on this topic is better to refer <a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5%2520In-depth%2520-%2520Agent%2520States/">to the documentation</a> , experiment.  Well, ask us if you can not figure out yourself;) <br><br><h3>  just_switch_to, transfer_to_state, suppress </h3><br>  The state_t class has a number of the most commonly used methods that have already been shown above: event () for subscribing events to a message, on_enter () and on_exit () for setting I / O handlers, time_limit () for setting a limit for the time in state. <br><br>  Along with these methods, the following state-class methods are very useful when working with ICA: <br><br>  The just_switch_to () method, which is intended for the case when the only reaction to the incoming message is the transfer of the agent to a new state.  You can write: <br><pre> <code class="cpp hljs">some_state.just_switch_to&lt;some_msg&gt;(another_state);</code> </pre> <br>  instead: <br><pre> <code class="cpp hljs">some_state.event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;some_msg&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= another_state; });</code> </pre> <br>  The transfer_to_state () method is very useful when we have some message M processed in the same way in two or more states S1, S2, ..., Sn.  But, if we are in states S2, ..., Sn, then we first have to return to S1, and only then do processing M. <br><br>  If this sounds surprising, then perhaps in the sample code this situation will be better understood: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> S1{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, S2{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, ..., Sn{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actual_M_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;M&gt; cmd)</span></span></span><span class="hljs-function"> </span></span>{...} ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ S1.event(&amp;demo::actual_M_handler); ... <span class="hljs-comment"><span class="hljs-comment">//           S1, //      M  . S2.event([this](mhood_t&lt;M&gt; cmd) { this &gt;&gt;= S1; actual_M_handler(cmd); }); ... //      . Sn.event([this](mhood_t&lt;M&gt; cmd) { this &gt;&gt;= S1; actual_M_handler(cmd); }); } ... };</span></span></code> </pre> <br>  Here, instead of defining very similar event handlers for S2, ..., Sn, you can use transfer_to_state: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> S1{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, S2{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, ..., Sn{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actual_M_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;M&gt; cmd)</span></span></span><span class="hljs-function"> </span></span>{...} ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ S1.event(&amp;demo::actual_M_handler); ... <span class="hljs-comment"><span class="hljs-comment">//           S1, //      M  . S2.transfer_to_state&lt;M&gt;(S1); ... //      . Sn.transfer_to_state&lt;M&gt;(Sn); } ... };</span></span></code> </pre> <br>  The suppress () method suppresses the search for an event handler for the current substate and all its parent substates.  Suppose we have a parent state A, in which std :: abort () is called on message M.  And there is a child state B in which M can be safely ignored.  We must determine the reaction to M in the B substate, because if we do not do this, then a handler for B will be found in A. Therefore, we will need to write something like <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ A.event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;M&gt;) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); }); ... B.event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;M&gt;) {}); <span class="hljs-comment"><span class="hljs-comment">//    ,      //   M   . ... }</span></span></code> </pre> <br>  The suppress () method allows you to write this situation in the code more clearly and clearly: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ A.event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;M&gt;) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); }); ... B.suppress&lt;M&gt;(); <span class="hljs-comment"><span class="hljs-comment">//    ,      //   M   . ... }</span></span></code> </pre> <br><h2>  Very simple example </h2><br>  The standard SObjectizer v.5.5 examples include a simple <a href="">blinking_led</a> example that simulates the operation of a flashing LED indicator.  The agent state diagram from this example looks like this: <br><br><img src="https://habrastorage.org/webt/9d/yt/ms/9dytmskalbsypsg9xjjzkwupl5k.png"><br><br>  And this is what the full agent code from this example looks like: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blinking_led</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> off{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }, blinking{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }, blink_on{ initial_substate_of{ blinking } }, blink_off{ substate_of{ blinking } }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">turn_on_off</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; blinking_led( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{ ctx } { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= off; off.just_switch_to&lt; turn_on_off &gt;( blinking ); blinking.just_switch_to&lt; turn_on_off &gt;( off ); blink_on .on_enter( []{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ON"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } ) .on_exit( []{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"off"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } ) .time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{<span class="hljs-number"><span class="hljs-number">1250</span></span>}, blink_off ); blink_off .time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{<span class="hljs-number"><span class="hljs-number">750</span></span>}, blink_on ); } };</code> </pre> <br>  Here all the actual work is done inside the I / O handlers for the blink_on substate.  And, besides, the limits for the stay in the blink_on and blink_off substates work. <br><br><h2>  Not a very simple example. </h2><br>  The regular SObjectizer v.5.5 examples also include a much more complicated example, <a href="">intercom_statechart</a> , which simulates the behavior of an intercom panel.  And the state diagram of the main agent in this example looks like this: <br><br><img src="https://habrastorage.org/webt/o-/i6/7d/o-i67dswwms9rkutntnvd-hrx7e.jpeg"><br><br>  Everything is so harsh because this imitation supports not only the call for an apartment by number, but also such things as a unique secret code for each apartment, as well as special service code.  These codes allow you to open the door lock without dialing anywhere. <br><br>  There are more interesting things in this example.  But it is too big to paint it in detail (even a separate article may not be enough for that).  So if it is interesting how really complex ICAs look in SObjectizer, you can see in this example.  And if something is not clear, then you can ask us a question.  For example, in the comments to this article. <br><br><h1>  Is it possible not to use the spacecraft support built into SObjectizer-5? </h1><br>  So, SObjectizer-5 has built-in support for ICA with a very wide range of supported features.  This support is made, of course, in order to use it.  In particular, the SObjectizer debugging mechanisms, like <a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5%2520In-depth%2520-%2520Message%2520Delivery%2520Tracing/">message delivery tracing</a> , are aware of the agent states and display the current status in their respective debug messages. <br><br>  However, if a developer does not want for some reason to use the built-in tools of SObjectizer-5, then he may not. <br><br>  For example, you can refuse to use SObjectizer-ovsky state_t and others like it because state_t is a rather heavyweight object that has std :: string, a pair of std :: function, and several counters of type std :: size_t, five pointers to various objects and some other trifle.  Collectively, this on 64-bit Linux and GCC-5.5, for example, gives 160 bytes per state_t (not counting what can be placed in dynamic memory). <br><br>  If your application requires, say, a million agents, each of which will have 10 states, then the overhead of a SObjectizer state_t may be unacceptable.  In this case, you can use any other mechanism for working with finite state machines by manually delegating the processing of messages to this mechanism.  Sort of: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">external_fsm_demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { some_fsm_type my_fsm_; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ so_subscribe_self() .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_one&gt; cmd) { my_fsm_.handle(*cmd); }) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_two&gt; cmd) { my_fsm_.handle(*cmd); }) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_three&gt; cmd) { my_fsm_.handle(*cmd); }); ... } ... };</code> </pre> <br>  In this case, you are paying for efficiency by increasing the amount of manual work and the lack of help from the debugging mechanisms of SObjectizer.  But here is the developer to decide. <br><br><h1>  Conclusion </h1><br>  The article turned out to be voluminous, much more than originally planned.  Thanks to everyone who read to this place.  If any readers find it possible to leave their feedback in the comments to the article, then it will be great. <br><br>  If something remains unclear, then ask questions, we will be happy to answer. <br><br>   ,    ,   SObjectizer-,       SObjectizer-    5.5.   ,      5.5.23,  <a href="https://plus.google.com/%2BYauheniAkhotnikau/posts/QKXUtwLShNh"></a> .  ,   , <a href="https://sourceforge.net/p/sobjectizer/blog/2018/09/what-can-or-should-go-into-so-5523/"></a> .            ,   - .  Those.       SObjectizer-.  ,    v.5.5.23      SObjectizer-       SObjectizer- -   2018-    . </div><p>Source: <a href="https://habr.com/ru/post/423497/">https://habr.com/ru/post/423497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../423487/index.html">Node.js without node_modules</a></li>
<li><a href="../423489/index.html">I'm an emergency doctor, and I want to talk about the new Apple Watch electrocardiogram</a></li>
<li><a href="../423491/index.html">PHP Digest number 139 (September 3 - 17, 2018)</a></li>
<li><a href="../423493/index.html">Android Go is the next billion devices and 50 MB limit. Yandex lecture</a></li>
<li><a href="../423495/index.html">What's inside XGBoost, and where does Go</a></li>
<li><a href="../423499/index.html">DevBoy - how I created a project with an open source device and launched a project on Kickstarter</a></li>
<li><a href="../423501/index.html">Search and create a visual style design project</a></li>
<li><a href="../423503/index.html">My experience of moving, living and studying in Germany</a></li>
<li><a href="../423505/index.html">Zuckerberg sells Facebook shares for $ 13 billion so that “our children never have to be sick”</a></li>
<li><a href="../423507/index.html">How to save memory on browser tabs, but not to lose their contents. Experience team Yandex. Browser</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>