<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Work with Apache Ignite topology</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article, I talked about how to build the simplest topology for Apache Ignite . It consisted of one client and one server, the client s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Work with Apache Ignite topology</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/18e/a39/676/18ea396769ab4ae28d7ed7899cd59f89.jpg" align="left">  In the <a href="https://habrahabr.ru/post/310334/">previous article,</a> I talked about how to build the simplest topology for <a href="https://ignite.apache.org/">Apache Ignite</a> .  It consisted of one client and one server, the client sent a message to the server and the server displayed it.  It was told about how to configure the product and monitor its livelihoods.  Now it's time for a more complex example.  The construction of a complex topology and more interesting interaction scenarios will be demonstrated.  It is assumed that the reader is familiar with the basic operations with Apache Ignite, described in the first article.  As a result of reading these two articles, the reader may have some assumptions about how to apply this, without exaggeration, a powerful product in their projects.  Also, the article will be useful to those who are interested in building high-performance systems, and want to peep a ready-made solution for their bike. <br><a name="habracut"></a><br><h2>  Topology setup </h2><br>  Recall that the topology Ignite consists of two types of nodes, clients and servers.  Clients, in general (but not necessarily), execute send requests, and servers process them.  The node's behavior is determined by its configuration, which is the Spring configuration for the corresponding Ignite object.  The main points related to the configuration of the nodes are described in the <a href="https://habrahabr.ru/post/310334/">previous article</a> .  We will now create two xml server-type configurations that differ in the ‚ÄúgridName‚Äù property and are otherwise the same.  In this example, these will be the names "testGrid-server" and "testGrid-server1".  Let's run, for example, two nodes with the first configuration and one with the second.  Since each of them will be launched in a separate JVM, you should take care of configuring the memory of the nodes, for which you can reduce the values ‚Äã‚Äãof the -Xms and -Xmx parameters in ignite.bat.  Use the ignitevisorcmd. (Bat | sh) command to run the Visor utility used to monitor the Ignite topology.  At startup we must specify one of the configs, specify any, the result will be the same. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/bf9/cb1/73a/bf9cb173ad1d4d0fa48de2be409534a4.JPG"></div><br>  Since we now have such a complex topology, it's time to get acquainted with the main features of the visor.  He lists the complete list of his commands with <b>help</b> .  A complete list of them with brief explanations can be seen on <a href="https://apacheignite.readme.io/docs/command-line-interface">the product documentation page</a> .  In addition to what has been said in the documentation, I note that you can write plug-ins to the visor, and it is <a href="https://github.com/apache/ignite/tree/master/modules/visor-console">written in Scala</a> .  In the context of this article, you should pay attention to the visor <b>config</b> command, which displays all the relevant details about the specified node.  This is a very large amount of information, so I will not give it here. <br><br>  Although this by the way was not necessary, the nodes are also non-Java, currently there is support for C ++ and .NET.  I also did not mention that you can define lifecycle handlers for a node.  In short, there are 4 events before / after starting / stopping a node.  What is there to do is not clear, logging is provided by standard means, perhaps some kind of security checks or server settings.  The only implementation of the LifecycleBean interface that comes with Ignite is used when initializing .NET nodes.  At first glance, nothing useful can be done with this feature. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Connect to servers </h2><br>  In the previous article, we connected the client to the server and sent the message ‚ÄúHello World!‚Äù.  By slightly modifying the code from the previous example, we will create in our test two nodes, client and server;  because of the way they are created, they will be created in one JVM.  They are configured with different xml configurations, and the gridName for the server will be ‚ÄútestGrid-server0‚Äù.  The test code is: <br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(SpringJUnit4ClassRunner.class) <span class="hljs-meta"><span class="hljs-meta">@ContextConfiguration</span></span>(locations = {<span class="hljs-string"><span class="hljs-string">"/ignite/providerConfig.xml"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IgniteHelloWorld</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-meta"><span class="hljs-meta">@Qualifier</span></span>(<span class="hljs-string"><span class="hljs-string">"clientProvider"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IgniteProvider igniteClient; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-meta"><span class="hljs-meta">@Qualifier</span></span>(<span class="hljs-string"><span class="hljs-string">"serverProvider"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IgniteProvider igniteServer; <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendHelloTest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (Ignite server = igniteServer.getIgnite(); Ignite client = igniteClient.getIgnite()) { client.compute().broadcast(() -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Hello World from client!"</span></span>)); server.compute().broadcast(() -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Hello World from server!"</span></span>)); } } }</code> </pre> <br>  Please note that Ignite objects that implement the AutoCloseable interface will close with a good tone after use.  So, we now have three server nodes running via the command line.  After executing the test in each of their three consoles, and in the console of our IDE, we will see approximately the same thing: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/6ad/17e/462/6ad17e4628e64236a2c5cbf80490bc2c.JPG"></div><br>  Another client and server joined the three existing servers, said hello and disconnected.  How is this behavior ensured?  The compute () method, which determines the group of servers on which the task will be executed, has two implementations.  The implementation without parameters, which we call in the test, looks like this: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IgniteCompute </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((ClusterGroupAdapter)ctx.cluster().get().forServers()).compute(); }</code> </pre><br>  Let's see what's going on here.  On the ctx object of the <a href="">GridKernalContextImpl</a> type (the developers use the word ‚Äú <a href="https://en.wikipedia.org/wiki/KERNAL">Kernal</a> ‚Äù because of some tradition that is significant for them) the cluster () method is called, which returns the ClusterProcessor object symbolizing, apparently, our node in terms of its interactions with the topology.  Actually, the node as a single-element cluster is obtained by further calling the get () method, which is given to us by the <a href="">IgniteClusterImpl</a> object, which can do a lot.  First of all, build a subset of nodes based on the application of a predicate to them, that is, a certain condition that is calculated on a set of objects and thus filters it.  In this case, the forServers () method returns a predicate that returns true for nodes that have the ATTR_CLIENT_MODE property == false.  A complete list of attributes <a href="">can be found</a> .  In addition to attribute-based predicates, Ignite comes with a number of other interesting implementations of predicates.  For example, you can filter by cache content, which it makes sense to introduce later, and a number of other, more exotic ones. <br><br>  Armed with this knowledge, it is not difficult to modify our test so that the message is sent to the selected nodes.  For identification, we have the gridName parameter, try sending servers with gridName == "testGrid-server", which we have 2. Having made calls <br><br><pre> <code class="java hljs">client.compute(client.cluster() .forAttribute(ATTR_GRID_NAME, <span class="hljs-string"><span class="hljs-string">"testGrid-server"</span></span>) .forServers()) .broadcast(() -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Hello World from client!"</span></span>)); server.compute(server.cluster() .forAttribute(ATTR_GRID_NAME, <span class="hljs-string"><span class="hljs-string">"testGrid-server1"</span></span>) .forServers()) .broadcast(() -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Hello World from server!"</span></span>));</code> </pre><br>  as expected, we will receive two messages from the client and one from the server.  If the predicate returns anything, the exception ‚ÄúClusterGroupEmptyCheckedException: Cluster group is empty‚Äù will be thrown.  In addition to forServers (), there are a number of other interesting standard predicates, for example forRemotes (), forRandom (), forOldest () and forYoungest (). <br><br>  Finally, the broadcast () call is not the only thing we can do.  To execute here is to pass the IgniteCallable object for execution.  There are also several versions of the call () method, which, unlike broadcast (), returns the result. <br><br><h2>  And what's inside? </h2><br>  It will be curious to know how it works.  In order to find out, we will perform such an experiment: from our client, send a message to the server created in the test, with which gridName == "testGrid-server0" and see in the debag what is going to happen.  For more insight, let's change our test a bit: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> param = <span class="hljs-number"><span class="hljs-number">1</span></span>; Integer clientResult = client.compute(client.cluster() .forAttribute(ATTR_GRID_NAME, <span class="hljs-string"><span class="hljs-string">"testGrid-server0"</span></span>) .forServers()) .call(() -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Hello World from client!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> param + <span class="hljs-number"><span class="hljs-number">1</span></span>; });</code> </pre><br>  The first thing that happens when calling the call () method is setting a read-write lock on our client.  Interestingly, Ignite uses its own implementation of this mechanism in the <a href="">GridSpinReadWriteLock</a> class, based on sun.misc.Unsafe.  On the one hand, this is good, Ignite developers care about performance, but on the other hand, what happens when they unclean in Java 9?  With anxiety, I will follow the development of events ... Even without surprise, one may find that, in the care of performance, the developers of Ignite rejected the standard java.util.concurrent.Future class in favor of their own implementation of the <a href="">IgniteFuture</a> interface.  I don‚Äôt know if they are much better, but one thing is clear - those who want to contribute to Apache Ignite should have a very deep knowledge of concurrency ... Then, based on our lambda, a task is formed, which is sent to execution.  This task is entrusted to the startTask method of the GridTaskProcessor class.  There is a security check here, but the security check is not implemented, it is likely to appear in future versions.  The next essential step is the distributed deployment of classes, but for now we will not go into this powerful feature, referring to the <a href="https://apacheignite.readme.io/docs/zero-deployment">original documentation</a> .  Let me remind you that Ignite must take steps to ensure that the executable code is on all the nodes where the task will be executed.  The task can be set to a timeout equal to the default Long.MAX_VALUE, in fact infinity, it can be overridden.  You can also customize the start-up task logging.  Traces of enterprise features ‚Äî load balancing, resiliency, and transactional settings ‚Äî are listed below.  If at some point in the task's processing time it turns out that the server or servers to which the task has dumped have fallen off, the processing is interrupted with an exception.  If we didn‚Äôt collapse anywhere along the road, then a job is generated, which is passed to the I / O dispatcher GridIoManager.  It forms the message and sends it using <a href="">TcpCommunicationSpi</a> .  Let me remind you that this object can be specified in the xml-configuration of the node, that is, we can influence the process of sending messages by implementing the heir TcpCommunicationSpi.  Next is also not easy, but finally using the NIO message leaves.  And our server gets it.  And calculates, and similarly sends the answer.  And he comes to the place of the call, in this case, the number 2. <br><br><h2>  Load management </h2><br>  What happens when a task can be executed on multiple servers?  We can verify this by sending a request to the servers with the gridName == "testGrid-server", of which 2. If taking into account the predicates, information about the availability of nodes, more than 1 node is available for the task, they are mixed using the Collections.shuffle (), and This list is transferred to the standard load balancer, which must be selected from the nodes 1 at its disposal. And here comes the interesting.  If you left everything by default, the <a href="https://ru.wikipedia.org/wiki/Round-robin_(%25D0%25B0%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC)">Round-Robbin</a> algorithm provided by the <a href="">RoundRobinLoadBalancingSpi</a> class will be used.  This SPI (in Ignite, all plug-in algorithms are called <a href="https://en.wikipedia.org/wiki/Service_provider_interface">SPI</a> ) iterates over the nodes using the round-robin method and selects the next node sequentially.  There are two working modes, poizadny and global, set by calling setPerTask (boolean).  If the task mode is selected, SPI selects the node at the beginning of the task execution randomly, and then cycles through the tasks as they are completed (in our case there is only one task, but the list of tasks can be transferred to execution).  The default is exactly this approach.  In global mode, a common sequential queue of nodes is used for all tasks.  It is clear that the choice of the algorithm in this place may affect the distribution of the load between the nodes.  In addition to the Round-Robbin balancer, two more are available: <a href="">adaptive</a> , which takes into account the performance of nodes based on a custom metric, which by default is the CPU load of the node server, and a random selection based <a href="https://github.com/apache/ignite/tree/2cfe0cb5a0d84caede8b528b0a515ab4ba92bbc6/modules/core/src/main/java/org/apache/ignite/spi/loadbalancing/weightedrandom">on the weights of the nodes</a> that can be specified during configuration (all are equal to 10 by default) .  Finally, you can write your own by implementing the appropriate interface.  You can specify the balancing SPI in the node xml-config (here I did not understand a bit, you can specify a list, how does the balancing occur, who exactly is balancing? Judging by the code, the class names are stuck in a string, and then SPI is instantiated by the class name. How Can it work? Judging by the hints in Javadoc's, it will work from version 2.1.) <br><br>  In addition to balancing, the developer has the ability to manage two more enterprise-level features.  Failover can be monitored with fail-over <a href="">SPI</a> .  The reasons for this may be needed include an error during the execution of the task, a target node falling out of the topology and a node refusing to perform the task.  The task of SPI of this type is to provide a node in return for a defective one.  Three implementations are provided out of the box: NeverFailoverSpi, which never returns, and two more cunning ones - <a href="">AlwaysFailoverSpi</a> and JobStealingFailoverSpi.  AlwaysFailoverSpi gives the node several attempts (by default, 5, you can override) before proposing another node.  This takes into account the binding of the task to the node (affinity) - if the task is linked, then after a specified number of attempts a fall occurs, if not, then taking into account the balancer data, a new node is selected and the defective is placed on the black list.  The number of attempts and the black list of nodes is stored in the context of the task.  JobStealingFailoverSpi is even more cunning, and we will not consider it.  The SPI Failover list can also be specified in the config.  If nothing is specified, the default is AlwaysFailoverSpi. <br><br>  And the last SPI from this series, <a href="">Checkpoint SPI</a> , as it is not difficult to guess, is designed to create save points (checkpoints), that is, intermediate points when performing a long or complex task.  This type of SPI provides an API with which you can save, delete, and load a checkpoint.  According to the authors of Ignite, this API should be used only by the system.  but technically this possibility is not closed for application developers.  We will not dive into the frightening bowels of this feature, by default the implementation is connected, which does nothing. <br><br><h2>  Traces </h2><br>  Finally, let's try to find traces of all these calls.  Ignite provides total logging.  If you do nothing to change the default state of affairs, a default logger will be created that will write messages to the console.  This is a regular <a href="https://docs.oracle.com/javase/8/docs/api/java/util/logging/package-summary.html">Java logging</a> , for which you can configure the config / java.util.logging.properties config.  If this does not suit you, you can implement the <a href="">IgniteLogger</a> interface and connect it via the xml config. <br><br>  And you can also ask the visor.  Using the node command, you can request detailed statistics on a node (if you know what to ask, and you may know, since we added the output to the console to our calculation).  As a result, you can see something like this after several launches: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/164/e97/787/164e97787275467e94dd920bd90f59b8.JPG"></div><br>  However, I may tell you about monitoring the topology another time. <br><br><h2>  findings </h2><br>  It is quite obvious that inside Ignite there are good, fit entrails.  It is intuitively clear that, on the basis of Ignite nodes, it is possible to build quite interesting solutions of the scale of a large enterprise or, at a minimum, borrow interesting ideas from it.  I hope that after reading this article, the reader has formed an idea of ‚Äã‚Äãhow to build a really complex, vital topology using the tools provided by Ignite. <br><br><h2>  Links </h2><br>  " <a href="https://github.com/kvmorozov/CachedActiviti">GitHub Test Case Code</a> </div><p>Source: <a href="https://habr.com/ru/post/310464/">https://habr.com/ru/post/310464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../310452/index.html">The book "Command line Linux. Complete Guide ¬ª</a></li>
<li><a href="../310454/index.html">Secrets of Progressive Web Apps: Part 1</a></li>
<li><a href="../310456/index.html">Custom Software Development</a></li>
<li><a href="../310460/index.html">The Complete Docker Practical Guide: From Scratch to AWS Cluster</a></li>
<li><a href="../310462/index.html">Put on a diet PostgreSQL indices for Zabbix</a></li>
<li><a href="../310466/index.html">Automation of IT services</a></li>
<li><a href="../310470/index.html">Solar JSOC - the experience of building a commercial SOC</a></li>
<li><a href="../310472/index.html">You do not have enough speed R? We are looking for hidden reserves</a></li>
<li><a href="../310474/index.html">16 myths about CRM-systems</a></li>
<li><a href="../310478/index.html">Stable version of Android Studio 2.2 released</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>