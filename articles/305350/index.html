<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to ReactiveUI: Studying Teams</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 1: Introduction to ReactiveUI: we pump properties in ViewModel 
 Part 2: Introduction to ReactiveUI: Collections 

 We have already discussed the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to ReactiveUI: Studying Teams</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://habrahabr.ru/post/303650/">Part 1: Introduction to ReactiveUI: we pump properties in ViewModel</a> <br>  <a href="http://habrahabr.ru/post/303898/">Part 2: Introduction to ReactiveUI: Collections</a> <br><br>  We have already discussed the possibilities of ReactiveUI related to working with properties, building dependencies between them, as well as working with collections.  These are one of the main primitives, on the basis of which the development using ReactiveUI is built.  Another such primitive are the commands that we consider in this part.  Commands encapsulate actions that are performed in response to some event: usually this is a user request or some kind of monitored change.  We will learn what can be done with the help of teams in ReactiveUI, discuss the features of their work and find out how teams in ReactiveUI differ from the teams with which we are familiar with WPF and its relatives. <br>  But before moving on to the commands, consider the broader topics related to reactive programming in general: the relationship between Task &lt;T&gt; and IObservable &lt;T&gt;, and what hot and cold sequences are. <br><a name="habracut"></a><br><h4>  Task vs.  Iobservable </h4><br>  So, let's draw a parallel between Task &lt;T&gt; (+ async, await, that's all) and IObservable &lt;T&gt;.  It will be important for us to understand how to work with teams in ReactiveUI, but the described approach is more widely used and does not hurt to know about it.  So: <b>Task &lt;T&gt; is IObservable &lt;T&gt;</b> .  But they are certainly not equivalent: IObservable &lt;T&gt; can solve a much larger range of tasks. <br>  It sounds suspicious, doesn't it?  Let's figure it out.  Immediately see an example: <br><pre><code class="cs hljs">Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; task = Task.Run(() =&gt; { Console.WriteLine(DateTime.Now.ToLongTimeString() + <span class="hljs-string"><span class="hljs-string">"   "</span></span>); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(DateTime.Now.ToLongTimeString() + <span class="hljs-string"><span class="hljs-string">"   "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"  "</span></span>; }); Console.WriteLine(DateTime.Now.ToLongTimeString() + <span class="hljs-string"><span class="hljs-string">"  -     "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> result = task.Result; Console.WriteLine(DateTime.Now.ToLongTimeString() + <span class="hljs-string"><span class="hljs-string">"  : "</span></span> + result);</code> </pre> <br>  We have created a task, it will execute asynchronously and will not prevent us from doing something else immediately after its launch, without waiting for completion.  The result is predictable: <br><blockquote>  18:19:47 We do something before the start of the task result waiting <br>  18:19:47 Starting a long task <br>  18:19:48 We complete the long task <br>  18:19:48 The result: The result of a long task <br></blockquote><br>  The first 2 lines will be displayed immediately and may have a different order, as lucky. <br>  And now let's rewrite to IObservable &lt;T&gt;: <br><pre> <code class="cs hljs">IObservable&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; task = Observable.Start(() =&gt; { Console.WriteLine(DateTime.Now.ToLongTimeString() + <span class="hljs-string"><span class="hljs-string">"   "</span></span>); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(DateTime.Now.ToLongTimeString() + <span class="hljs-string"><span class="hljs-string">"   "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"  "</span></span>; }); Console.WriteLine(DateTime.Now.ToLongTimeString() + <span class="hljs-string"><span class="hljs-string">"  -     "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> result = task.Wait(); <span class="hljs-comment"><span class="hljs-comment">//       Console.WriteLine(DateTime.Now.ToLongTimeString() + "  : " + result);</span></span></code> </pre><br>  The difference is in two lines: IObservable &lt;string&gt; instead of Task &lt;string&gt;, Observable.Start () instead of Task.Run () and task.Wait () instead of task.Result.  The result of the work is exactly the same. <br><br>  Let's look at another well-known technique with the launch of the action after the task is completed: <br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Task task.ContinueWith(t =&gt; Console.WriteLine(DateTime.Now.ToLongTimeString() + "  : " + t.Result)); //IObservable task.Subscribe(t =&gt; Console.WriteLine(DateTime.Now.ToLongTimeString() + "  : " + t));</span></span></code> </pre><br>  There is practically no difference again. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It turns out that Task &lt;T&gt; can be represented via IObservable &lt;T&gt;, which will produce one element and a completion signal.  There is no big philosophical and architectural difference between such approaches, and you can use any.  Even async / await is available in both cases: if we are to get the result from the IObservable in the asynchronous method, we can not do the blocking wait through the <i>Wait ()</i> method, as in the example, but use <i>await</i> .  Moreover, these two approaches can be combined, transformed one representation into another and use the advantages of both. <br><br><h4>  Hot and cold sequences </h4><br>  Let's discuss one more question concerning the work with observable sequences (observable).  They can be of two types: cold (cold) and hot (hot).  Cold sequences are passive and begin to generate notifications upon request, at the time of subscribing to them.  Hot sequences are active and do not depend on whether someone subscribes to them: notifications are still generated, they just sometimes go into void. <br>  Timer ticks, mouse movement events, network requests are hot sequences.  By subscribing to them at some point, we will start receiving relevant notifications.  10 observers will subscribe - notifications will be delivered to everyone.  Here is an example with a timer: <br><img src="https://habrastorage.org/files/010/0d2/c03/0100d2c032d041cba9a77ce1eb0ed943.png"><br><br>  The cold sequence is, for example, a query to the database or a file reading line by line.  The request or reading is started upon subscription, and OnNext () is called with each new received string.  When lines end, OnComplete () will be called.  When you re-subscribe, everything repeats again: a new query to the database or opening a file, the return of all received results, a completion signal: <br><img src="https://habrastorage.org/files/9db/3c0/486/9db3c0486cb74b0ea383bd086a0149a3.png"><br><br><hr><br><h4>  Classic commands ... </h4><br>  We now turn to our current topic - to the teams.  Commands, as I mentioned, encapsulate actions taken in response to certain events.  Such an event could be the user pressing the "Save" button;  then the action to be encapsulated is the save operation.  But the command can be executed not only in response to an explicit user action or related indirect events.  The signal from the timer, triggered every 5 minutes, regardless of the user, can also initiate the same ‚ÄúSave‚Äù command.  And although commands are usually used specifically for actions that the user performs in one way or another, you should not neglect their use in other cases. <br>  Commands also let you know if execution is currently available.  For example, we want to save not always available, but only when all the required form fields are filled in, and the availability of the command would determine if the button is active in the interface. <br>  Let's see what is the interest of the ICommand team: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ICommand</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler CanExecuteChanged; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanExecute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> parameter</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> parameter</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br>  Execute, obviously, executes the command.  You can pass a parameter to it, but you should not use this option if the required value can be obtained within the command itself (for example, taken from the ViewModel).  Then we understand why.  But, of course, there are situations when passing a parameter is the most acceptable option. <br>  CanExecute checks if the command is currently available.  It also has a parameter, and everything is the same as with Execute.  It is important that CanExecute with a certain parameter value allows or prohibits the execution of a command with only the same parameter value; for other values, the result may differ.  It should also be remembered that Execute doesn‚Äôt check CanExecute before execution of actions for the possibility of execution; this is the task of the calling code. <br>  The CanExecuteChanged event occurs when the status of the execution opportunity changes and it is worth re-checking CanExecute.  For example, when all the fields in the form have been filled out and it became possible to save, you need to initiate the inclusion of a button in the interface.  A button with an attached command will find out about this exactly like this. <br><br><h4>  ... and what's wrong with them </h4><br>  The first problem is that the CanExecuteChanged event does not indicate for which parameter value the execution opportunity status has changed.  This is the very reason why the use of parameters when calling Execute / CanExecute should be avoided: the ICommand interface with respect to parameters is not particularly consistent.  With the same reactive teams, as we shall see, this approach did not get along at all. <br><br>  The second problem - Execute () returns control only after the completion of the command execution.  When a command is executed for a long time, the user is upset because he is faced with a hung interface. <br><div class="spoiler">  <b class="spoiler_title">Who would like that?</b> <div class="spoiler_text">  The program has a command launch button, log output and a progress bar, which in a normal situation should constantly move.  The command at startup writes the current time to the log, one and a half seconds does something (for example, loads data) and writes the completion time. <br><img src="https://habrastorage.org/files/e76/b88/7b3/e76b887b3ca74c74886e61df665b0fed.gif"><br>  The progress bar stops, the log is updated only when the command is completed, the interface hangs.  It turned out bad ... <br></div></div><br>  How to save the situation?  Of course, you can implement the command so that it only initiates the execution of the necessary actions in another thread and returns control.  But then another problem arises: the user can click on the button again and run the command again, before the previous one is completed.  Let's complicate the implementation: let's make CanExecute return false while the task is running.  The interface will not hang, the command will not run in parallel several times, we have achieved our goal.  But all this needs to be done with your own hands.  And in the ReactiveUI team already know how all this and more. <br><br><hr><br><h4>  Reactive teams </h4><br>  Let's get acquainted with ReactiveCommand &lt;T&gt;.  Don't confuse: there is still a non-generic implementation with the same name: ReactiveCommand (it is in the ReactiveUI.Legacy namespace, and is obviously outdated).  This generic parameter does not mean a type of parameter, but a type of result, but we will return to this later. <br><br>  Immediately try to create and run a command, first dropping everything related to CanExecute.  Notice that usually we don‚Äôt create any commands directly via the new operator, but use the static ReactiveCommand class that provides the necessary methods. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> command = ReactiveCommand.Create(); command.Subscribe(_ =&gt; { Console.WriteLine(DateTime.Now.ToLongTimeString() + <span class="hljs-string"><span class="hljs-string">"   "</span></span>); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(DateTime.Now.ToLongTimeString() + <span class="hljs-string"><span class="hljs-string">"   "</span></span>); }); command.Execute(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); Console.WriteLine(DateTime.Now.ToLongTimeString() + <span class="hljs-string"><span class="hljs-string">"   "</span></span>); Console.ReadLine();</code> </pre><br>  The ReactiveCommand.Create () method creates synchronous tasks, they are of type ReactiveCommand &lt;object&gt;.  Execute () returns control only after completion: <br><blockquote>  19:01:07 Starting a long task <br>  19:01:08 End a long task <br>  19:01:08 After starting the team <br></blockquote><br>  Later we will look at ways to create asynchronous commands, but for now let's take a look at controlling the ability to execute a command. <br><br><h4>  Ability to execute a command </h4><br>  Let's discuss CanExecute and related features.  In addition to what we have already seen (the CanExecute method and the CanExecuteChanged event), the ReactiveCommand provides the IsExecuting and CanExecuteObservable sequences: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> command = ReactiveCommand.Create(); command.Subscribe(_ =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" "</span></span>)); command.CanExecuteChanged += (o, a) =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"CanExecuteChanged event: now CanExecute() == {0}"</span></span>, command.CanExecute(<span class="hljs-literal"><span class="hljs-literal">null</span></span>)); command.IsExecuting.Subscribe(isExecuting =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"IsExecuting: {0}"</span></span>, isExecuting)); command.CanExecuteObservable.Subscribe(canExecute =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"CanExecuteObservable: {0}"</span></span>, canExecute)); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"  ,  ..."</span></span>); command.Execute(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"  "</span></span>);</code> </pre><br><blockquote>  IsExecuting: False <br>  CanExecuteObservable: False <br>  CanExecuteObservable: True <br>  CanExecuteChanged event: now CanExecute () == True <br>  Subscribed to everything, run the command ... <br>  IsExecuting: True <br>  CanExecuteChanged event: now CanExecute () == False <br>  CanExecuteObservable: False <br>  Running command <br>  IsExecuting: False <br>  CanExecuteChanged event: now CanExecute () == True <br>  CanExecuteObservable: True <br>  After running the command <br></blockquote><br>  You can especially not pay attention to what happens immediately after the subscription and before the launch of the command: this is initialization.  In fact, we immediately return to the current state upon subscription (it turns out a cold first element and hot following ones).  And CanExecuteObservable is initially set to false.  It seems that when you subscribe, they first give us this value, and then the team determines that we have not provided a mechanism for determining accessibility, and makes the command available by default. <br>  Judging by the output of the program, the command is already unavailable during its execution.  This is especially true for asynchronous commands: they will not be run in parallel several times.  Thus, CanExecute, CanExecuteObservable and the CanExecuteChanged event depend not only on what we provide for the calculation, but also on whether the command is being executed now.  IsExecuting provides information about whether the command is currently being executed, and this can be used, for example, to display some kind of work indicator. <br><br>  Let's now give the team information on when it can be executed.  For this, every method for creating commands in the ReactiveCommand class has overloads that take <i>IObservable &lt;bool&gt; canExecute</i> .  The team will subscribe to this sequence and, upon receiving changes, will update their information on the availability of execution.  We look: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subject&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> command = ReactiveCommand.Create(subject); command.CanExecuteChanged += (o, a) =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"CanExecuteChanged event: now CanExecute() == {0}"</span></span>, command.CanExecute(<span class="hljs-literal"><span class="hljs-literal">null</span></span>)); command.CanExecuteObservable.Subscribe(canExecute =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"CanExecuteObservable: {0}"</span></span>, canExecute)); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"  "</span></span>); subject.OnNext(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"  "</span></span>); subject.OnNext(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"    "</span></span>); subject.OnNext(<span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br>  Subject here is observable, which we control with our own hands, giving out the necessary values ‚Äã‚Äãto the team through it.  At least it is very convenient for testing.  We subscribe to everything, make the execution available, and then two times unavailable.  What result will we get? <br><blockquote>  CanExecuteObservable: False <br>  Making execution available <br>  CanExecuteChanged event: now CanExecute () == True <br>  CanExecuteObservable: True <br>  Making execution unavailable <br>  CanExecuteChanged event: now CanExecute () == False <br>  CanExecuteObservable: False <br>  Once again we make execution inaccessible <br></blockquote><br>  It seems everything is expected.  Initially, execution is not available.  Then the team begins to respond to the changes we are making.  Here it is worth only mentioning that when we send the same availability state several times in a row, the team ignores repetitions.  Note also that CanExecuteObservable is simply a sequence of values ‚Äã‚Äãof type bool, and here there is an incompatibility with the fact that the CanExecute method has a parameter.  In ReactiveCommand, it is simply ignored. <br><br><h4>  Ways to invoke a command </h4><br>  We have already seen the command call with the Execute () method.  Look at other ways: <br><br>  <b>IObservable &lt;T&gt; ExecuteAsync (object parameter)</b> <br>  There is one feature: the command will not start until the subscription to the result of ExecuteAsync ().  We use it: <br><pre> <code class="cs hljs">command.ExecuteAsync().Subscribe();</code> </pre><br>  However, the synchronous command does not become asynchronous from this.  Of course, ExecuteAsync () will return control immediately, but execution has not yet started!  A Subscribe (), which starts it, returns control only after the completion of the command.  In fact, now we have written the equivalent of Execute ().  However, this is natural, because ExecuteAsync () returns a cold sequence and subscribing to it initiates the execution of our long task.  And it is executed in the current thread.  Although this can be fixed by explicitly specifying where to subscribe: <br><pre> <code class="cs hljs">command.ExecuteAsync().SubscribeOn(TaskPoolScheduler.Default).Subscribe();</code> </pre><br>  Now the TPL scheduler is responsible for completing the subscription.  Accordingly, the subscription will be executed in something like Task.Run (), and everything will work as it should.  But to do this in reality is not worth it, and this example only shows one of the possibilities.  All sorts of planners are many, and one day we will touch on this topic. <br><br>  <b>Task &lt;T&gt; ExecuteAsyncTask (object parameter)</b> <br>  Unlike ExecuteAsync (), this method immediately runs the command.  We try: <br><pre> <code class="cs hljs">command.ExecuteAsyncTask();</code> </pre><br>  We were returned Task &lt;&gt;, but there is still no happiness in life.  ExecuteAsyncTask () also returns control only after the completion of the command, and gives us the already completed task.  Some kind of setup. <br><br>  <b>InvokeCommand ()</b> <br>  This method allows you to conveniently customize the command call when a signal appears in the sequence (for example, a property change).  Like that: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.WhenAnyValue(x =&gt; x.FullName).Where(x =&gt; !<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(x)).InvokeCommand(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Search); <span class="hljs-comment"><span class="hljs-comment">//     this.WhenAnyValue(x =&gt; x.FullName).Where(x =&gt; !string.IsNullOrEmpty(x)).InvokeCommand(this, x =&gt; x.Search); // ,      </span></span></code> </pre><br>  So far we have not found a way to execute the command asynchronously.  Of course, you can use the ExecuteAsync () method and assign a scheduler to perform the subscription, but this is a crutch.  Moreover, WPF does not know about this method and will still call Execute () and hang itself. <br><br><h4>  Asynchronous reactive commands </h4><br>  Synchronous commands make sense when actions are performed quickly and there is no reason to complicate things.  And for long tasks, asynchronous commands are needed.  Here two methods help us: ReactiveCommand.CreateAsyncObservable () and ReactiveCommand.CreateAsyncTask ().  The difference between them is only in what the action performed is expressed.  We return to the first section of the article and how to present asynchronous tasks. <br><br>  Let's see CreateAsyncObservable: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> action = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Action(() =&gt; { Console.WriteLine(DateTime.Now.ToLongTimeString() + <span class="hljs-string"><span class="hljs-string">"   "</span></span>); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(DateTime.Now.ToLongTimeString() + <span class="hljs-string"><span class="hljs-string">"   "</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> command = ReactiveCommand.CreateAsyncObservable(_ =&gt; Observable.Start(action)); Console.WriteLine(DateTime.Now.ToLongTimeString() + <span class="hljs-string"><span class="hljs-string">"  ..."</span></span>); command.Execute(<span class="hljs-number"><span class="hljs-number">42</span></span>); Console.WriteLine(DateTime.Now.ToLongTimeString() + <span class="hljs-string"><span class="hljs-string">"   "</span></span>); Console.ReadLine();</code> </pre><br><blockquote>  2:33:50 Run the command ... <br>  2:33:50 After starting the team <br>  2:33:50 Starting a long task <br>  2:33:51 ending a long task <br></blockquote><br>  Hooray!  Execute is no longer blocked until the command is completed, and the interface will not hang.  With ExecuteAsync and ExecuteAsyncTask, everything is the same: there are no locks. <br><br>  Now reateAsyncTask: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> command = ReactiveCommand.CreateAsyncTask(_ =&gt; Task.Run(action)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> command = ReactiveCommand.CreateAsyncTask(_ =&gt; doSomethingAsync()); <span class="hljs-comment"><span class="hljs-comment">//   Task&lt;T&gt; var command = ReactiveCommand.CreateAsyncTask(async _ =&gt; await doSomethingAsync());</span></span></code> </pre><br>  Both of the described methods have many overloads that support, for example, the transfer of CanExecuteObservable or the possibility of cancellation. <br>  In addition, a result can be returned from an asynchronous command.  Generic-parameter T from ReactiveCommand &lt;T&gt; is just the type of the result of the command: <br><pre> <code class="cs hljs">ReactiveCommand&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; command = ReactiveCommand.CreateAsyncTask(_ =&gt; Task.Run(() =&gt; <span class="hljs-number"><span class="hljs-number">42</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> command.ExecuteAsync(); <span class="hljs-comment"><span class="hljs-comment">// result == 42</span></span></code> </pre><br>  And you can immediately send it somewhere: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> command = ReactiveCommand.CreateAsyncTask(_ =&gt; Task.Run(() =&gt; <span class="hljs-number"><span class="hljs-number">42</span></span>)); command.Subscribe(result =&gt; _logger.Log(result)); _answer = command.ToProperty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Answer); <span class="hljs-comment"><span class="hljs-comment">//        (ObservableToPropertyHelper)</span></span></code> </pre><br>  It is guaranteed that the result is returned in the UI stream.  Therefore, by the way, it is contraindicated to perform some long actions as a reaction to the execution of a command in Subscribe.  In the case of synchronous commands, the own result cannot be returned, the command is of type ReactiveCommand &lt;object&gt; and the values ‚Äã‚Äãwith which the command was launched will be returned. <br><br><h4>  We catch exceptions that occur when teams work </h4><br>  Exceptions to the operation of commands can occur constantly, especially if we are talking about some kind of data loading.  Accordingly, it is necessary to learn how to catch and process them.  Where and how to do it? <br><br>  <b>Synchronous commands</b> <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> command = ReactiveCommand.Create(); command.Subscribe(_ =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(); }); command.ThrownExceptions.Subscribe(e =&gt; Console.WriteLine(e.Message)); command.Execute(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   command.ExecuteAsync().Subscribe(); //  InvalidOperationException await command.ExecuteAsyncTask(); //  InvalidOperationException</span></span></code> </pre><br>  Since the calls of all methods are synchronous, one would expect that they will throw exceptions.  But everything is not so simple.  Execute () does not actually throw an exception.  It is implemented in such a way that all exceptions simply swallow.  The other two methods throw exceptions immediately, as expected. <br><br>  <b>With asynchronous commands, everything is much more interesting.</b> <br>  ReactiveCommand provides a ThrownExceptions sequence through which exceptions that occur during the execution of asynchronous commands come.  There is no difference between Observable and Task teams.  Let's create teams for our experiment: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> command = ReactiveCommand.CreateAsyncTask(_ =&gt; Task.Run(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(); })); <span class="hljs-comment"><span class="hljs-comment">/* 1  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> command = ReactiveCommand.CreateAsyncObservable(_ =&gt; Observable.Start(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(); })); <span class="hljs-comment"><span class="hljs-comment">/* 2  */</span></span> command.ThrownExceptions.Subscribe(e =&gt; Console.WriteLine(e.Message));</code> </pre><br>  And try different ways to invoke the command: <br><pre> <code class="cs hljs">command.Execute(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   ThrownExceptions command.ExecuteAsyncTask(); // InvalidOperationException  -   (Task   ) command.ExecuteAsync().Subscribe(); // InvalidOperationException  -  ,  Task    await command.ExecuteAsync(); //  InvalidOperationException     ThrownExceptions await command.ExecuteAsyncTask(); //  InvalidOperationException     ThrownExceptions var subj = new Subject&lt;Unit&gt;(); subj.InvokeCommand(command); subj.OnNext(Unit.Default); //   ThrownExceptions</span></span></code> </pre><br>  If we somehow subscribe to the command itself (for example, command.ToProperty (...)), then when an exception occurs, the OnError () command is not sent. <br><br>  In this example, it seems strange examples in which exceptions will occur "sometime".  In the TPL, this was necessary so that uncaught exceptions did not disappear without a trace.  Here it was possible to transfer them through ThrownExceptions and not to throw "in the future."  But such is the implementation, and in the next version ReactiveUI will seem to change something in this respect. <br><br><h4>  Cancel asynchronous commands </h4><br>  Commands that can take a long time would be good to be able to cancel.  There are many ways to do this.  Create an asynchronous command, which will loop the message in a loop until it is canceled: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> command = ReactiveCommand.CreateAsyncTask(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (a, t) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!t.IsCancellationRequested) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">300</span></span>); } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">""</span></span>); });</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The first way to cancel is canceling a subscription based on ExecuteAsync (): </font></font><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> disposable = command.ExecuteAsync().Subscribe(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); disposable.Dispose();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The second way is to transfer a token via ExecuteAsyncTask (): </font></font><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); command.ExecuteAsyncTask(ct: source.Token); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); source.Cancel();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But what to do if we want to cancel a command that is launched by the Execute () method, that is, when called, for example, by WPF itself? </font><font style="vertical-align: inherit;">This is also easy to do, for this we need to wrap the Task in IObservable and use the TakeUntil () method. </font><font style="vertical-align: inherit;">I will give an example with calling another command to cancel:</font></font><br><pre> <code class="cs hljs">Func&lt;CancellationToken, Task&gt; action = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (ct) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!ct.IsCancellationRequested) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">300</span></span>); } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">""</span></span>); }; IReactiveCommand&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; cancelCommand = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> runCommand = ReactiveCommand.CreateAsyncObservable(_ =&gt; Observable.StartAsync(action).TakeUntil(cancelCommand)); cancelCommand = ReactiveCommand.Create(runCommand.IsExecuting); runCommand.Execute(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); cancelCommand.Execute(<span class="hljs-literal"><span class="hljs-literal">null</span></span>);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The command is executed until the next notification appears in the cancelCommand sequence. </font><font style="vertical-align: inherit;">In fact, there may not even be a command at the place of cancelCommand, but any observable sequence. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In all these methods there is one subtlety: when we initiate cancellation, the command is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immediately</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> considered complete and available for re-execution, but if the cancellation token is ignored by the task, then some actions can continue inside. </font><font style="vertical-align: inherit;">This should also be taken into account if the command becomes canceled. </font><font style="vertical-align: inherit;">This is especially the case when we cancel a command in which there is no Task &lt;T&gt; at all:</font></font><br><pre> <code class="cs hljs">Action action = () =&gt; { ... }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> runCommand = ReactiveCommand.CreateAsyncObservable(_ =&gt; Observable.Start(action).TakeUntil(cancelCommand));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, the action will be executed after we cancel the execution and the command will again be available for the call. </font><font style="vertical-align: inherit;">Only it will happen behind the curtain, and can lead to very unexpected results.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Team unification </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can easily create a command that calls other commands: </font></font><br><pre> <code class="cs hljs">RefreshAll = ReactiveCommand.CreateCombined(RefreshNotifications, RefreshMessages);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, the command is executable when all commands from the transferred set are executable. </font><font style="vertical-align: inherit;">There is also an overload into which a separate canExecute can be passed to indicate when the command can be executed. </font><font style="vertical-align: inherit;">In this case, the possibility of executing each command and the parameter passed are taken into account.</font></font><br><br><hr><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> An example of working with teams </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's write a small example showing the use of commands. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will do a search. Well, conditional search. In fact, we will mimic the activity for a second and a half and return as a result a collection of several query modifications. We will also support canceling the search, clearing the old result when starting a new search and the ability to perform a search automatically when the input data changes. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We are looking at the view model:</font></font><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SearchViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">ReactiveObject</span></span> { [Reactive] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> SearchQuery { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } [Reactive] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AutoSearch { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ObservableAsPropertyHelper&lt;ICollection&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;&gt; _searchResult; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ICollection&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; SearchResult =&gt; _searchResult.Value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IReactiveCommand&lt;ICollection&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;&gt; Search { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IReactiveCommand&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; CancelSearch { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SearchViewModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Search = ReactiveCommand.CreateAsyncObservable( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.WhenAnyValue(vm =&gt; vm.SearchQuery).Select(q =&gt; !<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(q)), _ =&gt; Observable.StartAsync(ct =&gt; SearchAsync(SearchQuery, ct)).TakeUntil(CancelSearch) ); CancelSearch = ReactiveCommand.Create(Search.IsExecuting); Observable.Merge( Search, Search.IsExecuting.Where(e =&gt; e).Select(_ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;())) .ToProperty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, vm =&gt; vm.SearchResult, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> _searchResult); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.WhenAnyValue(vm =&gt; vm.SearchQuery) .Where(x =&gt; AutoSearch) .Throttle(TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">0.3</span></span>), RxApp.MainThreadScheduler) .InvokeCommand(Search); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Task&lt;ICollection&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;&gt; SearchAsync(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> query, CancellationToken token) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1500</span></span>, token); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;() { query, query.ToUpper(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(query.Reverse().ToArray()) }; } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, there are shortcomings. One of them in the auto search. If during the execution of the search the user changes the query, the current search will not be stopped and it will be completed first, and then a search will be performed on a new query. However, correcting this is a matter of a couple of lines. Or, say, it is strange not to clear the search results in the case when the user has erased the entire query. But we will leave such complex examples to the following parts, but for now we restrict ourselves to the existing logic. Once again I will draw attention to the fact that, in general, not the most primitive behavior of our search engine is concentrated in one place and is described fairly briefly and clearly. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Look at XAML:</font></font><br><pre> <code class="cs hljs">&lt;Grid DataContext=<span class="hljs-string"><span class="hljs-string">"{Binding ViewModel, ElementName=Window}"</span></span>&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=<span class="hljs-string"><span class="hljs-string">"Auto"</span></span>/&gt; &lt;RowDefinition Height=<span class="hljs-string"><span class="hljs-string">"*"</span></span>/&gt; &lt;RowDefinition Height=<span class="hljs-string"><span class="hljs-string">"Auto"</span></span>/&gt; &lt;/Grid.RowDefinitions&gt; &lt;StackPanel&gt; &lt;Label&gt;Search query:&lt;/Label&gt; &lt;TextBox Margin=<span class="hljs-string"><span class="hljs-string">"10, 5"</span></span> Text=<span class="hljs-string"><span class="hljs-string">"{Binding SearchQuery, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"</span></span> /&gt; &lt;/StackPanel&gt; &lt;ListBox Grid.Row=<span class="hljs-string"><span class="hljs-string">"1"</span></span> ItemsSource=<span class="hljs-string"><span class="hljs-string">"{Binding SearchResult}"</span></span>/&gt; &lt;Grid Grid.Row=<span class="hljs-string"><span class="hljs-string">"2"</span></span>&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width=<span class="hljs-string"><span class="hljs-string">"*"</span></span>&gt;&lt;/ColumnDefinition&gt; &lt;ColumnDefinition Width=<span class="hljs-string"><span class="hljs-string">"Auto"</span></span>&gt;&lt;/ColumnDefinition&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;ProgressBar Margin=<span class="hljs-string"><span class="hljs-string">"10"</span></span> x:Name=<span class="hljs-string"><span class="hljs-string">"SearchExecutingProgressBar"</span></span> /&gt; &lt;StackPanel Orientation=<span class="hljs-string"><span class="hljs-string">"Horizontal"</span></span> Grid.Column=<span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt; &lt;CheckBox VerticalAlignment=<span class="hljs-string"><span class="hljs-string">"Center"</span></span> IsChecked=<span class="hljs-string"><span class="hljs-string">"{Binding AutoSearch, Mode=TwoWay}"</span></span>&gt;Auto search&lt;/CheckBox&gt; &lt;Button Margin=<span class="hljs-string"><span class="hljs-string">"10"</span></span> Command=<span class="hljs-string"><span class="hljs-string">"{Binding Search}"</span></span>&gt;Run&lt;/Button&gt; &lt;Button Margin=<span class="hljs-string"><span class="hljs-string">"10"</span></span> Command=<span class="hljs-string"><span class="hljs-string">"{Binding CancelSearch}"</span></span>&gt;Cancel&lt;/Button&gt; &lt;/StackPanel&gt; &lt;/Grid&gt; &lt;/Grid&gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The question here may call ProgressBar. </font><font style="vertical-align: inherit;">I wanted it included in the search process. </font><font style="vertical-align: inherit;">But in the Search command, the IsExecuting property is not a bool, but a sequence, and binding to it in XAML will not work. </font><font style="vertical-align: inherit;">Therefore, we will do the binding in the constructor of our view:</font></font><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MainWindow</span></span> : <span class="hljs-title"><span class="hljs-title">Window</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SearchViewModel ViewModel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MainWindow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ViewModel = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SearchViewModel(); InitializeComponent(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.WhenAnyObservable(w =&gt; w.ViewModel.Search.IsExecuting).BindTo(SearchExecutingProgressBar, pb =&gt; pb.IsIndeterminate); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yes, in ReactiveUI there is support for such binding here, and in theory I could do them all this way. </font><font style="vertical-align: inherit;">But we will talk about binders another time, but for now I have limited myself to what I can't do without.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Look at the result</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/files/e00/b69/c51/e00b69c513384c5abbd9c1cd0367efb1.gif"><br></div></div><br><br>  Hooray!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It works as it should, the interface does not hang during the search, cancellation works, autosearch works </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the customer is ecstatic and gives a triple bonus</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><hr><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the next episode </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So let's summarize a little. </font><font style="vertical-align: inherit;">In this part, we figured out what the relationship is between Task &lt;T&gt; and IObservable &lt;T&gt;. </font><font style="vertical-align: inherit;">We compared hot and cold sequences. </font><font style="vertical-align: inherit;">But our main topic was the team. </font><font style="vertical-align: inherit;">We learned how to create synchronous and asynchronous commands and call them in different ways. </font><font style="vertical-align: inherit;">We figured out how to enable and disable the ability to execute them, as well as how to intercept errors in asynchronous commands. </font><font style="vertical-align: inherit;">In addition, we figured out how to cancel asynchronous commands. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I wanted to touch upon the view model in this part, but somehow I didn‚Äôt expect the teams to stretch into such a sheet. </font><font style="vertical-align: inherit;">Therefore, this time it will not be. </font><font style="vertical-align: inherit;">In the next part, we will consider either bindings, or testing and planners.</font></font><br>  Do not switch! </div><p>Source: <a href="https://habr.com/ru/post/305350/">https://habr.com/ru/post/305350/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../305334/index.html">The feasibility and benefits of using server drives, building RAID arrays, is it worth saving and when?</a></li>
<li><a href="../305336/index.html">Blocking of IP addresses of CloudFlare in Beeline. 149-FZ</a></li>
<li><a href="../305338/index.html">Let me go Meteor</a></li>
<li><a href="../305340/index.html">Interview on the programmer in Amazon</a></li>
<li><a href="../305342/index.html">Why tech support is (intentionally) unbearable</a></li>
<li><a href="../305352/index.html">6 "harmful" tips to the developer</a></li>
<li><a href="../305354/index.html">Guilloche</a></li>
<li><a href="../305356/index.html">The digest of interesting materials for the mobile # 161 developer (July 3-10)</a></li>
<li><a href="../305360/index.html">Reasonable AOP for IOC container fans</a></li>
<li><a href="../305364/index.html">Running cron inside the Docker container</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>