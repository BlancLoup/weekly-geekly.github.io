<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Develop a simple game in the game maker. Episode 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue to implement the Plants vs Zombies clone in Game Maker, studying the main features of game development in this environment. In this episod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Develop a simple game in the game maker. Episode 1</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/7f3/9bf/e22/7f39bfe229cb4c9090193bff6c2e7a28.png" width="720"></div><br><br>  <a href="http://habrahabr.ru/post/255995/" title="Episode 0 - Introduction to Game Maker and the first lines">We continue to</a> implement the Plants vs Zombies clone in Game Maker, studying the main features of game development in this environment.  In this episode, we will cover such concepts as scripts, timelines, the keyword other, depth, redefine the Draw event, explore some useful functions, and talk about debugging games. <br><br><a name="habracut"></a><br>  Now we can arrange the units as much as necessary, but in this lesson we will fix this.  In the o_game object in the Create event we will add a new variable, pEnergy, which will be responsible for storing the amount of energy (in Plants vs Zombies, these are suns).  For energy, you can buy units.  Also add a new alarm, which will be responsible for generating new energy units (in the original the suns fell from above).  So the event will now look like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cs hljs">pEnergy = <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-comment"><span class="hljs-comment">// player energy alarm[0] = room_speed; // generate enemies alarm[1] = room_speed * 3; // generate energy units</span></span></code> </pre> <br><br>  Alarm 1 event: <br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> generate energy elements instance_create(irandom(room_width - 40) + 40, irandom(room_height - 40) + 40, o_elem_energy); alarm[1] = room_speed * 6.5;</span></span></code> </pre><br><br>  Now we will make the "elements" of energy themselves, which will appear in a random place on the game screen, and then move.  Create a new object, set the sprite, call it o_elem_energy.  In the Create event, write such code <br><br><pre> <code class="cs hljs">image_alpha = <span class="hljs-number"><span class="hljs-number">0</span></span>; eAmount = <span class="hljs-number"><span class="hljs-number">25</span></span>; <span class="hljs-comment"><span class="hljs-comment">// amount of energy to add alarm[0] = 1; // incr alpha</span></span></code> </pre><br><br>  image_alpha = 0 is a built-in variable that makes the sprite completely invisible when the rendering code is executed.  image_alpha takes any value from 0 (invisible) to 1 (visible).  0.5 is 50% visibility.  Using Alarm 0, we will increase alpha, i.e.  make the sprite visible. <br><br>  eAmount is a user variable that will store the amount of energy received by the player when clicked. <br><br>  Code for Alarm 0: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Incr alpha if (image_alpha + 0.05 </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;= 1){ image_alpha += 0.05; alarm[0] = 1; }</span></span></span></span></code> </pre><br><br>  [Optimization corner] <br><br>  In the last episode, our ‚Äúbullets‚Äù used to shoot plants just flew horizontally and did it endlessly.  When there are such bullets there, say, 100, this is not a problem, but at 1000, there may be a drop in performance.  But in any case, it is necessary to get rid of unnecessary elements as soon as they are no longer necessary.  Since as soon as the bullets fly out of the screen, they no longer interest us, they should be removed immediately.  This can be done in 2 ways - through the standard Other event -&gt; Outside View (or Outside Room, depends on your game), or simply to check if the object is not on the screen itself.  There is no difference between them, standard events do exactly the same thing as the second method, they just do it for you.  So add the Step event to the o_bullet object and add the following code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x - sprite_width / <span class="hljs-number"><span class="hljs-number">2</span></span> &gt; room_width){ instance_destroy(); }</code> </pre><br><br>  Here, I hope everything is clear - as soon as the left border of the sprite goes beyond the scope of the room (room), we destroy the instance. <br>  [/ Optimization Corner] <br><br>  Now go back to the o_elem_energy object and create a Step event.  We write this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y + sprite_height/<span class="hljs-number"><span class="hljs-number">2</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>){ instance_destroy(); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ y -= <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre><br><br>  Here we move our instance every step 2 pixels up and, if the bottom border of the sprite is above the room, then we delete the instance. <br><br>  The player will need to click on the element of energy to get it.  To do this, create the Left Button event.  This event is triggered not only when we press (Left pressed) or release the mouse or finger on the touch devices (Left released), but when the mouse just goes through our instance, which suits us perfectly.  The code for this event could be: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> grab energy with(o_game){ pEnergy += other.eAmount; } instance_destroy();</span></span></code> </pre><br><br>  However, in the first episode, I promised that we would add support for the gamepad, and it is obvious that the gamepad does not have the Left Button event (or Left Pressed, or Left Released) instantiated.  And, accordingly, when controlling a gamepad, there will be another way to select energy.  And if so the code above will be duplicated.  However, duplication, for obvious reasons, is bad, so it's time to get acquainted with an important element of Game Maker - scripts (Scripts folder).  In fact, they are no different from the code that we write inside events, but the way it is triggered is different - you need to call it yourself.  Scripts are very convenient with duplicate code, while scripts can still take parameters, as functions (methods) in any other programming language do. <br><br>  We just have a case of the need to duplicate the code in the future, so instead of the code above in the Left Button event we write: <br><br><pre> <code class="cs hljs">scr_elem_energy_grab();</code> </pre><br><br>  This is the function call.  Parameters can be passed in brackets, but now we do not need them.  Game Maker now shows an error, because  this function does not yet exist.  Fix it - create a script, just like create objects / sprites / etc., rename it to scr_elem_energy_grab and put that code above (which starts with the comment /// grab energy).  We save, close and now no errors and further repetition of the code when we develop a mechanism for catching energy with a gamepad. <br>  Now when the instantiated object o_elem_energy triggers the Left Button event, we run the script scr_elem_energy_grab, which does the following - refers to the variable pEnergy of the instance instance of the o_game (we have one, so we can access it and o_game.pEnergy) and assign its value to a variable other.eAmount. <br><br>  We have already encountered the keyword other, but here its meaning is somewhat different.  Other.eAmount is a call to the instance variable of the object that started the with loop.  You asked, and who launched it?  Fine!  Let's think?  The with loop belongs to the object that called it.  And who called him, he's in the script?  Everything is simple - the script is launched on behalf of the instance object o_elem_energy and, accordingly, gets access to its variables.  So other.eAmount is a call to the eAmount variable that we declared in the Create event of the o_elem_energy object.  In Game Maker, everything is simple.  If we write simply pEnergy = eAmount;  then we will access the eAmount variable of the o_game instance, which does not exist, which will cause an error. <br><br>  Once again for fixing, writing such constructions will often have to be independent of the complexity of the game.  O_elem_energy has a variable eAmount.  In the Left Button event, it runs on behalf of the scr_elem_energy_grab object, i.e.  in the script, we can refer directly to the eAmount variable, however we add energy in the with loop.  Events inside with occur on the face of the o_game object and we can no longer directly access eAmount.  But we have the other keyword, with which we seem to go beyond the limits of the with loop and get access to eAmount again, because  we are inside a script running on behalf of o_elem_energy.  It is very simple and, I hope, it is clear to you. <br><br>  Remember, in the first episode we registered the Global Left Released event, which always works on the whole ‚Äúcanvas‚Äù of the game.  When we added a new Left Button event to the o_elem_energy object, a jamb formed.  After all, it turns out that when we pick up energy, the Global Left Released event of the o_game object will be launched and, accordingly, the unit will be placed on the playing field.  Strange behavior, isn't it?  So you need to be very careful with Global events.  This is very easy to fix, but we will still redo the placement mechanism for the units, so we‚Äôll leave it for later, and the source code on github will temporarily fix this problem. <br><br>  We realize the equivalent of sunflowers.  Create a new object and call it o_unit_enery_generator, give it a sprite and set the parent object o_unit_parent.  To avoid chaos among objects / sprites / scripts, there are groups in Game Maker.  Right-click on the folder Objects -&gt; Create new group.  Give her any meaningful name, for example, grp_units.  In it, we will store all user units.  Drag them into this group.  Do the same for enemy objects.  The name of the groups and the sorting of objects by them are created solely for your convenience and no longer affects anything. <br><br>  There is nothing new in the object code o_unit_enery_generator, so I just post its contents. <br><br>  Create: <br><pre> <code class="cs hljs">event_inherited(); HP = <span class="hljs-number"><span class="hljs-number">15</span></span>; genElemEnergyTime = room_speed * <span class="hljs-number"><span class="hljs-number">2</span></span>; alarm[<span class="hljs-number"><span class="hljs-number">0</span></span>] = genElemEnergyTime;</code> </pre><br><br>  Alarm 0: <br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> generate energy elements instance_create(x,y,o_elem_energy); alarm[0] = genElemEnergyTime;</span></span></code> </pre><br><br>  Now, when we have energy and it is generated, it would be nice to provide the opportunity to buy units, and for this we need some kind of GUI, where we can see the amount of available energy and select the desired unit.  And this will do. <br><br>  It's time to get acquainted with the event Draw.  Previously, it did not interest us, because  arranged the standard features for drawing objects of their sprites.  Now we need something non-standard.  This is a pretty important element in learning Game Maker. <br><br>  So, add a Draw event to the o_game object. <br><br><pre> <code class="cs hljs">draw_set_alpha(<span class="hljs-number"><span class="hljs-number">0.68</span></span>); draw_rectangle_colour(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>, elemGUI_width, elemGUI_height, c_blue, c_blue, c_blue, c_blue, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); draw_set_alpha(<span class="hljs-number"><span class="hljs-number">1</span></span>); draw_text_colour(<span class="hljs-number"><span class="hljs-number">40</span></span>,<span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(pEnergy), c_black, c_black, c_black, c_black, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br><br>  draw_set_alpha is a standard function that sets the transparency (alpha channel) of everything drawn after it.  For reasons I do not understand, the draw_rectangle_colour function does not have the ability to directly set transparency, so you have to use the draw_set_alpha method.  Be careful, changing the alpha channel, you change the transparency of the whole draw, and not just what is written in this particular Draw event.  This function also affects other objects, so as soon as you change the alpha, draw everything you need, return the transparency to its original position, i.e.  in 1. <br><br>  draw_rectangle_colour draws a blue-filled rectangle with the coordinates of the upper left corner (0; 0) and the coordinates of the lower right (elemGUI_width; elemGUI_height), respectively.  Do not forget to declare these variables in the Create event with values, for example, 200 and 50, respectively. <br><br>  draw_text_colour draws text of a given color, according to given coordinates.  Since  the pEnergy variable stores the number, you need to translate it into a string using string ().  Although the types are not set directly in Game Maker and you can add a number to the string without any problems, but for the Draw event you need to convert numbers to strings. <br><br>  [Attention] <br>  And now the moment, if the object is given a sprite, then with such a code as above, it will not be drawn.  Remember, in the first episode I mentioned that if we do not override the Draw event, then Game Maker itself will draw the sprite given to the object.  So, with the code above, we override the Draw event, and if the sprite were given to the o_game object, then it would stop drawing.  In order for the sprite to be drawn again, it is necessary to add draw_self () in the desired place of the overridden Draw event;  This line is responsible for drawing the given sprite object. <br><br>  Now consider another important point in Game Maker - depth.  In the last episode, we have already seen it 1 time.  It is time to elaborate on this point.  Depth determines the order of rendering.  The higher the Depth value, the object will be drawn in the lower layer.  Depth values ‚Äã‚Äãcan be both positive and negative.  Example - there are 3 obj0 objects with depth 0, obj1 with depth 100, obj2 with depth -20.  Render order - obj1 -&gt; obj0 -&gt; obj2.  Those.  if all 3 objects are on the screen in the same coordinates, obj2 will appear on top of all. <br><br>  Since o_game draws a GUI, it should be above all other layers.  So put him a depth equal to -100.  This can be done in the Create event or on the page of the object itself.  You can change the depth from anywhere in the code. <br><br>  So, we are drawing now exclusively blue rectangle with the inscription of the amount of available energy.  But you need to draw the choice of a unit.  This can be done in two ways - to make the unit selection buttons separate objects and simply place them along the coordinates on this rectangle, or you can draw icons directly into o_game and catch click events in the Step event (yes, you can do this instead of individual events).  The second method is more sophisticated, but the first one is simpler and specifically in this case more correct. <br><br>  So, we need objects, activating which we will be able to choose which particular unit we are going to install now.  In fact, for this purpose we are suitable and 1 object.  Create it and call it o_gui_unit. <br><br>  Create event: <br><pre> <code class="cs hljs">unitID = <span class="hljs-number"><span class="hljs-number">-1</span></span>; isActivated = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre><br><br>  Left Pressed event: <br><br><pre> <code class="cs hljs">with(o_game){ isPlaceUnitClick = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } with(o_gui_unit){ isActivated = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } isActivated = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre><br><br>  The first 3 lines are exactly the protection from incorrect clicks, so that when you click on a GUI, the object is not placed on the playing field.  You can delete this, or add the line isPlaceUnitClick = true;  in the Create object o_game. <br><br>  Draw event: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isActivated){ draw_rectangle_colour(x - sprite_width/<span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">3</span></span>, y - sprite_height/<span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">3</span></span>, x + sprite_width/<span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">3</span></span>, y + sprite_height/<span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">3</span></span>, c_yellow, c_yellow, c_yellow, c_yellow, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } draw_self(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unitID &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>){ draw_text(x, y + sprite_height/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(o_game.unitCost[unitID])); }</code> </pre><br><br>  From the side of the code, what is happening in this object should be obvious - in the Left Pressed event we go through all instances of the o_gui_unit object and change the value of the user variable isActivated to false, which makes it not the current selected for us, but the current instance is active.  If it is not clear, set comments. <br><br>  Also set the depth object to -110.  In general, any number, but less than o_game as the blue backing should be under the units, not over.  Either manually change, or in Create you can write depth = o_game.depth - 10; <br>  Never add 1-2 depth units to another object.  Always leave a little (5-10 units) in case you have to change something. <br><br>  One slippery moment.  If the object does not have a sprite, and we call the function draw_self ();  there will be an error  there is nothing to draw.  In this case, in this case, set any sprite.  Anyway, he does not have time to draw, and we will ask the necessary one later.  In general, it is better not to do this, but to put, for example, a check. <br><br>  Now we need to change a little o_game.  The Create event will now look like this: <br><br><pre> <code class="cs hljs">pEnergy = <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-comment"><span class="hljs-comment">// player energy alarm[0] = room_speed; // generate enemies alarm[1] = room_speed * 3; // generate energy units elemGUI_width = 200; elemGUI_height = 50; isPlaceUnitClick = true; enum units{ shooter = 0, energyGenerator = 1 } unitCost[units.shooter] = 50; unitCost[units.energyGenerator] = 25; var unitSprite; unitSprite[units.shooter] = spr_unit_shooter; unitSprite[units.energyGenerator] = spr_unit_energy_generator; var u = instance_create(100, 25, o_gui_unit); u.unitID = units.shooter; u.sprite_index = unitSprite[u.unitID]; u.isActivated = true; u = instance_create(100 + sprite_get_width(unitSprite[units.shooter]) + 10, 25, o_gui_unit); u.unitID = units.energyGenerator; u.sprite_index = unitSprite[u.unitID];</span></span></code> </pre><br><br>  A lot of code and part of it is clearly superfluous, but it looks great and for educational purposes only. <br>  enum is a key word.  With its help, we simply create a global array, the elements of which can be addressed in units.shooter, which will give us 0 - this is the value of this variable.  Next we declare a custom array with prices for units.  It would be possible not to use enum, then these 2 lines would look like this: <br><br><pre> <code class="cs hljs">unitCost[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">50</span></span>; unitCost[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">25</span></span>;</code> </pre><br><br>  But then look for or remember what kind of unit 0 is, and what unit 1 can be difficult and lazy. <br><br>  Next, we create, relatively speaking, buttons (more precisely, an o_gui_unit object) and set them with some properties. <br>  Previously, we set the sprite to the object via the Game Maker interface, but this can be done manually via sprite_index.  What we actually did. <br><br>  Now, since we have the prices for objects and there is some sort of GUI, with which we can choose which unit we need to install, it‚Äôs time to change the Global Left Released code to <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> place user unit if (!isPlaceUnitClick){ isPlaceUnitClick = true; exit; } var tBgWidth = background_get_width(bg_grass); var tBgHeight = background_get_height(bg_grass); var iX = mouse_x - mouse_x % tBgWidth + tBgWidth/2; var iY = mouse_y - mouse_y % tBgHeight + tBgHeight/2; if (instance_position(iX, iY, o_unit_parent) != noone){ exit; } var currID = -1; with(o_gui_unit){ if (isActivated){ currID = unitID; break; } } if (pEnergy &gt;= unitCost[currID]){ pEnergy -= unitCost[currID]; switch (currID) { case units.shooter: instance_create(iX, iY, o_unit_shooter); break; case units.energyGenerator: instance_create(iX, iY, o_unit_energy_generator); break; } }</span></span></code> </pre><br><br>  In the first check we look at this click on the field, or on our newly created GUI - i.e.  when you click on the object o_gui_unit.  The next 8 lines are familiar to us from the last episode, and then we analyze. <br><br>  In the loop with we go through all instances of the object o_gui_unit and see which of them is currently active.  As soon as we come across an active one, we write the unitID value of this instance into the currID variable.  unitID we need to know the price and what object we will put.  In the next test, we look at whether the player has enough energy to buy this unit, if enough - remove the appropriate amount of energy and see what kind of unit you need to put.  Everything is as always simple. <br><br>  If you, like me, can't wait to check what happened, we launch it and, strangely enough, it works.  And I wanted to talk about debugging. <br><br>  In the future, I will have to resort to the method ‚ÄúHow to draw an owl‚Äù, because there will be nothing new from the theory, and if you paint the elementary things a series of these publications will be delayed for a long time.  The Github code will be available, so I will only focus on new things, if you don't mind. <br><br>  It would be nice to make lawn mowers as in the original, which are triggered by the approach of zombies to them.  After that, they start moving in a straight line, destroying all enemies in their path.  Lawn mowers are not eternal, after the first operation disappear.  There is nothing new in the theory of lawn mowers.  Implement yourself and check.  The logic will be as follows: we add a collision event with o_enemy_parent to the lawn-mower and add a code that starts moving our lawn-mower to the right and destroys the instance with which it has a collision.  You also need to remember to set the check for going beyond the screen (in the object itself) and automatically arrange in o_game from. <br><br>  It's time to get to know Timeline.  This concept is similar to the familiar alarm'y, but act as separate entities.  Timelines allow you to execute code at certain steps (frames) you specify.  Not the most frequently used feature in Game Maker, but suitable for some purposes.  It is not very easy to work with them in the current version of Game Maker - it is difficult to select the desired step, it takes time.  For convenience, you need to invent your own crutch - write a system to create a level directly from the game.  But since the crutch for each game is different, there is nothing to blame the creators of Game Maker.  In the case of this particular game, I would do something like this - we create a hotel room where you can arrange enemies.  Then, relative to their x-coordinates on the screen, generate a code for the timeline.  We will calculate the y-coordinate later (or random).  This is really quite fast though it is more correct to write your own full-fledged level editor. <br><br>  In order to learn, we will generate the generation of enemies in the game in waves through the Timeline.  We will need a main timeline that will trigger the waves.  Probably, it will be necessary to make each level a separate timeline. <br>  Create an empty timeline, call it tl_level0 and click on the Add button.  Enter the desired step, for example, 120, and confirm.  Next we are given the opportunity to use all the same features as inside any event of any object.  In the code, you will need to create enemies, so as not to duplicate the creation code, we will use scripts.  For example, we add to the event steps 120, 240, 600, 1200 code - scr_generate_enemy_wave (3) ;.  And for the next few steps (waves), we will pass a larger number as an argument. <br><br>  A new moment, above, we used a function that takes no arguments, this time we will try something new.  In this line, we pass the number 3 to the script. The script itself will look like this: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> scr_generate_enemy_wave(maxEnem); var maxEnem = argument0; var enCount = 1 + irandom(maxEnem); while(--enCount &gt;= 0){ var tBgHeight = background_get_height(bg_grass); var cycleCnt = 0; var eY, eX = room_width + sprite_get_width(spr_enemy_zombie)/2 + 1; do{ if (++cycleCnt &gt; 200) break; eY = irandom(room_height - room_height % tBgHeight); eY = eY - eY % tBgHeight + tBgHeight/2; }until(instance_position(eX, eY, o_enemy_parent) == noone) instance_create(eX, eY, o_enemy_zombie); show_debug_message("enemy created"); }</span></span></code> </pre><br><br>   ,   ///    ,    ,               ,    . <br><br>  var maxEnem = argument0;       0,   . argument0, argument1, argument2  .. ‚Äî    .  Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calling scr_generate_enemy_wave (3); we put 3 in the argument0 variable. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then we just put the enemy on the playing field, after checking whether there is already a unit under it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Do you know?] </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Game Maker, there is no way not to pass an argument if it is used in the script. If you forget - nothing terrible, Game Maker will not compile the game and remind you where you forgot to pass the argument. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notice the show_debug_message ("enemy created") ;? This is the most primitive, but most commonly used debugging method. This standard feature allows you to display a message in the Game Maker console. The string that you passed to this function will be displayed. In our case it will be - ‚Äúenemy created‚Äù. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Do you know?]</font></font><br><br>   Game Maker' ,    -   show_debug_message ,        ,       .  -    GM       show_debug_message   -       - .    ,       . <br><br>       Game Maker  ,     timeline'.    Create  o_game  alarm[2] = room_speed * 6;// set timeline for enemy generation <br><br>   Alarm 2   : <br><br><pre> <code class="cs hljs">timeline_index = tl_level0; timeline_position = <span class="hljs-number"><span class="hljs-number">0</span></span>; timeline_running = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre><br><br>     ‚Äî tl_level0,    0( 0)  .    ,   ,     (),      .  Game Maker  ,    ,     ¬´¬ª    ,          . <br><br>      ,    .      show_debug_message,          get_timer();     .       Game Maker.     1.4,       .    . <br><br><div style="text-align:center;"><img src="//habrastorage.org/files/0d9/a45/461/0d9a45461b2742d5ba7e77e92dffde6c.png" width="720"></div><br><br>         .    , ,    ,    ..     F6.   ,  ‚Äî         . <br><br>       /.    show_debug_overlay       CPU/GPU.      ( Draw),     ,    ,          ,      . <br><br>        show_error   .          (   ,       / )      . <br><br>  ,  YoYoGames(  Game Maker)   ,              show_debug_message    get_timer   . <br><br>     GraphicRiver,     .       (      ),          - .     OpenGameArt.          . <br><br>   (  <a href="http://opengameart.org/content/zombie-and-skeleton-32x48">_1_</a> , <a href="http://opengameart.org/content/lpc-forest-tiles">_2_</a> ),       .        , .    ,    ,  Edit Sprite -&gt; File -&gt; Create from Stip.     ,      . <br><br><div style="text-align:center;"><img src="//habrastorage.org/files/a0c/742/192/a0c7421924054fa19205b13852acb091.png"></div><br><br>        .     64   (Edit -&gt; Transform -&gt; Stretch).  ,     Game Maker    ,  . <br><br>     ,     ,      .  ,       ‚Äî 1   .    .   Create     : image_speed = 0.2;       5 . <br><br>   Game Maker   SWF  Spine .  ,      Spine-      . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, in the end we will add another unit in order to learn a little more about the frequently used features of Game Maker. You can find it on Github, it is called o_enemy_zombie_fast. It has some interesting points. Consider the Step event:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isActive){ with(o_unit_parent){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance_to_point(other.x, other.y) &lt;= <span class="hljs-number"><span class="hljs-number">220</span></span>){ other.cHspeed = other.cHspeed2; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } event_inherited();</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first thing that catches your eye is that the event_inherited function can be called anywhere in the code, not necessarily at the beginning. Sometimes it is very useful. And one more thing specifically in this case is controversial by the criterion of optimality, but nevertheless this function is very useful - distance_to_point. It calculates the distance between (x; y) of the object that caused it and some point, the coordinates of which we transmit. The distance_to_object function is also useful, it calculates the distance between (x; y) of your object and the nearest instance of the object passed in the parameters. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, Game Maker has already prepared a lot of standard useful functions that save time on writing your own code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, the game gradually takes the desired form. It will now look something like this:</font></font><br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/Qgn6p3H3iuQ%3Ffeature%3Doembed&amp;xid=17259,15700002,15700021,15700186,15700190,15700248,15700253&amp;usg=ALkJrhh1gHeqsYKnImRl0UTZY6i1J8XY4g" frameborder="0" allowfullscreen=""></iframe><br><br>    2 ,     70% ,         Game Maker.  ,        ,    . <br><br>    : <br><br> ‚Äî     <br> ‚Äî    <br> ‚Äî    <br> ‚Äî    <br> ‚Äî  / <br> ‚Äî              <br> ‚Äî    View <br><br>   <a href="https://github.com/uraddo/pvzhabr">Github</a> <br><br><div class="spoiler"> <b class="spoiler_title">  Game Maker     ,          </b> <div class="spoiler_text"> ‚Äî   Google Play Services, Game Circle(Amazon)  Game Center (  ) <br> ‚Äî   -    <br> ‚Äî  Facebook API <br> ‚Äî    Game Maker <br> ‚Äî   Box2D <br> ‚Äî  <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/257123/">https://habr.com/ru/post/257123/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../257113/index.html">Writing a system of invitations (invitations) for your Meteor application</a></li>
<li><a href="../257115/index.html">Simple control of arduino via the Internet</a></li>
<li><a href="../257117/index.html">Lab penetration testing "Test lab v.7" is open</a></li>
<li><a href="../257119/index.html">Lectures of the Technosphere. Semester 2 Modern methods and tools for building information retrieval systems</a></li>
<li><a href="../257121/index.html">Image and video analysis. Image segmentation</a></li>
<li><a href="../257125/index.html">How to earn points without even starting the game</a></li>
<li><a href="../257127/index.html">Microsoft showed Project Astoria: what it will look like using Android code in Windows applications</a></li>
<li><a href="../257129/index.html">Creating plug-ins for AutoCAD using the .NET API (part 4 - inserting primitive objects)</a></li>
<li><a href="../257131/index.html">WS2812B protocol on STM32 without empty loops and interrupts. And how to make the right rainbow</a></li>
<li><a href="../257133/index.html">Beeline automatically adds a Mail.Ru search toolbar.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>