<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a web application on Go in 2017. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Content 

1. Part 1 
2. Part 2 
3. Part 3 
4. Part 4 


 So, our application will have two main parts: client and server. (What is the year now?). The...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a web application on Go in 2017. Part 2</h1><div class="post__text post__text-html js-mediator-article"><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text"><ol><li>  <a href="https://habrahabr.ru/post/329582/">Part 1</a> </li><li>  <strong>Part 2</strong> </li><li>  <a href="https://habrahabr.ru/post/329612/">Part 3</a> </li><li>  <a href="https://habrahabr.ru/post/329622/">Part 4</a> </li></ol></div></div><br><p>  So, our application will have two main parts: client and server.  (What is the year now?).  The server part will be on Go, and the client part will be on JS.  Let's first talk about the server side. </p><a name="habracut"></a><br><h2 id="go-server">  Go (server) </h2><br><p>  The server part of our application will be responsible for the initial maintenance of everything necessary for JavaScript and everything else, such as static files and data in JSON format.  This is all, only two functionalities: (1) static and (2) JSON. </p><br><p>  It is worth noting that static maintenance is optional: statics can be served in a CDN, for example.  But the important thing is that this is not a problem for our Go application - unlike the Python / Ruby application, it can work on a par with Ngnix and Apache serving static.  Delegating the distribution of static files to some other application is not particularly required to ease the load, although it makes sense in some situations. </p><br><p>  For simplicity, let's imagine that we are creating an application that serves a list of people (only first and last names), stored in database tables, and that's it.  The code is here - <a href="https://github.com/grisha/gowebapp">https://github.com/grisha/gowebapp</a> . </p><br><h3 id="struktura-katalogov">  Directory structure </h3><br><p>  As my experience shows, separating the functionality between packages at an early stage is a good idea in Go.  Even if it is not entirely clear how the final version will be structured, it‚Äôs best to keep everything in its unfolded state whenever possible. </p><br><p>  For a web application, in my opinion, this layout makes sense: </p><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># github.com/user/foo foo/ # package main | +--daemon/ # package daemon | +--model/ # package model | +--ui/ # package ui | +--db/ # package db | +--assets/ #    JS   </span></span></code> </pre> <br><h3 id="verhniy-uroven-paket-main">  Top level: <code>main</code> package </h3><br><p>  At the top level, we have the <code>main</code> package, and its code is in the <code>main.go</code> file.  The main advantage is that in this situation <code>go get github.com/user/foo</code> is the only command required to install the entire application in <code>$GOPATH/bin</code> . </p><br><p>  The <code>main</code> package should be as minimal as possible.  The only code that is here is the analysis of the arguments of the command.  If the application had a configuration file, I would place the parsing and verification of this file into another package, which would most likely call the <code>config</code> .  After this, <code>main</code> should transfer control to the <code>daemon</code> package. </p><br><p>  Here is the basis of <code>main.go</code> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/user/foo/daemon"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> assetsPath <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processFlags</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">daemon</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Config</span></span></span></span> { cfg := &amp;daemon.Config{} flag.StringVar(&amp;cfg.ListenSpec, <span class="hljs-string"><span class="hljs-string">"listen"</span></span>, <span class="hljs-string"><span class="hljs-string">"localhost:3000"</span></span>, <span class="hljs-string"><span class="hljs-string">"HTTP listen spec"</span></span>) flag.StringVar(&amp;cfg.Db.ConnectString, <span class="hljs-string"><span class="hljs-string">"db-connect"</span></span>, <span class="hljs-string"><span class="hljs-string">"host=/var/run/postgresql dbname=gowebapp sslmode=disable"</span></span>, <span class="hljs-string"><span class="hljs-string">"DB Connect String"</span></span>) flag.StringVar(&amp;assetsPath, <span class="hljs-string"><span class="hljs-string">"assets-path"</span></span>, <span class="hljs-string"><span class="hljs-string">"assets"</span></span>, <span class="hljs-string"><span class="hljs-string">"Path to assets dir"</span></span>) flag.Parse() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cfg } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupHttpAssets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cfg *daemon.Config)</span></span></span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"Assets served from %q."</span></span>, assetsPath) cfg.UI.Assets = http.Dir(assetsPath) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { cfg := processFlags() setupHttpAssets(cfg) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := daemon.Run(cfg); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"Error in main(): %v"</span></span>, err) } }</code> </pre> <br><p>  The following code takes three parameters: <code>-listen</code> , <code>-db-connect</code> and <code>-assets-path</code> , nothing special. </p><br><h4 id="ispolzovanie-struktur-dlya-yasnosti">  Using structures for clarity </h4><br><p>  In the <code>cfg := &amp;daemon.Config{}</code> we create a <code>daemon.Config</code> object.  Its main purpose is to present the configuration in a structured and understandable format.  Each of our packages defines its own <code>Config</code> type, which describes the parameters it needs, and which may include settings for other packages.  We see an example of this in the <code>processFlags()</code> above: <code>flag.StringVar(&amp;cfg.Db.ConnectString, ...</code> Here <code>db.Config</code> included in <code>daemon.Config</code> . In my opinion, this is a very useful technique. Using structures also leaves the possibility of serializing settings in the form of JSON, TOML or something else. </p><br><h4 id="ispolzovanie-httpfilesystem-dlya-obsluzhivaniya-statiki">  Using http.FileSystem to maintain statics </h4><br><p>  <code>http.Dir(assetsPath)</code> in <code>setupHttpAssets</code> is a preparation for how we will serve statics in the <code>ui</code> package.  This is done in such a way as to leave the possibility for another implementation of <code>cfg.UI.Assets</code> (which is the <code>http.FileSystem</code> interface), for example, to give this content from RAM.  I will talk about this in more detail later, in a separate post. </p><br><p>  In the end, <code>main</code> calls <code>daemon.Run(cfg)</code> , which actually starts our application and blocks until the end of the work. </p><br><h3 id="paket-daemon">  Package <code>daemon</code> </h3><br><p>  The <code>daemon</code> package contains everything related to running the process.  This includes, for example, which port will be tapped, a user log will be defined here, as well as everything related to a polite restart, etc. </p><br><p>  Since the task of the <code>daemon</code> package is to initialize the connection to the database, it needs to import the <code>db</code> package.  He is also responsible for listening to the TCP port and launching the user interface for this listener, so he needs to import the <code>ui</code> package, and since the <code>ui</code> package needs to have access to the data provided by the <code>model</code> package, it also needs to import the <code>model</code> package. </p><br><p>  The <code>daemon</code> module skeleton looks like this: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> daemon <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> <span class="hljs-string"><span class="hljs-string">"os/signal"</span></span> <span class="hljs-string"><span class="hljs-string">"syscall"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/grisha/gowebapp/db"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/grisha/gowebapp/model"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/grisha/gowebapp/ui"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Config <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ListenSpec <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Db db.Config UI ui.Config } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cfg *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"Starting, HTTP on: %s\n"</span></span>, cfg.ListenSpec) db, err := db.InitDb(cfg.Db) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"Error initializing database: %v\n"</span></span>, err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } m := model.New(db) l, err := net.Listen(<span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, cfg.ListenSpec) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"Error creating listener: %v\n"</span></span>, err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } ui.Start(cfg.UI, m, l) waitForSignal() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waitForSignal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ch := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> os.Signal) signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM) s := &lt;-ch log.Printf(<span class="hljs-string"><span class="hljs-string">"Got signal: %v, exiting."</span></span>, s) }</code> </pre> <br><p>  Note that <code>Config</code> includes <code>db.Config</code> and <code>ui.Config</code> , as I mentioned. </p><br><p>  All action takes place in <code>Run(*Config)</code> .  We initialize the connection to the database, create an instance of <code>model.Model</code> and run <code>ui</code> , passing it the settings, pointers to the model and the listener. </p><br><h3 id="paket-model">  Package <code>model</code> </h3><br><p>  The purpose of the <code>model</code> is to separate how the data is stored in the database from the <code>ui</code> , as well as to provide the business logic that the application can have.  This is the brain of your application, if you like. </p><br><p>  The <code>model</code> package must define a structure ( <code>Model</code> looks like a suitable name), and a pointer to an instance of this structure must be passed to all functions and methods <code>ui</code> .  In our application, there should be only one such instance - for additional confidence, you can implement this programmatically using a singleton, but I do not think that this is so necessary. </p><br><p>  Alternatively, you can do without the <code>Model</code> structure and simply use the <code>model</code> package itself.  I do not like this approach, however this is an option. </p><br><p>  The model must also define structures for the data entities with which we are dealing.  In our example, this will be the <code>Person</code> structure.  Its members must be exported (named with a capital letter), because other packages will access them.  If you use <a href="https://github.com/jmoiron/sqlx">sqlx</a> , here you must specify the tags that bind the elements of the structure to the names of the columns in the database, for example, <code>db:"first_name"</code> . </p><br><p>  Our <code>Person</code> Type: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Person <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Id <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> First, Last <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br><p>  Here we do not need tags, because the names of the columns correspond to the names of the elements of the structure, and <code>sqlx</code> takes care of the register so that <code>Last</code> corresponds to the column with the name <code>last</code> . </p><br><h4 id="paket-model-ne-dolzhen-importirovat-db">  The <code>model</code> package should NOT import <code>db</code> </h4><br><p>  Somewhat counterintuitively, <code>model</code> should not import <code>db</code> .  But it should not because the <code>db</code> package needs to import the <code>model</code> , and cyclical imports are prohibited in Go.  This is the case when interfaces come in handy.  <code>model</code> must specify an interface that <code>db</code> should satisfy.  So far we only know that we need a list of people, so we can start with this definition: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> db <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { SelectPeople() ([]*Person, error) }</code> </pre> <br><p>  Our application does not do much, but we know that it lists people, so our model, most likely, should have the <code>People() ([]*Person, error)</code> method <code>People() ([]*Person, error)</code> : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *Model)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">People</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]*Person, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.SelectPeople() }</code> </pre> <br><p>  For everything to be neat, it is better to place the code in different files, for example, the <code>Person</code> structure must be defined in <code>person.go</code> , etc.  But for readability, here is the single-file version of our <code>model</code> package: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> model <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> db <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { SelectPeople() ([]*Person, error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Model <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { db } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(db db)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Model</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;Model{ db: db, } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *Model)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">People</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]*Person, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.SelectPeople() } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Person <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Id <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> First, Last <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br><h3 id="paket-db">  <code>db</code> package </h3><br><p>  <code>db</code> is the actual implementation of the interaction with the database.  This is where SQL statements are constructed and executed.  This package also imports <code>model</code> , p.ch.  he will need to create these structures from the database data. </p><br><p>  First of all, <code>db</code> should provide the <code>InitDB</code> function, which will establish a connection to the database, as well as create the necessary tables and prepare SQL queries. </p><br><p>  Our simplified example does not support migrations, but, theoretically, this is where they should be performed. </p><br><p>  We use PostgreSQL, which means we need to import the <a href="https://github.com/lib/pq">pq</a> driver.  We will also rely on <code>sqlx</code> and we need our <code>model</code> .  Here is the beginning of the implementation of our <code>db</code> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> db <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"database/sql"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/grisha/gowebapp/model"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/jmoiron/sqlx"</span></span> _ <span class="hljs-string"><span class="hljs-string">"github.com/lib/pq"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Config <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ConnectString <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitDb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cfg Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*pgDb, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dbConn, err := sqlx.Connect(<span class="hljs-string"><span class="hljs-string">"postgres"</span></span>, cfg.ConnectString); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { p := &amp;pgDb{dbConn: dbConn} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := p.dbConn.Ping(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := p.createTablesIfNotExist(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := p.prepareSqlStatements(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br><p>  The exported <code>InitDb()</code> function creates an instance of <code>pgDb</code> , which is the Postgres implementation of our <code>model.db</code> interface.  It contains everything you need to communicate with the database, including prepared queries, and implements the methods necessary for the interface. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> pgDb <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { dbConn *sqlx.DB sqlSelectPeople *sqlx.Stmt }</code> </pre> <br><p>  Below is the code for creating tables and preparing queries.  From the point of view of SQL, everything is rather simplistic and, of course, there is room for improvement: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *pgDb)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTablesIfNotExist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { create_sql := <span class="hljs-string"><span class="hljs-string">` CREATE TABLE IF NOT EXISTS people ( id SERIAL NOT NULL PRIMARY KEY, first TEXT NOT NULL, last TEXT NOT NULL); `</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> rows, err := p.dbConn.Query(create_sql); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rows.Close() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *pgDb)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareSqlStatements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p.sqlSelectPeople, err = p.dbConn.Preparex( <span class="hljs-string"><span class="hljs-string">"SELECT id, first, last FROM people"</span></span>, ); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  Finally, we need to provide a method that implements the interface: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *pgDb)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectPeople</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]*model.Person, error)</span></span></span></span> { people := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]*model.Person, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := p.sqlSelectPeople.Select(&amp;people); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> people, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  Here we take advantage of <code>sqlx</code> to execute the query and build a slice from the results, simply by calling <code>Select()</code> (Note: <code>p.sqlSelectPeople</code> is of type <code>*sqlx.Stmt</code> ).  Without <code>sqlx</code> we would have to iterate through the rows of the result, processing each with the help of <code>Scan</code> , which would be more verbose. </p><br><p>  Beware of one very subtle point.  <code>people</code> could be defined as <code>var people []*model.Person</code> and the method would work the same way.  However, if the database returns an empty rowset, the method returns <code>nil</code> , rather than an empty slice.  If the result of this method is later encoded in JSON, then it will become <code>null</code> , not <code>[]</code> .  This can cause problems if the client side does not know how to handle <code>null</code> . </p><br><p>  That's all for <code>db</code> . </p><br><h3 id="paket-ui">  <code>ui</code> package </h3><br><p>  In the end, we need to serve all of this via HTTP, and this is exactly what <code>ui</code> does. </p><br><p>  Here is a very simplified version: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ui <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"net"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/grisha/gowebapp/model"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Config <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Assets http.FileSystem } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cfg Config, m *model.Model, listener net.Listener)</span></span></span></span> { server := &amp;http.Server{ ReadTimeout: <span class="hljs-number"><span class="hljs-number">60</span></span> * time.Second, WriteTimeout: <span class="hljs-number"><span class="hljs-number">60</span></span> * time.Second, MaxHeaderBytes: <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>} http.Handle(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, indexHandler(m)) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> server.Serve(listener) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> indexHTML = <span class="hljs-string"><span class="hljs-string">` &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Simple Go Web App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='root'&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; `</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">indexHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *model.Model)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.HandlerFunc(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintf(w, indexHTML) }) }</code> </pre> <br><p>  Note that <code>indexHTML</code> almost nothing.  This is almost 100% all the HTML that our application will use.  It will change a little when we proceed to the client side of the application, just a few lines. </p><br><p>  Also note how the handler is defined.  If this idiom is not familiar to you, it is worth spending a few minutes (or a day) to absorb it completely, since it is very common in Go.  <code>indexHandler()</code> is not the handler itself, it <em>returns</em> a handler function.  This is done this way so that we can pass <code>*model.Model</code> through the closure, since the signature of the HTTP handler function is fixed and the pointer to the model is not one of its parameters. </p><br><p>  While we in <code>indexHandler()</code> do nothing with the pointer to the model, but when we get to the actual implementation of the list of people, we need it. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  The above is, in fact, everything you need to know to create a basic web application on Go, at least from Go.  In the next article I will deal with the client part and we will complete the code of the list of people. </p><br><p>  <a href="https://habrahabr.ru/post/329612/">Continuation</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/329584/">https://habr.com/ru/post/329584/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329574/index.html">Smart IDReader SDK - how to add recognition in an iOS application in 5 minutes - now on Github</a></li>
<li><a href="../329576/index.html">Modeling designs. Requirements for the modeler</a></li>
<li><a href="../329578/index.html">Three cycles in the Lorenz attractor</a></li>
<li><a href="../329580/index.html">What is waiting for us in Swift 4?</a></li>
<li><a href="../329582/index.html">Creating a web application on Go in 2017</a></li>
<li><a href="../329592/index.html">learnopengl. Lesson 2.1 - Colors</a></li>
<li><a href="../329594/index.html">Is there too much text in your game?</a></li>
<li><a href="../329596/index.html">A bit of reverse-engineering USB flash on the SK6211 controller</a></li>
<li><a href="../329598/index.html">Online course "Functional Security of Computer Systems"</a></li>
<li><a href="../329600/index.html">How to use implicits in Scala and keep sanity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>