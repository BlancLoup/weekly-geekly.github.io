<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compilation. 4: toy yap</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With grammar calculators have played enough, go to the programming languages. Beta testers of the article gave the idea to write a JavaScript-like lan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compilation. 4: toy yap</h1><div class="post__text post__text-html js-mediator-article">  With grammar calculators have played enough, go to the programming languages.  Beta testers of the article gave the idea to write a JavaScript-like language: let's start with the simplest staple skeleton, and we will gradually turn it into twists - syntax sugar, data types, support for functions, etc. <br><br>  To the inferiority of our language was already clear from the name, let's call it JSkrip. <br><br><h3>  Further in the post </h3><br><ol><li>  Syntax </li><li>  Grammar </li><li>  Parser </li><li>  Syntax tree </li><li>  Pretty-printing </li></ol><br><a name="habracut"></a><br><h3>  Syntax </h3><br>  In the initial version of the language will be arithmetic constructions over integers, <code>if</code> , <code>while</code> , and <code>exit</code> ;  and a pair of "predefined functions": <code>echo()</code> for printing, and <code>input()</code> for input. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <code>from = 0; to = 1000; <br> echo( <font color="#ff6060">"   "</font> ,from, <font color="#ff6060">"  "</font> ,to, <font color="#ff6060">",    </font> <font color="#ff40ff">\n</font> <font color="#ff6060">"</font> ); <br> <font color="#808000">while</font> (from &lt;= to) <font color="#7f9fbf">{</font> <br> guess = (from+to)/2; <br> echo( <font color="#ff6060">" "</font> ,guess, <font color="#ff6060">"?  (1=, 2=, 3=) "</font> ); <br> i = input(); <br> <font color="#808000">if</font> (i==1) <br> to = guess-1; <br> <font color="#808000">else</font> <font color="#808000">if</font> (i==2) <br> from = guess+1; <br> <font color="#808000">else</font> <font color="#808000">if</font> (i==3) <font color="#7f9fbf">{</font> <br> echo( <font color="#ff6060">"!  !</font> <font color="#ff40ff">\n</font> <font color="#ff6060">"</font> ); <br> exit; <br> <font color="#7f9fbf">}</font> <font color="#808000">else</font> <br> echo( <font color="#ff6060">"   !</font> <font color="#ff40ff">\n</font> <font color="#ff6060">"</font> ); <br> <font color="#7f9fbf">}</font> <br> echo( <font color="#ff6060">",   !</font> <font color="#ff40ff">\n</font> <font color="#ff6060">"</font> ); <br></code> <br><br><h3>  Grammar </h3><br>  We look at the sample program, and try to formalize the language: <br><br> <code><font color="#7f9fbf">PROGRAM:</font> OPS ; <font color="#8080ff">//  </font> <br> <font color="#7f9fbf">OPS:</font> OP | OPS OP ; <br> <font color="#7f9fbf">OP:</font> <font color="#ff6060">'{'</font> OPS <font color="#ff6060">'}'</font> <font color="#8080ff">// </font> <br> <font color="#7f9fbf">|</font> EXPR <font color="#ff6060">';'</font> <font color="#8080ff">// </font> <br> <font color="#7f9fbf">|</font> ' <font color="#808000">if</font> <font color="#ff6060">' '</font> (' EXPR <font color="#ff6060">')'</font> OP <br> <font color="#7f9fbf">|</font> ' <font color="#808000">if</font> <font color="#ff6060">' '</font> (' EXPR <font color="#ff6060">')'</font> OP ' <font color="#808000">else</font> ' OP <br> <font color="#7f9fbf">|</font> ' <font color="#808000">while</font> <font color="#ff6060">' '</font> (' EXPR <font color="#ff6060">')'</font> OP <br> <font color="#7f9fbf">|</font> 'exit <font color="#ff6060">' '</font> ;' ; <br> <font color="#7f9fbf">EXPR:</font> NUM <font color="#8080ff">// </font> <br> <font color="#7f9fbf">|</font> ID <font color="#8080ff">// </font> <br> <font color="#7f9fbf">|</font> ID <font color="#ff6060">'('</font> ARGS <font color="#ff6060">')'</font> <font color="#8080ff">//  </font> <br> <font color="#7f9fbf">|</font> EXPR <font color="#ff6060">'+'</font> EXPR | EXPR <font color="#ff6060">'-'</font> EXPR | EXPR <font color="#ff6060">'*'</font> EXPR | EXPR <font color="#ff6060">'/'</font> EXPR | <font color="#ff6060">'('</font> EXPR <font color="#ff6060">')'</font> | <font color="#ff6060">'-'</font> EXPR <font color="#8080ff">// </font> <br> <font color="#7f9fbf">|</font> EXPR '==' EXPR | EXPR ' <font color="#808000">&lt;</font> =' EXPR | EXPR ' <font color="#808000">&gt;</font> =' EXPR | EXPR '!=' EXPR | EXPR <font color="#ff6060">'&gt;'</font> EXPR | EXPR <font color="#ff6060">'&lt;'</font> EXPR <br> <font color="#7f9fbf">|</font> <font color="#ff6060">'!'</font> EXPR <font color="#8080ff">//      ;  &amp;&amp;  *,   ||  +</font> <br> <font color="#7f9fbf">|</font> ID <font color="#ff6060">'='</font> EXPR ; <font color="#8080ff">// </font> <br> <font color="#7f9fbf">ARGS:</font> <font color="#8080ff">//  </font> <br> <font color="#7f9fbf">|</font> ARG <font color="#8080ff">//  </font> <br> <font color="#7f9fbf">|</font> ARGS <font color="#ff6060">','</font> ARG ; <br> <font color="#7f9fbf">ARG:</font> EXPR | STRING ; <font color="#8080ff">//     </font> <br></code> <br><br>  We come across already familiar ambiguities: with <code>else</code> , and with a group of operators in the expression.  We already know how to <a href="http://habrahabr.ru/blogs/programming/99298/">fix the grammar</a> : <br><br> <code><font color="#7f9fbf">PROGRAM:</font> OPS ; <br> <font color="#7f9fbf">OPS:</font> OP | OPS OP ; <br> <font color="#8080ff">// ,     else  </font> <br> <font color="#7f9fbf"><b>OP1</b> :</font> <font color="#ff6060">'{'</font> OPS <font color="#ff6060">'}'</font> | EXPR <font color="#ff6060">';'</font> <br> <font color="#7f9fbf">|</font> ' <font color="#808000">if</font> <font color="#ff6060">' '</font> (' EXPR <font color="#ff6060">')'</font> <b>OP1</b> ' <font color="#808000">else</font> ' <b>OP1</b> <font color="#8080ff">// if  else:     if  else</font> <br> <font color="#7f9fbf">|</font> ' <font color="#808000">while</font> <font color="#ff6060">' '</font> (' EXPR <font color="#ff6060">')'</font> <b>OP1</b> <br> <font color="#7f9fbf">|</font> 'exit <font color="#ff6060">' '</font> ;' ; <br> <font color="#8080ff">// ,   if  else</font> <br> <font color="#7f9fbf"><b>OP2</b> :</font> ' <font color="#808000">if</font> <font color="#ff6060">' '</font> (' EXPR <font color="#ff6060">')'</font> OP <font color="#8080ff">// if  else:    </font> <br> <font color="#7f9fbf">|</font> IF <font color="#ff6060">'('</font> EXPR <font color="#ff6060">')'</font> <b>OP1</b> ELSE <b>OP2</b> <br> <font color="#7f9fbf">|</font> WHILE <font color="#ff6060">'('</font> EXPR <font color="#ff6060">')'</font> <b>OP2</b> ; <br> <b><font color="#7f9fbf">OP:</font> OP1 | OP2 ;</b> <br> <font color="#7f9fbf">EXPR:</font> <b>EXPR1</b> | ID <font color="#ff6060">'='</font> EXPR ; <font color="#8080ff">//     </font> <br> <font color="#8080ff">//   ,   </font> <br> <font color="#7f9fbf"><b>EXPR1</b> :</font> <b>EXPR2</b> <br> <font color="#7f9fbf">|</font> <b>EXPR1</b> '==' <b>EXPR2</b> | <b>EXPR1</b> ' <font color="#808000">&lt;</font> =' <b>EXPR2</b> | <b>EXPR1</b> ' <font color="#808000">&gt;</font> =' <b>EXPR2</b> <br> <font color="#7f9fbf">|</font> <b>EXPR1</b> '!=' <b>EXPR2</b> | <b>EXPR1</b> <font color="#ff6060">'&gt;'</font> <b>EXPR2</b> | <b>EXPR1</b> <font color="#ff6060">'&lt;'</font> <b>EXPR2</b> ; <br> <font color="#7f9fbf"><b>EXPR2</b> :</font> <b>TERM</b> | <b>EXPR2</b> <font color="#ff6060">'+'</font> <b>TERM</b> | <b>EXPR2</b> <font color="#ff6060">'-'</font> <b>TERM</b> ; <br> <font color="#7f9fbf"><b>TERM</b> :</font> <b>VAL</b> | <b>TERM</b> <font color="#ff6060">'*'</font> <b>VAL</b> | <b>TERM</b> <font color="#ff6060">'/'</font> <b>VAL</b> ; <br> <font color="#7f9fbf"><b>VAL</b> :</font> NUM | <font color="#ff6060">'-'</font> <b>VAL</b> | <font color="#ff6060">'!'</font> <b>VAL</b> | <font color="#ff6060">'('</font> EXPR <font color="#ff6060">')'</font> | ID | ID <font color="#ff6060">'('</font> ARGS <font color="#ff6060">')'</font> ; <br> <font color="#7f9fbf">ARGS:</font> | ARG | ARGS <font color="#ff6060">','</font> ARG ; <br> <font color="#7f9fbf">ARG:</font> EXPR | STRING ; <br></code> <br><br><h3>  Parser </h3><br>  It is enough to add the usual <a href="http://habrahabr.ru/blogs/programming/99366/">bison</a> heading to turn the grammar into a dummy parser: <br><br> <code><font color="#ff40ff">%{</font> <br> <font color="#ff40ff">#include</font> <font color="#ff6060">&lt;iostream&gt;</font> <br> <font color="#008000">extern</font> <font color="#008000">int</font> yylineno; <br> <font color="#008000">extern</font> <font color="#008000">int</font> yylex(); <br> <font color="#008000">void</font> yyerror( <font color="#008000">char</font> *s) <font color="#ff40ff">{</font> <br> std::cerr <font color="#808000">&lt;&lt;</font> s <font color="#808000">&lt;&lt;</font> <font color="#ff6060">", line "</font> <font color="#808000">&lt;&lt;</font> yylineno <font color="#808000">&lt;&lt;</font> std::endl; <br> exit( <font color="#ff6060">1</font> ); <br> <font color="#ff40ff">}</font> <br> <font color="#ff40ff">#define YYSTYPE std::string</font> <br> <font color="#ff40ff">%}</font> <br> <br> <font color="#808000">%token</font> IF ELSE WHILE EXIT <br> <font color="#808000">%token</font> EQ LE GE NE <br> <font color="#808000">%token</font> STRING NUM ID <br> <br> <font color="#808080">%%</font> <br> <br> <font color="#7f9fbf">PROGRAM:</font> OPS <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">OPS:</font> OP <br> <font color="#7f9fbf">|</font> OPS OP <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">OP1:</font> <font color="#ff6060">'{'</font> OPS <font color="#ff6060">'}'</font> <br> <font color="#7f9fbf">|</font> EXPR <font color="#ff6060">';'</font> <br> <font color="#7f9fbf">|</font> IF <font color="#ff6060">'('</font> EXPR <font color="#ff6060">')'</font> OP1 ELSE OP1 <br> <font color="#7f9fbf">|</font> WHILE <font color="#ff6060">'('</font> EXPR <font color="#ff6060">')'</font> OP1 <br> <font color="#7f9fbf">|</font> EXIT <font color="#ff6060">';'</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">OP2:</font> IF <font color="#ff6060">'('</font> EXPR <font color="#ff6060">')'</font> OP <br> <font color="#7f9fbf">|</font> IF <font color="#ff6060">'('</font> EXPR <font color="#ff6060">')'</font> OP1 ELSE OP2 <br> <font color="#7f9fbf">|</font> WHILE <font color="#ff6060">'('</font> EXPR <font color="#ff6060">')'</font> OP2 <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">OP:</font> OP1 | OP2 ; <br> <br> <font color="#7f9fbf">EXPR:</font> EXPR1 <br> <font color="#7f9fbf">|</font> ID <font color="#ff6060">'='</font> EXPR <br> <br> <font color="#7f9fbf">EXPR1:</font> EXPR2 <br> <font color="#7f9fbf">|</font> EXPR1 EQ EXPR2 <br> <font color="#7f9fbf">|</font> EXPR1 LE EXPR2 <br> <font color="#7f9fbf">|</font> EXPR1 GE EXPR2 <br> <font color="#7f9fbf">|</font> EXPR1 NE EXPR2 <br> <font color="#7f9fbf">|</font> EXPR1 <font color="#ff6060">'&gt;'</font> EXPR2 <br> <font color="#7f9fbf">|</font> EXPR1 <font color="#ff6060">'&lt;'</font> EXPR2 <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">EXPR2:</font> TERM <br> <font color="#7f9fbf">|</font> EXPR2 <font color="#ff6060">'+'</font> TERM <br> <font color="#7f9fbf">|</font> EXPR2 <font color="#ff6060">'-'</font> TERM <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">TERM:</font> VAL <br> <font color="#7f9fbf">|</font> TERM <font color="#ff6060">'*'</font> VAL <br> <font color="#7f9fbf">|</font> TERM <font color="#ff6060">'/'</font> VAL <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">VAL:</font> NUM <br> <font color="#7f9fbf">|</font> <font color="#ff6060">'-'</font> VAL <br> <font color="#7f9fbf">|</font> <font color="#ff6060">'!'</font> VAL <br> <font color="#7f9fbf">|</font> <font color="#ff6060">'('</font> EXPR <font color="#ff6060">')'</font> <br> <font color="#7f9fbf">|</font> ID <br> <font color="#7f9fbf">|</font> ID <font color="#ff6060">'('</font> ARGS <font color="#ff6060">')'</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">ARGS:</font> <br> <font color="#7f9fbf">|</font> ARG <br> <font color="#7f9fbf">|</font> ARGS <font color="#ff6060">','</font> ARG <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">ARG:</font> EXPR <br> <font color="#7f9fbf">|</font> STRING <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#808080">%%</font> <br> <font color="#008000">int</font> main() <font color="#ff40ff">{</font> <font color="#808000">return</font> yyparse(); <font color="#ff40ff">}</font> <br></code> <br>  This time it is more convenient for us to store in each token not a number, but a string ( <code>std::string</code> ).  The type for character values ‚Äã‚Äãis specified by the <code>YYSTYPE</code> macro. <br><br>  It remains to attach lexer to grammar;  there will be a small trick - named states, for recognizing iscaps inside strings. <br>  Files of our language will be called <code>jsk</code> . <br><br> <code><font color="#ff40ff">%{</font> <br> <font color="#ff40ff">#include</font> <font color="#ff6060">&lt;string&gt;</font> <br> <font color="#ff40ff">#define YYSTYPE std::string</font> <br> <font color="#ff40ff">#include</font> <font color="#ff6060">"jsk.tab.h"</font> <br> <font color="#008000">void</font> yyerror( <font color="#008000">char</font> *s); <br> <font color="#ff40ff">%}</font> <br> <br> %option yylineno <br> %option noyywrap <br> <br> <font color="#ff40ff">%x</font> STR <br> <br> <font color="#808080">%%</font> <br> <br> <font color="#7f9fbf">[/][/]</font> <font color="#7f9fbf">.*\n</font> ; <font color="#8080ff">// comment</font> <br> <font color="#7f9fbf">if</font> <font color="#808000">return</font> IF; <br> <font color="#7f9fbf">else</font> <font color="#808000">return</font> ELSE; <br> <font color="#7f9fbf">while</font> <font color="#808000">return</font> WHILE; <br> <font color="#7f9fbf">exit</font> <font color="#808000">return</font> EXIT; <br> <font color="#7f9fbf">==</font> <font color="#808000">return</font> EQ; <br> <font color="#7f9fbf">[&lt;]</font> <font color="#7f9fbf">=</font> <font color="#808000">return</font> LE; <br> <font color="#7f9fbf">&gt;=</font> <font color="#808000">return</font> GE; <br> <font color="#7f9fbf">!=</font> <font color="#808000">return</font> NE; <br> <font color="#7f9fbf">[0-9]</font> <font color="#7f9fbf">+</font> <font color="#ff40ff">{</font> yylval = <font color="#7f9fbf">yytext</font> ; <br> <font color="#808000">return</font> NUM; <br> <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">[a-zA-Z_][a-zA-Z0-9_]</font> <font color="#7f9fbf">*</font> <font color="#ff40ff">{</font> yylval = <font color="#7f9fbf">yytext</font> ; <br> <font color="#808000">return</font> ID; <br> <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">["]</font> <font color="#ff40ff">{</font> yylval = <font color="#ff6060">""</font> ; <font color="#7f9fbf">BEGIN</font> (STR); <font color="#ff40ff">}</font> <br> <font color="#ff40ff">&lt;STR&gt;</font> <font color="#7f9fbf">[^\\\n"]</font> <font color="#7f9fbf">+</font> yylval += <font color="#7f9fbf">yytext</font> ; <br> <font color="#ff40ff">&lt;STR&gt;</font> <font color="#7f9fbf">\\n</font> yylval += <font color="#ff40ff">'\n'</font> ; <br> <font color="#ff40ff">&lt;STR&gt;</font> <font color="#7f9fbf">\\</font> <font color="#7f9fbf">["]</font> yylval += <font color="#ff6060">'"'</font> ; <br> <font color="#ff40ff">&lt;STR&gt;</font> <font color="#7f9fbf">\\</font> yyerror( <font color="#ff6060">"Invalid escape sequence"</font> ); <br> <font color="#ff40ff">&lt;STR&gt;</font> <font color="#7f9fbf">\n</font> yyerror( <font color="#ff6060">"Newline in string literal"</font> ); <br> <font color="#ff40ff">&lt;STR&gt;</font> <font color="#7f9fbf">["]</font> <font color="#ff40ff">{</font> <font color="#7f9fbf">BEGIN</font> (INITIAL); <font color="#808000">return</font> STRING; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">[ \t\r\n]</font> ; <font color="#8080ff">// whitespace</font> <br> <font color="#7f9fbf">[-{};()=&lt;&gt;+*/!,]</font> <font color="#ff40ff">{</font> <font color="#808000">return</font> * <font color="#7f9fbf">yytext</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">.</font> yyerror( <font color="#ff6060">"Invalid character"</font> ); <br> <br> <font color="#808080">%%</font> <br></code> <br>  The <b>% x</b> declaration defines a <i>named state</i> in which the lexer enters not as a result of reading input characters, but as a result of an explicit call to <code>BEGIN(STR)</code> .  The initial state is called <code>INITIAL</code> ;  To return to it, call <code>BEGIN(INITIAL)</code> .  As a result, we have two different sets of regexps in the lexer: one for the main program, the other for string literals.  On each quote switch between these two sets. <br><br>  The resulting dummy parser looks for syntax errors in the program;  and if it does not find it, then it does not display anything: <br> <code>[tyomitch@home ~]$ <b>lex jsk.lex</b> <br> [tyomitch@home ~]$ <b>bison -d jsk.y</b> <br> [tyomitch@home ~]$ <b>c++ lex.yy.c jsk.tab.c</b> <br> [tyomitch@home ~]$ <b>./a.out &lt; test.jsk</b> <br> [tyomitch@home ~]$ <b>./a.out</b> <br> <b>{ foo(); <br> bar; } <br> } <br></b> syntax error, line 3 <br></code> <br><br><h2>  Syntax tree </h2><br>  What can be done useful in the rule folding? <br>  In the past times, we were able to perform all the necessary actions right in the convolutions, right in the course of the analysis, (calculate the value of the expression). <br>  A more universal approach is to build a tree for the input text that matches the syntactic structure of the text and, after parsing, finish processing this tree.  For getting information from trees, there are a lot of methods not related to compilation: from recursive traversals to XPath queries. <br><br>  For each node type in the tree, we define a separate class, and we will store pointers to the node objects on the parser stack.  Besides them, the stack may contain lines from the lexer, as well as ‚Äúintermediate results‚Äù for which we decide not to select a separate node in the tree.  In our example, the tree node does not correspond to the <code>ARGS</code> symbol: we will store references to all the function arguments directly in the ‚Äúfunction call‚Äù node.  In other words, the syntax tree does not have to match the parse tree exactly;  we have the right to rebuild it more comfortably.  Another example of inconsistency is that there will not be an ‚Äúoperator‚Äù node in our syntax tree;  only a ‚Äúlist of operators‚Äù - possibly from a single element. <br><br> <code><font color="#ff40ff">%{</font> <br> <font color="#ff40ff">#include</font> <font color="#ff6060">&lt;iostream&gt;</font> <br> <font color="#ff40ff">#include</font> <font color="#ff6060">&lt;list&gt;</font> <br> <font color="#008000">extern</font> <font color="#008000">int</font> yylineno; <br> <font color="#008000">extern</font> <font color="#008000">int</font> yylex(); <br> <font color="#008000">void</font> yyerror( <font color="#008000">char</font> *s) { <br> std::cerr &lt;&lt; s &lt;&lt; <font color="#ff6060">", line "</font> &lt;&lt; yylineno &lt;&lt; std::endl; <br> exit( <font color="#ff6060">1</font> ); <br> } <br> <br> <font color="#008000">class</font> oper_t { <font color="#8080ff">// abstract</font> <br> <font color="#808000">protected</font> : oper_t() {} <br> <font color="#808000">public</font> : <font color="#008000">virtual</font> ~oper_t() {} <br> }; <br> <br> <font color="#008000">class</font> expr_t { <font color="#8080ff">// abstract</font> <br> <font color="#808000">protected</font> : expr_t() {} <br> <font color="#808000">public</font> : <font color="#008000">virtual</font> ~expr_t() {} <br> }; <br> <br> <font color="#008000">class</font> block : <font color="#808000">public</font> oper_t { <br> std::list&lt;oper_t*&gt; ops; <br> <font color="#008000">void</font> append(oper_t* op) { <br> block* b = <font color="#808000">dynamic_cast</font> &lt;block*&gt;(op); <br> <font color="#808000">if</font> (b) { <br> ops.splice(ops.end(), b-&gt;ops, b-&gt;ops.begin(), b-&gt;ops.end()); <br> <font color="#808000">delete</font> b; <br> } <br> <font color="#808000">else</font> ops.push_back(op); <br> } <br> <font color="#808000">public</font> : <br> block() {} <br> block(oper_t* op) { append(op); } <br> block(oper_t* op1, oper_t* op2) { append(op1); append(op2); } <br> }; <br> <br> <font color="#008000">class</font> exprop : <font color="#808000">public</font> oper_t { <br> expr_t* expr; <br> <font color="#808000">public</font> : exprop(expr_t* expr) : expr(expr) {} <br> }; <br> <br> <font color="#008000">class</font> ifop : <font color="#808000">public</font> oper_t { <br> expr_t* cond; <br> block thenops, elseops; <br> <font color="#808000">public</font> : ifop(expr_t* cond, oper_t* thenops, oper_t* elseops) : <br> cond(cond), thenops(thenops), elseops(elseops) {} <br> }; <br> <br> <font color="#008000">class</font> whileop : <font color="#808000">public</font> oper_t { <br> expr_t* cond; <br> block ops; <br> <font color="#808000">public</font> : whileop(expr_t* cond, oper_t* ops) : cond(cond), ops(ops) {} <br> }; <br> <br> <font color="#008000">class</font> exitop : <font color="#808000">public</font> oper_t {}; <br> <br> <font color="#008000">class</font> binary : <font color="#808000">public</font> expr_t { <br> <font color="#008000">const</font> <font color="#008000">char</font> * op; <br> expr_t *arg1, *arg2; <br> <font color="#808000">public</font> : binary( <font color="#008000">const</font> <font color="#008000">char</font> * op, expr_t *arg1, expr_t *arg2) : <br> op(op), arg1(arg1), arg2(arg2) {} <br> }; <br> <br> <font color="#008000">class</font> assign : <font color="#808000">public</font> expr_t { <br> std::string name; <br> expr_t* value; <br> <font color="#808000">public</font> : assign( <font color="#008000">const</font> std::string&amp; name, expr_t* value) : <br> name(name), value(value) {} <br> }; <br> <br> <font color="#008000">class</font> unary : <font color="#808000">public</font> expr_t { <br> <font color="#008000">const</font> <font color="#008000">char</font> * op; <br> expr_t* arg; <br> <font color="#808000">public</font> : unary( <font color="#008000">const</font> <font color="#008000">char</font> * op, expr_t* arg) : op(op), arg(arg) {} <br> }; <br> <br> <font color="#008000">class</font> funcall : <font color="#808000">public</font> expr_t { <br> std::string name; <br> std::list&lt;expr_t*&gt; args; <br> <font color="#808000">public</font> : funcall( <font color="#008000">const</font> std::string&amp; name, <br> <font color="#008000">const</font> std::list&lt;expr_t*&gt;&amp; args) : <br> name(name), args(args) {} <br> }; <br> <br> <font color="#008000">class</font> value : <font color="#808000">public</font> expr_t { <br> std::string text; <br> <font color="#808000">public</font> : value( <font color="#008000">const</font> std::string&amp; text) : text(text) {} <br> }; <br> <br> <font color="#8080ff">//   : , , ,  </font> <br> <font color="#008000">typedef</font> <font color="#008000">struct</font> { <br> std::string str; <br> oper_t* oper; <br> expr_t* expr; <br> std::list&lt;expr_t*&gt; args; <br> } YYSTYPE; <br> <font color="#ff40ff">#define YYSTYPE YYSTYPE</font> <br> <br> <font color="#8080ff">//  </font> <br> std::string replaceAll( <font color="#008000">const</font> std::string&amp; where, <font color="#008000">const</font> std::string&amp; what, <font color="#008000">const</font> std::string&amp; withWhat) { <br> std::string result = where; <br> <font color="#808000">while</font> ( <font color="#ff6060">1</font> ) { <br> <font color="#008000">int</font> pos = result.find(what); <br> <font color="#808000">if</font> (pos==- <font color="#ff6060">1</font> ) <font color="#808000">return</font> result; <br> result.replace(pos, what.size(), withWhat); <br> } <br> } <br> <font color="#ff40ff">%}</font> <br> <br> <font color="#808000">%token</font> IF ELSE WHILE EXIT <br> <font color="#808000">%token</font> EQ LE GE NE <br> <font color="#808000">%token</font> STRING NUM ID <br> <br> <font color="#808000">%type</font> <font color="#808000">&lt;</font> <font color="#008000">str</font> <font color="#808000">&gt;</font> ID NUM STRING <br> <font color="#808000">%type</font> <font color="#808000">&lt;</font> <font color="#008000">oper</font> <font color="#808000">&gt;</font> OPS OP1 OP2 OP <br> <font color="#808000">%type</font> <font color="#808000">&lt;</font> <font color="#008000">expr</font> <font color="#808000">&gt;</font> EXPR EXPR1 EXPR2 TERM VAL ARG <br> <font color="#808000">%type</font> <font color="#808000">&lt;</font> <font color="#008000">args</font> <font color="#808000">&gt;</font> ARGS <br> <br> <font color="#808080">%%</font> <br> <br> <font color="#7f9fbf">PROGRAM:</font> OPS <font color="#8080ff">//   </font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">OPS:</font> OP <font color="#8080ff">// inherit</font> <br> <font color="#7f9fbf">|</font> OPS OP <font color="#ff40ff">{</font> <font color="#808000">$$</font> = new block( <font color="#808000">$1</font> , <font color="#808000">$2</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">OP1:</font> <font color="#ff6060">'{'</font> OPS <font color="#ff6060">'}'</font> <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$2</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> EXPR <font color="#ff6060">';'</font> <font color="#ff40ff">{</font> <font color="#808000">$$</font> = new exprop( <font color="#808000">$1</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> IF <font color="#ff6060">'('</font> EXPR <font color="#ff6060">')'</font> OP1 ELSE OP1 <font color="#ff40ff">{</font> <font color="#808000">$$</font> = new ifop( <font color="#808000">$3</font> , <font color="#808000">$5</font> , <font color="#808000">$7</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> WHILE <font color="#ff6060">'('</font> EXPR <font color="#ff6060">')'</font> OP1 <font color="#ff40ff">{</font> <font color="#808000">$$</font> = new whileop( <font color="#808000">$3</font> , <font color="#808000">$5</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> EXIT <font color="#ff6060">';'</font> <font color="#ff40ff">{</font> <font color="#808000">$$</font> = new exitop(); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">OP2:</font> IF <font color="#ff6060">'('</font> EXPR <font color="#ff6060">')'</font> OP <font color="#ff40ff">{</font> <font color="#808000">$$</font> = new ifop( <font color="#808000">$3</font> , <font color="#808000">$5</font> , new block()); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> IF <font color="#ff6060">'('</font> EXPR <font color="#ff6060">')'</font> OP1 ELSE OP2 <font color="#ff40ff">{</font> <font color="#808000">$$</font> = new ifop( <font color="#808000">$3</font> , <font color="#808000">$5</font> , <font color="#808000">$7</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> WHILE <font color="#ff6060">'('</font> EXPR <font color="#ff6060">')'</font> OP2 <font color="#ff40ff">{</font> <font color="#808000">$$</font> = new whileop( <font color="#808000">$3</font> , <font color="#808000">$5</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">OP:</font> OP1 | OP2 ; <font color="#8080ff">// inherit</font> <br> <br> <font color="#7f9fbf">EXPR:</font> EXPR1 <font color="#8080ff">// inherit</font> <br> <font color="#7f9fbf">|</font> ID <font color="#ff6060">'='</font> EXPR <font color="#ff40ff">{</font> <font color="#808000">$$</font> = new assign( <font color="#808000">$1</font> , <font color="#808000">$3</font> ); <font color="#ff40ff">}</font> <br> <br> <font color="#7f9fbf">EXPR1:</font> EXPR2 <font color="#8080ff">// inherit</font> <br> <font color="#7f9fbf">|</font> EXPR1 EQ EXPR2 <font color="#ff40ff">{</font> <font color="#808000">$$</font> = new binary( <font color="#ff6060">"=="</font> , <font color="#808000">$1</font> , <font color="#808000">$3</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> EXPR1 LE EXPR2 <font color="#ff40ff">{</font> <font color="#808000">$$</font> = new binary( <font color="#ff6060">"&lt;="</font> , <font color="#808000">$1</font> , <font color="#808000">$3</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> EXPR1 GE EXPR2 <font color="#ff40ff">{</font> <font color="#808000">$$</font> = new binary( <font color="#ff6060">"&gt;="</font> , <font color="#808000">$1</font> , <font color="#808000">$3</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> EXPR1 NE EXPR2 <font color="#ff40ff">{</font> <font color="#808000">$$</font> = new binary( <font color="#ff6060">"!="</font> , <font color="#808000">$1</font> , <font color="#808000">$3</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> EXPR1 <font color="#ff6060">'&gt;'</font> EXPR2 <font color="#ff40ff">{</font> <font color="#808000">$$</font> = new binary( <font color="#ff6060">"&gt;"</font> , <font color="#808000">$1</font> , <font color="#808000">$3</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> EXPR1 <font color="#ff6060">'&lt;'</font> EXPR2 <font color="#ff40ff">{</font> <font color="#808000">$$</font> = new binary( <font color="#ff6060">"&lt;"</font> , <font color="#808000">$1</font> , <font color="#808000">$3</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">EXPR2:</font> TERM <font color="#8080ff">// inherit</font> <br> <font color="#7f9fbf">|</font> EXPR2 <font color="#ff6060">'+'</font> TERM <font color="#ff40ff">{</font> <font color="#808000">$$</font> = new binary( <font color="#ff6060">"+"</font> , <font color="#808000">$1</font> , <font color="#808000">$3</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> EXPR2 <font color="#ff6060">'-'</font> TERM <font color="#ff40ff">{</font> <font color="#808000">$$</font> = new binary( <font color="#ff6060">"-"</font> , <font color="#808000">$1</font> , <font color="#808000">$3</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">TERM:</font> VAL <font color="#8080ff">// inherit</font> <br> <font color="#7f9fbf">|</font> TERM <font color="#ff6060">'*'</font> VAL <font color="#ff40ff">{</font> <font color="#808000">$$</font> = new binary( <font color="#ff6060">"*"</font> , <font color="#808000">$1</font> , <font color="#808000">$3</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> TERM <font color="#ff6060">'/'</font> VAL <font color="#ff40ff">{</font> <font color="#808000">$$</font> = new binary( <font color="#ff6060">"/"</font> , <font color="#808000">$1</font> , <font color="#808000">$3</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">VAL:</font> NUM <font color="#ff40ff">{</font> <font color="#808000">$$</font> = new value( <font color="#808000">$1</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> <font color="#ff6060">'-'</font> VAL <font color="#ff40ff">{</font> <font color="#808000">$$</font> = new unary( <font color="#ff6060">"-"</font> , <font color="#808000">$2</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> <font color="#ff6060">'!'</font> VAL <font color="#ff40ff">{</font> <font color="#808000">$$</font> = new unary( <font color="#ff6060">"!"</font> , <font color="#808000">$2</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> <font color="#ff6060">'('</font> EXPR <font color="#ff6060">')'</font> <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$2</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> ID <font color="#ff40ff">{</font> <font color="#808000">$$</font> = new value( <font color="#808000">$1</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> ID <font color="#ff6060">'('</font> ARGS <font color="#ff6060">')'</font> <font color="#ff40ff">{</font> <font color="#808000">$$</font> =new funcall( <font color="#808000">$1</font> , <font color="#808000">$3</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">ARGS:</font> <font color="#ff40ff">{</font> <font color="#808000">$$</font> .clear(); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> ARG <font color="#ff40ff">{</font> <font color="#808000">$$</font> .clear(); <font color="#808000">$$</font> .push_back( <font color="#808000">$1</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> ARGS <font color="#ff6060">','</font> ARG <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$1</font> ; <font color="#808000">$$</font> .push_back( <font color="#808000">$3</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">ARG:</font> EXPR <font color="#8080ff">// inherit</font> <br> <font color="#7f9fbf">|</font> STRING <font color="#ff40ff">{</font> <font color="#808000">$$</font> =new value( <font color="#ff6060">'"'</font> +replaceAll( <font color="#808000">$1</font> , <font color="#ff6060">"</font> <font color="#ff40ff">\n</font> <font color="#ff6060">"</font> , <font color="#ff6060">"</font> <font color="#ff40ff">\\</font> <font color="#ff6060">n"</font> )+ <font color="#ff6060">'"'</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#808080">%%</font> <br> <font color="#008000">int</font> main() <font color="#ff40ff">{</font> <font color="#808000">return</font> yyparse(); <font color="#ff40ff">}</font> <br></code> <br>  The <code>%type&lt;str&gt;</code> declaration specifies for grammar characters (terminals and non-terminals) which <code>YYSTYPE</code> fields should be used as the value of a character.  If the field is set, the bison will substitute it every time the <b>$</b> -tag refers to such a grammar symbol.  If the field is not specified (as in the previous examples), then <code>YYSTYPE</code> used entirely. <br>  In classical syshnyh parsers, <code>YYSTYPE</code> declared as a <code>union</code> : each character interprets the same stored value in its own way.  This does not suit us: an object with a destructor cannot be a <code>union</code> field;  therefore, we declare <code>YYSTYPE</code> as a structure, and the structure fields of the structure that are not needed by the symbol will simply take up nothing.  But we are not greedy. <br><br>  The unpleasant moment is that due to the repair of the conflict with <code>else</code> in the grammar two identical <code>if..else</code> rules and two identical <code>while</code> rules appeared.  It‚Äôs on our conscience to choose what is more unpleasant: to give priority to <code>else</code> and <b>)</b> , as if they were operators;  or copy-paste convolution code twice. <br><br>  So, our parser builds a tree in memory, and when it is ready, it just comes out, without even freeing the memory.  Not too impressive? <br><br><h2>  Pretty-printing </h2><br>  It takes quite a bit of effort for the parser to do something meaningful;  for example, placed brackets in expressions, deleted redundant <b>{}</b> and, and in addition, leveled operators using BSD Kernel Normal Form. <br>  Let's add a recursive printout to our tree classes. <br>  Only class definitions and convolution of the <code>PROGRAM</code> symbol are <code>PROGRAM</code> . <br><br> <code><font color="#ff40ff">#define TOKENPASTE(x, y) x ## y</font> <br> <font color="#ff40ff">#define TOKENPASTE2(x, y) TOKENPASTE(x, y)</font> <br> <font color="#ff40ff">#define foreach(i, list)</font> <font color="#008000">typedef</font> <font color="#ff40ff">typeof(list) TOKENPASTE2(T,</font> <font color="#ff6060">__LINE__</font> <font color="#ff40ff">); \</font> <br> <font color="#ff40ff">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </font> <font color="#808000">for</font> <font color="#ff40ff">(TOKENPASTE2(T,</font> <font color="#ff6060">__LINE__</font> <font color="#ff40ff">)::iterator i = list.begin(); i != list.end(); i++)</font> <br> <br> <font color="#008000">class</font> oper_t { <font color="#8080ff">// abstract</font> <br> <font color="#808000">protected</font> : oper_t() {} <br> <font color="#808000">public</font> : <font color="#008000">virtual</font> ~oper_t() {} <br> <b><font color="#008000">virtual</font> <font color="#008000">void</font> print( <font color="#008000">int</font> indent= <font color="#ff6060">0</font> ) = <font color="#ff6060">0</font> ;</b> <br> }; <br> <br> <font color="#008000">class</font> expr_t { <font color="#8080ff">// abstract</font> <br> <font color="#808000">protected</font> : expr_t() {} <br> <font color="#808000">public</font> : <font color="#008000">virtual</font> ~expr_t() {} <br> <b><font color="#008000">virtual</font> <font color="#008000">void</font> print() = <font color="#ff6060">0</font> ;</b> <br> }; <br> <br> <font color="#008000">class</font> block : <font color="#808000">public</font> oper_t { <br> std::list&lt;oper_t*&gt; ops; <br> <font color="#008000">void</font> append(oper_t* op) { <br> block* b = <font color="#808000">dynamic_cast</font> &lt;block*&gt;(op); <br> <font color="#808000">if</font> (b) { <br> ops.splice(ops.end(), b-&gt;ops, b-&gt;ops.begin(), b-&gt;ops.end()); <br> <font color="#808000">delete</font> b; <br> } <br> <font color="#808000">else</font> ops.push_back(op); <br> } <br> <font color="#808000">public</font> : <br> block() {} <br> block(oper_t* op) { append(op); } <br> block(oper_t* op1, oper_t* op2) { append(op1); append(op2); } <br> <font color="#008000">int</font> size() { <font color="#808000">return</font> ops.size(); } <br> <b><font color="#008000">virtual</font> <font color="#008000">void</font> print( <font color="#008000">int</font> indent= <font color="#ff6060">0</font> ) { <br> foreach(i, ops) { <br> std::cout &lt;&lt; std::string(indent, <font color="#ff40ff">'\t'</font> ); <br> (*i)-&gt;print(indent); <br> } <br> } <br> <font color="#008000">virtual</font> ~block() { foreach(i, ops) <font color="#808000">delete</font> *i; }</b> <br> }; <br> <br> <font color="#008000">class</font> exprop : <font color="#808000">public</font> oper_t { <br> expr_t* expr; <br> <font color="#808000">public</font> : exprop(expr_t* expr) : expr(expr) {} <br> <b><font color="#008000">virtual</font> <font color="#008000">void</font> print( <font color="#008000">int</font> indent= <font color="#ff6060">0</font> ) { <br> expr-&gt;print(); <br> std::cout &lt;&lt; <font color="#ff6060">";"</font> &lt;&lt; std::endl; <br> } <br> <font color="#008000">virtual</font> ~exprop() { <font color="#808000">delete</font> expr; }</b> <br> }; <br> <br> <font color="#008000">class</font> ifop : <font color="#808000">public</font> oper_t { <br> expr_t* cond; <br> block thenops, elseops; <br> <font color="#808000">public</font> : ifop(expr_t* cond, oper_t* thenops, oper_t* elseops) : <br> cond(cond), thenops(thenops), elseops(elseops) {} <br> <b><font color="#008000">virtual</font> <font color="#008000">void</font> print( <font color="#008000">int</font> indent= <font color="#ff6060">0</font> ) { <br> std::cout &lt;&lt; <font color="#ff6060">"if "</font> ; cond-&gt;print();  std::cout &lt;&lt; <font color="#ff6060">" {"</font> &lt;&lt; std::endl; <br> thenops.print(indent+ <font color="#ff6060">1</font> ); <br> <font color="#808000">if</font> (elseops.size()) { <br> std::cout &lt;&lt; std::string(indent, <font color="#ff40ff">'\t'</font> ) &lt;&lt; <font color="#ff6060">"} else {"</font> &lt;&lt; std::endl; <br> elseops.print(indent+ <font color="#ff6060">1</font> ); <br> } <br> std::cout &lt;&lt; std::string(indent, <font color="#ff40ff">'\t'</font> ) &lt;&lt; <font color="#ff6060">"}"</font> &lt;&lt; std::endl; <br> } <br> <font color="#008000">virtual</font> ~ifop() { <font color="#808000">delete</font> cond; }</b> <br> }; <br> <br> <font color="#008000">class</font> whileop : <font color="#808000">public</font> oper_t { <br> expr_t* cond; <br> block ops; <br> <font color="#808000">public</font> : whileop(expr_t* cond, oper_t* ops) : cond(cond), ops(ops) {} <br> <b><font color="#008000">virtual</font> <font color="#008000">void</font> print( <font color="#008000">int</font> indent= <font color="#ff6060">0</font> ) { <br> std::cout &lt;&lt; <font color="#ff6060">"while "</font> ; cond-&gt;print();  std::cout &lt;&lt; <font color="#ff6060">" {"</font> &lt;&lt; std::endl; <br> ops.print(indent+ <font color="#ff6060">1</font> ); <br> std::cout &lt;&lt; std::string(indent, <font color="#ff40ff">'\t'</font> ) &lt;&lt; <font color="#ff6060">"}"</font> &lt;&lt; std::endl; <br> } <br> <font color="#008000">virtual</font> ~whileop() { <font color="#808000">delete</font> cond; }</b> <br> }; <br> <br> <font color="#008000">class</font> exitop : <font color="#808000">public</font> oper_t { <br> <b><font color="#008000">virtual</font> <font color="#008000">void</font> print( <font color="#008000">int</font> indent= <font color="#ff6060">0</font> ) { std::cout &lt;&lt; <font color="#ff6060">"exit;"</font> &lt;&lt; std::endl; }</b> <br> }; <br> <br> <font color="#008000">class</font> binary : <font color="#808000">public</font> expr_t { <br> <font color="#008000">const</font> <font color="#008000">char</font> * op; <br> expr_t *arg1, *arg2; <br> <font color="#808000">public</font> : binary( <font color="#008000">const</font> <font color="#008000">char</font> * op, expr_t *arg1, expr_t *arg2) : <br> op(op), arg1(arg1), arg2(arg2) {} <br> <b><font color="#008000">virtual</font> <font color="#008000">void</font> print() { <br> std::cout&lt;&lt; <font color="#ff6060">"("</font> ; <br> arg1-&gt;print(); <br> std::cout&lt;&lt;op; <br> arg2-&gt;print(); <br> std::cout&lt;&lt; <font color="#ff6060">")"</font> ; <br> } <br> <font color="#008000">virtual</font> ~binary() { <font color="#808000">delete</font> arg1; <font color="#808000">delete</font> arg2; }</b> <br> }; <br> <br> <font color="#008000">class</font> assign : <font color="#808000">public</font> expr_t { <br> std::string name; <br> expr_t* value; <br> <font color="#808000">public</font> : assign( <font color="#008000">const</font> std::string&amp; name, expr_t* value) : <br> name(name), value(value) {} <br> <b><font color="#008000">virtual</font> <font color="#008000">void</font> print() { std::cout&lt;&lt;name&lt;&lt; <font color="#ff6060">" = "</font> ; value-&gt;print(); } <br> <font color="#008000">virtual</font> ~assign() { <font color="#808000">delete</font> value; }</b> <br> }; <br> <br> <font color="#008000">class</font> unary : <font color="#808000">public</font> expr_t { <br> <font color="#008000">const</font> <font color="#008000">char</font> * op; <br> expr_t* arg; <br> <font color="#808000">public</font> : unary( <font color="#008000">const</font> <font color="#008000">char</font> * op, expr_t* arg) : op(op), arg(arg) {} <br> <b><font color="#008000">virtual</font> <font color="#008000">void</font> print() { std::cout&lt;&lt;op; arg-&gt;print(); } <br> <font color="#008000">virtual</font> ~unary() { <font color="#808000">delete</font> arg; }</b> <br> }; <br> <br> <font color="#008000">class</font> funcall : <font color="#808000">public</font> expr_t { <br> std::string name; <br> std::list&lt;expr_t*&gt; args; <br> <font color="#808000">public</font> : funcall( <font color="#008000">const</font> std::string&amp; name, <br> <font color="#008000">const</font> std::list&lt;expr_t*&gt;&amp; args) : <br> name(name), args(args) {} <br> <b><font color="#008000">virtual</font> <font color="#008000">void</font> print() { <br> std::cout&lt;&lt;name&lt;&lt; <font color="#ff6060">"("</font> ; <br> foreach(i,args) { <br> <font color="#808000">if</font> (i!=args.begin()) <br> std::cout&lt;&lt; <font color="#ff6060">", "</font> ; <br> (*i)-&gt;print(); <br> } <br> std::cout&lt;&lt; <font color="#ff6060">")"</font> ; <br> } <br> <font color="#008000">virtual</font> ~funcall() { foreach(i,args) <font color="#808000">delete</font> *i; }</b> <br> }; <br> <br> <font color="#008000">class</font> value : <font color="#808000">public</font> expr_t { <br> std::string text; <br> <font color="#808000">public</font> : value( <font color="#008000">const</font> std::string&amp; text) : text(text) {} <br> <b><font color="#008000">virtual</font> <font color="#008000">void</font> print() { std::cout&lt;&lt;text; }</b> <br> }; <br> <br> <font color="#7f9fbf">PROGRAM:</font> OPS <font color="#ff40ff">{</font> <b><font color="#808000">$1</font> - <font color="#808000">&gt;</font> print(); delete <font color="#808000">$1</font> ;</b> <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br></code> <br>  Checking what happened: <br> <code>[tyomitch@home ~]$ <b>lex jsk.lex</b> <br> [tyomitch@home ~]$ <b>bison -d jsk.y</b> <br> [tyomitch@home ~]$ <b>c++ jsk.tab.c lex.yy.c</b> <br> [tyomitch@home ~]$ <b>./a.out &lt; test.jsk</b> <br> from = 0; <br> to = 1000; <br> echo("   ", from, "  ", to, ",    \n"); <br> while (from &lt;= to) { <br> guess = ((from + to) / 2); <br> echo(" ", guess, "? (1=, 2=, 3=) "); <br> i = input(); <br> if (i == 1) { <br> to = (guess - 1); <br> } else { <br> if (i == 2) { <br> from = (guess + 1); <br> } else { <br> if (i == 3) { <br> echo("!  !\n"); <br> exit; <br> } else { <br> echo("   !\n"); <br> } <br> } <br> } <br> } <br> echo(",   !\n"); <br></code> <br>  A formatted listing of the input text is a common way to initially check the parser.  Sample code from the beginning of the post is not very good in this regard, because  covers not all language constructs.  But it is intended to illustrate the language, not for testing. <br><br>  It is clear that for the sake of text formatting alone there was no point in bothering with trees: it would be enough to keep a list of text lines for each operator on the stack, and merge these lines into rolls, adding indents.  Yes, there, for the sake of indentation, even a bison is not needed: and flex would have done it.  (Although bracing is a bit more interesting.) <br><br>  Next time we <a href="http://habrahabr.ru/blogs/programming/99466/">take a break from the bison</a> . </div><p>Source: <a href="https://habr.com/ru/post/99397/">https://habr.com/ru/post/99397/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../99391/index.html">Google fights for the right to keep corporate secrecy of search algorithms</a></li>
<li><a href="../99393/index.html">PowerColor launches video card with original cooling system</a></li>
<li><a href="../99394/index.html">Building Java applications using Apache Ant, quick start</a></li>
<li><a href="../99395/index.html">Work and graduate school in Switzerland</a></li>
<li><a href="../99396/index.html">12th Russian spy worked at Microsoft</a></li>
<li><a href="../99398/index.html">Using Twitter technologies on your site</a></li>
<li><a href="../99399/index.html">Americans are concerned about digital drugs</a></li>
<li><a href="../99402/index.html">PushButton Engine Lesson # 1: FlashDevelop Setup</a></li>
<li><a href="../99405/index.html">The debut application "On fishing!" For iPhone</a></li>
<li><a href="../99409/index.html">Code that cannot be maintained (part 3, final)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>