<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Instantiation of function templates by type list (Part 1)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Have you ever written a function template that should be instantiated for a specific set of types and nothing else? If not, then this article is unlik...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Instantiation of function templates by type list (Part 1)</h1><div class="post__text post__text-html js-mediator-article">  Have you ever written a function template that should be instantiated for a specific set of types and nothing else?  If not, then this article is unlikely to seem interesting to you.  But if you are still here, then we will begin. <br><br>  The article will consist of two parts.  In the first part, the problem will be described and its primary, slightly crooked, solution will be presented.  The second part will be devoted to the improvement and generalization of the solution. <br><br>  First we describe the problem.  Imagine you declare a function template in a header file.  If the template should be potentially suitable for everything that is possible, then it should be defined here in the header file.  This entails end-to-end dependencies, an increase in compile time and srach in the header file.  But it is still inevitable.  Of course, you can define a template in another header file and include it at the bottom of the file with the advertisement.  This will save you from the third problem, but it will not get rid of the first two.  Now the opposite situation, when the template should be used (instantiated) only for a couple of specific types.  Then you safely transfer the definition to the source and explicitly instantiate your template for each individual type.  A little time consuming when accompanied, but still better than shitting in the headline. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Our situation is somewhere in the middle.  There is a function template, and it must be instantiated for a specific type list that somewhere in your project is perpetuated with typedef.  Well, for example: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> TypeList&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, EmptyList&gt; MyTypeList.</code> </pre> <br>  The fact that such a list of types can be read by A. Alexandrecu in ‚ÄúModern Design in C ++‚Äù, and an example of implementation is <a href="http://loki-lib.sourceforge.net/html/a00681.html">here</a> . <br>  Under katom self-made implementation (the same as the thousands of others, probably).  I personally like it more, because it allows me to write <br> <code>typedef TypeList&lt;int,char,bool,string, EmptyList&gt; MyTypeList;</code> <br>  instead of the classic record <br> <code>typedef TypeList&lt;int,TypeList&lt;char,TypeList&lt;bool,TypeList&lt;string, EmptyList&gt;&gt;&gt;&gt; MyTypeList;</code> <br> <br><a name="habracut"></a><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmptyList</span></span></span><span class="hljs-class">{</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Head, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Tail&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeList</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Head <span class="hljs-keyword"><span class="hljs-keyword">head_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> TypeList&lt;Tail...&gt; <span class="hljs-keyword"><span class="hljs-keyword">tail_t</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Head&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeList</span></span></span><span class="hljs-class">&lt;Head, EmptyList&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Head <span class="hljs-keyword"><span class="hljs-keyword">head_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> EmptyList <span class="hljs-keyword"><span class="hljs-keyword">tail_t</span></span>; };</code> </pre><br>  Let's return to the topic.  You can have fifty different function templates in the project, and each of them should be instantiated only for this omnipresent list of types.  How to do better: <br>  1) Defining a pattern in the header file is a defeatist attitude. <br>  2) Determine the template in the source and specialize it manually for all types from the list ... yeah, and then correct it in 50 places, if the list grows, decreases or just changes. <br><br>  Both options are bad.  The purpose of this article is to show how you can define a template in the source and get rid of manual instantiation for each type.  To make the goal a little clearer and to awaken your appetite, just give the final result.  But how it is implemented will be discussed only in the next part of the article. <br><pre> <code class="cpp hljs">-------------------------------- typelists.h       -------------------------------- <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once struct EmptyList{}; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename Head, typename... Tail&gt; struct TypeList { typedef Head head_t; typedef TypeList&lt;Tail...&gt; tail_t; }; template&lt;typename Head&gt; struct TypeList&lt;Head, EmptyList&gt; { typedef Head head_t; typedef EmptyList tail_t; }; typedef TypeList&lt;int, double, bool, char, const char*, EmptyList&gt; MyTypeList; .....      ,    ... -------------------------------- myclass.h -------------------------------- #pragma once class MyClass { public: template&lt;typename T&gt; void f(T x); }; -------------------------------- myclass.cpp -------------------------------- #include "templateclass.h" #include "typelist.h" #include &lt;iostream&gt; namespace { InstantiateMemFunc(MyClass, f, MyTypeList) // (*) } template&lt;typename T&gt; void MyClass::f(T x) { std::cout&lt;&lt; x &lt;&lt; "\n"; } -------------------------------- main.cpp -------------------------------- #include &lt;typelist.h&gt; #include "myclass.h" int main() { MyClass tc; tc.f(3); tc.f(2.0); tc.f(true); tc.f('a'); tc.f("hello world"); return 0; }</span></span></span></span></code> </pre><br><br>  I hope, now it became clear that there is a problem and that there is a goal.  Note that usually we would have to insert the following code into the source code of myclass.cpp so that this program could be linked: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MyClass::f&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MyClass::f&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MyClass::f&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MyClass::f&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MyClass::f&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*);</code> </pre><br>  Here, let everyone judge for himself what he likes more, this or the line with the star in myclass.cpp. <br><br>  The remainder of the first part of the article will be devoted to deciding whether to instantiate a pattern for the type list in the source file.  The only thing that the first solution will do well is that it will work.  And the second part of the article will open the veil of what is behind the <code>InstantiateMemberFunction</code> expression in the file myclass.cpp. <br><br>  So let's get down to business, we need to instantiate a function template for the type list.  We divide the problem into two subtasks: <br>  1) how to do something for a list of types and <br>  2) how to instantiate a pattern for one particular type. <br><br>  Let's start with the first subtask.  Here, except how to steal the reception with recursion, nothing comes to mind.  Well, for example, like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Types&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomethingDoer</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">// ,  -     template&lt;&gt; struct SomethingDoer&lt;EmptyList&gt; //     { static void doSomething(...) //  -  , .    {} }; template&lt;typename Head, typename... Tail&gt; struct SomethingDoer&lt;TypeList&lt;Head, Tail...&gt; &gt; //    . { static void doSomething() { ...  -     - Head .... (**) SomethingDoer&lt;typename TypeList&lt;Head, Tail...&gt;::tail_t&gt;::doSomething(); //       } };</span></span></code> </pre><br>  Now the goal of the task becomes very clear.  In the line with two asterisks, you need to instantiate the desired function for one particular type - Head. <br>  Let's move to the second subtask. <br>  Question: How can I instantiate a function template?  5 second. <br>  Time is over.  Answer: explicitly and implicitly. <br><br>  Obviously, as we have already discussed, it is too time consuming when accompanied.  What about implicitly? <br>  Question: What are two ways to implicitly instantiate a function template?  10 Seconds.  Ok, another 10 ten seconds.  But now the time is up. <br>  Answer: <br>  Method one is to call a function so that the template parameter can be displayed or directly specified; <br>  The second way is to define a variable that has the type of instance of the template and assign it to ... uh, how would it be better to say ... the address of the template (yes, I know, the template does not have an address, but I don‚Äôt know how to call it differently). <br>  An example is better than a random word set: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{...} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{...} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{...} }; f&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-comment"><span class="hljs-comment">//   g(58); //   void (*gPtr)(int) = g; //   void (S::*memFuncPtr)() = &amp;S::memFunc&lt;- , , int&gt;; //  </span></span></code> </pre><br>  About that which way is better for us, I will not strongly rassusolivat, but it will drag on for a long time.  I'll say right away - the second one will work better. <br>  Since you agree with me, let's try to instantiate the template in the second way. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Head, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Tail&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomethingDoer</span></span></span><span class="hljs-class">&lt;TypeList&lt;Head, Tail...&gt; &gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MyClass::*MemFuncType)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Head)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ MemFuncType x = &amp;MyClass::f; (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)(x); <span class="hljs-comment"><span class="hljs-comment">//    ,     SomethingDoer&lt;typename TypeList&lt;Head, Tail...&gt;::tail_t&gt;::doSomething(); } };</span></span></code> </pre><br>  Voila, the mechanism for instantiating templates according to the type list has been created ... but not yet implemented.  Imagine, you wrote the above definition of the class SomethingDoer along with its doSomething method somewhere in the nameless namespace of the source file, in this case in myclass.cpp.  Will the MyClass :: f (T) template be instantiated for the desired type list?  Unfortunately not.  But how to force the above code to do what it was created for.  Yes, very simple.  You need to call him: <br><pre> <code class="cpp hljs">SomethingDoer&lt;MyTypeList&gt;::instantiate();</code> </pre><br>  Only where is this wonderful line to write?  There in the nameless namespace?  She does not return anything, it can not be assigned to any variable.  Okay, I'll have to wrap it up: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Instantiator</span></span></span><span class="hljs-class"> {</span></span> Instantiator() { SomethingDoer&lt;MyTypeList&gt;::instantiate(); } };</code> </pre><br>  I don't know what your compiler is, but gcc-4.8.1 should compile this code.  And in debug mode, it is possible to link.  But no more than that.  What happens in production mode (release)?  All that is not used in the case, will be thrown to dog bran.  And the most important thing is not used in the case, namely: the local variable <code>x</code> from the <code>doSomething</code> method and the constructor of the <code>Instantiator</code> class.  But it's not a problem.  You just need to convince the compiler that these two things are still very important.  With <code></code> - it's simple.  You can, for example, declare a variable volatile, and let only the compiler dare to do something with it.  And with the constructor <code>Instantiator</code> - take and declare a variable of type <code>Instantiator</code> . <br>  Here is how our source will now look: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"myclass.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"typelist.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; namespace { template&lt;typename Types&gt; struct SomethingDoer; template&lt;&gt; struct SomethingDoer&lt;EmptyList&gt; { static void doSomething(...) {} }; template&lt;typename Head, typename... Tail&gt; struct SomethingDoer&lt;TypeList&lt;Head, Tail...&gt; &gt; { typedef void (MyClass::*MemFuncType)(Head); static void doSomething() { volatile MemFuncType x = &amp;MyClass::f; (void)(x); SomethingDoer&lt;typename TypeList&lt;Head, Tail...&gt;::tail_t&gt;::doSomething(); } }; template &lt;typename TList&gt; struct Instantiator { Instantiator() { SomethingDoer&lt;TList&gt;::doSomething(); } }; Instantiator&lt;MyTypeList&gt; a; //     . } template&lt;typename T&gt; void MyClass::f(T x) { std::cout&lt;&lt; x &lt;&lt; "\n"; }</span></span></span></span></code> </pre><br>  That's it, at least we have already coped with the task.  The template is defined in the source instead of the header file and instantiated for a list of types.  All changes in the required type list will automatically be reflected in the mechanism of the instantiation, and we will not have to prescribe explicit instances of the template manually if the type list changes.  Only one tiny one is striking in the eyes: all this code is the utter deformity that your colleagues and you yourself have dozens of ‚Äúfaeces‚Äù and ‚Äúchnee‚Äù when you open it later. <br><br>  Before specifying what exactly is badly this solution, let us sum up the subtotals by collecting all the accumulated code in one place (under the cut). <br><habracut><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// myclass.h #pragma once class MyClass { public: template&lt;typename T&gt; void f(T x); }; // myclass.cpp #include "templateclass.h" #include "typelist.h" #include &lt;iostream&gt; namespace { template&lt;typename Types&gt; struct SomethingDoer; template&lt;&gt; struct SomethingDoer&lt;EmptyList&gt; { static void doSomething(...) {} }; template&lt;typename Head, typename... Tail&gt; struct SomethingDoer&lt;TypeList&lt;Head, Tail...&gt; &gt; { typedef void (MyClass::*MemFuncType)(Head); static void doSomething() { volatile MemFuncType x = &amp;MyClass::f; (void)(x); SomethingDoer&lt;typename TypeList&lt;Head, Tail...&gt;::tail_t&gt;::doSomething(); } }; template &lt;typename TList&gt; struct Instantiator { Instantiator() { SomethingDoer&lt;TList&gt;::doSomething(); } }; Instantiator&lt;MyTypeList&gt; a; //     . } template&lt;typename T&gt; void MyClass::f(T x) { std::cout&lt;&lt; x &lt;&lt; "\n"; } // typelists.h #pragma once struct EmptyList{}; template&lt;typename Head, typename... Tail&gt; struct TypeList { typedef Head head_t; typedef TypeList&lt;Tail...&gt; tail_t; }; template&lt;typename Head&gt; struct TypeList&lt;Head, EmptyList&gt; { typedef Head head_t; typedef EmptyList tail_t; }; typedef TypeList&lt;int, double, bool, char, const char*, EmptyList&gt; MyTypeList; // main.cpp #include &lt;typelist.h&gt; #include "myclass.h" int main() { MyClass tc; tc.f(3); tc.f(2.0); tc.f(true); tc.f('a'); tc.f("hello world"); return 0; }</span></span></code> </pre><br>  The main disadvantage of this solution, in addition to its deformity, is that it is private.  We instantiated the pattern of one particular function of one particular class.  For another class, we would have to do the same thing in another source.  And if there were some patterns, then you would have to slightly expand the <code>doSomething</code> method, although this is the least of all the evils.  The biggest evil is that each user will have to understand how this is done, because the code of the instantiation mechanism and the launch code of this mechanism are closely intertwined.  It would be nice to hide the mechanism, no matter how cumbersome and confusing it might be.  Yes, so hide, so that the user was enough to write: <br><pre> <code class="cpp hljs"> InstantiateMemFunc(MyClass, f, MyTypeList) <span class="hljs-comment"><span class="hljs-comment">// (*)</span></span></code> </pre><br>  But we will talk about this in the second part. </habracut></div><p>Source: <a href="https://habr.com/ru/post/235831/">https://habr.com/ru/post/235831/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../235819/index.html">Increasing website sales: how long should a free trial period be for a customer to pay?</a></li>
<li><a href="../235823/index.html">What to read at your leisure. Gaming Industry News Digest for August</a></li>
<li><a href="../235825/index.html">Circle on programming. Results of the first year</a></li>
<li><a href="../235827/index.html">ThL 5000 - a resilient Chinese</a></li>
<li><a href="../235829/index.html">Google has created a virtual museum of Chinese history and art.</a></li>
<li><a href="../235833/index.html">Protection of paper sheets of the contract from the substitution of text</a></li>
<li><a href="../235835/index.html">Vibration resonance sound synthesis</a></li>
<li><a href="../235839/index.html">Logitech MX Air Mouse Repair</a></li>
<li><a href="../235841/index.html">Terrible pirate drowned due to leaking captcha</a></li>
<li><a href="../235843/index.html">DigitalOcean added the ability to use CoreOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>