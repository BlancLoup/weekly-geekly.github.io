<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Wavelet compression on the fingers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wavelets are now at the hearing. Even people who are inexperienced in mathematics have probably heard that they can be used to compress images and vid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Wavelet compression on the fingers</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/fc0/c54/b17/fc0c54b17780bed402547df3aa15b416.png" align="left"><br><br>  Wavelets are now at the hearing.  Even people who are inexperienced in mathematics have probably heard that they can be used to compress images and videos while maintaining acceptable quality.  But what is a wavelet?  Wikipedia answers this question with a whole heap of formulas for which it is not so easy to see the essence. <br><br>  Let's try using simple examples to figure out where the wavelets come from and how they can be used in compression.  It is assumed that the reader is familiar with the basics of linear algebra, vector and matrix are not afraid of words, and are able to multiply them.  (And in the <a href="https://habr.com/ru/post/169615/">second part</a> we will even try to program something.) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h4>  Image compression </h4><br><br>  Simply put, the image is a table, in the cells of which the colors of each pixel are stored.  If we work with a black-and-white (or, more precisely, gray) image, then instead of the color, the brightness values ‚Äã‚Äãfrom the [0, 1] segment are placed in the cells.  At the same time, 0 corresponds to black, 1 - to white.  But it‚Äôs inconvenient to work with fractions, so often the brightness values ‚Äã‚Äãare taken as integers from the range from 0 to 255. Then each value will take exactly 1 byte. <br><br>  Even small images require a lot of memory to store.  So, if we encode the brightness of each pixel in one byte, the image of one frame of FullHD format (1920 √ó 1080) will take almost two megabytes.  Imagine how much memory you need to store an hour and a half movie! <br><br>  Therefore, images tend to compress.  That is, encode so that less storage is required for storage.  And while watching, we decode the data stored in the memory and get the original frame.  But this is only ideally. <br><br>  There are many data compression algorithms.  Their number can be judged by the formats supported by modern archivers: ZIP, 7Z, RAR, ACE, GZIP, HA, BZ2 and so on.  It is not surprising that due to the active work of scientists and programmers, at present, the degree of data compression has come close to the theoretical limit. <br><br>  The bad news is that this theoretical limit is not so great for an image.  Try saving a photo (especially with a lot of small details) in PNG format - the size of the resulting file can upset you. <br><br>  This is due to the fact that in images from the real world (photos, for example) brightness values ‚Äã‚Äãare rarely the same, even for neighboring pixels.  There are always the smallest fluctuations that are elusive with the human eye, but which the compression algorithm honestly tries to take into account. <br><br>  Compression algorithms "love" when there is a pattern in the data.  Long sequences of zeros are best compressed (the pattern is obvious here).  In fact, instead of storing 100 zeros in memory, you can simply write the number 100 (of course, with a note that this is exactly the number of zeros).  The decoding program will ‚Äúunderstand‚Äù that they meant zeros and will reproduce them. <br><br>  However, if a unit suddenly appears in our sequence in the middle, then it will not be possible to limit it to one number 100. <br><br>  But why encode absolutely all the details?  After all, when we look at the photo, the overall picture is important to us, and we will not notice any minor fluctuations in brightness.  So, when encoding, we can slightly change the image so that it is well encoded.  At the same time, the compression ratio will immediately increase.  True, the decoded image will differ slightly from the original, but who will notice? <br><br><h4>  Transform haar </h4><br><br>  So, our goal is to transform the image so that it is well compressed by classical algorithms.  Let's think about how to change it to get long chains of zeros. <br><br>  The "real" images, such as photos, have one feature - the brightness of neighboring pixels usually differs by a small amount.  In fact, in the world one rarely sees dramatic, contrasting changes in brightness.  And if they are, they occupy only a small part of the image. <br><br>  Consider a fragment of the first row of brightness from the well-known image ‚ÄúLenna‚Äù (in the figure). <img src="https://habrastorage.org/storage2/a99/fcb/5ad/a99fcb5ad9487e4438a453cd47da224c.png" align="right"><br><br><pre>  154, 155, 156, 157, 157, 157, 158, 156 </pre><br><br>  It can be seen that the neighboring numbers are very close.  To get the desired zeros or at least something close to them, you can encode the first number separately, and then consider only the differences of each number from the previous one. <br><br>  We get: <br><br><pre>  154, 1, 1, 1, 0, 0, 1, -2. </pre><br><br>  Already better!  Such a method is in fact used and is called delta encoding.  But he has a serious drawback - he is non-local.  That is, you cannot take a piece of the sequence and find out exactly which brightness in it is encoded without decoding all the values ‚Äã‚Äãin front of this piece. <br><br>  Let's try to do otherwise.  We will not try to immediately get a good consistency, we will try to improve it at least a little. <br><br>  To do this, divide all the numbers into pairs and find the half-sum and half-difference of values ‚Äã‚Äãin each of them. <br><br><pre>  (154, 155), (156, 157), (157, 157), (158, 156) </pre><br><pre>  (154.5, 0.5), (156.5, 0.5), (157, 0.0), (157, -1.0) </pre><br><br>  Why precisely half sums and half differences?  And everything is very simple!  Half-sum is the average brightness value of a pair of pixels.  And half the difference carries information about the differences between the values ‚Äã‚Äãin the pair.  Obviously, knowing the half-sum a and half-difference d one can find the values ‚Äã‚Äãthemselves: <br>  the first value in the pair = a - d, <br>  second value in pair = a + d. <br><br>  This transformation was proposed in 1909 by Alfred Haar and bears his name. <br><br><h4>  And where is the compression? </h4><br><br>  The resulting numbers can be regrouped according to the principle ‚Äúflies separately, cutlets separately,‚Äù by dividing half-sum and half-difference: <br><br><pre>  154.5, 156.5, 157, 157;  0.5, 0.5, 0.0, -1.0. </pre><br><br>  The numbers in the second half of the sequence will usually be small (the fact that they are not integers, let them not confuse them yet).  Why is that? <br><br>  As we have already found out, in real images, neighboring pixels rarely differ significantly from each other.  If the value of one is great, then the other is great.  In such cases, it is said that neighboring pixels are correlated. <br><br>  In fact, consider the first 2000 pairs of neighboring pixels and each pair will be represented on the graph by a dot. <br><br><img src="https://habrastorage.org/storage2/eaf/2cf/012/eaf2cf012aff44aab8936f53b1ef2958.png"><br><br>  All points are lined up along one straight line.  And so in almost all real images.  The upper left and lower right corners of the image are almost always empty. <br><br>  And now we will consider the schedule, points in which there will be half sums and half differences. <br><br><img src="https://habrastorage.org/storage2/6bf/b8f/9a1/6bfb8f9a13b1458d813dd3625327b087.png"><br><br>  It can be seen that half-differences are in a much narrower range of values.  This means that you can spend less than one byte on them.  Any, and compression. <br><br><h4>  Let's do the math! </h4><br><br>  Let's try to write mathematical expressions describing the Haar transform. <br><br>  So, we had a couple of pixels (vector) <img src="https://habrastorage.org/storage2/d89/5df/577/d895df5778fa86e8b8a73a1735fbdb0d.png">  , and we want to get a couple <img src="https://habrastorage.org/storage2/6f2/d35/d2e/6f2d35d2ea89e362e6e191384728ae2e.png">  . <br><br>  This transformation is described by the matrix. <img src="https://habrastorage.org/storage2/8a5/797/898/8a57978986f6d4aa350a75be0e86ee98.png">  . <br><br>  Indeed <img src="https://habrastorage.org/storage2/656/122/c75/656122c75c0da53aff5561aefe2f7ea1.png">  what we needed. <br><br>  The attentive reader probably noticed that the figures from the points on the last two graphs are the same.  The difference is only in the rotation angle of 45 ¬∞. <br><br>  In mathematics, rotation and extension are called affine transformations and are described just by multiplying the matrix by the vector.  What we got higher.  That is, the Haar transform is simply turning the points so that they can be conveniently and compactly encoded. <br><br>  True, there is one nuance.  Under affine transformations, the area of ‚Äã‚Äãthe figure may vary.  Not that it was bad, but somehow carelessly.  As is known, the coefficient of change of area is equal to the determinant of the matrix.  Let's see what it is for the Haar transform. <br><br><img src="https://habrastorage.org/storage2/fd4/b49/0f7/fd4b490f763e3351ba12468b960ded6b.png"><br><br>  In order for the determinant to become equal to one, it is sufficient to multiply each element of the matrix by <img src="https://habrastorage.org/storage2/3bb/086/256/3bb086256ba5fcded51e5af92f1f04a2.png">  .  This will not affect the angle of rotation (and therefore the ‚Äúcompressive capacity‚Äù of the transformation). <br><br>  The resulting matrix <br><br><img src="https://habrastorage.org/storage2/273/e45/790/273e45790c5fa83a4d75835da559c08f.png"><br><br><h4>  How to decode? </h4><br><br>  As it is known, if the determinant of a matrix is ‚Äã‚Äãnot equal to zero, then for it there is an inverse matrix that "cancels" its action.  If we find the inverse matrix for H, then the decoding will simply consist in multiplying vectors with half sums and half differences on it. <br><br><img src="https://habrastorage.org/storage2/7aa/da8/62a/7aada862a1bc891e7df84cc501ee6539.png"><br><br>  Generally speaking, finding the inverse matrix is ‚Äã‚Äãnot such an easy task.  But maybe it will be possible somehow to simplify this task? <br><br>  Let's take a closer look at our matrix.  It consists of two vector lines: <img src="https://habrastorage.org/storage2/58e/c55/cc0/58ec55cc06471a9b48240f7e18badbff.png">  and <img src="https://habrastorage.org/storage2/7d9/665/27c/7d966527cd80b42ad8bd4f3d90ea4b0a.png">  .  Let's call them v <sub>1</sub> and v <sub>2</sub> . <br><br>  They have interesting properties. <br><br>  First, their lengths are 1, i.e. <img src="https://habrastorage.org/storage2/c2e/863/8a4/c2e8638a486e03ef047b720240257cda.png">  .  Here the letter T means transposition.  Multiplying a row vector by a transposed row vector is a scalar product. <br><br>  Secondly, they are orthogonal, i.e. <img src="https://habrastorage.org/storage2/ef4/945/5a6/ef49455a6c0eea5afcc15dbfd94261aa.png">  . <br><br>  A matrix whose rows possess the specified properties is called orthogonal.  An extremely important property of such matrices is that the inverse matrix for them can be obtained by simple transposition. <br><br><img src="https://habrastorage.org/storage2/eb9/308/2bd/eb93082bd00b72e12be6510373598424.png"><br><br>  The validity of this expression can be seen by multiplying the H inverse matrix.  On the diagonal we get the scalar products of vector strings on themselves, that is, 1. And outside the diagonals there are scalar products of vector strings on each other, that is 0. As a result, the product will be equal to the identity matrix. <br><br>  We love orthogonal matrices! <br><br><h4>  Increasing the number of points </h4><br><br>  All this works well for two points.  But what if there are more points? <br><br>  In this case, it is also possible to describe the transformation by a matrix, but larger in size.  The diagonal of this matrix will consist of matrices H, so pairs will be selected in the vector of initial values, to which the Haar transform will be applied independently. <br><br><img src="https://habrastorage.org/storage2/390/252/689/3902526892ede15e1aabbc3e380178c2.png"><br><br>  I.e.  the source vector is simply processed independently in pairs. <br><br><h4>  Filters </h4><br><br>  So, when we know how to perform the Haar transformation, we will try to figure out what it gives us. <br><br>  The resulting "half-sum" (due to the fact that we do not divide by 2, we have to use quotes) - this, as we have already found out, is the average values ‚Äã‚Äãin pairs of pixels.  That is, in fact, the half-sum values ‚Äã‚Äãare a reduced copy of the original image!  Reduced because half the amount is two times less than the original pixels. <br><br>  But what is the difference? <br><br>  Half-sum averages of the brightness values, that is, they ‚Äúfilter out‚Äù random bursts of values.  We can assume that this is some kind of frequency filter. <br><br>  Similarly, the differences "distinguish" among the values ‚Äã‚Äãof inter-pixel "bursts" and eliminate the constant component.  That is, they "filter out" low frequencies. <br><br>  Thus, the Haar transform is a pair of filters that divide the signal into low-frequency and high-frequency components.  To get the original signal, you just need to re-combine these components. <br><br>  What does this give us?  Suppose we have a portrait picture.  The low-frequency component carries information about the general shape of the face, and smooth brightness variations.  High-frequency - this is noise and small details. <br><br>  Usually, when we look at a portrait, we are more interested in the low-frequency component, which means that when compressing, some of the high-frequency data can be discarded.  Moreover, as we found out, it usually has smaller values, and therefore is more compactly encoded. <br><br>  The compression ratio can be increased by applying the Haar transform multiple times.  In fact, the high-frequency component is only half of the whole set of numbers.  But what prevents to apply our procedure once again to low-frequency data?  After repeated use, the high frequency information will occupy already 75%. <br><br>  Although we have talked about one-dimensional chains of numbers so far, this approach is well applicable for two-dimensional data.  To perform a two-dimensional Haar transformation (or similar), you only need to perform it for each row and for each column. <br><br>  After repeated application to, for example, photos of the castle Lichtenstein, we obtain the following figure. <br><br><img src="https://habrastorage.org/storage2/021/12e/919/02112e9190211983d73dd09ac6135aa3.png"><br><br>  Black areas correspond to low brightness, that is, values ‚Äã‚Äãclose to zero.  As practice shows, if the value is small enough, then it can be rounded off or even zeroed out without much damage to the decoded picture. <br><br>  This process is called quantization.  And it is at this stage that some of the information is lost.  (By the way, the same approach is used in JPEG, only discrete cosine transform is used instead of the Haar transform.) By varying the number of nullable coefficients, you can adjust the compression ratio! <br><br>  Of course, if you zero too much, the distortion will be visible to the eye.  Everything needs measure! <br><br>  After all these actions, we will have a matrix containing many zeros.  You can write it line by line into a file and compress it with some kind of archiver.  For example, the same 7Z.  The result will be quite good. <br><br>  Decoding is done in the reverse order: unpack the archive, apply the inverse Haar transform, and write the decoded image to a file.  Voila! <br><br><h4>  Where is the Haar transform effective? </h4><br><br>  When will the Haar transform give the best result?  Obviously, when we get a lot of zeros, that is, when the image contains long sections of the same brightness values.  Then all differences will be reset.  This may be, for example, an X-ray, a scanned document. <br><br>  It is said that the Haar transform eliminates the constant component (it is also a moment of zero order), that is, converts constants to zeros. <br><br>  But still in real photographs of areas with the same brightness, not so much.  Let's try to improve the transformation, so that it also nullifies the linear component.  In other words, if the brightness values ‚Äã‚Äãincrease linearly, they will also be reset. <br><br>  This problem and more complex (elimination of moments of higher orders) was solved by Ingrid Dobeshi - one of the creators of the theory of wavelets. <br><br><h4>  Dobeshi's transformation </h4><br><br>  For our advanced transformation, there will already be few points.  Therefore, we will take four values, shifting each time by two. <br><br>  That is, if the original sequence is 1, 2, 3, 4, 5, 6, ..., N-1, N, then we will take quadruples (1, 2, 3, 4), (3, 4, 5, 6) etc. The last four "bites the sequence by the tail": (N-1, N, 1, 2). <br><br>  Similarly, we will try to build two filters: high-frequency and low-frequency.  Every four will be replaced by two numbers.  Since the quadruples overlap, the number of values ‚Äã‚Äãafter the conversion will not change. <br><br>  In order to make it convenient to consider the inverse matrix, we also require the orthogonality of the transformation.  Then the search for the inverse matrix is ‚Äã‚Äãreduced to transpose <br><br>  Let the values ‚Äã‚Äãof the brightness in the four are x, y, z, t.  Then we write the first filter in the form <br><br><img src="https://habrastorage.org/storage2/234/86f/ff2/23486fff2b0e3c009671073e7d83d770.png"><br><br>  The four coefficients that make up the vector line of the transformation matrix are not yet known to us. <br><br>  To make the vector line of the coefficients of the second filter be orthogonal to the first one, take the same coefficients but rearrange them and change the signs: <br><br><img src="https://habrastorage.org/storage2/912/c56/4df/912c564dfcfc2774a537338ca8a99a6c.png"><br><br>  The transformation matrix will have the form. <br><br><img src="https://habrastorage.org/files/ef3/712/239/ef37122397f64f6c9473d026e3ee8382.png"><br><br>  The orthogonality requirement is satisfied for the first and second rows automatically.  We require that lines 1 and 3 also be orthogonal: <br><br><img src="https://habrastorage.org/storage2/dec/49c/0c7/dec49c0c7db1844ea1c86387692937b0.png"><br><br>  Vectors must have unit length (otherwise the determinant will not be unit): <br><br><img src="https://habrastorage.org/storage2/1c7/eb5/c04/1c7eb5c04c25eddcbb6a0b0a553d22b7.png"><br><br>  The conversion should reset the chain of identical values ‚Äã‚Äã(for example, (1, 1, 1, 1)): <br><br><img src="https://habrastorage.org/storage2/eba/c60/ab8/ebac60ab84de7f47f9419c7a093e2c52.png"><br><br>  The transformation should reset the chain of linearly growing values ‚Äã‚Äã(for example, (1, 2, 3, 4)): <br><br><img src="https://habrastorage.org/storage2/483/773/83e/48377383ece7e8e838b859071454b4a1.png"><br><br>  By the way, if this four is reset, then any other linearly growing or linearly decreasing will be reset.  It is easy to verify this by writing down the corresponding equation and dividing all the coefficients by the first factor. <br><br>  Received 4 equations connecting coefficients.  Solving them, we get: <br><br><img src="https://habrastorage.org/storage2/f95/d2f/268/f95d2f268e21fe5447eedeb2de321ae8.png"><br><br>  Substituting them into the matrix, we obtain the desired transformation.  After applying it to photos, we get more zeros and small coefficients, which will compress the image more strongly. <br><br>  Another nice feature is that artifacts will not be noticeable after quantization. <br><br>  This transformation was called the D4 wavelet (the reader is invited to independently solve the mystery of this alphanumeric name). <br><br><h4>  Other wavelets </h4><br><br>  Of course, we can not dwell on this, and demand the elimination of the parabolic component (the moment of the 2nd order), and so on.  As a result, we obtain the D6, D8 wavelets and others. <br><br>  In order not to count everything manually, the coefficients can be viewed in <a href="http://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B5%25D0%25B9%25D0%25B2%25D0%25BB%25D0%25B5%25D1%2582%25D1%258B_%25D0%2594%25D0%25BE%25D0%25B1%25D0%25B5%25D1%2588%25D0%25B8">Wikipedia</a> . <br><br>  Dobeshi discovered a very interesting way of obtaining the coefficients of these transformations, but alas, this is already beyond the scope of our article. <br><br><h4>  Homework </h4><br><br>  In order to finally understand the basics, I suggest writing a program in your favorite language that opens an image, performs a Haar transformation (or even D4), quantizes the result, and then saves the result to a file.  Try to compress this file with your favorite archiver.  Good shrink? <br><br>  Try the reverse transform.  How do you explain the nature of the artifacts in the image? <br><br><h4>  Conclusion </h4><br>  So, we briefly reviewed the basic ideas of the discrete wavelet transform. <br><br>  Of course, this article did not consider very many interesting mathematical details and practical applications of wavelet transforms.  But you can not grasp the immensity.  Yes, and much difficult to explain without raising the degree of matan.  I hope that the writing turned out to be useful to someone. <br><br>  Thanks for attention! <br><br>  Continued: <a href="http://habrahabr.ru/post/169615/">Wavelet compression "on the fingers": practice</a> . <br><br><h4>  Literature </h4><br>  There are many pretty good books that give a deeper insight into wavelets.  I recommend starting with the following: <br><ol><li>  Welstead C. Fractals and wavelets for compressing images in action.  - M .: Triumph, 2003. </li><li>  Stark G.-G.  The use of wavelets for DSP.  - M .: Technosphere, 2007. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/168517/">https://habr.com/ru/post/168517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../168493/index.html">7 steps to successfully migrate the SharePoint 2007 portal to SharePoint 2010</a></li>
<li><a href="../168497/index.html">Returning to the printed</a></li>
<li><a href="../168503/index.html">Kim Jong-un and the mysterious smartphone</a></li>
<li><a href="../168511/index.html">Runetology (184): Oleg Cheltsov, Fotolia project founder</a></li>
<li><a href="../168515/index.html">Squid3 in SSLBump mode with dynamic certificate generation</a></li>
<li><a href="../168523/index.html">First impressions of Sony Xperia Z and ZL</a></li>
<li><a href="../168525/index.html">IT AS IS</a></li>
<li><a href="../168527/index.html">Open Days Ingria "How to start-up get into the TV"</a></li>
<li><a href="../168529/index.html">Instagram has launched a web version of the user's tape</a></li>
<li><a href="../168531/index.html">Competitive admission of applications for improving the accessibility of GNOME</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>