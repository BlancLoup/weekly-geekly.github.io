<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Service Oriented Architecture (SOA)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Service-oriented architecture (SOA) was invented in the late 1980s. It originates in the ideas set forth in CORBA, DCOM, DCE, and other documents. Muc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Service Oriented Architecture (SOA)</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/ey/br/er/eybrert4uuwh3skcp5kprps9ye8.jpeg"></p><br><p>  Service-oriented architecture (SOA) was invented in the late 1980s.  It originates in the ideas set forth in CORBA, DCOM, DCE, and other documents.  Much has been written about SOA, there are several implementations of it.  But, in fact, SOA can be reduced to several ideas, and the architecture does not dictate the ways of their implementation: </p><br><ul><li>  Compatibility of user-oriented applications. </li><li>  Reuse of business services. </li><li>  Independence from a set of technologies. </li><li>  Autonomy (independent evolution, scalability and deployment). </li></ul><br><p>  SOA is a set of architectural principles that are independent of technology and products, just like polymorphism or encapsulation. </p><a name="habracut"></a><br><p>  In this article, I will look at the following patterns related to SOA: </p><br><ul><li>  Common Object Request Broker Architecture (CORBA). </li><li>  Web services. </li><li>  Message queue </li><li>  Service Bus Enterprise (ESB). </li><li>  Microservices. </li></ul><br><h2 id="obschaya-arhitektura-brokera-obektnyh-zaprosov-corba">  Common Object Request Broker Architecture (CORBA) </h2><br><p>  In the 1980s, active use of corporate networks and client-server architecture began.  There was a need for a standard way of interaction between applications that are created using different technologies, are executed on different computers and under different operating systems.  For this, CORBA was developed.  This is one of the standards of distributed computing, which originated in the 1980s and flourished by 1991. </p><br><p>  The CORBA standard has been implemented by several vendors.  It provides: </p><br><ul><li>  Platform-independent remote procedure calls. </li><li>  Transactions (including deleted!). </li><li>  Security. </li><li>  Developments. </li><li>  Independence from the choice of programming language. </li><li>  Independence on the choice of OS. </li><li>  Independence from the choice of equipment. </li><li>  Independence from data transmission / communication features. </li><li>  Data collection through interface description language (Interface Definition Language, IDL). </li></ul><br><p>  Today, CORBA is still used for heterogeneous computing.  For example, it <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/idl/corba.html">is still part of Java EE</a> , although <a href="https://www.infoq.com/news/2016/06/corba-removed-java-9">starting with Java 9 it will be delivered as a separate module</a> . </p><br><p>  I want to note that I <strong>do not consider CORBA as an SOA pattern</strong> (although I attribute both CORBA and SOA-patterns to the sphere of distributed computing).  I talk about it here, because I consider the weaknesses of the CORBA to be one of the causes of SOA. </p><br><h3 id="princip-raboty">  Principle of operation </h3><br><p>  First we need to get an Object Request Broker (ORB) broker that conforms to the CORBA specification.  It is provided by the vendor and uses language converters (language mappers) to generate stubs (stubs) and skeletons (skeleton) in the languages ‚Äã‚Äãof the client code.  Using this ORB and interface definitions that use IDL (similar to WSDL), you can generate remotely called stub classes on the basis of real classes in the client.  And on the server, you can generate skeleton classes that process incoming requests and call real targets. </p><br><p><img src="https://habrastorage.org/webt/gb/cb/xc/gbcbxc8eovnl3m2vzcupbrkcjpe.png"></p><br><p>  The caller calls the local procedure implemented by the stub. </p><br><ol><li>  The stub checks the call, creates the request message and sends it to the ORB. </li><li>  The client ORB sends a message over the network to the server and blocks the current thread of execution. </li><li>  The server ORB receives a request message and creates an instance of the skeleton. </li><li>  The skeleton executes the procedure in the callee. </li><li>  The callee performs the calculations and returns the result. </li><li>  The skeleton packs the output arguments into the reply message and passes it to the ORB. </li><li>  ORB sends a message over the network to the client. </li><li>  The client ORB receives the message, unpacks and transmits the information to the stub. </li><li>  The stub passes the output arguments to the caller, unblocks the execution thread, and the caller continues its work. </li></ol><br><h3 id="dostoinstva">  Virtues </h3><br><ul><li>  Independence from selected technologies (apart from the ORB implementation). </li><li>  Independence from data transmission / communication features. </li></ul><br><h3 id="nedostatki">  disadvantages </h3><br><ul><li>  <strong>Location independence</strong> : client code has no idea whether the call is local or remote.  It sounds good, but the duration of the delay and the types of failures can vary greatly.  If we don‚Äôt know what a call we have, then the application cannot choose the appropriate strategy for handling method calls, and therefore generate remote calls within the loop.  As a result, the entire system is slower. </li><li>  <strong>Difficult, bloated and ambiguous specification</strong> : it was assembled from several versions of specifications from different vendors, so (at that time) it was bloated, ambiguous and difficult to implement. </li><li>  <strong>Blocked communication pipes</strong> : specific protocols are used on top of TCP / IP, as well as specific ports (or even random ports).  But corporate security rules and firewalls often allow HTTP connections only through port 80, blocking CORBA data exchanges. </li></ul><br><h2 id="veb-servisy">  Web services </h2><br><p>  Although today you can find an application for CORBA, but we know that <strong>it was necessary to reduce the number of remote calls</strong> in order to improve system performance.  It also <strong>required a reliable communication channel and a simpler messaging specification</strong> . </p><br><p>  And to solve these problems, web services began to appear in the late 1990s. </p><br><ul><li>  <em><strong>A</strong> <u>reliable communication channel</u> <strong>was needed</strong> , therefore:</em> <br><ul><li>  HTTP was the default to work on port 80. </li><li>  They began using a platform-independent language (like XML or JSON) for messaging. </li></ul></li><li>  <em><strong>It was necessary to</strong> <u>reduce the number of remote hits</u> , so:</em> <br><ul><li>  Remote connections have become explicit, so now we always know when a remote call is being made. </li><li>  Instead of numerous remote calls of objects, we turn to remote services, but much less often. </li></ul></li><li>  <em><strong>It was necessary to</strong> <u>simplify the messaging specification</u> , therefore:</em> <br><ul><li>  The first draft of SOAP appeared in 1998, became a recommendation of the W3C in 2003, after which it became a standard.  SOAP has incorporated some of the CORBA ideas, such as the messaging layer and the ‚Äúdocument‚Äù that defines the interface using the <em>Web Services Description Language (WSDL</em> ). </li><li>  Roy Fielding in 2000 described REST in his dissertation, " <em>Architectural Design and Network-based Software Architectures</em> ."  Its specification turned out to be much simpler than SOAP, so soon REST overtook SOAP in popularity. </li><li>  Facebook developed GraphQL in 2012, and released the public release in 2015.  This is the request language for the API, which allows the client to strictly determine what data the server should send to him, no more and no less. </li></ul></li></ul><br><blockquote>  [Web-based] services can be published, found and used in a standard way, regardless of technology. <br>  - Microsoft 2004, <a href="https://msdn.microsoft.com/en-us/library/aa480021.aspx">Understanding Service-Oriented Architecture</a> </blockquote><p><img src="https://habrastorage.org/webt/tn/rg/6n/tnrg6nuedds0qf8k10y23ap29ju.png"></p><br><p>  Thanks to microservices, we have moved in the SOA paradigm from remote invocation of object methods (CORBA) to the transfer of messages between services. </p><br><p>  But you need to understand that within the framework of SOA, web services are not just general-purpose APIs, just providing CRUD access to the database via HTTP.  In some cases, this implementation may be useful, <em>but for the sake of the integrity of your data, it is necessary that users understand the underlying model of the implementation and follow the business rules</em> .  SOA implies that web services are limited to business subdomain contexts (business sub-domain) and separates the implementation from tasks solved by web services. </p><br><blockquote>  From the point of view of SOA technologies, it‚Äôs not just a service architecture, but a set of policies, methods and frameworks, thanks to which we provide and receive the necessary services. <br>  - Microsoft 2004, <a href="https://msdn.microsoft.com/en-us/library/aa480021.aspx">Understanding Service-Oriented Architecture</a> </blockquote><br><h3 id="dostoinstva-1">  Virtues </h3><br><ul><li>  The independence of a set of technologies, deployment and scalability of services. </li><li>  Standard, simple and reliable communication channel (text transmission via HTTP through port 80). </li><li>  Optimized messaging. </li><li>  Stable messaging specification. </li><li>  Isolation of contexts of domains (Domain contexts). </li></ul><br><h3 id="nedostatki-1">  disadvantages </h3><br><ul><li>  Different web services are difficult to integrate due to differences in messaging languages.  For example, two web services using different JSON representations of the same concept. </li><li>  Synchronous messaging can overload systems. </li></ul><br><h2 id="ochered-soobscheniy">  Message queue </h2><br><p>  We have several applications that asynchronously communicate with each other using platform-independent messages.  Message Queuing improves scalability and increases application isolation.  They do not need to know where other applications are located, how many of them, and even what they are.  However, all these applications must use the same messaging language, that is, a predefined text-based presentation format. </p><br><p>  The message queue uses the program message broker (RabbitMQ, Beanstalkd, Kafka, etc.) as an infrastructure component.  To implement communication between applications, you can configure the queue in different ways: </p><br><ul><li><p>  <strong>Request / Reply</strong> </p><br><ul><li>  The client sends a message to the queue, including a link to the <em>"conversation" (reference) reference</em> .  A message arrives at a special node that responds to the sender with another message, which refers to the same <em>conversation</em> , so the recipient knows which <em>conversation the</em> message refers to and can continue to act.  This is very useful for business processes of medium and long duration (chains of events, <strong>sagas</strong> ). </li></ul><br></li><li>  <strong>Publish / Subscribe</strong> <br><ul><li>  <strong>By lists</strong> <br>  The queue maintains lists of published topics of subscriptions (topics) and their subscribers.  When the queue receives a message for a topic, it places it in the appropriate list.  A message is matched to a topic by message type or by a predetermined set of criteria, including the content of the message. </li><li>  <strong>Based on broadcast</strong> <br>  When a queue receives a message, it broadcasts it to all nodes listening on the queue.  Nodes should filter the data themselves and process only messages of interest. </li></ul></li></ul><br><p><img src="https://habrastorage.org/webt/-2/2j/yu/-22jyuc5hhvxlpoq2rxcrcgxff0.jpeg"></p><br><p>  All these patterns can be attributed to either a <em>pull- (polling)</em> or a <em>push</em> approach: </p><br><ul><li>  In a pull script, the client polls the queue with a certain frequency.  The client controls his load, but there may be a delay: the message is already in the queue, and the client is not processing it yet, because the time for the next poll of the queue has not come. </li><li>  In a push script, the queue immediately gives customers messages as they arrive.  There is no delay, but customers do not manage their load. </li></ul><br><h3 id="dostoinstva-2">  Virtues </h3><br><ul><li>  The independence of a set of technologies, deployment and scalability of services. </li><li>  Standard, simple and reliable communication channel (text transmission via HTTP through port 80). </li><li>  Optimized messaging. </li><li>  Stable messaging specification. </li><li>  Domain contexts isolation. </li><li>  Easy to connect and disconnect services. </li><li>  Asynchronous messaging helps manage system load. </li></ul><br><h3 id="nedostatki-2">  disadvantages </h3><br><ul><li>  Different web services are difficult to integrate due to differences in messaging languages.  For example, two web services using different JSON representations of the same concept. </li></ul><br><h2 id="servisnaya-shina-predpriyatiya-esb">  Service Bus Enterprise (ESB) </h2><br><p>  The company's service bus used web services already in the 1990s, when they were first developed (perhaps some implementations first used CORBA?). </p><br><p> The ESB came into being at a time when companies had separate applications.  For example, one for working with finance, the other for personnel accounting, the third for warehouse management, etc., and they needed to be somehow connected with each other, somehow integrated.  But all these applications were created without integration, there was no standard language for application interaction (as it is today).  Therefore, application developers provided endpoints for sending and receiving data in a specific format.  The client companies then integrated the applications, establishing communication channels between them and transforming messages from one application language into another. </p><br><p>  A message queue can simplify the interaction of applications, but it is not able to solve the problem of different language formats.  However, an attempt was made to turn the message queue from a simple communication channel into an intermediary, delivering messages and transforming them into the necessary formats / languages.  ESB was the next step in the natural evolution of a simple message queue. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mo/x7/mq/mox7mqycewpvzbieykuq1nvtieg.png"></div><br><p>  This architecture uses a modular application (composite application), usually user-oriented, which communicates with web services to perform some operations.  In turn, these web services can also communicate with other web services, subsequently returning some data to the application.  But neither the application nor the back-end services know anything about each other, including the location and communication protocols.  They know only what service they want to contact and where the service bus is located. </p><br><p>  The client (service or modular application) sends a request to the service bus, which <strong>converts the</strong> message to the format supported at the destination, and forwards the request to it.  <strong>All</strong> interaction goes through the service bus, so if it falls, then all the other systems fall with it.  That is, the ESB is a key intermediary, a very complex component of the system. </p><br><p>  This is a very simplified description of the ESB architecture.  Moreover, while the ESB is the main component of the architecture, other components can be used in the system, such as Domain Brokers, Data Services, Process Orchestration Services and Rules Engine.  The same pattern can use an integrated architecture (federated design): the system is divided into business domains with its ESBs, and all the ESBs are connected to each other.  Such a scheme has higher performance and there is no single point of failure: if some ESB falls, only its business domain will suffer. </p><br><p><img src="https://habrastorage.org/webt/cf/7q/je/cf7qjezxptvy46r8kvil8ehec64.jpeg"></p><br><p>  ESB main responsibilities: </p><br><ul><li>  Track and route messaging between services. </li><li>  Convert messages between communicating service components. </li><li>  Manage the deployment and versioning of services. </li><li>  Manage the use of redundant services. </li><li>  Provide standard event processing, data conversion and mapping services, message and event queue services, security or exception handling services, protocol conversion services and ensuring the required quality of communication. </li></ul><br><blockquote>  Creating structures of communication between different processes, we saw a lot of products and approaches, which use highly developed communication mechanisms.  A good example is enterprise service buses, often incorporating sophisticated message routing, choreography, transformation, and business rule enforcement. <br>  - Martin Fowler 2014, <a href="https://martinfowler.com/articles/microservices.html">Microservices</a> </blockquote><p>  This architectural pattern has positive sides.  However, I find it particularly useful in cases where we do not ‚Äúown‚Äù web services and we need an intermediary for translating messages between services, for orchestrating business processes using several web services, and other tasks. </p><br><p>  I also recommend not to forget that ESB implementations are already quite developed and in most cases allow using a user interface with drag &amp; drop support for their configuration. </p><br><h3 id="dostoinstva-3">  Virtues </h3><br><ul><li>  The independence of a set of technologies, deployment and scalability of services. </li><li>  Standard, simple and reliable communication channel (text transmission via HTTP through port 80). </li><li>  Optimized messaging. </li><li>  Stable messaging specification. </li><li>  Domain contexts isolation. </li><li>  Easy to connect and disconnect services. </li><li>  Asynchronous messaging helps manage system load. </li><li>  A single point to control versioning and conversion. </li></ul><br><h3 id="nedostatki-3">  disadvantages </h3><br><ul><li>  Lower communication speed, especially between already compatible services. </li><li>  Centralized logic: <br><ul><li>  A single point of failure that can bring down the communications systems of the entire company. </li><li>  Greater complexity of configuration and support. </li><li>  Over time, you can come to storage in the ESB business rules. </li><li>  The bus is so complex that you need a whole team to control it. </li><li>  High dependence of services on ESB. </li></ul></li></ul><br><h2 id="mikroservisy">  Microservices </h2><br><p>  At the heart of the microservice architecture are the concepts of SOA.  Its purpose is the same as that of the ESB: create a single, common corporate application from several specialized business domain applications. </p><br><p>  The main difference between microservices and buses is that the ESB was created in the context of <strong>integrating individual applications</strong> so that a single corporate distributed application is obtained.  And the microservice architecture was created in the context of rapidly and constantly changing <strong>businesses, which (mostly) build their own cloud applications from scratch.</strong> </p><br><p>  That is, in the case of the ESB, we <strong>already had applications that we do not ‚Äúown‚Äù</strong> , and therefore we could not change them.  And in the case of microservices, we <strong>completely control the applications</strong> (at the same time, third-party web services can be used in the system). </p><br><p>  The nature of building / designing microservices does not require deep integration.  Microservices must comply with the business concept, limited context.  They must maintain their state, be independent of other microservices, and therefore they need less integration.  That is, low interdependence and high connectivity have led to a remarkable side effect - reducing the need for integration. </p><br><blockquote>  [Microservices are] small autonomous services that work together and are designed around a business domain. <br>  - Sam Newman 2015, <a href="https://youtu.be/PFQnNFe27kU%3Ft%3D1m50s">Principles Of Microservices</a> </blockquote><p>  The main drawback of the ESB architecture was a very complex centralized application, on which all other applications depended.  And in the microservice architecture, this application is almost completely removed. </p><br><p>  There are still elements that permeate the entire ecosystem of microservices.  But they have far fewer tasks compared to ESB.  For example, a message queue is still used for asynchronous communication between microservices, but this is only a channel for transmitting messages, nothing more.  Or you can recall the microservice ecosystem gateway, through which all external data exchange passes. </p><br><p>  Sam Newman, author of <em>Building Microservices</em> , outlines eight principles of microservice architecture.  It: </p><br><ul><li>  <strong>Designing services around business domains</strong> <br>  This can give us stable interfaces, highly interconnected and little-dependent code modules, as well as well-defined demarcated contexts. </li><li>  <strong>Automation culture</strong> <br>  This will give us much more freedom, we will be able to deploy more modules. </li><li>  <strong>Hiding implementation details</strong> <br>  This allows services to evolve independently of each other. </li><li>  <strong>Full decentralization</strong> <br>  Decentralize decision making and architectural concepts, provide teams with autonomy so that the company itself becomes a complex adaptive system capable of quickly adapting to change. </li><li>  <strong>Independent deployment</strong> <br>  You can deploy a new version of the service without changing anything else. </li><li>  <strong>First consumer</strong> <br>  The service should be easy to use, including other services. </li><li>  <strong>Fault Isolation</strong> <br>  If one service falls, others continue to work, it makes the whole system resilient to failure. </li><li>  <strong>Easy monitoring</strong> <br>  There are many components in the system, so it is difficult to keep track of everything that happens in it.  We need sophisticated monitoring tools to look into every corner of the system and track any chain of events. </li></ul><br><p><img src="https://habrastorage.org/webt/8i/3n/_1/8i3n_1w4bdgvpesqlwcj6v2p1ak.jpeg"></p><br><blockquote>  The community prefers a different approach: <strong>smart endpoints and stupid channels</strong> .  Microservices from which applications are assembled should depend as little as possible from each other and at the same time be very closely connected - they contain their own domain logic and work more like filters from the point of view of classic Unix: they receive requests, apply logic and generate responses.  They are orchestrated using simple REST-like protocols, rather than complex protocols like WS-Choreography or BPEL or some kind of centralized tool. <br>  - Martin Fowler 2014, <a href="https://martinfowler.com/articles/microservices.html">Microservices</a> </blockquote><br><h3 id="dostoinstva-4">  Virtues </h3><br><ul><li>  The independence of a set of technologies, deployment and scalability of services. </li><li>  Standard, simple and reliable communication channel (text transmission via HTTP through port 80). </li><li>  Optimized messaging. </li><li>  Stable messaging specification. </li><li>  Domain contexts isolation. </li><li>  Easy to connect and disconnect services. </li><li>  Asynchronous messaging helps manage system load. </li><li>  Synchronous messaging helps manage system performance. </li><li>  Fully independent and autonomous services. </li><li>  Business logic is stored only in services. </li><li>  Allow the company to turn into a complex adaptive system consisting of several small autonomous parts / teams that can quickly adapt to change. </li></ul><br><h3 id="nedostatki-4">  disadvantages </h3><br><ul><li>  <strong>High complexity of operation:</strong> <br><ul><li>  You need to invest a lot in a strong DevOps culture. </li><li>  The use of numerous technologies and libraries can get out of control. </li><li>  You need to carefully manage the input / output API changes, because many of the applications will use these interfaces. </li><li>  The use of ‚Äúeventual consistency‚Äù can lead to serious consequences that need to be considered when developing an application, from backend to UX. </li><li>  Testing is complicated because changes in the interface can unpredictably affect other services. </li></ul></li></ul><br><h2 id="antipattern-arhitektura-ravioli-ravioli-architecture">  Antipattern: Ravioli Architecture (Ravioli Architecture) </h2><br><p><img src="https://habrastorage.org/webt/px/xx/q5/pxxxq5vecno8nbyowf3czlgsmte.png"></p><br><p>  <em>The architecture of ravioli is</em> usually called the anti-pattern microservice architecture.  Ravioli are obtained, if there are too many microservices, they are too small and do not reflect domain concepts. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  In recent decades, SOA has evolved greatly.  Due to the inefficiency of previous solutions and the development of technology, today we have come to a microservice architecture. </p><br><p>  Evolution went along the classical path: complex problems were broken up into smaller, simpler ones to solve. </p><br><p>  The problem of code complexity can be solved just as we break a monolithic application into separate domain components (delineated contexts).  But with the growth of teams and code base, the need for independent development, scaling and deployment increases.  SOA helps achieve this independence by strengthening the boundaries of contexts. </p><br><p><img src="https://habrastorage.org/webt/4a/gv/pl/4agvpldhyy4ztsmtq6ls4a7rdw4.png"></p><br><p>  I repeat that the whole thing is a weak interdependence and high connectivity, and the size of the components must be greater than the former.  You need to pragmatically assess your needs: use SOA only when necessary, because it greatly increases the complexity.  And if in fact you can do without SOA, then it is better to choose microservices of the appropriate size and quantity, no more and no less. </p><br><h2 id="istochniki">  Sources </h2><br><p>  1997 - Steve Vinoski - <a href="http%253A%252F%252Fwww.cs.wustl.edu%252F~schmidt%252FPDF%252Fvinoski.pdf%26usg%3DAFQjCNGHgp0XUqdxj7IF5pKEGNr8KSop2A%26sig2%3D5dDa9AU9WVrxa7d64Ih88g%26bvm%3Dbv.148073327,d.bGg">CORBA: Integrating Diverse Applications Within Distributed Heterogeneous Environments</a> <br>  2000 - Roy Fielding - <a href="https%253A%252F%252Fwww.ics.uci.edu%252F~fielding%252Fpubs%252Fdissertation%252Ffielding_dissertation.pdf%26usg%3DAFQjCNEEwS3STct3jnKXToOQXO15Q4cY1g%26sig2%3D7B1V07RRh9X6vFTcFVRMVQ">Network-based Software Architects</a> <br>  2004 - Microsoft - <a href="https://msdn.microsoft.com/en-us/library/ff647328.aspx">Message Bus</a> <br>  2004 - Microsoft - <a href="https://msdn.microsoft.com/en-us/library/aa480021.aspx">Understanding Service-Oriented Architecture</a> <br>  2011 - Chris Ostrowski - <a href="https://www.youtube.com/watch%3Fv%3D0hyXOuvyq2Q">Understanding Oracle SOA - Part 1 - Architecture</a> <br>  2011 - Chris Ostrowski - <a href="https://www.youtube.com/watch%3Fv%3DzNvyCUO0dyw">Understanding Oracle SOA - Part 2 - Technologies</a> <br>  2011 - Chris Ostrowski - <a href="https://www.youtube.com/watch%3Fv%3D0J4iHaUOpzU">Understanding Oracle SOA - Part 3 - Development</a> <br>  2011 - Chris Ostrowski - <a href="https://www.youtube.com/watch%3Fv%3Dt9-kj1veqXk">Understanding Oracle SOA - Part 4 - Business Benefits</a> <br>  2012 - Prabhu - <a href="http://www.mudskipper-solutions.com/home/service-oriented-architecture-soa">Service Oriented Architecture - SOA</a> <br>  2014 - Martin Fowler - <a href="https://martinfowler.com/articles/microservices.html">Microservices</a> <br>  2014 - PWC - <a href="http://www.pwc.com/us/en/technology-forecast/2014/cloud-computing/features/microservices.html">Agile coding in enterprise IT: Code small and local</a> <br>  2015 - Udi Dahan - <a href="https://www.youtube.com/watch%3Fv%3DCVc3d4hrH6Y">Messaging Architecture and Services Bus</a> <br>  2015 - Sam Newman - <a href="https://www.youtube.com/watch%3Fv%3DPFQnNFe27kU">Principles Of Microservices</a> <br>  2016 - Kai W√§hner - <a href="https://www.youtube.com/watch%3Fv%3DfITFdDU5L9w">Microservices: Death of the Enterprise Service Bus?</a> <br>  2016 - Abraham Mar√≠n P√©rez - <a href="https://www.infoq.com/news/2016/06/corba-removed-java-9">Java 9 Will Remove CORBA from Default Classpath</a> <br>  2016 - Oracle - <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/idl/corba.html">CORBA Technology and the Java Platform Standard Edition</a> <br>  2017 - Wikipedia - <a href="https://en.wikipedia.org/wiki/Distributed_object_communication">Distributed object communication</a> <br>  2017 - Wikipedia - <a href="https://ru.wikipedia.org/wiki/CORBA">CORBA</a> <br>  2017 - Wikipedia - <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D1%2580%25D0%25B2%25D0%25B8%25D1%2581%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2588%25D0%25B8%25D0%25BD%25D0%25B0_%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D0%25BF%25D1%2580%25D0%25B8%25D1%258F%25D1%2582%25D0%25B8%25D1%258F">Enterprise Service Tire</a> <br>  2017 - Wikipedia - <a href="https://ru.wikipedia.org/wiki/REST">REST</a> <br>  2017 - Wikipedia - <a href="https://ru.wikipedia.org/wiki/SOAP">SOAP</a> <br>  2017 - Wikipedia - <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D1%2580%25D0%25B2%25D0%25B8%25D1%2581-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B0%25D1%2580%25D1%2585%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0">Service Oriented Architecture</a> <br>  2017 - Microsoft - <a href="https://msdn.microsoft.com/en-us/library/bb833022.aspx">Enterprise Architecture: SOA in the real world</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/342526/">https://habr.com/ru/post/342526/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../342512/index.html">‚ÄúHello, World!‚Äù For novice writers</a></li>
<li><a href="../342514/index.html">How White Label helps in the development of services and products. 5 examples</a></li>
<li><a href="../342516/index.html">Key announcements Connect (); 2017</a></li>
<li><a href="../342518/index.html">Why programmers don't get jobs: four horror stories</a></li>
<li><a href="../342524/index.html">Experience developing low power devices on the STM32L</a></li>
<li><a href="../342528/index.html">Video of reports from the Agile Kitchen conference in M.Video</a></li>
<li><a href="../342530/index.html">It fell by itself, or the consequence are the cones</a></li>
<li><a href="../342532/index.html">51% attack or pocket guide for the Chinese government</a></li>
<li><a href="../342534/index.html">Dive into ICO</a></li>
<li><a href="../342536/index.html">Container Management Tools</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>