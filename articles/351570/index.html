<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rust: try overloading functions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rust does not have function overloading: you cannot define two functions that have the same name. The compiler will display a message that you have a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rust: try overloading functions</h1><div class="post__text post__text-html js-mediator-article"><p>  Rust does not have function overloading: you cannot define two functions that have the same name.  The compiler will display a message that you have a double assignment of the same definition, even if they contain different types of arguments. </p><br><p>  After several attempts, the problem was successfully solved.  How - under the cut. </p><a name="habracut"></a><br><p>  Games with types do not work. </p><br><pre><code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooA</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(_: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooB</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(_: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> FooA <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Foo { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(_: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"FooA"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> FooB <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Foo { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(_: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"FooB"</span></span>); } }</code> </pre> <br><p>  Let's try to call a function with an argument of type <code>&amp;str</code> . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { Foo::foo(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); }</code> </pre> <br><p>  It does not compile, because the call is ambiguous and Rust does not try to figure out which of their functions ‚Äî depending on the types / number of arguments ‚Äî is called.  If we run this code, the compiler will report that there are several functions that can be called in this case. </p><br><p>  On the contrary, this example requires an unambiguous indication of the called function: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { &lt;Foo <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> FooB&gt;::foo(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); }</code> </pre> <br><p>  <a href="https://play.rust-lang.org/%3Fgist%3D9df9128c20b9c612806223dd91a70de0%26amp%3Bversion%3Dstable">Code</a> </p><br><p>  However, this negates all the benefits of overloading.  At the end of this note, I will show that Rust implements the traditional overloading of functions - through the use of types and generic programming - generics. </p><br><h2 id="staticheskiy-polimorfizm">  Static polymorphism </h2><br><p>  To allow the method to accept various types of arguments, Rust uses static polymorphism with generics. </p><br><p>  The generic parameter is limited by type: the function accepts only arguments of such types that implement the required types.  Description imposes restrictions on a set of actions that you can do in relation to an argument. </p><br><p>  They can be as simple as <code>AsRef</code> , for example, to allow your API to take more options for arguments: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_bytes</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">AsRef</span></span>&lt;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]&gt;&gt;(bytes: T) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{:?}"</span></span>, bytes.as_ref()); }</code> </pre> <br><p>  In the calling code, this looks like overloading: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { print_bytes(<span class="hljs-string"><span class="hljs-string">"hello world"</span></span>); print_bytes(&amp;[<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">39</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">91</span></span>]); }</code> </pre> <br><p>  <a href="https://play.rust-lang.org/%3Fgist%3D7286491e1d741d0817eb7868bb1d41fc%26amp%3Bversion%3Dstable">Code</a> </p><br><p>  Probably the best example of this is taking several types of arguments. <br>  <a href="https://doc.rust-lang.org/std/string/trait.ToString.html">type</a> <code>ToString</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_str</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">ToString</span></span>&gt;(value: T) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s = value.to_string(); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, s); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { print_str(<span class="hljs-number"><span class="hljs-number">42</span></span>); print_str(<span class="hljs-number"><span class="hljs-number">3.141593</span></span>); print_str(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); print_str(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); print_str(''); }</code> </pre> <br><p>  <a href="https://play.rust-lang.org/%3Fgist%3Da02e3e28783ddc33ff07ec92db600422%26amp%3Bversion%3Dstable">Code</a> </p><br><p>  This kind of overload makes your API more convenient for your users to use.  They will not need to burden themselves with translating arguments into the necessary type, the API does not require this.  The result is an API that is a pleasure to work with. </p><br><p>  This approach has advantages in comparison with the usual overload, because the implementation of types (user) types allows your API to accept different user types. </p><br><p>  The familiar overload offers much more flexibility in the implementation and in the number of arguments taken in the overloaded functions.  The latter problem can be solved by using tuples as a container for a set of arguments, but this is not very attractive.  An example of this is the <a href="https://doc.rust-lang.org/std/net/trait.ToSocketAddrs.html">type</a> <code>ToSocketAddrs</code> in the standard library. </p><br><h2 id="intermediya-izbytochnyy-generic-kod">  Intermedia: redundant generic code </h2><br><p>  Be wary of clogging with excessive generic code.  If you have a generic function with a large number of non-trivial code, then for each call of this function with arguments of different types, specialized copies of the functions are created.  This happens even if every time at the beginning of the function you translate input arguments into variables of the desired types. </p><br><p>  Fortunately, there is a simple solution to the problem: implementing a private function without generics that accepts the types you want to work with.  While public functions do type conversions and pass on the execution of your private function: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> stats { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stddev</span></span></span></span>&lt;T: ?<span class="hljs-built_in"><span class="hljs-built_in">Sized</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">AsRef</span></span>&lt;[<span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>]&gt;&gt;(values: &amp;T) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span> { stddev_impl(values.as_ref()) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stddev_impl</span></span></span></span>(values: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>]) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> len = values.len() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum: <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span> = values.iter().cloned().sum(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mean = sum / len; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var = values.iter().fold(<span class="hljs-number"><span class="hljs-number">0f64</span></span>, |acc, &amp;x| acc + (x - mean) * (x - mean)) / len; var.sqrt() } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> stats::stddev;</code> </pre> <br><p>  Although the function is called with two different types ( <code>&amp;[f64]</code> and <code>&amp;Vec&lt;f64&gt;</code> ), the main logic of the function is implemented (and compiled) only once, which prevents excessive swelling of the binaries. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = stddev(&amp;[<span class="hljs-number"><span class="hljs-number">600.0</span></span>, <span class="hljs-number"><span class="hljs-number">470.0</span></span>, <span class="hljs-number"><span class="hljs-number">170.0</span></span>, <span class="hljs-number"><span class="hljs-number">430.0</span></span>, <span class="hljs-number"><span class="hljs-number">300.0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = stddev(&amp;<span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[<span class="hljs-number"><span class="hljs-number">600.0</span></span>, <span class="hljs-number"><span class="hljs-number">470.0</span></span>, <span class="hljs-number"><span class="hljs-number">170.0</span></span>, <span class="hljs-number"><span class="hljs-number">430.0</span></span>, <span class="hljs-number"><span class="hljs-number">300.0</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(a, b); }</code> </pre> <br><p>  <a href="https://play.rust-lang.org/%3Fgist%3D91dd76eca898115a3bea4dc39d1695c9%26amp%3Bversion%3Dstable">Code</a> </p><br><h2 id="proveryaem-granicy">  Checking borders </h2><br><p>  Not every overload falls into this category of simple argument conversions.  Sometimes you really need different logic to handle different sets of arguments taken.  For these cases, you can define your own type to implement the program logic of your function: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span>(<span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomFoo</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">custom_foo</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, this: &amp;Foo); }</code> </pre> <br><p>  This makes the type very clumsy, for <code>self</code> and arguments are swapped: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> CustomFoo <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">custom_foo</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, this: &amp;Foo) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Foo({}) i32: {}"</span></span>, this.<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> CustomFoo <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">custom_foo</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, this: &amp;Foo) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Foo({}) char: {}"</span></span>, this.<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, S: <span class="hljs-built_in"><span class="hljs-built_in">AsRef</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; + ?sized&gt; CustomFoo <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> S { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">custom_foo</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, this: &amp;Foo) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Foo({}) str: {}"</span></span>, this.<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.as_ref()); } }</code> </pre> <br><p>  Description cannot be hidden as an implementation detail.  If you decide to make the type private, the compiler will output the following: <code>private trait in public interface</code> . </p><br><p>  Let's make a wrapper over the type: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span>(<span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Foo { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;T: CustomFoo&gt;(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, arg: T) { arg.custom_foo(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { Foo(<span class="hljs-literal"><span class="hljs-literal">false</span></span>).foo(<span class="hljs-number"><span class="hljs-number">13</span></span>); Foo(<span class="hljs-literal"><span class="hljs-literal">true</span></span>).foo('')); Foo(<span class="hljs-literal"><span class="hljs-literal">true</span></span>).foo(<span class="hljs-string"><span class="hljs-string">"baz"</span></span>); }</code> </pre> <br><p>  <a href="https://play.rust-lang.org/%3Fgist%3D83347c7604dc08886f32cdd1395a889e%26amp%3Bversion%3Dstable">Code</a> </p><br><p>  The application of this technique can be found in the standard library in the <code>Pattern</code> , which is used by various <a href="https://doc.rust-lang.org/std/primitive.str.html">functions</a> that search for or in some way match strings, for example, <code>str::find</code> . </p><br><p>  Unlike you, the standard library has the ability to hide these types, while at the same time allowing them to be used in public interfaces by means of the <code>#[unstable]</code> attribute. </p><br><h2 id="popast-odnim-vystrelom-v-dvuh-zaycev">  Get one shot in two birds with one stone </h2><br><p>  There is a better way that will give us almost all the features of common function overload. </p><br><p>  Create a type for the function whose signature you want to reload with generalized parameters in the place of the "overloaded" parameters. </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OverloadedFoo</span></span></span></span>&lt;T, U&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">overloaded_foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, tee: T, yu: U); }</code> </pre> <br><p>  Restrictions on types in Rust are very powerful tools. </p><br><p>  When implementing the method, simply restrict <code>Self</code> to implement the type and generalized parameters that your type needs.  For Rust, this is enough: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Foo { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;T, U&gt;(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, tee: T, yu: U) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>: OverloadedFoo&lt;T, U&gt; { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.overloaded_foo(tee, yu) } }</code> </pre> <br><p>  After that, implement the type for all types for which you want to provide an overload: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> OverloadedFoo&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Foo { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">overloaded_foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, tee: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, yu: <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"foo&lt;i32, f32&gt;(tee: {}, yu: {})"</span></span>, tee, yu); } }</code> </pre> <br><p>  They may be empty implementing blocks.  Make sure that the types are consistent with each other.  Compiler messages are very helpful here. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, S: <span class="hljs-built_in"><span class="hljs-built_in">AsRef</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; + ?<span class="hljs-built_in"><span class="hljs-built_in">Sized</span></span>&gt; OverloadedFoo&lt;&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> S, <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Foo { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">overloaded_foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, tee: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> S, yu: <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"foo&lt;&amp;str, char&gt;(tee: {}, yu: {})"</span></span>, tee.as_ref(), yu); } }</code> </pre> <br><p>  It's all! </p><br><p>  Try removing the comment from the last line and look at the error message when the function is called with arguments for which there is no corresponding signature. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { Foo.foo(<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">3.14159</span></span>); Foo.foo(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>, ''); <span class="hljs-comment"><span class="hljs-comment">// Foo.foo('', 13); //     }</span></span></code> </pre> <br><p>  <a href="https://play.rust-lang.org/%3Fgist%3D880fae763e1c7c6f3b7c8619b6c97867%26amp%3Bversion%3Dstable">Code</a> </p><br><h1 id="vyvod">  Conclusion </h1><br><p>  As always, the way you choose to get the effect of overloading functions depends on your needs.  I set myself the goal of examining several techniques for emulating overload and limiting them so that you can make the right decision on its use in your code. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/351570/">https://habr.com/ru/post/351570/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351558/index.html">Jessica Livingston (Y Combinator): ‚ÄúThe Sound of Silence‚Äù</a></li>
<li><a href="../351562/index.html">From patches in the fight against malware to a holistic strategy</a></li>
<li><a href="../351564/index.html">Wireless LANs or how Wi-Fi works according to IEEE 802.11 standard. Lab at Packet Tracer</a></li>
<li><a href="../351566/index.html">A few tips on organizing a Python application on the server</a></li>
<li><a href="../351568/index.html">Minimal multiboot bootloader</a></li>
<li><a href="../351572/index.html">CleanTalk Malware Scanner - Heuristic Code Analysis</a></li>
<li><a href="../351574/index.html">Convert IP range to Classless Addressing (CIDR) and back to Go</a></li>
<li><a href="../351576/index.html">13 reasons to switch to Kanban. And no superstition</a></li>
<li><a href="../351580/index.html">One million plus one equals one million. Theory of Relativity of the Natural Series</a></li>
<li><a href="../351582/index.html">Impressions of Teamlead Conf 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>