<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Another Monad Guide (part 4: Maybe Monad and list monad)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="By mike vanier 

 In previous articles in this series, we studied the conceptual basis of monads, but our discussion was too abstract. Now that you, I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Another Monad Guide (part 4: Maybe Monad and list monad)</h1><div class="post__text post__text-html js-mediator-article">  By mike vanier <br><br>  In previous articles in this series, we studied the conceptual basis of monads, but our discussion was too abstract.  Now that you, I hope, have understood what monads are and what they are for, the time has come for a detailed examination of specific monads.  This means that we define the correct embodiments of the <font color="blue">Monad</font> type class for the many different concepts of computation that we saw before.  We use our knowledge to get a monadic composition in each case through monadic application (operator <font color="blue">&gt;&gt; =</font> ), and using monadic laws we derive the definition of <font color="blue">return</font> . <br><a name="habracut"></a><br><h4>  Monad <font color="blue">Maybe</font> </h4><br><br>  <font color="blue">Maybe monad is</font> usually presented first in Haskell manuals, because it is very easy to use, implement and understand.  First, take a look at the definition of the <font color="blue">Maybe</font> data type: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  <font color="#06c">data</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Maybe</a></font> a <font color="#66cc66"><b>=</b></font> Nothing <font color="#339933">|</font>  Just a </blockquote><br><br>  Here it is stated that <font color="blue">Maybe</font> is a type constructor in which a specific type <font color="blue">a</font> is placed to get a (specific) data type.  They also say that <font color="blue">Maybe</font> is a ‚Äúpolymorphic‚Äù data type, the meaning is the same.  So, if <font color="blue">a</font> were an <font color="blue">Int</font> , we would get: <br><br><blockquote>  <font color="#06c">data</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Maybe</a></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Int</a></font> <font color="#66cc66"><b>=</b></font> Nothing <font color="#339933">|</font>  Just <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">int</a></font> </blockquote><br><br>  Only we don‚Äôt need to write it directly, since the abstract definition above applies to all types. <br><br>  A value of type <font color="blue">Maybe a</font> may or may not be present.  If the value is <font color="blue">Nothing</font> (‚ÄúNothing‚Äù), then it is ‚Äúas if not‚Äù, and if it is <font color="blue">Just x</font> for some value of <font color="blue">x</font> , then this is ‚Äújust‚Äù the value of <font color="blue">x</font> .  You can think of this as a container, in which either 0 elements or it is one.  (Recall that I once said that monadic values ‚Äã‚Äãare sometimes mistakenly represented as containers. This is the very case.) <br><br>  The <font color="blue">Maybe</font> polymorphic type is useful in that we can use it as a model of an ‚Äúextended function‚Äù that either produces something as an output value, or it crashes and cannot return any value.  (That is, such a function may fail.) It is written like this: <br><br><blockquote>  f <font color="#66cc66"><b>::</b></font> a <font color="#339933">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Maybe</a></font> b </blockquote><br><br>  The function <font color="blue">f</font> takes a value of type <font color="blue">a</font> and either returns <font color="blue">Nothing</font> (a sign of failure) or a value of <font color="blue">Just x</font> , where y <font color="blue">x is</font> type <font color="blue">b</font> .  Functions like <font color="blue">f</font> will work in the <font color="blue">Maybe</font> monad, and the composition of two such functions is as follows: <br><br><blockquote>  f <font color="#66cc66"><b>::</b></font> a <font color="#339933">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Maybe</a></font> b <font color="#5d478b">- we assume that f is somewhere defined</font> <br>  g <font color="#66cc66"><b>::</b></font> b <font color="#339933">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Maybe</a></font> c <font color="#5d478b">- we assume that g is somewhere defined</font> <br><br>  h <font color="#66cc66"><b>::</b></font> a <font color="#339933">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Maybe</a></font> c <font color="#5d478b">is the monadic composition f and g</font> <br>  h <font color="#66cc66"><b>=</b></font> f <font color="#339933">&gt; =&gt;</font> g <font color="#5d478b">- remember:&gt; =&gt; is the operator of a monadic composition</font> </blockquote><br><br>  We said that all monads must be type constructors.  <font color="blue">Maybe</font> is a type constructor, so everything is fine.  But in order for <font color="blue">Maybe to</font> become a monad, we need to create an instance of the <font color="blue">Monad</font> type class, which means that we have to fill in the following definition: <br><br><blockquote>  <font color="#06c">instance</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Monad</a></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Maybe</a></font> <font color="#06c">where</font> <br>  <font>(</font> <font color="#339933">&gt;&gt; =</font> <font>)</font> <font color="#66cc66"><b>=</b></font> <i><font color="#5d478b">{- definition &gt;&gt; = for Maybe -}</font></i> <br>  <font>return</font> <font color="#66cc66"><b>=</b></font> <i><font color="#5d478b">{- the definition for Maybe -}</font></i> </blockquote><br><br>  How can we set <font color="blue">(&gt;&gt; =)</font> and <font color="blue">return</font> for <font color="blue">Maybe</font> ? <br><br>  First, we write the definition framework for <font color="blue">&gt;&gt; =</font> , covering two possible cases of the left operand of type <font color="blue">Maybe a</font> : <br><br><blockquote>  Nothing <font color="#339933">&gt;&gt; =</font> f <font color="#66cc66"><b>=</b></font> <i><font color="#5d478b">{- you need to add -}</font></i> <br>  Just x <font color="#339933">&gt;&gt; =</font> f <font color="#66cc66"><b>=</b></font> <i><font color="#5d478b">{- you need to add -}</font></i> </blockquote><br><br>  where <font color="blue">x</font> is of type <font color="blue">a</font> .  The left part of the definition can be written in another way: <br><br><blockquote>  <font>(</font> <font color="#339933">&gt;&gt; =</font> <font>)</font> Nothing f <font color="#66cc66"><b>=</b></font> <i><font color="#5d478b">{- you need to add -}</font></i> <br>  <font>(</font> <font color="#339933">&gt;&gt; =</font> <font>)</font> <font>(</font> Just x <font>)</font> f <font color="#66cc66"><b>=</b></font> <i><font color="#5d478b">{- you need to add -}</font></i> </blockquote><br><br>  But it is better still if the operator <font color="blue">(&gt;&gt; =) is</font> specified as an operator, and not as a function, and Haskell allows us to. <br><br>  To complete this definition, let's think about what we want from the monadic composition in the <font color="blue">Maybe</font> monad.  Let's take our example with the functions <font color="blue">f</font> and <font color="blue">g</font> , monadically compose them and get the function <font color="blue">h</font> : <br><br><blockquote>  f <font color="#66cc66"><b>::</b></font> a <font color="#339933">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Maybe</a></font> b <br>  g <font color="#66cc66"><b>::</b></font> b <font color="#339933">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Maybe</a></font> c <br>  h <font color="#66cc66"><b>::</b></font> a <font color="#339933">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Maybe</a></font> c <br>  h <font color="#66cc66"><b>=</b></font> f <font color="#339933">&gt; =&gt;</font> g </blockquote><br><br>  If we pass an argument to the function <font color="blue">f</font> , and it returns <font color="blue">Nothing</font> (that is, it fails), then what should the function <font color="blue">h</font> return? <br><br><blockquote>  f x <font color="#66cc66"><b>=</b></font> Nothing <br>  h x <font color="#66cc66"><b>=</b></font> <font>(</font> f <font color="#339933">&gt; =&gt;</font> g <font>)</font> x <font color="#66cc66"><b>=</b></font> <font color="#339933">???</font> </blockquote><br><br>  It seems obvious that if <font color="blue">fx</font> returns <font color="blue">Nothing</font> , then <font color="blue">h</font> must also return <font color="blue">Nothing</font> , because if part of the expression (function <font color="blue">f</font> ) could not return the result, then the whole expression (function <font color="blue">h</font> ) cannot return it.  The only option when <font color="blue">h</font> returns a value is when <font color="blue">f</font> returns the result (let's call it <font color="blue">y</font> ), it will be passed to the function <font color="blue">g</font> , and <font color="blue">gy</font> will also have the correct result.  If <font color="blue">f</font> or <font color="blue">g</font> fails, then <font color="blue">h</font> will fail, that is, calculating <font color="blue">hx</font> will be <font color="blue">Nothing</font> . <br><br>  With this in mind, from our definition of <font color="blue">h</font> we get: <br><br><blockquote>  h <font color="#66cc66"><b>=</b></font> f <font color="#339933">&gt; =&gt;</font> g <br>  h <font color="#66cc66"><b>=</b></font> \ x <font color="#339933">-&gt;</font> <font>(</font> f x <font color="#339933">&gt;&gt; =</font> g <font>)</font> <font color="#5d478b">- equivalent (from definition&gt; =&gt;)</font> <br>  h x <font color="#66cc66"><b>=</b></font> f x <font color="#339933">&gt;&gt; =</font> g <font color="#5d478b">- equivalent</font> <br>  <font color="#5d478b">- assume that f x == Nothing</font> <br>  h x <font color="#66cc66"><b>=</b></font> <font>(</font> Nothing <font color="#339933">&gt;&gt; =</font> g <font>)</font> <br>  <font color="#66cc66"><b>=</b></font> Nothing <br>  <font color="#5d478b">-- in this way:</font> <br>  Nothing <font color="#339933">&gt;&gt; =</font> g <font color="#66cc66"><b>=</b></font> Nothing </blockquote><br><br>  Now we know how the <font color="blue">(&gt;&gt; =)</font> operator responds to the <font color="blue">Nothing</font> argument ‚Äî it simply returns the same <font color="blue">Nothing</font> : <br><br><blockquote>  Nothing <font color="#339933">&gt;&gt; =</font> f <font color="#66cc66"><b>=</b></font> Nothing <br>  Just x <font color="#339933">&gt;&gt; =</font> f <font color="#66cc66"><b>=</b></font> <i><font color="#5d478b">{- you need to add -}</font></i> </blockquote><br><br>  Please note, I replaced <font color="blue">g</font> with <font color="blue">f here</font> , and this is correct, because the names of the functions are not important.  In practice, we generally get rid of the function names, if possible, and replace them with the special operator <font color="blue">_</font> (underscore), like this: <br><br><blockquote>  Nothing <font color="#339933">&gt;&gt; =</font> <font color="#339933">_</font> <font color="#66cc66"><b>=</b></font> Nothing </blockquote><br><br>  With the second equation, this cannot be done, because we will also use the function <font color="blue">f</font> in the definition. <br><br>  Now let's get on the other side.  If <font color="blue">fx</font> <i>does not</i> fail, the result is the value <font color="blue">Just y</font> for some <font color="blue">y</font> .  We need to "unpack" the value of <font color="blue">y</font> from <font color="blue">Just y</font> , which we would then pass to the function <font color="blue">g</font> , and <font color="blue">gy</font> is the result of the whole function <font color="blue">h</font> : <br><br><blockquote>  h <font color="#66cc66"><b>=</b></font> f <font color="#339933">&gt; =&gt;</font> g <br>  h <font color="#66cc66"><b>=</b></font> \ x <font color="#339933">-&gt;</font> <font>(</font> f x <font color="#339933">&gt;&gt; =</font> g <font>)</font> <font color="#5d478b">- equivalent (from definition&gt; =&gt;)</font> <br>  h x <font color="#66cc66"><b>=</b></font> f x <font color="#339933">&gt;&gt; =</font> g <font color="#5d478b">- equivalent</font> <br>  <font color="#5d478b">- suppose that f x == Just y</font> <br>  h x <font color="#66cc66"><b>=</b></font> <font>(</font> Just y <font color="#339933">&gt;&gt; =</font> g <font>)</font> <br>  <font color="#66cc66"><b>=</b></font> g y </blockquote><br><br>  What gives us the second part of the definition: <br><br><blockquote>  Nothing <font color="#339933">&gt;&gt; =</font> f <font color="#66cc66"><b>=</b></font> Nothing <br>  Just x <font color="#339933">&gt;&gt; =</font> f <font color="#66cc66"><b>=</b></font> f x </blockquote><br><br>  Notice that I replaced <font color="blue">y</font> with <font color="blue">x</font> and <font color="blue">g</font> with <font color="blue">f</font> .  Again, the names of variables and functions do not matter as long as you are consistent. <br><br>  This completes the definition of the operator <font color="blue">&gt;&gt; =</font> for the <font color="blue">Maybe</font> monad.  Now we need to get a <font color="blue">return</font> for this monad: <br><br><blockquote>  <font>return</font> x <font color="#66cc66"><b>=</b></font> <font color="#339933">???</font> </blockquote><br><br>  for any value of <font color="blue">x</font> .  What options do we have?  We could just say that <br><br><blockquote>  <font>return</font> x <font color="#66cc66"><b>=</b></font> Nothing </blockquote><br><br>  for any <font color="blue">x</font> .  However, we would violate monad laws if we did: <br><br><blockquote>  <font>return</font> x <font color="#339933">&gt;&gt; =</font> f <font color="#339933">==</font> f x <br>  Nothing <font color="#339933">&gt;&gt; =</font> f <font color="#339933">==</font> f x <br>  Nothing <font color="#339933">==</font> f x <font color="#5d478b">- WRONG!</font> </blockquote><br><br>  Assuming that at least <i>some</i> <font color="blue">fx is</font> not <font color="blue">Nothing</font> (for example, consider the monadic function <font color="blue">fx</font> = <font color="blue">Just x</font> ), we get an error.  There is another option: <br><br><blockquote>  <font>return</font> x <font color="#66cc66"><b>=</b></font> Just x </blockquote><br><br>  and it satisfies the monad laws: <br><br><blockquote>  <font>return</font> x <font color="#339933">&gt;&gt; =</font> f <br>  <font color="#66cc66"><b>=</b></font> <font>(</font> Just x <font>)</font> <font color="#339933">&gt;&gt; =</font> f <font color="#5d478b">- by definition, return for Maybe monad</font> <br>  <font color="#66cc66"><b>=</b></font> f x <font color="#5d478b">- by definition &gt;&gt; = for Maybe monad</font> <br>  <font color="#5d478b">- implementation of the first monad law</font> <br><br>  Just x <font color="#339933">&gt;&gt; =</font> <font>return</font> <br>  <font color="#66cc66"><b>=</b></font> <font>return</font> x <font color="#5d478b">- by definition &gt;&gt; = for Maybe monad</font> <br>  <font color="#66cc66"><b>=</b></font> Just x <font color="#5d478b">- by definition, return for Maybe monad</font> <br>  <font color="#5d478b">- implementation of the second monad law</font> <br><br>  Nothing <font color="#339933">&gt;&gt; =</font> <font>return</font> <br>  <font color="#66cc66"><b>=</b></font> Nothing <font color="#5d478b">- by definition &gt;&gt; = for the monad Maybe</font> <br>  <font color="#5d478b">- implementation of the second monad law</font> </blockquote><br><br>  Once the laws are respected, take this option.  The full definition of the <font color="blue">Maybe</font> monad is: <br><br><blockquote>  <font color="#06c">instance</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Monad</a></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Maybe</a></font> <font color="#06c">where</font> <br>  <font>return</font> x <font color="#66cc66"><b>=</b></font> Just x <br><br>  Nothing <font color="#339933">&gt;&gt; =</font> f <font color="#66cc66"><b>=</b></font> Nothing <br>  Just x <font color="#339933">&gt;&gt; =</font> f <font color="#66cc66"><b>=</b></font> f x </blockquote><br><br>  Wow  We just created our first monad! <br><br>  Just to protect yourself, check that it satisfies the third monad law, which says: <br><br><blockquote>  <font>(</font> mv <font color="#339933">&gt;&gt; =</font> f <font>)</font> <font color="#339933">&gt;&gt; =</font> g <font color="#339933">==</font> mv <font color="#339933">&gt;&gt; =</font> <font>(</font> \ x <font color="#339933">-&gt;</font> <font>(</font> f x <font color="#339933">&gt;&gt; =</font> g <font>)</font> <font>)</font> </blockquote><br><br>  We first check the law for the case when mv = Nothing: <br><br><blockquote>  <font>(</font> Nothing <font color="#339933">&gt;&gt; =</font> f <font>)</font> <font color="#339933">&gt;&gt; =</font> g <font color="#5d478b">- on the left side</font> <br>  <font color="#66cc66"><b>=</b></font> Nothing <font color="#339933">&gt;&gt; =</font> g <font color="#5d478b">- by definition &gt;&gt; =</font> <br>  <font color="#66cc66"><b>=</b></font> Nothing <font color="#5d478b">- by definition &gt;&gt; =</font> <br><br>  Nothing <font color="#339933">&gt;&gt; =</font> <font>(</font> \ x <font color="#339933">-&gt;</font> <font>(</font> f x <font color="#339933">&gt;&gt; =</font> g <font>)</font> <font>)</font> <font color="#5d478b">- on the right side</font> <br>  <font color="#66cc66"><b>=</b></font> Nothing <font color="#5d478b">- by definition &gt;&gt; =</font> </blockquote><br><br>  Well, the check was successful.  Now let's see if it works for <font color="blue">mv = Just v</font> , where <font color="blue">v</font> is some value: <br><br><blockquote>  <font>(</font> <font>(</font> Just v <font>)</font> <font color="#339933">&gt;&gt; =</font> f <font>)</font> <font color="#339933">&gt;&gt; =</font> g <font color="#5d478b">- on the left side</font> <br>  <font color="#66cc66"><b>=</b></font> f v <font color="#339933">&gt;&gt; =</font> g <font color="#5d478b">- by definition &gt;&gt; =</font> <br><br>  <font>(</font> Just v <font>)</font> <font color="#339933">&gt;&gt; =</font> <font>(</font> \ x <font color="#339933">-&gt;</font> <font>(</font> f x <font color="#339933">&gt;&gt; =</font> g <font>)</font> <font>)</font> <font color="#5d478b">- on the right side</font> <br>  <font color="#66cc66"><b>=</b></font> <font>(</font> \ x <font color="#339933">-&gt;</font> <font>(</font> f x <font color="#339933">&gt;&gt; =</font> g <font>)</font> <font>)</font> v <font color="#5d478b">- by definition &gt;&gt; =</font> <br>  <font color="#66cc66"><b>=</b></font> f v <font color="#339933">&gt;&gt; =</font> g <font color="#5d478b">- normal function application (beta reduction)</font> </blockquote><br><br>  And also successful.  So the law is being carried out!  This is <i>really the</i> correct definition of the <font color="blue">Maybe</font> monad!  And the audience goes crazy! <br><br>  What is the meaning of all this?  This means that now we can easily connect a bunch of monadic functions of the <font color="blue">Maybe</font> monad.  You may be wondering why this is important?  It is not hard to imagine many monadic functions in the <font color="blue">Maybe</font> monad, that is, those that can fail.  Let's say they have the type <font color="blue">Int -&gt; Maybe Int</font> .  Here are three similar functions: <br><br><blockquote>  f <font color="#66cc66"><b>::</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Int</a></font> <font color="#339933">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Maybe</a></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Int</a></font> <br>  f x <font color="#66cc66"><b>=</b></font> <font color="#06c">if</font> x ` <font>mod`</font> <font color="red">2</font> <font color="#339933">==</font> <font color="red">0</font> <font color="#06c">then</font> Nothing <font color="#06c">else</font> Just <font>(</font> <font color="red">2</font> <font color="#339933">*</font> x <font>)</font> <br><br>  g <font color="#66cc66"><b>::</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Int</a></font> <font color="#339933">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Maybe</a></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Int</a></font> <br>  g x <font color="#66cc66"><b>=</b></font> <font color="#06c">if</font> x ` <font>mod`</font> <font color="red">3</font> <font color="#339933">==</font> <font color="red">0</font> <font color="#06c">then</font> Nothing <font color="#06c">else</font> Just <font>(</font> <font color="red">3</font> <font color="#339933">*</font> x <font>)</font> <br><br>  h <font color="#66cc66"><b>::</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Int</a></font> <font color="#339933">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Maybe</a></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Int</a></font> <br>  h x <font color="#66cc66"><b>=</b></font> <font color="#06c">if</font> x ` <font>mod`</font> <font color="red">5</font> <font color="#339933">==</font> <font color="red">0</font> <font color="#06c">then</font> Nothing <font color="#06c">else</font> Just <font>(</font> <font color="red">5</font> <font color="#339933">*</font> x <font>)</font> </blockquote><br><br>  We would like to combine them into one function, which is the result of applying in order <font color="blue">f</font> , <font color="blue">g</font> , <font color="blue">h</font> : <br><br><blockquote>  k <font color="#66cc66"><b>::</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Int</a></font> <font color="#339933">-&gt;</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Maybe</a></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Int</a></font> </blockquote><br><br>  And if one of the three functions fails, the function <font color="blue">k</font> should return <font color="blue">Nothing</font> .  This function multiplies the input number by 30 if it is not divisible by 2, 3 or 5 (and if divisible, the function returns <font color="blue">Nothing</font> ). <br><br>  From the previous material, if you understood it well, it should be clear that you can specify <font color="blue">k</font> through the monadic composition: <br><br><blockquote>  k <font color="#66cc66"><b>=</b></font> f <font color="#339933">&gt; =&gt;</font> g <font color="#339933">&gt; =&gt;</font> h </blockquote><br><br>  Or you can take the operator <font color="blue">&gt;&gt; =</font> : <br><br><blockquote>  k x <font color="#66cc66"><b>=</b></font> f x <font color="#339933">&gt;&gt; =</font> g <font color="#339933">&gt;&gt; =</font> h </blockquote><br><br>  Or perhaps you like to <font color="blue">do-</font> abstract: <br><br><blockquote>  k x <font color="#66cc66"><b>=</b></font> <font color="#06c">do</font> y <font color="#339933">&lt;-</font> f x <br>  z <font color="#339933">&lt;-</font> g y <br>  h z </blockquote><br><br>  It's easy, anyway.  {1: In the original - the steady expression "Any way you slice it", similar in meaning.  - Approx.  trans.} <br><br>  In general, the function <font color="blue">h</font> can be defined at all without monadic constructions; it will look like this: <br><br><blockquote>  k x <font color="#66cc66"><b>=</b></font> <font color="#06c">case</font> f x <font color="#06c">of</font> <br>  Nothing <font color="#339933">-&gt;</font> Nothing <br>  Just y <font color="#339933">-&gt;</font> <font color="#06c">case</font> g y <font color="#06c">of</font> <br>  Nothing <font color="#339933">-&gt;</font> Nothing <br>  Just z <font color="#339933">-&gt;</font> h z </blockquote><br><br>  Now I understand why the <font color="blue">Maybe</font> monad is important.  It dramatically simplifies the code by chaining several <font color="blue">Maybe</font> functions.  Imagine a coarse nonmonadic code for composing ten <font color="blue">Maybe</font> functions in this form.  Such an indent to the right would have been such that readability would suffer greatly, and the overall structure of the calculations would be lost in the labyrinth of nested <font color="blue">case</font> expressions.  But with the help of monads, the composition of ten functions is simply written: <br><br><blockquote>  f11 <font color="#66cc66"><b>=</b></font> f1 <font color="#339933">&gt; =&gt;</font> f2 <font color="#339933">&gt; =&gt;</font> f3 <font color="#339933">&gt; =&gt;</font> f4 <font color="#339933">&gt; =&gt;</font> f5 <font color="#339933">&gt; =&gt;</font> f6 <font color="#339933">&gt; =&gt;</font> f7 <font color="#339933">&gt; =&gt;</font> f8 <font color="#339933">&gt; =&gt;</font> f9 <font color="#339933">&gt; =&gt;</font> f10 </blockquote><br><br>  or (using <font color="blue">&gt;&gt; =</font> ): <br><br><blockquote>  f11 x <font color="#66cc66"><b>=</b></font> f1 x <font color="#339933">&gt;&gt; =</font> f2 <font color="#339933">&gt;&gt; =</font> f3 <font color="#339933">&gt;&gt; =</font> f4 <font color="#339933">&gt;&gt; =</font> f5 <font color="#339933">&gt;&gt; =</font> f6 <font color="#339933">&gt;&gt; =</font> f7 <font color="#339933">&gt;&gt; =</font> f8 <font color="#339933">&gt;&gt; =</font> f9 <font color="#339933">&gt;&gt; =</font> f10 </blockquote><br><br>  Using monads, the composition of monadic functions is as simple as the composition of ordinary (nonmonadic) functions. <br><br>  The <font color="blue">Maybe</font> monad is very useful for explaining basic concepts, but it can be confusing: many people mistakenly believe that the only role of monads is in processing non-functional calculations, that is, those calculations that work with input / output (with console or file), with a changeable global state, and so on.  And I showed that some monadic calculations can equally well be performed without monads at all.  It turns out that monads are not something mandatory, they are simply <i>very</i> convenient.  That is why I said that even despite the <i>initial</i> reason for the invention of monads for non-functional calculations (working with <font color="blue">IO</font> ), they turned out to have much greater applicability.  Because of this, monads are good. <br><br>  Now for the next monad. <br><br><h4>  Monad <font color="blue">list</font> </h4><br><br>  If <font color="blue">Maybe</font> you just liked the monad, you will even love the <font color="blue">list</font> monad.  ;-) In this case, we will fill in the following definition: <br><br><blockquote>  <font color="#06c">instance</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">monad</a></font> <font>[</font> <font>]</font> <font color="#06c">where</font> <br>  <font>(</font> <font color="#339933">&gt;&gt; =</font> <font>)</font> <font color="#66cc66"><b>=</b></font> <i><font color="#5d478b">{- definition of &gt;&gt; = for lists -}</font></i> <br>  <font>return</font> <font color="#66cc66"><b>=</b></font> <i><font color="#5d478b">{- definition of return for lists -}</font></i> </blockquote><br><br>  Notice that to represent the empty list <font color="blue">[]</font> we use a list type constructor.  This is a small hack (for lists in Haskell special syntax support is included).  But nothing can be done. <br><br>  As with all monads, the first task will be to understand what the monadic functions of this monad are.  For the list, the monadic function <font color="blue">f</font> looks like this: <br><br><blockquote>  f <font color="#66cc66"><b>::</b></font> a <font color="#339933">-&gt;</font> <font>[</font> b <font>]</font> </blockquote><br><br>  (where <font color="blue">[b]</font> means, of course, ‚Äúa list of elements of type <font color="blue">b</font> ‚Äù).  Recall that the generic definition of a monadic function is written as follows: <br><br><blockquote>  f <font color="#66cc66"><b>::</b></font> a <font color="#339933">-&gt;</font> m b </blockquote><br><br>  for some monad <font color="blue">m</font> , which must be a type constructor.  The list is an obvious candidate for the monad, since the ‚Äúlist of‚Äù is a type constructor (even if its syntax is hard-wired in Haskell);  Optionally, we could define the list ourselves: <br><br><blockquote>  <font color="#06c">data</font> List a <font color="#66cc66"><b>=</b></font> Nil <font color="#339933">|</font>  Cons a <font>(</font> List a <font>)</font> </blockquote><br><br>  The type of monadic functions for it would look accordingly: <br><br><blockquote>  f <font color="#66cc66"><b>::</b></font> a <font color="#339933">-&gt;</font> List b </blockquote><br><br>  But we will still adhere to the standard syntax. <br><br>  What are the functions of this sort?  Usually they are understood as functions that take an input value of type <font color="blue">a</font> and produce a bunch of values ‚Äã‚Äãof type <font color="blue">b</font> , collected in one convenient container (list).  (And again, we have a monad that looks like a container.) Another way to think of them as functions that return multiple values, that is, such functions return a bunch of different values ‚Äã‚Äã‚Äúin one‚Äù.  (I do not mean "parallel" because it implies parallel processing, which is not here.) Multiple output values ‚Äã‚Äãare just list items.  When using functions like the following, useful perspectives open up: <br><br><blockquote>  f <font color="#66cc66"><b>::</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Int</a></font> <font color="#339933">-&gt;</font> <font>[</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Int</a></font> <font>]</font> <br>  g <font color="#66cc66"><b>::</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Int</a></font> <font color="#339933">-&gt;</font> <font>[</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Int</a></font> <font>]</font> </blockquote><br><br>  Here both <font color="blue">f</font> and <font color="blue">g</font> take one <font color="blue">Int</font> -value and return many <font color="blue">Int</font> -values.  But what if we want to take each result of the function <font color="blue">f</font> and apply it to each result of the function <font color="blue">g</font> , collecting the results of the application?  It would be great if this could be done directly, without unpacking each element from the result lists of the functions <font color="blue">g</font> and <font color="blue">f</font> .  And this can be done using the monad list. <br><br>  Let's move on to more tangible examples of these functions: <br><br><blockquote>  f <font color="#66cc66"><b>::</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Int</a></font> <font color="#339933">-&gt;</font> <font>[</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Int</a></font> <font>]</font> <br>  f x <font color="#66cc66"><b>=</b></font> <font>[</font> x <font color="#339933">-</font> <font color="red">1</font> <font color="#339933">,</font> x <font color="#339933">,</font> x <font color="#339933">+</font> <font color="red">1</font> <font>]</font> <br><br>  g <font color="#66cc66"><b>::</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Int</a></font> <font color="#339933">-&gt;</font> <font>[</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Int</a></font> <font>]</font> <br>  g x <font color="#66cc66"><b>=</b></font> <font>[</font> <font color="#339933">-</font> x <font color="#339933">,</font> x <font>]</font> </blockquote><br><br>  How do we ‚Äúbundle‚Äù these two functions?  <font color="blue">fx</font> returns a list, and to apply <font color="blue">g</font> to each element we need a <font color="blue">map</font> function: <br><br><blockquote>  f <font color="red">10</font> <font color="#339933">-&gt;</font> <font>[</font> <font color="red">9</font> <font color="#339933">,</font> <font color="red">10</font> <font color="#339933">,</font> <font color="red">11</font> <font>]</font> <br>  <font>map</font> g <font>(</font> f <font color="red">10</font> <font>)</font> <font color="#339933">-&gt;</font> <font>[</font> <font>[</font> <font color="#339933">-</font> <font color="red">9</font> <font color="#339933">,</font> <font color="red">9</font> <font>]</font> <font color="#339933">,</font> <font>[</font> <font color="#339933">-</font> <font color="red">10</font> <font color="#339933">,</font> <font color="red">10</font> <font>]</font> <font color="#339933">,</font> <font>[</font> <font color="#339933">-</font> <font color="red">11</font> <font color="#339933">,</font> <font color="red">11</font> <font>]</font> <font>]</font> </blockquote><br><br>  This new result is interesting, but it cannot be a composition of <font color="blue">f</font> and <font color="blue">g</font> , because it has a different type (list of lists of <font color="blue">Int</font> , and not just a list of <font color="blue">Int</font> ).  We can smooth it into a simple list with the <font color="blue">concat</font> function (which simply combines the lists into one): <br><br><blockquote>  <font color="#5d478b">- Pay particular attention to the type concat: [[a]] -&gt; [a]</font> <br>  <font>concat</font> <font>(</font> <font>map</font> g <font>(</font> f <font color="red">10</font> <font>)</font> <font>)</font> <font color="#339933">-&gt;</font> <font>[</font> <font color="#339933">-</font> <font color="red">9</font> <font color="#339933">,</font> <font color="red">9</font> <font color="#339933">,</font> <font color="#339933">-</font> <font color="red">10</font> <font color="#339933">,</font> <font color="red">10</font> <font color="#339933">,</font> <font color="#339933">-</font> <font color="red">11</font> <font color="#339933">,</font> <font color="red">11</font> <font>]</font> </blockquote><br><br>  We get a set of all results produced by applying <font color="blue">f</font> to an integer and then applying <font color="blue">g</font> to what happened after <font color="blue">f</font> .  If you think of <font color="blue">f</font> and <font color="blue">g</font> as functions that create a set of ‚Äúhere and now‚Äù results, their output values ‚Äã‚Äãwill be the set of all possible applications, first the functions <font color="blue">f</font> , and then the functions <font color="blue">g</font> .  We can present this in the form of a diagram: <br><br><pre>                   g |  -9
            |  9 ----&gt; |
            |  |  9
            |
        f |  g |  -ten
   10 ----&gt; |  10 ----&gt; |
            |  |  ten
            |
            |  g |  -eleven
            |  11 ----&gt; |
                       |  eleven </pre><br><br>  It is clearly seen that the composition <font color="blue">f</font> and <font color="blue">g</font> is the set of all paths between <font color="blue">f</font> and <font color="blue">g</font> . <br><br>  Curiously, we have just defined the <font color="blue">&gt;&gt; =</font> operator for the list monad!  It is given as follows: <br><br><blockquote>  <font color="#5d478b">- mv :: [a]</font> <br>  <font color="#5d478b">- g :: a -&gt; [b]</font> <br>  mv <font color="#339933">&gt;&gt; =</font> g <font color="#66cc66"><b>=</b></font> <font>concat</font> <font>(</font> <font>map</font> g mv <font>)</font> </blockquote><br><br>  where <font color="blue">mv</font> is a monadic value in a list monad (which is simply a list of values ‚Äã‚Äãof type <font color="blue">a</font> ).  In the previous example, <font color="blue">mv</font> is the result of calculating <font color="blue">f 10</font> .  The definition works even for an empty list <font color="blue">[]</font> , since mapping a function to an empty list will give an empty list, and a <font color="blue">concat</font> for an empty list is also always an empty list.  The result is a very simple definition of the operator <font color="blue">&gt;&gt; =</font> . <br><br>  [Note to GHC fans: I believe the <font color="blue">&gt;&gt; =</font> operator in the GHC compiler is implemented more efficiently and differently, although it does the same thing.] <br><br>  How to set <font color="blue">return</font> for this monad?  Let's think of the monadic value-list as an ‚Äúaction‚Äù that returns many values.  Recall that <font color="blue">return</font> should be equivalent to a single function, as in other monads.  What would be the equivalent of a single function in a list monad?  It must take a value and return an ‚Äúaction‚Äù that, after a ‚Äúcalculation,‚Äù simply returns that value.  So we realized that <font color="blue">return</font> can't just return an empty list.  It is reasonable to assume about <font color="blue">return</font> something like this: <br><br><blockquote>  <font>return</font> <font color="#66cc66"><b>::</b></font> a <font color="#339933">-&gt;</font> <font>[</font> b <font>]</font> <br>  <font>return</font> x <font color="#66cc66"><b>=</b></font> <font>[</font> x <font>]</font> </blockquote><br><br>  That is, <font color="blue">return</font> elementarily creates a list from a single value.  Check whether the monad laws are observed in this case: <br><br><blockquote>  <font color="#5d478b">- f :: a -&gt; [b]</font> <br>  <font color="#5d478b">- x :: a</font> <br>  <font>return</font> x <font color="#339933">&gt;&gt; =</font> f <font color="#66cc66"><b>=</b></font> <font>concat</font> <font>(</font> <font>map</font> f <font>(</font> <font>return</font> x <font>)</font> <font>)</font> <font color="#5d478b">- by definition &gt;&gt; =</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> <font>(</font> <font>map</font> f <font>[</font> x <font>]</font> <font>)</font> <font color="#5d478b">- by definition return</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> <font>[</font> f x <font>]</font> <font color="#5d478b">- by definition map</font> <br>  <font color="#66cc66"><b>=</b></font> f x <font color="#5d478b">- by definition concat</font> <br>  <font color="#5d478b">- implementation of the first monad law</font> <br><br>  <font color="#5d478b">- mv :: [a]</font> <br>  mv <font color="#339933">&gt;&gt; =</font> <font>return</font> <font color="#66cc66"><b>=</b></font> <font>concat</font> <font>(</font> <font>map</font> <font>return</font> mv <font>)</font> <font color="#5d478b">- by definition &gt;&gt; =</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> <font>(</font> <font>map</font> <font>(</font> \ x <font color="#339933">-&gt;</font> <font>[</font> x <font>]</font> <font>)</font> mv <font>)</font> <font color="#5d478b">- by definition return</font> <br>  <font color="#5d478b">- Two cases:</font> <br>  <font color="#5d478b">- Case 1: mv == []</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> <font>(</font> <font>map</font> <font>(</font> \ x <font color="#339933">-&gt;</font> <font>[</font> x <font>]</font> <font>)</font> <font>[</font> <font>]</font> <font>)</font> <font color="#5d478b">- by definition mv</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> <font>[</font> <font>]</font> <font color="#5d478b">- by definition map</font> <br>  <font color="#66cc66"><b>=</b></font> <font>[</font> <font>]</font> <font color="#5d478b">- by definition concat</font> <br>  <font color="#66cc66"><b>=</b></font> mv <font color="#5d478b">- by definition mv</font> <br>  <font color="#5d478b">- Case 2: mv == [v1, v2, ...]</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> <font>(</font> <font>map</font> <font>(</font> \ x <font color="#339933">-&gt;</font> <font>[</font> x <font>]</font> <font>)</font> <font>[</font> v1 <font color="#339933">,</font> v2 <font color="#339933">,</font> <font color="#339933">...</font> <font>]</font> <font>)</font> <font color="#5d478b">- by definition mv</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> <font>[</font> <font>[</font> v1 <font>]</font> <font color="#339933">,</font> <font>[</font> v2 <font>]</font> <font color="#339933">,</font> <font color="#339933">...</font> <font>]</font> <font color="#5d478b">- by definition map</font> <br>  <font color="#66cc66"><b>=</b></font> <font>[</font> v1 <font color="#339933">,</font> v2 <font color="#339933">,</font> <font color="#339933">...</font> <font>]</font> <font color="#5d478b">- by definition concat</font> <br>  <font color="#66cc66"><b>=</b></font> mv <font color="#5d478b">- by definition mv</font> <br>  <font color="#5d478b">- implementation of the second monad law</font> </blockquote><br><br>  Well, the two laws for the monad are proven.  You might want to try other definitions of <font color="blue">return</font> (when <font color="blue">return</font> returns, for example, a specific list <font color="blue">[0, 2, 3]</font> , or when it returns an infinite number of copies of its argument), and you will see that they will all violate monadic laws.  This is a good way to practice monadic laws. <br><br>  It remains to prove the third monad law, before calling the list a real monad.  I must say, it is more difficult, but we will try anyway.  Simplify your task - take the "pleasant" form of the third monad law (defined through the monadic composition).  First we need a definition of a monadic composition of lists: <br><br><blockquote>  <font color="#5d478b">- The third monad law (pleasant version):</font> <br>  <font>(</font> f <font color="#339933">&gt; =&gt;</font> g <font>)</font> <font color="#339933">&gt; =&gt;</font> h <font color="#66cc66"><b>=</b></font> f <font color="#339933">&gt; =&gt;</font> <font>(</font> g <font color="#339933">&gt; =&gt;</font> h <font>)</font> <br>  <font color="#5d478b">-- By definition:</font> <br>  f <font color="#339933">&gt; =&gt;</font> g <font color="#66cc66"><b>=</b></font> \ x <font color="#339933">-&gt;</font> f x <font color="#339933">&gt;&gt; =</font> g <br>  <font color="#5d478b">- Take the definition &gt;&gt; = for the list monad:</font> <br>  f <font color="#339933">&gt; =&gt;</font> g <font color="#66cc66"><b>=</b></font> \ x <font color="#339933">-&gt;</font> <font>concat</font> <font>(</font> <font>map</font> g <font>(</font> f x <font>)</font> <font>)</font> <br>  <font color="#5d478b">- You can rewrite the expression through the composition operator (.):</font> <br>  f <font color="#339933">&gt; =&gt;</font> g <font color="#66cc66"><b>=</b></font> <font>concat</font> <font color="#339933">.</font>  <font>map</font> g <font color="#339933">.</font>  f </blockquote><br><br>  In addition, I will use several properties of the <font color="blue">concat</font> and <font color="blue">map</font> functions.  You still have to take them on faith;  then I'll show you how to get them: <br><br><blockquote>  <font color="#5d478b">- equation 1:</font> <br>  <font>map</font> <font>(</font> f <font color="#339933">.</font> g <font>)</font> <font color="#66cc66"><b>=</b></font> <font>map</font> f <font color="#339933">.</font>  <font>map</font> g <br>  <font color="#5d478b">- equation 2:</font> <br>  <font>map</font> f <font color="#339933">.</font>  <font>concat</font> <font color="#66cc66"><b>=</b></font> <font>concat</font> <font color="#339933">.</font>  <font>map</font> <font>(</font> <font>map</font> f <font>)</font> <br>  <font color="#5d478b">- equation 3:</font> <br>  <font>concat</font> <font color="#339933">.</font>  <font>concat</font> <font color="#66cc66"><b>=</b></font> <font>concat</font> <font color="#339933">.</font>  <font>map</font> <font>concat</font> </blockquote><br><br>  I once said that the dot <font color="blue">(.)</font> Is a (pure) composition operator.  It has lower priority than the use of the function, therefore, an expression like <font color="blue">map f.</font>  <font color="blue">map g</font> means only <font color="blue">(map f).</font>  <font color="blue">(map g)</font> .  Haskell programmers usually get rid of parentheses where possible.  It is also important to understand that, for example, the function <font color="blue">map f</font> is a function of the <font color="blue">map</font> , which generally has two arguments (such: a function for the elements of the list and the list itself).  If you recall what I was talking about currying, then you will guess that <font color="blue">map f</font> is a function that takes one list and returns another, where the function <font color="blue">f is</font> applied to each element.  Curry we will now use a lot. <br><br>  So, the conclusion of the evidence, taking into account all the above: <br><br><blockquote>  <font>(</font> f <font color="#339933">&gt; =&gt;</font> g <font>)</font> <font color="#339933">&gt; =&gt;</font> h <br>  <font color="#66cc66"><b>=</b></font> <font>(</font> <font>concat</font> <font color="#339933">.</font> <font>map</font> g <font color="#339933">.</font> f <font>)</font> <font color="#339933">&gt; =&gt;</font> h <font color="#5d478b">- by definition&gt; =&gt;</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> <font color="#339933">.</font>  <font>map</font> h <font color="#339933">.</font>  <font>(</font> <font>concat</font> <font color="#339933">.</font> <font>map</font> g <font color="#339933">.</font> f <font>)</font> <font color="#5d478b">- by definition&gt; =&gt;</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> <font color="#339933">.</font>  <font>map</font> h <font color="#339933">.</font>  <font>concat</font> <font color="#339933">.</font>  <font>map</font> g <font color="#339933">.</font>  f <font color="#5d478b">- delete unnecessary brackets</font> <br><br>  f <font color="#339933">&gt; =&gt;</font> <font>(</font> g <font color="#339933">&gt; =&gt;</font> h <font>)</font> <br>  <font color="#66cc66"><b>=</b></font> f <font color="#339933">&gt; =&gt;</font> <font>(</font> <font>concat</font> <font color="#339933">.</font> <font>map</font> h <font color="#339933">.</font> g <font>)</font> <font color="#5d478b">- by definition&gt; =&gt;</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> <font color="#339933">.</font>  <font>map</font> <font>(</font> <font>concat</font> <font color="#339933">.</font> <font>map</font> h <font color="#339933">.</font> g <font>)</font> <font color="#339933">.</font>  f <font color="#5d478b">- by definition&gt; =&gt;</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> <font color="#339933">.</font>  <font>map</font> <font>(</font> <font>(</font> <font>concat</font> <font color="#339933">.</font> <font>map</font> h <font>)</font> <font color="#339933">.</font> g <font>)</font> <font color="#339933">.</font>  f <font color="#5d478b">- equivalent conversion</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> <font color="#339933">.</font>  <font>(</font> <font>map</font> <font>(</font> <font>concat</font> <font color="#339933">.</font> <font>map</font> h <font>)</font> <font>)</font> <font color="#339933">.</font>  <font>(</font> <font>map</font> g <font>)</font> <font color="#339933">.</font>  f <font color="#5d478b">- by equation 1</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> <font color="#339933">.</font>  <font>map</font> <font>(</font> <font>concat</font> <font color="#339933">.</font> <font>map</font> h <font>)</font> <font color="#339933">.</font>  <font>map</font> g <font color="#339933">.</font>  f <font color="#5d478b">- delete unnecessary brackets</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> <font color="#339933">.</font>  <font>map</font> <font>concat</font> <font color="#339933">.</font>  <font>map</font> <font>(</font> <font>map</font> h <font>)</font> <font color="#339933">.</font>  <font>map</font> g <font color="#339933">.</font>  f <font color="#5d478b">- by equation 1</font> </blockquote><br><br>  Now we need to show that: <br><br><blockquote>  <font>concat</font> <font color="#339933">.</font>  <font>map</font> h <font color="#339933">.</font>  <font>concat</font> <font color="#66cc66"><b>=</b></font> <font>concat</font> <font color="#339933">.</font>  <font>map</font> <font>concat</font> <font color="#339933">.</font>  <font>map</font> <font>(</font> <font>map</font> h <font>)</font> </blockquote><br><br>  Let's prove it. <br><br><blockquote>  <font color="#5d478b">- add parentheses for clarity:</font> <br>  <font>concat</font> <font color="#339933">.</font>  <font>(</font> <font>map</font> h <font color="#339933">.</font> <font>concat</font> <font>)</font> <font color="#66cc66"><b>=</b></font> <font>concat</font> <font color="#339933">.</font>  <font>map</font> <font>concat</font> <font color="#339933">.</font>  <font>map</font> <font>(</font> <font>map</font> h <font>)</font> <br>  <font color="#5d478b">- according to equation 2:</font> <br>  <font>concat</font> <font color="#339933">.</font>  <font>concat</font> <font color="#339933">.</font>  <font>map</font> <font>(</font> <font>map</font> h <font>)</font> <font color="#66cc66"><b>=</b></font> <font>concat</font> <font color="#339933">.</font>  <font>map</font> <font>concat</font> <font color="#339933">.</font>  <font>map</font> <font>(</font> <font>map</font> h <font>)</font> <br>  <font color="#5d478b">- add parentheses for clarity:</font> <br>  <font>(</font> <font>concat</font> <font color="#339933">.</font> <font>concat</font> <font>)</font> <font color="#339933">.</font>  <font>map</font> <font>(</font> <font>map</font> h <font>)</font> <font color="#66cc66"><b>=</b></font> <font>concat</font> <font color="#339933">.</font>  <font>map</font> <font>concat</font> <font color="#339933">.</font>  <font>map</font> <font>(</font> <font>map</font> h <font>)</font> <br>  <font color="#5d478b">- according to equation 3:</font> <br>  <font>concat</font> <font color="#339933">.</font>  <font>map</font> <font>concat</font> <font color="#339933">.</font>  <font>map</font> <font>(</font> <font>map</font> h <font>)</font> <font color="#66cc66"><b>=</b></font> <font>concat</font> <font color="#339933">.</font>  <font>map</font> <font>concat</font> <font color="#339933">.</font>  <font>map</font> <font>(</font> <font>map</font> h <font>)</font> </blockquote><br><br>  And this is the end.  Fuuuh!  In fact, Haskellists rarely do this, but evidence is needed to show that the intended monad is indeed a monad. <br><br><blockquote><blockquote>  <b>Note in the margin: Conclusion of identities with <font color="blue">map / concat</font> (equations 1, 2 and 3)</b> <br><br>  <u><b>Training</b></u> <br><br>  Before embarking on the proofs of identities, we first need to prove several others (mathematics is difficult!).  We list them: <br><br><blockquote>  <font color="#5d478b">- Expression 4:</font> <br>  <font>concat</font> <font>(</font> x: xs <font>)</font> <font color="#66cc66"><b>=</b></font> x <font color="#339933">++</font> <font>concat</font> xs <br>  <font color="#5d478b">- Expression 5:</font> <br>  <font>concat</font> <font>(</font> x <font color="#339933">++</font> y <font>)</font> <font color="#66cc66"><b>=</b></font> <font>concat</font> x <font color="#339933">++</font> <font>concat</font> y <br>  <font color="#5d478b">- Expression 6:</font> <br>  <font>map</font> f <font>(</font> x <font color="#339933">++</font> y <font>)</font> <font color="#66cc66"><b>=</b></font> <font>map</font> f x <font color="#339933">++</font> <font>map</font> f y </blockquote><br><br>  Expression 4 follows from the definition of <font color="blue">concat</font> .  Expression 5 is easily proved by induction on x using equation 4. <br><br><blockquote>  <font color="#5d478b">- base case: x - empty list</font> <br>  <font>concat</font> <font>(</font> <font>[</font> <font>]</font> <font color="#339933">++</font> y <font>)</font> <font color="#66cc66"><b>=</b></font> <font>concat</font> <font>[</font> <font>]</font> <font color="#339933">++</font> <font>concat</font> y <br>  <font>concat</font> y <font color="#66cc66"><b>=</b></font> <font>[</font> <font>]</font> <font color="#339933">++</font> <font>concat</font> y <font color="#5d478b">- by definition concat []</font> <br>  <font>concat</font> y <font color="#66cc66"><b>=</b></font> <font>concat</font> y <font color="#5d478b">- by definition ++</font> <br>  <font color="#5d478b">-- Right.</font> <br><br>  <font color="#5d478b">- induction: the list x is not empty;</font>  <font color="#5d478b">x1 is the head of the list;</font>  <font color="#5d478b">xs is the tail of the list.</font> <br>  <font>concat</font> <font>(</font> <font>(</font> x1: xs <font>)</font> <font color="#339933">++</font> y <font>)</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> <font>(</font> x1: <font>(</font> xs <font color="#339933">++</font> y <font>)</font> <font>)</font> <font color="#5d478b">- by definition ++</font> <br>  <font color="#66cc66"><b>=</b></font> x1 <font color="#339933">++</font> <font>concat</font> <font>(</font> xs <font color="#339933">++</font> y <font>)</font> <font color="#5d478b">- by equation 4</font> <br>  <font color="#66cc66"><b>=</b></font> x1 <font color="#339933">++</font> <font>concat</font> xs <font color="#339933">++</font> <font>concat</font> y <font color="#5d478b">- inductive hypothesis</font> <br><br>  <font>concat</font> <font>(</font> x1: xs <font>)</font> <font color="#339933">++</font> <font>concat</font> y <br>  <font color="#66cc66"><b>=</b></font> x1 <font color="#339933">++</font> <font>concat</font> xs <font color="#339933">++</font> <font>concat</font> y <font color="#5d478b">- by equation 4</font> <br>  <font color="#5d478b">- True, that was required to prove.</font> </blockquote><br><br>  Equation 6 can be proved in the same way: <br><br><blockquote>  <font color="#5d478b">- base case: x - empty list</font> <br>  <font>map</font> f <font>(</font> <font>[</font> <font>]</font> <font color="#339933">++</font> y <font>)</font> <font color="#66cc66"><b>=</b></font> <font>map</font> f <font>[</font> <font>]</font> <font color="#339933">++</font> <font>map</font> f y <br>  <font>map</font> f y <font color="#66cc66"><b>=</b></font> <font>[</font> <font>]</font> <font color="#339933">++</font> <font>map</font> f y <br>  <font>map</font> f y <font color="#66cc66"><b>=</b></font> <font>map</font> f y <br>  <font color="#5d478b">-- Right.</font> <br><br>  <font color="#5d478b">- induction: the list x is not empty;</font>  <font color="#5d478b">x1 is the head of the list;</font>  <font color="#5d478b">xs is the tail of the list.</font> <br>  <font>map</font> f <font>(</font> x <font color="#339933">++</font> y <font>)</font> <br>  <font color="#66cc66"><b>=</b></font> <font>map</font> f <font>(</font> <font>(</font> x1: xs <font>)</font> <font color="#339933">++</font> y <font>)</font> <br>  <font color="#66cc66"><b>=</b></font> <font>map</font> f <font>(</font> x1: <font>(</font> xs <font color="#339933">++</font> y <font>)</font> <font>)</font> <font color="#5d478b">- by definition ++</font> <br>  <font color="#66cc66"><b>=</b></font> f x1: <font>map</font> f <font>(</font> xs <font color="#339933">++</font> y <font>)</font> <font color="#5d478b">- by definition map</font> <br>  <font color="#66cc66"><b>=</b></font> f x1: <font>(</font> <font>map</font> f xs <font color="#339933">++</font> <font>map</font> f y <font>)</font> <font color="#5d478b">- inductive hypothesis</font> <br>  <font color="#66cc66"><b>=</b></font> <font>(</font> f x1: <font>map</font> f xs <font>)</font> <font color="#339933">++</font> <font>map</font> f y <font color="#5d478b">- by definition ++</font> <br>  <font color="#66cc66"><b>=</b></font> <font>map</font> f <font>(</font> x1: xs <font>)</font> <font color="#339933">++</font> <font>map</font> f y <font color="#5d478b">- by definition map</font> <br>  <font color="#66cc66"><b>=</b></font> <font>map</font> f x <font color="#339933">++</font> <font>map</font> f y <font color="#5d478b">- by definition x</font> <br>  <font color="#5d478b">- True, that was required to prove.</font> </blockquote><br><br>  Now with this we prove equations 1, 2 and 3. <br><br>  <u><b>Equation 1:</b></u> <br><br><blockquote>  <font>map</font> <font>(</font> f <font color="#339933">.</font> g <font>)</font> <font color="#66cc66"><b>=</b></font> <font>map</font> f <font color="#339933">.</font>  <font>map</font> g </blockquote><br><br>  We use induction on the implicit list argument on both sides, as well as the definition of the <font color="blue">map</font> : <br><br><blockquote>  <font color="#5d478b">- base case: empty list</font> <br>  <font>map</font> <font>(</font> f <font color="#339933">.</font> g <font>)</font> <font>[</font> <font>]</font> <font color="#66cc66"><b>=</b></font> <font>[</font> <font>]</font> <br>  <font>(</font> <font>map</font> f <font color="#339933">.</font> <font>map</font> g <font>)</font> <font>[</font> <font>]</font> <font color="#66cc66"><b>=</b></font> <font>map</font> f <font>(</font> <font>map</font> g <font>[</font> <font>]</font> <font>)</font> <font color="#66cc66"><b>=</b></font> <font>map</font> f <font>[</font> <font>]</font> <font color="#66cc66"><b>=</b></font> <font>[</font> <font>]</font> <br>  <font color="#5d478b">- OK</font> <br><br>  <font color="#5d478b">- induction: non-empty list:</font> <br>  <font>map</font> <font>(</font> f <font color="#339933">.</font> g <font>)</font> <font>(</font> x: xs <font>)</font> <br>  <font color="#66cc66"><b>=</b></font> <font>(</font> <font>(</font> f <font color="#339933">.</font> g <font>)</font> x <font>)</font> : <font>(</font> <font>map</font> <font>(</font> f <font color="#339933">.</font> g <font>)</font> xs <font>)</font> <font color="#5d478b">- by definition map</font> <br>  <font color="#66cc66"><b>=</b></font> <font>(</font> f <font>(</font> g x <font>)</font> <font>)</font> : <font>(</font> <font>map</font> <font>(</font> f <font color="#339933">.</font> g <font>)</font> xs <font>)</font> <font color="#5d478b">- by definition (.)</font> <br>  <font>(</font> <font>map</font> f <font color="#339933">.</font> <font>map</font> g <font>)</font> <font>(</font> x: xs <font>)</font> <br>  <font color="#66cc66"><b>=</b></font> <font>map</font> f <font>(</font> <font>map</font> g <font>(</font> x: xs <font>)</font> <font>)</font> <font color="#5d478b">- by definition (.)</font> <br>  <font color="#66cc66"><b>=</b></font> <font>map</font> f <font>(</font> <font>(</font> g x <font>)</font> : <font>(</font> <font>map</font> g xs <font>)</font> <font>)</font> <font color="#5d478b">- by definition map</font> <br>  <font color="#66cc66"><b>=</b></font> <font>(</font> f <font>(</font> g x <font>)</font> <font>)</font> : <font>(</font> <font>map</font> f <font>(</font> <font>map</font> g xs <font>)</font> <font>)</font> <font color="#5d478b">- by definition map</font> <br>  <font color="#66cc66"><b>=</b></font> <font>(</font> f <font>(</font> g x <font>)</font> <font>)</font> : <font>(</font> <font>(</font> <font>map</font> f <font color="#339933">.</font> <font>map</font> g <font>)</font> xs <font>)</font> <font color="#5d478b">- by definition (.)</font> <br>  <font color="#66cc66"><b>=</b></font> <font>(</font> f <font>(</font> g x <font>)</font> <font>)</font> : <font>(</font> <font>map</font> <font>(</font> f <font color="#339933">.</font> g <font>)</font> xs <font>)</font> <font color="#5d478b">- inductive hypothesis</font> <br>  <font color="#5d478b">- True, that was required to prove.</font> </blockquote><br><br>  <u><b>Equation 2:</b></u> <br><br><blockquote>  <font>map</font> f <font color="#339933">.</font>  <font>concat</font> <font color="#66cc66"><b>=</b></font> <font>concat</font> <font color="#339933">.</font>  <font>map</font> <font>(</font> <font>map</font> f <font>)</font> </blockquote><br><br>  We prove by induction: <br><br><blockquote>  <font color="#5d478b">- base case: empty list</font> <br>  <font>(</font> <font>map</font> f <font color="#339933">.</font> <font>concat</font> <font>)</font> <font>[</font> <font>]</font> <font color="#66cc66"><b>=</b></font> <font>map</font> f <font>(</font> <font>concat</font> <font>[</font> <font>]</font> <font>)</font> <font color="#66cc66"><b>=</b></font> <font>map</font> f <font>[</font> <font>]</font> <font color="#66cc66"><b>=</b></font> <font>[</font> <font>]</font> <br>  <font>(</font> <font>concat</font> <font color="#339933">.</font> <font>map</font> <font>(</font> <font>map</font> f <font>)</font> <font>)</font> <font>[</font> <font>]</font> <font color="#66cc66"><b>=</b></font> <font>concat</font> <font>(</font> <font>map</font> <font>(</font> <font>map</font> f <font>)</font> <font>[</font> <font>]</font> <font>)</font> <font color="#66cc66"><b>=</b></font> <font>concat</font> <font>[</font> <font>]</font> <font color="#66cc66"><b>=</b></font> <font>[</font> <font>]</font> <br>  <font color="#5d478b">- OK</font> <br><br>  <font color="#5d478b">- induction: non-empty list</font> <br>  <font>(</font> <font>map</font> f <font color="#339933">.</font> <font>concat</font> <font>)</font> <font>(</font> x: xs <font>)</font> <br>  <font color="#66cc66"><b>=</b></font> <font>map</font> f <font>(</font> <font>concat</font> <font>(</font> x: xs <font>)</font> <font>)</font> <font color="#5d478b">- by definition (.)</font> <br>  <font color="#66cc66"><b>=</b></font> <font>map</font> f <font>(</font> x <font color="#339933">++</font> <font>concat</font> xs <font>)</font> <font color="#5d478b">- by equation 4</font> <br>  <font color="#66cc66"><b>=</b></font> <font>map</font> f x <font color="#339933">++</font> <font>(</font> <font>map</font> f <font>(</font> <font>concat</font> xs <font>)</font> <font>)</font> <font color="#5d478b">- by equation 6</font> <br>  <font color="#66cc66"><b>=</b></font> <font>map</font> f x <font color="#339933">++</font> <font>(</font> <font>(</font> <font>map</font> f <font color="#339933">.</font> <font>concat</font> <font>)</font> xs <font>)</font> <font color="#5d478b">- by definition (.)</font> <br>  <font color="#66cc66"><b>=</b></font> <font>map</font> f x <font color="#339933">++</font> <font>(</font> <font>(</font> <font>concat</font> <font color="#339933">.</font> <font>map</font> <font>(</font> <font>map</font> f <font>)</font> <font>)</font> xs <font>)</font> <font color="#5d478b">- inductive hypothesis</font> <br>  <font color="#66cc66"><b>=</b></font> <font>map</font> f x <font color="#339933">++</font> <font>concat</font> <font>(</font> <font>map</font> <font>(</font> <font>map</font> f <font>)</font> xs <font>)</font> <font color="#5d478b">- by definition (.)</font> <br><br>  <font>(</font> <font>concat</font> <font color="#339933">.</font> <font>map</font> <font>(</font> <font>map</font> f <font>)</font> <font>)</font> <font>(</font> x: xs <font>)</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> <font>(</font> <font>map</font> <font>(</font> <font>map</font> f <font>)</font> <font>(</font> x: xs <font>)</font> <font>)</font> <font color="#5d478b">- by definition (.)</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> <font>(</font> <font>map</font> f x: <font>map</font> <font>(</font> <font>map</font> f <font>)</font> xs <font>)</font> <font color="#5d478b">- by definition map</font> <br>  <font color="#66cc66"><b>=</b></font> <font>map</font> f x <font color="#339933">++</font> <font>concat</font> <font>(</font> <font>map</font> <font>(</font> <font>map</font> f <font>)</font> xs <font>)</font> <font color="#5d478b">- by equation 4</font> <br>  <font color="#5d478b">- True, that was required to prove.</font> </blockquote><br><br>  <u><b>Equation 3:</b></u> <br><br><blockquote>  <font>concat</font> <font color="#339933">.</font>  <font>concat</font> <font color="#66cc66"><b>=</b></font> <font>concat</font> <font color="#339933">.</font>  <font>map</font> <font>concat</font> </blockquote><br><br>  As always, we use induction: <br><br><blockquote>  <font color="#5d478b">- base case: empty list</font> <br>  <font>(</font> <font>concat</font> <font color="#339933">.</font> <font>concat</font> <font>)</font> <font>[</font> <font>]</font> <font color="#66cc66"><b>=</b></font> <font>concat</font> <font>(</font> <font>concat</font> <font>[</font> <font>]</font> <font>)</font> <font color="#66cc66"><b>=</b></font> <font>concat</font> <font>[</font> <font>]</font> <font color="#66cc66"><b>=</b></font> <font>[</font> <font>]</font> <br>  <font>(</font> <font>concat</font> <font color="#339933">.</font> <font>map</font> <font>concat</font> <font>)</font> <font>[</font> <font>]</font> <font color="#66cc66"><b>=</b></font> <font>concat</font> <font>(</font> <font>map</font> <font>concat</font> <font>[</font> <font>]</font> <font>)</font> <font color="#66cc66"><b>=</b></font> <font>concat</font> <font>[</font> <font>]</font> <font color="#66cc66"><b>=</b></font> <font>[</font> <font>]</font> <br>  <font color="#5d478b">-- Right</font> <br><br>  <font color="#5d478b">- induction: non-empty list</font> <br>  <font>(</font> <font>concat</font> <font color="#339933">.</font> <font>concat</font> <font>)</font> <font>(</font> x: xs <font>)</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> <font>(</font> <font>concat</font> <font>(</font> x: xs <font>)</font> <font>)</font> <font color="#5d478b">- by definition (.)</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> <font>(</font> x <font color="#339933">++</font> <font>concat</font> xs <font>)</font> <font color="#5d478b">- by equation 4</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> x <font color="#339933">++</font> <font>concat</font> <font>(</font> <font>concat</font> xs <font>)</font> <font color="#5d478b">- by equation 5</font> <br><br>  <font>(</font> <font>concat</font> <font color="#339933">.</font> <font>map</font> <font>concat</font> <font>)</font> <font>(</font> x: xs <font>)</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> <font>(</font> <font>map</font> <font>concat</font> <font>(</font> x: xs <font>)</font> <font>)</font> <font color="#5d478b">- by definition (.)</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> <font>(</font> <font>concat</font> x: <font>map</font> <font>concat</font> xs <font>)</font> <font color="#5d478b">- by definition map</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> x <font color="#339933">++</font> <font>concat</font> <font>(</font> <font>map</font> <font>concat</font> xs <font>)</font> <font color="#5d478b">- by equation 4</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> x <font color="#339933">++</font> <font>(</font> <font>concat</font> <font color="#339933">.</font> <font>map</font> <font>concat</font> <font>)</font> xs <font color="#5d478b">- by definition (.)</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> x <font color="#339933">++</font> <font>(</font> <font>concat</font> <font color="#339933">.</font> <font>concat</font> <font>)</font> xs <font color="#5d478b">- inductive hypothesis</font> <br>  <font color="#66cc66"><b>=</b></font> <font>concat</font> x <font color="#339933">++</font> <font>concat</font> <font>(</font> <font>concat</font> xs <font>)</font> <font color="#5d478b">- by definition (.)</font> <br>  <font color="#5d478b">- True, that was required to prove.</font> </blockquote><br></blockquote></blockquote><br><br>  I hope, now you have no doubt that the monad of the list is really a monad.  ;-) <br><br>  And the most interesting question here, of course, is: what can we <i>do</i> with a monad-list that would be difficult without a monad?  Here is a simple example: to find all pairs of numbers between 1 and 6, whose sum equals 7 (numbers are, for example, dice).  Using the monad of the list, solve the problem elementarily: <br><br><blockquote>  <font color="#5d478b">- Use the &lt;font color = blue&gt; do &lt;/ font&gt; notation:</font> <br>  <font color="#06c">do</font> n1 <font color="#339933">&lt;-</font> <font>[</font> 1 <font color="#339933">..</font> 6 <font>]</font> <br>  n2 <font color="#339933">&lt;-</font> <font>[</font> 1 <font color="#339933">..</font> 6 <font>]</font> <br>  <font color="#06c">if</font> n1 <font color="#339933">+</font> n2 <font color="#339933">==</font> <font color="red">7</font> <font color="#06c">then</font> <font>return</font> <font>(</font> n1 <font color="#339933">,</font> n2 <font>)</font> <font color="#06c">else</font> <font>[</font> <font>]</font> <br>  <font color="#5d478b">- Result: [(1,6), (2,5), (3,4), (4,3), (5,2), (6,1)]</font> </blockquote><br><br>  And you can also rewrite without the <font color="blue">do-</font> notation, only it turns out incomprehensible <br><br><blockquote>  <font>[</font> 1 <font color="#339933">..</font> 6 <font>]</font> <font color="#339933">&gt;&gt; =</font> \ n1 <font color="#339933">-&gt;</font> <br>  <font>[</font> 1 <font color="#339933">..</font> 6 <font>]</font> <font color="#339933">&gt;&gt; =</font> \ n2 <font color="#339933">-&gt;</font> <br>  <font color="#06c">if</font> n1 <font color="#339933">+</font> n2 <font color="#339933">==</font> <font color="red">7</font> <font color="#06c">then</font> <font>return</font> <font>(</font> n1 <font color="#339933">,</font> n2 <font>)</font> <font color="#06c">else</font> <font>[</font> <font>]</font> </blockquote><br><br>  How it works?  You would have to sit down and track all the calculations related to <font color="blue">&gt;&gt; =</font> and <font color="blue">return</font> for lists, but here‚Äôs an explanation on your fingers.  So: <font color="blue">[1..6]</font> is the monadic value in the monad of the list, and <font color="blue">n1</font> runs through <i>all of them</i> at once.  <font color="blue">n2</font> - exactly the same.  And all pairs are returned <font color="blue">(n1, n2)</font> , whose sum is correct.  This is how we calculate a function over all elements, as if they were one element.  This is the essence of the monad list. <br><br>  If you are very adept at Haskell programming, a siren will probably scream in your head.  "How so!" - I hear your indignation.  ‚ÄúWhy not just take advantage of <font color="blue">list comprehensions</font> ?‚Äù And indeed: <br><br><blockquote>  <font>[</font> <font>(</font> n1 <font color="#339933">,</font> n2 <font>)</font> <font color="#339933">|</font>  n1 <font color="#339933">&lt;-</font> <font>[</font> 1 <font color="#339933">..</font> 6 <font>]</font> <font color="#339933">,</font> n2 <font color="#339933">&lt;-</font> <font>[</font> 1 <font color="#339933">..</font> 6 <font>]</font> <font color="#339933">,</font> n1 <font color="#339933">+</font> n2 <font color="#339933">==</font> <font color="red">7</font> <font>]</font> </blockquote><br><br>  The possibilities of the list monad and the list generators are identical.  The choice of a particular syntax depends on preferences, and it can also be determined by a task.  In his article <font color="blue">‚ÄúComprehending Monads,‚Äù</font> <font color="blue">Phil Walder</font> (in the title there is a play on words, as in many of his articles) even suggested extending the syntax of list generators to arbitrary monads.  This proposal was still rejected in favor of the current record. <br><br>  A list monad is more than an alternative to a list generator.  On the one hand, there are many very common functions that work with the incarnations of any monads;  with the list monad they will work too.  On the other hand, there is an extension of the <font color="blue">Monad</font> type class called <font color="blue">MonadPlus</font> .  It complements the functionality of monads (specifically, the ‚Äúzero‚Äù element for the monad is defined there and the operation of ‚Äúadding‚Äù two monadic values ‚Äã‚Äãis introduced).  The lists are made by both <font color="blue">MonadPlus</font> and <font color="blue">MonadPlus</font> , and this means that common functions from <font color="blue">MonadPlus</font> will work on lists as well.  (There is, for example, a generalization of the <font color="blue">concat</font> function, the msum <font color="blue">function</font> , which works with all <font color="blue">MonadPlus</font> embodiments, including lists.) It is great to use generic functions that can work with many data types, but not specify them for each type separately.  This is a clear victory. <br><br><h5>  Next </h5><br><br>  In the next article, we will look at monads that allow you to track errors. <br><br><h5>  Content </h5><br>  <a href="http://habrahabr.ru/blogs/Haskell/127556/">Part 1: The Basics</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/128070/">Part 2: functions &gt;&gt; = and return</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/128538/">Part 3: Monad Laws</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/129909/">Part 4: Maybe Monad and List Monad</a> </div><p>Source: <a href="https://habr.com/ru/post/129909/">https://habr.com/ru/post/129909/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../129900/index.html">Multidomain in Apache without the hassle on the local host</a></li>
<li><a href="../129902/index.html">Whole habr</a></li>
<li><a href="../129903/index.html">Solving the problem of blurred fonts in Ubuntu</a></li>
<li><a href="../129906/index.html">Open Source Projects for the Benefit of Humanity</a></li>
<li><a href="../129907/index.html">Google announced Google Cloud SQL</a></li>
<li><a href="../129910/index.html">In the black and black city: What is kripi and what is it eaten with</a></li>
<li><a href="../129912/index.html">Optical Signaling Devices in the USA</a></li>
<li><a href="../129914/index.html">diveintohtml5 we transport on app engine</a></li>
<li><a href="../129915/index.html">Media Resources module: cornerstone</a></li>
<li><a href="../129916/index.html">Sean Parker and Sean Fanning launch a new startup: Airtime</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>