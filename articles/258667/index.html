<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Metaprogramming: what it is and how it should be</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Metaprogramming is a type of programming associated with the creation of programs that spawn other programs as a result of their work ( wiki ). This i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Metaprogramming: what it is and how it should be</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/329/822/782/3298227824c54f508cffeeea4b8db1cb.png" align="right"><br>  Metaprogramming is a type of programming associated with the creation of programs that spawn other programs as a result of their work ( <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25B0%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">wiki</a> ).  This is a rather general term, to which, according to the same Wikipedia, the source code is generated by external tools, various preprocessors, and ‚Äúcompiler plugins‚Äù - macros with the ability to modify the syntax tree directly in the compilation process, and even such an exotic possibility, as a self-modifying code, a program modification by the program itself at runtime. <br><br>  Although, of course, self-modifying code is rather a separate large topic worthy of a separate study;  here, by metaprogramming, we will understand the processes that occur during compilation of a program. <br><br>  Metaprogramming is implemented in one way or another in very different languages;  if you do not consider exotic and close to them languages, then the most famous example of metaprogramming is C ++ with its template system.  From the "new" languages ‚Äã‚Äãcan be considered D and Nim.  One of the most successful attempts to implement metaprogramming is the Nemerle language.  Actually, on the example of this four, we consider the subject. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Metaprogramming is an interesting topic;  In this article I will try to figure out what it is and how it should be in an ideal case. <br><a name="habracut"></a><br><h2>  Compilation stages </h2><br>  Before we start discussing a topic, we should look at how the compiler works. <br>  So, at the input of the compiler - the source code as a program text. <br><br>  The first stage of compilation is <b>lexical analysis</b> .  At this stage, the program from the solid text is divided into tokens (lexemes) - each variable, literal, operator, keyword, comment becomes a separate object.  Of course, working with such objects is much more convenient than directly with the source lines. <br><br>  The next stage is <b>parsing</b> , building a syntax tree.  At this stage, the linear structure becomes hierarchical;  in the way we actually represent it when writing programs.  Classes, functions, code blocks, operations become nodes of an abstract syntax tree (AST).  The syntax analysis itself consists of many stages;  which includes working with types (including type inference), and various optimizations. <br><br>  The final stage is <b>code generation</b> .  Based on the syntax tree, virtual and / or machine code is generated;  everything depends on the target architecture here - registers and memory are allocated, tree nodes are turned into sequences of commands, additional optimization is carried out. <br><br>  First of all, we will be interested in lexical and syntactic analysis (although at the stage of code generation, metaprogramming is also possible ... but this is a separate, large and completely unexplored topic). <br><img src="https://habrastorage.org/files/a52/4aa/18d/a524aa18da5a43acb55d218222a77961.png"><br><br><h2>  Lexical Macros </h2><br>  One of the oldest metaprogramming tools that has survived to the present day is the sshny preprocessor.  Probably, the first preprocessors were indeed separate programs, and after preprocessing they returned the result of their work back to the source text format.  The preprocessor is lexical, because it works at the level of tokens - that is, after receiving a sequence of tokens (although in fact the preprocessor still produces the simplest syntax analysis for its own purposes - for example, for its own macros with arguments).  A preprocessor can replace one sequence of tokens with another;  he knows nothing about the syntactical structure of the program - that‚Äôs why it‚Äôs so easy to make famous <br><pre><code class="hljs smalltalk"><span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre> <br>  The problem of the "sishny" preprocessor is that, on the one hand, it works at a too early stage (after lexical analysis, when the program still differs little from simple text);  on the other hand, this is not a full-fledged programming language, but merely a system of conditional compilation and replacement of some sequences of lexemes with others.  Of course, a lot can be done on this (see <a href="http://www.boost.org/doc/libs/1_58_0/libs/preprocessor/doc/index.html">boost.preprocessor</a> ), but it‚Äôs still not up to the full-fledged - and most importantly clear and convenient - metaprogramming. <br><br><h2>  C ++ Templates </h2><br>  The next most famous metaprogramming tool is C ++ templates - constructs that allow you to create parameterized classes and functions.  Templates, unlike sishnyh macros, already work with the syntax tree.  Consider the most common pattern in C ++ <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> T, <span class="hljs-type"><span class="hljs-type">int</span></span> N&gt; struct <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span> { T data[N]; };</code> </pre> <br>  and its application (instantiation): <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span>&gt; arr;</code> </pre> <br><br>  What happens here from the point of view of the compiler?  The template structure is a separate, special AST node;  The template has two parameters - type and integer constant.  At the point of instantiation of a template, template parameters (which are actually also AST nodes) are substituted into the template body instead of formal parameter names;  the result is the creation (or search for a previously created) node, which is used mainly in the syntactic tree.  Here the following is important: <b>both the template itself and the template parameters at the point of instantiation are not just a type and number, they are nodes of the syntax tree</b> .  That is, by passing the int type and the number 100, you actually construct and transfer two small syntactic trees (in this case, with one single node) to the larger syntax tree (the template body) and you end up with a new tree that is inserted into the main syntax tree  It looks like a macro macro substitution mechanism, but already at the level of syntax trees. <br><br>  Of course, template parameters can also be more complex constructs (for example, std :: vector &lt;std :: set &lt;int&gt;&gt; can be passed as a type).  But here is the time to pay attention to the fundamental incompleteness of the capabilities of C ++ templates.  In accordance with clause 14.1 of the standard, only types and some non-types can be template parameters: integers, enumeration elements, pointers to class members, pointers to global objects, and pointers to functions.  In general, the logic is clear - there is something in the list that can be determined at the compilation stage.  But for example, for unknown reasons there are no lines and floating point numbers in it.  And if you remember that the parameters are AST nodes, it becomes obvious that there are not many other useful things.  So, what prevents you from passing an arbitrary AST node, such as a variable name or a code block, as a parameter?  Similarly, the templates themselves can only be classes (structures) or functions.  And what prevents to make a template an arbitrary block of code - both imperative (control statements, expressions) and declarative (for example, a fragment of a structure or enumeration)?  Nothing but the lack of such features in C ++ itself. <br><br><h2>  From templates to syntax macros </h2><br>  The template mechanism, even in the form in which it exists in C ++, provides quite ample opportunities for metaprogramming.  And yet, it is just a system of substitutions of some AST fragments in others.  And what if we go further, and, apart from substitutions, allow something else - in particular, the execution of arbitrary actions on AST nodes using a script?  These are syntax macros, the most powerful metaprogramming tool to date.  Arbitrary code written by a programmer and executed at the compilation stage of the main program, having access to the compiler's API and to the structure of the compiled program in the form of AST, in fact, full-fledged compiler plugins embedded in the compiled program.  Not many programming languages ‚Äã‚Äãimplement this feature;  One of the best implementations in my opinion is in the <a href="http://www.nemerle.org/">Nemerle</a> language, so we will consider it in more detail. <br>  Here is the simplest example from <a href="">almost official</a> documentation: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">macro </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestMacro</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { WriteLine(<span class="hljs-string"><span class="hljs-string">"compile-time\n"</span></span>); &lt;[ WriteLine(<span class="hljs-string"><span class="hljs-string">"run-time\n"</span></span>) ]&gt;; }</code> </pre> <br>  If you insert a macro call into another file (which by the way is no different from a function call) <br><pre> <code class="hljs lisp">TestMacro()<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  then at compilation we will get the message ‚Äúcompile-time‚Äù in the compiler's log.  And when you start the program, the message ‚Äúrun-time‚Äù will be displayed in the console. <br><br>  As we can see, the macro is the usual code (in this case, in the same Nemerle language as the main program);  The difference is that this code is executed at the stage of compiling the main program.  Thus, compilation is divided into two phases: first, macros are compiled, and then the main program, upon compilation of which macros compiled earlier can be invoked.  The first line is executed at compile time.  The second line contains an interesting syntax - special brackets &lt;[]&gt;.  With the help of such brackets, you can take code fragments as in quotes, by analogy with ordinary strings.  But unlike lines, these are fragments of AST, and they are inserted into the main syntax tree of the program - just like templates when instantiated. <br><br>  And special brackets are needed because macros, unlike templates, are located in a different context, in a different dimension;  and we need to somehow divide the macro code and the code with which the macro operates.  Such strings in terms of Nemerle are called quasiquotes.  ‚ÄúQuasi‚Äù - because they can be constructed on the fly using interpolation - a feature known to everyone who writes in scripting languages, when you can insert the names of various variables into a string using a special syntax, and they turn into the values ‚Äã‚Äãof these variables.  Another example from the documentation: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">macro </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestMacro</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">myName</span></span></span><span class="hljs-function">)</span></span> { WriteLine(<span class="hljs-string"><span class="hljs-string">"Compile-time. myName = "</span></span> + myName.ToString()); &lt;[ WriteLine(<span class="hljs-string"><span class="hljs-string">"Run-time.\n Hello, "</span></span> + $myName) ]&gt;; }</code> </pre> <br>  The argument is an AST node (as well as for templates);  To insert a node into a quasiquote, use the $ symbol in front of its name. <br><br>  Of course, instead of such a line, it was possible to construct the AST fragment inserted manually using the compiler API and the types available in the context of the macro corresponding to the AST nodes.  Something like <br><pre> <code class="hljs lisp">new FunctionCall( <span class="hljs-name"><span class="hljs-name">new</span></span> Literal(<span class="hljs-string"><span class="hljs-string">"run-time\n"</span></span>) )</code> </pre> <br>  but it‚Äôs much easier to write the code ‚Äúas it is‚Äù and entrust the work on building AST to the compiler - after all, it is for this purpose that it is intended! <br><br>  In <a href="http://dlang.org/">D,</a> metaprogramming is presented using templates (which are generally similar to C ++ templates, although there are some improvements) and mixins.  Consider them in more detail.  The first type is patterned mixins;  the very extension of templates with the ability to make arbitrary code fragments template.  For example, this program will display the number 5. <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-function">mixin </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testMixin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> [] argv)</span></span></span><span class="hljs-function"> </span></span>{ mixin testMixin!(); writeln(x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  the variable declared in mixin becomes available after the mixin is included in the code. <br><br>  The second type of mixins is string mixins;  in this case, the string argument with the code in D becomes the argument of the mixin keyword: <br><pre> <code class="hljs lisp">mixin (`writeln(<span class="hljs-string"><span class="hljs-string">"hello world"</span></span>)<span class="hljs-comment"><span class="hljs-comment">;`);</span></span></code> </pre> <br>  The string, of course, must be known at compile time;  and this can be not only a constant explicitly defined string (otherwise there would be no point in this), but also a string formed programmatically at compile time!  In this case, the usual functions of the D language can be used to form a string ‚Äî the same ones that can be used in runtime.  Of course, with certain restrictions - the compiler must be able to execute the code of these functions at compile time (yes, a rather powerful interpreter of the D language itself is built into the D compiler). <br><br>  In the case of string mixins, we do not work with AST nodes in the form of quasiquote;  instead, we work with the source code of a language that is formed explicitly (for example, by concatenating strings) and traverses the full path of lexical and syntactic analysis.  There are advantages and disadvantages to this method.  Personally, direct work with AST seems to me more ‚Äúclean‚Äù and ideologically correct than generating source code lines;  however, working with strings may be useful in some situation. <br><br>  You can also briefly mention the <a href="http://nim-lang.org/">language of Nim</a> .  In it, the template keyword works similarly to the mixin template from D (and for classic templates in the early C ++ style, another concept is used - generic).  Using the macro keyword, syntax macros are declared that are somewhat similar to Nemerle macros.  In Nim, an attempt was made to formalize the phases of calling patterns ‚Äî using special pragmas, you can specify whether to call a pattern before or after resolving variable names.  Unlike D, there is some API to the compiler with which you can explicitly create AST nodes.  The issues of ‚Äúhygiene‚Äù of macros are touched upon (a macro is ‚Äúhygienic‚Äù if it is guaranteed that it does not affect identifiers at the point of its use ... I should consider these issues in more detail, but probably another time). <br><br><h2>  findings </h2><br>  Looking at the implementation of metaprogramming in different languages, there are some thoughts about how it should look like in the ideal case.  Here are some thoughts: <br><br>  <b>Metaprogramming should be explicit.</b> <br><br>  A macro call is a very specific thing (actually a VERY specific thing!), And the programmer must unambiguously visually identify such macros in the code (even without syntax highlighting).  Therefore, the syntax of macros must clearly differ from the syntax of functions.  More or less, this requirement is fulfilled only in D (the special keyword mixin at the calling point);  Nemerle and Nim macros are indistinguishable from functions.  Moreover, in Nemerle there are several other ways to call a macro - macro attributes and the ability to override the syntax of the language ... here you can digress a little and note that the syntax, unlike functions and classes, is global;  and I rather negatively relate to this possibility, because it leads to the erosion of the language and its transformation into a generator of languages, which means that for each new project you will have to learn a new language ... the perspective, I must say, is doubtful) <br><br>  <b>Using the same language for programs and metaprograms is not necessary.</b> <br>  In all the considered examples, metaprograms (macros) were written in the same language as the main program.  It seems that the developers of languages ‚Äã‚Äãdid not think about the possibility of using another programming language for macros, more adapted for interpretation than for compilation. <br><br>  Meanwhile, an example of an alternative approach has always been on the surface: in web programming, the html markup language and the javascript programming language are used;  javascript is executed during the rendering (compilation analog) html, from scripts the object model of the html document (HTML DOM) is available - a close enough analog of AST.  Using the appropriate functions, you can add, modify and delete HTML DOM nodes, and at different levels - both as source code html, and as nodes of the DOM tree. <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  html   ,  mixin  D <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'myDiv'</span></span>).innerHTML = <span class="hljs-string"><span class="hljs-string">'&lt;ol&gt;&lt;li&gt;html data&lt;/li&gt;&lt;/ol&gt;'</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  html    ,  Nim var link = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); link.setAttribute(<span class="hljs-string"><span class="hljs-string">'href'</span></span>, <span class="hljs-string"><span class="hljs-string">'mypage.htm'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'myDiv'</span></span>).appendChild(link);</code> </pre> <br>  What are the advantages and disadvantages of this approach? <br>  Obviously, the metaprogram should not be able to crash or suspend the compiler.  Obviously, if you write metaprograms on SI - with pointers and other low-level things, it will be very easy to bring it down.  On the other hand, using common code in programs and metaprograms is convenient.  Although this ‚Äúcommon code‚Äù is still limited to some very common things like pure algorithms: the compiler's API is not applicable in programs, and the ‚Äúreal OS‚Äù libraries (including graphics, window system, network ...) are very poorly applicable in metaprograms .  Of course, you can create a couple of your windows during compilation and display them on the screen, but why? <br><br>  Thus, it is not necessary that programs and metaprograms be in the same language.  Programs and metaprograms have completely different tasks and completely different execution environments.  Probably, the best solution is to leave the programmer free and use several languages: both a safe subset of the main language and some common scripting language - the same javascript is fine. <br><br>  <b>Standardization API compiler</b> <br>  The appearance and distribution in a language of full metaprogramming will inevitably require standardization of the compiler's API.  Of course, this would have a positive impact on the quality of the compilers themselves, on their compliance with the Standard, and compatibility with each other.  And it seems that the example of html and browsers in itself is quite good.  Although the structure of AST is more complicated than html markup (incompatibility of some nodes and other features), it would be quite good to take as a basis for building such an API the experience of browser technologies combined with the experience of existing implementations of metaprogramming. <br><br>  <b>IDE support</b> <br>  Metaprogramming can be quite complicated.  Until now, all the implementations known to me did not suggest any means of facilitating the work of a programmer: to compile in mind is still a undertaking (of course there are fans ...).  Although metaprogrammers in C ++, for example, do just that.  Therefore, I consider it necessary the appearance of such means as the disclosure of templates and macros in a special IDE mode - both in debug mode and in code editing mode;  some analogue of executing the code "from the command line" <a href="https://ru.wikipedia.org/wiki/REPL">REPL</a> for macros.  A programmer must have a full set of tools for visual access to AST, for separate compilation and test run of macros, for ‚Äúcompiling step by step‚Äù (just like that - for viewing in a special debugger how the macro works when compiling the main code step by step). <br><br>  Well, perhaps that's all.  A lot of questions remained behind the scenes, but I think even this is enough to appreciate the incredible power of metaprogramming.  Now imagine that all this would already be in C ++.  Look at the Boost library, at those amazing and incredible things that people do even on existing templates and lexical macros ... <br><br>  If this were so ... what truly hacking opportunities would open up to us! </div><p>Source: <a href="https://habr.com/ru/post/258667/">https://habr.com/ru/post/258667/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../258657/index.html">Introduction to Amazon EC2 Container Service</a></li>
<li><a href="../258659/index.html">Notifications can help you know your audience better + news + cool</a></li>
<li><a href="../258661/index.html">Introducing OsmocomBB: 0x02 Hardware</a></li>
<li><a href="../258663/index.html">PENTESTIT ethical hacking and penetration testing courses</a></li>
<li><a href="../258665/index.html">The digest of interesting materials from the world of web development and IT for the last week? 161 (May 18 - 24, 2015)</a></li>
<li><a href="../258671/index.html">How I use the traits</a></li>
<li><a href="../258673/index.html">Choosing ciphersuites for TLS and Logjam vulnerability. Yandex experience</a></li>
<li><a href="../258675/index.html">Moscow hackathon for machine learning - June 6-7, at the Microsoft office on Krylatskoe</a></li>
<li><a href="../258677/index.html">How to build a smart home</a></li>
<li><a href="../258679/index.html">Restaurant Automation: 24 interesting tools</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>