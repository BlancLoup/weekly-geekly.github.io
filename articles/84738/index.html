<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Based on Cisco Live 2009: Advanced Concepts of DMVPN</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuing the series of articles on VPN, I want to share the details about the implementation of DMVPN technology, outlined on Cisco Live 2009. Caref...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Based on Cisco Live 2009: Advanced Concepts of DMVPN</h1><div class="post__text post__text-html js-mediator-article"> Continuing the series of articles on VPN, I want to share the details about the implementation of DMVPN technology, outlined on Cisco Live 2009. Careful, many letters :) <br><a name="habracut"></a><br>  I will begin according to the established tradition with the <u>formulation of the problem</u> . <br><br>  So, we have a central office and several branches, we want to combine them into a common network using public communication channels (Internet). <br><img src="http://img24.imageshack.us/img24/6099/zeroris.png" alt="image"><br>  Unlike the described GET VPN technology, the use of Internet channels obliges us to use tunneling (replacing the header). <br><br>  What is Dynamic Multipoint VPNs (DMVPN)?  In short, this is a multipoint GRE ( <i>mGRE</i> ) <i>association</i> with IPSec. <br>  mGRE is a tunneling protocol that differs from traditional GRE by the possibility of establishing tunnels with several neighbors on the same interface.  The basis is the use of Next-Hop Resolution Protocol ( <i>NHRP</i> ), which allows you to dynamically establish such connections.  IPSec, interacting with NHRP, establishes SA as necessary and provides encryption for each separate connection. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It is important that while the connection topology is a classic hub-n-spoke, DMVPN allows you to dynamically establish spoke-to-spoke tunnels. <br><br>  In short, the idea behind NHRP is to specify a hub or <i>NHS</i> (Next-Hop Server), which is static for all spoke.  Each spoke is registered dynamically (i.e., NHS doesn‚Äôt know the spoke addresses initially), establishes a permanent tunnel with the NHS and the NHS makes its tunnel and real-time (mapping) addresses in the base of its neighbors, and also reports the rest, if necessary, so that could establish connections with each other directly, and not through a hub.  Connections of spoke-to-spoke, unlike hub-to-spoke, are not permanent, but temporary.  As soon as the traffic between branches is absent for some time, the tunnel between them is removed.  This allows using weaker models as spoke routers, since they do not need to hold as many connections as there are spoke.  As a hub, on the contrary, you have to choose a router strong enough to withstand the connection with all spoke. <br><img src="http://img16.imageshack.us/img16/5923/firstris.png" alt="image"><br>  Since each branch office reports its existence (through registration) dynamically, branch offices can be hidden behind dynamic NAT.  And since  Since the hub is configured statically on each branch office router, it can only be located behind static NAT. <br><br>  Now we introduce the concept of <u>phases DMVPN</u> .  Phases in this case are understood as the type (or character) of the spoke-to-spoke or spoke-to-hub interaction.  There are three phases in total. <br>  <b>Phase 1</b> .  Only hub-to-spoke tunnels are implemented, no spoke-to-spoke tunnels are installed and all traffic flows through the hub.  In this case, it is logical to replace the next-hop routing protocols from the NHC address to the NHS address. <br>  Registration is as follows: <br><img src="http://img98.imageshack.us/img98/9138/nhrpphase1.png" alt="image"><br>  Those.  first an IPSec tunnel is established, then the NHC sends an NHRP registration request message. <br>  The interval between messages is 1/3 'ip nhrp registration holdtime' or 'ip nhrp registration timeout'.  If the NHS does not respond, the interval increases exponentially, starting from 1 (1, 2, 4, 8 ..., 64, ...).  In this case, after the third attempt NHS will be marked as Down and will not be used.  In other words, registration requests perform the keepalive function. <br>  Each NHRP Registration message contains a matching NHC tunnel address and its real address (NBMA) and may also contain extension headers, such as authentication, NAT, etc. <br><br>  The response to this message is naturally NHRP registration reply.  Contains the correspondence between real and tunnel addresses of NHC and NHS, as well as all the same extension headers.  In fact, it also confirms the viability of the hub. <br>  After registering the NHC, the output of the NHRP table is as follows: <br>  <u>On Hub</u> : <br> <code>HUB#sh ip nhrp <br> 10.1.1.2/32 via 10.1.1.2, Tunnel0 created 15:17:10, expire 01:22:43 <br> Type: dynamic, Flags: unique registered <br> NBMA address: 172.16.2.1 <br> 10.1.1.3/32 via 10.1.1.3, Tunnel0 created 15:17:10, expire 01:22:43 <br> Type: dynamic, Flags: unique registered <br> NBMA address: 172.16.3.1</code> <br>  <u>On Spoke 1</u> : <br> <code>SPOKE1#sh ip nhrp <br> 10.1.1.1/32 via 10.1.1.1, Tunnel0 created 15:17:45, never expire <br> Type: static, Flags: used <br> NBMA address: 172.16.1.1</code> <br> <br>  Since we have touched the mapping output, then let's discuss the <s>types and flags</s> corresponding to this mapping. <br>  <u><i>Types</i></u> <br><ol><li>  <i>Static</i> - a record for which the interface clearly defines the correspondence of the tunnel address and the real one (ip nhrp map ...) </li><li>  <i>Dynamic</i> is an NHRP record.  There are two types: </li><li>  <i>Incomplete</i> - we know the tunnel address spoke, but have not yet received a response to the NHRP Resolution request. </li></ol><br>  <u><i>Flags</i></u> <br><ol><li>  <i>Unique</i> .  It means that this mapping is unique and in the case of changing the NBMA address this record will not be updated. </li><li>  <i>Registered</i> - obtained from NHRP Registration, usually on the hub. </li><li>  <i>Learned</i> - obtained from NHRP Registration, on the contrary, usually on spoke. \ </li><li>  <i>Authoritative</i> .  Can be used to respond to NHRP resolution request. </li><li>  <i>Used</i> .  The recording was used in the previous 60 seconds. </li><li>  <i>Router</i> .  Entries for a remote router or for networks behind it are marked with such a flag. </li><li>  <i>Implicit</i>  The record is obtained from the source information in the NHRP packet. </li><li>  <i>Local</i> .  Information about our local network that we gave to some other spoke in response to the NHRP request.  It also stores the NBMA address of this spoke. </li><li>  <i>NAT</i> .  (appeared in 12.4 (6) T version of IOS, not shown after 12.4 (15) T. Indicates that the remote peer supports NAT operation. After 12.4 (15) T just shows the claimed NBMA address in the record as well. </li><li>  <i>no socket</i> .  A record for which the router does not need or does not want to establish an IPSec tunnel, because there is no traffic that needs this tunnel.  If further such traffic appears, the entry will be converted to a ‚Äúsocket‚Äù and the IPsec tunnel will be raised.  Entries like Local and implicit are always marked first as ‚Äúno socket‚Äù.  In addition, the NHRP by default caches source information from NHRP resolution request or reply when they pass through a router.  To allow such caching, but not to raise the IPSec tunnel, they are marked as (no socket).  If this is not done, unnecessary IPSec sockets from the hub to spoke will be formed, which will not be used.  The data arriving at the tunnel interface and leaving it cannot use (no socket) recording, since in this case the router is an intermediate node in the path between the two interacting, and we hardly want to raise another tunnel with an intermediate point.  If at some point in time the router receives a data packet that did not come from the tunnel interface and must use (nmo socket) a record, the router converts it into a (socket) record, since in this case the router will be the exit point to the tunnel for this data flow.  Also, these (no socket) entries are marked as (non-authoritative), since only records obtained from NHRP registrations are marked as (authoritative). </li><li>  <i>Negative</i> .  Indicates that the requested mapping has not yet been received.  When NHRP sends the NHRP resolution request, it sets this (negative) flag to an incomplete entry, which saves the router from sending these requests multiple times, waiting for a response or establishing an IPSec connection. </li></ol><br><br>  After registration, route information is exchanged, in which the hub puts itself as the next-hop for each route.  After that, NHC can exchange data, but through the hub. <br><br>  From the <u>advantages of</u> this technology, it is possible to note the presence of only one tunnel on each NHC, which saves resources. <br>  <u>The disadvantage</u> is obvious: routing through the hub not only loads it, but also leads to significant delays in transmission. <br><br>  <b>Phase 2</b> .  Here we can already build spoke-to-spoke tunnels, for which the ‚Äúdeception‚Äù of CEF is used.  All affiliates receive full routing information with unchanged next-hop (I will explain later how to do this). <br><br>  NHC, receiving such a route from the NHS, places the corresponding CEF record marked ‚Äúinvalid‚Äù for the route, and for the next-hop address (i.e., address of another NHC), the glean record (i.e., the address L3 must be allowed to address L2).  This permission is performed by the NHRP when the first packet is sent along this route. <br><br>  An example of such records: <br><br> <code>SPOKE1#sh ip cef 192.168.2.0 <br> 192.168.2.0/24, version 27, epoch 0 <br> 0 packets, 0 bytes <br> via 10.1.1.3, Tunnel0, 0 dependencies <br> next hop 10.1.1.3, Tunnel0 <br> invalid adjacency <br> SPOKE1#sh ip cef 10.1.1.3 <br> 10.1.1.0/24, version 20, epoch 0, attached, connected <br> 0 packets, 0 bytes <br> via Tunnel0, 0 dependencies <br> valid glean adjacency</code> <br> <br>  At the NHRP level, there are also three types of records corresponding to the second phase. <br><ol><li>  Record is missing.  Everything is transparent, the traffic is sent to the NHS, followed by the NHRP resolution request. </li><li>  Record type (no socket).  It seems we know who to send, but not established IPSec connection.  Traffic is still flying to the NHS, and a connection is being established with another NHC </li><li>  Record type (socket).  Traffic flies to another NHC over an IPSec tunnel. </li></ol><br><br>  The first packet will be sent through the NHS using process switching.  The NHC will send the NHS NHRP resolution request, to which the NHS will respond with an address that allows you to add to the CEF record. <br><br>  <u>Feature</u>  Prior to iOS 12.4.5a, the request and response ran through the entire NHS chain.  After (not at 6500 and 7600), the response to NHRP resolution request was shifted to the NHC itself, whose address we are interested in.  The interaction scheme of the new phase implementation is shown in the figure: <br><img src="http://img63.imageshack.us/img63/1376/nhrp2.png" alt="image"><br><br>  Sample output from the debug nhrp packet command for phase 2. <br> <code>SPOKE1#ping 192.168.2.1 <br> <br> Type escape sequence to abort. <br> Sending 5, 100-byte ICMP Echos to 192.168.2.1, timeout is 2 seconds: <br> !!!!! <br> Success rate is 100 percent (5/5), round-trip min/avg/max = 8/41/72 ms <br> SPOKE1# <br> *Mar 1 00:30:01.367: NHRP: Send Resolution Request via Tunnel0 vrf 0, packet size: 81 <br> *Mar 1 00:30:01.367: src: 10.1.1.2, dst: 10.1.1.3 <br> *Mar 1 00:30:01.371: (F) afn: IPv4(1), type: IP(800), hop: 255, ver: 1 <br> *Mar 1 00:30:01.371: shtl: 4(NSAP), sstl: 0(NSAP) <br> *Mar 1 00:30:01.371: (M) flags: "router auth src-stable", reqid: 4 <br> *Mar 1 00:30:01.371: <b><u>src NBMA: 172.16.2.1</u></b> <br> *Mar 1 00:30:01.371: src protocol: 10.1.1.2, dst protocol: 10.1.1.3 <br> *Mar 1 00:30:01.375: (C-1) code: no error(0) <br> *Mar 1 00:30:01.375: prefix: 0, mtu: 1514, hd_time: 7200 <br> *Mar 1 00:30:01.375: addr_len: 0(NSAP), subaddr_len: 0(NSAP), proto_len: 0, pref: 0 <br> *Mar 1 00:30:01.375: NHRP: Send Resolution Request via Tunnel0 vrf 0, packet size: 81 <br> *Mar 1 00:30:01.379: src: 10.1.1.2, dst: 10.1.1.1 <br> *Mar 1 00:30:01.379: (F) afn: IPv4(1), type: IP(800), hop: 255, ver: 1 <br> *Mar 1 00:30:01.379: shtl: 4(NSAP), sstl: 0(NSAP) <br> *Mar 1 00:30:01.383: (M) flags: "router auth src-stable", reqid: 4 <br> *Mar 1 00:30:01.383: src NBMA: 172.16.2.1 <br> *Mar 1 00:30:01.383: src protocol: 10.1.1.2, dst protocol: 10.1.1.3 <br> *Mar 1 00:30:01.383: (C-1) code: no error(0) <br> *Mar 1 00:30:01.387: prefix: 0, mtu: 1514, hd_time: 7200 <br> *Mar 1 00:30:01.387: addr_len: 0(NSAP), subaddr_len: 0(NSAP), proto_len: 0, pref: 0 <br> *Mar 1 00:30:01.415: NHRP: Receive Resolution Reply via Tunnel0 vrf 0, packet size: 109 <br> *Mar 1 00:30:01.415: (F) afn: IPv4(1), type: IP(800), hop: 255, ver: 1 <br> *Mar 1 00:30:01.415: shtl: 4(NSAP), sstl: 0(NSAP) <br> *Mar 1 00:30:01.415: (M) flags: "router auth dst-stable unique src-stable", reqid: 4 <br> *Mar 1 00:30:01.419: <b><u>src NBMA: 172.16.2.1</u></b> <br> *Mar 1 00:30:01.419: src protocol: 10.1.1.2, dst protocol: 10.1.1.3 <br> *Mar 1 00:30:01.419: (C-1) code: no error(0) <br> *Mar 1 00:30:01.423: prefix: 32, mtu: 1514, hd_time: 6089 <br> *Mar 1 00:30:01.423: addr_len: 4(NSAP), subaddr_len: 0(NSAP), proto_len: 4, pref: 0 <br> *Mar 1 00:30:01.423: client NBMA: 172.16.3.1 <br> *Mar 1 00:30:01.423: client protocol: 10.1.1.3</code> <br> <br>  The presence of the src NBMA field allows the destination NHC to respond bypassing the hub. <br>  <u>Remarks</u> . <br><ul><li>  Saving the next-hop address at first glance looks like a logical and correct solution.  But it has one drawback: each NHC must receive the entire routing table from the NHS, without using summaries.  This allows you to use only one level of NHS, i.e.  we can serve half NHC with one NHS, the other half with another, but we are obliged to connect them as NHS for each other.  This is necessary in order to allow the NHRP resolution request to pass all potential NHS.  And their static indication reduces overall reliability. </li><li>  Well and besides, the first packet will be sent not through CEF, but through process switching. </li></ul><br>  <b>Phase 3</b> . <br>  In this phase, we allow the NHC to participate in the response to the NHRP resolution requests, taking this ‚Äúadvantage‚Äù from the NHS. <br><br>  Consider the steps. <br><img src="http://img52.imageshack.us/img52/4383/nhrp3.png" alt="image"><br><ol><li>  NHC is traditionally registered on the NHS, which allows the latter to establish a routing protocol neighborhood with the NHC and exchange routing information.  At the same time, the NHS is not obliged to keep the route information in its original form: it can change the next-hop for itself and even its summatization.  Moreover, the more general route we send back to NHC, the easier it will be :) </li><li>  NHC receives the routing information and populates the CEF table.  Since we now have the next-hop NHS itself, we will not have ‚Äúinvalid‚Äù or ‚Äúglean‚Äù entries.  In other words, the first packet along this route will be sent using CEF ... where ??? ... right, to the hub!  But this, among other things, means that the absence of "incorrect" entries in CEF will not cause NHRP resolution requests!  And here <i>NHRP redirect message</i> ! </li><li>  Step 3 - a direct continuation of the second.  So, the first packet sent from spoke to another spoke goes through the NHS.  When the NHS receives a packet via the mGRE tunnel, and then is forced to send it back over the same interface (but to another NHC), the NHS sends the source of this packet to the main third-party feature, the NHRP redirect message.  This message tells NHC that it is using a ‚Äúnot quite right‚Äù :) route in packet routing.  And it ‚Äúhints‚Äù that it would be good to use NHRP resolution to refine the path of the NHC.  The first packet itself is however sent to the NHS at. </li><li>  Again we continue.  Now the NHC that sent the first packet receives a redirect message containing the destination address of that very first packet.  This NHC sends the NHRP resolution request about the same IP, but (attention !!!) not to the NHS, but <b>again at the same address</b> !  Those.  NHC asks another NHC for its real address.  Once again: the destination address in the NHRP resolution request is not the NHS, but the NHC we are interested in, although we (like the first packet) will get to it via the NHS.  NHS will send it in the same way as intended (i.e. again the packet will go through the hub, non-optimally). </li><li>  Decoupling :) Now our destination NHC (and not NHS !!) responds to the resolution request.  Using the real address attached to the request, this NHC will respond to the sender directly, bypassing the NHS.  In this case, the answer will contain the entire network (route, prefix) found in the RIB, and not just the requested address.  When our NHC sender of the request receives such a response, it will know the real next-hop of such an address, fill in the NHRP table, and correct the entry in CEF (or create a new one). </li></ol><br><br>  Example debazh output: <br> <code>SPOKE2#ping 192.168.1.1 <br> <br> Type escape sequence to abort. <br> Sending 5, 100-byte ICMP Echos to 192.168.1.1, timeout is 2 seconds: <br> !!!!! <br> Success rate is 100 percent (5/5), round-trip min/avg/max = 32/51/84 ms <br> SPOKE2# <br> *Mar 1 00:07:57.151: NHRP: <u>Receive Traffic Indication</u> via Tunnel0 vrf 0, packet size: 97 <br> *Mar 1 00:07:57.155: (F) afn: IPv4(1), type: IP(800), hop: 255, ver: 1 <br> *Mar 1 00:07:57.155: shtl: 4(NSAP), sstl: 0(NSAP) <br> *Mar 1 00:07:57.159: (M) traffic code: redirect(0) <br> *Mar 1 00:07:57.159: src NBMA: 172.16.1.1 <br> *Mar 1 00:07:57.159: src protocol: 10.1.1.1, dst protocol: 10.1.1.3 <br> *Mar 1 00:07:57.163: Contents of nhrp traffic indication packet: <br> *Mar 1 00:07:57.167: 45 00 00 64 00 00 00 00 FE 01 EF EB 0A 01 01 03 <br> *Mar 1 00:07:57.171: C0 A8 01 01 08 00 36 7F 00 00 00 <br> *Mar 1 00:07:57.211: NHRP: Send Resolution Request via Tunnel0 vrf 0, packet size: 85 <br> *Mar 1 00:07:57.215: src: 10.1.1.3, dst: 192.168.1.1 <br> *Mar 1 00:07:57.219: (F) afn: IPv4(1), type: IP(800), hop: 255, ver: 1 <br> *Mar 1 00:07:57.219: shtl: 4(NSAP), sstl: 0(NSAP) <br> *Mar 1 00:07:57.219: (M) flags: "router auth src-stable nat ", reqid: 5 <br> *Mar 1 00:07:57.219: src NBMA: 172.16.3.1 <br> *Mar 1 00:07:57.219: src protocol: 10.1.1.3, dst protocol: 192.168.1.1 <br> *Mar 1 00:07:57.219: (C-1) code: no error(0) <br> *Mar 1 00:07:57.219: prefix: 0, mtu: 1514, hd_time: 7200 <br> *Mar 1 00:07:57.219: addr_len: 0(NSAP), subaddr_len: 0(NSAP), proto_len: 0, pref: 0 <br> *Mar 1 00:07:57.247: NHRP: Receive Resolution Request via Tunnel0 vrf 0, packet size: 105 <br> *Mar 1 00:07:57.251: (F) afn: IPv4(1), type: IP(800), hop: 254, ver: 1 <br> *Mar 1 00:07:57.251: shtl: 4(NSAP), sstl: 0(NSAP) <br> *Mar 1 00:07:57.255: (M) flags: "router auth src-stable nat ", reqid: 6 <br> *Mar 1 00:07:57.255: src NBMA: 172.16.2.1 <br> *Mar 1 00:07:57.259: src protocol: 10.1.1.2, dst protocol: 10.1.1.3 <br> *Mar 1 00:07:57.263: (C-1) code: no error(0) <br> *Mar 1 00:07:57.263: prefix: 0, mtu: 1514, hd_time: 7200 <br> *Mar 1 00:07:57.263: addr_len: 0(NSAP), subaddr_len: 0(NSAP), proto_len: 0, pref: 0 <br> *Mar 1 00:07:57.271: NHRP: Send Resolution Reply via Tunnel0 vrf 0, packet size: 133 <br> *Mar 1 00:07:57.275: src: 10.1.1.3, dst: 10.1.1.2 <br> *Mar 1 00:07:57.279: (F) afn: IPv4(1), type: IP(800), hop: 255, ver: 1 <br> *Mar 1 00:07:57.279: shtl: 4(NSAP), sstl: 0(NSAP) <br> *Mar 1 00:07:57.283: (M) flags: "router auth dst-stable unique src-stable nat ", reqid: 6 <br> *Mar 1 00:07:57.283: src NBMA: 172.16.2.1 <br> *Mar 1 00:07:57.287: src protocol: 10.1.1.2, dst protocol: 10.1.1.3 <br> *Mar 1 00:07:57.291: (C-1) code: no error(0) <br> *Mar 1 00:07:57.291: prefix: 32, mtu: 1514, hd_time: 7200 <br> *Mar 1 00:07:57.295: addr_len: 4(NSAP), subaddr_len: 0(NSAP), proto_len: 4, pref: 0 <br> *Mar 1 00:07:57.299: client NBMA: 172.16.3.1 <br> *Mar 1 00:07:57.299: client protocol: 10.1.1.3 <br> *Mar 1 00:07:57.323: NHRP: Receive Resolution Reply via Tunnel0 vrf 0, packet size: 153 <br> *Mar 1 00:07:57.331: (F) afn: IPv4(1), type: IP(800), hop: 254, ver: 1 <br> *Mar 1 00:07:57.331: shtl: 4(NSAP), sstl: 0(NSAP) <br> *Mar 1 00:07:57.331: (M) flags: "router auth dst-stable unique src-stable nat ", reqid: 5 <br> *Mar 1 00:07:57.335: src NBMA: 172.16.3.1 <br> *Mar 1 00:07:57.339: src protocol: 10.1.1.3, dst protocol: 192.168.1.1 <br> *Mar 1 00:07:57.343: (C-1) code: no error(0) <br> *Mar 1 00:07:57.343: prefix: 24, mtu: 1514, hd_time: 7200 <br> *Mar 1 00:07:57.343: addr_len: 4(NSAP), subaddr_len: 0(NSAP), proto_len: 4, pref: 0 <br> *Mar 1 00:07:57.347: client NBMA: 172.16.2.1 <br> *Mar 1 00:07:57.347: client protocol: 10.1.1.2</code> <br> <br>  Underlined highlighted receiving NHRP redirect. <br><br>  Let's <u>summarize the third phase</u> : <br><ol><li>  No invalid entries in CEF.  All packets use CEF, and NHRP requests are now called not by an incorrect entry in CEF, but by an explicit indication from the NHS. </li><li>  NHS is no longer the only source of NHRP information.  The rest of the NHC was also involved.  More like peer2peer. </li><li>  NHRP replies from NHC contains a whole prefix, not just next-hop.  This, by the way, allows us to send a general route from the NHS to the NHC, since  The destination NHC will return the prefix that belongs to it, which may be more particular than the one originally received from the NHS. </li><li>  The initial packets run through the hub. </li><li>  Since the answer is not NHS, but NHC, there may be several levels of hubs in the topology. </li></ol><br>  Now let's <b>summarize the routing results</b> , armed with phase knowledge. <br><br>  <u>Postulate 1</u> .  NHC only establishes a routing protocol neighborhood with the NHS, and never with the NHC.  NHC reports on its local networks NHS. <br>  <u>Postulate 2</u> .  NHS establishes a neighborhood with all NHC.  In doing so, he informs NHC about all networks learned from other NHCs and his local networks. <br>  In addition, regardless of the phase, you need to turn off the split horizon for RIP and EIGRP. <br>  But there is a difference in functioning, depending on the phase: <br><ol><li>  In phase 1 and phase 3, the hub cannot save the next-hop in the routing information (for example, BGP next-hop-self, OSPF network point-to-multipoint), due to this it is possible to use summatization.  In addition, the number of hubs is not limited and they are not required to be the same level. </li><li>  In phase 2, on the contrary, the hub is <b>obliged to</b> save next-hop in the routing information (EIGRP <b>no ip next-hop-self</b> , BGP default, OSPF network broadcast), it is possible to use no more than two hubs. </li></ol><br>  <u>Postulate 3</u> .  The NHS establishes a routing protocol adjacency with other NHSs.  Wherein <br><ol><li>  In phase 1 and phase 3, the routing protocol between hubs may differ from the routing protocol between hubs and NHC. </li><li>  In phase 2, hubs <b>are required to</b> use the same protocol. </li></ol><br><br>  ‚ÄúNow that we have reviewed the theoretical fundamentals of DMVPN operation, let's see how to configure it on Cisco routers. <br>  <b>The setting</b> will differ depending on the desired phase and the role of the router (Hub or spoke). <br><br>  In order: <br><br>  <u>In</u> terms of NHRP, the <u>hub is</u> configured the same for Phase 1 and Phase 2. The difference will be in the configuration of the routing protocols. <br><br>  Create a tunnel interface and assign it the address: <br> <code>Hub(config)# interface Tunnel0 <br> Hub(config-if)# ip address 10.1.1.1 255.255.255.0</code> <br> <br>  Set the source interface and mode - GRE multipoint <br> <code>Hub(config-if)# tunnel source FastEthernet0/0 <br> Hub(config-if)# tunnel mode gre multipoint</code> <br> <br>  Then we actually set the NHRP protocol settings. <br>  Network ID: <br> <code>Hub(config-if)# ip nhrp network-id 123</code> <br> <br>  Optional authentication: <br> <code>Hub(config-if)# ip nhrp authentication cisco</code> <br> <br>  And we set up mapping of multicast mailings to dynamically recognizable addresses <br> <code>Hub(config-if)# ip nhrp map multicast dynamic</code> <br> <br>  <u><i>Phase 3.</i></u> It differs from Phase 2 only in its presence <br> <code>Hub(config-if)# ip nhrp redirect</code> <br> <br>  <u>Spoke</u> . <br><br>  <u><i>Phase 1.</i></u> <br>  Create a tunnel interface and assign it the address: <br> <code>Spoke1(config)# interface Tunnel0 <br> Spoke1(config-if)# ip address 10.1.1.2 255.255.255.0</code> <br> <br>  Set the source interface <br> <code>Spoke1(config-if)# tunnel source FastEthernet0/0</code> <br> <br>  Since we plan to communicate only with the hub - we can explicitly set the destination address and the type of tunnel - the usual GRE IP (by default) <br> <code>Spoke1(config-if)# tunnel destination 172.16.1.1</code> <br> <br>  Because  to register using the NHRP protocol anyway, then we set the network identifier: <br> <code>Spoke1(config-if)# ip nhrp network-id 123</code> <br> <br>  Optional authentication: <br> <code>Spoke1(config-if)# ip nhrp authentication cisco</code> <br> <br>  And we configure the mapping of multicast mailings to the hub (attention, not tunnel, but real) <br> <code>Spoke1(config-if)# ip nhrp map multicast 172.16.1.1</code> <br> <br>  Specify the NHS tunnel address: <br> <code>Spoke1(config-if)# ip nhrp nhs 10.1.1.1</code> <br> <br>  And we create a mapping for this tunnel address into a real one: <br> <code>Spoke1(config-if)# ip nhrp map 10.1.1.1 172.16.1.1</code> <br> <br>  <u><i>Phase 2.</i></u> <br>  Almost the same, just set the tunnel mode and do not specify the tunnel destination: <br> <code>Spoke1(config)# interface Tunnel0 <br> Spoke1(config-if)# ip address 10.1.1.2 255.255.255.0 <br> Spoke1(config-if)# tunnel source FastEthernet0/0 <br> Spoke1(config-if)# tunnel mode gre multipoint <br> Spoke1(config-if)# ip nhrp network-id 123 <br> Spoke1(config-if)# ip nhrp authentication cisco <br> Spoke1(config-if)# ip nhrp map multicast 172.16.1.1 <br> Spoke1(config-if)# ip nhrp nhs 10.1.1.1 <br> Spoke1(config-if)# ip nhrp map 10.1.1.1 172.16.1.1</code> <br> <br>  <u><i>Phase 3.</i></u> It differs from Phase 2 only in its presence <br> <code>Spoke1(config-if)# ip nhrp shortcut <br> Spoke1(config-if)# ip nhrp redirect</code> <br> <br>  So we set up mGRE.  It remains to attach <b>IPSec</b> to it.  The setting is the same on all routers. <br><br>  Create <u>an ISAKMP policy</u> <br> <code>Router(config)#crypto isakmp policy 10 <br> Router(config-isakmp)# encr aes <br> Router(config-isakmp)# authentication pre-share <br> Router(config-isakmp)# group 2</code> <br> <br>  For ease of description, I use shared key authentication. <br> <code>Router(config-isakmp)#crypto isakmp key cisco address 0.0.0.0 0.0.0.0</code> <br> <br>  Turn on <u>keepalive</u> <br> <code>Router(config)#crypto isakmp keepalive 10 3 periodic</code> <br> <br>  Create a transform-set and bind it to the <u>IPSec profile</u> . <br> <code>Router(config)#crypto ipsec transform-set IPSEC_SET esp-aes esp-sha-hmac <br> Router(cfg-crypto-trans)#crypto ipsec profile IPSEC_PROFILE <br> Router(ipsec-profile)# set transform-set IPSEC_SET</code> <br> <br>  <u>We cling a profile</u> on the tunnel interface <br> <code>Router(config)#interface tunnel 0 <br> Router(config-if)#tunnel protection ipsec profile IPSEC_PROFILE</code> <br> <br>  Now let's talk about <b>the routing protocol settings</b> .  For simplicity, I will limit myself to the two most common IGPs: OSPF and EIGRP, plus one of them is link-state, the other is distance-vector. <br><br>  So, as we have already found out, <u>phase 1 &amp; 3</u> oblige the <i><u>hub</u></i> to change next-hop in the routing information to its address, therefore <br>  OSPF: <code>Hub(config-if)# ip ospf network point-to-multipoint</code> <br>  In the case of EIGRP, the next-hop is changed by default and does not require additional efforts. <br>  In addition, in the case of EIGRP and RIP, you need to disable the split-horizon: <code>Hub(config-if)#no ip split-horizon eigrp <i>AS_NUMBER</i></code> <br><br>  Everything is simple to <i><u>spoke</u></i> : we configure the OSPF network type and forcibly prohibit the spoke to be DR or BDR. <br>  OSPF: <code>Spoke(config-if)# ip ospf network point-to-multipoint <br> Spoke(config-if)# ip ospf priority 0</code> <code>Spoke(config-if)# ip ospf network point-to-multipoint <br> Spoke(config-if)# ip ospf priority 0</code> <br> <br>  For <u>phase 2 a</u> little bit different. <br><br>  At the <u>hub,</u> we no longer need to change the next-hop, but the split horizon still hinders us.  therefore <br>  OSPF: <code>Hub(config-if)# ip ospf network broadcast</code> (timers to taste) <br>  EIGRP: <code>Hub(config-if)#no ip next-hop-self eigrp <i>AS_NUMBER</i> <br> Hub(config-if)#no ip split-horizon eigrp <i>AS_NUMBER</i></code> <code>Hub(config-if)#no ip next-hop-self eigrp <i>AS_NUMBER</i> <br> Hub(config-if)#no ip split-horizon eigrp <i>AS_NUMBER</i></code> <br> <br>  We also set the OSPF network type as broadcast to <i><u>spoke</u></i> , and since we only need to have a hub neighborhood, we still forcefully forbid the spoke to be DR or BDR. <br>  OSPF: <code>Spoke(config-if)# ip ospf network broadcast <br> Spoke(config-if)# ip ospf priority 0</code> <code>Spoke(config-if)# ip ospf network broadcast <br> Spoke(config-if)# ip ospf priority 0</code> <br> <br>  Let's <b>summarize the</b> technology. <br><ul><li>  DMVPN is a technology that allows you to build a VPN with multiple participants.  The basic topology is hub-n-spoke, but it is possible to dynamically establish spoke-to-spoke tunnels and even a hierarchy of hubs. </li><li>  The basis is mGRE (and it is based on NHRP), and the protection is assigned to IPSec, which interacts closely with it. </li><li>  The load on the hub is generally greater than the spoke.  This allows the use of equipment that varies in performance, depending on the needs of a particular branch office. </li><li>  The nature of the work depends on the configured phase. </li><li>  The configuration of the routing protocols also requires care. </li><li>  Among the shortcomings I would like to point out the limited support for multicasts and the lack of support for the Cisco ASA (sob ...) </li></ul><br><br>  For this, allow me to bow out :) Of course, again I do not hope that I have revealed all aspects of the technology.  Behind the scenes at least left a configuration with many hubs, etc.  But I hope that I managed to set out a general idea of ‚Äã‚Äãtechnology. <br><br>  I strongly hope for constructive criticism, because  The article is large and surely it is full of inaccuracies, errors and misprints. <br><br>  Podkopaev Ilya, instructor <br><br>  UPD.  Thank you <a href="https://habrahabr.ru/users/quickshooter/" class="user_link">Quickshooter</a> for the error found :) </div><p>Source: <a href="https://habr.com/ru/post/84738/">https://habr.com/ru/post/84738/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../84731/index.html">Google wants to rebuild Mountain View</a></li>
<li><a href="../84733/index.html">"Law 404" is not as terrible as it is painted</a></li>
<li><a href="../84735/index.html">Use gray logic, Luke</a></li>
<li><a href="../84736/index.html">Adobe Profiler Fail</a></li>
<li><a href="../84737/index.html">Examples domains</a></li>
<li><a href="../84743/index.html">The best software for Mac "with Russian roots"</a></li>
<li><a href="../84744/index.html">Digital tandem</a></li>
<li><a href="../84750/index.html">Distributed fonts for texts in sixteen languages</a></li>
<li><a href="../84752/index.html">Are new Windows 7 new</a></li>
<li><a href="../84756/index.html">Tale of how I finished Popcorn</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>