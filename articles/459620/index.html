<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>TDDx2, BDD, DDD, FDD, MDD and PDD, or anything else you want to know about Driven Development</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Looking through the articles on software design, I constantly met a cloud of unprecedented cuts and casually mentioned development practices. 



- TD...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>TDDx2, BDD, DDD, FDD, MDD and PDD, or anything else you want to know about Driven Development</h1><div class="post__text post__text-html js-mediator-article"><p>  Looking through the articles on software design, I constantly met a cloud of unprecedented cuts and casually mentioned development practices. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8v/ge/gp/8vgegpum3fifmxfni0u_ysms0to.jpeg"></div><br><ul><li>  <strong>TDD</strong> - well, everyone knows that, first we write tests, and then the rest of the code. </li><li>  <strong>BDD</strong> is something familiar, sort of like, also tests, but special ones. </li><li>  <strong>TDD</strong> - again?  So, stop, here we are not talking about tests at all.  But why is it called the same? </li><li>  <strong>DDD</strong> - bound contexts, ubiquitous language, domain ... </li><li>  <strong>FDD</strong> - how much can you? </li><li>  <strong>MDD</strong> - Seriously, based on diagrams? </li><li>  <strong>PDD</strong> - ... </li></ul><br><p>  Development approaches are divided by complexity, scope and purpose. <br>  I think it is time to figure out why they are needed, why there are so many of them, and how they can be useful to us. </p><br><p>  We will start to get acquainted with them from the simplest to the rather complex, we consider examples of use and the pros and cons of each of them. </p><a name="habracut"></a><br><h1 id="tdd---test-driven-development">  TDD - Test Driven Development </h1><br><p>  <strong>TDD</strong> is a software development methodology that is based on the repetition of short development cycles: a test is initially written covering the desired change, then a program code is written that implements the desired system behavior and allows the written test to pass.  Then refactoring of the written code is carried out with constant verification of passing tests. </p><br><p>  It sounds simple and clear.  Many people are familiar with this approach to development, and even Uncle Bob itself actively promotes it. </p><br><blockquote>  TDD is considered a form of proper application building method.  Test-driven design philosophy is that your tests are a specification of how your program should behave.  If you view your test suite as a mandatory part of the build process, if your tests fail, the program does not build because it is incorrect.  Of course, the limitation is that the correctness of your program is defined only as the completeness of your tests.  However, research has shown that development based on testing can lead to a 40‚Äì80% reduction in errors in production. </blockquote><p>  When you start using TDD, you may feel that you are working more slowly than usual.  This happens because you will work outside the ‚Äúcomfort zone‚Äù, and this is quite normal. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t5/uc/s_/t5ucs_g6howdrtrlnmarn6zv1ag.png"></div><br><p>  Once you feel that writing tests has become a simple and natural part of the workflow, that you no longer need to think about using TDD while working on a project, you realize that TDD has come into your work. </p><br><p>  This methodology allows you to create an application that is suitable for automatic testing and a very good code coverage of tests, since the TOR is translated into the language of automatic tests, that is, everything that the program should do is checked.  Also, TDD often simplifies software implementation: implementation redundancy is eliminated - if a component passes the test, then it is considered ready. </p><br><p>  The architecture of software products developed in this way is usually better (in applications that are suitable for automated testing, responsibility is usually very well distributed among the components, and the complex procedures performed are decomposed into many simple ones).  The stability of the application developed through testing is higher due to the fact that all the main functionality of the program is covered by tests and their performance is constantly checked.  Accompanying projects where everything or almost everything is tested is very high - developers may not be afraid to make changes to the code, if something goes wrong, then the results of the automatic testing will be reported. </p><br><p>  You can learn more about TDD principles by reading Kent Beck‚Äôs book "Extreme Programming. Development Through Testing." </p><br><h2 id="tdd---type-driven-development">  TDD - Type Driven Development </h2><br><p>  Type Driven Development is abbreviated as well as development through testing, so they usually write the full name. </p><br><p>  When developing based on types, your data types and type signatures are program specifications.  Types also serve as a form of documentation, which is guaranteed to be updated. </p><br><p>  Types are small control points, thanks to which we get a lot of mini-tests for our entire application.  Moreover, the costs of creating types are minimal and they are not required to be updated, since they are part of the code base. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ue/7h/y5/ue7hy5tcox8zmj5hngev707m994.jpeg"></div><br><p>  Type development is another correct method for building an application.  As with testing-based development, type-based development can increase your confidence in the code and save you time when making changes to a large code base. </p><br><p>  Of the minuses only increasing complexity in languages ‚Äã‚Äãwith dynamic typing.  For example, for JavaScript this approach is harder to apply than for TypeScript. </p><br><p>  On Habr√© there is a wonderful <a href="https://habr.com/ru/post/161205/">article</a> about typing. </p><br><h2 id="bdd---behaviour-driven-development">  BDD - Behavior Driven Development </h2><br><p>  Because of some methodological similarities, TDD (Test Driven Development) and BDD (Behavior Driven Development) are often confused even by professionals.  What is the difference?  The concepts of both approaches are similar, first the tests run and only then the development begins, but their purpose is completely different.  TDD is more about programming and testing at the level of technical implementation of the product, when the tests are created by the developers themselves.  <strong>BDD suggests a tester or analyst of user-language scenarios in natural language</strong> ‚Äî in the language of business, so to speak. </p><br><blockquote>  BDD - behavior-driven development is a development based on behavior description.  A certain person (or people) writes descriptions of the form "I like the user when I pressed the start button, then the menu was shown as in the picture" (there are specially selected keywords).  Programmers have long written special tools that translate such descriptions into tests (sometimes completely transparent to the programmer).  And then the classic development with tests. </blockquote><p>  If you write down the names of tests in the form of sentences and use the business domain vocabulary when writing method names, the created documentation becomes clear to customers, analysts and testers. </p><br><p>  Script texts are recorded in a specific form. </p><br><blockquote>  Having (approx. Given - given) some context, <br><br>  When (approx. When) an event occurs, <br><br>  Then (approx. Then) check the result. </blockquote><p>  Something like this might turn out: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pa/dq/zd/padqzdoeivthlm1ii0qe65htcoe.png"></div><br><p>  Or another example in Russian: </p><br><blockquote>  + Scenario 1: There is money in the account + 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <strong>Having an</strong> account with money <br><br>  <strong>And a</strong> valid card <br><br>  <strong>And</strong> ATM cash <br><br>  <strong>When a</strong> customer requests cash <br><br>  <strong>Then</strong> make sure that the account was written off. <br><br>  <strong>And</strong> make sure that cash is issued <br><br>  <strong>And</strong> make sure the card is returned. </blockquote><p>  The BDD approach together with engineering practitioners allowed us to abandon legacy documentation containing irrelevant information, and receive new documentation on the fly, store it with the project, which brought analysts and testers closer to the code. </p><br><p>  BDD is rather a process whose goal is to reduce the cost of implementing new features.  Even at the start of development, we get important artifacts.  For example, understandable to support the documentation.  This documentation enables all interested parties to form their own ideas about the product and user behavior scenarios, which should be implemented during development iterations.  With the BDD approach, we also reduce the threshold for entry into the project of new participants. </p><br><h3 id="v-chem-preimuschestvo-bdd">  What is the advantage of BDD? </h3><br><ul><li>  Tests readable for non-programmers. </li><li>  They are easy to change.  They are often written in almost pure English. </li><li>  They may be written by the product owner or other interested persons. </li><li>  The test results are more humane. </li><li>  Tests are independent of the target programming language.  Migrating to another language is greatly simplified. </li></ul><br><h3 id="minusy">  Minuses: </h3><br><p> But this approach has its drawbacks - it is long and expensive.  BDD is inconvenient at least in that it requires the involvement of testing specialists already at the stage of elaboration of requirements, and this extends the development cycle. </p><br><p>  The way out of this situation may be the choice of a suitable BDD framework and properly aligned development processes. </p><br><p>  Read more about BDD <a href="https://habr.com/ru/post/216923/">here</a> . </p><br><p>  Many have long understood that testing is a kind of panacea for all diseases, but is it really?  Of course, thoroughly tested code works more stable and predictable, but tests do not save us from problems and errors at the design and task setting stage.  The following design approaches can help you with this. </p><br><h2 id="ddd---domain-driven-design">  DDD - Domain Driven Design </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r2/yv/qy/r2yvqyh9gninztlb6_k0paa6pjm.png"></div><br><p>  Subject-oriented design is not a specific technology or methodology.  DDD is a set of rules that allow you to make the right design decisions.  This approach can significantly speed up the process of designing software in an unfamiliar subject area. </p><br><blockquote>  Domain <strong>-oriented design</strong> (less commonly problem-oriented, English Domain-driven design, DDD) is a set of principles and schemes aimed at creating optimal systems of objects.  The development process is reduced to the creation of software abstractions, which are called domain models.  These models include business logic that establishes a link between the actual conditions of the product's field of application and the code. </blockquote><p>  The DDD approach is particularly useful in situations where the developer is not an expert in the field of the product being developed.  For example: a programmer cannot know all areas in which software is required to be created, but with the help of a correct structure representation, using a domain-oriented approach, he can easily design an application based on key points and knowledge of the work area. </p><br><p>  In this article I try to convey the essence of each approach to software development, but I can write more than one article about DDD and cover all the nuances in several paragraphs.  Therefore, when explaining, I will provide explanatory links to the most worthy sources. </p><br><p>  The main goal of Domain-Driven Design is to combat the complexity of business processes, their automation and implementation in code.  ‚ÄúDomain‚Äù is translated as ‚Äúsubject area‚Äù, and it is precisely the subject area that pushes development and design within the framework of this approach. </p><br><p>  The key concept in DDD is ‚Äúubiquitous language‚Äù.  Ubiquitous language promotes transparent communication between project participants.  He is not one in the sense that he is one for all occasions.  Just the opposite.  All participants communicate on it, the whole discussion takes place in terms of a single language, and all artifacts should be maximally stated in terms of a single language, that is, starting from the TK, and ending with the code. </p><br><p>  The next concept is "domain model".  This model is a dictionary of terms from the ubiquitous language.  Both the domain model and the ubiquitous language are limited by the context, which in the Domain-Driven Design is called the bounded context.  It limits the domain model so that all concepts within it are unambiguous, and everyone understands what is being said. </p><br><p>  Example: take the entity ‚Äúperson‚Äù and put it in the context of ‚Äúpublic speaking‚Äù.  In this context, according to DDD, he becomes a speaker or speaker.  And in the context of "family" - a husband or brother. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fr/ol/pb/frolpb6kxzrufs8nxfspbnjbhnm.jpeg"></div><br><p>  Now about the code.  It is important that your code reads like a book, is simple and understandable to everyone who speaks the same project language.  What I mean? </p><br><p>  If in the project language you use the expression "product was added", then the following option is not in DDD: </p><br><blockquote>  var product = new Product ('apple') <br><br>  product.save () </blockquote><p>  Why?  The code says that we created the product in a strange way and saved it.  How to add the product?  Need to <strong>add it</strong> .  Here is the DDD code: </p><br><blockquote>  Product :: add ('apple'); </blockquote><br><h3 id="arhitektura">  Architecture: </h3><br><p>  From the point of view of Domain-Driven Design, it makes absolutely no matter what architecture you choose.  Domain-Driven Design is not about that, Domain-Driven Design is about language and communication. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yr/u1/xk/yru1xky15pmztnac5w504au08rk.png"></div><br><p>  But DDD is almost impossible without the pure architecture of the project, since when adding new functionality or changing the old one, you should try to preserve the flexibility and transparency of the code base.  Pro ports, adapters and onion architecture can be found in an excellent <a href="https://herbertograca.com/2019/06/05/reflecting-architecture-and-domain-in-code/">article</a> .  The picture above is just from it. </p><br><p>  There are also articles about DDD that I strongly advise to read carefully - <a href="https://habr.com/ru/post/316438/">here</a> and <a href="https://habr.com/ru/company/jugru/blog/440772/">here</a> . </p><br><h3 id="chto-zhe-nam-eto-daet-v-itoge">  What it gives us in the end: </h3><br><ul><li>  almost all team members can read the project code; </li><li>  task setting becomes more explicit; </li><li>  business logic bugs become easier to search; </li><li>  QA is much easier for specialists to view the code and find logical errors and bugs. </li></ul><br><h3 id="minusy-1">  Minuses: </h3><br><ul><li>  highly skilled developers are required, especially at the start of the project; </li><li>  not all customers are willing to go for such costs, DDD needs to be learned by all participants in the development process. </li></ul><br><h2 id="fdd---features-driven-development">  FDD - Features Driven Development </h2><br><p>  FDD - This methodology (briefly referred to as FDD) was developed by Jeff De Luca and a recognized object-oriented technology guru Peter Coad.  FDD is an attempt to combine the most recognized techniques in the software development industry, taking as a basis for the customer-important functionality (features) of the software being developed.  The main goal of this methodology is to develop real, working software systematically, in the set time frame. </p><br><p>  Like the rest of the adaptive methodology, it focuses on short iterations, each of which serves to work out a specific part of the functionality of the system.  According to FDD, one iteration lasts two weeks.  FDD has five processes.  The first three of them relate to the beginning of the project: </p><br><ul><li>  development of a general model; </li><li>  compiling a list of required system properties; </li><li>  planning work on each property; </li><li>  design of each property; </li><li>  constructing each property. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yb/pn/-7/ybpn-73k8zvpmk-qudlqwxg9-oa.jpeg"></div><br><p>  The last two steps must be done during each iteration.  In addition, each process is divided into tasks and has verification criteria. </p><br><p>  Let's take a closer look at each item. </p><br><p>  <strong>Development of a general model.</strong> </p><br><p>  Development begins with an analysis of the breadth of the existing range of tasks and the context of the system.  Further, for each simulated area is a more detailed analysis.  Preliminary descriptions are compiled in small groups and submitted for further discussion and peer review.  After one of the proposed models or their combination becomes a model for a specific area.  The models of each task pane are combined into a common final model, which may change during the course of work. </p><br><p>  <strong>List of functions</strong> </p><br><p>  The information collected when building a general model is used to compile a list of functions.  Functions are combined into so-called "areas" (English domain), and they, in turn, are divided into sub-areas (English subject areas) according to their functional characteristics. </p><br><p>  Each subarea corresponds to a specific business process, and its steps become a list of functions (properties).  Functions are presented in the form of "action - result - object", for example, "check user password".  The development of each function should take no more than 2 weeks, otherwise the task must be decomposed into smaller iterations.  The list of properties in FDD is the same as the product backlog in SCRUM. </p><br><p>  <strong>Plan for properties (functions)</strong> </p><br><p>  Next comes the stage of distribution of functions among leading programmers or by teams. </p><br><p>  <strong>Function design</strong> </p><br><p>  For each property, a design package is created.  The lead programmer selects a small group of properties for development within two weeks.  After that, detailed sequence diagrams are left for each property, specifying the overall model.  Further "stubs" of classes and methods are written.  At this point, we need to focus on the design of the software product. </p><br><p>  <strong>Function implementation</strong> </p><br><p>  We write the code, we remove stubs, we test. </p><br><p>  After the property has been tested and put into the product, we take the following property in priority, we repeat the design / implementation cycle. </p><br><p>  Total, as a result, we get: </p><br><ul><li>  system property documentation; </li><li>  careful design; </li><li>  easier to evaluate small tasks; </li><li>  tests are focused on business problems; </li><li>  elaborated product creation process; </li><li>  Short iterative development cycles allow you to quickly increase functionality and reduce the number of errors. </li></ul><br><p>  Minuses: </p><br><ul><li>  FDD is more suitable for large projects.  Small development teams will not be able to feel the full benefits of this approach; </li><li>  significant costs of implementation and training. </li></ul><br><h2 id="mdd---model-driven-development">  MDD - Model Driven Development </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-d/wi/ys/-dwiysxakx7fo4tlanhlqkb4f0e.png"></div><br><p>  Recently, a lot of attention has been given in publications to the theme of architecture and development based on MDA (Model Driven Architecture) and MDD (Model Driven Development) models.  Without going into details, select only the key points. </p><br><blockquote>  Model-Driven Development (model-driven development) is the style of software development when models become the main development artifacts from which code and other artifacts are generated. </blockquote><p>  To put it simply, the whole essence of the development comes down to building the necessary diagrams, from which we subsequently generate the working code of the project. </p><br><p>  The main goal of MDD is to minimize the costs associated with binding to specific system platforms and software infrastructures.  After all, the main business logic is contained in diagrams and does not constrain us within the framework of the choice of programming language and development tools. </p><br><p>  Let's digress a bit and remember the compiler.  It converts a high-level programming language to an equivalent machine-language implementation.  The model in this case is a program written in a high-level language that hides irrelevant details about its implementation.  In MDD, our diagrams are another level of abstraction that does not allow us to get bogged down in the details of development, but look at the big picture. </p><br><p>  The diagrams act as original ‚Äúdrawings‚Äù from which various automated and semi-automated processes extract programs and corresponding models.  Moreover, automatic code generation varies from extracting a simple skeleton of an application to obtaining the final code base (which is comparable to traditional compilation). </p><br><p>  The idea of ‚Äã‚ÄãMDD is not new - it has been used with varying success before.  The reason for the increased attention to them now is that automation lends itself to significantly more processes than before.  This development is reflected in the emergence of MDD-standards, which leads to the unification of relevant funds.  One of these standards is the revised version of Unified Modeling Language - UML 2.0. </p><br><p>  According to the Object Management Group (OMG) standards, creating an application consists of the following steps: </p><br><ul><li>  First, a domain model of the projected application is developed that is completely independent of the implementing technology; </li><li>  then it is transformed by a special tool into a platform-dependent model; </li><li>  Finally, it is translated into source code in the appropriate programming language. </li></ul><br><p>  A classic example of MDD, which has been used for a long time, is database modeling.  Based on a single conceptual data model, you can maintain multiple physical models associated with it for different DBMSs. </p><br><p>  <strong>What advantages we get:</strong> </p><br><ul><li>  speeding up the launch of a minimum viable product (Minimum Viable Product) to the market; </li><li>  time is reduced by: generating an application framework, class models, databases; </li><li>  constantly updated documentation; </li><li>  for the participants of the project diagrams are much clearer than the code. </li></ul><br><p>  <strong>Minuses:</strong> </p><br><ul><li>  MMD implementation will require the use of special software solutions such as Rational Software Architect, Simulink or Sirius; </li><li>  programmers are required to have impressive knowledge of designing diagrams; </li><li>  significant financial costs for the integration of this methodology. </li></ul><br><h2 id="pdd---panic-driven-development">  PDD - Panic Driven Development </h2><br><p>  If you have tried agile development methodologies, then you probably also tried PDD.  Let's take a closer look at what the principles of this methodology are. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k8/cd/li/k8cdliqmqwpouf0q_jdktotmyqu.jpeg"></div><br><h3 id="novye-zadachi-prioritetnee-staryh">  New tasks take precedence over old ones. </h3><br><p>  Whenever a new problem appears in the middle of a sprint, it takes precedence over any scheduled work.  New is always better and has a higher priority.  Strange, why it did not become one of the principles of agile development?  Focusing on providing value for the client requires that the team take care of new features and put off previously defined work. </p><br><h3 id="pishite-stolko-koda-skolko-nuzhno-chtoby-reshit-problemu">  Write as much code as you need to solve the problem. </h3><br><p>  Developers write code for life.  Errors can only be corrected by code.  Discussion of design and UX can only slow down development.  But we do not want to lose precious time?  First write the solution, then check your guess for the correction.  If the fix works, the problem is resolved. </p><br><h3 id="testy-dolzhny-pisatsya-v-konce">  Tests should be written at the end. </h3><br><p>  After the patch is implemented, tests can be scheduled as a task to be done in the future.  Tests are useful, but not prioritized.  You can take care of them later.  Manual testing should be sufficient to prove the operability of the implemented solution. </p><br><h3 id="dovertes-svoemu-instinktu">  Trust your instinct. </h3><br><p>  Programming is an art.  Art has an internal instinctive component.  Trust your intuition.  Write the code.  Deploy it.  Only brave smiles luck. </p><br><h3 id="process-gibok">  The process is flexible. </h3><br><p>  Any process created to develop, test, and release software is simply a set of agreements and rules that are not set in stone.  Critical fixes require different approaches.  It is expected that you will bend the process to complete the task on time if the business requires it. </p><br><h3 id="eto-process-upravlyaemyy-menedzherom">  This is a manager driven process. </h3><br><p>  As part of the same team, managers have the right to express their opinions on development issues.  Refactoring or best practices can and should be reversed by business needs.  Engineers can give their opinion, but they must ultimately accept any needs that come from above. </p><br><h3 id="plyusy-podhoda">  Advantages of the approach: </h3><br><ul><li>  high speed development; </li><li>  cheap; </li><li>  Customers are happy to finally find intelligent developers. </li></ul><br><h3 id="minusy-2">  Minuses: </h3><br><ul><li>  <strong>All advantages will be broken about technical debt and complexity of the project</strong> . </li></ul><br><p>  PDD is a kind of development anti-pattern, which, unfortunately, we all practice from time to time. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  The world of agile development is multifaceted.  We met only a small part of it, reviewed a sufficient number of software development practices, learned about their advantages and disadvantages. </p><br><p>  I hope many of you have learned something new about the Driven Development practices, and now, having come face to face with the abbreviations DDD, BDD, MDD you will not be confused, and you may even want to try them in practice. </p></div><p>Source: <a href="https://habr.com/ru/post/459620/">https://habr.com/ru/post/459620/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459612/index.html">How Qualcomm has ripped off the mobile industry for almost 20 years in a row.</a></li>
<li><a href="../459614/index.html">Utko-robot muddies the water in the rice fields</a></li>
<li><a href="../459616/index.html">MIPT Opens the First Advanced Master Program in Russia in Computer Science and Software Engineering</a></li>
<li><a href="../459618/index.html">A few obscure docker-compose features.</a></li>
<li><a href="../45962/index.html">Markup. Transitional vs Strict</a></li>
<li><a href="../459622/index.html">How in 1995 they wrote games for Sega Saturn</a></li>
<li><a href="../459624/index.html">Combat drones</a></li>
<li><a href="../459628/index.html">The Open Invention Network has more than three thousand licensees - what does this mean for open source software?</a></li>
<li><a href="../45963/index.html">Software Engineering and Miyamotopoliya course</a></li>
<li><a href="../459630/index.html">Tic Tac Toe, Part 2: Undo / Redo with state storage</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>