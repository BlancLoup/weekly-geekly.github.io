<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Java 8 in parallel. Learn to create subtasks and monitor their implementation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue the series of articles devoted to processing large amounts of data in parallel (a beautiful word, is not it?). 

 In the previous article,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Java 8 in parallel. Learn to create subtasks and monitor their implementation</h1><div class="post__text post__text-html js-mediator-article">  We continue the series of articles devoted to processing large amounts of data in parallel (a beautiful word, is not it?). <br><br>  In the previous <a href="http://habrahabr.ru/post/270943/">article,</a> we also introduced the interesting <b>Fork / Join Framework</b> toolkit, which allows you to split the processing into several parts and run parallel tasks.  What's new in this article - you ask?  I will answer - more informative examples and new mechanisms for high-quality information processing.  In parallel, I will tell you about the resource and other features of work in this mode. <br><br><img src="https://habrastorage.org/files/1ed/637/257/1ed637257ec2460c97f0d98b7eade44d.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      All interested invite under the cat: <br><a name="habracut"></a><br><h4>  Start </h4><br>  All that is well divided - divide.  Something like this I wrote in the previous article, offering to divide the processing into parts and to load processors as much as possible (unless of course you have them).  Somehow rudely sounded. <br><br>  Yes, of course, there are, for a long time, even home computers are multi-core.  Here lies the first feature of work in this mode.  It is necessary to observe parity between the number of subtasks and the number of cores.  According to numerous tests, the launch formula is approximately the following, the number of subtasks should be: (Number of cores +0) or (Number of cores +1).  These options have been tested on several serious servers and several ordinary machines. <br><br><h4>  Restriction Mechanisms </h4><br>  By limiting mechanisms, I understand all sorts of mechanisms (‚Äúcut-offs‚Äù) as quickly and conveniently as possible to handle and debug errors.  In my projects I try to create the maximum number of ways to debug code, for example: <br><br>  <b>a)</b> Try to implement single-tasking and multi-tasking mechanisms for your calculations.  What for?  I'll explain now.  Suppose you have a successfully submitted project, and even possibly a tested one.  In case of a non-standard situation, the first thing to do is to quickly understand and correct the error, switch to the single-task mode (forcibly) and immediately get an error on the application server screen (if it is possible and has access). <br><br>  It is more convenient to identify shortcomings in single-task mode - if you have parallel mode enabled, then when you stop the first subtask, you will see part of the second one (this is not always convenient for viewing). <br><br>  <b>b)</b> Consider the mechanisms for accessing and downloading the constantly required data. <br><br>  I'll tell you more.  For example, you want to transfer about 100 huge tables to Map &lt;K, V&gt; before processing.  Yes, it is quickly convenient, but there are some unpleasant moments. <br><br>  Suppose you start testing big data.  There is a problem in three contracts, blocks, clients, without a difference, in three positions (let's call them ‚Äúpositions‚Äù).  You figured out what was wrong, fixed, rewritten jar, restarted and ... Nothing!  We sit again, waiting for a few minutes.  We are waiting for the calculation. <br><br>  In this situation, we would be helped by the mechanisms of selective loading (s) of data. <br><br>  For example, the next is not the best option.  In fact, the construction of the map for all data.  Although sometimes it is applied. <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Map&lt;Long, String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValueInDao</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Date date)</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;Long, String&gt; valueMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;Long, String&gt;(); HashMap map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinkedHashMap(); map.put(<span class="hljs-string"><span class="hljs-string">"date"</span></span>, date); List&lt;Values&gt; ValuesList = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.findWithQuery(<span class="hljs-string"><span class="hljs-string">"select c from Values c where c.vf &lt; :date and c.vd &gt;= :date"</span></span>, map); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ValuesList.size() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ListIterator&lt;Values&gt; iterValues = ValuesList.listIterator(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (iterValues.hasNext()) { Values tmpValues = iterValues.next(); valueMap.put(tmpValues.getId,tmpValues.getDescr ()); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valueMap.size() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> valueMap; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.emptyMap(); }</code> </pre> <br>  The next option is preferable (IMHO).  In it, we limit ourselves to incoming data, since we only get what we really need. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Map&lt;Long,String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Long&gt; idList,Date date)</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;Long,String&gt; valueMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;Long, String&gt;(); HashMap map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinkedHashMap(); List&lt;Value&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idList.size() &gt; <span class="hljs-number"><span class="hljs-number">1000</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; idList.size() / <span class="hljs-number"><span class="hljs-number">999</span></span>; i++) { map.put(<span class="hljs-string"><span class="hljs-string">"idList"</span></span>, idList.subList(j, j + <span class="hljs-number"><span class="hljs-number">999</span></span>)); map.put(<span class="hljs-string"><span class="hljs-string">"date"</span></span>, date); list.addAll(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.findWithQuery(<span class="hljs-string"><span class="hljs-string">"select c from Value c where c.id in ("</span></span> + <span class="hljs-string"><span class="hljs-string">":idList"</span></span> + <span class="hljs-string"><span class="hljs-string">") and c.val &lt; :date and c.val2 &gt;= :date"</span></span>, map)); map.clear(); j += <span class="hljs-number"><span class="hljs-number">999</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j &lt;= idList.size()-<span class="hljs-number"><span class="hljs-number">1</span></span>) { map.put(<span class="hljs-string"><span class="hljs-string">"idList"</span></span>, idList.subList(j, idList.size())); map.put(<span class="hljs-string"><span class="hljs-string">"date"</span></span>, date); list.addAll(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.findWithQuery(<span class="hljs-string"><span class="hljs-string">"select c from Value c where c.id in ("</span></span> + <span class="hljs-string"><span class="hljs-string">":idList"</span></span> + <span class="hljs-string"><span class="hljs-string">") and c.val &lt; :date and c.val2 &gt;= :date"</span></span>, map)); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { map.put(<span class="hljs-string"><span class="hljs-string">"idList"</span></span>, idList); map.put(<span class="hljs-string"><span class="hljs-string">"date"</span></span>, date); list = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.findWithQuery(<span class="hljs-string"><span class="hljs-string">"select c from Value c where c.id in ("</span></span> + <span class="hljs-string"><span class="hljs-string">":idList"</span></span> + <span class="hljs-string"><span class="hljs-string">") and c.val &lt; :date and c.val2 &gt;= :date"</span></span>, map); } Iterator&lt;Value&gt; iter = list.iterator(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(iter.hasNext()) { Value tmpValue = iter.next(); valueMap.put(tmpValue.getId, tmpValue.getValue()); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valueMap.size() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> valueMap; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.emptyMap(); }</code> </pre> <br>  <b>c)</b> Immediately create mechanisms for recording and outputting errors in tables (files) and other sources.  If your algorithms are clearly aligned, then nothing prevents you from creating a class that will work by key.  For example, before loading there is a ‚Äúflag‚Äù that allows you to write data to a table with errors, thus you know the exact area. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (varKeyError == <span class="hljs-number"><span class="hljs-number">1</span></span>) { --   , ,    err       }</code> </pre> <br><br><h4>  Faster‚Ä¶ </h4><br>  Having a little talk about possible features / errors, let's move on to our immediate goal, namely, processing in parallel mode large amounts of information and slightly expand the existing example (brazenly take them from the previous <a href="http://habrahabr.ru/post/270943/">article</a> ). <br><br>  It created several classes responsible for input data and processing.  Then we were based on the <b>RecursiveAction</b> class.  Let me remind, once again, what was done in the example.  In the StreamSettings class, we split the data into parts until we reach the threshold value set at countValue = 500. As I explained earlier, you can create any restriction mechanism.  For example, the option (valueId.size () / Runtime.getRuntime (). AvailableProcessors () * 2) is also operational and can be used to find some optimal value. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StreamSettings</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RecursiveAction</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> countValue = <span class="hljs-number"><span class="hljs-number">500</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> countProcessors = Runtime.getRuntime().availableProcessors(); List&lt;ValueValue&gt; data; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> start, end; StreamSettings(List&lt;ValueValue&gt; valueId,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startNumber,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endNumber) { data = valueId; start = startNumber; end = endNumber; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (end - start &lt; countValue || countProcessors &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = start; i &lt; end; i++) { ValueValue value = data.get(i); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CalcGo().calcGo(value); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { raiseApplicationError(<span class="hljs-string"><span class="hljs-string">" "</span></span> + e.getMessage(), e); } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> middle = (start + end)/ <span class="hljs-number"><span class="hljs-number">2</span></span>; invokeAll(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CalcGo(data, start, middle), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CalcGo(data,middle,end)); } } }</code> </pre> <br>  We continue our research.  Let's try to see the new processing options, let's focus on the <b>RecursiveTask</b> class.  The main difference will be that the compute () method will return the result (and this is required very well).  In fact, we can wait for the execution of several subtasks and make calculations.  The following are examples that we will discuss in more detail. <br>  The Stream class is responsible for splitting into subtasks.  In the example, we find the mean value and create an instance of the class (Stream goVar1 = new Stream (forSplit, start, middle)) from 0 to the ‚Äúmiddle‚Äù and at (Stream goVar2 = new Stream (forSplit, middle, end)) from the ‚Äúmiddle‚Äù to the final element. <br><br>  The difference from the previous variant, the class StreamSettings, is not used invokeAll, but the fork () and join () methods will be called, respectively. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stream</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RecursiveTask</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Long</span></span></span><span class="hljs-class">&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> countProcessors = Runtime.getRuntime().availableProcessors(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> countLimit = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> start; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> end; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> forSplit; Stream(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> componentValue,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startNumber, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endNumber) { forSplit = componentValue; start = startNumber; end = endNumber; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> Long </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Long countSum = <span class="hljs-number"><span class="hljs-number">0L</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( countProcessors == <span class="hljs-number"><span class="hljs-number">1</span></span> || end - start &lt;= countLimit) { System.out.println(<span class="hljs-string"><span class="hljs-string">"=run="</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"=start="</span></span>+start); System.out.println(<span class="hljs-string"><span class="hljs-string">"=end="</span></span>+end); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = start; i &lt;= end; i++) { countSum += <span class="hljs-number"><span class="hljs-number">1</span></span> ; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> middle = (start + end)/ <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* invokeAll(new Stream(forSplit, start, middle), new Stream(forSplit, middle+1, end));*/</span></span> Stream goVar1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stream(forSplit,start, middle); Stream goVar2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stream(forSplit,middle,end); goVar1.fork(); goVar2.fork(); countSum = goVar1.join() + goVar2.join(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> countSum; } } <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.ForkJoinPool; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Start</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> componentValue = <span class="hljs-number"><span class="hljs-number">2000</span></span>; Long beginT = System.nanoTime(); ForkJoinPool fjp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ForkJoinPool(); Stream test = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stream(componentValue,<span class="hljs-number"><span class="hljs-number">0</span></span>,componentValue); Long countSum = fjp.invoke(test); Long endT = System.nanoTime(); Long timebetweenStartEnd = endT - beginT; System.out.println(<span class="hljs-string"><span class="hljs-string">"=====time========"</span></span> +timebetweenStartEnd); System.out.println(<span class="hljs-string"><span class="hljs-string">"=====countSum========"</span></span> +countSum); } }</code> </pre><br>  As a result of correct alignment of launches and expectations of launches, you can create a convenient system for asynchronous execution of calculations. <br><br><h4>  Features of information processing </h4><br>  The topic covered is extensive and allows for significant improvements.  The gain in time is approximately 1.7 times compared with the sequential launch.  You can use available resources more efficiently and put multiple calculations in parallel mode. <br><br>  Good luck to all.  Questions and suggestions leave in the comments.  The next article will be devoted to such an interesting tool as <b>Heartbeat</b> .  Not?  Do not know?  See you then. </div><p>Source: <a href="https://habr.com/ru/post/272479/">https://habr.com/ru/post/272479/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../272469/index.html">Translation: Instructions for conducting code review</a></li>
<li><a href="../272471/index.html">How to scale Ruby applications</a></li>
<li><a href="../272473/index.html">About system thinking</a></li>
<li><a href="../272475/index.html">Simple Computer Classroom Management System</a></li>
<li><a href="../272477/index.html">The digest of interesting materials for the mobile developer # 132 (November 30 - December 6)</a></li>
<li><a href="../272483/index.html">Basic laws for creating development teams</a></li>
<li><a href="../272487/index.html">DIY: dll hijacking under MS Office for the youngest</a></li>
<li><a href="../272491/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ188 (December 1 - 6, 2015)</a></li>
<li><a href="../272495/index.html">PHP Digest number 75 - interesting news, materials and tools (November 22 - December 6, 2015)</a></li>
<li><a href="../272497/index.html">Disposable without borders</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>