<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Anatomy of Melancholia</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Knowledge is power. 

 Francis Bacon. 

 ... in much wisdom much sorrow; 
 and who multiplies knowledge, multiplies sorrow. 

 Book of Ecclesiastes. 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Anatomy of Melancholia</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/files/562/b61/a75/562b61a75bd84112bf2b407727913339.PNG">  <i><b>Knowledge is power.</b></i> <i><b><br><br></b></i>  <i><b>Francis Bacon.</b></i> <i><b><br><br></b></i>  <i><b>... in much wisdom much sorrow;</b></i> <i><b><br></b></i>  <i><b>and who multiplies knowledge, multiplies sorrow.</b></i> <i><b>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </b></i>  <i><b>Book of Ecclesiastes.</b></i> <i><b><br></b></i> <br>  Games live their lives.  They arise from nowhere, develop, generate new games, are forgotten by everyone and, sometimes, come back from oblivion.  There are many examples in the history of games that were defeated in this process of natural selection.  These are the various variants of <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B0%25D1%2580%25D0%25B8%25D0%25B0%25D0%25BD%25D1%2582%25D1%258B_%25D1%2581%25D1%2591%25D0%25B3%25D0%25B8">Shogi</a> , which have survived to this day only thanks to the reverent attitude of the Japanese people to their cultural heritage.  A party to a game similar to <a href="http://en.wikipedia.org/wiki/Taikyoku_shogi">Taikyoku shogi</a> could drag on for months (if not for years).  But these chess dinosaurs of the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D1%2580%25D0%25B8%25D0%25BE%25D0%25B4_%25D0%25A5%25D1%258D%25D0%25B9%25D0%25B0%25D0%25BD">Heian</a> epoch are not the brightest representatives of the fossil world of board games. <br><a name="habracut"></a><br>  I want to talk about a truly amazing game.  The threats in it are not obvious, and the goals are not trivial.  You can win in many ways, but playing is not easy at all.  It can not be attributed either to the Checkers family or to the chess family.  Its origin is foggy.  For the average man in the street, this game is about as exciting as it is drawing up <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D0%25B3%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25BA%25D0%25B2%25D0%25B0%25D0%25B4%25D1%2580%25D0%25B0%25D1%2582">magic squares</a> .  It fully justifies one of its names - only <a href="http://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25BB%25D0%25BE%25D1%2581%25D0%25BE%25D1%2584">philosophers</a> can play it. <br><br>  For the first time, the <a href="https://en.wikipedia.org/wiki/Rithmomachy">Rithmomachia</a> , also known as the ‚ÄúBattle of Numbers‚Äù or ‚ÄúThe Game of the Philosophers‚Äù, was described, approximately, in 1030 by a monk named Asilo.  Authorship, apparently baseless, is attributed to <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BB%25D0%25B0%25D1%2582%25D0%25BE%25D0%25BD">Plato</a> , and the rules of the game are based on <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25BE%25D1%258D%25D1%2586%25D0%25B8%25D0%25B9">Boethius'</a> arithmetic theory.  Subsequently, the rules of the game were marginally changed by another monk, named <a href="https://en.wikipedia.org/wiki/Hermannus_Contractus">Hermannus Contractus</a> , who added notes on the theory of music.  For a long time, Ritmomachia was used as a teaching tool in teaching students to mathematics.  Intellectuals of that time played Ritmomachia for pleasure (at one time it was even more popular than Chess), <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D1%2591%25D1%2580%25D1%2582%25D0%25BE%25D0%25BD,_%25D0%25A0%25D0%25BE%25D0%25B1%25D0%25B5%25D1%2580%25D1%2582_(%25D1%2583%25D1%2587%25D1%2591%25D0%25BD%25D1%258B%25D0%25B9)">Robert Burton</a> mentioned it in <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BD%25D0%25B0%25D1%2582%25D0%25BE%25D0%25BC%25D0%25B8%25D1%258F_%25D0%25BC%25D0%25B5%25D0%25BB%25D0%25B0%25D0%25BD%25D1%2585%25D0%25BE%25D0%25BB%25D0%25B8%25D0%25B8">Anatomy of Melancholy</a> , and <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BE%25D1%2580,_%25D0%25A2%25D0%25BE%25D0%25BC%25D0%25B0%25D1%2581">Thomas More</a> considered this game a good leisure for the inhabitants of his <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D1%2582%25D0%25BE%25D0%25BF%25D0%25B8%25D1%258F_(%25D0%25BA%25D0%25BD%25D0%25B8%25D0%25B3%25D0%25B0)">Utopia</a> .  Then, suddenly, it was all over.  The interests of mathematics and Ritmomachia diverged and the game was forgotten.  Of course, this does not mean that we can not remember it. <br><br><h4>  <b>Rules of the game</b> </h4><br>  Two players play Ritmomachia on a rectangular 8x16 square board.  Turns are performed alternately.  For each move, one piece moves.  As a result of a move, one or more opponent pieces may be taken (removed from the board).  The following types of shapes are defined: <br><br><ul><li>  <b>A circle</b> </li><li>  <b>Triangle</b> </li><li>  <b>Square</b> </li><li>  <b>Pyramid</b> </li></ul><br><img src="https://habrastorage.org/files/653/7ba/59d/6537ba59df4e4c739edbc882305adf51.PNG"><br><br>  Ignoring the numerical marks on the figures (I‚Äôll talk about them below), you can see that two types of moves are allowed.  In the first case, the figure moves in a straight line and can be stopped by any other figure (one‚Äôs own or an opponent) on the way.  Thus the Circle (one cell diagonally), as well as the Triangle (strictly two cells orthogonal) and Square (strictly three cells orthogonal) are moved.  Another possibility is to ‚Äújump‚Äù the pieces to the target cell, similar to the knight's move in chess.  So can walk the Triangle or Square.  Any move should be performed only on an empty square. <br><br>  A unique figure is the Pyramid.  Actually it is not a figure, but a set of figures.  Each piece in the set (Circle, Triangle or Square) allows the Pyramid to perform the appropriate type of turn.  The figure above shows the possible moves of the Pyramid in the "top of the range".  As it is easy to guess, by the end of the game, the ‚Äúcompleteness‚Äù can be greatly disturbed (by the way, the Pythmid from Ritmomachia is the only figure I know that can be ‚Äúkilled in parts‚Äù). <br><br>  I will dwell on the methods of "murder".  There are four of them in Ritmomachia: <br><br><ul><li>  <b>Capture by Siege</b> </li><li>  <b>Capture by Equality</b> </li><li>  <b>Capture by Ambush</b> </li><li>  <b>Capture by Eruption</b> </li></ul><br><img src="https://habrastorage.org/files/6ff/dd7/df2/6ffdd7df204948a9961d493d5ab2066c.PNG"><br><br>  The most radical is the capture of the figure "under siege."  The figure will be removed if after the next turn it turns out to be blocked in all diagonal or orthogonal directions.  If the figure is located at the edge of the board or in the corner - you will have to block fewer directions.  This is the simplest (but not the only) way to take the Pyramid all at once - entirely.  Taking ‚Äúunder siege‚Äù is the only way that does not use the numerical values ‚Äã‚Äãof the figures. <br><br>  Another way is to take a figure with a matching numeric value.  If, after completing the move, on the field, where the next move could move the figure (if this field was empty, of course) is the figure of the enemy, with the same numerical value, it will be taken.  It should be noted that this method of combat may be asymmetric.  So (in the picture above), after White‚Äôs move, the Circle, with a numerical value of 16, can take a black Triangle with the same value, but the Triangle, on its own turn, cannot do this, since it goes to other cells.  At the same time, white and black triangles with numerical values ‚Äã‚Äãof 25 beat each other symmetrically (which figure will be taken is determined by the order of the turn). <br><br>  An improved version of the previous one is the following method.  This time, ‚Äúfrom ambush‚Äù, two figures are attacking.  If the sum, difference, product or quotient of their numerical values ‚Äã‚Äãcoincide with the numerical value on the opponent's figure - the figure is removed.  This is the most frequently used possibility of fighting figures in the game, but it may be far from easy to see all such threats in a less complex position. <br><br>  The latter method allows you to beat the pieces in the far distance.  If the result of the product or the particular numerical value of the figure and the distance to the opponent‚Äôs figure (orthogonal) coincides with the numerical value of the opponent‚Äôs figure - the figure is removed.  Other figures located in the direction of the battle, do not prevent the threat.  When calculating the distance, the starting and ending positions are taken into account.  This is a symmetric method of combat (since it does not depend on the rules for moving figures).  The sequence of the turn determines which of the pieces will be shot. <br><br>  It remains to talk about how these rules apply to the Pyramids.  With this, everything is simple - in any calculations for taking figures, the Pyramid can act either as an independent figure (its numerical value coincides with the sum of the numerical values ‚Äã‚Äãof all its components), or as any of its parts.  Similarly, the Pyramid can be taken as a whole (by its total value) or in parts (each of its components is vulnerable separately).  Given the rules for moving the Pyramid, which I mentioned above, this makes the Pyramid the strongest (and most vulnerable) figure. <br><br><img src="https://habrastorage.org/files/158/754/d87/158754d873e047b2a9e5d0622f71ec08.PNG"><br><br>  The initial placement of figures is associated with another important feature of the game.  Although the set of figures is the same, the numerical values ‚Äã‚Äãdiffer.  Also, the ‚Äúequipment‚Äù of the pyramids is different (shown on the side of the board, for each of the players).  This makes the game asymmetric.  Tactics and strategies, for the black player are not suitable for white (and vice versa).  This makes the game more interesting. <br><br><h4>  <b>Glorious victories</b> </h4><br>  The rules described above are enough to start playing Ritmomachia, but if the goal of the game was to simply capture all the pieces of the opponent, the game would not be so interesting.  Yes, you can win in this way, but this is not the only (and not the best) way to win!  I really like the game, the purpose of which is not the straightforward "killing" of enemy figures.  So in Chess, to win, it is not at all necessary to ‚Äúeat‚Äù all the figures, it‚Äôs enough to checkmate the King!  In some versions of <a href="http://brainking.com/ru/GameRules%3Ftp%3D73">Hasami Shogi</a> , the goal of the game is even more unexpected (to win, you need to build a line of 5 of your chips in a row).  Ritmomachia does not disappoint in this regard.  Here is a list of ways to win in this game (in order of increasing their "gloriousness"): <br><br><ul><li> <b>De Corpore</b> ("by body"): Take a given (or more) number of enemy pieces (usually 15) </li><li>  <b>De Bonis</b> ("by goods"): Take the opponent's pieces with a given (or large) total value (usually 1315 for whites and 984 for blacks) </li><li>  <b>De Lite</b> ("by lawsuit"): Take enemy pieces with a given (or large) total value, provided that the number of digits on the captured pieces does not exceed the specified </li><li>  <b>De Honore</b> ("by honor"): Take enemy pieces with a given (or large) total value, provided that the number of captured figures does not exceed the specified </li><li>  <b>De Honore Liteque</b> ("by honor and lawsuit"): Take enemy pieces with a given (or more) total value, provided that the number of captured pieces does not exceed the set and the number of digits on the captured pieces does not exceed the set </li><li>  <b>Victoria Magna</b> ("great victory"): Arrange three figures (on the territory of the enemy) in an arithmetic progression </li><li>  <b>Victoria Major</b> (‚Äúgreater victory‚Äù): Arrange four figures (on the enemy‚Äôs territory) so that they have two (but not more) groups of three figures placed in different types of progression ( <a href="http://en.wikipedia.org/wiki/Arithmetic_progression">arithmetic</a> , <a href="http://en.wikipedia.org/wiki/Geometric_progression">geometric</a> or <a href="http://en.wikipedia.org/wiki/Harmonic_progression_(mathematics)">harmonic</a> ) </li><li>  <b>Victoria Excellentissima</b> ("most excellent victory"): Arrange (on the territory of the enemy) four figures so that there are all three types of progression </li></ul><br>  Here you can distinguish between two fundamentally different types of game objectives.  <b>Common Victories</b> are associated with the capture of enemy pieces (with the possible limitation of the number of captured pieces, in order to protect against aggressive play).  <b>Proper Victories</b> are considered a more worthy conclusion and are associated with the re-creation of a certain ‚Äúharmony‚Äù on the territory of the enemy (which does not exclude the possibility of a battle of enemy figures). <br><br><img src="https://habrastorage.org/files/b77/f07/014/b77f070140ed4c8f93e191de5aad02c9.png"><br><br>  The examples above illustrate that enemy figures can (and should) be involved in ‚Äúharmony‚Äù.  In the first case, an arithmetic progression was constructed (16, 36, 56).  The second example combines geometric (4, 12, 36) and harmonic (4, 6, 12) progression.  In the third case, there are all three types of progression (you can find them yourself).  In case there are difficulties with an oral account, tables of all possible <a href="http://www.boardspace.net/rithmomachy/english/Rithmomachy%2520Glorious%2520Victories.html">solutions</a> in Ritmomachia are built (however, people who have problems with an oral account are unlikely to be interested in Rhythmomachia). <br><br><h4>  <b>Possible options</b> </h4><br>  In its heyday, ritmomachia has already undergone many changes.  Subsequent renovations did not improve the situation.  There are many discrepancies in the descriptions of the rules of this game.  Some sources give alternative versions of the original arrangement of pieces (I even came across a variant describing the game on a 8 x 14 board): <br><br><img src="https://habrastorage.org/files/79e/f2b/412/79ef2b4129944de68d0f29edf39c3e83.PNG"><br><br>  There are options with simplified rules for moving figures.  According to these rules, the figures move in a straight line (orthogonal and diagonal) for a given number of cells.  Any figure in the path of movement stops moving.  Jumps, like the course of the Horse in Chess, are absent.  The pyramid, as usual, combines the moves present in its set of figures. <br><br><img src="https://habrastorage.org/files/801/6eb/a13/8016eba135434885a27e1fcbe9eca3f7.png"><br><br>  In addition, there is a variant with the usual rules of the movement of figures, in which a special move of the Pyramid of 3 cells along the diagonal is added.  Such a move is possible under the condition that none of the figures originally included in the Pyramid were taken.  Another option is associated with the preservation of the initial set of figures of the Pyramid.  It is allowed to use the total value of the Pyramid, only under the condition that none of its figures have yet been ‚Äúeaten‚Äù.  There are more simple options in which the Pyramid is removed completely if any of its components is attacked. <br><br>  Some of the options associated with changes in the rules of taking figures.  So, in one of the options, to capture a " <b>by Siege</b> " figure (siege), it is necessary to block all directions of its "natural" movement.  At the same time, it is not necessary to place your pieces close to the blocked one (the examples below illustrate the concept).  This is quite an interesting rule. <br><br><img src="https://habrastorage.org/files/7b3/b0a/a89/7b3b0aa8919445709549b8fa09b97000.png"><br><br>  There is an option in which the capture of " <b>by Ambush</b> " (ambush) is carried out like games of a "clamping" type (in this case, the rules for moving figures are ignored): <br><br><img src="https://habrastorage.org/files/585/d3b/43e/585d3b43e9924c9994fcd1cf10a5d482.png"><br><br>  There are a large number of discrepancies in the definitions of " <b>Glorious Victories</b> ".  Often, the conditions of such victories include the preliminary destruction of the enemy's Pyramid.  Also, there is a condition for completing the game, limited to taking the Pyramid.  There are many variations of this game.  Acquaintance with the nuances of the rules, before the start of the game, in any case, is not at all superfluous. <br><br><h4>  <b>Details for the curious</b> </h4><br>  The implementation of the game is naturally divided into several stages.  The easiest way was to realize the movement of figures.  From this I started.  Here is how the squares look like: <br><br><div class="spoiler">  <b class="spoiler_title">Moving Squares</b> <div class="spoiler_text"><pre><code class="hljs dos">: leap-n ( 'leap-<span class="hljs-built_in"><span class="hljs-built_in">dir</span></span> '<span class="hljs-built_in"><span class="hljs-built_in">shift</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">dir</span></span> count ? -- ) <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> BEGIN OVER EXECUTE <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> on-board? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>- DUP <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> FALSE <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>DROP TRUE TRUE ENDIF <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>DROP FALSE TRUE ENDIF <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>DROP FALSE TRUE ENDIF UNTIL <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> EXECUTE <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> on-board? empty? AND <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> from here DUP last-position ! <span class="hljs-built_in"><span class="hljs-built_in">move</span></span> capture-all add-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span> ENDIF ENDIF <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DROP ENDIF <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>DROP DROP ENDIF ; : <span class="hljs-built_in"><span class="hljs-built_in">shift</span></span>-n ( '<span class="hljs-built_in"><span class="hljs-built_in">shift</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">dir</span></span> count ? -- ) <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> BEGIN OVER EXECUTE <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> on-board? empty? AND <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>- DUP <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> FALSE <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>DROP TRUE TRUE ENDIF <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>DROP FALSE TRUE ENDIF <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>DROP FALSE TRUE ENDIF UNTIL <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> from here DUP last-position ! <span class="hljs-built_in"><span class="hljs-built_in">move</span></span> capture-all add-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span> ENDIF <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>DROP ENDIF ; : s-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-n ( -- ) ['] North <span class="hljs-number"><span class="hljs-number">3</span></span> TRUE <span class="hljs-built_in"><span class="hljs-built_in">shift</span></span>-n ; : s-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-s ( -- ) ['] South <span class="hljs-number"><span class="hljs-number">3</span></span> TRUE <span class="hljs-built_in"><span class="hljs-built_in">shift</span></span>-n ; : s-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-w ( -- ) ['] West <span class="hljs-number"><span class="hljs-number">3</span></span> TRUE <span class="hljs-built_in"><span class="hljs-built_in">shift</span></span>-n ; : s-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-e ( -- ) ['] East <span class="hljs-number"><span class="hljs-number">3</span></span> TRUE <span class="hljs-built_in"><span class="hljs-built_in">shift</span></span>-n ; : s-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-nw ( -- ) ['] Northwest ['] North <span class="hljs-number"><span class="hljs-number">2</span></span> TRUE leap-n ; : s-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-ne ( -- ) ['] Northeast ['] North <span class="hljs-number"><span class="hljs-number">2</span></span> TRUE leap-n ; : s-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-sw ( -- ) ['] Southwest ['] South <span class="hljs-number"><span class="hljs-number">2</span></span> TRUE leap-n ; : s-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-se ( -- ) ['] Southeast ['] South <span class="hljs-number"><span class="hljs-number">2</span></span> TRUE leap-n ; : s-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-wn ( -- ) ['] Northwest ['] West <span class="hljs-number"><span class="hljs-number">2</span></span> TRUE leap-n ; : s-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-ws ( -- ) ['] Southwest ['] West <span class="hljs-number"><span class="hljs-number">2</span></span> TRUE leap-n ; : s-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-en ( -- ) ['] Northeast ['] East <span class="hljs-number"><span class="hljs-number">2</span></span> TRUE leap-n ; : s-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-es ( -- ) ['] Southeast ['] East <span class="hljs-number"><span class="hljs-number">2</span></span> TRUE leap-n ; {moves s-moves {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} s-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-n {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} s-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-s {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} s-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-w {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} s-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-e {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} s-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-nw {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} s-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-ne {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} s-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-sw {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} s-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-se {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} s-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-wn {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} s-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-ws {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} s-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-en {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} s-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-es moves}</code> </pre> <br></div></div><br>  Some difficulty has arisen with the Pyramids, since their set of moves is determined by which pieces belong to them at the moment.  It was necessary to describe all possible moves for them, and when making a move, check the presence in the set of the corresponding figure: <br><br><div class="spoiler">  <b class="spoiler_title">Moving the Pyramids</b> <div class="spoiler_text"><pre> <code class="hljs dos">: is-correct-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>? ( piece-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> -- ? ) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>-empty? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> piece-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> PYRAMID &gt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> here SWAP a1 to BEGIN friend-p <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DUP is-piece-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DROP TRUE TRUE <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> FALSE ENDIF <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DROP FALSE TRUE ENDIF UNTIL SWAP to <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DROP FALSE ENDIF <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DROP FALSE ENDIF ; : pr-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-ne ( -- ) ['] Northeast ROUND is-correct-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>? leap-<span class="hljs-number"><span class="hljs-number">0</span></span> ; : pr-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-se ( -- ) ['] Southeast ROUND is-correct-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>? leap-<span class="hljs-number"><span class="hljs-number">0</span></span> ; : pr-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-nw ( -- ) ['] Northwest ROUND is-correct-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>? leap-<span class="hljs-number"><span class="hljs-number">0</span></span> ; : pr-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-sw ( -- ) ['] Southwest ROUND is-correct-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>? leap-<span class="hljs-number"><span class="hljs-number">0</span></span> ; {moves p-moves {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} pr-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-ne {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} pr-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-se {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} pr-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-nw {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} pr-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-sw ... moves}</code> </pre><br></div></div><br>  The implementation of the battle of figures turned into a real "race for survival."  It was necessary to implement four completely different (and very nontrivial) ways of taking.  At the same time, I wanted to limit the number of field views in order to minimize the overhead of calculations (the course is already calculated ugly for a long time).  As a result, I settled on the idea of ‚Äã‚Äãpre-filling several arrays, with the implementation of subsequent checks on the conditions of the battle of figures: <br><br><div class="spoiler">  <b class="spoiler_title">Ways to fight</b> <div class="spoiler_text"><pre> <code class="hljs cmake">MAXV [] attacking-values[] MAXS [] current-positions[] MAXS [] current-values[] MAXS [] eruption-values[] : fill-current ( pos -- ) <span class="hljs-number"><span class="hljs-number">1</span></span> current-count ! DUP <span class="hljs-number"><span class="hljs-number">0</span></span> current-positions[] ! DUP piece-type-at PYRAMID &gt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> a1 to <span class="hljs-number"><span class="hljs-number">0</span></span> BEGIN enemy-p <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>-empty? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> piece piece-value current-count @ MAXS &lt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> here current-count @ current-positions[] ! DUP current-count @ current-values[] ! current-count ++ <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> UNTIL <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DUP piece-at piece-value <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> current-values[] ! to ; : get-eruption-values ( n -- ) <span class="hljs-number"><span class="hljs-number">0</span></span> sum-value ! PYRAMID is-piece-type? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> here a1 to BEGIN friend-p <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>-empty? eruption-count @ MAXE &lt; <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> OVER piece piece-value DUP sum-value @ + sum-value ! * eruption-count @ eruption-values[] ! eruption-count ++ <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> UNTIL to sum-value @ <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> piece piece-value <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> eruption-count @ MAXE &lt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> * eruption-count @ eruption-values[] ! eruption-count ++ <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>DROP <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> ; : get-attacking-values ( piece-type -- ) <span class="hljs-number"><span class="hljs-number">0</span></span> sum-value ! <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> sum-flag ! PYRAMID is-piece-type? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> here a1 to BEGIN friend-p <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>-empty? attacking-count @ MAXV &lt; <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> piece piece-value sum-value @ + sum-value ! OVER is-piece-type? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> sum-flag ! piece piece-value attacking-count @ attacking-values[] ! attacking-count ++ <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> UNTIL to DROP sum-flag @ attacking-count @ MAXV &lt; <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> sum-value @ attacking-count @ attacking-values[] ! attacking-count ++ <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> is-piece-type? attacking-count @ MAXV &lt; <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> piece piece-value attacking-count @ attacking-values[] ! attacking-count ++ <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> ; : check-siege-od ( 'dir -- ) EXECUTE <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> predict-move <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>-board? <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> friend? <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> siege-counter -- <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>-board? friend? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> get-eruption-values <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> to <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> siege-counter -- <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> ; : check-siege-dd ( 'dir -- ) EXECUTE <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> predict-move <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>-board? <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> friend? <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> siege-counter -- <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>-board? friend? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> ROUND get-attacking-values ROUND check-equality-piece <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> to <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> siege-counter -- <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> ; : check-siege ( pos -- ) <span class="hljs-number"><span class="hljs-number">4</span></span> siege-counter ! DUP to ['] North check-siege-od DUP to ['] South check-siege-od DUP to ['] West check-siege-od DUP to ['] East check-siege-od siege-counter @ <span class="hljs-number"><span class="hljs-number">0</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> is-captured? ! <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> siege-counter ! DUP to ['] Northeast check-siege-dd DUP to ['] Southeast check-siege-dd DUP to ['] Northwest check-siege-dd DUP to ['] Southwest check-siege-dd siege-counter @ <span class="hljs-number"><span class="hljs-number">0</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> is-captured? ! <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> to ; : check-equality-dd ( 'second-dir count 'first-dir -- ) EXECUTE <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>-board? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> BEGIN <span class="hljs-number"><span class="hljs-number">1</span></span>- DUP <span class="hljs-number"><span class="hljs-number">0</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> OVER EXECUTE <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>-board? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> predict-move friend? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> OVER count-to-piece-type DUP get-attacking-values check-equality-piece <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> to <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> UNTIL <span class="hljs-number"><span class="hljs-number">2</span></span>DROP <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>DROP <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> ; : check-equality-od ( 'second-dir count 'first-dir -- ) EXECUTE <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>-board? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> empty? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> BEGIN <span class="hljs-number"><span class="hljs-number">1</span></span>- DUP <span class="hljs-number"><span class="hljs-number">0</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> OVER EXECUTE <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>-board? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> predict-move friend? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> OVER count-to-factor get-eruption-values OVER count-to-piece-type DUP get-attacking-values check-equality-piece <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>-empty? <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> SWAP to <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> UNTIL <span class="hljs-number"><span class="hljs-number">2</span></span>DROP <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>DROP <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> ; : check-equality ( pos -- ) DUP to ['] North <span class="hljs-number"><span class="hljs-number">2</span></span> ['] North check-equality-od DUP to ['] North <span class="hljs-number"><span class="hljs-number">2</span></span> ['] Northwest check-equality-dd DUP to ['] North <span class="hljs-number"><span class="hljs-number">2</span></span> ['] Northeast check-equality-dd DUP to ['] South <span class="hljs-number"><span class="hljs-number">2</span></span> ['] South check-equality-od DUP to ['] South <span class="hljs-number"><span class="hljs-number">2</span></span> ['] Southwest check-equality-dd DUP to ['] South <span class="hljs-number"><span class="hljs-number">2</span></span> ['] Southeast check-equality-dd DUP to ['] West <span class="hljs-number"><span class="hljs-number">2</span></span> ['] West check-equality-od DUP to ['] West <span class="hljs-number"><span class="hljs-number">2</span></span> ['] Northwest check-equality-dd DUP to ['] West <span class="hljs-number"><span class="hljs-number">2</span></span> ['] Southwest check-equality-dd DUP to ['] East <span class="hljs-number"><span class="hljs-number">2</span></span> ['] East check-equality-od DUP to ['] East <span class="hljs-number"><span class="hljs-number">2</span></span> ['] Northeast check-equality-dd DUP to ['] East <span class="hljs-number"><span class="hljs-number">2</span></span> ['] Southeast check-equality-dd to ; : check-ambush-prod ( value -- ? ) value-<span class="hljs-number"><span class="hljs-number">1</span></span> @ value-<span class="hljs-number"><span class="hljs-number">2</span></span> @ * OVER = <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DROP <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DUP value-<span class="hljs-number"><span class="hljs-number">1</span></span> @ * value-<span class="hljs-number"><span class="hljs-number">2</span></span> @ = <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DROP <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> value-<span class="hljs-number"><span class="hljs-number">2</span></span> @ * value-<span class="hljs-number"><span class="hljs-number">1</span></span> @ = <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> ; : check-ambush-cond ( value -- ? ) value-<span class="hljs-number"><span class="hljs-number">1</span></span> @ value-<span class="hljs-number"><span class="hljs-number">2</span></span> @ + OVER = <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DROP <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DUP value-<span class="hljs-number"><span class="hljs-number">1</span></span> @ + value-<span class="hljs-number"><span class="hljs-number">2</span></span> @ = <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DROP <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DUP value-<span class="hljs-number"><span class="hljs-number">2</span></span> @ + value-<span class="hljs-number"><span class="hljs-number">1</span></span> @ = <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DROP <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> check-ambush-prod <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> ; : check-ambush-pair ( -- ) current-count @ BEGIN <span class="hljs-number"><span class="hljs-number">1</span></span>- DUP current-positions[] @ <span class="hljs-number"><span class="hljs-number">0</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DUP current-values[] @ check-ambush-cond <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DUP <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DUP current-positions[] @ DUP enemy-at? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DUP ChangePieces capture-at <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DROP <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span> OVER current-positions[] ! <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> is-captured? ! <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> DUP <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> UNTIL DROP ; : check-ambush ( -- ) attacking-count @ BEGIN <span class="hljs-number"><span class="hljs-number">1</span></span>- attacking-count @ BEGIN <span class="hljs-number"><span class="hljs-number">1</span></span>- <span class="hljs-number"><span class="hljs-number">2</span></span>DUP &lt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>DUP attacking-values[] @ value-<span class="hljs-number"><span class="hljs-number">1</span></span> ! attacking-values[] @ value-<span class="hljs-number"><span class="hljs-number">2</span></span> ! check-ambush-pair <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> DUP <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> UNTIL DROP DUP <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> UNTIL DROP ; : fill-eruption-values ( 'dir pos n -- ) value-<span class="hljs-number"><span class="hljs-number">1</span></span> ! to <span class="hljs-number"><span class="hljs-number">1</span></span> BEGIN <span class="hljs-number"><span class="hljs-number">1</span></span>+ OVER EXECUTE <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> predict-move OVER value-<span class="hljs-number"><span class="hljs-number">1</span></span> @ &gt; <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>-board? friend? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> OVER get-eruption-values <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> to <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> UNTIL <span class="hljs-number"><span class="hljs-number">2</span></span>DROP ; : check-eruption-pair ( -- ) current-count @ BEGIN <span class="hljs-number"><span class="hljs-number">1</span></span>- DUP current-positions[] @ <span class="hljs-number"><span class="hljs-number">0</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DUP current-values[] @ value-<span class="hljs-number"><span class="hljs-number">1</span></span> @ = <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DUP <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DUP current-positions[] @ DUP enemy-at? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DUP ChangePieces capture-at <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DROP <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span> OVER current-positions[] ! <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> is-captured? ! <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> DUP <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> UNTIL DROP ; : check-eruption-values ( -- ) eruption-count @ BEGIN <span class="hljs-number"><span class="hljs-number">1</span></span>- DUP eruption-values[] @ value-<span class="hljs-number"><span class="hljs-number">1</span></span> ! check-eruption-pair DUP <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> UNTIL DROP ; : check-eruption ( pos -- ) ['] North OVER <span class="hljs-number"><span class="hljs-number">4</span></span> fill-eruption-values ['] South OVER <span class="hljs-number"><span class="hljs-number">4</span></span> fill-eruption-values ['] West OVER <span class="hljs-number"><span class="hljs-number">4</span></span> fill-eruption-values ['] East OVER <span class="hljs-number"><span class="hljs-number">4</span></span> fill-eruption-values to check-eruption-values ; : capture-all ( -- ) here ROWS COLS * BEGIN <span class="hljs-number"><span class="hljs-number">1</span></span>- DUP <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>-board-at? OVER enemy-at? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> attacking-count ! <span class="hljs-number"><span class="hljs-number">0</span></span> eruption-count ! <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> is-captured? ! DUP fill-current DUP check-siege is-captured? @ <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DUP check-equality <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> is-captured? @ <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> check-ambush <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> is-captured? @ <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DUP check-eruption <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> is-captured? @ <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> capture-piece <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> DUP <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> UNTIL DROP to ;</code> </pre><br></div></div><br>  The capture of figures in the Pyramid, as well as the displacement, had to be processed in a special way: <br><br><div class="spoiler">  <b class="spoiler_title">Taking figures</b> <div class="spoiler_text"><pre> <code class="hljs cmake">: capture-piece ( -- ) current-count @ BEGIN <span class="hljs-number"><span class="hljs-number">1</span></span>- DUP <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DUP current-positions[] @ DUP <span class="hljs-number"><span class="hljs-number">0</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DUP enemy-at? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DUP ChangePieces capture-at <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DROP <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DROP <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DUP current-positions[] @ DUP enemy-at? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DUP ChangePieces capture-at <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DROP <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> UNTIL DROP ;</code> </pre><br></div></div><br>  Already in the process of debugging, I realized that all the checks are performed at the time before the progress.  I had to write a small function imitating the movement of the figure (this is not a complete recalculation of the position on the board, but I managed to get by with a little blood): <br><br><div class="spoiler">  <b class="spoiler_title">Position change</b> <div class="spoiler_text"><pre> <code class="hljs vbscript">: predict-move ( -- pos ) here DUP from = <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> last-position @ <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DUP last-position @ = <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> from <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ENDIF ENDIF ;</code> </pre><br></div></div><br>  Against the background of all these horrors, checking the conditions for completing the game seemed like a trivial task.  There was a small amount of Axiom magic, but there is nothing here that I would be afraid to show my parents: <br><br><div class="spoiler">  <b class="spoiler_title">Completion check</b> <div class="spoiler_text"><pre> <code class="hljs delphi"><span class="hljs-number"><span class="hljs-number">15</span></span> CONSTANT WINC <span class="hljs-number"><span class="hljs-number">1315</span></span> CONSTANT WINW <span class="hljs-number"><span class="hljs-number">984</span></span> CONSTANT WINB : WhitePieces++ ( -- ) WhitePieces ++ ; : BlackPieces++ ( -- ) BlackPieces ++ ; : WhiteValues++ ( -- ) WhiteValues ++ ; : BlackValues++ ( -- ) BlackValues ++ ; : ChangePieces ( pos -- ) DUP piece-at piece-value SWAP player-at White = <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> COMPILE WhitePieces++ <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>- COMPILE WhiteValues++ DUP <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNTIL</span></span> DROP <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> COMPILE BlackPieces++ <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>- COMPILE BlackValues++ DUP <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNTIL</span></span> DROP ENDIF ; : OnIsGameOver ( -- gameResult ) #UnknownScore current-player White = <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> WhitePieces @ WINC &gt;= <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DROP #LossScore ENDIF WhiteValues @ WINW &gt;= <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DROP #LossScore ENDIF ENDIF current-player Black = <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> BlackPieces @ WINC &gt;= <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DROP #LossScore ENDIF BlackValues @ WINB &gt;= <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DROP #LossScore ENDIF ENDIF ;</code> </pre><br></div></div><br>  From this point on, the program could already play (although it did it rather passively).  The fact is that, in the absence of an evaluation function (and the custom implementation of AI), Axiom tries to perform a complete search, to a terminal position.  It is clear that the completion of the game is far beyond the horizon of the possible depth of enumeration, as a result of which, the found moves are not particularly meaningful.  In general, it remains to add AI teeth: <br><br><div class="spoiler">  <b class="spoiler_title">Evaluation function</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">: OnEvaluate ( <span class="hljs-comment"><span class="hljs-comment">-- score ) current-player material-balance ;</span></span></code> </pre><br></div></div><br>  Here, a very convenient <b>material-balance</b> function (provided by Axiom) is used, which uses the weight values ‚Äã‚Äãspecified for the figures (the same values ‚Äã‚Äãare used for the implementation of the Rhythmochial rules): <br><br><div class="spoiler">  <b class="spoiler_title">Description of figures</b> <div class="spoiler_text"><pre> <code class="hljs cs">{pieces {piece} R0 {moves} r-moves <span class="hljs-number"><span class="hljs-number">0</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} R1 {moves} r-moves <span class="hljs-number"><span class="hljs-number">1</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} R2 {moves} r-moves <span class="hljs-number"><span class="hljs-number">2</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} R3 {moves} r-moves <span class="hljs-number"><span class="hljs-number">3</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} R4 {moves} r-moves <span class="hljs-number"><span class="hljs-number">4</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} R5 {moves} r-moves <span class="hljs-number"><span class="hljs-number">5</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} R6 {moves} r-moves <span class="hljs-number"><span class="hljs-number">6</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} R7 {moves} r-moves <span class="hljs-number"><span class="hljs-number">7</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} R8 {moves} r-moves <span class="hljs-number"><span class="hljs-number">8</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} R9 {moves} r-moves <span class="hljs-number"><span class="hljs-number">9</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} R16 {moves} r-moves <span class="hljs-number"><span class="hljs-number">16</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} R25 {moves} r-moves <span class="hljs-number"><span class="hljs-number">25</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} R36 {moves} r-moves <span class="hljs-number"><span class="hljs-number">36</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} R49 {moves} r-moves <span class="hljs-number"><span class="hljs-number">49</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} R64 {moves} r-moves <span class="hljs-number"><span class="hljs-number">64</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} R81 {moves} r-moves <span class="hljs-number"><span class="hljs-number">81</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} T0 {moves} t-moves <span class="hljs-number"><span class="hljs-number">0</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} T6 {moves} t-moves <span class="hljs-number"><span class="hljs-number">6</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} T9 {moves} t-moves <span class="hljs-number"><span class="hljs-number">9</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} T12 {moves} t-moves <span class="hljs-number"><span class="hljs-number">12</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} T16 {moves} t-moves <span class="hljs-number"><span class="hljs-number">16</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} T20 {moves} t-moves <span class="hljs-number"><span class="hljs-number">20</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} T25 {moves} t-moves <span class="hljs-number"><span class="hljs-number">25</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} T30 {moves} t-moves <span class="hljs-number"><span class="hljs-number">30</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} T36 {moves} t-moves <span class="hljs-number"><span class="hljs-number">36</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} T42 {moves} t-moves <span class="hljs-number"><span class="hljs-number">42</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} T49 {moves} t-moves <span class="hljs-number"><span class="hljs-number">49</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} T56 {moves} t-moves <span class="hljs-number"><span class="hljs-number">56</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} T64 {moves} t-moves <span class="hljs-number"><span class="hljs-number">64</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} T72 {moves} t-moves <span class="hljs-number"><span class="hljs-number">72</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} T81 {moves} t-moves <span class="hljs-number"><span class="hljs-number">81</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} T90 {moves} t-moves <span class="hljs-number"><span class="hljs-number">90</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} T100 {moves} t-moves <span class="hljs-number"><span class="hljs-number">100</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} S0 {moves} s-moves <span class="hljs-number"><span class="hljs-number">0</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} S15 {moves} s-moves <span class="hljs-number"><span class="hljs-number">15</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} S25 {moves} s-moves <span class="hljs-number"><span class="hljs-number">25</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} S28 {moves} s-moves <span class="hljs-number"><span class="hljs-number">28</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} S36 {moves} s-moves <span class="hljs-number"><span class="hljs-number">36</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} S45 {moves} s-moves <span class="hljs-number"><span class="hljs-number">45</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} S49 {moves} s-moves <span class="hljs-number"><span class="hljs-number">49</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} S64 {moves} s-moves <span class="hljs-number"><span class="hljs-number">64</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} S66 {moves} s-moves <span class="hljs-number"><span class="hljs-number">66</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} S81 {moves} s-moves <span class="hljs-number"><span class="hljs-number">81</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} S120 {moves} s-moves <span class="hljs-number"><span class="hljs-number">120</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} S121 {moves} s-moves <span class="hljs-number"><span class="hljs-number">121</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} S153 {moves} s-moves <span class="hljs-number"><span class="hljs-number">153</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} S169 {moves} s-moves <span class="hljs-number"><span class="hljs-number">169</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} S225 {moves} s-moves <span class="hljs-number"><span class="hljs-number">225</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} S289 {moves} s-moves <span class="hljs-number"><span class="hljs-number">289</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} S361 {moves} s-moves <span class="hljs-number"><span class="hljs-number">361</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} P0 {moves} p-moves <span class="hljs-number"><span class="hljs-number">0</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} P91 {moves} p-moves <span class="hljs-number"><span class="hljs-number">91</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} {piece} P190 {moves} p-moves <span class="hljs-number"><span class="hljs-number">190</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>} pieces}</code> </pre><br></div></div><br>  This implementation lacks a lot (for example, checking the end of the game for <b>Glorious Victories</b> ).  I will try to add the missing functionality in the future.  The current version of the source can always be found <a href="">here</a> . <br><br><h4>  What is the result? </h4><br>  Ritmomachia interested me, first of all, in its complexity.  Of course, there were no thoughts to implement it on <a href="http://ru.wikipedia.org/wiki/Zillions_of_Games">ZRF</a> .  I had to master <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D1452">Axiom</a> , for this!  Currently, there is a simplified <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D2282">implementation</a> that does not support <b>Glorious Victories</b> .  Also, there is no firm certainty that I found all the errors in the code (1000 lines in ForthScript is serious).  This is a beta version, but in general, it works: <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/-GogR14dizc%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700191,15700253&amp;usg=ALkJrhht-AWVz1GsrFOZOLsAoSm5NBrjfQ" frameborder="0" allowfullscreen=""></iframe><br><br>  You may notice that the game ends very quickly.  It really is.  In case both players play aggressively, under the conditions of <b>Common Victories</b> (and without limiting the number of pieces taken), the average duration of the game is ~ 10 moves.  In this case, the first player has a significant advantage: <br><br><pre> <code class="hljs pgsql">Cumulative results <span class="hljs-keyword"><span class="hljs-keyword">following</span></span> game <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>: Player <span class="hljs-number"><span class="hljs-number">1</span></span> "Eval", wins = <span class="hljs-number"><span class="hljs-number">13.</span></span> Player <span class="hljs-number"><span class="hljs-number">2</span></span> "Eval", wins = <span class="hljs-number"><span class="hljs-number">0.</span></span> Draws = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  It's funny that if only one of the players is aggressive, the game is delayed to more than 300 moves (the aggressive player almost always wins). <br><br><pre> <code class="hljs pgsql">Cumulative results <span class="hljs-keyword"><span class="hljs-keyword">following</span></span> game <span class="hljs-number"><span class="hljs-number">22</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>: Player <span class="hljs-number"><span class="hljs-number">1</span></span> "Rithmomachy", wins = <span class="hljs-number"><span class="hljs-number">1.</span></span> Player <span class="hljs-number"><span class="hljs-number">2</span></span> "Eval", wins = <span class="hljs-number"><span class="hljs-number">21.</span></span> Draws = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  It's hard to play with a computer.  Even with the illumination of the figures that are under combat, it is not easy to figure out which particular figure should make a move in order to accomplish the capture (at the same time, it is desirable not to substitute your own figures).  In our time, this game is unlikely to be popular, but one does not take away from her.  She is great at developing oral skill. <br></div><p>Source: <a href="https://habr.com/ru/post/234587/">https://habr.com/ru/post/234587/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../234573/index.html">Lumia 1520 - or how to stop eating apples in 5 days</a></li>
<li><a href="../234575/index.html">Medical anatomical illustration - the history of the study of the human body in the atlases of 5 centuries. Part 3</a></li>
<li><a href="../234577/index.html">runScribe helps to avoid injuries while running</a></li>
<li><a href="../234579/index.html">Freemium or Free Trial - which business model to choose when selling software?</a></li>
<li><a href="../234583/index.html">Amazon bought Twitch video streaming service for $ 970 million</a></li>
<li><a href="../234589/index.html">Budget planning: hot September</a></li>
<li><a href="../234591/index.html">Asterisk: PVS-Studio is interested in telephony</a></li>
<li><a href="../234595/index.html">Instruments. How to legally form a partnership break</a></li>
<li><a href="../234597/index.html">28 mistakes of a startup in the eyes of an investor. Business angel experience</a></li>
<li><a href="../234599/index.html">Firefox OS smartphone went on sale for $ 33 (in India)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>