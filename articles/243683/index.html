<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pipe matching in Clojure PL (metaprogramming in Lisp for beginners)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 A few days ago, I discovered a wonderful Clojure PL, one of the modern Lisp dialects, which features a good implementation of multi-thr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pipe matching in Clojure PL (metaprogramming in Lisp for beginners)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/b3d/d1a/703/b3dd1a703e004003b099687f9a28d10f.jpg"><br><br><h1>  Introduction </h1><br>  A few days ago, I discovered a wonderful Clojure PL, one of the modern Lisp dialects, which features a good implementation of multi-threading tools, compilation into jvm bytecode, respectively, the ability to use java libraries, jit compilation, etc.  About Clojure can be read for example <a href="http://habrahabr.ru/post/173071/">here</a> .  But this article is about metaprogramming.  Lisp is designed in such a way that the data and the code in it are the same.  Function declarations, macros, function calls, macro deployment - in Lisp, these are all just lists, possibly nested into each other. <br><br><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defn</span></span> square [foo] (<span class="hljs-name"><span class="hljs-name">*</span></span> foo foo)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> show-it [foo] `(println ~foo))</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This combination of code and data provides powerful metaprogramming capabilities ‚Äî code that writes code, writes code, writes code, etc.  - This is the most common thing for programming in Lisp.  In compile-time, all the functionality of the language is fully accessible to us, we can call functions, deploy macros, possibly recursively.  For example, if we define this macro: <br><a name="habracut"></a><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defmacro</span></span> recurs [foo bar] (<span class="hljs-name"><span class="hljs-name">println</span></span> <span class="hljs-string"><span class="hljs-string">"hello from compiler"</span></span> foo) (<span class="hljs-name"><span class="hljs-name">case</span></span> (<span class="hljs-name"><span class="hljs-name">&lt;=</span></span> bar <span class="hljs-number"><span class="hljs-number">0</span></span>) true `(defn foo [] ~foo) false `(recurs ~(- foo <span class="hljs-number"><span class="hljs-number">1</span></span>) ~(- bar <span class="hljs-number"><span class="hljs-number">1</span></span>))))</code> </pre><br><br>  And in the code we insert the expression <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">recurs</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br><br>  That at compile time we will see <br><br><pre> <code class="bash hljs">hello from compiler 2 hello from compiler 1</code> </pre><br><br>  And the macro in this case will unfold into the definition of the function foo with arity 1 and the return value 1, i.e. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">def</span></span> user/foo (<span class="hljs-name"><span class="hljs-name">clojure</span></span>.core/fn ([] <span class="hljs-number"><span class="hljs-number">1</span></span>)))</code> </pre><br><br>  If we write (recurs 3 1) then the function foo will return the value 2, etc.  Lisp macros are an excellent tool for hiding any complex logic or control structures behind a simple syntax and accordingly for extending the expressive means of the language itself.  Many constructions of a language like "defn", "- &gt;&gt;", "-&gt;" are in fact also simply macros. <br><br>  Lisp macros are ordinary functions, with the exception that they are executed at compile time, and to master the technique of writing them, in principle, it is enough to know how the following 4 ‚Äúspecial forms‚Äù work <br><br><pre> <code class="lisp hljs">`(expr) '(expr) ~(<span class="hljs-name"><span class="hljs-name">expr</span></span>) ~@(<span class="hljs-name"><span class="hljs-name">expr</span></span>)</code> </pre><br><br>  About this you can read in detail <a href="http://blog.8thlight.com/colin-jones/2012/05/22/quoting-without-confusion.html">here</a> .  In a nutshell, the quote ('and `) construct is just a notation to the compiler:‚Äú this expression should not be tried, but returned as it is, i.e.  in the form of a code, and the unquote (~ and ~ @) construction roughly means ‚Äúexecute this expression and insert the result in this place of the code‚Äù.  Naturally, unqoute constructs only make sense within quote constructs.  Thus, macros are functions that take as arguments of a quote construct, returning as values ‚Äã‚Äãof a quote construct and are executed in compile-time. <br><br><h1>  Why do I need pipe matching? </h1><br>  To demonstrate the power of Lisp macros, we will write a pipe matching implementation for Lisp.  What is pipe matching?  As the name implies, this is a composition of two control structures: pipe and pattern matching. <br><br>  Pipes in Clojure's PL are just macros that take the n-th number of expressions as arguments and expand in a certain way to the composition of these expressions, to put it in quite simple terms: <br>  (-&gt; expr1 expr2 expr3 ...) here the pipe "-&gt;" inserts expr1 as the first argument into expr2 (all other arguments move 1 position to the right), the resulting expr12 inserts as the first argument into expr3, etc.  Example <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">-&gt;</span></span> (<span class="hljs-name"><span class="hljs-name">func1</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span>) (<span class="hljs-name"><span class="hljs-name">func2</span></span> <span class="hljs-string"><span class="hljs-string">"bar"</span></span>) (<span class="hljs-name"><span class="hljs-name">func3</span></span> <span class="hljs-number"><span class="hljs-number">123</span></span>))</code> </pre><br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">func3</span></span> (<span class="hljs-name"><span class="hljs-name">func2</span></span> (<span class="hljs-name"><span class="hljs-name">func1</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span>) <span class="hljs-string"><span class="hljs-string">"bar"</span></span>) <span class="hljs-number"><span class="hljs-number">123</span></span>)</code> </pre><br><br>  These two expressions are the same.  The question of the readability of the code is a matter of taste, but personally it‚Äôs obvious to me that the pipes are needed.  There are other pipes, for example - &gt;&gt;, which, if not difficult to guess, works in a similar way -&gt;, it only inserts not the first but the last argument.  In general, you can write any kind of pipe, but as a rule these two are most often used. <br><br>  Pattern Matching is an obvious thing, for example, for erlang / elixir, haskell, ml is a developer, but in a few words it‚Äôs not so easy to explain here, you should rather feel it.  Very distant pm can be defined as a composition of assignment and comparison.  The uninitiated may refer to <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D0%25BF%25D0%25BE%25D1%2581%25D1%2582%25D0%25B0%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D1%2581_%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D1%2586%25D0%25BE%25D0%25BC">Wikipedia</a> or see <a href="http://habrahabr.ru/post/233637/">my previous article</a> , where I briefly described the use of pm in PL elixir / erlang.  Clojure does not have native pattern matching, but as you might guess there are libraries that implement the pm macros almost identical pm in erlang.  We will not reinvent the wheel and use the library macro match in this project. <br><br>  Now back to the question - why do you need to connect pm and pipe in one entity pipe matching?  When we write programs of the ‚Äúhello world‚Äù level, where all functions are pure, there are no side - effects and everything is extremely deterministic, perhaps this does not make much sense.  But in real production you cannot do without dirty functions.  For example, we need to upload a photo to an album in the social network VK.  According to the <a href="https://vk.com/dev/upload_files">documentation</a> for this, we need the album id, access key and the actual data to be downloaded.  The general loading algorithm is as follows <br><br><pre> <code class="bash hljs">   url  (get-http ,  json)   (post-http ,  json)    (get-http ,  json)</code> </pre><br><br>  Reading a file, parsing json, http requests are all dirty functions.  During their call, anything can happen - there is no file at the given address, invalid json, valid json without the required fields, disconnection, the server answered not 200, but something else, etc. and etc.  In each of these functions, everything is very bad.  And everything would be fine, but each next function requires correct results from the previous one.  In each individual function, we can write clauses for bad cases and avoid exceptions, but you need to have it all work together, and if something goes wrong - we want to know exactly what and where exactly went wrong.  Perhaps many readers will want to write something like this. <br><br><img src="https://habrastorage.org/files/d72/651/e85/d72651e859a747a890cc162e843f8f34.jpg"><br><br>  But this is a shame) Which is difficult not only to maintain and debug, but simply to read / write / understand.  It is in such situations (which will agree pretty often) pipe matching will make the code very simple by hiding all the complex logic.  An example of using the macro pipe_matching and pipe_not_matching <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defn</span></span> nested_process foo bar baz (<span class="hljs-name"><span class="hljs-name">pipe_matching</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span> some_data} (<span class="hljs-name"><span class="hljs-name">simple_func1</span></span> foo) (<span class="hljs-name"><span class="hljs-name">simple_func2</span></span>) (<span class="hljs-name"><span class="hljs-name">simple_func3</span></span> bar) (<span class="hljs-name"><span class="hljs-name">simple_func4</span></span> baz)))</code> </pre><br><br>  What happens here: the nested_process function accepts foo, bar, and baz arguments.  And then follow-up calls of possibly dirty functions simple_func1 with arity 1, simple_func2 with arity 1, simple_func3 with arity 2 and simple_func4 with arity 2 begin, while as in ordinary pipes the result of the previous expression is the first argument of the next one.  And now the most important thing is that we set the pattern {: ok some_data} with the first argument of the pipe_matching macro.  Under this pattern is suitable map, where there is a key: ok with any value.  And while simple_func functions return values ‚Äã‚Äãsuitable for this pattern, the next function is called (as in a normal pipe).  But as soon as any of the simple_func functions returns a value not matching this pattern, it will return as the value of the nested_process function and will not be passed further along the chain.  For example, if simple_func3 returns {: error "on simple_func3 server ans 500"}, the function simple_func4 will not be called at all, and nested_process will return {: error "on simple_func3 server ans 500"}.  You can also make a similar macro pipe_not_matching, which can be used like this <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defn</span></span> nested_process foo bar baz (<span class="hljs-name"><span class="hljs-name">pipe_not_matching</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:error</span></span> some_error} (<span class="hljs-name"><span class="hljs-name">simple_func1</span></span> foo) (<span class="hljs-name"><span class="hljs-name">simple_func2</span></span>) (<span class="hljs-name"><span class="hljs-name">simple_func3</span></span> bar) (<span class="hljs-name"><span class="hljs-name">simple_func4</span></span> baz)))</code> </pre><br><br>  I think how it works - it is clear from the context.  If simple_func3 returns here {: error ‚Äúon simple_func3 server ans 500‚Äù}, and the 1st and 2nd functions return the values ‚Äã‚Äãthat do not match the pattern before, the result will be the same as in the previous example.  In practice, I prefer pipe_not_matching.  As a result, we have almost literal serialization of the logic of the problem into the code without any if / else / elseif / case / switch etc.  In general, everything for what we love FP - the code is the task itself without unnecessary abstract entities.  Cool?  Now let's see how to write such macros on Lisp literally in a couple of lines. <br><br><h1>  We write pipe matching for Lisp </h1><br>  First of all, let's write the dependencies for the namespace of our library - we need only one macro ‚Äúmatch‚Äù <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">ns</span></span> pmclj.core (<span class="hljs-symbol"><span class="hljs-symbol">:use</span></span> [clojure.core.match <span class="hljs-symbol"><span class="hljs-symbol">:only</span></span> (<span class="hljs-name"><span class="hljs-name">match</span></span>)]))</code> </pre><br><br>  We define in general 2 macros, which are our goal <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defmacro</span></span> pipe_matching [pattern init_expression &amp; other_expressions ] (<span class="hljs-name"><span class="hljs-name">pipe_matching_inner</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:pattern</span></span> pattern, <span class="hljs-symbol"><span class="hljs-symbol">:result</span></span> init_expression, <span class="hljs-symbol"><span class="hljs-symbol">:expressions</span></span> other_expressions, <span class="hljs-symbol"><span class="hljs-symbol">:continue_on_match</span></span> true})) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> pipe_not_matching [pattern init_expression &amp; other_expressions ] (<span class="hljs-name"><span class="hljs-name">pipe_matching_inner</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:pattern</span></span> pattern, <span class="hljs-symbol"><span class="hljs-symbol">:result</span></span> init_expression, <span class="hljs-symbol"><span class="hljs-symbol">:expressions</span></span> other_expressions, <span class="hljs-symbol"><span class="hljs-symbol">:continue_on_match</span></span> false}))</code> </pre><br><br>  The macro will take pattern as the first argument, the remaining arguments will be expressions for pm itself. It is logical that we need at least one expression, so we will call it init_expression and set it as the obligatory second argument.  Pay attention to the &amp; sign - here it means that other_expressions is a list of any length (possibly empty) consisting respectively of possible arguments (third, fourth, etc.).  Thus, a macro can be expanded with any number of arguments greater than 1. <br><br>  Further, for convenience, we simply serialize the arguments to the map with the keys: pattern,: result,: expressions,: continue_on_match.  result here - the result obtained in the previous step, expressions - the remaining expressions not expanded into the result code of the macro, continue_on_match - true / false: means what to do if result matched the pattern - continue the chain of calls or return the value. <br><br>  The resulting map is passed to the recursive function pipe_matching_inner which returns the code we need.  Yes, this is the beauty of Lisp, you can call functions in compile-time, so long as they were already compiled at the time of the call.  The function is as follows. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defn</span></span> pipe_matching_inner [{pattern <span class="hljs-symbol"><span class="hljs-symbol">:pattern</span></span>, result <span class="hljs-symbol"><span class="hljs-symbol">:result</span></span>, expressions <span class="hljs-symbol"><span class="hljs-symbol">:expressions</span></span>, continue_on_match <span class="hljs-symbol"><span class="hljs-symbol">:continue_on_match</span></span>}] (<span class="hljs-name"><span class="hljs-name">case</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">=</span></span> expressions <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">=</span></span> expressions ())) true result false (<span class="hljs-name"><span class="hljs-name">let</span></span> [to_pipe (<span class="hljs-name"><span class="hljs-name">first</span></span> expressions) rest_expr (<span class="hljs-name"><span class="hljs-name">rest</span></span> expressions)] `(let [~'res ~result] (case (= ~continue_on_match (check_match ~'res ~pattern)) true ~(pipe_matching_inner {:pattern pattern, :result `(-&gt; ~'res ~to_pipe), :expressions rest_expr, :continue_on_match continue_on_match}) false ~'res)))))</code> </pre><br><br>  It takes a map, which we formatted in the body of the macro.  Here, by the way, you can see that native pm in some form and with a rather strange syntax in Clojure is still there: [{pattern: pattern, result: result, expressions: expressions, continue_on_match: continue_on_match}]. <br>  Case - expression here says the following: if we have already processed all the expressions - nothing remains how to return the result.  Otherwise - we process.  Next comes the very important Lisp special form - let.  There are no global variables and assignments here and there cannot be, but we can do local binding in the spirit of the expression =&gt; symbol.  The first and rest functions actually return the first one and everything except the first element of the list, everything is transparent here - we take the following expression to process. <br>  Further, the most interesting is the actual code, which we dynamically generate in compile-time.  There will already have to make a little mental effort to understand what is happening.  We locally bind the result from the previous expression to the res symbol (in order not to execute this expression more than once at runtime).  Pay attention to ~ '- this is a small hack, connected with the fact that when compiling the characters are attached to the corresponding namespace, the combination ~' unhooks them as it were, we will not delve into these issues in the context of this narration.  This is followed by a case - an expression that will be honestly executed at runtime - we will check if our res pattern matches the pattern.  check_match - the macro itself, very simple, based on the match macro library <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defmacro</span></span> check_match [obj pattern] `(match ~obj ~pattern true <span class="hljs-symbol"><span class="hljs-symbol">:else</span></span> false))</code> </pre><br><br>  And further, depending on whether the expression check_match is expected true - for pipe_matching and false - for pipe_not_matching, either the call chain will continue or res will return.  The subsequent call chain is also beautifully drawn by the recursive calls to the pipe_matching_inner function. <br><br>  Let's see how it will look like now. <br>  Here is such a beautiful pipe matching <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">pipe_matching</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span> some} (<span class="hljs-name"><span class="hljs-name">func1</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span>) (<span class="hljs-name"><span class="hljs-name">func2</span></span> <span class="hljs-string"><span class="hljs-string">"bar"</span></span>) (<span class="hljs-name"><span class="hljs-name">func3</span></span> <span class="hljs-number"><span class="hljs-number">123</span></span>))</code> </pre><br><br>  In fact, it unfolds in such a local hell <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">clojure</span></span>.core/let [res (<span class="hljs-name"><span class="hljs-name">func1</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span>)] (<span class="hljs-name"><span class="hljs-name">clojure</span></span>.core/case (<span class="hljs-name"><span class="hljs-name">clojure</span></span>.core/= true (<span class="hljs-name"><span class="hljs-name">pmclj</span></span>.core/check_match res {<span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span> some})) true (<span class="hljs-name"><span class="hljs-name">clojure</span></span>.core/let [res (<span class="hljs-name"><span class="hljs-name">clojure</span></span>.core/-&gt; res (<span class="hljs-name"><span class="hljs-name">func2</span></span> <span class="hljs-string"><span class="hljs-string">"bar"</span></span>))] (<span class="hljs-name"><span class="hljs-name">clojure</span></span>.core/case (<span class="hljs-name"><span class="hljs-name">clojure</span></span>.core/= true (<span class="hljs-name"><span class="hljs-name">pmclj</span></span>.core/check_match res {<span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span> some})) true (<span class="hljs-name"><span class="hljs-name">clojure</span></span>.core/-&gt; res (<span class="hljs-name"><span class="hljs-name">func3</span></span> <span class="hljs-number"><span class="hljs-number">123</span></span>)) false res)) false res))</code> </pre><br><br>  I want to draw your attention that to build the same logic without pipe matching, you would have to write all this hell by yourself) <br><br>  Fully code can be found <a href="https://github.com/timCF/pmclj">here</a> . <br><br>  In conclusion, I want to say that at first glance, the Lisp syntax is certainly not very user-friendly, but IMHO it fits well for building large / complex systems.  Of course, after erlang / elixir you feel without otp as without hands, but I am sure that it is a matter of time.  Anyway, this is my first jvm experience, and I think it will be pretty successful) <br><br><h1>  UPD: </h1><br><br>  Made some refactoring after which the macros themselves do not look so scary.  He listened to the advice and added 4 more macros: <br><br>  pred_matching / pred_not_matching - the same, only accepts the first argument lambda with arity 1. <br>  key_matching / key_not_matching - the same, only accepts a key with the first argument, and at runtime searches for the results of the calls with the specified key value, if the value is nil or missing, it is false otherwise - true. <br><br>  usage example <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defn</span></span> func1 [arg] {<span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span> arg}) (<span class="hljs-name"><span class="hljs-name">defn</span></span> func2 [arg1 arg2] {<span class="hljs-symbol"><span class="hljs-symbol">:fail</span></span> (<span class="hljs-name"><span class="hljs-name">+</span></span> (<span class="hljs-name"><span class="hljs-name">get</span></span> arg1 <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>) arg2)}) (<span class="hljs-name"><span class="hljs-name">defn</span></span> func3 [arg1 arg2] {<span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span> (<span class="hljs-name"><span class="hljs-name">+</span></span> (<span class="hljs-name"><span class="hljs-name">get</span></span> arg1 <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>) arg2)}) (<span class="hljs-name"><span class="hljs-name">defn</span></span> example_pred [] (<span class="hljs-name"><span class="hljs-name">pred_matching</span></span> #(<span class="hljs-name"><span class="hljs-name">contains</span></span>? % <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>) (<span class="hljs-name"><span class="hljs-name">func1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">func2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) (<span class="hljs-name"><span class="hljs-name">func3</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>))) (<span class="hljs-name"><span class="hljs-name">defn</span></span> example_pm [] (<span class="hljs-name"><span class="hljs-name">pipe_matching</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span> some} (<span class="hljs-name"><span class="hljs-name">func1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">func2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) (<span class="hljs-name"><span class="hljs-name">func3</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>))) (<span class="hljs-name"><span class="hljs-name">defn</span></span> example_key [] (<span class="hljs-name"><span class="hljs-name">key_matching</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span> (<span class="hljs-name"><span class="hljs-name">func1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">func2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) (<span class="hljs-name"><span class="hljs-name">func3</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>)))</code> </pre><br><br>  By the way, you will get an example of code where a correct return from the previous function is needed: the place (+ (get arg1: ok) arg2) potentially contains exceptions, for example, if the get function returns nil. <br>  As expected, all three functions of example will return the same value in this case. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">example_pred</span></span>) {:fail <span class="hljs-number"><span class="hljs-number">3</span></span>} (<span class="hljs-name"><span class="hljs-name">example_pm</span></span>) {:fail <span class="hljs-number"><span class="hljs-number">3</span></span>} (<span class="hljs-name"><span class="hljs-name">example_key</span></span>) {:fail <span class="hljs-number"><span class="hljs-number">3</span></span>}</code> </pre><br><br>  Also added rkey_matching / rkey_not_matching macros, work in the same way, just look for key entries in the structure recursively, and if they find, terminate the call chain and return the error found.  As practice has shown - this is the most convenient option in terms of ease of use / versatility. <br><br>  The universality of control structures here is naturally such pred_matching&gt; pipe_matching&gt; rkey_matching&gt; key_matching.  Which of these to use depends on personal taste and the complexity of the data we work with. <br><br>  The resulting code is <a href="">here.</a> </div><p>Source: <a href="https://habr.com/ru/post/243683/">https://habr.com/ru/post/243683/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../243673/index.html">Monitoring and data center management system</a></li>
<li><a href="../243675/index.html">About agile-methodology. Subjectively</a></li>
<li><a href="../243677/index.html">Half a million applications Windows Store, the state of the gaming market in Europe, Oculus Mobile SDK became available for download - and other news of the week for the mobile developer</a></li>
<li><a href="../243679/index.html">Swift Reactive Programming</a></li>
<li><a href="../243681/index.html">WiFi from Ruckus - why is it the best</a></li>
<li><a href="../243685/index.html">Troubleshooting RTZ2 after Microsoft Update KB2998527</a></li>
<li><a href="../243687/index.html">Textbook on the programming language D. Part 4</a></li>
<li><a href="../243689/index.html">IBM invites everyone to a Bluemix meeting</a></li>
<li><a href="../243691/index.html">White Cube on guard of air purity, part 2</a></li>
<li><a href="../243693/index.html">HP Apollo 8000 Water Cool Supercomputer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>