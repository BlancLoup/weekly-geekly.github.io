<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Native OmniDirectional shadows implementation in DirectX11</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hey. Continuing to talk about various technologies from graphic game dev - I would like to talk about how to work with shadows in DirectX 11. I'll tel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Native OmniDirectional shadows implementation in DirectX11</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/d59/f86/132/d59f861321893fa5168833e1dd178a4e.jpg" alt="image"><br><br>  Hey.  Continuing to talk about various technologies from graphic game dev - I would like to talk about how to work with shadows in DirectX 11.  I'll tell you about creating a Point-source of light with full use of GAPI DirectX11 tools, and will touch on such things as: <i><b>Hardware Depth Bias</b></i> , <i><b>GS Cubemap Render</b></i> , <i><b>Native Shadow Map Depth</b></i> , <i><b>Hardware PCF</b></i> . <br>  Based on easy surfing on the Internet - I came to the conclusion that most of the articles on shadows in DX11 are incorrect, not very nicely implemented, or using outdated approaches.  In this article I will try to compare the implementation of shadows in DirectX 9 and DirectX 11. Everything described below is also true for OpenGL. <br><br><a name="habracut"></a><br><h4>  Introduction </h4><br>  And for the start of this expedition, I will still bring into the business those people who do not quite understand what shadows are in games and how they work. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Even back in the 1978th ‚Äã‚Äãyear, Lance Williams introduced the concept of the method of creating shadows, which was called <b><i>Projective shadowing (Shadow mapping)</i></b> and for the state of 2015, there are no better shadow technologies available in production.  Yes, there are a lot of modifications of <b>Projective shadowing</b> , but all of them, one way or another, are based on the latter.  So what is the essence of this method and how can you get shadows from the geometry of any complexity, and even in real-time?  The bottom line is that from the position of the light source the whole scene is rendered without textures and only the distance from the light source to a fragment of the scene is remembered, this thing is simply called the <i>Shadow Map</i> .  This is done all before the main render of the scene.  And further, in the simplest case - the main scene is drawn and for each fragment (pixel) of this scene it is determined whether the source sees this fragment (the light source can be called a camera) or not.  If he sees - the light falls on a fragment, if he does not see - he does not hit, everything is simple.  Well, I will say more about the mathematics of this process, almost all real-time rendering technologies are tied to matrices, I wrote about them a little bit <a href="http://habrahabr.ru/post/238385/">here</a> .  The definition of the ‚Äúvisibility‚Äù of a scene fragment by a light source is as follows: the fragment position is converted from the space of the main camera (view matrix and projection of the main camera) into the light source space: as a result, two comparable values ‚Äã‚Äãare obtained.  The first is the distance from the center of the light source to a fragment of the scene, and the second is the same depth (distance) from the <i>Shadow map</i> that was created earlier.  Comparing them - it is possible to determine whether the fragment is in the shadow or not. <br>  Here is the simplest implementation of shadows.  I also want to note that the sources of light are different, therefore, the shadows will also be different.  There are four main types of light source: <br><br><ul><li>  <b>Spot Light</b> (also known as Projection Light) - it is best presented as an ordinary projector, which has a cone angle of light and is directed to a specific place.  The matrix of such a light source is <i>Perspective Martix</i> . </li><li>  <b>Point Light</b> (also known as Omnidirectional Light) is an omnidirectional light source, it is easier to imagine as a point (hence the Point), which emits light in all directions.  The matrix of such a source is a <i>Perspective Matrix</i> with a viewing angle (Field of View, FOV) of 90 degrees, while it has six species matrices, which are directed to each side (the sides of the cube). </li><li>  <b>Directional Light</b> (also known as Sun Light) is an infinitely distant source of light, the sun on earth, for example.  The matrix of such a light source is the <i>Orthographic Matrix</i> . </li><li>  <b>Ambient Light</b> is a special light source that has no position.  Carries in itself information about the uniform light resulting from the reflections of light from other sources.  In recent times, fading away and being replaced by advanced <i>Global Illumination</i> algorithms. </li></ul><br>  In theory, everything sounds good and consistent, but in practice there are some problems. <br>  The first and most important problem is the discreteness of the shadow map.  In GPU memory, they are stored as special format textures that have a finite size (in games, the ‚Äúshadow quality‚Äù parameter is often associated with the size of the shadow map).  You can present this problem if you place a small piece of geometry right in front of the light source and cast a shadow on the large canvas.  Because of this, the distance between the ends of the beam and its beginning become incomparable (after all, shadow maps of finite size).  The same pixel on the shadow map will correspond to many different positions on the canvas, this leads to such an effect as <i>Aliasing</i> (the shadow looks stepwise): <br><img src="https://habrastorage.org/getpro/habr/post_images/269/d66/c66/269d66c6636c9744aefe461c165dafd0.jpg" alt="image"><br><br>  With this problem, there are many means of struggle, from non-standard projection matrices (for example, <i>Trapezoidal Shadow Map</i> , <i>Geometry Pitch Shadow Map</i> ) to the creation of a large number of shadow maps (4e: <i>Cascaded Shadow Map</i> ).  But all these algorithms are rather narrow to use and are not universal.  The most common way to get rid of strong aliasing is <b><i>Percentage Closer Filtering</i></b> , which is to make several samples with a certain constant offset and interpolate the data, but more about it later. <br><br>  In this article I will consider one of the most difficult light sources - <i>Omnidirectional Light</i> .  Since  it radiates light in all directions and you have to make an unusual shadow map - <i>Cube Shadow Map</i> . <br>  Let's start.  What needs to be implemented for a point light source? <br><ul><li>  Render scenes to a special shadow map - <i>Cube Shadow Map</i> </li><li>  Shader for rendering lighting for any model, for example Lambert </li><li>  DirectX11 shadow filtering </li></ul><br><h4>  Shadow card render </h4><br>  In the era of DirectX9, there were few people who made honest point-light with shadows, but if they did, it was a great waste of resources.  In order to calculate the shadow for an omnidirectional light source - it is necessary to show the world around the light source more than once, there are two options - either <i>Dual Paraboloid Shadow Mapping</i> (twice) or <i>Cube Shadow Mapping</i> (six times).  Let us dwell on the second, because  It is most traditional for point light.  So, in the era of DirectX9, the world was rendered into a special cubic texture, which contained six two-dimensional textures in itself, each time it switched the active side (texture) and the world was drawn again.  Unfortunately - many now continue to do the same, even on DirectX11.  The second problem was that in DirectX9 it was impossible to work with hardware depth from the shader and had to write the depth for further use manually (often in a linear form). <br>  In DirectX 9, the Cube Shadow Map worked as follows: <br><ul><li>  The world was rendered six times - for each side separately </li><li>  The world was rendered in Render Target format R32_Float and was a normal texture </li><li>  Overwhelmingly, the depth of the fragments was recorded in a linear format. </li><li>  Shadows are manually filtered by overlaying. </li></ul><br>  Separately, I want to say why in a linear format?  The fact is that in checking whether the shadow belongs to the current fragment, it was necessary to compare two values: the first is the depth recorded in the shadow map, and the second is the current depth of the fragment in the light source space.  If everything was simple in the case of Spot / Directional, we took a point and reprojected this point into the light source space (by multiplying the view / projection of the light source by the matrix) and compared these two depths.  In the case of Point-light, everything becomes more complicated, we have six different species matrices, which means that we must first determine which face the fragment is in and reproject with a specific face matrix.  This meant that we had to use <i>Dynamic Flow Control</i> in the shader, which is pretty hard for the GPU.  Therefore, they did it easier: they stored the depth in a linear format (the distance from the light source to the fragment was kept in the shadow map) and compared with the linear depth when superimposed.  In this renderer, the hard depth buffer and the Render Target were used, where the linear depth was recorded. <br><br>  In DirectX11, much has changed, at least with the advent of DirectX10, it became possible to use geometric shaders and read native depth in a shader. <br><br>  How do the same shadows work in DirectX11? <br><ul><li>  The world is rendered once - the geometry shader automatically selects the desired side for recording </li><li>  The approach no longer uses the Render Target and renders only the native depth to the hardware buffer. </li><li>  Fragment depth has a standard view: pz / pw </li><li>  Ability to use hardware PCF </li></ul><br><h4>  Practice </h4><br><br>  Now, consider how it all looks in the implementation.  The very first thing you need to implement <i>Cube Shadows Mapping</i> is a matrix of the form and projection: <br><pre><code class="hljs go">_projection = Matrix.PerspectiveFovRH( MathUtil.DegreesToRadians(<span class="hljs-number"><span class="hljs-number">90.0f</span></span>), <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.01f</span></span>, this.Transform.Scale.X);</code> </pre> <br>  The projection matrix always has a viewing angle of 90 degrees, the aspect ratio is one (the cube is still a cube), the far plane is equal to the radius of the light source. <br>  There are six view matrices for this light source: <br><pre> <code class="hljs vbscript"> _view[<span class="hljs-number"><span class="hljs-number">0</span></span>] = Matrix.LookAtRH(position, position + Vector3.<span class="hljs-built_in"><span class="hljs-built_in">Right</span></span>, Vector3.Up); _view[<span class="hljs-number"><span class="hljs-number">1</span></span>] = Matrix.LookAtRH(position, position + Vector3.<span class="hljs-built_in"><span class="hljs-built_in">Left</span></span>, Vector3.Up); _view[<span class="hljs-number"><span class="hljs-number">2</span></span>] = Matrix.LookAtRH(position, position + Vector3.Up, Vector3.BackwardRH); _view[<span class="hljs-number"><span class="hljs-number">3</span></span>] = Matrix.LookAtRH(position, position + Vector3.Down, Vector3.ForwardRH); _view[<span class="hljs-number"><span class="hljs-number">4</span></span>] = Matrix.LookAtRH(position, position + Vector3.BackwardLH, Vector3.Up); _view[<span class="hljs-number"><span class="hljs-number">5</span></span>] = Matrix.LookAtRH(position, position + Vector3.ForwardLH, Vector3.Up);</code> </pre> <br>  Each view matrix describes its own face. In DirectX11, the order of CubeTexture is: Right, Left, Up, Down, Front, Back. <br>  The following is a special description of the <i>Hardware Depth Buffer</i> : <br><pre> <code class="hljs pgsql">TextureDescription cubeDepthDescription = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> TextureDescription() { ArraySize = <span class="hljs-number"><span class="hljs-number">6</span></span>, BindFlags = BindFlags.ShaderResource | BindFlags.DepthStencil, CpuAccessFlags = CpuAccessFlags.<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, Depth = <span class="hljs-number"><span class="hljs-number">1</span></span>, Dimension = TextureDimension.TextureCube, <span class="hljs-keyword"><span class="hljs-keyword">Format</span></span> = SharpDX.DXGI.<span class="hljs-keyword"><span class="hljs-keyword">Format</span></span>.R32_Typeless, Height = CommonLight.SHADOW_CUBE_MAP_SIZE, MipLevels = <span class="hljs-number"><span class="hljs-number">1</span></span>, OptionFlags = ResourceOptionFlags.TextureCube, SampleDescription = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> SharpDX.DXGI.SampleDescription(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">Usage</span></span> = ResourceUsage.<span class="hljs-keyword"><span class="hljs-keyword">Default</span></span>, Width = CommonLight.SHADOW_CUBE_MAP_SIZE };</code> </pre> <br>  Bind flags are a shader resource and the fact that our texture is a depth buffer. <br>  It is also important to cancel that the format is set to <i>R32_Typeless</i> , this is a <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb205074(v%3Dvs.85).aspx">mandatory requirement</a> when reading hardware depth. <br>  Due to the fact that we do not use the render to the texture - it is enough for us to fill the hardware depth buffer with data: <br><pre> <code class="hljs css">_<span class="hljs-selector-tag"><span class="hljs-selector-tag">graphics</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SetViewport</span></span>(0<span class="hljs-selector-tag"><span class="hljs-selector-tag">f</span></span>, 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">f</span></span>, (<span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span>)<span class="hljs-selector-tag"><span class="hljs-selector-tag">CommonLight</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SHADOW_CUBE_MAP_SIZE</span></span>, (<span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span>)<span class="hljs-selector-tag"><span class="hljs-selector-tag">CommonLight</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SHADOW_CUBE_MAP_SIZE</span></span>); _<span class="hljs-selector-tag"><span class="hljs-selector-tag">graphics</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SetRenderTargets</span></span>((<span class="hljs-selector-tag"><span class="hljs-selector-tag">DepthStencilBuffer</span></span>)<span class="hljs-selector-tag"><span class="hljs-selector-tag">light</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ShadowMap</span></span>); _<span class="hljs-selector-tag"><span class="hljs-selector-tag">graphics</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Clear</span></span>((<span class="hljs-selector-tag"><span class="hljs-selector-tag">DepthStencilBuffer</span></span>)<span class="hljs-selector-tag"><span class="hljs-selector-tag">light</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ShadowMap</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">SharpDX</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Direct3D11</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.DepthStencilClearFlags</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Depth</span></span>, 1<span class="hljs-selector-tag"><span class="hljs-selector-tag">f</span></span>, 0); _<span class="hljs-selector-tag"><span class="hljs-selector-tag">cubemapDepthResolver</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Parameters</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">["View"]</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SetValue</span></span>(((<span class="hljs-selector-tag"><span class="hljs-selector-tag">OmnidirectionalLight</span></span>)<span class="hljs-selector-tag"><span class="hljs-selector-tag">light</span></span>)<span class="hljs-selector-class"><span class="hljs-selector-class">.GetCubemapView</span></span>()); _<span class="hljs-selector-tag"><span class="hljs-selector-tag">cubemapDepthResolver</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Parameters</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">["Projection"]</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SetValue</span></span>(((<span class="hljs-selector-tag"><span class="hljs-selector-tag">OmnidirectionalLight</span></span>)<span class="hljs-selector-tag"><span class="hljs-selector-tag">light</span></span>)<span class="hljs-selector-class"><span class="hljs-selector-class">.GetCubemapProjection</span></span>()); <span class="hljs-selector-tag"><span class="hljs-selector-tag">scene</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.RenderScene</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">gameTime</span></span>, _<span class="hljs-selector-tag"><span class="hljs-selector-tag">cubemapDepthResolver</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">false</span></span>, 0);</code> </pre> <br>  Set the size of the viewport, set the depth buffer, the effect and render our scene. <br>  A standard shader needs only one thing - a vertex one, a pixel one is missing because, again, we don‚Äôt use <i>Render To Texture</i> : <br><pre> <code class="hljs lua">VertexOutput DefaultVS(VertexInput <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>) { VertexOutput <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> = (VertexOutput)<span class="hljs-number"><span class="hljs-number">0</span></span>; float4 worldPosition = mul(<span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.Position, World); <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.Position = worldPosition; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>; }</code> </pre> <br>  Just here another shader appears - a geometric one, it will then choose the necessary face for recording the depth: <br><pre> <code class="hljs pgsql">[maxvertexcount(<span class="hljs-number"><span class="hljs-number">18</span></span>)] <span class="hljs-type"><span class="hljs-type">void</span></span> DefaultGS( triangle VertexOutput <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> TriangleStream&lt;GeometryOutput&gt; CubeMapStream ) { [unroll] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-type"><span class="hljs-type">int</span></span> f = <span class="hljs-number"><span class="hljs-number">0</span></span>; f &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>; ++f ) { { GeometryOutput output = (GeometryOutput)<span class="hljs-number"><span class="hljs-number">0</span></span>; output.RTIndex = f; [unroll] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-type"><span class="hljs-type">int</span></span> v = <span class="hljs-number"><span class="hljs-number">0</span></span>; v &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++v ) { <span class="hljs-type"><span class="hljs-type">float4</span></span> worldPosition = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>[v].Position; <span class="hljs-type"><span class="hljs-type">float4</span></span> viewPosition = mul(worldPosition, <span class="hljs-keyword"><span class="hljs-keyword">View</span></span>[f]); output.Position = mul(viewPosition, Projection); CubeMapStream.Append( output ); } CubeMapStream.RestartStrip(); } } }</code> </pre> <br>  His task is to receive a triangle at the entrance, and in response to emit six, but each will be in his face (the parameter RTIndex).  Here are the structures: <br><pre> <code class="hljs pgsql">cbuffer Params : register(b0) { float4x4 World; float4x4 <span class="hljs-keyword"><span class="hljs-keyword">View</span></span>[<span class="hljs-number"><span class="hljs-number">6</span></span>]; float4x4 Projection; }; struct VertexInput { <span class="hljs-type"><span class="hljs-type">float4</span></span> Position : SV_POSITION; //uint InstanceID : SV_InstanceID; }; struct VertexOutput { <span class="hljs-type"><span class="hljs-type">float4</span></span> Position : SV_POSITION; //uint InstanceID : SV_InstanceID; }; struct GeometryOutput { <span class="hljs-type"><span class="hljs-type">float4</span></span> Position : SV_POSITION; uint RTIndex : SV_RenderTargetArrayIndex; };</code> </pre> <br><br>  A person who worked with multiple renders of the same model may notice that instead of emite of a new geometry, you can use instancing by choosing the desired RTIndex based on InstanceID.  Yes, you can, but I got a noticeable loss in performance.  In detail, why it happened - did not go.  It turned out to be much easier to simulate new triangles than to use the ones obtained from the instancing. <br>  After this process, we can get hard cubic depth.  In this case, the render of this geometry was made in one pass. <br>  The next stage is the imposition of a shadow, in my example <i>Deferred Shading is used</i> , but this is also true for <i>Forward</i> rendering.  Now again about the problems: we have to translate the distance from the light source to the fragment into the light source space (cubic depth buffer), but we simply cannot do this, because it is necessary to know which of the six species matrices to use.  <i>You</i> don‚Äôt want to use <i>Dynamic Flow Control</i> , so you can come up with an interesting hack, which is based on the fact that all view matrices are the same and have a FOV of 90 degrees: <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> _vectorToDepth(float3 vec, <span class="hljs-type"><span class="hljs-type">float</span></span> n, <span class="hljs-type"><span class="hljs-type">float</span></span> f) { float3 AbsVec = abs(vec); <span class="hljs-type"><span class="hljs-type">float</span></span> LocalZcomp = max(AbsVec.x, max(AbsVec.y, AbsVec.z)); <span class="hljs-type"><span class="hljs-type">float</span></span> NormZComp = (f+n) / (fn) - (<span class="hljs-number"><span class="hljs-number">2</span></span>*f*n)/(fn)/LocalZcomp; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (NormZComp + <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; }</code> </pre> <br>  In this way, we can determine the depth in the light source space of a particular vector. <br>  Now, we can read the depth from the shadow map using the three-dimensional vector [FragmentPosition-LightPosition] and obtain the depth in the light source space using the same vector, compare them and determine whether the fragment is in the shadow or not. <br>  After passing the shaders to get the shadow and rendering the Light card, we get a shadow with strong aliasing.  For this, the shadow would be good to handle with a filter and the DirectX11 Hardware PCF comes to the rescue, this feature is realized by using special <i>comprasion</i> samplers: <br><pre> <code class="hljs objectivec">SamplerComparisonState LightCubeShadowComparsionSampler : <span class="hljs-keyword"><span class="hljs-keyword">register</span></span>(s0);</code> </pre> <br>  It is described as follows: <br><pre> <code class="hljs pgsql">var dms4 = SharpDX.Direct3D11.SamplerStateDescription.<span class="hljs-keyword"><span class="hljs-keyword">Default</span></span>(); dms4.AddressU = SharpDX.Direct3D11.TextureAddressMode.Clamp; dms4.AddressV = SharpDX.Direct3D11.TextureAddressMode.Clamp; dms4.<span class="hljs-keyword"><span class="hljs-keyword">Filter</span></span> = SharpDX.Direct3D11.<span class="hljs-keyword"><span class="hljs-keyword">Filter</span></span>.ComparisonMinMagMipLinear; dms4.ComparisonFunction = SharpDX.Direct3D11.Comparison.Less;</code> </pre> <br>  And a sample is made like this: <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">LightCubeShadowMap</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SampleCmpLevelZero</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">LightCubeShadowComparsionSampler</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">lightVector</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">obtainedDepth</span></span>)<span class="hljs-selector-class"><span class="hljs-selector-class">.r</span></span></code> </pre> <br>  Where <i>obtainedDepth</i> is the depth that is obtained from the <i>_vectorToDepth</i> function. <br>  The output is a smoothed depth comparison result (if the sampler filter was Linear), which is equivalent to 2x2 Bilinear PCF: <br><img src="https://pp.vk.me/c627723/v627723321/6306/2MhOavy6h68.jpg" alt="image"><br><br>  You can also make an additional 3x3 HPCF and get the following result: <br><img src="https://pp.vk.me/c627723/v627723321/630f/8Town7PK1Jo.jpg" alt="image"><br><br>  I completely forgot to mention one more problem: as mentioned earlier, the depth buffer is discrete, which means that any surface reflected in this buffer looks intermittent (due to limited accuracy), like this: <br><img src="https://pp.vk.me/c627723/v627723321/6320/Xv4H8PgBo5g.jpg" alt="image"><br><br>  The surface begins to cast a shadow on itself, creating the wrong shadow: <br><img src="https://pp.vk.me/c627723/v627723321/6329/yJlJ8FA57-E.jpg" alt="image"><br><br>  This problem is solved if, when comparing, one of the depths is shifted by some small value (bias) in order to even out the problem.  Usually they do something like: cD + 0.0001 &lt;sD when checking.  This method is harmful, because shifting in this way - we very easily get the effect of Peter Pan: <br><div class="spoiler">  <b class="spoiler_title">Peter Pan</b> <div class="spoiler_text"><img src="http://i.imgur.com/Q35Wf0O.png" alt="image"><br></div></div><br>  To effectively solve the problem in DirectX11 there are standard tools, these bias values ‚Äã‚Äãare set in <i>Rasterizer State</i> , the <i>DepthBias</i> and <i>SlopeScaledDepthBias parameters</i> . <br>  Smooth point-light shadows using DirectX11 features are implemented in such a simple way. <br><br>  I will not post the full code, because  it is very much connected with the engine, but I‚Äôm sure to share the shaders: <br><blockquote><div class="spoiler">  <b class="spoiler_title">DeferredShading.fx</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"..//pp_GBuffer.fxh"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Lights.fxh"</span></span></span><span class="hljs-meta"> float4 PointLightPS(float2 UV : TEXCOORD) : SV_TARGET { SurfaceData surfaceData = GetSurfaceData(UV); float3 texelPosition = GetPosition(UV); float3 texelNormal = surfaceData.Normal; float3 vL = texelPosition - LightPosition; float3 L = normalize(vL); float3 lightColor = _calculationLight(texelNormal, L); float3 lightCookie = float3(1, 1, 1); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(IsLightCookie) { float3 rL = mul(float4(L, 1), LightRotation).xyz; lightCookie = LightCubeCookie.Sample(LightCubeCookieSampler, float3(rL.xy, -rL.z) ).rgb; } float shadowed = 1; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(IsLightShadow) shadowed = _sampleCubeShadowHPCF(L, vL); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//if(IsLightShadow) // shadowed = _sampleCubeShadowPCFSwizzle3x3(L, vL); float atten = _calcAtten(vL); return float4(lightColor * lightCookie * shadowed * atten, 1); } technique PointLightTechnique { pass { Profile = 10.0; PixelShader = PointLightPS; } }</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Lights.fxh</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">cbuffer LightSource : register(b1) { float3 LightPosition; <span class="hljs-type"><span class="hljs-type">float</span></span> LightRadius; <span class="hljs-type"><span class="hljs-type">float4</span></span> LightColor; float4x4 LightRotation; float2 LightNearFar; const <span class="hljs-type"><span class="hljs-type">bool</span></span> IsLightCookie; const <span class="hljs-type"><span class="hljs-type">bool</span></span> IsLightShadow; }; TextureCube&lt;<span class="hljs-type"><span class="hljs-type">float4</span></span>&gt; LightCubeCookie : register(t3); SamplerState LightCubeCookieSampler : register(s1); TextureCube&lt;<span class="hljs-type"><span class="hljs-type">float</span></span>&gt; LightCubeShadowMap : register(t4); SamplerComparisonState LightCubeShadowComparsionSampler : register(s2); SamplerState LightCubeShadowPointSampler : register(s3); <span class="hljs-type"><span class="hljs-type">float</span></span> _calcAtten(float3 vL) { float3 lVec = vL / LightRadius; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span> - dot(lVec,lVec)); } float3 _calculationLight(float3 N, float3 L) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LightColor.xyz * saturate(dot(N, -L)) * LightColor.w; } <span class="hljs-type"><span class="hljs-type">float</span></span> _vectorToDepth(float3 vec, <span class="hljs-type"><span class="hljs-type">float</span></span> n, <span class="hljs-type"><span class="hljs-type">float</span></span> f) { float3 AbsVec = abs(vec); <span class="hljs-type"><span class="hljs-type">float</span></span> LocalZcomp = max(AbsVec.x, max(AbsVec.y, AbsVec.z)); <span class="hljs-type"><span class="hljs-type">float</span></span> NormZComp = (f+n) / (fn) - (<span class="hljs-number"><span class="hljs-number">2</span></span>*f*n)/(fn)/LocalZcomp; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (NormZComp + <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; } <span class="hljs-type"><span class="hljs-type">float</span></span> _sampleCubeShadowHPCF(float3 L, float3 vL) { <span class="hljs-type"><span class="hljs-type">float</span></span> sD = _vectorToDepth(vL, LightNearFar.x, LightNearFar.y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LightCubeShadowMap.SampleCmpLevelZero(LightCubeShadowComparsionSampler, float3(L.xy, -Lz), sD).r; } <span class="hljs-type"><span class="hljs-type">float</span></span> _sampleCubeShadowPCFSwizzle3x3(float3 L, float3 vL) { <span class="hljs-type"><span class="hljs-type">float</span></span> sD = _vectorToDepth(vL, LightNearFar.x, LightNearFar.y); float3 forward = float3(L.xy, -Lz); float3 right = float3( forward.z, -forward.x, forward.y ); right -= forward * dot( right, forward ); right = normalize(right); float3 up = <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span>(right, forward ); <span class="hljs-type"><span class="hljs-type">float</span></span> tapoffset = (<span class="hljs-number"><span class="hljs-number">1.0</span></span>f / <span class="hljs-number"><span class="hljs-number">512.0</span></span>f); right *= tapoffset; up *= tapoffset; float3 v0; v0.x = LightCubeShadowMap.SampleCmpLevelZero(LightCubeShadowComparsionSampler, forward - right - up, sD).r; v0.y = LightCubeShadowMap.SampleCmpLevelZero(LightCubeShadowComparsionSampler, forward - up, sD).r; v0.z = LightCubeShadowMap.SampleCmpLevelZero(LightCubeShadowComparsionSampler, forward + right - up, sD).r; float3 v1; v1.x = LightCubeShadowMap.SampleCmpLevelZero(LightCubeShadowComparsionSampler, forward - right, sD).r; v1.y = LightCubeShadowMap.SampleCmpLevelZero(LightCubeShadowComparsionSampler, forward, sD).r; v1.z = LightCubeShadowMap.SampleCmpLevelZero(LightCubeShadowComparsionSampler, forward + right, sD).r; float3 v2; v2.x = LightCubeShadowMap.SampleCmpLevelZero(LightCubeShadowComparsionSampler, forward - right + up, sD).r; v2.y = LightCubeShadowMap.SampleCmpLevelZero(LightCubeShadowComparsionSampler, forward + up, sD).r; v2.z = LightCubeShadowMap.SampleCmpLevelZero(LightCubeShadowComparsionSampler, forward + right + up, sD).r; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dot(v0 + v1 + v2, <span class="hljs-number"><span class="hljs-number">.1111111</span></span>f); } // UE4: https://github.com/EpicGames/UnrealEngine/blob/<span class="hljs-keyword"><span class="hljs-keyword">release</span></span>/Engine/Shaders/ShadowProjectionCommon.usf static const float2 DiscSamples5[]= { // <span class="hljs-number"><span class="hljs-number">5</span></span> random points <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> disc <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> radius <span class="hljs-number"><span class="hljs-number">2.500000</span></span> float2(<span class="hljs-number"><span class="hljs-number">0.000000</span></span>, <span class="hljs-number"><span class="hljs-number">2.500000</span></span>), float2(<span class="hljs-number"><span class="hljs-number">2.377641</span></span>, <span class="hljs-number"><span class="hljs-number">0.772542</span></span>), float2(<span class="hljs-number"><span class="hljs-number">1.469463</span></span>, <span class="hljs-number"><span class="hljs-number">-2.022543</span></span>), float2(<span class="hljs-number"><span class="hljs-number">-1.469463</span></span>, <span class="hljs-number"><span class="hljs-number">-2.022542</span></span>), float2(<span class="hljs-number"><span class="hljs-number">-2.377641</span></span>, <span class="hljs-number"><span class="hljs-number">0.772543</span></span>), }; <span class="hljs-type"><span class="hljs-type">float</span></span> _sampleCubeShadowPCFDisc5(float3 L, float3 vL) { float3 SideVector = normalize(<span class="hljs-keyword"><span class="hljs-keyword">cross</span></span>(L, float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>))); float3 UpVector = <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span>(SideVector, L); SideVector *= <span class="hljs-number"><span class="hljs-number">1.0</span></span> / <span class="hljs-number"><span class="hljs-number">512.0</span></span>; UpVector *= <span class="hljs-number"><span class="hljs-number">1.0</span></span> / <span class="hljs-number"><span class="hljs-number">512.0</span></span>; <span class="hljs-type"><span class="hljs-type">float</span></span> sD = _vectorToDepth(vL, LightNearFar.x, LightNearFar.y); float3 nlV = float3(L.xy, -Lz); <span class="hljs-type"><span class="hljs-type">float</span></span> totalShadow = <span class="hljs-number"><span class="hljs-number">0</span></span>; [UNROLL] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; ++i) { float3 SamplePos = nlV + SideVector * DiscSamples5[i].x + UpVector * DiscSamples5[i].y; totalShadow += LightCubeShadowMap.SampleCmpLevelZero( LightCubeShadowComparsionSampler, SamplePos, sD); } totalShadow /= <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> totalShadow; }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">CubeDepthReslover.fxh</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">cbuffer Params : register(b0) { float4x4 World; float4x4 <span class="hljs-keyword"><span class="hljs-keyword">View</span></span>[<span class="hljs-number"><span class="hljs-number">6</span></span>]; float4x4 Projection; }; struct VertexInput { <span class="hljs-type"><span class="hljs-type">float4</span></span> Position : SV_POSITION; //uint InstanceID : SV_InstanceID; }; struct VertexOutput { <span class="hljs-type"><span class="hljs-type">float4</span></span> Position : SV_POSITION; //uint InstanceID : SV_InstanceID; }; struct GeometryOutput { <span class="hljs-type"><span class="hljs-type">float4</span></span> Position : SV_POSITION; uint RTIndex : SV_RenderTargetArrayIndex; }; VertexOutput DefaultVS(VertexInput <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>) { VertexOutput output = (VertexOutput)<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> worldPosition = mul(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.Position, World); output.Position = worldPosition; //output.InstanceID = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.InstanceID; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output; } [maxvertexcount(<span class="hljs-number"><span class="hljs-number">18</span></span>)] <span class="hljs-type"><span class="hljs-type">void</span></span> DefaultGS( triangle VertexOutput <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> TriangleStream&lt;GeometryOutput&gt; CubeMapStream ) { [unroll] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-type"><span class="hljs-type">int</span></span> f = <span class="hljs-number"><span class="hljs-number">0</span></span>; f &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>; ++f ) { { GeometryOutput output = (GeometryOutput)<span class="hljs-number"><span class="hljs-number">0</span></span>; output.RTIndex = f; [unroll] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-type"><span class="hljs-type">int</span></span> v = <span class="hljs-number"><span class="hljs-number">0</span></span>; v &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++v ) { <span class="hljs-type"><span class="hljs-type">float4</span></span> worldPosition = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>[v].Position; <span class="hljs-type"><span class="hljs-type">float4</span></span> viewPosition = mul(worldPosition, <span class="hljs-keyword"><span class="hljs-keyword">View</span></span>[f]); output.Position = mul(viewPosition, Projection); CubeMapStream.Append( output ); } CubeMapStream.RestartStrip(); } } } technique CubeDepthResolver { pass DefaultPass { Profile = <span class="hljs-number"><span class="hljs-number">10.0</span></span>; VertexShader = DefaultVS; GeometryShader = DefaultGS; PixelShader = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } }</code> </pre> <br></div></div></blockquote><br><br>  If you have any questions or need help - I will be happy to help, you can see the contacts in my profile. <br><br>  Coming upcoming articles: <br><ul><li>  Implement Deferred Rendered Water </li><li>  Physically-Based Rendering without using IBL </li></ul><br>  <i>PS</i> <i><br></i>  <i>Dear reader, if you like to read the articles carefully and have found something inaccurate or inaccurate, do not rush to write a comment, but rather write me a personal message, I will definitely say thank you!</i> </div><p>Source: <a href="https://habr.com/ru/post/259679/">https://habr.com/ru/post/259679/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../259663/index.html">Online store trump card: online shopping usability study</a></li>
<li><a href="../259667/index.html">Installing OpenStreetMap Nominatim to find latitude and longitude at the address entered</a></li>
<li><a href="../259671/index.html">Fast security-oriented fuzzing with AFL</a></li>
<li><a href="../259675/index.html">Ruby and C. Part 4. We are on friendly terms with the accelerometer, gyroscope and range finder with Raphael.js</a></li>
<li><a href="../259677/index.html">Autopilot system for radio-controlled helicopter. Part 1: The Idea</a></li>
<li><a href="../259683/index.html">Autopilot system for radio-controlled helicopter. Part 2: Takeover</a></li>
<li><a href="../259691/index.html">Battle "Listener vs Visitor" at the stadium antlr4</a></li>
<li><a href="../259701/index.html">Vim in full: Introduction</a></li>
<li><a href="../259709/index.html">Port i2cdevlib on STM32 HAL</a></li>
<li><a href="../259717/index.html">Start using GTKD</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>