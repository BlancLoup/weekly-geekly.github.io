<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reactive work with Bluetooth in real conditions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A small preface, or what is the pain 


 Recently, I have been actively working on applications that have Bluetooth modules for non-very-well-designed...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reactive work with Bluetooth in real conditions</h1><div class="post__text post__text-html js-mediator-article"><h3 id="nebolshoe-predislovie-ili-v-chem-zhe-bol">  A small preface, or what is the pain </h3><br><p>  Recently, I have been actively working on applications that have Bluetooth modules for non-very-well-designed protocols with custom devices, which periodically adds interesting ones to me <del>  yep how </del>  problems. </p><br><p>  Since I am a sincere fan of reactivity in applications, I had to solve such problems on my own, since there are simply no solutions on the web.  Totally.  I would like to tell you about the resulting architecture of working with Bluetooth devices. </p><br><h3 id="opasnosti-na-puti-dzhedaya">  Dangers on the way of the Jedi </h3><br><p>  The first important point that the developer should keep in mind when working with Bluetooth is that packets can be damaged along the way.  And yet - they can be accompanied by noise.  And this is not one case in a million, such phenomena can occur quite often, and they need to be processed.  Another bluetooth may disconnect, or not connect, or pretend to connect, but in actual fact we know that it means nothing ... </p><br><p>  As an example of solving these problems, we will design a micro-framework for processing events that are determined by type using a header (first N bytes) and validated with some simple check-sum.  In order not to clutter up the code, we will assume that the header of the protocol has a fixed size.  All packets are divided into two types: with a fixed length, and with a dynamic one, transmitted by a separate byte. </p><a name="habracut"></a><br><h3 id="proektirovanie">  Design </h3><br><p>  Let's start with a description of possible events in the application.  So, the general abstraction will look something like this, taking into account the restrictions adopted: </p><br><pre><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> headSize: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> head: ByteArray <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isCorrupted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> <span class="hljs-comment"><span class="hljs-comment">//To be continued }</span></span></code> </pre> <br><p>  Further, when we have defined sets of constant properties for all packages, it is necessary to formalize somehow the conditions under which we: </p><br><ol><li>  Let's calculate that the package belongs to some type. </li><li>  Must be added to buffer bytes, as long as the packet is not going to </li><li>  Must bang buffer, as any conditions for its assembly are not fulfilled (this item is needed more for safety, it is better to add logs there during the testing of the application to check the completeness of the other conditions) </li><li>  We try to build a package from the buffer and check its validity. </li></ol><br><p>  These four conditions lead us to the following interface: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventMatcher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> headSize: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matches</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(packet: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ByteBuffer</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(packet: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ByteBuffer</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Event <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(packet: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ByteBuffer</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldDrop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(packet: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ByteBuffer</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> }</code> </pre> <br><p>  Create a component that will provide <del>  would say that convenient, but I will leave it to your discretion </del>  proxy interface to our matcher for all existing types, nothing outstanding, the code under the cat: </p><br><div class="spoiler">  <b class="spoiler_title">Proxy matcher</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventMatchersAdapter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> matchers = mutableMapOf&lt;KClass&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Event&gt;, EventMatcher&gt;() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">KClass</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, matcher: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EventMatcher</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = apply { matchers.put(event, matcher) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unregister</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">KClass</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = apply { matchers.remove(event) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">knownEvents</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;KClass&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Event&gt;&gt; = matchers.keys.toList() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matches</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(packet: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ByteBuffer</span></span></span></span><span class="hljs-function"><span class="hljs-params">, event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">KClass</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = matchers[event]?.matches(packet) ?: <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(packet: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ByteBuffer</span></span></span></span><span class="hljs-function"><span class="hljs-params">, event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">KClass</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = matchers[event]?.shouldBuffer(packet) ?: <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldDrop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(packet: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ByteBuffer</span></span></span></span><span class="hljs-function"><span class="hljs-params">, event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">KClass</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = matchers[event]?.shouldDrop(packet) ?: <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(packet: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ByteBuffer</span></span></span></span><span class="hljs-function"><span class="hljs-params">, event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">KClass</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: Event? = matchers[event]?.create(packet) }</code> </pre> </div></div><br><p>  In the packages we describe the method of determining whether the package was damaged or not.  This is a rather convenient approach, which allows you not to suffer much because of a poorly designed protocol, in which the engineer decided to throw you a hundred ways to check the packages for correctness, for each of several. </p><br><div class="spoiler">  <b class="spoiler_title">An example of a package with a fixed length</b> <div class="spoiler_text"><pre> <code class="hljs sql">data class A(override val head: ByteArray, val payload: ByteArray, val <span class="hljs-keyword"><span class="hljs-keyword">checksum</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">Byte</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">Event</span></span>() { companion <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { //(two <span class="hljs-keyword"><span class="hljs-keyword">bytes</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">head</span></span>) + (<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bytes</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> payload) + (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">checksum</span></span>) @JvmStatic val <span class="hljs-keyword"><span class="hljs-keyword">length</span></span> = <span class="hljs-number"><span class="hljs-number">5.</span></span>toByte() @JvmStatic val headValue = byteArrayOf(<span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>) @JvmStatic val matcherValue = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>: EventMatcher { override val headSize: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span> override fun matches(packet: ByteBuffer): <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(packet.position() == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(packet.position() == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> packet[<span class="hljs-number"><span class="hljs-number">0</span></span>] == headValue[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> packet[<span class="hljs-number"><span class="hljs-number">0</span></span>] == headValue[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; packet[<span class="hljs-number"><span class="hljs-number">1</span></span>] == headValue[<span class="hljs-number"><span class="hljs-number">1</span></span>] } override fun <span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(packet: ByteBuffer): A { packet.rewind() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> A( ByteArray(<span class="hljs-number"><span class="hljs-number">2</span></span>, { packet.get() }), ByteArray(<span class="hljs-number"><span class="hljs-number">2</span></span>, { packet.get() }), packet.get() ) } override fun shouldBuffer(packet: ByteBuffer): <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = packet.position() &lt; <span class="hljs-keyword"><span class="hljs-keyword">length</span></span> override fun shouldDrop(packet: ByteBuffer): <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = packet.position() &gt; <span class="hljs-keyword"><span class="hljs-keyword">length</span></span> } } override fun isCorrupted(): <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = checksumOf(payload) != <span class="hljs-keyword"><span class="hljs-keyword">checksum</span></span> override fun equals(other: <span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>?): <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(other <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? A == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> other <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.equals(<span class="hljs-keyword"><span class="hljs-keyword">head</span></span>, other.head) &amp;&amp; Arrays.equals(payload, other.payload) &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">checksum</span></span> == other.checksum } override fun hashCode(): <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> = Arrays.hashCode(<span class="hljs-keyword"><span class="hljs-keyword">head</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> * <span class="hljs-number"><span class="hljs-number">31</span></span> + Arrays.hashCode(payload) <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> * <span class="hljs-number"><span class="hljs-number">31</span></span> + checksum.hashCode() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">An example of a package with dynamic length</b> <div class="spoiler_text"><pre> <code class="hljs sql">data class C(override val head: ByteArray, val length: Byte, val payload: ByteArray, val <span class="hljs-keyword"><span class="hljs-keyword">checksum</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">Byte</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">Event</span></span>() { companion <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { @JvmStatic val headValue = byteArrayOf(<span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>) @JvmStatic val matcherValue = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>: EventMatcher { override val headSize: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span> override fun matches(packet: ByteBuffer): <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(packet.position() == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(packet.position() == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> packet[<span class="hljs-number"><span class="hljs-number">0</span></span>] == headValue[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> packet[<span class="hljs-number"><span class="hljs-number">0</span></span>] == headValue[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; packet[<span class="hljs-number"><span class="hljs-number">1</span></span>] == headValue[<span class="hljs-number"><span class="hljs-number">1</span></span>] } override fun <span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(packet: ByteBuffer): C { packet.rewind() val msb = packet.get() val lsb = packet.get() val <span class="hljs-keyword"><span class="hljs-keyword">length</span></span> = packet.get() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> C( byteArrayOf(msb, lsb), <span class="hljs-keyword"><span class="hljs-keyword">length</span></span>, packet.take(<span class="hljs-number"><span class="hljs-number">3</span></span>, length.toPositiveInt()), packet.get() ) } override fun shouldBuffer(packet: ByteBuffer): <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(packet.position()) { <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span> -&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; packet.position() &lt; (packet[<span class="hljs-number"><span class="hljs-number">2</span></span>].toPositiveInt() + <span class="hljs-number"><span class="hljs-number">4</span></span>) //increase <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bytes</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">head</span></span>) + (<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">length</span></span>) + (<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">checksum</span></span>) } override fun shouldDrop(packet: ByteBuffer): <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(packet.position()) { <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span> -&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; packet.position() &gt; (packet[<span class="hljs-number"><span class="hljs-number">2</span></span>].toPositiveInt() + <span class="hljs-number"><span class="hljs-number">4</span></span>) //increase <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bytes</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">head</span></span>) + (<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">length</span></span>) + (<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">checksum</span></span>) } } } override fun isCorrupted(): <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = checksumOf(payload) != <span class="hljs-keyword"><span class="hljs-keyword">checksum</span></span> override fun equals(other: <span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>?): <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(other <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? C == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> other <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> C <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.equals(<span class="hljs-keyword"><span class="hljs-keyword">head</span></span>, other.head) &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">length</span></span> == other.length &amp;&amp; Arrays.equals(payload, other.payload) &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">checksum</span></span> == other.checksum } override fun hashCode(): <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> = Arrays.hashCode(<span class="hljs-keyword"><span class="hljs-keyword">head</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> * <span class="hljs-number"><span class="hljs-number">31</span></span> + length.hashCode() <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> * <span class="hljs-number"><span class="hljs-number">31</span></span> + Arrays.hashCode(payload) <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> * <span class="hljs-number"><span class="hljs-number">31</span></span> + checksum.hashCode() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> } }</code> </pre> </div></div><br><p>  Further, we are required to describe the packet reading algorithm itself, and one that will be: </p><br><ol><li>  Maintain several different types. </li><li>  Destroy damage packages for us </li><li>  Will be friends with Flowable </li></ol><br><p>  The implementation of the algorithm hidden behind the Subscriber interface: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventsBridge</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> adapter: EventMatchersAdapter, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> emitter: FlowableEmitter&lt;Event&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bufferSize: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">128</span></span>): DisposableSubscriber&lt;<span class="hljs-built_in"><span class="hljs-built_in">Byte</span></span>&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> buffers: Map&lt;KClass&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Event&gt;, ByteBuffer&gt; = mutableMapOf&lt;KClass&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Event&gt;, ByteBuffer&gt;() .apply { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(knownEvent <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> adapter.knownEvents()) { put(knownEvent, ByteBuffer.allocateDirect(bufferSize)) } } .toMap() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { emitter.onError(t) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { emitter.onComplete() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>((key, value) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> buffers) { value.put(t) adapter.knownEvents() .filter { it == key } .forEach { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (adapter.matches(value, it)) { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { adapter.shouldDrop(value, it) -&gt; { value.clear() } !adapter.shouldBuffer(value, it) -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> event = adapter.create(value, it) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!emitter.isCancelled &amp;&amp; event != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; !event.isCorrupted()) { release() emitter.onNext(event) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { value.clear() } } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { value.clear() } } } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(buffer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> buffers) buffer.value.clear() } }</code> </pre> <br><h3 id="ispolzovanie">  Using </h3><br><p>  Consider the example of running unit tests: </p><br><div class="spoiler">  <b class="spoiler_title">A simple test for one type of package</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_single_fixedLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> adapter = EventMatchersAdapter() .register(Event.A::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Event.A.matcherValue) val packetA = generateCorrectPacketA</span></span></span></span>() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testSubscriber = TestSubscriber&lt;Event&gt;() Flowable.create&lt;Event&gt;( { emitter -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bridge = EventsBridge(adapter, emitter) Flowable.create&lt;<span class="hljs-built_in"><span class="hljs-built_in">Byte</span></span>&gt;({ byteEmitter -&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(byte <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> packetA) { byteEmitter.onNext(byte) } }, BackpressureStrategy.BUFFER).subscribe(bridge) }, BackpressureStrategy.BUFFER ) .subscribe(testSubscriber) testSubscriber.assertNoErrors() testSubscriber.assertValue { event -&gt; event <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Event.A &amp;&amp; !event.isCorrupted() } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Test with lots of noise, several types of packages</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_multiple_dynamicLength_mixed_withNoise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> adapter = EventMatchersAdapter() .register(Event.C::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Event.C.matcherValue) .register</span></span></span></span>(Event.D::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Event.D.matcherValue) val packetC1 = generateCorrectPacketC</span></span></span></span>() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> packetD1 = generateCorrectPacketD() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> packetD2 = generateCorruptedPacketD() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> packetC2 = generateCorruptedPacketC() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testSubscriber = TestSubscriber&lt;Event&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> random = Random() Flowable.create&lt;Event&gt;( { emitter -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bridge = EventsBridge(adapter, emitter) Flowable.create&lt;<span class="hljs-built_in"><span class="hljs-built_in">Byte</span></span>&gt;({ byteEmitter -&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">100</span></span>) { byteEmitter.onNext(random.nextInt().toByte()) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(byte <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> packetC1) { byteEmitter.onNext(byte) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">100</span></span>) { byteEmitter.onNext(random.nextInt().toByte()) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(byte <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> packetD1) { byteEmitter.onNext(byte) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">100</span></span>) { byteEmitter.onNext(random.nextInt().toByte()) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(byte <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> packetD2) { byteEmitter.onNext(byte) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">100</span></span>) { byteEmitter.onNext(random.nextInt().toByte()) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(byte <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> packetC2) { byteEmitter.onNext(byte) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">100</span></span>) { byteEmitter.onNext(random.nextInt().toByte()) } }, BackpressureStrategy.BUFFER).subscribe(bridge) }, BackpressureStrategy.BUFFER ) .subscribe(testSubscriber) testSubscriber.assertNoErrors() testSubscriber.assertValueCount(<span class="hljs-number"><span class="hljs-number">2</span></span>) }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Test Package Generation</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateCorrectPacketB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ByteArray { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rnd = Random() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> payload = byteArrayOf( rnd.nextInt().toByte(), rnd.nextInt().toByte(), rnd.nextInt().toByte(), rnd.nextInt().toByte() ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> byteArrayOf( Event.B.headValue[<span class="hljs-number"><span class="hljs-number">0</span></span>], Event.B.headValue[<span class="hljs-number"><span class="hljs-number">1</span></span>], payload[<span class="hljs-number"><span class="hljs-number">0</span></span>], payload[<span class="hljs-number"><span class="hljs-number">1</span></span>], payload[<span class="hljs-number"><span class="hljs-number">2</span></span>], payload[<span class="hljs-number"><span class="hljs-number">3</span></span>], checksumOf(payload) ) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateCorrectPacketC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ByteArray { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rnd = Random() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> payload = List(rnd.nextInt(<span class="hljs-number"><span class="hljs-number">16</span></span>), { index -&gt; rnd.nextInt().toByte() }).toByteArray() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ByteArray(<span class="hljs-number"><span class="hljs-number">4</span></span> + payload.size, { index -&gt; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(index) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; Event.C.headValue[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-number"><span class="hljs-number">1</span></span> -&gt; Event.C.headValue[<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-number"><span class="hljs-number">2</span></span> -&gt; payload.size.toByte() <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>..(<span class="hljs-number"><span class="hljs-number">4</span></span> + payload.size - <span class="hljs-number"><span class="hljs-number">2</span></span>) -&gt; payload[index - <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-number"><span class="hljs-number">4</span></span> + payload.size - <span class="hljs-number"><span class="hljs-number">1</span></span> -&gt; checksumOf(payload) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>.toByte() } }) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateCorruptedPacketB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ByteArray { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rnd = Random() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> payload = byteArrayOf( rnd.nextInt().toByte(), rnd.nextInt().toByte(), rnd.nextInt().toByte(), rnd.nextInt().toByte() ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> byteArrayOf( Event.B.headValue[<span class="hljs-number"><span class="hljs-number">0</span></span>], Event.B.headValue[<span class="hljs-number"><span class="hljs-number">1</span></span>], payload[<span class="hljs-number"><span class="hljs-number">0</span></span>], payload[<span class="hljs-number"><span class="hljs-number">1</span></span>], payload[<span class="hljs-number"><span class="hljs-number">2</span></span>], payload[<span class="hljs-number"><span class="hljs-number">3</span></span>], (checksumOf(payload) + <span class="hljs-number"><span class="hljs-number">1</span></span>.toByte()).toByte() ) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateCorruptedPacketC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ByteArray { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rnd = Random() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> payload = List(rnd.nextInt(<span class="hljs-number"><span class="hljs-number">16</span></span>), { _ -&gt; rnd.nextInt().toByte() }).toByteArray() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ByteArray(<span class="hljs-number"><span class="hljs-number">4</span></span> + payload.size, { index -&gt; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(index) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; Event.C.headValue[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-number"><span class="hljs-number">1</span></span> -&gt; Event.C.headValue[<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-number"><span class="hljs-number">2</span></span> -&gt; payload.size.toByte() <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>..(<span class="hljs-number"><span class="hljs-number">4</span></span> + payload.size - <span class="hljs-number"><span class="hljs-number">2</span></span>) -&gt; payload[index - <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; (checksumOf(payload) + <span class="hljs-number"><span class="hljs-number">1</span></span>.toByte()).toByte() } }) }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Unpretentious cheksumma used for testing</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checksumOf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ByteArray</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Byte</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-number"><span class="hljs-number">0x00</span></span>.toByte() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { result = (result + b).toByte() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (result.inv() + <span class="hljs-number"><span class="hljs-number">1</span></span>.toByte()).toByte() }</code> </pre> </div></div><br><h3 id="i-zachem-vse-eto-bylo-nuzhno">  And why was all this necessary? </h3><br><p>  In this example, I would like to show how easy and easy it is to maintain modularity when processing almost arbitrary events, by the way, not necessarily coming from a Bluetooth source (there hasn't been any Bluetooth-dependent code yet), while avoiding possible damage communication packets and noise. </p><br><h3 id="i-chto-dalshe">  So, what is next? </h3><br><p>  Let's make a small wrapper on RxBluetooth, which will allow us to work in a reactive style with various connections while listening to different sets of events. </p><br><p>  All code can be divided into three sets of components: two services and one repository. <br>  Our services will provide us with connection and work with connection data, respectively, and the repository will provide an abstraction for working with specific connections and act as implicit flyweight connections. </p><br><p>  Interfaces will be approximately as follows: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConnectivityService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">UUID</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;DataService&gt; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Flowable&lt;Event&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ByteArray</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataRepository</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(serviceUUID: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">UUID</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Flowable&lt;Event&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(serviceUUID: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">UUID</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ByteArray</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Flowable&lt;<span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> }</code> </pre> <br><p>  And, accordingly, the implementation under the cut </p><br><div class="spoiler">  <b class="spoiler_title">ConnectivityServiceImpl</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConnectivityServiceImpl</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bluetooth: RxBluetooth, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> events: EventMatchersAdapter, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> timeoutSeconds: <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span> = <span class="hljs-number"><span class="hljs-number">15L</span></span>): ConnectivityService { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">UUID</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;DataService&gt; = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(bluetooth.isBluetoothEnabled &amp;&amp; bluetooth.isBluetoothAvailable) { <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; Observable.empty() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; { ensureBluetoothNotDiscovering() bluetooth.startDiscovery() bluetooth.observeDevices() .filter { device -&gt; device.uuids.contains(ParcelUuid(service)) } .timeout(timeoutSeconds, TimeUnit.SECONDS) .take(<span class="hljs-number"><span class="hljs-number">1</span></span>) .doOnNext { _ -&gt; ensureBluetoothNotDiscovering() } .doOnError { _ -&gt; ensureBluetoothNotDiscovering() } .doOnComplete { -&gt; ensureBluetoothNotDiscovering() } .flatMap { device -&gt; bluetooth.observeConnectDevice(device, service) } .map { connection -&gt; DataServiceImpl(BluetoothConnection(connection), events) } } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ensureBluetoothNotDiscovering</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(bluetooth.isDiscovering) { bluetooth.cancelDiscovery() } } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">DataServiceImpl</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataServiceImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> connection: BluetoothConnection, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> adapter: EventMatchersAdapter): DataService { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Flowable&lt;Event&gt; = Flowable.create&lt;Event&gt;({ emitter -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> underlying = EventsBridge(adapter = adapter, emitter = emitter) emitter.setDisposable(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>: MainThreadDisposable() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDispose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!underlying.isDisposed) { underlying.dispose() } } }) connection.observeByteStream().subscribe(underlying) }, BackpressureStrategy.BUFFER) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ByteArray</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = connection.send(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = connection.closeConnection() }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">DataRepositoryImpl</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataRepositoryImpl</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> connectivity: ConnectivityService): DataRepository { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> services = ConcurrentHashMap&lt;UUID, DataService&gt;() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(serviceUUID: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">UUID</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Flowable&lt;Event&gt; = serviceOf(serviceUUID) .flatMap { service -&gt; service.sub() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(serviceUUID: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">UUID</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ByteArray</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Flowable&lt;<span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>&gt; = serviceOf(serviceUUID) .map { service -&gt; service.write(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>((_, service) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> services) { service.dispose() } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serviceOf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(serviceUUID: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">UUID</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Flowable&lt;DataService&gt; = with(services[serviceUUID]) { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { <span class="hljs-literal"><span class="hljs-literal">null</span></span> -&gt; connectivity.sub(serviceUUID).doOnNext { service -&gt; services.put(serviceUUID, service) }.toFlowable(BackpressureStrategy.BUFFER) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; Flowable.just(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } } }</code> </pre> </div></div><br><p>  And so, in the minimum number of lines, we are able to do what was usually stretched into eerie call chains, or callback hells, like this: </p><br><pre> <code class="hljs cs">repository.sub(UUID.randomUUID()) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe { <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> -&gt; when(<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Event.A -&gt; doSomeStuffA(<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Event.B -&gt; doSomeStuffB(<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Event.C -&gt; doSomeStuffC(<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Event.D -&gt; doSomeStuffD(<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>) } }</code> </pre> <br><p>  11 lines for listening to four events from an arbitrary device, not bad, is not it?) </p><br><h3 id="vmesto-zaklyucheniya">  Instead of conclusion </h3><br><p>  If someone from the reader has a desire to look at the source code - they <a href="https://gist.github.com/komigor/466fcdf7c30160e7cfea26d4ce21dd84">are here</a> . </p><br><p>  If someone wants to see how other rules fit into the formation of packets of raw bytes - write, try to add. </p><br><p>  UPD: designed in a <a href="https://github.com/komigor/RxBinary">micro framework</a> with optsinalnyh bridges in ReactiveX, Korutiny, as well as a clean implementation on Kotlin. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/348190/">https://habr.com/ru/post/348190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348174/index.html">Implementing a simple pixel game in the Ethereum blockchain</a></li>
<li><a href="../348176/index.html">Automate when you can, program when necessary</a></li>
<li><a href="../348182/index.html">Testing the performance of hyperconvergent systems and SDS do it yourself</a></li>
<li><a href="../348184/index.html">Wine 3.0 and many goodies</a></li>
<li><a href="../348188/index.html">Introduction to Data Vault</a></li>
<li><a href="../348192/index.html">Software sound synthesis on early personal computers. Part 2</a></li>
<li><a href="../348194/index.html">Making multicolored icons using SVG symbols and CSS variables</a></li>
<li><a href="../348196/index.html">Track user actions with CSS</a></li>
<li><a href="../348198/index.html">Understanding lvalue and rvalue in C and C ++</a></li>
<li><a href="../348200/index.html">Sean Pierce: A Real Leader</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>