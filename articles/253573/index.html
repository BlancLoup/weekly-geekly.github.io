<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Understanding the download of ArchLinux over the network</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article, we prepared a basic system. Finish the setting in the next article . 

 Here we will create a new Arch Linux system capable o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Understanding the download of ArchLinux over the network</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/post/253256/">previous article,</a> we prepared a basic system.  Finish the setting in the <a href="http://habrahabr.ru/post/254415/">next article</a> . <br><br>  Here we will create a new Arch Linux system capable of booting over the network and automatically launching the Firefox browser, and in between cases we will deal with the necessary functionality of the boot server.  Then we configure the server itself and try to boot from it.  Everything will happen exactly as in the picture that Google found on the query "PXE": <br><img src="https://habrastorage.org/files/d01/7d4/5c8/d017d45c8fa84b22929222d40306129b.png"><br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Install Linux again </h2><br><br>  Archlinux compares favorably with the ready-made distributions in that the installation of the new system from the working machine is the same as when using the installation image, and in both cases you get the most current version of the system at the moment.  Only small installation scripts will be needed: <br><pre><code class="bash hljs">pacman -S arch-install-scripts</code> </pre> <br><br>  Absolutely predictable start: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> root=/srv/nfs/diskless mkdir -p <span class="hljs-variable"><span class="hljs-variable">$root</span></span></code> </pre> <br><br>  Install only the base packages, therefore: <br><pre> <code class="bash hljs">pacstrap -d -c -i <span class="hljs-variable"><span class="hljs-variable">$root</span></span> base</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Note:</b> <div class="spoiler_text">  ‚ÄúWe strive to minimize the capacity of the installed system, because the network performance is much lower than the performance of the slowest hard drive!‚Äù I had to write in this place, but I know that the volume can be reduced even more if you select specific packages from base package groups.  I propose to do it yourself. </div></div><br><br>  Then repeat all the steps until installing the bootloader according to the <a href="http://habrahabr.ru/post/253256/">previous article</a> .  Here is the checklist: <br><ul><li>  carry out russification (internationalization); </li><li>  specify the time zone and configure the autorun service NTP; </li><li>  Add username and block his password from being changed. </li></ul><br><br><h3>  Compare boot from disk and boot from network </h3><br><br>  In the <a href="http://habrahabr.ru/post/253256/">previous article,</a> we looked at the Linux boot process from the point of view of internal storage.  Now we present what is happening through the eyes of a network card.  The picture from the title illustrates events well, except that all servers in our case will work on the same computer. <br><br>  Immediately after turning on the computer, the PXE code (Preboot eXecution Environment, pronounced pixie - thanks to the <a href="https://ru.wikipedia.org/wiki/PXE">wiki</a> ), located directly in the network card's ROM, is triggered.  His task is to find the loader and transfer control to it. <br><div class="spoiler">  <b class="spoiler_title">Note:</b> <div class="spoiler_text">  Hereinafter, the possibilities of a network card, which is built into almost any commercially available motherboard, are considered (albeit, among some, equipped with the Socket 775, there were inferior instances).  If the corresponding PXE item is not in the list of bootable devices BIOS, then try to enable it in the integrated devices section among the settings of the network card.  If nothing helps, then read the instructions from your motherboard, and make sure that it is suitable for further experiments. </div></div><br><br>  The network adapter is completely unaware of which network it is currently in, therefore it assigns itself the address 0.0.0.0 and sends a DHCPDISCOVER message.  <s>Passport</s> data will be attached to the message, which will definitely be useful to us: <br><ul><li>  ARCH Option 93 - PXE client <a href="http://tools.ietf.org/html/rfc4578">architecture</a> (UEFI, BIOS); </li><li>  Vendor-Class Option 60 is an identifier that for all PXE clients has the form ‚ÄúPXEClient: Arch: xxxxx: UNDI: yyyzzz‚Äù, where the numbers xxxxx are the client architecture, yyyzzz is the major and minor versions of the UNDI (Universal Network Driver Interface) driver. <br></li></ul><br><br>  The adapter expects to receive a response from the <a href="https://ru.wikipedia.org/wiki/DHCP">DHCP server</a> via BOOTP ( <a href="https://ru.wikipedia.org/wiki/Bootstrap_Protocol">Bootstrap Protocol</a> ), where in addition to the required IP address, subnet mask and gateway address, there is information about the <a href="https://ru.wikipedia.org/wiki/TFTP">TFTP server</a> address and the name of the bootloader file that should be taken from it.  The TFTP server, in turn, simply gives anyone who wants it any files that they ask for. <br><br>  After receiving the answer and applying the network settings, further control of the download is transferred to the resulting file, the size of which can not exceed 32 KB, so two-step download is used.  Everything needed to display the boot menu on the screen is downloaded by the same TFTP protocol.  The vast majority of network boot tutorials use the pxelinux bootloader, but GRUB does the same thing, and even more: it has different boot loaders for different architectures, including UEFI. <br><br>  Further, the download is suspended while the boot menu is displayed, and then the selected vmlinuz and initramfs files are downloaded via the same TFTP protocol, to which further download control is transferred.  At this stage, there is no longer any difference at all in the boot mechanism over the network or from the internal drive. <br><br><h3>  Configuring network boot with GRUB </h3><br><br>  Since there is already a GRUB on our server, we will create a folder structure for the network client using this method: <br><br><pre> <code class="bash hljs">grub-mknetdir --net-directory=<span class="hljs-variable"><span class="hljs-variable">$root</span></span>/boot --subdir=grub</code> </pre> <br><br>  The grub folder and several others will appear in the $ root / boot folder.  We will completely ‚Äúgive away‚Äù this file structure using a TFTP server.  Now we are using 64-bit ArchLinux for the reason that in a 32-bit system there is no folder / grub / x86_64-efi /, which is required for booting UEFI systems.  You can take this folder from our 64-bit server and transfer it unchanged to a 32-bit server, then UEFI support will also appear in it. <br><br>  Create a bootloader configuration file with the following contents: <br><div class="spoiler">  <b class="spoiler_title">cat $ root / boot / grub / grub.cfg</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> load_video { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ x<span class="hljs-variable"><span class="hljs-variable">$feature_all_video_module</span></span> = xy ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> insmod all_video <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> insmod efi_gop insmod efi_uga insmod ieee1275_fb insmod vbe insmod vga insmod video_bochs insmod video_cirrus <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ x<span class="hljs-variable"><span class="hljs-variable">$feature_default_font_path</span></span> = xy ] ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> font=unicode <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> font=<span class="hljs-string"><span class="hljs-string">"fonts/unicode.pf2"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> loadfont <span class="hljs-variable"><span class="hljs-variable">$font</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> gfxmode=auto load_video insmod gfxterm <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> locale_dir=locale <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> lang=ru_RU insmod gettext <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> terminal_input console terminal_output gfxterm <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> timeout=5 <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> default=0 menuentry <span class="hljs-string"><span class="hljs-string">" Firefox"</span></span> { load_video <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> gfxpayload=keep insmod gzio <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">" ..."</span></span> linux /vmlinuz-linux \ add_efi_memmap \ ip=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$net_default_ip</span></span></span><span class="hljs-string">"</span></span>:<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$net_default_server</span></span></span><span class="hljs-string">"</span></span>:192.168.1.1:255.255.255.0::eth0:none \ nfsroot=<span class="hljs-variable"><span class="hljs-variable">${net_default_server}</span></span>:/diskless <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"   ..."</span></span> initrd /initramfs-linux.img }</code> </pre> <br></div></div><br><br>  I took the grub.cfg file from the server and removed from it everything that does not participate in the display of the GRUB boot menu or is somehow related to disks. <br><br>  Pay attention to the familiar line with the kernel parameters: <br><pre> <code class="bash hljs">linux /vmlinuz-linux add_efi_memmap ip=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$net_default_ip</span></span></span><span class="hljs-string">"</span></span>:<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$net_default_server</span></span></span><span class="hljs-string">"</span></span>:192.168.1.1:255.255.255.0::eth0:none nfsroot=<span class="hljs-variable"><span class="hljs-variable">${net_default_server}</span></span>:/diskless</code> </pre> <br>  As in the <a href="http://habrahabr.ru/post/253256/">previous time,</a> assign the value of the variable "ip".  I remind you that it is used in the ‚Äúnet‚Äù handler, which we adapted to configure the network card in the boot server.  Here again the static IP address and the constant name of the eth0 network card are indicated.  The values ‚Äã‚Äãof $ net_default_ip and $ net_default_server are substituted by GRUB independently based on the data received from the very first DHCP request.  $ net_default_ip is the IP address allocated for our machine, and $ net_default_server is the IP address of the boot server. <br><br>  Most network boot guides (among those found in the Runet), suggest setting a variable like ‚Äúip = ::::: eth0: dhcp‚Äù, which forces the net handler to send a new DHCPDISCOVER request to get the network settings again. <br><br>  There is no objective reason to ‚Äúspam‚Äù the DHCP server once again and wait for it to respond, so again we use static and do not forget to specify the DNS servers.  We have already solved this problem, so we simply copy the necessary files and add the service to autoload: <br><pre> <code class="bash hljs">cp {,<span class="hljs-variable"><span class="hljs-variable">$root</span></span>}/etc/systemd/system/update_dns@.service &amp;&amp; cp {,<span class="hljs-variable"><span class="hljs-variable">$root</span></span>}/etc/default/dns@eth0 &amp;&amp; arch-chroot <span class="hljs-variable"><span class="hljs-variable">$root</span></span> systemctl <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> update_dns@eth0</code> </pre> <br><br>  We return to the line with the kernel parameters.  Still unfamiliar to us, the add_efi_memmap (EFI memory map) command <a href="https://www.kernel.org/doc/Documentation/x86/x86_64/uefi.txt">adds an EFI memory map of available RAM</a> .  Last time, we intentionally missed it, due to the relatively difficult preliminary layout of the media to support UEFI.  Now we do not need to mark up, because the file system on the boot server already exists and will be used unchanged. <br><br>  The kernel variable, nfsroot, shows where exactly the network should look for the root file system.  It performs the same function as the root variable in the boot server.  In this case, the address of the <a href="https://ru.wikipedia.org/wiki/Network_File_System">NFS server</a> is specified, which in our case coincides with the TFTP server, but this is completely optional. <br><br><h3>  Prepare initramfs </h3><br><br>  Handler net is responsible for connecting the root file system using the NFS protocol.  Last time we removed this functionality from it, but now we will need it, but in a slightly modified form.  The fact is that the net handler out of the box only supports connection via the NFS protocol of version 3. Fortunately, support for version 4 is added very simply. <br><br>  First, install the package, which includes the net handler we need, as well as the utility package for working with NFS (the nfsv4 module and the mount.nfs4 program): <br><br><pre> <code class="bash hljs">pacman --root <span class="hljs-variable"><span class="hljs-variable">$root</span></span> --dbpath <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/var/lib/pacman -S mkinitcpio-nfs-utils nfs-utils</code> </pre> <br><br>  Fix the net handler from the hooks folder (instead of the command to mount nfsmount, now we will use mount.nfs4): <br><pre> <code class="bash hljs">sed s/nfsmount/mount.nfs4/ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$root</span></span></span><span class="hljs-string">/usr/lib/initcpio/hooks/net"</span></span> &gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$root</span></span></span><span class="hljs-string">/etc/initcpio/hooks/net_nfs4"</span></span></code> </pre> <br>  Using the install handler installer, add the nfsv4 module and the mount.nfsv4 program to iniramfs.  First, copy and rename the workpiece: <br><pre> <code class="bash hljs">cp <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/usr/lib/initcpio/install/net <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/initcpio/install/net_nfs4</code> </pre> <br>  Now we fix only one build () function, and do not touch the rest: <br><pre> <code class="bash hljs">nano <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/initcpio/install/net_nfs4 <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span></span>() { add_checked_modules <span class="hljs-string"><span class="hljs-string">'/drivers/net/'</span></span> add_module nfsv4? add_binary <span class="hljs-string"><span class="hljs-string">"/usr/lib/initcpio/ipconfig"</span></span> <span class="hljs-string"><span class="hljs-string">"/bin/ipconfig"</span></span> add_binary <span class="hljs-string"><span class="hljs-string">"/usr/bin/mount.nfs4"</span></span> <span class="hljs-string"><span class="hljs-string">"/bin/mount.nfs4"</span></span> add_runscript }</code> </pre> <br><br>  Add the handler to the initramfs by correcting the line in the mkinitcpio.conf file: <br><pre> <code class="bash hljs">nano <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/mkinitcpio.conf HOOKS=<span class="hljs-string"><span class="hljs-string">"base udev net_nfs4"</span></span></code> </pre> <br><br>  If you don‚Äôt touch anything, then usually a fast gzip archiver is used to compress the initramfs file.  We are not in such a hurry, as far as we want compression stronger, therefore we will use xz.  We remove the comment from this line in the mkinitcpio.conf file: <br><pre> <code class="bash hljs">COMPRESSION=<span class="hljs-string"><span class="hljs-string">"xz"</span></span></code> </pre> <br><br>  Xz archiving takes much longer, but the initramfs file is reduced at least a couple of times, which is why it is transmitted much faster by the TFTP server over the network.  We copy the preset from our server so that in the course of work only one initramfs file is generated, then we start mkinitcpio: <br><br><pre> <code class="bash hljs">cp /etc/mkinitcpio.d/habr.preset <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/mkinitcpio.d/habr.preset &amp;&amp; arch-chroot <span class="hljs-variable"><span class="hljs-variable">$root</span></span> mkinitcpio -p habr</code> </pre> <br><br>  Finally, edit fstab.  Here you can choose the options for mounting the root file system to optimize its work, but we will not touch anything: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"192.168.1.100:/diskless / nfs defaults 0 0"</span></span> &gt;&gt; <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/fstab</code> </pre> <br><br>  The basic installation of the client system is over.  But we want to add a graphical environment and automatic launch of Firefox. <br><br><h3>  Download Firefox </h3><br><br>  To reduce the amount of memory occupied by our system, we abandon the use of the <a href="https://wiki.archlinux.org/index.php/Display_manager">screen manager</a> and focus on the simplest <a href="https://wiki.archlinux.org/index.php/Window_manager">window manager</a> , for example, <a href="http://openbox.org/wiki/Main_Page">openbox</a> with automatic user authorization username.  The use of "lightweight" components will allow the system to run wonderfully and work even on the most ancient hardware. <br><br>  Install the modules to support VirtualBox, server X, nice TTF font, openbox and firefox (all other modules will be installed as dependencies): <br><pre> <code class="bash hljs">pacman --root <span class="hljs-variable"><span class="hljs-variable">$root</span></span> --dbpath <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/var/lib/pacman -S virtualbox-guest-modules virtualbox-guest-utils xorg-xinit ttf-dejavu openbox firefox</code> </pre> <br><br>  Enable autoloading of the virtualbox service: <br><pre> <code class="bash hljs">arch-chroot <span class="hljs-variable"><span class="hljs-variable">$root</span></span> systemctl <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> vboxservice</code> </pre> <br><br>  Add an automatic login username without entering a password, for this we change the launch line agetty: <br><pre> <code class="bash hljs">mkdir <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/systemd/system/getty@tty1.service.d &amp;&amp; \ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -e <span class="hljs-string"><span class="hljs-string">"[Service]\nExecStart=\nExecStart=-/usr/bin/agetty --autologin username --noclear %I 38400 linux Type=simple %I"</span></span> &gt; <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/systemd/system/getty@tty1.service.d/autologin.conf</code> </pre> <br><br>  Immediately after the user is authorized, the file ~ / .bash_profile is executed, from his home folder, where we add the automatic launch of the graphic server: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'[[ -z $DISPLAY &amp;&amp; $XDG_VTNR -eq 1 ]] &amp;&amp; exec startx &amp;&gt; /dev/null'</span></span> &gt;&gt; <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/home/username/.bash_profile</code> </pre> <br><br>  After the launch of the X server, the openbox should start: <br><pre> <code class="bash hljs">cp <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/X11/xinit/xinitrc <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/home/username/.xinitrc &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'exec openbox-session'</span></span> &gt;&gt; <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/home/username/.xinitrc</code> </pre> <br>  Comment out the following lines at the very end of the file (from the twm line to the line we added to start openbox, but not including it): <br><pre> <code class="bash hljs">cat <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/home/username/.xinitrc <span class="hljs-comment"><span class="hljs-comment"># twm &amp; # xclock -geometry 50x50-1+1 &amp; # xterm -geometry 80x50+494+51 &amp; # xterm -geometry 80x20+494-0 &amp; # exec xterm -geometry 80x66+0+0 -name login exec openbox-session</span></span></code> </pre> <br><br>  Copy openbox configuration files <br><pre> <code class="bash hljs">mkdir -p <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/home/username/.config/openbox &amp;&amp; cp -R <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/xdg/openbox/* <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/home/username/.config/openbox</code> </pre> <br><br>  Add firefox to autoload in openbox environment: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -e <span class="hljs-string"><span class="hljs-string">'exec firefox habrahabr.ru/post/253573/'</span></span> &gt;&gt; <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/home/username/.config/openbox/autostart</code> </pre> <br><br>  Since we were just hosted on behalf of the superuser in the home folder of the user username, we need to return the rights to all the files located in his folder: <br><pre> <code class="bash hljs">chown -R username <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/home/username</code> </pre> <br><br>  Preparing the system for booting over the network is finished, and it is time to move on to setting up the boot server.  Now we know that for loading we will need: <br><ul><li>  DHCP server with support for BOOTP to configure the network card; </li><li>  TFTP server for transferring the bootloader and the vmlinuz and initramfs files, which we have in the $ root / boot / grub folder; </li><li>  NFS-server to host the root file system, which lies in our $ root folder. </li></ul><br><br><h2>  Configuring the boot server </h2><br><br>  Further steps with minor changes repeat <a href="https://wiki.archlinux.org/index.php/Diskless_system">this article from the wiki</a> , so there is a minimum of comments on my part. <br><br><h3>  Installing a DHCP server </h3><br>  Download the package: <br><pre> <code class="bash hljs">pacman -S dhcp</code> </pre> <br>  and bring the contents of the configuration file /etc/dhcpd.conf to the following form: <br><pre> <code class="bash hljs">mv /etc/dhcpd.conf /etc/dhcpd.conf.old</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">nano /etc/dhcpd.conf</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#    BOOTP allow booting; allow bootp; # ,     (    ,  BOOTP  ,   PXE   ) authoritative; #    (  ) option architecture code 93 = unsigned integer 16; #     (  ) subnet 192.168.1.0 netmask 255.255.255.0 { #      ,    class "pxe_client" { match if exists architecture; } pool { #     : if option architecture = 7 { filename "/grub/x86_64-efi/core.efi"; } else { filename "/grub/i386-pc/core.0"; } #    TFTP ,   ,   ,    ,  DHCP next-server 192.168.1.100; # ,   (    ) default-lease-time 600; max-lease-time 7200; option domain-name-servers 192.168.1.1; option routers 192.168.1.1; range 192.168.1.128 192.168.1.192; #    ,   allow members of "pxe_client"; } }</span></span></code> </pre> <br></div></div><br><br>  As you can see, the DHCP server will respond only to those DHCPDISCOVER requests that come from PXE clients, and the rest will simply be ignored. <br><br>  We start the DHCP server: <br><pre> <code class="bash hljs">systemctl start dhcpd4</code> </pre> <br><br><h3>  Install TFTP server </h3><br>  Download and install the necessary package: <br><pre> <code class="bash hljs">pacman -S tftp-hpa</code> </pre> <br>  We need the TFTP server to provide access to the bootloader files that we placed in the $ root / boot folder.  To do this, we modify the launch of the service in a proven way: <br><pre> <code class="bash hljs">mkdir -p /etc/systemd/system/tftpd.service.d &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -e <span class="hljs-string"><span class="hljs-string">'[Service]\nExecStart=\nExecStart=/usr/bin/in.tftpd -s /srv/nfs/diskless/boot'</span></span> &gt; /etc/systemd/system/tftpd.service.d/directory.conf</code> </pre> <br>  The first line, ‚ÄúExecStart =,‚Äù cancels the execution of the command specified in the original $ root / usr / lib / systemd / system / tftpd.service file, and instead executes "/usr/bin/in.tftpd -s / srv / nfs / diskless / boot ".  Only in the case when the service starts only once (Type = oneshot), can we use several lines of ExecStart = to execute commands one by one.  This is not the case, so we cancel one command and execute another. <br><br>  We start the TFTP server: <br><pre> <code class="bash hljs">systemctl start tftpd.socket tftpd.service</code> </pre> <br><br><h3>  Install NFS server </h3><br><br>  Download the package: <br><pre> <code class="bash hljs">pacman -S nfs-utils</code> </pre> <br>  Add the folder in which we installed the system to the list of exported: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -e <span class="hljs-string"><span class="hljs-string">"/srv/nfs 192.168.1.0/24(rw,fsid=root,no_subtree_check,no_root_squash)\n</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$root</span></span></span><span class="hljs-string"> 192.168.1.0/24(rw,no_subtree_check,no_root_squash)"</span></span> &gt;&gt; /etc/exports</code> </pre> <br>  Do not forget to use the NFS v.4 syntax specifying the path relative to the folder with fsid = root (root relative to all other exported folders, without specifying which nothing will work). <br><br>  We start the services providing work of the NFS server: <br><pre> <code class="bash hljs">systemctl start rpcbind nfs-server</code> </pre> <br><br>  On this boot server is ready to work. <br><br><h2>  We try to boot from the network </h2><br><br>  We will follow the boot process from the server using the tcpdump program. <br><pre> <code class="bash hljs">pacman -S tcpdump tcpdump -v <span class="hljs-string"><span class="hljs-string">'( \ src host 0.0.0.0 and udp[247:4] = 0x63350101) or ( \ dst host HabraBoot and dst port tftp) or ( \ dst host HabraBoot and tcp[tcpflags] == tcp-syn)'</span></span></code> </pre> <br><br>  The first line "catches" the DHCPDISCOVER request from the PXE client.  In the output filtered by the second line, the names of all files requested by TFTP will be listed.  The third line shows two tcp-syn requests sent at the very beginning of the NFS connection (the first connection is made by the net handler, and the second reconnection occurs during the processing of the fstab file). <br><br>  Create a new virtual machine, for brevity, we will call it "client".  In the network settings, we again specify the ‚ÄúNetwork Bridge‚Äù connection type and turn on the machine.  Immediately press the F12 key on the keyboard to select the boot device, and then the l key to boot over the network. <br><br>  Wait until the download is complete.  If everything is in order, then on the server we add the used services to the autoload: <br><br><pre> <code class="bash hljs">systemctl <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> tftpd.socket tftpd.service dhcpd4 rpcbind nfs-server</code> </pre> <br><br>  All servers DHCP, TFTP and NFS we launched on one boot server.  Doing so is optional.  For example, Mikrotik routers support Bootp and allow you to use yourself as TFTP - just upload all the necessary files there and check the network settings. <br><br>  Now the graphical environment will only work in VirtualBox, because we did not install drivers for the "iron" video cards.  We will solve the problem of automatically selecting the necessary drivers in the <a href="http://habrahabr.ru/post/254415/">next article</a> .  At the same time, we will speed up the loading of the system and make it a ‚Äúlive image‚Äù. </div><p>Source: <a href="https://habr.com/ru/post/253573/">https://habr.com/ru/post/253573/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../253561/index.html">We start PHPUnit tests for the project on 1C-Bitrix</a></li>
<li><a href="../253563/index.html">How do we build a magical SSD hosting in the Netherlands and the USA with new principles of charging and working, is it really magic?</a></li>
<li><a href="../253567/index.html">City Wi-Fi on the example of Moscow University dormitories</a></li>
<li><a href="../253569/index.html">K-Meleon Welcomes Habrazhiteley</a></li>
<li><a href="../253571/index.html">Online conference for Java developers DEV Labs 2015</a></li>
<li><a href="../253575/index.html">Lesson 1.1 - Actors and ActorSystem</a></li>
<li><a href="../253579/index.html">We write client for Slack with notifications</a></li>
<li><a href="../253583/index.html">Web Components and JSON-LD to help the web developer</a></li>
<li><a href="../253585/index.html">Making web forms easier to fill out</a></li>
<li><a href="../253587/index.html">Backend and Golden Hammers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>