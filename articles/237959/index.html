<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>[Translation] The problem of JavaScript constructors and three ways to solve it</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 As you know, you can create a new object in JavaScript using the following constructor function: 



function Fubar (foo, bar) { this._...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>[Translation] The problem of JavaScript constructors and three ways to solve it</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  As you know, you can create a new object in JavaScript using the following constructor function: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fubar</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo, bar</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._foo = foo; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._bar = bar; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> snafu = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Fubar(<span class="hljs-string"><span class="hljs-string">"Situation Normal"</span></span>, <span class="hljs-string"><span class="hljs-string">"All Fsked Up"</span></span>);</code> </pre> <br><br>  When we call a constructor function using the <code>new</code> keyword, we get a new object, and the context of its constructor is set on the object itself.  If we explicitly do not return anything from the constructor, then we get the object itself as a result.  Thus, the body of the constructor function is used to initialize the newly created object, the prototype of which is the contents of the <code>prototype</code> property of the constructor, so you can write as follows: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="javascript hljs">Fubar.prototype.concatenated = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._foo + <span class="hljs-string"><span class="hljs-string">" "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._bar; } snafu.concatenated() <span class="hljs-comment"><span class="hljs-comment">//=&gt; 'Situation Normal All Fsked Up'</span></span></code> </pre><br><br>  Using the <code>instanceof</code> operator, you can verify that the object was created using a specific constructor: <br><br><pre> <code class="javascript hljs">snafu <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Fubar <span class="hljs-comment"><span class="hljs-comment">//=&gt; true</span></span></code> </pre><br><br>  (It is possible to make <code>instanceof</code> ‚Äúwrong‚Äù possible in cases with more advanced idioms, or if you are a harmful troll collecting exception programming language and enjoying it, torturing job seekers with them. However, for our purposes, <code>instanceof</code> works quite well.) <br><a name="habracut"></a><br><h4>  Problem </h4><br>  What happens if we call the constructor by accidentally missing the <code>new</code> keyword? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fubar = Fubar(<span class="hljs-string"><span class="hljs-string">"Fsked Up"</span></span>, <span class="hljs-string"><span class="hljs-string">"Beyond All Recognition"</span></span>); fubar <span class="hljs-comment"><span class="hljs-comment">//=&gt; undefined</span></span></code> </pre><br><br>  Charles-Sigmund-Juan !?  We called a regular function that returns nothing, so <code>fubar</code> will be undefined.  This is not what we need, even worse, because: <br><br><pre> <code class="javascript hljs">_foo <span class="hljs-comment"><span class="hljs-comment">//=&gt; 'Fsked Up'</span></span></code> </pre><br><br>  JavaScript sets the context to the global scope to perform a normal function, so we just got there to trash.  Well, it can somehow be corrected: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fubar</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo, bar</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-string"><span class="hljs-string">"use strict"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._foo = foo; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._bar = bar; } Fubar(<span class="hljs-string"><span class="hljs-string">"Situation Normal"</span></span>, <span class="hljs-string"><span class="hljs-string">"All Fsked Up"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//=&gt; TypeError: Cannot set property '_foo' of undefined</span></span></code> </pre><br><br>  Although the use of ‚Äúuse strict‚Äù is often omitted in the code and in the books, in production it can be called almost mandatory due to cases like the one described above.  However, constructors that do not provide the ability to call themselves without the <code>new</code> keyword are a potential problem. <br><br>  So what can we do about it? <br><br><h4>  Solution # 1 - auto-inheritance </h4><br>  David Herman explains auto-inheritance in his book <a href="http://effectivejs.com/">Effective JavaScript</a> .  When we call the constructor with <code>new</code> , the pseudo-variable <code>this</code> points to a new instance of our so-called ‚Äúclass‚Äù.  This can be used to determine whether the constructor was called with the code word <code>new</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fubar</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo, bar</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-string"><span class="hljs-string">"use strict"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj, ret; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Fubar) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._foo = foo; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._bar = bar; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Fubar(foo, bar); } Fubar(<span class="hljs-string"><span class="hljs-string">"Situation Normal"</span></span>, <span class="hljs-string"><span class="hljs-string">"All Fsked Up"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//=&gt; { _foo: 'Situation Normal', _bar: 'All Fsked Up' }</span></span></code> </pre><br><br>  Why make it work without <code>new</code> ?  One of the problems that this approach solves is the impossibility of calling <code>new Fubar(...)</code> .  Consider an example: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logsArguments</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> logsSum = logsArguments(sum2); logsSum(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">//=&gt; 2 2 4</span></span></code> </pre><br><br>  <code>logsArguments</code> decorates the function that logs its arguments, returning the result of its call.  Let's try to do the same with <code>Fubar</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fubar</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo, bar</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._foo = foo; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._bar = bar; } Fubar.prototype.concatenated = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._foo + <span class="hljs-string"><span class="hljs-string">" "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._bar; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> LoggingFubar = logsArguments(Fubar); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> snafu = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LoggingFubar(<span class="hljs-string"><span class="hljs-string">"Situation Normal"</span></span>, <span class="hljs-string"><span class="hljs-string">"All Fsked Up"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//=&gt; Situation Normal All Fsked Up snafu.concatenated() //=&gt; TypeError: Object [object Object] has no method 'concatenated'</span></span></code> </pre><br><br>  This does not work, because <code>snafu</code> is an instance of <code>LoggingFubar</code> , not <code>Fubar</code> .  But if you use auto-inheritance in <code>Fubar</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fubar</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo, bar</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-string"><span class="hljs-string">"use strict"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj, ret; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Fubar) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._foo = foo; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._bar = bar; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Fubar(); ret = Fubar.apply(obj, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> ? obj : ret; } } Fubar.prototype.concatenated = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._foo + <span class="hljs-string"><span class="hljs-string">" "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._bar; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> LoggingFubar = logsArguments(Fubar); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> snafu = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LoggingFubar(<span class="hljs-string"><span class="hljs-string">"Situation Normal"</span></span>, <span class="hljs-string"><span class="hljs-string">"All Fsked Up"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//=&gt; Situation Normal All Fsked Up snafu.concatenated() //=&gt; 'Situation Normal All Fsked Up'</span></span></code> </pre><br><br>  Now it works, although, of course, <code>snafu</code> is an instance of <code>Fubar</code> , not <code>LoggingFubar</code> .  It is impossible to say for sure whether this is what we wanted.  This method cannot be called a more than useful abstraction, not devoid of leaks, just as one cannot say that it ‚Äújust works‚Äù, although thanks to it some things become possible which are much more difficult to implement with other approaches. <br><br><h4>  Solution # 2 - use overloaded function </h4><br>  A function that checks whether an object is an instance of a particular class can be very useful.  If you are not afraid of the idea that one function can do two different things, then you can make the constructor perform a check on its own <code>instanceof</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fubar</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo, bar</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-string"><span class="hljs-string">"use strict"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Fubar) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._foo = foo; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._bar = bar; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Fubar; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> snafu = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Fubar(<span class="hljs-string"><span class="hljs-string">"Situation Normal"</span></span>, <span class="hljs-string"><span class="hljs-string">"All Fsked Up"</span></span>); snafu <span class="hljs-comment"><span class="hljs-comment">//=&gt; { _foo: 'Situation Normal', _bar: 'All Fsked Up' } Fubar({}) //=&gt; false Fubar(snafu) //=&gt; true</span></span></code> </pre><br><br>  This makes it possible to use the constructor as a filter. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arrayOfSevereProblems = problems.filter(Fubar);</code> </pre><br><br><h4>  Decision number 3 - burn out fire </h4><br>  If there is no urgent need for auto-inheritance, and the use of overloaded functions for some reason does not fit, we may still need a way to avoid accidentally invoking the constructor without using the <code>new</code> keyword.  Let him <br>  <code>"use strict"</code> helps, but this is not a panacea.  In this mode, an error will not be generated if you do not try to write the value to the global scope, and if we try to do something before writing the same value, it will happen no matter what. <br><br>  Could it be much better to take matters into your own hands?  Oliver Scherrer <a href="http://podefr.tumblr.com/post/75666281033/the-auto-instantiating-javascript-constructor-is-an">offers</a> this solution: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fubar</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo, bar</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-string"><span class="hljs-string">"use strict"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Fubar)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Fubar needs to be called with the new keyword"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._foo = foo; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._bar = bar; } Fubar(<span class="hljs-string"><span class="hljs-string">"Situation Normal"</span></span>, <span class="hljs-string"><span class="hljs-string">"All Fsked Up"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//=&gt; Error: Fubar needs to be called with the new keyword</span></span></code> </pre><br><br>  Easier and safer than just relying on <code>"use strict"</code> .  If you need to make a check on your own <code>instanceof</code> , you can wrap it in a constructor as a function method: <br><br><pre> <code class="javascript hljs">Fubar.is = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Fubar; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arrayOfSevereProblems = problems.filter(Fubar.is);</code> </pre><br><br><h4>  Conclusion </h4><br>  Constructors called without the <code>new</code> keyword can pose a potential threat.  This can be avoided in three ways: by auto-inheritance, using overloaded functions and forcibly throwing an error in case of an incorrect call. <br><br>  The original article of the author can be found <a href="http://raganwald.com/2014/07/09/javascript-constructor-problem.html%3Futm_source%3Djavascriptweekly%26utm_medium%3Demail">here</a> . <br><br>  The article is attached to the <a href="http://www.reddit.com/r/javascript/comments/2acr9f/a_javascript_constructor_problem_and_three/">discussion on reddit</a> . </div><p>Source: <a href="https://habr.com/ru/post/237959/">https://habr.com/ru/post/237959/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../237941/index.html">Rust Style C ++ Mutexes</a></li>
<li><a href="../237943/index.html">Juniper ipsec tunnel tracing</a></li>
<li><a href="../237947/index.html">How does the chosen LTE network affect the power consumption of the phone, or the disadvantages of LTE networks in the CIS</a></li>
<li><a href="../237951/index.html">VoIP Zoo - Provisioning</a></li>
<li><a href="../237955/index.html">Router from DAP-1160</a></li>
<li><a href="../237961/index.html">Where to register a domain. Price comparison</a></li>
<li><a href="../237963/index.html">Adaperio means "reveal the truth." The story of creating a startup in two hardcore monologues</a></li>
<li><a href="../237965/index.html">Biocentrism. How life creates the universe</a></li>
<li><a href="../237967/index.html">One dispute lost, or why the Indabus service is invented</a></li>
<li><a href="../237969/index.html">How I tried five payment systems for my site</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>