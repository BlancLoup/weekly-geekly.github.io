<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Containerization on Linux in detail - LXC and OpenVZ Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a continuation of a series begun in publications. Containers are the future of clouds and Containerization on Linux in detail - LXC an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Containerization on Linux in detail - LXC and OpenVZ Part 2</h1><div class="post__text post__text-html js-mediator-article">  This article is a continuation of a series begun in publications. <a href="http://habrahabr.ru/company/FastVPS/blog/208650/">Containers are the future of clouds</a> and <a href="http://habrahabr.ru/company/FastVPS/blog/209072/">Containerization on Linux in detail - LXC and OpenVZ.</a>  <a href="http://habrahabr.ru/company/FastVPS/blog/209072/">Part 1</a> . <br><br>  If you can skip the publication about the future, then the article ‚ÄúPart 1‚Äù will be required to read in order to understand what we are talking about here. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/818/604/13b/81860413b7035bbb8137428b89b8217f.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Technical implementation of the container hardware resource limiting subsystem </h4><br>  For the completeness of the description, we must necessarily touch on the aspect of the delimitation of not only system resources and rights, but also hardware resources. <br><br>  What resources we need to share between users: <br><ul><li>  CPU </li><li>  Hard disk (load on it) </li><li>  Memory (volume) </li></ul><br>  For all such restrictions, the cgroups subsystem is used.  I / O load can be fixed using the blkio cgroups subsystem, and it is important to note that there is both the ability to set hard limits in bytes / second and operations per second (IOPS), and the ability to set weights (i.e., 10 % of the entire server).  Memory is limited by the memory cgroup, everything is pretty simple - we indicate the amount of RAM, if the container exceeds it - the process experiences an OOM message.  For the processor, only the possibility of specifying the load in percent is permissible, which is explained by the peculiarities of the scheduler implementation on Linux. <br><br>  So, to implement the delineation of resource use, we used the following cgroups: <br><ul><li>  cpu </li><li>  memory </li><li>  blkio </li></ul><br><a name="habracut"></a><br><h4>  Common problems when using containers </h4><br>  When I <a href="http://habrahabr.ru/company/FastVPS/blog/208650/">described</a> all the advantages of containers, I deliberately decided not to touch on the shortcomings of containers, since this is a very voluminous topic and a lot of explanations are required. <br><br>  So, let's go: <br><ol><li>  In Linux upstream containers, there are problems with isolation of the / proc file system between containers.  OpenVZ has solved this problem. </li><li>  In Linux upstream containers it is impossible to limit the amount of disk available to the container without using completely separate file systems (which in turn is inconvenient and very inconvenient in support).  As a promising solution to this problem in the future, it is worth noting the functionality of the subvolume of the Btrfs file system, which allows you to create a completely isolated section (with a fixed volume) within one file system. </li><li>  As a client OS, using containerization, only the same OS that is running on a physical server can be used.  This is not a lack of technical context, it is a feature of implementation.  That is, you can run only Linux on a physical Linux machine.  If it is necessary to start another OS, KVM will provide a very good service, which is perfectly supported on both OpenVZ cores and Linux upstream (to its credit, it‚Äôs better there). </li><li>  Less security than full virtualization.  Creating an exploit that from a container will lead to the failure of the hardware node itself is potentially possible.  In the case of using containers from the Linux kernel, the number of ways to disable the hardware server is decidedly higher, as in OpenVZ isolation is much better (due to granular UBC limits, as well as additional checks that are not available in the upstream core). </li><li>  For stable use (but again, we are not talking about production!) Linux upstream containers are ready starting at about 3.8 kernel (ideally, 3.10), while many currently stable kernel distributions are younger and there is no possibility to use all the functionality.  A pretty good option for working with Linux upstream containers is the <a href="https://blogs.oracle.com/linux/entry/announcing_the_unbreakable_enterprise_kernel">kernel from Oracle</a> , it is just version 3.8 and declares the readiness of containers for industrial use. </li><li>  There is no support from the manufacturers of distros, for example, standard means even Fedora 20 cannot be placed inside the container, and in a virtual machine it is possible.  The installation question is a simpler one for Debian and the debootstrap package can easily install the required distribution.  In the case of OpenVZ, the issue is solved using pre-assembled <a href="http://download.openvz.org/template/precreated/">OS images</a> . </li><li>  The problem with management utilities.  Since this is an extremely important point, in my opinion, I decided to dwell on it in more detail and painted it separately at the end of the article. </li><li>  The lack of a built-in solution for limiting the speed of a network connection ‚Äî this problem affects both Linux upstream containers and OpenVZ.  Of course, it is possible to create your own solutions based on tc, but such a useful function simply must be. </li></ol><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c9a/035/952/c9a0359529d477aa7b7ef16a844015db.jpg"><br><br><h4>  The advantages of OpenVZ over standard Linux containerization </h4><br>  We have already discussed that OpenVZ and Linux upstream containers are very similar technologies with similar architecture and implementation, but they have a lot of differences.  Part of the difference is due to the fact that the current version of OpenVZ is supported for the 2.6.32 RHEL kernel.  Stop!  Do you see the same thing as me?  2.6.32 kernel, really?  But please do not be afraid that this kernel is old - this is not so, because Red Hat does a tremendous amount of work on backporting code from new branches and this kernel is functionally very close to 3.x and at the same time extremely far from the standard ‚Äúvanilla‚Äù 2.6. 32. <br><br>  Thus, if we compare the RHEL6 OpenVZ core and the current version of the upstream core (3.12).  The isolation level of processor and disk resources is on the same level, but there are a number of subtleties worth paying attention to, they are lower. <br><br>  What exactly we have in OpenVZ, which is not in the upstream Linux kernel: <br><ol><li>  The vSwap system is used, which allows you to configure overcommit for the container, and also allows you to issue a virtual one (because it performs the deceleration artificially and at a speed of about 100 megabytes / second) SWAP </li><li>  A more accurate calculation of RAM consumed by containers at the expense of more granular UBC counters, you can calculate the occupied memory of the kernel, memory of sockets, allocated memory and really busy, the number of shm pages of memory and much more </li><li>  The ability to account for page cache consumption by each of the containers </li><li>  Storage system with the possibility of limiting the location of the available container, built on the basis of ploop with functionality similar to LVM, with the ability to create snapshots, the ability to increase / decrease in online mode.  This file system in turn provides isolation level at the level of full virtualization systems. </li><li>  Support for live migration from server-to server with zero downtime (loss of 1 ping) and the use of a very efficient algorithm </li></ol><br>  As you can see, almost all the benefits of OpenVZ are focused on the actual operation of the solution, and not on the provision of mechanisms to implement this or that opportunity, as they do in Linux upstream containers. <br><img src="https://habrastorage.org/getpro/habr/post_images/161/e9c/750/161e9c7509429ee827274726402a1bee.jpg"><br><br><h4>  Problem from the user space </h4><br>  Unfortunately, there is no unified way to manage containers.  In OpenVZ, vzctl is used for this, which, by the way, can also manage containers even on a regular <a href="http://openvz.org/Vzctl_for_upstream_kernel">upstream kernel</a> since versions 3.x, and it is also included in the Fedora-20 distribution and can be installed and used without external dependencies.  There are also LXC and docker (which in turn is also based on LXC), but they also do not fully cover all the functionality that container users may need.  In addition, Linux Upstream Containers are used in a very unusual place - in the systemd initialization system used in many distributions, the <a href="http://0pointer.de/public/systemd-man/systemd-nspawn.html">systemd-nspaw functionality</a> . <br><br>  Therefore, the question of implementing a convenient, competent, flexible and well-designed framework for managing containers in Linux is open and you can change the world by writing it (smile) You can also learn a lot about container management utilities from the Linux Plumbers conference 2013 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/785/052/bcb/785052bcbf6d5d37da25c1e6b4e22557.jpg"><br><br><h4>  findings </h4><br>  As we have seen, Linux containerization is developing very actively, in the coming years, we will certainly get full containerization ready for industrial use in the upstream core.  But for industrial use (here I mean using to isolate clients from each other, not from their own services) containers are only ready when using OpenVZ.  But if you need containerization for your own purposes - then Linux upstream containers are an excellent choice, just worry about the latest kernel version. <br><br>  I would also like to thank Andrey Wagin <a href="http://habrahabr.ru/users/avagin/" class="user_link">avagin</a> for his help in editing particularly complex technical issues. <br><br>  Regards, Pavel Odintsov <br>  CTO <a href="http://fastvps.ru/">FastVPS</a> LLC </div><p>Source: <a href="https://habr.com/ru/post/209084/">https://habr.com/ru/post/209084/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../209072/index.html">Containerization on Linux in detail - LXC and OpenVZ. Part 1</a></li>
<li><a href="../209074/index.html">Raising the Thunderbolt Ethernet Adapter on XenServer</a></li>
<li><a href="../209076/index.html">Tasks for the developer Yandex.Music for iOS</a></li>
<li><a href="../209078/index.html">What is Teradata?</a></li>
<li><a href="../209080/index.html">Black Friday. How did it all really</a></li>
<li><a href="../209092/index.html">Microsoft and Adobe released a set of updates, January 2014</a></li>
<li><a href="../209094/index.html">Google Drive has a tape of user activity</a></li>
<li><a href="../209096/index.html">Flexible muscular movement for two-legged creatures</a></li>
<li><a href="../209100/index.html">You and your work *</a></li>
<li><a href="../209102/index.html">Startup alone. My-Wins Story</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>