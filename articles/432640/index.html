<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Release Rust 1.31 and Rust 2018</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The Rust development team is pleased to announce the release of a new version of Rust, 1.31.0, as well as "Rust 2018". Rust is a programming language ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Release Rust 1.31 and Rust 2018</h1><div class="post__text post__text-html js-mediator-article"><p>  The Rust development team is pleased to announce the release of a new version of Rust, 1.31.0, as well as "Rust 2018".  Rust is a programming language that allows everyone to create reliable and efficient software. </p><br><p> If you have a previous version of Rust installed using <code>rustup</code> , then to update Rust to version 1.31.0, you just need to run: </p><br><pre> <code class="bash hljs">$ rustup update stable</code> </pre> <br><p>  If you have not yet installed <code>rustup</code> , you can <a href="https://www.rust-lang.org/tools/install">install it</a> from the corresponding page of our website.  <a href="">Detailed notes for the release of Rust 1.31.0</a> can be found on GitHub. </p><br><h2 id="chto-voshlo-v-stabilnuyu-versiyu-1310">  What is included in the stable version 1.31.0 </h2><br><p>  Rust 1.31, perhaps the most significant release since Rust 1.0!  This release includes the first iteration of the ‚ÄúRust 2018‚Äù, but this is not the only innovation!  The review of improvements will be long, so here's the table of contents: </p><br><ul><li>  <strong>Rust 2018</strong> <br><ul><li>  <strong>Non-lexical lifetimes</strong> </li><li>  <strong>Modifications to the module system</strong> </li></ul></li><li>  <strong>Additional withdrawal rules</strong> </li><li> <strong><code>const fn</code></strong> </li> <li>  <strong>New tools</strong> </li><li>  <strong>Instrumental code quality checks</strong> </li><li>  <strong>Documentation</strong> </li><li>  <strong>Subject working groups</strong> </li><li>  <strong>New website</strong> </li><li>  <strong>Standard Library Stabilization</strong> </li><li>  <strong>Improvements in Cargo</strong> </li><li>  <strong>Release Developers</strong> </li></ul><a name="habracut"></a><br><h3 id="rust-2018">  Rust 2018 </h3><br><p>  We wrote about Rust 2018 <a href="https://blog.rust-lang.org/2018/03/12/roadmap.html">for the first time in March</a> , and then <a href="https://blog.rust-lang.org/2018/07/27/what-is-rust-2018.html">in July</a> .  For details <em>why you</em> need Rust 2018, refer to these publications.  In this review, we have so much to tell, so we will focus only on what Rust 2018 is. You can also read about this <a href="https://hacks.mozilla.org/2018/12/rust-2018-is-here/">in a post on Mozilla Hacks</a> ( <a href="https://habr.com/post/432564/">translation</a> ). </p><br><p>  In short, Rust 2018 is an opportunity to combine into a coherent whole all the work we have done in the past three years.  Rust 2018 is more than just a set of language enhancements.  In addition to them, it includes: </p><br><ul><li>  Toolkit (IDE support, <code>rustfmt</code> , Clippy) </li><li>  Documentation </li><li>  The work of the subject working groups </li><li>  New website </li></ul><br><p>  Further we will tell about all this in more detail and about other innovations. </p><br><p>  Let's create a new project with Cargo: </p><br><pre> <code class="plaintext hljs">$ cargo new foo</code> </pre> <br><p>  Here are the contents of <code>Cargo.toml</code> : </p><br><pre> <code class="plaintext hljs">[package] name = "foo" version = "0.1.0" authors = ["Your Name &lt;you@example.com&gt;"] edition = "2018" [dependencies]</code> </pre> <br><p>  A new key has been added to the <code>[package]</code> section: <code>edition</code> .  Please note that it is set to <code>2018</code> .  You can also install it in <code>2015</code> - this value will be set by default if the key is missing. </p><br><p>  With the use of Rust 2018, some new features will be unlocked that are not allowed in Rust 2015. </p><br><p>  It is important to note that each package can be in 2015 or 2018 mode, and they will work together.  Your draft 2018 revision can use dependencies of 2015 revision, and the draft 2015 revision can use dependencies 2018 revision.  This ensures the integrity of the ecosystem and that all new features will be optional, while maintaining compatibility with existing code.  In addition, when you decide to transfer the Rust 2015 code to Rust 2018, changes can be made automatically via <code>cargo fix</code> . </p><br><p>  You may ask: what about the new features themselves?  Firstly, they are also added to Rust 2015, if they are compatible with the features of this edition.  Thus, most of the language remains the same everywhere.  You can view <a href="https://doc.rust-lang.org/edition-guide">the revision guide</a> to find out the minimum <code>rustc</code> version for each new feature and its other requirements.  However, there are several big innovations that need to be mentioned separately: non-lexical lifetimes and some changes in the module system. </p><br><h4 id="neleksicheskie-vremena-zhizni">  Non-lexical lifetimes </h4><br><p>  If you have been following the development of Rust over the past few years, then you may occasionally come across the term "NLL" or "non-lexical lifetimes".  This is slang, which, to put it in simple terms, means: the borrowing analyzer has become smarter and now accepts some correct code that it had previously rejected.  Consider an example: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = &amp;x; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> z = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x; }</code> </pre> <br><p>  Previously, Rust produced a compilation error: </p><br><pre> <code class="plaintext hljs">error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable --&gt; src/main.rs:5:18 | 4 | let y = &amp;x; | - immutable borrow occurs here 5 | 6 | let z = &amp;mut x; | ^ mutable borrow occurs here 7 | } | - immutable borrow ends here</code> </pre> <br><p>  This is because the area of ‚Äã‚Äãlink life was defined "lexically";  that is, borrowing <code>y</code> was considered active until <code>y</code> went out of scope at the end of <code>main</code> , even if we never use <code>y</code> inside the region again.  The code above is fine, but the dependency analyzer could not understand it. </p><br><p>  Now this code is remarkably compiled. </p><br><p>  But what if we used <code>y</code> ?  For example: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = &amp;x; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> z = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"y: {}"</span></span>, y); }</code> </pre> <br><p>  Rust used to give you this error: </p><br><pre> <code class="plaintext hljs">error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable --&gt; src/main.rs:5:18 | 4 | let y = &amp;x; | - immutable borrow occurs here 5 | let z = &amp;mut x; | ^ mutable borrow occurs here ... 8 | } | - immutable borrow ends here</code> </pre> <br><p>  In Rust 2018, this error message has improved: </p><br><pre> <code class="plaintext hljs">error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable --&gt; src/main.rs:5:13 | 4 | let y = &amp;x; | -- immutable borrow occurs here 5 | let z = &amp;mut x; | ^^^^^^ mutable borrow occurs here 6 | 7 | println!("y: {}", y); | - borrow later used here</code> </pre> <br><p>  Instead of indicating where <code>y</code> goes out of scope, it shows where conflict borrowing occurs.  This makes debugging such errors much easier. </p><br><p>  In Rust 1.31, this improvement is exclusively for Rust 2018. We plan to add it to Rust 2015 later. </p><br><h4 id="izmeneniya-sistemy-moduley">  Modifications to the module system </h4><br><p>  The module system can be a problem for people who study Rust for the first time.  Of course, there is always something that takes time to master.  But the main reason why the modules so embarrass many - despite the simple and consistent rules that determine the system of modules, the consequences of their application may seem contradictory, mysterious and unnatural. </p><br><p>  Therefore, revision 2018 makes some changes in how the paths work, simplifying the system of modules and making it clearer. </p><br><p>  Here is a brief summary: </p><br><ul><li>  <code>extern crate</code> no longer required almost anywhere. </li><li>  You can import macros using <code>use</code> instead of using the <code>#[macro_use]</code> attribute. </li><li>  Absolute paths begin with the name of the container, where the <code>crate</code> keyword refers to the current container. </li><li>  <code>foo.rs</code> and the subdirectory <code>foo/</code> can coexist;  <code>mod.rs</code> no longer required when placing submodules in a subdirectory. </li></ul><br><p>  It looks like an arbitrary set of rules, but on the whole the mental model is now much simpler. </p><br><p>  There are <em>many</em> more details, please refer to <a href="https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-clarity.html">the editors' manual</a> for all the details. </p><br><h3 id="dopolnitelnye-pravila-vyvoda-vremen-zhizni">  Additional withdrawal rules for lifetimes </h3><br><p>  Let's talk about the improvements available in both editions: we added some additional inference rules for <code>impl</code> blocks and function definitions.  Code like this: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; Reader <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> BufReader&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br><p>  can now be written like this: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Reader <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> BufReader&lt;<span class="hljs-symbol"><span class="hljs-symbol">'_</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br><p>  Lifetime <code>'_</code> still shows that <code>BufReader</code> takes it as a parameter, but we no longer need to set a name for it. </p><br><p>  Lifetimes are still required to be determined in structures.  However, we no longer need to write as much template code as before: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Rust 2015 struct Ref&lt;'a, T: 'a&gt; { field: &amp;'a T } // Rust 2018 struct Ref&lt;'a, T&gt; { field: &amp;'a T }</span></span></code> </pre> <br><p>  Dependency <code>: 'a</code> will be displayed.  You can still specify it explicitly if you want.  We are considering other possibilities for the conclusion in such places for the future, but so far we have no concrete plans. </p><br><h3 id="const-fn"> <code>const fn</code> </h3> <br><p>  There are several ways to declare a function in Rust: <code>fn</code> for normal functions, <code>unsafe fn</code> for unsafe functions, and <code>extern fn</code> for external functions.  This release adds a new way to declare a function: <code>const fn</code> .  It is used like this: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { x + <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br><p>  A constant function can be called as a normal function, but beyond that it can be used in any constant context.  At the same time, it will be executed at compile time, not at run time.  For example: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SIX: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> = foo(<span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre> <br><p>  The <code>foo</code> function will execute at compile time and <code>SIX</code> will take the value <code>6</code> . </p><br><p>  Constant functions cannot do everything that normal functions can do: they must have a deterministic result.  This is important for reasons of reliability.  In the current form, constant functions can perform a minimal subset of operations.  Here are some examples of what you can do in them: </p><br><ul><li>  Use integer arithmetic operations and comparison operations. </li><li>  Use any logical operations except <code>&amp;&amp;</code> and <code>||</code> </li><li>  Construct arrays, structures, enumerations, and tuples </li><li>  Call other constant functions </li><li>  Address by index in arrays and slices </li><li>  Refer to fields of structures and tuples </li><li>  Use constants (but not static values, and not even references to them) </li><li>  Use <code>&amp;</code> <code>*</code> links </li><li>  Cast types, except casting a raw pointer to an integer value </li></ul><br><p>  We will extend the capabilities of constant functions, but the above set is already enough to use <code>const fn</code> in practice. </p><br><p>  See <a href="https://doc.rust-lang.org/reference/items/functions.html">the handbook for</a> details. </p><br><h3 id="novye-instrumenty">  New tools </h3><br><p>  Revision 2018 marks the beginning of a new level of maturity of the Rust.  Cargo, Rustdoc and Rustup have been major tools since version 1.0;  With edition 2018 comes a new generation of tools that everyone can now use: Clippy, Rustfmt and IDE support. </p><br><p>  The <a href="https://github.com/rust-lang/rust-clippy/"><code>clippy</code></a> static code analyzer is now available in stable Rust.  You can install it through the <code>rustup component add clippy</code> and run it with the <code>cargo clippy</code> .  Clippy has now received version 1.0 and has the same stability guarantees for static checks as rustc.  New checks can be added, or the functionality of old ones can be extended, but old ones cannot be deleted (can only be marked as obsolete).  This means that the code that compiles with clippy will continue to compile with clippy (provided that no checks are set to generate <br>  error through <code>deny</code> ), but may issue new warnings. </p><br><p>  <a href="https://github.com/rust-lang/rustfmt">Rustfmt</a> is a tool for formatting code in Rust.  Automatic code formatting will save you time, and it will also bring your code closer to the <a href="">official Rust style</a> .  You can install it through the <code>rustup component add rustfmt</code> and use the <code>cargo fmt</code> command. </p><br><p>  Current release includes Rustfmt 1.0.  From now on, we guarantee backward compatibility for Rustfmt: if you format your code today, the formatting will not change in the future (only for default parameters).  Backward compatibility means that it is now practical to run Rustfmt on your CI (use <code>cargo fmt --check</code> ).  Try this along with "formatting while saving" in the editor, and your workflow is revolutionized. </p><br><p>  IDE support is one of the most requested features of tools for Rust.  Now there are several high quality solutions: </p><br><ul><li>  <a href="https://marketplace.visualstudio.com/items%3FitemName%3Drust-lang.rust">Visual studio code</a> </li><li>  <a href="https://plugins.jetbrains.com/plugin/8182-rust">IntelliJ</a> </li><li>  <a href="https://github.com/rust-lang-nursery/atom-ide-rust">Atom</a> </li><li>  <a href="https://github.com/rust-lang/rust-enhanced">Sublime Text 3</a> </li><li>  <a href="https://www.eclipse.org/downloads/packages/release/photon/r/eclipse-ide-rust-developers-includes-incubating-components">Eclipse</a> </li></ul><br><p>  The support work in the IDE is not finished.  In particular, code completion in RLS based editors is not up to par.  However, if you basically want support for types, documentation, and the ‚Äútransition to definition,‚Äù then you will be satisfied. </p><br><h3 id="instrumentalnye-proverki-kachestva-koda-tool-lints">  Instrumental code quality checks (tool lints) </h3><br><p>  In <a href="https://blog.rust-lang.org/2018/10/25/Rust-1.30.0.html">Rust 1.30,</a> we stabilized "instrumental attributes", such as <code>#[rustfmt::skip]</code> .  In Rust 1.31, we stabilized something like this: "tool code quality checks" ("tool lints"), such as <code>#[allow(clippy::bool_comparison)]</code> .  This allows you to set namespaces for checks to make it clearer what tools they come from. </p><br><p>  If you previously used Clippy checks, you can migrate as follows: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//  #![cfg_attr(feature = "cargo-clippy", allow(bool_comparison))] //  #![allow(clippy::bool_comparison)]</span></span></code> </pre> <br><p>  You no longer need <code>cfg_attr</code> !  You will also now receive alerts that will help you switch to using the new style. </p><br><h3 id="dokumentaciya">  Documentation </h3><br><p>  Rustdoc had several improvements this year, and a completely rewritten book, The Rust Programming Language, was released.  You can buy a <a href="https://nostarch.com/rust">paper copy from No Starch Press</a> ! </p><br><p>  Previously, it was called the "second edition" of the book, but since it became the first print edition, it caused confusion.  After all, the print edition is scheduled to be updated periodically.  In the end, after many discussions with No Starch, it was decided to update the book on the website along with each issue, and No Starch would periodically pick up the changes and print them.  The book sells pretty well and collects money for the <a href="http://www.blackgirlscode.com/">Black Girls Code</a> . </p><br><p>  You can find a new version of the book <a href="https://doc.rust-lang.org/beta/book/">here</a> . </p><br><h3 id="predmetnye-rabochie-gruppy">  Subject working groups </h3><br><p>  This year we announced the creation of four working groups: </p><br><ul><li>  Network Services </li><li>  Command line applications </li><li>  WebAssembly </li><li>  Embedded devices </li></ul><br><p>  Groups worked very hard to make Rust better in each of these areas.  Here are some achievements: </p><br><ul><li>  The network services have reworked the interface for Futures, and async / await on top of that.  These improvements have not yet been released, but we are already close to this! </li><li>  The CLI team worked on libraries and documentation to make command line applications better. </li><li>  The WebAssembly team has released many world-class tools for using Rust with wasm. </li><li>  For embedded devices, it became possible to develop ARM on a stable Rust! </li></ul><br><p>  You can learn more about all this on our new website! </p><br><h3 id="novyy-veb-sayt">  New website </h3><br><p>  <a href="https://blog.rust-lang.org/2018/11/29/a-new-look-for-rust-lang-org.html">Last week</a> we announced a new version of our website.  Now it has become the official version of rust-lang.org! </p><br><p>  To create it took a year of work of many people.  And although there is still much to be done to complete it, we are proud of the work done. </p><br><h3 id="stabilizaciya-standartnoy-biblioteki">  Standard Library Stabilization </h3><br><p>  Were added new implementations <code>From</code> : </p><br><ul><li>  <code>u8</code> now implements <code>From&lt;NonZeroU8&gt;</code> , similarly for other numeric types and their <code>NonZero</code> equivalents </li><li>  <code>Option&lt;&amp;T&gt;</code> implements <code>From&lt;&amp;Option&lt;T&gt;&gt;</code> , similarly for <code>&amp;mut</code> </li></ul><br><p>  The following functions have also been stabilized: </p><br><ul><li>  <a href="https://doc.rust-lang.org/std/primitive.slice.html"><code>slice::align_to</code></a> and its mutable analog </li><li>  <a href="https://doc.rust-lang.org/std/primitive.slice.html"><code>slice::chunks_exact</code></a> , as well as its mutable and <code>r</code> counterparts (such as <a href="https://doc.rust-lang.org/std/primitive.slice.html"><code>slice::rchunks_exact_mut</code></a> ) in all combinations </li></ul><br><p>  See <a href="">the release notes for</a> details. </p><br><h3 id="uluchsheniya-v-cargo">  Improvements in Cargo </h3><br><p>  Cargo will now load packages in parallel using HTTP / 2. </p><br><p>  In addition, since <code>extern crate</code> is no longer necessary, it would be unpleasant to write <code>extern crate foo as bar;</code>  to rename dependencies.  Therefore, you can do this in <code>Cargo.toml</code> as follows: </p><br><pre> <code class="plaintext hljs">[dependencies] baz = { version = "0.1", package = "foo" }</code> </pre> <br><p>  or equivalently: </p><br><pre> <code class="plaintext hljs">[dependencies.baz] version = "0.1" package = "foo"</code> </pre> <br><p>  Now the <code>foo</code> package is available as <code>baz</code> for use in your code. </p><br><p>  See <a href="">the release notes for</a> details. </p><br><h2 id="razrabotchiki-1310">  Developers 1.31.0 </h2><br><p>  Usually at the end of the review, we thank the <a href="">people who contributed to the preparation of the release</a> .  But this time, unlike past ones, this list does not fully cover all those people who helped, and all the amount of work that was done.  Each regular release is the result of six weeks of work, but this release is the culmination of three years of effort, reflected in a myriad of repositories made by a huge number of people.  We were pleased to work with all of you, and we look forward to the continued development of Rust over the next three years. </p><br><p>  <em>From the translator: I express special thanks to the members of the Rustycrate community and personally <a href="https://github.com/dashadee">@dashadee</a> , <a href="https://habr.com/users/ozkriff/" class="user_link">ozkriff</a> , <a href="https://habr.com/users/humbug/" class="user_link">humbug</a> and <a href="https://habr.com/users/mvlabat/" class="user_link">mvlabat</a> for their help with translation and proofreading.</em> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/432640/">https://habr.com/ru/post/432640/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../432630/index.html">Everything you wanted to know about processing requests, but were shy to ask</a></li>
<li><a href="../432632/index.html">The story of Lenny, the beloved Internet troll phone spammers</a></li>
<li><a href="../432634/index.html">An overview of five HTTP libraries for web development</a></li>
<li><a href="../432636/index.html">React Training Course, Part 1: Course Overview, React, ReactDOM, and JSX Reasons for Popularity</a></li>
<li><a href="../432638/index.html">What's new in Upsource 2018.2</a></li>
<li><a href="../432642/index.html">Using DeviceLock DLP and Citrix Xen to control email on mobile devices</a></li>
<li><a href="../432644/index.html">Overview of Intamsys FUNMAT HT High-Temperature 3D Printer</a></li>
<li><a href="../432646/index.html">Balanced merger top-down and bottom-up</a></li>
<li><a href="../432648/index.html">As we entered the cloud providers market and fell in love with B2B. Case MCS</a></li>
<li><a href="../432650/index.html">Collecting requirements for a software project - no bills</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>