<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Kodein is an interesting alternative to Dagger 2 for dependency injection in Kotlin</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, my name is Vladimir, I work as a chief IT engineer at SberTech, in the Digital Business Platform team. Once at dinner, we discussed the pros an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Kodein is an interesting alternative to Dagger 2 for dependency injection in Kotlin</h1><div class="post__text post__text-html js-mediator-article">  Hello, my name is Vladimir, I work as a chief IT engineer at SberTech, in the Digital Business Platform team.  Once at dinner, we discussed the pros and cons of Dagger 2 and what we would like to change in our implementation.  We are many, and we, respectively, also write a lot of code, so at that time there were already 100,500 methods and half-tons of dex files in our application.  Thinking over our brains, we came to the conclusion that we will not be able to write less, but we can reduce the amount of generated code during compilation.  So it was decided to look for an alternative to the existing mastodon from Google. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/232/06d/5a0/23206d5a0d9f9e5bb186fc6480013203.png"><br><a name="habracut"></a><br><h2>  How to choose </h2><br>  We have described a few general requirements for the chosen one that will save us from unnecessary code generation: <br><br>  <b>1. Generation of dependencies at runtime, not at compilation</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In our project we have long gone beyond multidex (already three times) and at the moment there are 4 dex-files in the project.  An important role in their formation is played by code generation during compilation. <br><br>  <b>2. Ease of use</b> <br><br>  Imagine the situation.  You need to quickly distribute the architecture, taking into account the application of the dependency injection pattern.  You selected several juniors from the team who were assigned to implement dependencies using the framework.  For a couple of hours they successfully coped with the task, and the project even started and did not fall in runtime.  Quickly and efficiently, everyone is overjoyed. <br><br>  Experience with Dagger says that a couple of hours is not enough.  And even a couple of days.  Or even months.  Ease of use leads to high performance - and when it comes to dependency injection among 20 million clients, the matter of time cannot be ignored. <br><br>  <b>3. Functionality no less than Dagger 2</b> <br><br>  Dagger 2 provides a bunch of interesting implementation possibilities, scopes and other charms of dependency injection.  I would not want to lose all this when switching to another framework. <br><br>  As a result, we stopped at several frameworks: <br><br><ul><li>  Feather <br></li><li>  Proton <br></li><li>  Codein <br></li><li>  Transfuse <br></li><li>  Toothpick <br></li><li>  Tiger <br></li><li>  Lightsaber <br></li></ul><br>  We discarded the last four options immediately, since they use code generation.  Why change the flea?  Therefore, a glance fell on Feather, Proton and Kodein.  But the first two have not been supported for a long time, and Kodein is released quite often.  As a result, we decided to stay on it. <br><br><h2>  DI or SL? </h2><br>  A small lyrical digression.  On Reddit and among android architects, there is a debate about whether this framework is a implementation of the dependency injection pattern, or is it a service locator implementation.  Argument of supporters of service locator: so said Jake Warton himself and well justified it.  But still the framework developer positions itself as DI.  Inside the team, we also argued on this topic, but did not come to a common opinion.  I contacted Salomon Brys (framework developer).  I quote the answer: <br><br>  <i>"To be exact, there are a number of differences between lib and a SL:</i> <i><br></i>  <i>- A DI lib must understand transient dependencies and order of initialization</i> <i><br></i>  <i>- A DI lib must provide scopes (singleton, provider, etc.)</i> <i><br></i>  <i>Kodein is a DI lib, for sure. ‚Äù</i> <br><br>  Based on the position of the author of the framework, Kodein is not a service locator, because it more fully meets the requirements of the DI pattern.  Personally, I think this is a question of terminology, not what the tool does.  If the library meets your needs, then it doesn‚Äôt matter what the pattern it implements is called.  The main thing is that the work is done without problems. <br><br><h2>  Implementation and disadvantages </h2><br>  The transition to Kodein became possible when we began to translate our project to a modular architecture - to display all products into separate modules, as independent as possible from each other.  This gave us a free hand and allowed us to replace the Dagger 2 in one small module with Kodein.  If anything, we could simply roll back to the previous stable version of the module and continue working. <br><br>  At first, we were a little afraid that Kodein would not work correctly on a Java project, since it was written in Kotlin and uses its ‚Äútricks‚Äù.  But it turned out that Kodein has good support for java-code, and it‚Äôs possible to embed dependencies there as easily as on Dagger 2 (and even easier, it will be discussed below). <br><br>  The transition from Dagger 2 to Kodein was not painful, since the module was rather small, and DI was not very actively used there.  The process went quite smoothly, everything started with a half-kick, and the dependencies climbed in and rooted as they were intended.  A nice bonus was the absence of problems with kapt, as it was with Dagger 2. Of course, it is better to implement Kodein on a project written in Kotlin, but we experimented, so we had to consider the library from unexpected sides. <br><br>  All this looks like the perfect silver bullet that will put an end to Google's hegemony and select the title of the best DI framework from Dagger.  But Kodein found quite critical flaws during work: <br><br><ol><li>  The main and fatty minus is that we can get an error in runtime, not knowing where it came from.  This was the problem of the first Dagger, which they got rid of in Dagger 2, going to code generation during compilation.  Now we see the same thing in Kodein.  The problem is solved by thorough testing and functional coverage by autotests.  Moreover, the framework itself pushes us to use its capabilities when writing tests. <br></li><li>  If you have an old and large java-project and there is no possibility to connect Kotlin, then Kodein does not suit you.  But it is rather a disease of our huge project with years of heritage. <br></li><li>  Low popularity in real projects.  This leads to the fact that the project is developing much slower than the same Dagger, because developers receive less feedback, fewer repository contributors.  Not the fact that we will derive Kodein in production, because now we are still struggling with the drawbacks that we have found. <br></li></ol><br><h2>  How to connect </h2><br>  Connecting the framework to the project does not take a lot of time, just simply specify the dependency in the gradle file: <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">implementation</span></span> <span class="hljs-string"><span class="hljs-string">'com.github.salomonbrys.kodein:kodein:4.1.0'</span></span></code> </pre> <br><h2>  Linking to Kotlin: </h2><br>  We declare a Kodein object in which dependencies will be declared. <br><br><pre> <code class="hljs pgsql">val kodein = Kodein {   bind&lt;Message&gt;() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> provider { MessageFactory(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) }   bind&lt;DbProvider&gt;() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> singleton { SqliteDS.<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>("path/to/file") } }</code> </pre><br>  Now more about this: the bind method says that there will be a linking of classes through an inline function.  In generics, we specify an interface, the implementation of which we want to inject.  After comes the method with, which talks about the method of binding, there are several of them in Kodein, they will be described below, in this case it‚Äôs provider and singleton.  After that, in curly brackets, we substitute the desired instance of the class that we want to inject. <br><br>  The binding itself will look like this: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein) {   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ds: DataSource = kodein.instance() }</code> </pre><br>  In principle, nothing complicated, you can quickly start working with this framework without knowing the details. <br><br><h2>  Types of binding </h2><br>  Kodein allows you to inject dependencies in several ways: <br><br><ul><li>  Factory binding is a binding that requires an argument to get an instance of the required type from the factory.  An instance will be generated every time an instance of the required type is requested: <br></li></ul><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = <span class="hljs-type"><span class="hljs-type">Kodein</span></span> {   bind&lt;<span class="hljs-type"><span class="hljs-type">Message</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> factory { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MessageFactory</span></span>(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">) } }</span></span></code> </pre> <br><ul><li>  Provider binding - this binding returns an instance of the required type from any storage and, unlike the Factory binding, does not require arguments for injection.  Generation will also occur every time a request is made. <br></li></ul><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = <span class="hljs-type"><span class="hljs-type">Kodein</span></span> {   bind&lt;<span class="hljs-type"><span class="hljs-type">Message</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> provider { <span class="hljs-type"><span class="hljs-type">MessageFactory</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>) } }</code> </pre><br><ul><li>  Singleton binding - everything is simple, we create a singleton with lazy initialization.  Creating a singleton will be called only once. <br></li></ul><br><pre> <code class="hljs pgsql">val kodein = Kodein {   bind&lt;DBProvider&gt;() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> singleton { SqliteDS.<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>("path/to/file") } }</code> </pre> <br><br><ul><li>  Tagged bindings - allow you to tag types for which different instances will be generated. <br></li></ul><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = <span class="hljs-type"><span class="hljs-type">Kodein</span></span> {   bind&lt;<span class="hljs-type"><span class="hljs-type">Message</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> factory { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MessageFactory</span></span>(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">) }   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bind&lt;Message&gt;</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">"</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">ImageMessage</span></span></span></span><span class="hljs-class"><span class="hljs-params">"</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">provider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-type"><span class="hljs-type">MessageFactory</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>) }   bind&lt;<span class="hljs-type"><span class="hljs-type">Message</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"PaymentMessage"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> singleton { <span class="hljs-type"><span class="hljs-type">MessageFactory</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>) } }</code> </pre><br>  There are also opportunities: <br><br><ul><li>  Creating singleton without lazy initialization.  The object will be generated when the Kodein object is initialized. <br></li><li>  Receiving an instance (only if it was created). <br></li><li>  Creating a mixed version of singleton and factory binding - when we want to get an instance with an argument and not create a new one every time. <br></li></ul><br>  Another useful feature is wrapping bundles in weak and soft links.  This can be an advantage if you understand that objects should not be long-lived. <br><br>  An interesting possibility is the binding in local streams.  That is, each stream will have its own copy of the injection that we need. <br><br><h2>  Creating modules </h2><br>  Kodein allows you to store bindings in modules in much the same way as Dagger 2. Example: <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> apiModule = <span class="hljs-type"><span class="hljs-type">Kodein</span></span>.<span class="hljs-type"><span class="hljs-type">Module</span></span> {   bind&lt;<span class="hljs-type"><span class="hljs-type">MessengerApi</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> singleton { <span class="hljs-type"><span class="hljs-type">DefaultMessengerApi</span></span>() } }</code> </pre><br>  And then when you initialize the Kodein object, you can specify the desired module: <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">val</span></span> kodein = <span class="hljs-type"><span class="hljs-type">Kodein</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-title"><span class="hljs-title">apiModule</span></span>) }</code> </pre><br><h2>  Bind override </h2><br>  By default, Kodein does not allow redefining of bindings, as accidental ‚Äúdouble‚Äù binding can lead to unforeseen consequences and waste time searching for a problem.  But this possibility is present.  It will be convenient, for example, for testing classes, where you can change the implementation to any Mock.  This is done as follows: <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = <span class="hljs-type"><span class="hljs-type">Kodein</span></span> {   bind&lt;<span class="hljs-type"><span class="hljs-type">MessengerApi</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> singleton { <span class="hljs-type"><span class="hljs-type">DefaultMessengerApi</span></span>() }   <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>   bind&lt;<span class="hljs-type"><span class="hljs-type">MessengerApi</span></span>&gt;(overrides = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> singleton { <span class="hljs-type"><span class="hljs-type">CustomMessengerApi</span></span>() } }</code> </pre><br>  Imagine that we do not know whether there is already an instance of the type that we want to inject.  For such a case, there is a design that allows, in the presence of such an instance, to overload it: <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = <span class="hljs-type"><span class="hljs-type">Kodein</span></span> {   <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(testEnvModule, allowOverride = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) }</code> </pre><br>  There is also a flag that says that it would be preferable to take an already redefined instance.  In case there is some ‚Äúimproved‚Äù functionality in the ‚Äúnew‚Äù instance: <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testModule = <span class="hljs-type"><span class="hljs-type">Kodein</span></span>.<span class="hljs-type"><span class="hljs-type">Module</span></span>(allowSilentOverride = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) {   bind&lt;<span class="hljs-type"><span class="hljs-type">EmailClient</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> singleton { <span class="hljs-type"><span class="hljs-type">MockEmailClient</span></span>() } }</code> </pre> <br><h2>  Lazy initialization </h2><br>  Thanks to the delegation of properties from Kotlin, Kodein can use lazy initialization of bindings for almost all types of bindings: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein) {   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> messageFactory: (<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) -&gt; Dice <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.lazy.factory()   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dbProvider: DataSource <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.lazy.instance()   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> randomProvider: () -&gt; Random <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.lazy.provider()   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> answerConstant: String <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.lazy.instance(<span class="hljs-string"><span class="hljs-string">"answer"</span></span>) }</code> </pre> <br><h2>  How classes are generated in runtime </h2><br>  Generation of classes occurs due to embedding functions.  This allows embedding in the code when compiling.  That is, the compiler simply inserts a piece of the necessary code into the place where the built-in function will be declared.  The generation of classes in Kodein follows the same principle.  The choice of the necessary types for creation of copies happens at the expense of reified generics.  You can read more on the links at the end of the article. <br><br><h2>  Kodein on java-projects </h2><br>  And what about those who have projects written not in Kotlin, but in Java?  Kodein provides the same functionality and good old Java, but with some limitations.  The framework partially supports the JSR-330 specification, specifically the <a href="https://habrahabr.ru/users/inject/" class="user_link">Inject</a> annotation, which is familiar to anyone who has ever encountered DI in Java. <br><br>  There are some disadvantages here.  Injections are not made through inline functions and generics, but with the help of reflection.  Accordingly, there will be a loss in performance due to reflection and multilingual compilation.  In addition, the object with the bindings must be written on Kotlin - if the conditions indicate the use of exclusively Java, then, alas, Kodein will not work for you. <br><br>  To use Kodein on java-projects, you need to take a few steps: <br><br><ol><li>  Connect JxInjector in gradle: <br></li></ol><br><pre> <code class="java hljs">compile <span class="hljs-string"><span class="hljs-string">'com.github.salomonbrys.kodein:kodein-jxinject:4.1.0'</span></span></code> </pre> <br>  2. Add the jxIntector module to the Kodein object: <br><br><pre> <code class="java hljs">val kodein = Kodein {   <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(jxInjectorModule)   <span class="hljs-comment"><span class="hljs-comment">/* Other bindings */</span></span></code> </pre><br>  3. Perform binding.  It can be done in two ways.  The first way is classic.  Just write the inject annotation on the required field, write the method - and everything will work the same as on Dagger. <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyJavaController</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyJavaController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Connection connection, FileSystem fs)</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>   }   <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre><br>  The second way is using specific Kodein objects: <br><br><pre> <code class="java hljs">MyJavaController controller = Jx.of(kodein).newInstance(MyJavaController.class);</code> </pre> <br>  or so: <br><br><pre> <code class="java hljs">MyJavaController controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyJavaController(); Jx.of(kodein).inject(controller);</code> </pre> <br><h2>  Conclusion </h2><br>  A simple and lightweight DI framework that allows you to understand the basics literally overnight and begin to implement it in your project, and even written in Kotlin and proven in production?  It sounds too good, but with Kodein this has become true. <br><br>  This framework is not a 100% alternative to Dagger 2, but it can be used on fat projects with lots of code, where even Mr. Proper could not do it, where additional code generation can result in a new dex file.  But do not assume that for small projects Kodein will be bad.  It greatly simplifies dependency injection without requiring knowledge of the mechanisms specific to Dagger 2. <br><br>  Kodein also fits Kotlin very well and feels pretty good on such projects.  Here, at least, the code generation of classes is very interesting - this is a deviation from the approach with reflection in favor of the opportunities offered by Kotiln.  Unfortunately, all the code written in the framework of this experiment, we have not yet brought into production, since there is no 100% certainty that the framework will not shoot us in the leg.  The study is ongoing. <br><br><h2>  useful links </h2><br><ul><li>  <a href="https://github.com/SalomonBrys/Kodein">The repository of the founding father of Kodein</a> </li><li>  You can read more about inline functions in the Kotlin language <a href="https://kotlinlang.org/docs/reference/inline-functions.html">here.</a> </li><li>  More information about the delegation of properties can be read <a href="https://kotlinlang.org/docs/reference/delegated-properties.html">here.</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/347208/">https://habr.com/ru/post/347208/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347198/index.html">Rust: swing the tape and parsing JSON</a></li>
<li><a href="../347200/index.html">Java with assembly inserts</a></li>
<li><a href="../347202/index.html">In the US with a bodyshop: go or not go?</a></li>
<li><a href="../347204/index.html">IT solutions architecture. Part 1. Enterprise architecture</a></li>
<li><a href="../347206/index.html">As simple as possible about sorting combinations in real business problems</a></li>
<li><a href="../347210/index.html">Behaviors - Erlang behaviors</a></li>
<li><a href="../347212/index.html">Configuring squid or how not to buy a paid solution</a></li>
<li><a href="../347216/index.html">The principle of the stream cipher with examples in C #. From One-time pad to stream cipher based on hashf and CTR</a></li>
<li><a href="../347218/index.html">Projection Modeling Technique</a></li>
<li><a href="../347220/index.html">Microchip implantation: myths and reality</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>