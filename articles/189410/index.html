<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Single sign-on on omniauth and rails</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="User authentication in ecosystems like Google or Envato is implemented as separate services ( accounts.google.com , account.envato.com ) that provide ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Single sign-on on omniauth and rails</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/175/f6b/e35/175f6be35ad8005743c062b3e3abb20a.jpeg" align="left"><br>  User authentication in ecosystems like Google or Envato is implemented as separate services ( <a href="http://accounts.google.com/">accounts.google.com</a> , <a href="http://account.envato.com/">account.envato.com</a> ) that provide the necessary data and tokens to client sites.  During the development of some projects on Ruby on Rails, I had to face a similar task.  Scientifically - <a href="https://en.wikipedia.org/wiki/Single_sign-on">single sign-on</a> or <a href="https://en.wikipedia.org/wiki/Single_sign-on">single sign-on</a> <a href="http://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D1%2585%25D0%25BD%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25B8%25D1%258F_%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25B2%25D1%2585%25D0%25BE%25D0%25B4%25D0%25B0">technology</a> . <br><br>  We needed (1) a common service for all sites of the ecosystem, with (2) predominantly social authorization, for the sake of logging in using the ‚Äúlogin + password‚Äù combination. <br>  Service, (3) accumulating in itself data from those social services with the help of which the user logs into the system, and (4) providing this data to client sites. <br><br>  The task turned out to be as interesting as it was non-standard.  It all started with a useful, but already slightly outdated article - the author suggested using the omniauth gem and custom strategy on client sites, and on the provider site - using the same omniauth in conjunction with devise for authentication via social.  Services. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In my case, Devise didn‚Äôt fit a little (set on login + password), so omniauth was completely preferred.  This was the beginning of my little adventure, the course of which I invite you to read in this article. <br><a name="habracut"></a><br><h4>  General scheme </h4><br>  Three projects will be considered: <a href="https://github.com/gambala/demo-sso-client">client</a> <a href="https://github.com/gambala/demo-sso-provider">site, provider site</a> and <a href="https://github.com/gambala/omniauth-accounts">omniauth custom strategy</a> .  The links are all available on github and ready to use.  The article will be raised only the key points. <br><br><h5>  <a href="https://github.com/gambala/demo-sso-client">Client site</a> </h5><br>  We will run on <b>localhost: 4000</b> . <br>  The structure is standard for any sites using omniauth: <br><ul><li>  We include omniauth and our omniauth-accounts strategy in Gemfile: </li></ul><br><pre><code class="ruby hljs">gem <span class="hljs-string"><span class="hljs-string">'omniauth'</span></span> gem <span class="hljs-string"><span class="hljs-string">'omniauth-accounts'</span></span></code> </pre> <br><ul><li>  bundle install </li><li>  In config / initializers / omniauth.rb insert the initialization code: </li></ul><br><pre> <code class="ruby hljs">Rails.application.config.middleware.use OmniAuth::Builder <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> provider <span class="hljs-symbol"><span class="hljs-symbol">:accounts</span></span>, ENV[<span class="hljs-string"><span class="hljs-string">'ACCOUNTS_API_ID'</span></span>], ENV[<span class="hljs-string"><span class="hljs-string">'ACCOUNTS_API_SECRET'</span></span>], <span class="hljs-symbol"><span class="hljs-symbol">client_options:</span></span> { <span class="hljs-symbol"><span class="hljs-symbol">site:</span></span> ENV[<span class="hljs-string"><span class="hljs-string">'ACCOUNTS_API_SITE'</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><ul><li>  In router.rb, add a route for the callback method: </li></ul><br><pre> <code class="ruby hljs">match <span class="hljs-string"><span class="hljs-string">'/auth/:provider/callback'</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:to</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'auth#callback'</span></span></code> </pre><br><ul><li>  We create a controller and a callback method in it, in which we receive through request.env ['omniauth.auth'] the final hash with the data and tokens </li></ul><br><pre> <code class="ruby hljs">rails g controller auth --skip-assets <span class="hljs-comment"><span class="hljs-comment"># auth_controller.rb class AuthController &lt; ApplicationController def callback auth_hash = request.env['omniauth.auth'] render json: auth_hash end end</span></span></code> </pre><br>  That's all, minimal. <br><br><h5>  <a href="https://github.com/gambala/omniauth-accounts">Strategy</a> </h5><br>  A derivative of the standard oauth 2.0 strategy, omniauth-oauth2 is indicated in the Gemspec.  There is very little code, and besides, it does not make sense to adjust it for yourself; all the necessary strategies are transmitted in the initialization parameters (in the example, as environment variables).  It: <br><ul><li>  Credentials keys (ACCOUNTS_API_ID and ACCOUNTS_API_SECRET) for connecting to the site-provider of the client site </li><li>  The address of the site provider ACCOUNTS_API_SITE </li><li>  Address for authentication on the provider site (default: / authorize) .. </li><li>  ... and to get a token (/ token) </li></ul><br>  Having received this data, the strategy takes up all further work.  Because of this, however, in the course of development, unpleasant incidents may occur, when in a certain situation the strategy is ‚Äúlost‚Äù - it cannot continue its implementation further as planned.  I had to face such problems, and the solution to each was found - which will be discussed further in the article. <br><br><h5>  <a href="https://github.com/gambala/demo-sso-provider">Site provider</a> </h5><br>  We will run on <b>localhost: 3000</b> . <br>  Combines the two halves: <br><ul><li>  One - to communicate with the client site </li><li>  Another - to communicate with social services </li></ul><br><img src="http://habrastorage.org/storage2/5fa/33b/ed6/5fa33bed6542d8b35ed1ac77ef192312.png"><br>  Authentication on the site provider occurs using standard omniauth strategies. <br>  Authentication on the client site - using a custom strategy. <br><br>  Common link - account: <ul><li>  Ways to log on to the provider site are tied to it (as a key keeper on a habr) </li><li>  Applications and grants for client sites are tied to it. </li></ul><br><br><h4>  ISP authentication and account management </h4><br>  When registering on the client site, it is pleasant to fill in most of the required fields automatically from your Facebook or Twitter profile.  Our site provider will play the role of an aggregator - let it aggregate all the data from the social.  services in a single profile, which can be supplemented manually, and client sites will take information from there. <br><br>  This topic has previously skipped on the pages of Habr.  Unfortunately, I can‚Äôt find this article in any way, but there, in particular, the question was raised about typical problems with social authentication on the site: <br><ul><li>  Ability to merge accounts </li><li>  Update account data when updating services </li><li>  Ability to bind different services to one account </li></ul><br>  All this is typical requirements for a system of this type, as well as validation with sending a letter to email - a traditional requirement that has emerged in authentication by login + password.  A brief look at these requirements. <br><br><h6>  Merge accounts </h6><br>  Signed in through the gmail-box - the system created one account, with data from gmail.  The next time you went through facebook, and the system again created a new account.  We look and understand that the last time we created an account for ourselves through ... we remember ... gmail!  We click on the button, we go through gmail this time and our accounts merge into one - just like two pennies! .. or not - there is one problem.  Merge data. <br><br>  In gmail, we are Alexander Polovin, and on Facebook, Alex Polovin.  And what data to leave in your account? <br><br>  Immediately when you merge, ask the user what to leave?  No, this is a very unsuccessful undertaking in terms of usability - the user merges accounts so that he can quickly go back using the account to the site he had visited before, he doesn‚Äôt have time to be distracted by the ‚ÄúReplace‚Äù and ‚ÄúReplace all‚Äù dialogs. <br><br>  My decision was to add new data ‚Äúas a reserve‚Äù, as additional values ‚Äã‚Äãof the account fields.  In fact, all account data is stored in a hash, and this hash can take the following form after the merger (we‚Äôll also add the data from the conditional twitter - Half of Alex): <br><pre> <code class="ruby hljs">{ <span class="hljs-symbol"><span class="hljs-symbol">name:</span></span> [<span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">'Alex Polovin'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>], <span class="hljs-symbol"><span class="hljs-symbol">first_name:</span></span> [<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'Alex'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>], <span class="hljs-symbol"><span class="hljs-symbol">sir_name:</span></span> [<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'Polovin'</span></span>], ... }</code> </pre><br>  As you can see, the values ‚Äã‚Äãare simply added to the array for each field.  However, they are not duplicated - ‚ÄúHalf‚Äù of Twitter has not been preserved as a duplicate in the ‚Äúlast name‚Äù. <br><br>  Client sites will always receive the very first value from the arrays, if desired, the user can put any of the values ‚Äã‚Äãin the first place. <br><br><h6>  Account Update </h6><br>  Among all the data available omniauth from social.  services, the most frequently updated avatar user.  Slightly less often - links to pages (the urls parameter), nickname and description on Twitter.  In any case, there is a desire to update them in your account with a single click ... or leave the former ones - the situations are different.  Our algorithm is great for this ‚Äî it writes new values ‚Äã‚Äãto the end of the arrays without saving duplicates. <br><br><h6>  Linking different services to one account </h6><br>  Analogue of the key for the habre - the system creates an entry in the authentication table and binds to the current account.  It is used later as a key and as a data source. <br><br><h6>  Manual editing of account fields </h6><br>  Not all fields are filled from social.  services.  The user should be able to fill in the missing data on their own, on the website of the provider.  And also - swap the values ‚Äã‚Äãin the arrays, which was mentioned a couple of paragraphs above. <br><br><h5>  Implementation </h5><br><h6>  Models </h6><br><ul><li>  Account - stores the data hash (info) </li><li>  Authentication - accomplished via omniauth authentication on facebook, twitter, or other service;  stores the provider name and uid of the user; </li></ul><br>  To make Rails understand info as a hash: the type of the text field is indicated in the migration, and the code is added to the model: <br><pre> <code class="ruby hljs">serialize <span class="hljs-symbol"><span class="hljs-symbol">:info</span></span>, Hash</code> </pre><br>  Between models - one-to-many relationship: <br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># /app/models/account.rb has_many :authentications # /app/models/authentication.rb belongs_to :account</span></span></code> </pre><br><br><h6>  Controllers </h6><br>  <b>AuthenticationsController</b> covers all authentication needs, includes the following actions: <br><ul><li>  auth (/ auth) - the page for selecting a service to enter, or update the data of the questionnaire </li><li>  logout (/ logout) - logout </li><li>  callback (/ auth /: provider / callback) - in this method, the main work is performed on entering, updating data, authenticating bindings, etc. </li><li>  failure (/ auth / failure) - performed if an error occurred at the ‚Äúend of the end‚Äù when entering </li><li>  detach (/ auth / detach) - disconnects authentication from current account </li></ul><br>  When choosing one of the authentication services, standard omniauth operations are performed ‚Äî the crown of which, in case of successful authentication, is the callback method call.  Depending on the situation, it performs the following actions: <br><ul><li>  Updates the questionnaire data </li><li>  Merges two different accounts together </li><li>  Binds a new service to the current account. </li><li>  Performs a second or initial login. </li></ul><br>  The data hash is formed in a separate private method get_data_hash (), depending on the selected social.  service. <br><br>  To add data to the end of arrays without duplicates, the add_info model method is used (based on the operation of combining arrays): <br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(info)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.info.merge!(info){<span class="hljs-params"><span class="hljs-params">|key, oldval, newval|</span></span> [*oldval].to_a <span class="hljs-params"><span class="hljs-params">| [*newval].to_a} </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">end</span></span></span></span></code> </pre><br>  And to bind authentication, add_authentications: <br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_authentications</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(authentications)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.authentications &lt;&lt; authentications <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  As a result, the session of the account id for which the login was made is saved in the session - session [: account_id]. <br><br>  <b>AccountsController</b> at this stage contains the following actions: <br><ul><li>  index - the output of the user profile in the form of </li><li>  edit - edit account profile data </li><li>  update - update the questionnaire (POST request from edit) </li></ul><br>  And also the filter is a mandatory check for the presence of a user in the network (with a redirect to the login page). <br><br>  I really wanted to achieve the possibility of really convenient and flexible data changes.  And such a task is still standing and will be worked out in the future.  For now - editing is done in two ways: <br><ul><li>  If js is disabled, there is a text zone with a YAML-formatted hash </li><li>  If enabled, the visual editor of json-structures jsoneditor is loaded. </li></ul><br><img src="http://habrastorage.org/storage2/459/980/d24/459980d249fad3f3b8b619b2c1e1c986.png"><br><br><h4>  Creating a connection between the client site and the provider site </h4><br>  The standard practice in this case is to create an ‚Äúapplication‚Äù on the provider‚Äôs website.  Specify the name and address of the client site (or rather, the address for the callback redirect) - and we get two keys - id and secret.  We specify them in the parameters of the social authentication system - whether it is any plug-in to cms, or hem for Rails.  In our case - the keys are used omniauth - ACCOUNTS_API_ID and ACCOUNTS_API_SECRET. <br><br>  Implement application support in the site provider is easy: <br><pre> <code class="ruby hljs">rails g scaffold Application <span class="hljs-symbol"><span class="hljs-symbol">name:</span></span>string <span class="hljs-symbol"><span class="hljs-symbol">uid:</span></span>string <span class="hljs-symbol"><span class="hljs-symbol">secret:</span></span>string <span class="hljs-symbol"><span class="hljs-symbol">redirect_uri:</span></span>string <span class="hljs-symbol"><span class="hljs-symbol">account_id:</span></span>integer rake <span class="hljs-symbol"><span class="hljs-symbol">db:</span></span>migrate <span class="hljs-comment"><span class="hljs-comment"># account.rb has_many :applications</span></span></code> </pre><br>  When creating a new record, the model should generate keys for it: <br><pre> <code class="ruby hljs">before_create <span class="hljs-symbol"><span class="hljs-symbol">:default_values</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">default_values</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">self</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uid</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SecureRandom</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">16</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.secret = SecureRandom.hex(<span class="hljs-number"><span class="hljs-number">16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  And - in all actions on the application should be filtered by the current user.  For example, instead of: <br><pre> <code class="ruby hljs">@applications = Application.all</code> </pre><br>  used by: <br><pre> <code class="ruby hljs">@applications = Account.find(session[<span class="hljs-symbol"><span class="hljs-symbol">:account_id</span></span>]).applications</code> </pre><br>  And - be sure to ensure that the user is online - put a filter: <br><pre> <code class="ruby hljs">before_filter <span class="hljs-symbol"><span class="hljs-symbol">:check_authentication</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check_authentication</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> !</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">session</span></span></span><span class="hljs-function">[:</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">account_id</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">redirect_to</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">auth_path</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notice</span></span></span><span class="hljs-function">: '    ,    .' </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre><br><br><h5>  Process flow </h5><br>  Authentication is based on oauth 2.0 - the principles of this protocol can be found in this article on Habr√©, or clearly here. <br><br>  The starting point is client-site.com/auth/accounts.  It is picked up by omniauth and, using the omniauth-accounts strategy, sends a request to the server of the site provider. <br><br>  At the same time, omniauth generates the state parameter, which helps the provider not to confuse the request from one client site and user with other requests. <br><br>  The site provider accepts the request (according to the standard - at provider-site.com/authorize), and performs certain actions.  The goal of the provider at this stage is to authorize the user and grant him a grant for authentication on the client‚Äôs site. <br><br>  If the goal is achieved, a redirect from the site provider is redirected to the callback method of the site client, in which through request.env ['omniauth.auth'] we get a hash with tokens and data from the site provider. <br><br><h5>  Authorization </h5><br>  The authorize method - the darkest place in the process scheme - there are a lot of nuances to consider before issuing a grant to the user. <br><br>  Ideally (when re-authorization) - the following conditions are met: <br><ul><li>  The user has already logged in to the provider site </li><li>  The user has already been granted a grant for this application. </li><li>  This grant has not expired. </li></ul><br>  In this case, the user is authorized immediately and redirects to the callback method of the client site.  The parameters are the grant code and the state. <br><br>  If at least one of these conditions is not met, you must first resolve the problems: <br><ul><li>  If the user has not logged in to the site provider - allow him to do it </li><li>  If the grant is not issued - create it </li><li>  If the grant has expired - re-create the grant </li></ul><br>  These actions involve navigating the site provider and even the social sites.  services (if the user needs to log in).  The latter turned out to be not without purpose ‚Äî it is in this place that the omniauth shows its unpleasant sides. <br><br>  The fact is that omniauth, when going to authorize, passes several parameters to the url, and also writes several parameters to the session of the site provider.  This is necessary for him to correctly redirect to the callback method.  But if we suddenly want to use omniauth on the provider site (for example, when trying to log in through a social service), omniauth will erase its data from the session.  And the redirect will end with the error OmniAuth :: Strategies :: OAuth2 :: CallbackError - invalid_credentials. <br><br>  Therefore, in order to avoid such situations, all omniauth parameters are clearly fixed in the session and are restored just before the redirect. <br><br><img src="http://habrastorage.org/storage2/1a8/712/81f/1a871281fff86710c49fca0002845ae8.png"><br><br><h6>  orders # register </h6><br>  If all parameters are passed correctly (that is, the request came exactly from omniauth) - create a record in the current session - ‚Äúorder for the grant‚Äù and save all the parameters in it: <br><pre> <code class="ruby hljs">session[<span class="hljs-symbol"><span class="hljs-symbol">:grants_orders</span></span>] = Hash.new <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !session[<span class="hljs-symbol"><span class="hljs-symbol">:grants_orders</span></span>] session[<span class="hljs-symbol"><span class="hljs-symbol">:grants_orders</span></span>].merge!( params[<span class="hljs-symbol"><span class="hljs-symbol">:client_id</span></span>] =&gt; { <span class="hljs-symbol"><span class="hljs-symbol">redirect_uri:</span></span> params[<span class="hljs-symbol"><span class="hljs-symbol">:redirect_uri</span></span>], <span class="hljs-symbol"><span class="hljs-symbol">state:</span></span> params[<span class="hljs-symbol"><span class="hljs-symbol">:state</span></span>], <span class="hljs-symbol"><span class="hljs-symbol">response_type:</span></span> params[<span class="hljs-symbol"><span class="hljs-symbol">:response_type</span></span>], <span class="hljs-string"><span class="hljs-string">'omniauth.params'</span></span> =&gt; session[<span class="hljs-string"><span class="hljs-string">'omniauth.params'</span></span>], <span class="hljs-string"><span class="hljs-string">'omniauth.origin'</span></span> =&gt; session[<span class="hljs-string"><span class="hljs-string">'omniauth.origin'</span></span>], <span class="hljs-string"><span class="hljs-string">'omniauth.state'</span></span> =&gt; session[<span class="hljs-string"><span class="hljs-string">'omniauth.state'</span></span>] } )</code> </pre><br><br><h6>  orders # show </h6><br>  Perform all checks here.  Whether the user is online, whether the application that the request came from is registered on the site, is there an old grant, is it overdue. <br><ul><li>  If everything is in order, immediately call the method of issuing a grant </li><li>  If something is wrong, we‚Äôll show a page that is typical for such authentications (‚ÄúThe application requests access to the account‚Äù, ‚ÄúAllow‚Äù, ‚ÄúDeny‚Äù) </li></ul><br><img src="http://habrastorage.org/storage2/c30/492/211/c304922111648f5738827f16959f214a.png"><br><br><h6>  orders # accept </h6><br>  It is carried out if the grant was right away and was suitable for the requirements, or when you click on the ‚ÄúAllow‚Äù button on the order page of the grant. <br><ul><li>  All omniauth parameters saved in the session are restored so that they are adequately processed by omniauth when redirected to the callback method </li><li>  Create a grant and perform a redirect </li></ul><br><br><h6>  orders # deny </h6><br>  Cancel the application, simply remove it from the session. <br><br><h6>  grants # token </h6><br>  According to the parameters passed, we find the application and the grant.  If everything is in order, we issue grant tokens in json format. <br><br><h6>  accounts # get_info </h6><br>  We return the hash in json format, as it was agreed - only the first values ‚Äã‚Äãof the parameters, if they are represented by an array. <br><pre> <code class="ruby hljs">data_hash = grant.account.info hash = Hash.new hash[<span class="hljs-string"><span class="hljs-string">'id'</span></span>] = grant.account.id data_hash.each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|key, value|</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> value.kind_of?(Array) hash[key] = value[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> hash[key] = value <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> render <span class="hljs-symbol"><span class="hljs-symbol">:json</span></span> =&gt; hash.to_json</code> </pre><br><br><h4>  Conclusion </h4><br>  The solution turned out to be ingenious - and in it, for sure, much can be improved and optimized.  The following tasks are currently outlined: <br><ul><li>  To give the possibility, when creating an application, to specify which parameters it will require - is mandatory and optional.  And, if the necessary parameters are not in the user profile - to give him the opportunity to enter them directly on the page for receiving the grant </li><li>  Provide login login + password - using the omniauth-identity strategy </li><li>  Add a logout action to the client site, leaving the system not only on the client site, but also on the provider site </li><li>  Solve the problem with the missing session in the token and get_info json requests (this seems to be somehow related to the Rails security system, protect_from_forgery and verify_authenticity_token) </li></ul><br>  Not every day you have to write a similar system - after all, in fact, there are not so many ecosystems on the Internet.  Google, Envato, Yandex, Yahoo - and who else?  Perhaps - your project?  And this is not the only way to introduce authentication into related projects - there is CAS technology (a couple of useful links), there is OpenID (and as an option, the same Loginz).  On our own homepage and other TM projects, there is generally a separate authentication system on each site, plus the proprietary "Key House". <br><br>  Why did my choice fall on SSO?  Perhaps the key ‚Äúfor‚Äù is the atmosphere.  These are the feelings that the user experiences when he enters not the site, but the System - with a capital "C".  Into a powerful, advanced, developed System - this is truly an amazing feeling, colleagues. <br><img src="http://habrastorage.org/storage2/d9f/43d/2eb/d9f43d2eb2e07455d13fc8b3805bd96d.png"></div><p>Source: <a href="https://habr.com/ru/post/189410/">https://habr.com/ru/post/189410/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../189392/index.html">Digest news from the world of mobile payments # 2</a></li>
<li><a href="../189402/index.html">Deeper and deeper SOPA, all the darker things to come</a></li>
<li><a href="../189404/index.html">Closing the dream</a></li>
<li><a href="../189406/index.html">Daemon Without Wires - A4Tech's Bloody R8 Review</a></li>
<li><a href="../189408/index.html">New 3D printing method allows you to create painted furniture and lamps</a></li>
<li><a href="../189412/index.html">Backup for home and small office</a></li>
<li><a href="../189414/index.html">Goodbye Habr. Today we finish our blog on Habr√©</a></li>
<li><a href="../189416/index.html">Gadget Eddiction: Single Collection Review</a></li>
<li><a href="../189420/index.html">Pixomondo and Dell: on the wings of success</a></li>
<li><a href="../189422/index.html">Robot R2B2 brute force PIN-codes Android-smartphones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>