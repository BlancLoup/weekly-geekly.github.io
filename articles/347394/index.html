<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Code alignment instructions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="How hard can it be to measure the performance of a simple function, like this one? 



// func.cpp void benchmark_func(int* a) { for (int i = 0; i < 3...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Code alignment instructions</h1><div class="post__text post__text-html js-mediator-article">  How hard can it be to measure the performance of a simple function, like this one? <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// func.cpp void benchmark_func(int* a) { for (int i = 0; i &lt; 32; ++i) a[i] += 1; }</span></span></code> </pre> <br>  Well, let's just wrap it up in some micro-benchmark, call it many, many times (to average the results) and see what happens, right?  Well, okay, we can still look at the generated instructions just to make sure that the compiler didn‚Äôt "optimize" something.  We can also conduct several different tests to make sure that the loop is the bottleneck.  Well, that's it.  We understand what we measure, right? <br><br>  Let's imagine that there is another function in our file, the speed of which you also measure, but in separate tests.  Those.  the file looks something like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// func.cpp void foo(int* a) { for (int i = 0; i &lt; 32; ++i) a[i] += 1; } void benchmark_func(int* a) { for (int i = 0; i &lt; 32; ++i) a[i] += 1; }</span></span></code> </pre> <br>  Then one day your manager comes to you and shows a claim from a user of your library, which is that it does not work as fast as you promised.  But wait, we measured the performance well and promised exactly what we got from the test results.  What went wrong? <br><a name="habracut"></a><br>  The user says that he was only interested in testing the benchmark_func () function, so he ran performance tests for her only. <br><br><h2>  Numbers </h2><br>  I collected this code with the latest Clang with the following options: <br><br><pre> <code class="bash hljs">-O2 -march=skylake -fno-unroll-loops</code> </pre> <br>  I ran this code on an Intel Core i7-6700 Skylake processor <br>  All code together with scripts for assembly can be downloaded <a href="https://github.com/dendibakh/dendibakh.github.io/tree/master/_posts/code/CodeAlignment">here</a> .  You will also need a <a href="https://github.com/google/benchmark">google benchmark</a> library. <br><br>  Let's call the version of the code with two functions ‚Äúbasic‚Äù, and the variant with only one function benchmark_func is ‚Äúno_foo‚Äù.  And here are the results: <br><br><pre> <code class="bash hljs">$ ./baseline.sh --------------------------------------------------------- Benchmark CPU Iterations Throughput Clockticks/iter --------------------------------------------------------- func_bench_median 4 ns 191481954 32.5626GB/s 74.73 $ ./no_foo.sh --------------------------------------------------------- Benchmark CPU Iterations Throughput Clockticks/iter --------------------------------------------------------- func_bench_median 4 ns 173214907 29.5699GB/s 84.54</code> </pre> <br>  I calculated the ‚ÄúClockticks / iter‚Äù metric on my own, dividing the number of ticks for performing the benchmark_func () function by the number of iterations. <br>  Oddly enough, deleting the function foo () not called in the test from the source file at all has reduced the performance of the remaining function by ~ 10%. <br><br><h2>  Let's try to understand what's going on here. </h2><br>  Looking ahead, I‚Äôll say that the generated assembly code for the benchmark_func () function is identical in both cases, and the only difference is in its location in the binary and the alignment of the internal loop. <br><br>  Let's first look at the generated code for the "base" version: <br><br><pre> <code class="hljs go">$ objdump -d a.out -M intel | grep <span class="hljs-string"><span class="hljs-string">"&lt;_Z14benchmark_funcPi&gt;:"</span></span> -A15 <span class="hljs-number"><span class="hljs-number">00000000004046</span></span>c0 &lt;_Z14benchmark_funcPi&gt;: <span class="hljs-number"><span class="hljs-number">4046</span></span>c0: <span class="hljs-number"><span class="hljs-number">48</span></span> c7 c0 <span class="hljs-number"><span class="hljs-number">80</span></span> ff ff ff mov rax,<span class="hljs-number"><span class="hljs-number">0xffffffffffffff</span></span>80 <span class="hljs-number"><span class="hljs-number">4046</span></span>c7: c5 fd <span class="hljs-number"><span class="hljs-number">76</span></span> c0 vpcmpeqd ymm0,ymm0,ymm0 <span class="hljs-number"><span class="hljs-number">4046</span></span>cb: <span class="hljs-number"><span class="hljs-number">0f</span></span> <span class="hljs-number"><span class="hljs-number">1f</span></span> <span class="hljs-number"><span class="hljs-number">44</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> nop DWORD PTR [rax+rax*<span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">0x0</span></span>] <span class="hljs-number"><span class="hljs-number">4046d</span></span>0: c5 fe <span class="hljs-number"><span class="hljs-number">6f</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>c <span class="hljs-number"><span class="hljs-number">07</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> vmovdqu ymm1,YMMWORD PTR [rdi+rax*<span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">0x80</span></span>] <span class="hljs-number"><span class="hljs-number">4046d</span></span>7: <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">4046d</span></span>9: c5 f5 fa c8 vpsubd ymm1,ymm1,ymm0 <span class="hljs-number"><span class="hljs-number">4046d</span></span>d: c5 fe <span class="hljs-number"><span class="hljs-number">7f</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>c <span class="hljs-number"><span class="hljs-number">07</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> vmovdqu YMMWORD PTR [rdi+rax*<span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">0x80</span></span>],ymm1 <span class="hljs-number"><span class="hljs-number">4046e4</span></span>: <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">4046e6</span></span>: <span class="hljs-number"><span class="hljs-number">48</span></span> <span class="hljs-number"><span class="hljs-number">83</span></span> c0 <span class="hljs-number"><span class="hljs-number">20</span></span> add rax,<span class="hljs-number"><span class="hljs-number">0x20</span></span> <span class="hljs-number"><span class="hljs-number">4046</span></span>ea: <span class="hljs-number"><span class="hljs-number">75</span></span> e4 jne <span class="hljs-number"><span class="hljs-number">4046d</span></span>0 &lt;_Z14benchmark_funcPi+<span class="hljs-number"><span class="hljs-number">0x10</span></span>&gt; <span class="hljs-number"><span class="hljs-number">4046</span></span>ec: c5 f8 <span class="hljs-number"><span class="hljs-number">77</span></span> vzeroupper <span class="hljs-number"><span class="hljs-number">4046</span></span>ef: c3 ret</code> </pre> <br>  We can notice that the code is aligned on the cache line (0x406c0 mod 0x40 == 0x0).  It's good.  But there is one more thing that we need to know about the architecture of Intel processors.  In my Skylake family processor I use a micro-instruction translation engine, MITE (Micro-instruction Translation Engine), which selects instructions for 16 bytes in one pass.  The important point here is that it is not just any 16 bytes, but 16 bytes from a window aligned 16-byte interval.  After these instructions have been selected, the decoder converts them into a sequence of smaller micro-operations (uops).  Further, these micro-operations are transferred to the following stages of implementation. <br><br>  But there is another hardware block called DSB (Decoded Stream Buffer), which, as its name implies, is a micro-operations cache.  If we want to execute some set of instructions that we have recently performed, we first check to see if there are any corresponding micro-operations in the DSB.  If they are there, it will save us not only from re-broadcasting their MITE, but even from reading them from RAM (which is generally excellent).  However, there are certain limitations that affect how microtools can get (or not get) into DSB, we will talk about this below. <br><br>  In the assembler commands above, you can see that the code was vectorized and we actually have only 4 loop iterations, which is good for this example, because otherwise LSD (Loop Stream Detector) would detect the loop and stop fetching instructions from the memory. <br><br>  More information about all these nuances of Intel architecture can be found in the document "Intel 64 and IA-32 Architectures Optimization Reference Manual".  You can also watch a good Zia Ansari <a href="https://www.youtube.com/watch%3Fv%3DIX16gcX4vDQ%26t%3D1228s">presentation</a> on this topic. <br><br><h2>  Code alignment matters </h2><br>  I think you already guess what will be discussed further.  Let's see how the benchmark_func () function is located in the code in both cases: <br><br>  "Base case": <br><br><img src="https://habrastorage.org/getpro/habr/post_images/324/aee/985/324aee9851fea2f8db176b6e7fc226c9.png" alt="image"><br><br>  "No_foo": <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f04/bae/0b4/f04bae0b48a08be3ec33117d3506ac59.png" alt="image"><br><br>  The thick rectangles in the pictures above indicate 32-byte windows, and the yellow background indicates the instructions of the loop body.  The first observation may be that in the second case, the entire loop code falls into one 32-byte window, and in the first case it is distributed between the two.  Indeed, in the second case, we have half as many misses when accessing DSB (DSB_MISS_PS 1800M vs 888M) and exactly zero DSH-MITE switching overhead (DSB2MITE_SWITCHES, PENALTY_CYCLES 888M vs 0).  But why in this case everything works 10% worse?  Probably, there is some other architectural feature that I have not yet taken into account. <br><br>  I conducted several experiments, testing my various hypotheses about how decoded instructions fit into the DSB, but still I‚Äôm not 100% sure that I fully understood this.  I laid out my experiments <a href="https://github.com/dendibakh/dendibakh.github.io/blob/master/_posts/code/CodeAlignment/DSB_layout.pdf">here</a> . <br><br>  Performance counters showed no anomalies.  The only thing you can pay attention to is the difference between the two cases in the parameter <br>  IDQ_UOPS_NOT_DELIVERED, CYCLES_0_UOPS_DELIV (4100M vs 5200M).  If you do not know what it is - look at the end of the article, there are explanations of all the counters used. <br><br><h2>  We go even further </h2><br>  I did two more experiments, obviously setting the alignment: -mllvm -align-all-functions = 5 and -mllvm -align-all-blocks = 5: <br><br><pre> <code class="bash hljs">$ ./aligned_functions.sh --------------------------------------------------------- Benchmark CPU Iterations Throughput Clockticks/iter --------------------------------------------------------- func_bench_median 3 ns 218294614 36.8538GB/s 63.37 $ ./aligned_blocks.sh --------------------------------------------------------- Benchmark CPU Iterations Throughput Clockticks/iter --------------------------------------------------------- func_bench_median 3 ns 262104631 44.3106GB/s 46.25</code> </pre> <br>  When aligning benchmark_func () on the 32-byte boundary, I received + 13% performance, and on aligning all the basic blocks (including the beginning of the function) in the benchmark_func () function on the 32-byte boundary, I received + 36% speed increase.  Funny, right? <br><br>  The location of the function for the case with the alignment function is not much different from the "base" case: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc4/e76/2f3/fc4e762f39d12b5351861c1da7cd2e7a.png" alt="image"><br><br>  That is, we are dealing with some kind of problem with DSB, as in the "base" case.  The counters show even worse DSB utilization: DSB_MISS_PS 2600M vs 1800M.  What is even more important is to compare the counter readings IDQ_UOPS_NOT_DELIVERED, CYCLES_0_UOPS_DELIV: 330M vs 4100M.  In the end, what is really important for us is to ensure that the backend is filled with decoded micro-instructions. <br><br>  Now the case with aligned base blocks: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/86e/051/c06/86e051c0618367543981bbd00db36c04.png" alt="image"><br><br>  It is interesting in that there is both a high level of DSB usage and a low number of cycles in which there were no microinstructions delivered.  Look at the table below for specific counters. <br><br><h2>  Used performance counters </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/841/cf5/01c/841cf501c4d4199d1fa7af314367757e.png" alt="image"><br><br>  Here is an explanation of the column headers of this table: <br><br>  <b>FRONTEND_RETIRED.DSB_MISS_PS</b> - counts instructions for which a search miss in DSB (Decode Stream Buffer) occurred <br><br>  <b>DSB2MITE_SWITCHES.PENALTY_CYCLES</b> - counts penalty cycles when switching between DSB and MITE.  A request to DSB, in which the required instructions were not found and had to contact MITE, may in the worst case cost up to 6 cycles in which no micro-operations are transferred to IDQ.  As a rule, it takes up to 2 cycles. <br><br>  <b>IDQ.ALL_DSB_CYCLES_4_UOPS</b> - counts the number of <b>ticks</b> in which exactly 4 micro-instructions were delivered to the Instruction Decode Queue (IDQ) from Decode Stream Buffer (DSB) <br><br>  <b>IDQ.ALL_DSB_CYCLES_ANY_UOPS</b> ‚Äî counts the number of <b>ticks</b> in which microtools were delivered to the Instruction Decode Queue (IDQ) from Decode Stream Buffer (DSB) <br><br>  <b>IDQ_UOPS_NOT_DELIVERED.CORE</b> ‚Äî counts the number of micro-operations not delivered to the Resource Allocation Table (RAT) for each thread, adding ‚Äú4-x‚Äù when the Instruction Decode Queue (IDQ) delivers x micro-operations to the Resource Allocation Table (RAT) (x belongs to {0 1,2,3}) <br><br>  <b>IDQ_UOPS_NOT_DELIVERED.CYCLES_0_UOPS_DELIV.CORE</b> ‚Äî counts, for each stream, the number of cycles in which micro-operations were not delivered to the Resource Allocation Table (RAT).  IDQ_Uops_Not_Delivered.core = 4. <br><br><h2>  Cautions </h2><br>  For this particular case, all these problems with alignment will disappear if we, for example, increase the number of iterations to 1024. At this point, the cycle detector (LSD) will work.  He will understand that we are in a cycle and follow the same instructions over and over again.  Then it will simply disable reading the instructions from the memory and run their execution from its internal buffer.  At this moment it becomes completely irrelevant how our instructions are located and aligned in memory. <br><br>  Another interesting example is that I got a 10% drop in performance when I used the <a href="https://ru.wikipedia.org/wiki/Gold_(%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25BF%25D0%25BE%25D0%25BD%25D0%25BE%25D0%25B2%25D1%2589%25D0%25B8%25D0%25BA)">gold</a> linker.  This is not because it is somehow bad, but again, because of the alignment of the code. <br><br><h2>  Why not align the code always? </h2><br>  Alignment means that the compiler inserts NOP instructions into the code.  This increases the size of the binary and can also hit on performance if these NOP instructions fall into some frequently used cycle.  Execution of NOP instructions is not absolutely free - they still need to be read from memory and decoded. <br><br><h2>  findings </h2><br>  As you can see, even such a small amount of code can be difficult.  I do not think that all of us should be experts in microprocessor architecture, but it is worth at least knowing that such problems may exist.  Be aware that once measured function performance may change in the future even without changing the code of this function.  If this is an important point for you - do not forget to take additional measures of performance to identify problems like the one described in this article. </div><p>Source: <a href="https://habr.com/ru/post/347394/">https://habr.com/ru/post/347394/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347384/index.html">Where to find and how to choose timlid</a></li>
<li><a href="../347386/index.html">The whole truth about VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps from $ 20 or how to share the server?</a></li>
<li><a href="../347388/index.html">Social Architecture: The Importance of Contracts and Unlimited Property</a></li>
<li><a href="../347390/index.html">How to build a REST-like API in a large project</a></li>
<li><a href="../347392/index.html">VIPER and UITableView / UICollectionView with simple cells</a></li>
<li><a href="../347398/index.html">Application Security with Citrix NetScaler</a></li>
<li><a href="../347400/index.html">Security Week 1: Witnesses do not steal, old deep exploits, Google Play against swinishness</a></li>
<li><a href="../347402/index.html">How can a beginner contribute to an open source project with 20K stars?</a></li>
<li><a href="../347404/index.html">Scrum implementation by techie: real experience, pitfalls, tips & tricks</a></li>
<li><a href="../347406/index.html">Python for teaching science informatics: Simulating Queuing Systems</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>