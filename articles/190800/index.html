<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write our debugger for Windows [part 2]</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Be sure to read the first part if you have not done it yet. Otherwise it will be difficult to understand the second part. 

 Foreword 
 This article i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write our debugger for Windows [part 2]</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/b83/312/722/b833127225577b16a71ccf4cdf78ff40.jpg"><br><br>  Be sure to read the <a href="http://habrahabr.ru/post/154847/">first part</a> if you have not done it yet.  Otherwise it will be difficult to understand the second part. <br><br><h1>  Foreword </h1><br>  This article is a continuation of the previous part of ‚ÄúWriting Your Debugger for Windows‚Äù.  It is very important that you read and understand it.  Without a complete understanding of what is written in the first part, you will not be able to understand this article and evaluate all the material in its entirety. <br>  The only thing that remained unmentioned in the previous article is that our debugger can only debug the machine code.  You can‚Äôt start debugging managed code.  Maybe, if there is a fourth part of the article, I will also consider debugging and managed code in it. <br>  I would like to show you some important aspects of debugging.  They will include showing the source code and the callstack, setting breakpoints, entering the executable function (step into), attaching the debugger to the process, setting the default system debugger and some others. <br><a name="habracut"></a><br>  Task list: <br><ul><li>  Start debugging with main () function </li><li>  Getting the process start address </li><li>  Breakpoint Settings on the Start Address </li><li>  Breakpoint Stop, Cancellation Instructions </li><li>  Stop debugging and waiting for user actions </li><li>  Continue debugging on user command </li></ul><br><ul><li>  CDebuggerCore - debug interface class </li></ul><br><ul><li>  Getting source codes and line numbers </li><li>  Setting custom breakpoints </li><li>  Code tracing (step-in, step-out, step-over) </li><li>  Conditional breakpoints </li><li>  Debugging a running process </li><li>  Disconnect from process, shutdown or wait? </li><li>  Debugging a Fallen Process </li><li>  Manually connecting the debugger </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Let's start debugging! </h1><br>  So, what do you do when you want to debug your program?  Well, for the most part, we press F5 to start debugging applications and the Visual Studio debugger will stop the program execution in those places where you set breakpoints (including conditional ones).  Clicking the ‚ÄúRepeat‚Äù button in the ‚ÄúDebug Assertion Failed‚Äù dialog box also opens the source code in the right place and stops the execution.  Calling DebugBreak or _asm int 3 instructions do the same.  And this is a small part of the ‚Äúhow to debug an application‚Äù options. <br>  Rarely or from time to time, we start debugging from the very beginning by pressing F11 (step-into), and VS starts debugging with the functions main / wmain or WinMain / wWinMain (or with the _t prefix).  Well, this is the logical starting address of the process being debugged.  I call it ‚Äúlogical‚Äù because it is not a real starting address, which is also known as the entry point of the module.  For console applications, this is the mainCRTStartup function, which then calls the main function and the Visual Studio debugger starts with main.  Dll libraries can also have their own entry point.  If you want to know a little more, read the information on the / ENTRY flag. <br>  All this means that we must pause the program at the entry point of the application and allow the developer to continue debugging.  Yes, I said ‚Äúsuspend‚Äù the execution of the program at the input point of the module ‚Äî the process is already running, and if we do not suspend it, it will end somewhere.  The call stack (image below) will appear as soon as you press F11. <br><img src="https://habrastorage.org/getpro/habr/post_images/9b3/d1a/066/9b3d1a066dd858328dc4008f8e781ae6.jpg"><br>  What do we need to do to pause the process at the entry point? <br>  In a nutshell: <br><ol><li>  Get process start address </li><li>  Change the instruction at this address - for example, replace it with a breakpoint instruction (_asm int 3) </li><li>  Process the program stop as soon as the execution reaches this breakpoint, restore the original instruction </li><li>  Stop execution, show call stack, registers and source code, if possible </li><li>  Continue execution upon user request. </li></ol><br>  Just five points!  But the task, in fact, not easy. <br><br><h2>  Getting the process start address </h2><br>  The starting address of the entry point and logical * entry point (function main / WinMain) - these are jungle!  Before telling you in a few words about these concepts, let me give you a visual idea of ‚Äã‚Äãthis.  But the first thing you need to understand: the first instruction for this address is the starting point of the program and the debugger only works with this address. <br>  * [This term is coined by me and only relates to this article!] <br>  This is how the WinMain function in disassembled form in Visual Studio looks like (with annotations): <br><img src="https://habrastorage.org/storage2/c21/3bb/326/c213bb32680038da67e7409faafb3e1d.jpg"><br>  You can switch to the same view by running debugging, clicking the right mouse button and selecting ‚Äúto disassembled code‚Äù.  Code bytes are not displayed by default (highlighted in green), but you can enable them through the context menu. <br>  Relax!  You do not need to understand the instructions either in machine language or in any dialect of assembler!  This is just for illustration.  In the example above, 0x00978F10 is the starting address, and 8B FF is the first instruction.  We just need to replace it with a breakpoint instruction.  We know that such an API function is called DebugBreak, but at such a low level we cannot use it.  For x86, the instruction is a breakpoint _asm int 3. It names code 0xCC (204). <br>  It turns out that we just need to replace the value of byte 8B with CC and that's it!  When the program is launched, the exception EXCEPTION_DEBUG_EVENT with the code EXCEPTION_BREAKPOINT will be generated in this place.  We know that it was we who did this, and after that we handle this exception in the way we need it.  If you did not understand this paragraph, I ask you for the last time, first read the first part of the article [http://habrahabr.ru/post/154847/]. <br>  X86 instructions are not fixed length, but who cares?  We do not need to see how many bytes (1, 2, N) the instruction takes.  We just change the first byte.  The first byte of the instruction can be anything, not just 8B.  But we must ensure that as soon as the time comes to continue the execution of the program, we will restore the original byte. <br>  A small remark for those who know everything and for those who do not know something.  First, breakpoints are not the only way to stop a program from running at the starting address.  A better alternative is one-time breakpoints, which we'll discuss later.  Secondly, the CC instruction is not the only breakpoint instruction, but for us it is enough for the eyes. <br>  There are some difficulties with getting the starting address, but to keep your interest, let me immediately show the C ++ code to get the starting address.  The lpStartAddress member in the CREATE_PROCESS_DEBUG_INFO structure contains the starting address.  We can read this information while processing the very first debugging event: <br><br><pre><code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> This <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> inside Debugger-<span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> controlled <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> WaitForDebugEvent, ContinueDebugEvent <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(debug_event.dwDebugEventCode) { case CREATE_PROCESS_DEBUG_EVENT: { LPVOID pStartAddress = (LPVOID)debug_event.u.CreateProcessInfo.lpStartAddress; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Do something with pStartAddress to set BREAKPOINT. ... ...</code> </pre> <br><br>  The type CREATE_PROCESS_DEBUG_INFO :: lpStartAddress is LPTHREAD_START_ROUTINE, and I think you know what it is (function pointer).  But, as I said, there are some difficulties with the starting address.  In short, this address is relative to where the application image was loaded into memory.  To make me more convincing, let me show you the output of dumpbin utilities with the / headers option: <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">dumpbin</span></span> /headers <span class="hljs-type"><span class="hljs-type">DebugMe</span></span>.exe ... <span class="hljs-type"><span class="hljs-type">OPTIONAL</span></span> <span class="hljs-type"><span class="hljs-type">HEADER</span></span> <span class="hljs-type"><span class="hljs-type">VALUES</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>B magic # (<span class="hljs-type"><span class="hljs-type">PE32</span></span>) <span class="hljs-number"><span class="hljs-number">8.00</span></span> linker version <span class="hljs-type"><span class="hljs-type">A000</span></span> size <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> code <span class="hljs-type"><span class="hljs-type">F000</span></span> size <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> initialized <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> 0 size of uninitialized </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> 11767 entry point (00411767) @</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ILT</span></span></span><span class="hljs-class">+1890(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_wWinMainCRTStartup</span></span></span><span class="hljs-class">) 1000 base of code</span></span></code> </pre><br><br>  This address (00411767) is stored in lpStartAddress while debugging our application.  But when I started debugging from within Visual Studio, the address of wWinMainCRTStartup was different from this (@ILT has nothing to do with this). <br>  Thus, let me postpone the discussion of the intricacies of obtaining a starting address and simply use the GetStartAddress () function, the code of which will be shown later.  It will return the exact address where you should set a breakpoint! <br><br><h2>  Change instruction at start address to breakpoint instruction </h2><br>  As soon as we get the start address, changing the instructions at this point to a breakpoint (CC) is quite trivial.  We need to do: <br><ol><li>  Read one byte at this address and save it. </li><li>  Write in its place byte 0xCC </li><li>  Clear instruction cache </li><li>  Continue debugging </li></ol><br>  Now you need to ask two important questions: <br><ol><li>  How to count, write and reset instructions? </li><li>  When do we do this? </li></ol><br>  Let me answer the second question first.  We will read, write and reset instructions during the processing of the CREATE_PROCESS_DEBUG_EVENT event (or, at your discretion, at the time of EXCEPTION_BREAKPOINT).  When the process starts to load, we get the real starting address (I mean the CRT-Main address), read the first instruction at this address, save it, and write to this place byte 0xCC.  Then we call our debugger ContinueDebugEvent (). <br>  For a better understanding, let me show you the code: <br><br><pre> <code class="hljs pgsql">DWORD dwStartAddress = GetStartAddress(m_cProcessInfo.hProcess, m_cProcessInfo.hThread); BYTE cInstruction; DWORD dwReadBytes; // <span class="hljs-keyword"><span class="hljs-keyword">Read</span></span> the first instruction ReadProcessMemory(m_cProcessInfo.hProcess, (<span class="hljs-type"><span class="hljs-type">void</span></span>*)dwStartAddress, &amp;cInstruction, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;dwReadBytes); // Save it! m_OriginalInstruction = cInstruction; // Replace it <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> Breakpoint cInstruction = <span class="hljs-number"><span class="hljs-number">0xCC</span></span>; WriteProcessMemory(m_cProcessInfo.hProcess, (<span class="hljs-type"><span class="hljs-type">void</span></span>*)dwStartAddress,&amp;cInstruction, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;dwReadBytes); FlushInstructionCache(m_cProcessInfo.hProcess,(<span class="hljs-type"><span class="hljs-type">void</span></span>*)dwStartAddress,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br><br>  A little bit about the code: <br>  ‚Ä¢ M_cProcessInfo is a member of our class, which is nothing more than PROCESS_INFORMATION, filled with the CreateProcess function. <br>  ‚Ä¢ The GetStartAddress () function returns the starting address of the process.  For a unicode user interface application, this is the address of the wWinMainCRTStartup () function; <br>  ‚Ä¢ Then we call ReadProcessMemory to get the byte located at the start address and save its value <br>  ‚Ä¢ After this, write a breakpoint instruction (0xCC) at this address using the WriteProcessMemory function <br>  ‚Ä¢ Finally, call FlushInstructionCache so that the CPU reads the new instruction, and not any cached old one.  The CPU, of course, may not zasherovat instruction, but you always have to call FlushInstructionCache. <br>  Note that ReadProcessMemory requires PROCESS_VM_READ rights.  In addition, WriteProcessMemory requires PROCESS_VM_READ |  PROCESS_VM_OPERATION - all these permissions are granted to the debugger as soon as it passes the debug flag to CreateProcess.  Thus, we do not need to do anything and reading / writing will always be successful (with valid memory addresses, of course!). <br><br><h2>  Processing breakpoint instructions and restoring original instructions </h2><br>  As you know, breakpoint instruction (EXCEPTION_BREAKPOINT) is the type of exception that comes with the EXCEPTION_DEBUG_EVENT debugging event.  We handle debug events using the EXCEPTION_DEBUG_INFO structure.  The code below will help you remember and understand: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Inside <span class="hljs-keyword"><span class="hljs-keyword">debugger</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(debug_event.dwDebugEventCode) { case EXCEPTION_DEBUG_EVENT: { EXCEPTION_DEBUG_INFO &amp; Exception = debug_event.u.Exception; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Out <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> union <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Exception.ExceptionCode would be the actual exception code. ...</code> </pre><br><br>  The operating system will always send one breakpoint instruction to the debugger, which will indicate that the process is loading.  That is why you can ‚Äúset the breakpoint instruction at the starting address‚Äù at the very first exception of the breakpoint.  This ensures that all breakpoints after the first one are yours. <br>  No matter where your breakpoints are, you still need to ignore the first breakpoint event.  Although debuggers, for example, WinDbg, will show you this breakpoint, the Visual Studio debugger will ignore this breakpoint and start execution from the logical beginning of the program (main / WinMain, not CRT-Main). <br>  Thus, the interrupt handling code will look like this: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">'Exception'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the same variable declared above <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(Exception.ExceptionRecord.ExceptionCode) { case EXCEPTION_BREAKPOINT: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_bBreakpointOnceHit) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Would be set to <span class="hljs-literal"><span class="hljs-literal">false</span></span>, before debugging starts { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle the actual breakpoint event } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> This <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> first breakpoint event sent <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kernel, just ignore it. <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Optionally display to the user that first BP was ignored. m_bBreakpointOnceHit = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ...</code> </pre><br><br>  You can also use the else-part to set a breakpoint instead of setting it during the process start event.  In any case, the main processing of the breakpoint event occurs in the if part.  We need to handle a breakpoint that we placed at the starting address. <br>  It becomes difficult and intriguing - concentrate, read carefully, sit relaxed.  If you haven't had a break while you read this article, make it! <br>  In simple terms, the breakpoint event occurred where we placed it.  Now we simply interrupt the execution, show the call stack (and other useful information), return the original instruction and wait for any action from the user to continue debugging. <br>  At the assembler or machine code level, when a breakpoint event was generated and sent to the debugger, the instruction has already been executed, although it was just one byte in size.  The instruction pointer has already moved to this byte. <br>  Thus, in addition to recording the original instructions at our address, we also need to correct the processor registers.  We can get and set registers of our process specifically using the GetThreadContext and SetThreadContext functions.  Both functions take on a context structure.  Strictly speaking, the members of this structure depend on the processor architecture.  Since this article focuses on the x86 architecture, we will follow the same structure definition, which can be found in the header file winnt.h. <br>  Here is how we can get the flow context: <br><br><pre> <code class="hljs 1c">CONTEXT lcContext; lcContext.ContextFlags = CONTEXT_ALL; GetThreadContext(m_cProcessInfo.hThread, <span class="hljs-meta"><span class="hljs-meta">&amp;lcContext); ,   .  ?   EIP     </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> .    Eip  CONTEXT.     , EIP        .   </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> ,          ,       </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">   .      : lcContext.Eip --; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Move back one byte SetThreadContext(m_cProcessInfo.hThread, &amp;lcContext);</span></span></span></span></code> </pre><br><br>  EIP is the address at which the processor will read the next instruction and execute it.  You need THREAD_GET_CONTEXT and THREAD_SET_CONTEXT rights to successfully perform these functions, and you already have them. <br>  Let me briefly switch to another topic: restoring the original instructions!  To write the original instruction in the running process, we need to call WriteProcessMemory, followed by FlushInstructionCache.  Here is how it is done: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">dwWriteSize</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">WriteProcessMemory</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">m_cProcessInfo</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.hProcess</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">StartAddress</span></span>, &amp;<span class="hljs-selector-tag"><span class="hljs-selector-tag">m_cOriginalInstruction</span></span>, 1,&amp;<span class="hljs-selector-tag"><span class="hljs-selector-tag">dwWriteSize</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">FlushInstructionCache</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">m_cProcessInfo</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.hProcess</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">StartAddress</span></span>, 1);</code> </pre><br><br>  Original instructions restored.  We can call ContinueDebugEvent.  What we did: <br><ol><li>  GetThreadContext, reduce EIP by one, SetThreadContext. </li><li>  Restore the original instructions </li><li>  Continue debugging </li></ol><br>  Well, where is the call stack?  Registers?  Source?  And when will the program end?  All this will be without user interaction! <br><br><h2>  Stop execution, call stack, register values ‚Äã‚Äãand source code, if any </h2><br>  To display the call stack, we need to load debugging symbols, which are stored in existing * .PDB files.  The set of functions from DbgHelp.dll helps us to load symbols, list the source code of files, trace the call stack and much more.  And all this will be considered later. <br>  To display the CPU registers, we just need to display the actual data from the CONTEXT structure.  To display 10 registers as in the Visual Studio debugger (Debug -&gt; Windows -&gt; Registers or Alt + F5) you can use the following code: <br><br><pre> <code class="hljs perl">CString strRegisters; strRegisters.Format( L<span class="hljs-string"><span class="hljs-string">"EAX = %08X\nEBX = %08X\nECX = %08X\n"</span></span> L<span class="hljs-string"><span class="hljs-string">"EDX = %08X\nESI = %08X\nEDI = %08X\n"</span></span> L<span class="hljs-string"><span class="hljs-string">"EIP = %08X\nESP = %08X\nEBP = %08X\n"</span></span> L<span class="hljs-string"><span class="hljs-string">"EFL = %08X"</span></span>, lcContext.Eax, lcContext.Ebx, lcContext.Ecx, lcContext.Edx, lcContext.Esi, lcContext.Edi, lcContext.Eip, lcContext.Esp, lcContext.Ebp, lcContext.EFlags );</code> </pre><br><br>  And that's it!  Display this text in the appropriate window. <br>  To suspend program execution until the user gives the appropriate command (Continue, Step-in, Stop Debugging, etc.), we should not call ContinueDebugEvent.  Since the debug stream and GUI stream are different, we simply ask the GUI stream to display the actual information and freeze the debug stream until some ‚Äúevent‚Äù arrives, for example, from the user. <br>  Confused?  The word "event" is in quotation marks, since it is nothing more than an event created by the CreateEvent function.  To suspend program execution, we call WaitForSingleObject (in the debugger thread).  To restart the debugger thread, we simply call SetEvent from the GUI thread.  Of course, depending on your preferences, you can use other technologies to synchronize threads.  This clause provides only a general idea of ‚Äã‚Äãthe implementation of the function ‚Äúsuspend execution - continue execution‚Äù. <br>  Now, thanks to this reasoning, we can write code logic: <br><ol><li>  GetThreadContext, reduce EIP by one, SetThreadContext </li><li>  Return original instruction using WriteProcessMemory, FlushInstructionCache </li><li>  Display current register values </li><li>  Using the functions of character information * .PDB files, display the source code and line number (if possible) </li><li>  Using call stack trace functions and character information functions, get a call stack and display it </li><li>  Waiting for user response </li><li>  Execution of the event requested by the user (Continue, Step, Stop, ...) </li><li>  Calling ContinueDebugEvent </li></ol><br>  Surprised?  Fine!  I hope you enjoy debugging! <br>  One important point that is worth mentioning is that a thread that is being debugged cannot be the primary thread being debugged, but it must call a breakpoint instruction.  Until now, we are still handling the first breakpoint event to pause program execution.  But those eight stages that I have listed above will apply to all debugging events (from any stream being debugged) that can pause the execution of the program. <br>  There are still minor difficulties with changing EIP.  Let me tell you about the problem itself, and I will show you the solution to it later.  The breakpoint can be set by the user, and we also replace the instructions for these addresses with CC (of course, keeping the original instructions).  As soon as program execution reaches the next breakpoint, we simply return the instruction and execute the 8 steps that I described above.  Enough detail?  Well, if we do this, then the program will pause in this place only once, and if we do not return the original instruction, then we will have complete confusion! <br><br>  Anyway, let me continue! <br>  Oh yes!  Source!  I know you already want to know how to do it to death! <br>  Any * .EXE and * .DLL image can have debugging information supplied with it in the * .PDB file.  A little about this: <br><ul><li>  Debugging information will be available only if the / DEBUG flag was set when compiling with the linker.  In Visual Studio, you can change this in the project properties (Linker-&gt; Debugging -&gt; Generate Debug Info). </li><li>  The / DEBUG flag does not mean that the EXE / DLL will be compiled in a debug configuration.  The _DEBUG / DEBUG preprocessor macros are processed at compile time.  But the rest is already during linking. </li><li>  This means that even in the Release configuration, the image may contain debug information, and in the Debug configuration it may not. </li><li>  A file with the * .PDB extension stores debugging information and is usually named &lt;program_name&gt; .pdb, but you can rename it using the linker options.  The file contains all the information about the source code: functions, classes, types, and more. </li><li>  The linker places a small piece of information about the * .PDB file in the header of the EXE / DLL image.  Since this information is placed in the header, this does not affect file performance, only the file size is increased by several bytes / kilobyte. </li></ul><br>  To get debug information, we need to use the Sym * functions inside DbgHelp.Dll.  This library is the most important component of debugging at the source code level.  It also contains call stack trace functions and for getting information about an EXE / DLL image.  To use them you need to connect Dbghelp.h and DbgHelp.lib. <br>  To get debugging information, you need to initialize the symbol handler for this process.  Since our target process is debugee, we initialize it with a debugee identifier.  To initialize the symbol handler, we need to call the SymInitialize function: <br><br><pre> <code class="hljs objectivec"><span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> bSuccess = SymInitialize(m_cProcessInfo.hProcess, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br><br>  The first parameter is the ID of the running process for which character information is required.  The second parameter is the paths where you should look for the * .PDB file, separated by a semicolon.  The third parameter indicates whether the symbol handler should automatically load characters for all modules or not. <br>  Now the lines below make sense: <br><br><pre> <code class="hljs lua"><span class="hljs-string"><span class="hljs-string">'Debugger.exe'</span></span>: Loaded <span class="hljs-string"><span class="hljs-string">'C:\Windows\SysWOW64\msvcrt.dll'</span></span>, Cannot <span class="hljs-built_in"><span class="hljs-built_in">find</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-built_in"><span class="hljs-built_in">open</span></span> the PDB file <span class="hljs-string"><span class="hljs-string">'Debugger.exe'</span></span>: Loaded <span class="hljs-string"><span class="hljs-string">'C:\Windows\SysWOW64\mfc100ud.dll'</span></span>, Symbols <span class="hljs-built_in"><span class="hljs-built_in">loaded</span></span>.</code> </pre><br><br>  Visual Studio 2010 could not find the symbols for msvcrt.dll.  And the mfc100ud.dll library has its own debug symbols, so Visual Studio was able to download them.  Essentially, this means that for MFC libraries, Visual Studio will display symbolic information, source code, class / function names, stack stack, and so on.  To explicitly load symbols for the corresponding libraries / exe-files, we call the function SymLoadModule64 / SymLoadModuleEx. <br>  Where and when should we call these functions?  It took me a lot of time while I tried to initialize and load debugging information before the debug loop (i.e. before any debugging event, but after CreateProcess).  It did not work.  This must be done when processing CREATE_PROCESS_DEBUG_EVENT.  Since we refuse to automatically load symbols from dependent modules, we need to call the SymLoadModule64 / Ex function for the newly downloaded EXE file.  For incoming events LOAD_DLL_DEBUG_EVENT, we also need to call this function.  Depending on the module settings, we will either be able to show debug information to the user, or not. <br>  Below you can see an example of debugging information loading code when processing a library loading event.  The GetFileNameFromHandle function is described in the previous part of the <a href="http://habrahabr.ru/post/154847/">article</a> . <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LOAD_DLL_DEBUG_EVENT: { CStringA sDLLName; sDLLName = GetFileNameFromHandle(debug_event.u.LoadDll.hFile); DWORD64 dwBase = SymLoadModule64 (m_cProcessInfo.hProcess, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, sDLLName, <span class="hljs-number"><span class="hljs-number">0</span></span>, (DWORD64)debug_event.u.LoadDll.lpBaseOfDll, <span class="hljs-number"><span class="hljs-number">0</span></span>); strEventMessage.Format(L<span class="hljs-string"><span class="hljs-string">"Loaded DLL '%s' at address %x."</span></span>, sDLLName, debug_event.u.LoadDll.lpBaseOfDll); ...</code> </pre><br><br>  Of course, the similar code will be also when loading process.  A small caveat: successful initialization of debugging information and its successful download does not mean that the source code will be available!  We need to call SymGetModuleInfo64 to load information from * .PDB, if it is available.  Here is how it is done: <br><br><pre> <code class="hljs pgsql">// Code continues <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> above IMAGEHLP_MODULE64 module_info; module_info.SizeOfStruct = sizeof(module_info); <span class="hljs-type"><span class="hljs-type">BOOL</span></span> bSuccess = SymGetModuleInfo64(m_cProcessInfo.hProcess,dwBase, &amp;module_info); // <span class="hljs-keyword"><span class="hljs-keyword">Check</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">notify</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bSuccess &amp;&amp; module_info.SymType == SymPdb) { strEventMessage += ", Symbols Loaded"; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { strEventMessage +=", No debugging symbols found."; }</code> </pre><br><br>  I am very grateful to Jochen Kalmbach for his excellent article on stack tracing, which helped me to find information about the source code and stack trace. <br>  When the symbol type is symPdb, we have information about the source code.  * .PDB contains only information about the source code, the source code itself (the files * .h and * .cpp) must be available at the specified path!  * .PDB contains character names, file names, line numbers and more.  Tracing the stack (without reviewing the source code) is quite possible if we have function names. <br>  Finally, when a breakpoint event arrives, we can get a call stack and show it.  To do this, we need to call the StackWalk64 function.  Below you can look at the trimmed sample code that uses this function.  Please, for a full understanding, read the article by Jochen Kalmbach, about which I spoke. <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RetrieveCallstack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HANDLE hThread)</span></span></span><span class="hljs-function"> </span></span>{ STACKFRAME64 <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>={<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// Initialize 'stack' with some required stuff. StackWalk64(IMAGE_FILE_MACHINE_I386, m_cProcessInfo.hProcess, hThread, &amp;stack, &amp;context, _ProcessMemoryReader, SymFunctionTableAccess64, SymGetModuleBase64, 0); ...</span></span></code> </pre><br><br>  STACKFRAME64 is a data structure that contains addresses from which information about the call stack is extracted.  As Jochen writes, for x86 we need to initialize this structure before calling the function StackWalk64: <br><br><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">CONTEXT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>.ContextFlags = CONTEXT_FULL; GetThreadContext(hThread, &amp;<span class="hljs-keyword"><span class="hljs-keyword">context</span></span>); // Must be like this stack.AddrPC.Offset = <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>.Eip; // EIP - Instruction Pointer stack.AddrPC.Mode = AddrModeFlat; stack.AddrFrame.Offset = <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>.Ebp; // EBP stack.AddrFrame.Mode = AddrModeFlat; stack.AddrStack.Offset = <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>.Esp; // ESP - Stack Pointer stack.AddrStack.Mode = AddrModeFlat;</code> </pre><br><br>  When calling StackWalk64, the first constant determines the type of machine that is x86.  The next argument is the ID of the process being debugged.  The third is the thread ID in which we will receive the call stack (not necessarily the main thread).  The fourth parameter is the most important parameter for us.  The fifth is the context of the structure that has the necessary addresses for initialization.  The _ProcessMemoryReader function is a function we declared that does nothing except call ReadProcessMemory.  The other two Sym * functions are from DbgHelp.dll.  The last parameter is also a function pointer, but we do not need it. <br>  To trace the call stack, you definitely need a loop until the trace ends.  While such questions are open as: an invalid call stack, an endless call stack and some others, I decided to do it in a simple way: call the function until the returned address becomes NULL or until StackWalk64 is executed abnormally.  Below is shown how we will receive the call stack (the function names will be received a bit later): <br><br><pre> <code class="hljs bash">BOOL bSuccess; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { bSuccess = StackWalk64(IMAGE_FILE_MACHINE_I386, ... ,0); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!bTempBool) <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; // Symbol retrieval code goes here. // The contents of <span class="hljs-string"><span class="hljs-string">'stack'</span></span> would <span class="hljs-built_in"><span class="hljs-built_in">help</span></span> determining symbols. // Which would put information <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a vector. }<span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( stack.AddrReturn.Offset != 0 );</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The debugging symbol has several properties: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Module name (exe or dll) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Symbol name - decorated or not decorated </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Symbol type: function, class, parameter, local variable, etc. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Virtual symbol address </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The stack trace also includes: source file, line number, first processor instruction on this line. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although we do not need the first instruction of the processor on this line, as long as we do not disassemble the code, we may need to move relative to the first instruction. </font><font style="vertical-align: inherit;">So it happens, the code at the source code level contains several instructions in one line (for example, multiple function calls). </font><font style="vertical-align: inherit;">For now, I omit it. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, we need: the name of the module, the name of the function being called and the line number in order to form complete stack data.</font></font><br>    ,    ,    SymGetModuleInfo64.  ,          ‚Äì SymLoadModuleXX,       SymGetModuleInfo64    .   (      StackWalk64  ),        : <br><br><pre> <code class="hljs cpp">IMAGEHLP_MODULE64 <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>={<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>.SizeOfStruct = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>); SymGetModuleInfo64(m_cProcessInfo.hProcess, (DWORD64)<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.AddrPC.Offset, &amp;<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>);  <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>.ModuleName      ,    .  <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>.MoadedImageModule       . Module.LineNumbers  ,        (<span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äì ).        .         ,   SymGetSymFromAddr64  SymFromAddr.       PIMAGEHLP_SYMBOL64,     <span class="hljs-number"><span class="hljs-number">6</span></span> ,     ( ,  )  SYMBOL_INFO.    ,    ,    ‚Äì   .     : IMAGEHLP_SYMBOL64 *pSymbol; DWORD dwDisplacement; pSymbol = (IMAGEHLP_SYMBOL64*)<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BYTE[<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(IMAGEHLP_SYMBOL64)+MAX_SYM_NAME]; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(pSymbol, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(IMAGEHLP_SYMBOL64) + MAX_SYM_NAME); pSymbol-&gt;SizeOfStruct = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(IMAGEHLP_SYMBOL64); <span class="hljs-comment"><span class="hljs-comment">// Required pSymbol-&gt;MaxNameLength = MAX_SYM_NAME; // Required SymGetSymFromAddr64(m_cProcessInfo.hProcess, stack.AddrPC.Offset, &amp;dwDisplacement, pSymbol); // Retruns true on success</span></span></code> </pre><br><br>     : <br><ul><li>      .  ,         .   MAX_SYM_NAME   2000. </li><li>  IMAGEHLP_SYMBOL64       DbgHlp.dll   .          (       ‚Äî . .), SizeOfStruct     ,     .  MaxNameLength  . </li><li>       : Name (,  )  Address,      (   ). </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using SymFromAddr and initializing SYMBOL_INFO is almost the same, and I prefer to use this new feature. Although now she cannot give us any additional information, then I will explain all the fields of this structure as needed. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, to finish working with the call stack, we need to get the path to the source code and the line number. I remind you that the * .PDB file contains this information only if the debugging symbols were successfully loaded. Also, the PDB contains only the source code information, not the source code.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To get the information with the line number, we need to use SymGetLineFromAddr64 and get it through the IMAGEHLP_LINE64 structure. This function takes 4 arguments, and the first three coincide with the function described above. It is only necessary to initialize the structure with the correct size. It looks like this:</font></font><br><br><pre> <code class="hljs pgsql">IMAGEHLP_LINE64 <span class="hljs-type"><span class="hljs-type">line</span></span>; <span class="hljs-type"><span class="hljs-type">line</span></span>.SizeOfStruct = sizeof(<span class="hljs-type"><span class="hljs-type">line</span></span>); bSuccess = SymGetLineFromAddr64(m_cProcessInfo.hProcess, (DWORD)stack.AddrPC.<span class="hljs-keyword"><span class="hljs-keyword">Offset</span></span>, &amp;dwDisplacement, &amp;<span class="hljs-type"><span class="hljs-type">line</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(bSuccess) { // Use <span class="hljs-type"><span class="hljs-type">line</span></span>.FileName, <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-type"><span class="hljs-type">line</span></span>.LineNumber }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The functions of the debugging symbols or any other functions from DbgHlp.dll do not support the loading of the source code and its display. We have to do it ourselves. If the string information or source file is not available, we will not be able to display the source code. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the time of this writing, I have not yet decided what will be displayed if the source code is not available. We can show a set of instructions, but the x86 instructions are not fixed size. We can simply show a sequence of bytes (for example, "55 04 FF 76 78 AE ...") in one line. Or we can disassemble the instructions and show the result. Although I have a module for disassembling x86 code, it does not understand all the instructions.</font></font><br>   ,           .       ,      ,      ,   ,   ,  ,       ,      UI.   ,      Windows            . <br><br><h2>           </h2><br>     ,    ,     ContinueDebugEvent.   ,       . <br>        (UT ‚Äì  , DT ‚Äì  ): <br> [UT]        .      UI. <br> [DT]     CreateEvent. <br> [DT]      CreateProcess     . <br> [DT]    ,     . <br> [DT]   WaitForSingleObject   DT    <br> [UT]   - ,    (,     ) <br> [UT]         SetEvent   DT <br> [DT]  ,          . <br>    ,      ()  .      /  ,    ,       : <br>       ( GetStartAddress!). , CREATE_PROCESS_DEBUG_INFO::lpStartAddress ‚Äì   ,     .     ,       ?  ,      ,   ,          . <br>   ,  ,    DbgHelp.dll  Sym* ,         .   SymFromName     ,   SYMBOL_INFO.    SymGetSymFromName64,     PIMAGEHLP_SYMBOL64.   ,     wWinMainCRTStartup,   SymFromName: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">DWORD </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStartAddress</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HANDLE hProcess, HANDLE hThread </span></span></span><span class="hljs-function">)</span></span> { SYMBOL_INFO *pSymbol; pSymbol = (SYMBOL_INFO *)<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BYTE[<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SYMBOL_INFO )+MAX_SYM_NAME]; pSymbol-&gt;SizeOfStruct= <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SYMBOL_INFO ); pSymbol-&gt;MaxNameLen = MAX_SYM_NAME; SymFromName(hProcess,<span class="hljs-string"><span class="hljs-string">"wWinMainCRTStartup"</span></span>,pSymbol); <span class="hljs-comment"><span class="hljs-comment">// Store address, before deleting pointer DWORD dwAddress = pSymbol-&gt;Address; delete [](BYTE*)pSymbol; // Valid syntax! return dwAddress; }</span></span></code> </pre><br><br> ,     wWinmainCRTStartup,        .  ,      , , , ,    EXE  ,    32-,    , Unicode  ANSI    . <br>      ?      . <br><br><h1> CDebuggerCore ‚Äî The debugging-interface class </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I wrote an abstract class that has only a few purely virtual functions needed for debugging. Unlike the previous article, which was closely integrated into the user interface and MFC, I made this class independent of anything. I used the native identifiers of the Windows STL and CString class in this class. Please note that you can use CString from non-MFC applications through the &lt;atlstr.h&gt; connection. There is no need to link the program with the MFC-libraries, just one header file is enough. If CString bothers you, replace it with your favorite string class and that's it. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the basic skeleton of CDebuggerCore:</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> CDebuggerCore { HANDLE m_hDebuggerThread; // Handle <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> debugger thread HANDLE m_heResumeDebugging; // <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ResumeDebugging PROCESS_INFORMATION m_cProcessInfo; // Other member <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> shown <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> now. <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: // Asynchronous <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> debugging // Spawns a thread, that has the debugging-<span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>, which // calls <span class="hljs-keyword"><span class="hljs-keyword">following</span></span> virtual <span class="hljs-keyword"><span class="hljs-keyword">functions</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">notify</span></span> debugging events. <span class="hljs-type"><span class="hljs-type">int</span></span> StartDebugging(const <span class="hljs-type"><span class="hljs-type">CString</span></span>&amp; strExeFullPath); // How the <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> responded <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> debugging, // it may <span class="hljs-keyword"><span class="hljs-keyword">also</span></span> <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> stop-debugging. // <span class="hljs-keyword"><span class="hljs-keyword">To</span></span> be <span class="hljs-keyword"><span class="hljs-keyword">called</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> UI-thread <span class="hljs-type"><span class="hljs-type">int</span></span> ResumeDebugging(EResumeMode); // Don<span class="hljs-string"><span class="hljs-string">'t want to listen anything! Terminate! void StopDebugging(); protected: // Abstract methods virtual void OnDebugOutput(const TDebugOutput&amp;) = 0; virtual void OnDllLoad(const TDllLoadEvent&amp;) = 0; virtual void OnUpdateRegisters(const TRegisters&amp;) = 0; virtual void OnUpdateCallStack(const TCallStack&amp;) = 0; virtual void OnHaltDebugging(EHaltReason) = 0; };</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some readers may not like this class. But in order to explain how the debugger code works, I have to write the code itself! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since this class is abstract, it must be basic for some other class and all virtual methods (On *) must be overloaded. Needless to say, these virtual functions are called from the main class depending on various debugging events. No virtual function requires a return value, so you can leave the implementation empty. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose you created the CDebugger class inherited from CDebuggerCore and implemented all the virtual functions. Then you can start debugging with this code:</font></font><br><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">In</span></span> <span class="hljs-keyword"><span class="hljs-keyword">header</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> at <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> persist-able <span class="hljs-keyword"><span class="hljs-keyword">location</span></span> CDebugger theDebugger; // The <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> code <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> you ask it <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> debugging: theDebugger.StartDebugging("Path to executable");</code> </pre><br><br>         ,   ,     ,    .     ‚Äì  ,  StartDebugging . <br> ,      DebuggerThread (    ).      CreateProcess,            WaitForDebugEvent  ContinueDebugEvent.   -  ,         On*. ,    OUTPUT_DEBUG_STRING_EVENT,   OnDebugOutput   .         .         . <br>    ,   , ,   ,      On* ,    HaltDebugging   .     private  CDebuggerCore,    : <br><br><pre> <code class="hljs pgsql">// Enum enum EHaltReason { // Reason codes, <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> Breakpoint }; // <span class="hljs-keyword"><span class="hljs-keyword">In</span></span> CDebuggerCore private: <span class="hljs-type"><span class="hljs-type">void</span></span> HaltDebugging(EHaltReason);</code> </pre><br><br>    : <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> CDebuggerCore::HaltDebugging(EHaltReason eHaltReason) { // Halt the debugging OnHaltDebugging(eHaltReason); // <span class="hljs-keyword"><span class="hljs-keyword">And</span></span> wait <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> it, <span class="hljs-keyword"><span class="hljs-keyword">until</span></span> ResumeDebugging <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">called</span></span>, which would <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> the event WaitForSingleObject(m_heResumeDebugging,INFINITE); }</code> </pre><br><br>        ,     HaltDebugging,     OnHaltDebugging.  OnHaltDebugging     ,     ,       .    ,     . DT . <br>   UI,  : ,    ..  UI  ResumeDebugging c    (, ¬´   (Continue)¬ª, ¬´   (StepIp)¬ª  ¬´  (Stop)¬ª).  ResumeDebugging,       EResumeMode,          SetEvent    .     . <br> ,  HaltDebugging  ,   ,    .      m_eResumeMode,    ResumeDebugging   ;   ,    .   , EResumeMode   : <br><br><pre> <code class="hljs pgsql">// What action was initiated <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resume enum EResumeMode { <span class="hljs-keyword"><span class="hljs-keyword">Continue</span></span>, // F5 Stop, // Shift+F5 StepOver, // F10 // More .. };</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The final part will be: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Getting source codes and line numbers </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setting custom breakpoints </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code tracing (step-in, step-out, step-over) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conditional breakpoints </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Debugging a running process </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Disconnect from process, shutdown or wait? </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Debugging a Fallen Process </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Manually connecting the debugger </font></font></li></ul></div><p>Source: <a href="https://habr.com/ru/post/190800/">https://habr.com/ru/post/190800/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../190788/index.html">New Brief: Samsung Announces 3D V-NAND Flash Memory SSDs</a></li>
<li><a href="../190790/index.html">Why Emacs?</a></li>
<li><a href="../190792/index.html">Jiayu G4 - the long-awaited Chinese flagship</a></li>
<li><a href="../190794/index.html">Apple patented 3D controls with touch screen gestures</a></li>
<li><a href="../190796/index.html">Zuckerberg launched Internet.org to connect the whole world to the Internet</a></li>
<li><a href="../190806/index.html">Is the concept of an accounting object relevant?</a></li>
<li><a href="../190808/index.html">SIP URI and URL. Part 2 (SIP URI scheme)</a></li>
<li><a href="../190810/index.html">Why we do not have customer support by mail?</a></li>
<li><a href="../190814/index.html">Adaptive emails</a></li>
<li><a href="../190816/index.html">Vkontakte enabled https almost by default</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>