<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to render frame Unreal Engine</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once I looked for the Unreal source code and, inspired by an excellent analysis of how popular games render a frame ( translation of an article on Hab...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to render frame Unreal Engine</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/166/7e4/e24/1667e4e24327dd84c75843f6b4ea2dc9.png"></div><br><br>  Once I looked for the Unreal source code and, inspired by an excellent analysis of <a href="http://www.adriancourreges.com/blog/2015/11/02/gta-v-graphics-study/" rel="noopener">how popular games render a frame</a> ( <a href="https://habrahabr.ru/company/ua-hosting/blog/271931/">translation of an</a> article on Habr√©), I decided to do something similar with it, too, to study how the engine renders the frame (with the parameters and settings of the scene on default). <br><br>  Since we have access to the source code, we can examine the source of the renderer to understand what it does, however, this is quite a voluminous part of the engine, and the rendering paths are highly context-sensitive, so it will be easier to explore the pure low-level API (sometimes looking at the code, to fill in the blanks). <br><a name="habracut"></a><br>  I assembled a simple scene with several static and dynamic props, several light sources, volume fog, transparent objects and particle effects to use a fairly wide range of materials and rendering methods. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, I skipped Editor through <a href="https://renderdoc.org/" rel="noopener">RenderDoc</a> and turned on capture.  Perhaps this is not too similar to what a real game frame will look like, but it will give us a rough idea of ‚Äã‚Äãhow Unreal renders the standard frame (I did not change any settings and chose the maximum quality for the PC): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ee/e77/c20/5eee77c202b3b80203a219cd56f13877.png" alt="image"></div><br><br>  Note: the analysis is based on the capture of the video processor information and the source code of the renderer ( <strong>version 4.17.1</strong> ).  Before this project, I didn‚Äôt have much experience with Unreal.  If I missed something or in something was mistaken, then let me know in the comments. <br><br>  Fortunately, the Unreal drawing call list is clear and well annotated, and it will simplify our work.  The list may look different if there are no entities / materials in the scene, or if a lower quality is chosen.  For example, if you render without particles, there will be no <strong>ParticleSimulation</strong> passes. <br><br>  The <strong>SlateUI</strong> rendering <strong>pass</strong> contains all API calls performed by the Unreal Editor to render its UI, so we will skip it and focus on all passes in the <strong>Scene</strong> section. <br><br>  <strong>Particle simulation</strong> <br><br>  The frame begins with the passage of <strong>ParticleSimulation</strong> .  It calculates the motion of particles in the video processor and other properties for each particle emitter in the scene for two target renders: RGBA32_Float (positions are written here) and RGBA16_Float (speeds) (and pairs of data / time / life).  Here, for example, is the output for the target render RGBA32_Float, where each pixel corresponds to the position of the sprite in the world: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a46/57a/1a5/a4657a1a5f447c86fb05023f104abf3a.png" alt="image"></div><br><br>  It seems that in this case the particle effect added by me to the scene has two emitters requiring simulation in the video processor without calculating collisions, so the corresponding rendering passes can be performed in the early stages of frame creation. <br><br>  <strong>Z-Bump Pre-Pass</strong> <br><br>  Next is the <strong>PrePass</strong> rendering <strong>pass</strong> , which is the preliminary pass of the z-buffer.  It renders all opaque polygonal meshes (meshes) into the R24G8 depth buffer: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/516/0f7/292/5160f7292b366de4bcbb0dab3276ca7a.png" alt="image"></div><br><br>  It is worth noting that in Unreal, when rendering into the depth buffer, a <a href="https://developer.nvidia.com/content/depth-precision-visualized" rel="noopener">reverse Z-buffer (reverse-Z) is used</a> .  This means that the near plane is assigned the value 1, and the distant one - 0. This provides greater accuracy along the depth range and reduces the number of z-collisions for distant grids.  The name of the rendering pass implies that the pass is triggered by the buffer ‚ÄúDBuffer‚Äù.  This is the name of the decal buffer that the Unreal Engine uses to render deferred decals.  It requires the depth of the scene, so the Z-buffer pre-pass is activated.  But, as we will see below, the Z-buffer is used in other contexts, for example, for calculating overlaps (occlusion) and reflections in screen space. <br><br>  Some render passes in the list are empty.  for example, <strong>ResolveSceneDepth</strong> , which, I believe, is necessary for platforms that really require ‚Äúresolving by depth‚Äù of the target render before using it as a texture (it is not needed on a PC), as well as <strong>ShadowFrustumQueries</strong> , which looks like a <strong>dummy</strong> marker, because the real overlap tests for shadows are performed in the next render pass. <br><br>  <strong>Overlap check</strong> <br><br>  <strong>BeginOcclusionTests</strong> handles all overlap checks in a frame.  By default, Unreal uses <a href="https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter06.html" rel="noopener">hardware occlusion queries</a> to check for overlap.  In short, it is performed in three stages: <br><br><ol><li>  We render everything that we perceive as an overlapping object (for example, a large opaque mesh) to the depth buffer </li><li>  Create an overlap request, pass it and render the props for which we want to define the overlap.  This is implemented using the z-test and the depth buffer created in step 1. The query returns the number of pixels that passed the z-test, that is, if the value is zero, then the entire props is located behind an opaque grid.  Since rendering the entire grid of a props for overlapping can be costly, we use as a replacement the boundary box of this props.  If it is invisible, then the props is also absolutely invisible. </li><li>  We read the results of the query back to the video processor and based on the number of rendered pixels we can choose whether to send the props for rendering or not (even if we see a small number of pixels, we can decide that the props should not be rendered). </li></ol><br>  Unreal uses different types of overlap requests, depending on the context: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9d/8c3/c56/b9d8c3c562adda8f275948b86912d36a.png" alt="image"></div><br><br>  Hardware overlap requests have their drawbacks - they have fragmentation of draw calls.  This means that they require the renderer to perform a single draw call per grid (or group of grids) for which you need to define an overlap.  They can significantly increase the number of draw calls per frame, require reading back to the CPU, which adds synchronization points between the CPU and the video processor, and cause the CPU to wait for the video processor to finish processing the request.  They are not very suitable for the cloned geometry, but for now we will not pay attention to it. <br><br>  Unreal solves the problem of the synchronization point of the CPU and the video processor like any other engine that uses queries ‚Äî read the request data deferred for several frames.  This approach works, but it can add the problem of ‚Äújumping out‚Äù props onto the screen when the camera moves rapidly (in practice this may not be a serious problem, because cutting off overlaps with the help of boundary boxes is conservative, that is, the grid is likely to be labeled as visible even before it actually becomes visible).  However, there remains the problem of unnecessary draw calls, and it is not so easy to solve.  Unreal tries to reduce its impact by grouping requests as follows: first, it renders all opaque geometry into a z-buffer (the Z-buffer described above is described above).  It then transmits separate requests for each props to be checked for overlap.  At the end of the frame, it receives the request data from the previous (or even earlier) frame and resolves the problem of visibility of the props.  If it is visible, the engine marks it for rendering in the next frame.  On the other hand, if it is invisible, the engine adds it to the ‚Äúgrouped‚Äù query, which combines the boundary parallelepipeds of the props (maximum eight objects) and uses it to determine visibility during the next frame.  If in the next frame the group becomes visible (as a whole), the engine breaks it up and sends individual requests again.  If the camera and props are static (or moving slowly), then this approach reduces the number of required floor requirements by a factor of eight.  The only oddity that I noticed during the grouping (batching) of the overlapping props was that it seems random and does not depend on the spatial proximity of the props to each other. <br><br>  This process corresponds to the <strong>IndividualQueries</strong> and <strong>GroupedQueries markers</strong> in the above list of render passes.  The <strong>GroupedQueries</strong> part <strong>is</strong> empty because the engine was unable to create a query during the previous frame. <br><br>  To complete the passage of overlaps, <strong>ShadowFrustumQueries</strong> transmits hardware requests for overlaps of boundary grids of local (point or directional) (casting and not casting a shadow, contrary to the name of the passage).  If they are overlapped, then there is no point in calculating the lighting / shadows for them.  It is worth noting that despite the presence in the scene of four local light sources casting a shadow (for which you need to compute a shadow map for each frame), the number of draw calls in <strong>ShadowFrustumQueries</strong> is three.  I suspect this is so, because the limiting volume of one of the sources crosses the near plane of the camera, so Unreal believes that it will still be visible.  It is also worth mentioning that for dynamic lighting, which calculates a cubic shadow map, we pass a sphere for the overlap checks, <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/355/677/201/355677201249cab7dc29faac587e4b84.png" alt="image"></div><br><br>  and for static dynamic lighting, which Unreal calculates for the shadows of each object (more on this below), the pyramid is transmitted: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/287/190/467/287190467a98983d28ee7d4413db1edd.png" alt="image"></div><br><br>  Finally, I assume that <strong>PlanarReflectionQueries</strong> refers to overlap tests performed when calculating plane reflections (created by moving the camera behind / in front of the plane of the reflections and redrawing the grids). <br><br>  <strong>Hi-Z Buffer Generation</strong> <br><br>  Unreal then creates a Hi-Z buffer ( <strong>HZB SetupMipXX passes</strong> ) stored as a 16-bit floating point number (texture format R16_Float).  It receives as input the depth buffer created during the preliminary passage of the Z-buffer and creates a mip-chain (i.e., gradually reduces their resolution) depths.  It also seems that for convenience, he resampls the first mip to the size of a power of two: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5c/0c0/715/b5c0c0715395ce6fd9f93874af25129e.png" alt="image"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc3/6e5/5ee/cc36e55ee110a09d89cc7122af4fb6f4.png" alt="image"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/318/045/d3f/318045d3f53e72b9e63829dce81a1e2d.png" alt="image"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7b/9f1/d57/b7b9f1d57974c50032e3067aff5e62c2.png" alt="image"></div><br><br>  Since, as mentioned above, Unreal uses a reverse Z-buffer, the pixel shader uses the min operator to reduce the expansion. <br><br>  <strong>Rendering shadow maps</strong> <br><br>  This is followed by a rendering of the computation of the shadow map ( <strong>ShadowDepths</strong> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/249/ad6/f48/249ad6f489fb956b893a23dbd362a12f.png" alt="image"></div><br><br>  I added a ‚Äústationary‚Äù (Stationary) directional light source, two ‚ÄúMovable‚Äù point sources, two stationary point sources, and a ‚Äústatic‚Äù (Static) point source to the scene.  They all cast shadows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48b/397/436/48b397436c6e4aea6606e4a9fa3b4610.png" alt="image"></div><br><br>  In the case of stationary sources, the renderer bakes the shadows of static props and calculates the shadows only for dynamic (mobile) props.  In the case of mobile sources, it calculates the shadows for everything and every frame (fully dynamic).  Finally, in the case of static sources, it bakes the lighting + shadows into the lighting map so that they never appear during rendering. <br><br>  For the directional light source, I also added a cascading shadow map with three divisions to see how Unreal handles them.  Unreal creates a shadow map texture R16_TYPELESS (three tiles in a row, one for each division), which is reset in each frame (therefore, there are no torn updates to the shadow map partitions based on the distance in the engine).  Then, at the <strong>Atlas0</strong> pass <strong>stage, the</strong> engine <strong>renders</strong> all the opaque props into the corresponding shadow map file: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/733/3f4/321/7333f432167c539a013cb8aa3bcb1e46.png" alt="image"></div><br><br>  As the above call list confirms, only in Split0 there is a geometry for rendering, so the other tiles are empty.  The shadow map is rendered without using a pixel shader, which doubles the speed at which the shadow map is generated.  It is worth noting: it seems that the separation between Stationary and Movable is not saved for a directional (source) light source, the renderer renders all props (including static ones) into the shadow map. <br><br>  Next is the Atlas1 pass, which renders shadow maps for all stationary light sources.  In my scene is marked as moving (dynamic) only prop "stone".  For stationary sources and dynamic props, Unreal uses object-specific shadow maps stored in a texture atlas.  This means that it renders for each source and for dynamic props one shadow map tile: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/872/d53/5b2/872d535b2ec3ae695c21aea0d5c3f098.png" alt="image"></div><br><br>  Finally, for each dynamic (moving) light source, Unreal creates a traditional cube shadow map ( <strong>Cubemap</strong> XX passes), using a geometry shader to select the face of the cube on which to render (to reduce the number of draw calls).  In it, it only renders dynamic props using caching of shadow maps for static / stationary props.  The CopyCachedShadowMap pass copies the cached cube shadow map, after which the depths of the dynamic props shadow map are rendered on top of it.  For example, here is the face of a cached cube shadow map for a dynamic light source (CopyCachedShadowMap output): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15b/8ae/595/15b8ae595309516ab19e95e3c8f609a1.png" alt="image"></div><br><br>  And here it is with a rendered dynamic stone "stone": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/638/514/0e4/6385140e429f3efd1e1f500438e45f4a.png" alt="image"></div><br><br>  A cubic map for static geometry is cached and not created every frame, because the renderer knows that the light source is not really moving (although it is marked as Movable).  If the source is animated, then the renderer each frame renders a ‚Äúcached‚Äù cubic map with all static / stationary geometry, and then adds dynamic props to the shadow map (this picture is from another test that I conducted specifically to verify this): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78b/dce/daf/78bdcedaf08aa0cfd4d8947427a4dd27.png" alt="image"></div><br><br>  The only static light source does not appear at all in the list of draw calls.  This confirms that it does not affect the dynamic props and, through the baked light map, affects only static props. <br><br>  I will give you advice: if there are stationary sources of lighting in the scene, then before performing the profiling in the Editor, bake all the lighting (at least I‚Äôm not sure what the launch of the game does as ‚Äústandalone‚Äù).  It seems that otherwise Unreal treats them as dynamic sources, creating cubic maps instead of using shadows for each object. <br><br>  Now we will continue to study the process of rendering the frame in the Unreal engine, having considered the generation of the lighting grid, the preliminary passage of the g-buffer and the lighting. <br><br>  <strong>Lighting purpose</strong> <br><br>  The renderer then switches to the compute shader shader to link the lighting to the 3D grid ( <strong>ComputeLightGrid</strong> pass) in a manner similar to clustered shading.  This lighting grid can be used to quickly determine the sources of light that affect the surface depending on its position. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a45/0f2/012/a450f2012ab5d634e3566b5f3d69590c.png" alt="image"></div><br><br>  As the name of the passage suggests, the grid of illumination of visible space has dimensions 29x16x32.  Unreal uses a screen space of 64 √ó 64 pixels and 32 parts of z-depth.  This means that the number of XY dimensions of the lighting grid will depend on the screen resolution.  In addition, judging by the name, we also assign 9 light sources and two reflection probes.  A reflection probe is an ‚Äúentity‚Äù with a position and a radius that reads the environment around itself and is used to create reflections on the props. <br><br>  According to the compute shader source code (LightGridInjection.usf), the separation is carried out exponentially: this means that the z size of each grid cell in the visible space becomes larger with distance from the camera.  In addition, it uses the parallelepiped of each cell aligned with the coordinate axes to perform the intersections of the limiting volumes of the light sources.  To store the indices of light sources, a linked list is used, which is converted into a solid array in the Compact passage. <br><br>  This illumination grid will be used for in-pass volumetric fog calculations to add light scattering in the fog, in the environment reflection pass, and the translucent rendering pass. <br><br>  I noticed another interesting fact: the CullLights pass begins with clearing Unordered Access Views for the lighting data, but it uses ClearUnordered Access ControlUint for only two of the three UAVs.  For the rest, it uses the compute shader, which sets the value manually (the first Dispatch in the list above).  Obviously, in the case of buffer sizes larger than 1024 bytes, the source code prefers to use cleanup using the compute shader instead of using the API cleanup call. <br><br>  <strong>Volume fog</strong> <br><br>  This is followed by volume fog calculations, in which the compute shader shaders are used again. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56c/e4d/2da/56ce4d2dad513d19c436d1ca91c723d3.png" alt="image"></div><br><br>  In this passage, the permeability and the scattering of light in the volume texture are calculated and stored, which allows a simple calculation of the fog using only the surface position.  As in the previously performed illumination destination, the volume ‚Äúfits‚Äù into the visibility pyramid with the help of 8 √ó 8 tiles and 128 depth gradations.  Gradations of depth are distributed exponentially.  They move the near plane a little to avoid a large number of small cells close to the camera (this is similar to <a href="http://www.humus.name/Articles/PracticalClusteredShading.pdf" rel="noopener">the</a> Avalanche Studios <a href="http://www.humus.name/Articles/PracticalClusteredShading.pdf" rel="noopener">cluster shading system</a> ). <br><br>  As in the volume fog technology (LINK) of the <a href="http://advances.realtimerendering.com/s2014/index.html" rel="noopener">Assassin's Creed IV</a> and <a href="https://www.ea.com/frostbite/news/physically-based-unified-volumetric-rendering-in-frostbite" rel="noopener">Frostbite</a> engine, fog is calculated in three passes: the first ( <strong>InitializeVolumeAttributes</strong> ) calculates and saves the fog parameters (scattering and absorption) into the volume texture, and also saves the global emission value into the second volume texture .  The second pass ( <strong>LightScattering</strong> ) calculates the scattering and attenuation of light for each cell, combining shaded directional lighting, sky lighting, and local light sources assigned to the texture of the light volume in the ComputeLightGrid aisle.  He also applies temporal anti-aliasing (antialiasing, AA) to the output of the compute shader (Light Scattering, Extinction) using the history buffer, which is itself a 3D texture, improving the quality of the diffuse lighting in the grid cell.  The final pass ( <strong>FinalIntegration</strong> ) simply performs the raymarching of the 3D texture along the Z axis and accumulates the diffuse illumination and permeability, saving the result in the process to the appropriate grid cell. <br><br>  The finished volume buffer with light scattering is as follows.  In it you can see the pillars of light due to the directional sources of illumination and local sources dissipating in the fog. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cbe/11e/f76/cbe11ef7629b662e3e70b7ac324cfe21.png" alt="image"></div><br><br>  <strong>G-Buffer Pre-Pass</strong> <br><br>  This is followed by a proprietary version of the preliminary pass of the Unreal G-Buffer, usually used in deferred rendering architectures.  This pass is needed in order to cache the properties of materials into a multitude of target renderers in order to reduce redrawing during costly calculations of lighting and shading. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9f/e85/b19/f9fe85b19810f89ab2939f9710dddadf.png" alt="image"></div><br><br>  In this passage, all opaque props are usually rendered (static, moving, etc.).  In the case of Unreal, the sky is also rendered first!  In most cases, this is a bad decision, because the sky is later redrawn by other props that are closer to the camera, that is, the work turns out to be superfluous.  However, in this case, this is quite normal, because the preliminary buffer of the Z-buffer previously performed by the renderer eliminates the sky redrawing (and most of the redrawing in general, at least for opaque props). <br><br>  Here is a list of target renders to which the g-buffer pre-passes are recording. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/60b/19f/264/60b19f26474ea558b706d1e106df6c11.png" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The depth buffer is used only for the z-test, it was already filled in the preliminary pass of the z-buffer, and now the renderer does not write anything to it. </font><font style="vertical-align: inherit;">However, the renderer writes to the stencil buffer in order to mark those pixels that belong to the rendering opaque geometry. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The contents of the g-buffer may depend on the render settings. </font><font style="vertical-align: inherit;">For example, if the renderer has to write a speed to the g-buffer, then it will take GBufferD and the data will be moved. </font><font style="vertical-align: inherit;">For our scene and rendering path, the g-buffer has the following scheme.</font></font><br><br><table width="629"><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/83e/8fe/9ca/83e8fe9ca8522e0d65cef1af89e1e849.png" alt="image"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/9bd/949/d9a/9bd949d9a17fda4a6b1724e7bc93489e.png" alt="image"></td></tr><tr><td> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SceneColorDeferred</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : contains indirect lighting</font></font></td><td> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GBufferA</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : world space normals stored as RGB10A2_UNORM. </font><font style="vertical-align: inherit;">It seems that no coding is used</font></font></td></tr><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/d4e/539/5f9/d4e5395f96f29f6b599f63a3cdabb12e.png" alt="image"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/c32/dfd/668/c32dfd6683b1aafc5c4839149a01e12b.png" alt="image"></td></tr><tr><td> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distortion</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : various materials properties (metalness, roughness, reflection intensity and shading model)</font></font></td><td> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GBufferC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Albedo in RGB, AO in alpha channel</font></font></td></tr><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/5ea/d29/b49/5ead29b49488ca80d0198338705c188f.png" alt="image"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/1ff/d61/6a0/1ffd616a0b86ba6f7a8431e6d586218a.png" alt="image"></td></tr><tr><td> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GBufferE</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : own data depending on the shading model (for example, subsurface color or tangent vector).</font></font></td><td> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GBufferD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><strong><font style="vertical-align: inherit;">Baked Shading</font></strong><font style="vertical-align: inherit;"> Indicators</font></font></td></tr><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/d7b/116/e93/d7b116e9331e77c3ae09eb8daf63212d.png" alt="image"></td><td></td></tr><tr><td> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stencil</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to mark opaque props</font></font></td><td></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It is worth noting that all the opaque props in the scene (except for the moving stone and the sky) sample information about the illumination from three atlases with mip levels that cache the irradiation, shadows and surface normals: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f65/7a1/7c0/f657a17c01c3f946f810d90a429d6aa9.png" alt="image"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33f/79d/895/33f79d895e3c4acb29b80e3a8d391946.png" alt="image"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a6/1d2/516/5a61d25160977f695c082075ac934d52.png" alt="image"></div><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And again the simulation of particles The</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simulation of particles was the first action performed in the frame, it was a passage that recorded positions in the world and the speed of the sprites of the particles. </font><font style="vertical-align: inherit;">It occurs in the frame so early that the renderer does not have access to the depth and normal buffers to calculate collisions in the video processor, so it is time to go back and re-run the simulation for those particles that require it.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44d/85a/60e/44d85a60ec763fd507d3e698313ea140.png" alt="image"></div><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering speeds</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> By default, Unreal writes the speed of the moving props to a separate R16G16 format buffer. </font><font style="vertical-align: inherit;">In the future, the speed will be used for motion blur (for motion blur) and for all effects that require re-projection (for example, for temporal smoothing). </font><font style="vertical-align: inherit;">In our scene, only a stone is marked as a moving object, so it is the only render to the velocity buffer.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4bf/c97/ffd/4bfc97ffdbdfd80eac6874bbd8fd6682.png" alt="image"></div><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ambient Occlusion</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After receiving all the information about the materials, the renderer is preparing to proceed to the lighting stage. But first he needs to first calculate the ambient occlusion in screen space.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fe/d84/976/8fed84976fbaabdf8bb19af06d004c5a.png" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are no deferred decals in our scene, but if there were, then I assume that the empty passages of DeferredDecals would change the properties of some materials in the g-buffer. Ambient occlusion in screen space is calculated in two passes - in a quarter resolution and full screen. The </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AmbientOcclusionPS 908 √ó 488</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pass </font><font style="vertical-align: inherit;">calculates AO using a quarter-sized normal resolution buffer created in the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AmbientOcclusionSetup</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pass </font><font style="vertical-align: inherit;">, a Hi-Z buffer created by the renderer earlier and random vector textures from which depth / normal buffers will be sampled. In addition, when sampling textures from random vectors, the shader adds small distortions to each frame in order to emulate supersampling and gradually improve the quality of the AO.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/049/6ea/05b/0496ea05be34b67570862c9e4ad768d6.png" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then, the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AmbientOccPSPS 1815 √ó 976</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pass </font><font style="vertical-align: inherit;">calculates the full screen, with a higher resolution, with AO and combines them with a quarter resolution buffer. </font><font style="vertical-align: inherit;">The results are quite good even without the need to pass blur.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c9/6b1/279/5c96b12791f53e0978a8b859fab9d7ba.png" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finally, the full-resolution AO buffer is applied to the SceneColourDeferred buffer (which is part of the above G-buffer), which so far contains indirect (ambient) scene lighting. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e4/478/e88/0e4478e889ce1b5f0f93ab770541a5fa.png" alt="image"></div><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lighting</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before starting a discussion on lighting, it is worthwhile to step aside a bit and briefly talk about how Unreal illuminates translucent objects, because soon we will meet often with this system. Unreal's approach to lighting translucent surfaces is to bring the lighting into two 64x64x64 RGBA16_FLOAT volume textures. Two textures contain light (shaded + attenuated) in the form of spherical harmonics that reach each cell of the volume (TranslucentVolumeX texture) and approximate the direction of light from each light source (TranslucentVolumeDirX texture). The renderer stores 2 sets of such textures, one for props that are close to the camera and require high-resolution lighting, the second for more distant objects, for which high-resolution lighting is not so important. It uses a similar approach.that is, writing to a cascading shadow map, in which more texels are located closer to the camera than away from it.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here is an example of volume textures for translucent lighting close to the camera with only a (shadowed) directional source. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c4/3c6/211/3c43c6211d9eb89550fefc0df9c84cda.png" alt="image"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/718/bc1/7c0/718bc17c02fefe7f15cd1bc8cee1fd3b.png" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These volumes of translucent lighting do not affect opaque props, they will be used later to illuminate translucent props and effects (particles, etc.). </font><font style="vertical-align: inherit;">However, they will be filled in the aisle lighting. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let us return to the direct illumination of opaque props - now the renderer can calculate and apply lighting to the scene. </font><font style="vertical-align: inherit;">With a large number of light sources, this list of draw calls can be quite long. </font><font style="vertical-align: inherit;">I have deployed only the most important parts.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d6/d7e/f40/4d6d7ef408d6d47273e285c248f6182a.png" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Light sources are processed in two groups, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NonShadowedLights</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ShadowedLights</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The NonShadowedLights group includes simple sources of illumination, for example, the usual sources used for particle effects, and not casting shadows in the scene. The difference between them is that conventional sources of scene illumination use the depth boundaries test when rendering to avoid illuminating pixels beyond the approximate amount of illumination. This is implemented using </font></font><a href="https://github.com/GPUOpen-LibrariesAndSDKs/DepthBoundsTest11" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">specialized driver extensions.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Illumination accumulates in the above-mentioned SceneColourDeferred. Another difference is that simple light sources do not write at all to the volumes of translucent lighting (although it seems that this feature is provided in the renderer code, so perhaps this parameter can be enabled somewhere). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interestingly, in the case when the number of shadowless (and non-static) visible light sources in the scene exceeds 80, the renderer switches from the classic deferred shading mode to the tile deferred lighting mode.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a43/79d/c31/a4379dc311f718bba53ee54ccf5df7e6.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, the renderer uses the compute shader to calculate the lighting (only for such light sources), passing the lighting data down to the shader through constant buffers (I thank </font></font><a href="https://twitter.com/w0xd_" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wand de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for pointing this out to me.). In addition, it seems that switching to tiled deferred lighting and using the compute shader shader to apply all sources of lighting in one pass only affects direct lighting. The </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InjectNonShadowedTranscluscentLighting</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pass </font><font style="vertical-align: inherit;">still adds all the light sources separately to the amounts of translucent lighting (each creates a separate draw call):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd2/1ab/573/cd21ab57357f4b1a9bb4fd14522a51e2.png" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ShadowedLights pass handles all shadow-casting light sources, both stationary and moving. </font><font style="vertical-align: inherit;">By default, Unreal processes each shadow casting light source in three steps:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6bd/7ba/8ef/6bd7ba8efe1b2380f3af6be760df2342.png" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, it calculates the shadows of the screen space ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ShadowProjectionOnOpaque</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), then adds the effect of lighting to the amount of translucent lighting ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InjectTranslucentVolume</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) and finally calculates the lighting in the scene ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StandardDeferredLighting</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As stated above, for this scene the case of directional lighting, the shadow information contains only Split0. </font><font style="vertical-align: inherit;">The result of the shadow calculations is written to an RGBA8 buffer the size of a screen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/310/22e/735/31022e7357fc1a18ced8bb3ea21e8429.png" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next stage ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InjectTranslucentVolume</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) records the effect of directional illumination for both stages in the above-described amount of translucent illumination (two calls per </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InjectTranslucentVolume</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pass </font><font style="vertical-align: inherit;">). Finally, the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StandardDeferredLighting</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pass </font><font style="vertical-align: inherit;">calculates and records the lighting by the shadow buffer mask of the screen space into the SceneColorDeferred buffer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It appears that local sources use the same order to project shadows into the screen space buffer, adding lighting to the amount of translucent lighting and calculating the lighting with writing to the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SceneColorDeferred</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> buffer </font><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3bd/566/18c/3bd56618ca6c50c8a3ea4c380c6a786d.png" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Both types are treated roughly the same way, the difference between mobile / stationary local sources is that mobiles add lighting with shadows to the amount of translucent lighting, and, of course, that for shadows mobile sources with shadows use a cube map rather than an object atlas . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All light sources use one target render of the shadow buffer of screen space, clearing the corresponding parts for the shadows of each source (I suppose this is done to save memory). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Upon completion of the aisle coverage, SceneColorDeferred contains all the accumulated direct illumination of the scene.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a27/af6/1f3/a27af61f3e8c77c364f2bba3b946144b.png" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is worth noting that despite the fact that the renderer created a grouped / clustered data structure in advance (lighting assignment pass), it is not used at all during the lighting pass of opaque geometry, using traditional deferred shading instead with separate rendering of each light source. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a final step, the volumes of translucent lighting are filtered (for both stages) in order to suppress distortion when lighting translucent props / effects.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f78/816/653/f788166538dc34b88caedde3f19ecbfd.png" alt="image"></div><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Illumination in image space.</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then full-screen reflections in the screen space are calculated (the target rendering format is RGBA16_FLOAT).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c70/ab0/d3c/c70ab0d3cd0d4da6b00ed99fe96609a6.png" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The shader also uses the Hi-Z buffer calculated at the beginning of the frame to accelerate the calculation of intersections by selecting the Hi-Z buffer mip level during raymarching based on the roughness of the surface (i.e., making the ray tracing for rough surfaces coarser because the details invisible in their reflections). Finally, in each frame, oscillations are added to the initial position of the beam, which, combined with temporal smoothing, increases the quality of reflection display.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/387/75b/af0/38775baf0b6e7ee41f1778b599a01b71.png" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The shader uses the target render of the previous frame to sample the colors when a collision is detected during raymarching, this can be seen from the volume fog in the reflections, as well as from the reflected transparent props (statues). Also on the right under the chair you can see traces of the effect of particles. Since we do not have the correct depth for transparent surfaces (to calculate correct collisions), reflections are usually stretched, but in many cases the effect looks quite convincing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With the help of the compute shader, reflections in the screen space are applied to the main target renderer ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReflectionEnvironment</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pass </font><font style="vertical-align: inherit;">). This shader also uses reflection reflections captured by two reflection probes in the scene. Reflections for each probe are stored in cubic maps with mip levels:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/204/833/df7/204833df7e27ec55e63392074ddf3398.png" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Environment reflection probes are generated when the game starts and capture only static / stationary geometry (note that the animated stone is not on the above cube maps). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our scene with applied reflections in screen space and environment reflections now looks like this.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/61f/f1b/9fc/61ff1b9fc6f950b7092e93a79dcdbc84.png" alt="image"></div><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mist and Atmospheric Effects Mist and atmospheric effects</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> follow if they are also included in our scene.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/573/d36/4d3/573d364d38cf1028508661c2001d0c69.png" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> First, a quarter-resolution overlap mask is created, which determines which of the pixels will be received by the lighting columns (which apply only to directional lighting in the scene). </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8dd/db7/b50/8dddb7b508d68e3ffb26c97b7d49de87.png" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then the renderer begins to improve the quality of the mask using temporal anti-aliasing and applies three passes of blur to create this mask (I had to process the mask because it was almost completely white): </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aab/966/82f/aab96682f55f51c7745a6d368a4e18e4.png" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From this capture of the video processor's actions it is not quite clear to me why a temporary AA is applied to the mask before blurring, because the final result has a very low resolution. </font><font style="vertical-align: inherit;">Perhaps, to clarify this, more examples of use in different environments will be required. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before the fog and the lighting columns are added to the scene, the renderer takes a breather and applies atmospheric effects (in full resolution) to the main target renderer.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/766/086/a317660866c3035314ee89890914c279.png" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It looks like a complete scattering calculation using pre-calculated transmittance, irradiation, and inward scattering, similar to the </font></font><a href="https://hal.inria.fr/inria-00288758/file/article.pdf" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">work of Bruneton</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/432/5ad/016/4325ad016f99e8da66015f5bfd60b226.png" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our scene is in the room, so, unfortunately, the effects of the simulation are not too noticeable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, the renderer uses an exponential fog and lighting columns in the scene.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1a/133/5e6/d1a1335e68509970361a0dff99161466.png" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The shader uses the volume fog volume texture created by several nada passes, performing a sampling based on the position of the opaque geometry. </font><font style="vertical-align: inherit;">She also applies the mask of the lighting columns calculated above. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transparency rendering</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After the fog is applied to the opaque props, the renderer is assumed to be a translucent geometry and effects.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/536/173/e81/536173e816fae5e4d09e17759d3e71cc.png" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I added two glass statues to the scene that are rendered first, using ordinary alpha blending on top of the main target render. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/3d1/1c8/9c43d11c8122a5f6e5554ea6fee24aa3.png" alt="image"></div><br><br>  These two transparent props are well located in the scene, they are influenced by local and directional light sources, reflections of the surroundings, fog, etc.  By default, the renderer uses a high-quality shader for rendering transparent props, which, among other things, samples pre-calculated atmospheric simulation textures, baked lightmap data, translucent light volumes containing light from directional and local light sources, and cubic light emission probe maps.  All this is used to calculate the lighting.  However, I did not see that the shader reads the texture of the volume of volume fog, it seems that it only calculates the fog based on the height / distance, maybe I missed this parameter somewhere.  Distance dependent fog, like atmospheric scatter, is computed in the vertex shader. <br><br>  The renderer writes the effects of particles into a separate target render (full resolution). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/352/b29/3bf/352b293bfe2c437a80f8dee83c8bd56f.png" alt="image"></div><br><br>  As in the case of transparent props, the atmospheric scatter and fog for them are calculated in the vertex shader.  In addition, with certain settings of the particle system, the renderer can use for lighting particles the volumes of translucent lighting (in one of the cases I saw how it does it in a pixel shader). <br><br>  Before completing the processing of transparency, the renderer performs one more pass to calculate the refractions. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/479/614/984/4796149848f2d724c403fcc40a834f69.png" alt="image"></div><br><br>  Both transparent props and particles (which should provide refraction) are rendered again to write to the full resolution buffer with distortion vectors, which will later be used to calculate the refraction (I processed the image so that the vectors are better visible).  Stencil buffer is also active on this pass, which marks pixels that require refraction. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e8/b39/d77/3e8b39d77c446bf062b37ccabbb59213.png" alt="image"></div><br><br>  During the diffraction calculation pass ( <strong>DistortionApply</strong> ), the renderer reads the contents of the main target render (which is currently available) and the distortion vectors, and then writes a strange texture of the refractions. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/18f/934/18c/18f93418c2af2dcb64c53c48402069b2.png" alt="image"></div><br><br>  Since the stencil buffer is active, marking the pixels that receive a refraction, the renderer does not need to clear the texture. <br><br>  As we have said, the last pass of the refractions simply copies using the stencil buffer the texture of the refractions into the main target render. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e3/d76/9b2/8e3d769b2b65af253ed9a69c7fe5ebeb.png" alt="image"></div><br><br>  You may have already noticed the refraction in the right-hand seat caused by particles that we have not yet applied.  For transparent props, the refraction is rendered after rendering the props. <br><br>  The next pass ( <strong>BokehDOFRecombine</strong> ) finally applies particles to the scene.  This is a simple shader that does less than can be solved by the name of the passage (perhaps it depends on the rendering settings). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9e/e1f/5ad/f9ee1f5adc71b10585968a59d0353449.png" alt="image"></div><br><br>  <strong>Post processing</strong> <br><br>  The last part of the frame processing process includes several post-processing passes, which I will briefly review. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bed/8d2/4b6/bed8d24b6afa0b8d8444025cfad111ef.png" alt="image"></div><br><br>  When configuring our scene, the renderer applies temporal smoothing, motion blur, automatic exposure, bloom, and tonemapping to the main target renderer. <br><br>  Temporary Smoothing Unreal uses a history buffer for gradually accumulating samples, after which it is rendered in two passes.  In the first pass, pixels that are not in the stencil buffer (in our case, these are some of the particles) are applied to a temporary AA using the main target render, history buffer and velocity buffer for re-projection: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bf/a91/6c0/1bfa916c0f4068d68f0784dc77e85a27.png" alt="image"></div><br><br>  Then a similar passage of temporary AA is performed for the parts in the stencil buffer, creating the finished image with anti-aliasing: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a5/c38/ab8/2a5c38ab8a14760a5322ebb4d3e983c3.png" alt="image"></div><br><br>  The difference between these two passes of the time AA is that the former uses the mix ratio (feedback) between the history buffer and the current target renderer, which is variable and may depend on pixel brightness, distance transmitted by the scale renderer, etc.  (based on parameters), and the second pass uses a constant mixing factor of 0.25: this means that the final pixel with anti-aliasing will mainly consist of the current sample.  I think this is done to reduce the effect of the ‚Äúghostness‚Äù of fast-moving particles, for which we have no information about speed. <br><br>  This is followed by the creation of motion blur, preceded by a leveling and speeding aisle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29d/3ef/fe2/29d3effe260012ec29acd15f83576be4.png" alt="image"></div><br><br>  In our case, the motion blur effect is not too noticeable, because the camera is static and the only moving prop that has speed is a stone (and it is already a little blurred due to movement and temporal smoothing). <br><br>  To implement autoexposure (eye adaptation), the renderer creates a histogram of the illumination of the current scene using the compute shader.  The histogram groups the brightness of pixels and calculates the number of pixels belonging to each brightness group. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/485/249/aae/485249aaee2194f9a4b04dcd2b8c3d47.png" alt="image"></div><br><br>  The advantage of this approach is that we can easily skip over those areas of the image that contain very dark or very bright values ‚Äã‚Äãand create a more reasonable approximation of the average illumination of the scene.  Using this medium illumination, the renderer can calculate the adaptation of the eye, adjusting the exposure accordingly (bright images lead to a small exposure, and darker images to a large one). <br><br>  To implement the Bloom effect, several passes are used to reduce the resolution, in which Gaussian filtering is applied, and then several operations of increasing the resolution and combining (the image is changed in such a way as to make it clearer without controlling the exposure). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/609/8cc/7b9/6098cc7b91728fff95739a83704b535a.png" alt="image"></div><br><br>  In the <strong>PostProcessCombineLUTs</strong> pass, a geometric shader and a rather long pixel shader are used to create a lookup table for the color scale (volume texture 32x32x32 RGB10A2).  The lookup table will be used during the tonemapping stage: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/767/f44/2f6/767f442f62aa4073984751107b64c93d.png" alt="image"></div><br><br>  The last frame pass ( <strong>Tonemapper</strong> ) combines the previously calculated bloom with the main target render, adjusts the image exposure using the eye adaptation previously calculated, and then passes the color through the color scale lookup table to create the final pixel color: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d5/d6a/24c/0d5d6a24c5734411d48fcd8f3f33cce7.png" alt="image"></div><br><br>  <strong>Summarize</strong> <br><br>  It should be emphasized that this is just one rendering path, it can be influenced by many parameters and settings, and in fact we have considered the very basics. <br><br>  Overall, this turned out to be an interesting exercise, despite the fact that I rather learned <i>what the</i> renderer is doing, and not <i>how</i> it does it.  A lot of things have remained unexplored and I want to return to this topic again. <br><br>  The Unreal source code is not well documented, but it is quite clear and understandable.  Following the list of draw calls, it is very easy to find the corresponding code.  However, in many cases it was quite difficult to understand from the source code what the shaders do, because they actively use conditional compilation.  For convenience of studying and performance profiling, it would be nice to have some intermediate cache of processed and ready-to-compile specialized shaders (the names of which are added to the list of draw calls). <br><br>  It seems that by default the Unreal renderer focuses on creating high-quality images.  He actively uses data baking (surroundings, lighting, volumes, etc.) and applies temporal smoothing to significantly improve image quality. <br><br>  If there are a lot of props in your scene and not many opportunities to block them (for example, a large number of large overlapping objects), then you should carefully consider the passage of the calculation of overlaps.  In addition, refractions on transparent props and particles lead to double rendering.  Finally, many stationary or moving local light sources affect the lighting stage because they are rendered individually (and contribute to the cost of adding lighting for transparency and volume effects). <br><br>  In conclusion, I would like to thank <a href="https://twitter.com/baldurk">Baldurk</a> for the excellent RenderDoc tool and Epic for revealing the Unreal source code for use, study and learning. </div><p>Source: <a href="https://habr.com/ru/post/341080/">https://habr.com/ru/post/341080/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../341068/index.html">Service alert a million users with RabbitMQ</a></li>
<li><a href="../341070/index.html">Nearly 2018, and we love callbacks</a></li>
<li><a href="../341072/index.html">We work with Bitcoin on Elixir</a></li>
<li><a href="../341074/index.html">Translation and dubbing of a movie at home - Indie Game: The Movie Special Edition</a></li>
<li><a href="../341076/index.html">Ember.js: a great framework for web applications</a></li>
<li><a href="../341084/index.html">Implementing HFT robots on CEPappliance devices</a></li>
<li><a href="../341086/index.html">Numbers and letters: how was SmartData conference</a></li>
<li><a href="../341092/index.html">Results of web activity after 10 years</a></li>
<li><a href="../341094/index.html">Stryker, mutation testing in javascript</a></li>
<li><a href="../341096/index.html">Fake emails from almost any person in less than 5 minutes and ways to protect</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>