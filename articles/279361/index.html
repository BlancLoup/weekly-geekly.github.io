<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>[PF] Print PDF under .NET, raster approach</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Under the cut I want to tell you about printing PDF files under .NET. With an emphasis on printing from different trays of the printer. This is useful...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>[PF] Print PDF under .NET, raster approach</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/58c/fb2/b69/58cfb2b69eba4e3fada1adac9dba1a41.jpg"></div><br>  Under the cut I want to tell you about printing PDF files under .NET.  With an emphasis on printing from different trays of the printer.  This is useful when you need to print documents consisting of different types of paper laid out in the trays of the printer. <br><a name="habracut"></a><br>  The .NET environment out of the box does not provide tools for working with PDF files.  Of course there are paid libraries, but not always even in them you can find a solution to the tasks. <br><br>  To print the document ‚Äúas is‚Äù, you need, using ‚Äúwinspool.drv‚Äù, to send the file to the printer in the form of Raw Data.  This is <a href="http://Microsoft ">written</a> in detail on the support site.  With this approach, it should be borne in mind that the printer used must be able to handle the PDF format.  If there is no such printer, you need to convert PDF to PostScript and send it to the printer as Raw Data.  On how to convert PDF to PostScript, you can always consult with Google. <br><br>  If you need to change printer settings when printing, you will have to look for another way.  PostScript is a device-independent document description language that does not provide legal means for fine work with iron, for example, for selecting trays. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Another way is to render PDF to raster and print the last one.  This method is the most costly in terms of resources, but it is simply implemented and allows printing arbitrary documents by regular .Net tools.  This is the approach we will use. <br><br>  The .NET environment provides a convenient PrintDocument class for working with printers, in which the printer canvas is represented by a Graphics object.  You can drag a bitmap image of a PDF page onto the canvas using DrawImage.  For rendering PDF documents to raster there is a wonderful free utility GhostScript. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/97d/0fe/586/97d0fe58601340399858cf3e416f213b.jpg"></div><br>  GhostScript utility is available for free download on the official site <a href="http://www.ghostscript.com/">GhostScript</a> .  Download and install the appropriate version of <a href="http://ghostscript.com/download/gsdnld.html">Download</a> .  For convenient work, the <a href="https://ghostscriptnet.codeplex.com/">GhostScriptNet</a> wrapper has been developed from the .NET environment, which will also have to be downloaded.  Archive unpacked near the project.  In the archive we are interested in the assembly of Ghostscript.NET.dll, which we immediately connect to the project of the application being developed, it is assumed that it has already been created;) <br><br>  The environment is configured and ready to go.  To check, we will write a very small console application that converts the document pages to * .jpg files: <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Ghostscript.NET; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Ghostscript.NET.Rasterizer; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">GhostScript</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> GhostscriptVersionInfo _lastInstalledVersion = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> DPI = <span class="hljs-number"><span class="hljs-number">200</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> outputPath = <span class="hljs-string"><span class="hljs-string">@"output\"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!args.Any()) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"{0} [*.pdf]"</span></span>, Path.GetFileName(Environment.GetCommandLineArgs()[<span class="hljs-number"><span class="hljs-number">0</span></span>])); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inputPdfPath = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; _lastInstalledVersion = GhostscriptVersionInfo.GetLastInstalledVersion( GhostscriptLicense.GPL | GhostscriptLicense.AFPL , GhostscriptLicense.GPL ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rasterizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GhostscriptRasterizer(); rasterizer.CustomSwitches.Add(<span class="hljs-string"><span class="hljs-string">"-dNOINTERPOLATE"</span></span>); rasterizer.CustomSwitches.Add(<span class="hljs-string"><span class="hljs-string">"-sPAPERSIZE=a4"</span></span>); rasterizer.TextAlphaBits = <span class="hljs-number"><span class="hljs-number">4</span></span>; rasterizer.GraphicsAlphaBits = <span class="hljs-number"><span class="hljs-number">4</span></span>; rasterizer.Open(inputPdfPath, _lastInstalledVersion, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Directory.Exists(outputPath)) { Directory.Delete(outputPath, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } Directory.CreateDirectory(outputPath); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pageNumber = <span class="hljs-number"><span class="hljs-number">1</span></span>; pageNumber &lt;= rasterizer.PageCount; pageNumber++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> outputFileName = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"Page-{0:0000}.jpg"</span></span>, pageNumber); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> outputFilePath = Path.Combine(outputPath, outputFileName); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img = rasterizer.GetPage(DPI, DPI, pageNumber)) { img.Save(pageFilePath, ImageFormat.Jpeg); } } } } }</code> </pre> <br>  Working with GhostScriptNet is quite simple; we create an object of the GhostscriptRasterizer class that will provide functionality for converting document pages into objects of the Image class.  We set the parameters that I selected so that the result matches the AcrobatReader as much as possible.  Open the PDF file, cycle through the pages, getting Image objects.  We save in jpg files in in advance prepared directory. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/19f/ab6/eec/19fab6eeca734ee892c8ecff67cfee05.jpg"></div><br>  Now let's deal with printing using PrintDocument.  This class has a simple and intuitive interface, while it contains everything you need for flexible work with the printer.  It is better to see once than hear a hundred times, so go to the code. <br><br>  An example of a function for printing an image from a file: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Print</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> file</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Drawing.Printing.PrintDocument()) { pd.PrinterSettings.Duplex = Duplex.Simplex; pd.PrintPage += (o, e) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img = System.Drawing.Image.FromFile(file); e.Graphics.DrawImage(img, e.Graphics.VisibleClipBounds); }; pd.Print(); } }</code> </pre><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/592/450/6dc/5924506dcaf84161aae2c78d468723ea.jpg"></div><br>  The first thing you might need when working with a PrintDocument is to specify a printer.  This is done through the PrinterName property: <br><br><pre> <code class="cs hljs">pd.PrinterSettings.PrinterName = <span class="hljs-string"><span class="hljs-string">" "</span></span>;</code> </pre><br><br>  If this is not done, the default printer on the system will be used. <br><br>  The name of the printer can be obtained from the list of available printers: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> printrers = PrinterSettings.InstalledPrinters; pd.PrinterSettings.PrinterName = printrers[<span class="hljs-number"><span class="hljs-number">1</span></span>];</code> </pre><br><br>  To print multiple pages, the page handler should use the HasMorePages flag belonging to an object of the PrintPageEventArgs class.  The PrintPage handler will be called until HasMorePages == true. <br><br>  For example, HasMorePages can be used like this: <br><br><pre> <code class="cs hljs">e.HasMorePages = ++index &lt; pages.Count;</code> </pre><br><br>  To print double-sided documents, you must specify before printing: <br><br><pre> <code class="cs hljs">pd.PrinterSettings.Duplex = Duplex.Vertical;</code> </pre><br><br>  In this case, every 2 consecutive pages will be interpreted as pages of one sheet. <br><br>  To disable the print progress window, you need to specify a standard print controller: <br><br><pre> <code class="cs hljs">pd.PrintController = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StandardPrintController();</code> </pre><br><br>  Interesting from a practical point of view is the ability to specify the source of paper (tray).  And you can change the tray on the fly, i.e.  when one page comes from one tray, another - from another.  This means that you can print documents consisting, for example, of different types of paper, which are laid out in trays. <br><br>  You can specify the tray for the entire print as follows: <br><br><pre> <code class="cs hljs">pd.DefaultPageSettings.PaperSource = pd.PrinterSettings.PaperSources[SourceId];</code> </pre><br><br>  And for the page like this: <br><br><pre> <code class="cs hljs">e.PageSettings.PaperSource = pd.PrinterSettings.PaperSources[SourceId];</code> </pre><br><br>  In the second case, remember that e.PageSettings.PaperSource will only affect the next page.  Those.  we always have a one page delay: for the first page - pd.DefaultPageSettings.PaperSource, for all subsequent pages - e.PageSettings.PaperSource. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c87/a4f/be8/c87a4fbe8466404cb941e8b6b359cfe5.jpg"></div><br>  Now, by crossing the generation of images with print, you can write a simple program for outputting * .pdf files to a printer.  I will not give the code, because  nothing new in it will be.  In addition, the solution to the forehead has a significant drawback - a lot of machine resources are spent on render pages, so the print goes insanely long.  For example, printing a large 5000 page document will take at least 30 minutes, while Acrobat Reader would have done it in about 10 to 15 minutes.  Since most of the time is spent on image generation, then we will optimize it over time.  This process can be accelerated ten times or more, depending on the iron.  It is enough to parallelize the generation of images of pages.  In fact, such acceleration will be just a change of the time resource for the processor one. <br><br>  For parallelization we will use a pool of threads.  Each thread will process its own fragment of a document consisting of N pages.  The result will be added to the dictionary, where the key will be the number of the current page, and the value will be the MemoryStream.  ‚ÄúWhy Stream, and not, say, Bitmap?‚Äù A curious reader will ask.  It's simple.  The fact is that in Stream we will keep pages compressed in Jpeg format, thus saving memory, because 5000 pages is a lot.  As soon as all pages are calculated, we send them to the printer.  It is very easy to find out that the processing is over: the number of pages of the original document should match the number of elements of the dictionary. <br><br><div class="spoiler">  <b class="spoiler_title">In C #, the above can be expressed with the following code.</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Diagnostics; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Drawing.Imaging; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Drawing.Printing; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Ghostscript.NET; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Ghostscript.NET.Rasterizer; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">GS_Parallel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, MemoryStream&gt; PageStore; <span class="hljs-comment"><span class="hljs-comment">//   private const int Dpi = 200; private const int Quants = 30; private const int MaxThreads = 10; static void Main(string[] args) { PageStore = new Dictionary&lt;int, MemoryStream&gt;(); if (!args.Any()) { Console.WriteLine("{0} [*.pdf]", Path.GetFileName(Environment.GetCommandLineArgs()[0])); return; } var inputPdfPath = args[0]; ThreadPool.SetMaxThreads(MaxThreads, MaxThreads); var mainRasterizer = CreateRasterizer(inputPdfPath); //     var step = mainRasterizer.PageCount / Quants; var tail = mainRasterizer.PageCount % Quants; var shift = 0; for (var i = 0; i &lt; Quants; i++) { var wi = new WorkInfo() {StartPage = shift + 1, EndPage = shift + step, SourcefilePath = inputPdfPath}; ThreadPool.QueueUserWorkItem(PdfProcessing, wi); shift += step; } if (tail &gt; 0) { var wi = new WorkInfo() { StartPage = shift + 1, EndPage = shift + tail, SourcefilePath = inputPdfPath }; ThreadPool.QueueUserWorkItem(PdfProcessing, wi); } Console.WriteLine("Start preparation"); while (PageStore.Count &lt; mainRasterizer.PageCount) { //    Console.WriteLine("{0:000.0}%", ((double)PageStore.Count) / mainRasterizer.PageCount * 100); Thread.Sleep(100); } Console.WriteLine("Start printing"); PrintPages(PageStore); } static GhostscriptVersionInfo _lastInstalledVersion = GhostscriptVersionInfo.GetLastInstalledVersion(GhostscriptLicense.GPL | GhostscriptLicense.AFPL, GhostscriptLicense.GPL); static GhostscriptRasterizer CreateRasterizer(string file) { var rasterizer = new GhostscriptRasterizer(); rasterizer.CustomSwitches.Add("-dNOINTERPOLATE"); rasterizer.CustomSwitches.Add("-dCOLORSCREEN=0"); rasterizer.CustomSwitches.Add("-sPAPERSIZE=a4"); rasterizer.TextAlphaBits = 4; rasterizer.GraphicsAlphaBits = 4; rasterizer.Open(file, _lastInstalledVersion, true); return _rasterizer; } static void PdfProcessing(object stateInfo) { var wi = (WorkInfo)stateInfo; var rasterizer = CreateRasterizer(wi.SourcefilePath); for (var pageNumber = wi.StartPage; pageNumber &lt;= wi.EndPage; pageNumber++) { using (var img = rasterizer.GetPage(Dpi, Dpi, pageNumber)) { var mem = new MemoryStream(); img.Save(mem, ImageFormat.Jpeg); lock (PageStore) { PageStore[pageNumber] = mem; } } } } static void PrintPages(IReadOnlyDictionary&lt;int, MemoryStream&gt; pageStore) { using (var pd = new PrintDocument()) { pd.PrinterSettings.Duplex = Duplex.Simplex; pd.PrintController = new StandardPrintController(); var index = 0; pd.PrintPage += (o, e) =&gt; { var pageStream = pageStore[index + 1]; var img = System.Drawing.Image.FromStream(pageStream); e.Graphics.DrawImage(img, e.Graphics.VisibleClipBounds); index++; e.HasMorePages = index &lt; pageStore.Count; Console.WriteLine("Print {0} of {1}; complete {2:000.0}%", index, pageStore.Count, ((double)index) / pageStore.Count * 100); }; pd.Print(); } } } class WorkInfo { public int StartPage; public int EndPage; public string SourcefilePath; } }</span></span></code> </pre><br></div></div><br><br>  To save memory when saving Bitmap in a MemoryStream, you can increase the compression ratio. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Getting and configuration a jpeg encoder const long quality = 35L; var encoders = ImageCodecInfo.GetImageDecoders(); var jpgEncoder = encoders.FirstOrDefault(codec =&gt; codec.FormatID == ImageFormat.Jpeg.Guid); var encoderParams = new EncoderParameters(1); encoderParams.Param[0] = new EncoderParameter(Encoder.Quality, quality); //Save with the jpeg encoder img.Save(mems, jpgEncoder, encoderParams);</span></span></code> </pre><br><br>  However, an increase in the compression ratio will slow down processing and degrade the quality of printed documents. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c03/832/d2e/c03832d2e44f4eb58ac780a51480dda0.jpg"></div><br>  If the amount of printed data is very large (for example, automation of a mini-printing house), you can do even more interesting.  You can divide the task into two applications: one will render documents, the other will print.  Moreover, the result of the PDF rendering can be saved again in PDF.  When printing prepared PDFs, they no longer need to render them; it is enough to extract the saved images, which is done fairly quickly. <br><br>  Cycle of articles: <br>  <a href="https://habrahabr.ru/company/tcsbank/blog/279361/">Raster approach</a> <br>  <a href="https://habrahabr.ru/company/tcsbank/blog/283278/">Vector approach theory</a> <br>  <a href="https://habrahabr.ru/company/tcsbank/blog/302062/">Vector approach practice</a> </div><p>Source: <a href="https://habr.com/ru/post/279361/">https://habr.com/ru/post/279361/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279351/index.html">[Moscow] Meeting with Kotlin developers</a></li>
<li><a href="../279353/index.html">Shortcuts on the source page and other fixes in the Vivaldi 1.0.422.8 build</a></li>
<li><a href="../279355/index.html">March 24, QIWI will assemble Scala programmers at the ‚ÄúQIWI Scaladrom Meetup‚Äù</a></li>
<li><a href="../279357/index.html">Wix: development overlooking the sea</a></li>
<li><a href="../279359/index.html">Let's pay advertising your channel push-notifications in the amount of up to 10 thousand rubles</a></li>
<li><a href="../279367/index.html">Investigating the speed of a method call</a></li>
<li><a href="../279369/index.html">AirPlay server and Time Machine backup on MTK routers (and not only)</a></li>
<li><a href="../279371/index.html">Just another bike encryption</a></li>
<li><a href="../279373/index.html">Creating a draft interface form and dialog box map in PLANTUML</a></li>
<li><a href="../279375/index.html">CodingFuture + Puppet. Part IV: Centralized Management (cftotalcontrol)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>