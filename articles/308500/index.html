<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Navigator 2GIS: Extrapolation of the position of the car</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the application 2GIS now have a navigator. We learned to ‚Äúgo‚Äù on the track, voice maneuvers, automatically rebuild the route, calculate the time on...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Navigator 2GIS: Extrapolation of the position of the car</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/bde/60a/52d/bde60a52daf44369bfa94ba4519b587a.png"><br><br>  In the application 2GIS now have a navigator.  We learned to ‚Äúgo‚Äù on the track, voice maneuvers, automatically rebuild the route, calculate the time on the way, bring the user to the entrance to the building or organization, taking into account fences and barriers - all in an honest offline.  Traffic jams (except that they need the Internet), bridges and streets that have been blocked have been considered for a long time.  While in our navigator - the necessary minimum.  A little later we will teach him to warn about too high speed, speed bumps and traffic police cameras, set up the night mode, make the routes on toll and dirt roads optional.  To use it, you need to update 2GIS in your smartphone or download it in the <a href="https://itunes.apple.com/ru/app/id481627348">AppStore</a> or <a href="https://www.microsoft.com/ru-ru/store/p/2gis/9nblggh2rfsd%3Freferrer%3Dmat_click_id%253D886615118e9db1cfd6cbd97e63ab71e5-20160817-22254">Windows Store</a> .  For Android, the update comes out gradually, starting from August 22 (will be available to the entire audience by September). <br><br>  And today we will tell how the 2GIS navigator predicts the position of the car and smoothly moves the arrow along the route.  After all, the quality of the user's route guidance determines the ergonomics of the interface of any modern navigator, the simplicity of orientation on the terrain and the timeliness of maneuvers. <br><a name="habracut"></a><br>  Most of the time, the driver of the car has to follow the road, so even a quick glance at the screen of the device with the navigator program should be enough to get the most accurate and timely information about its location relative to the route and surrounding objects.  This seemingly simple functionality requires solving a number of technical problems for its implementation.  Some of them we consider. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  GPS marker and route </h3><br>  To mark the user's location on the map, many navigators (and ours are no exception) use a special GPS marker in the form of an arrowhead or simply a triangle, which intuitively indicates the direction of motion.  In addition, the marker should be clearly visible on the map, so its color is usually very different from the background, edges are additionally circled, etc. <br><br>  In the simplest case, you can display the position of the device on the ground, reading the coordinates from the GPS sensor and placing the marker in the appropriate place on the map.  Already here we are confronted with the first problem - the measurement error, which even in conditions of a good signal may well reach 20‚Äì30 meters. <br><br>  To answer the usual question ‚ÄúWhere am I?‚Äù This way of displaying will be quite sufficient, especially if around the marker we also draw a circle of accuracy with a radius equal to the estimated error.  However, to navigate, you need to come up with something better, because a driver moving along a city street is unlikely to be satisfied with a GPS marker located inside a neighboring house or, even worse, on some intra-block passage. <br><br>  The route built by the program to the destination point and always present in the navigation script helps to solve the problem.  With the help of some tweaks, we can ‚Äúpull‚Äù a point on the map to the route, leveling some of the measuring error of the GPS sensor.  In the first approximation, a draw can be viewed as projecting a point onto a route line.  Consideration of the same nuances, as well as ways to detect a route detour, unfortunately, is beyond the scope of this article. <br><br>  By adopting the indicated draw technique, we can abstract away from the two-dimensional geographic coordinates (latitude-longitude or any other) and move on to a one-dimensional coordinate ‚Äî an offset from the beginning of the route, measured, for example, in meters.  Such a transition simplifies both theoretical models and calculations performed on user devices. <br><br><h3>  Display geo-location in time </h3><br>  The discrete nature of the receipt of data from the GPS sensor is another problem when implementing user guidance along a route.  In the ideal case, the coordinates are updated once per second.  Consider several options for displaying the geo-location in time and choose the most suitable for our tasks. <br><br>  1. The easiest way is to receive each new sample from the sensor, immediately draw to the route and display the corresponding location on the map.  Among the advantages, it is worth noting the exceptional ease of implementation, high accuracy in a certain sense (after all, here we simply display satellite data without making any serious changes to them) and minimal computational complexity.  The main drawback is that the marker in this case does not move around the map in the usual sense, but ‚Äúteleports‚Äù from point to point.  In the main navigation scenarios, the camera (virtual observer - a term from the field of computer graphics) is tied to the GPS marker, so its teleportation like this leads to a sharp ‚Äúmisalignment‚Äù of the map along the route and, as a result, to the driver‚Äôs disorientation, especially at high speeds, when Between the geo-location counts, the car travels a considerable distance.  Our task is to help the user, and not confuse him, so this flaw is already enough to exclude this option from consideration. <br><br>  The only way to avoid disorientation is to move the GPS marker smoothly, without ‚Äúteleportation‚Äù, which means that you need to move it much more often than geo-location counts come.  To ensure such a movement, it is necessary to somehow calculate the intermediate points between the actual readings from the sensor and use them until the next reading is obtained.  The specific approach to the calculation of these intermediate points should be given special attention, since it ultimately greatly affects the overall ergonomics of the navigator program. <br><br>  2. The second way to display the user's location is associated with the most obvious approach to the generation of intermediate points - interpolation between the last real GPS samples.  The point is to move the marker from the penultimate count to the last for some specified time, calculating intermediate points with the required frequency from one of the known mathematical functions (the simplest option is <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B8%25D0%25BD%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B5%25D1%2580%25D0%25BF%25D0%25BE%25D0%25BB%25D1%258F%25D1%2586%25D0%25B8%25D1%258F">linear interpolation</a> ).  Using the navigator with this method is much more convenient, but it also has disadvantages. <br><br>  One of the most innocuous is the need to pre-set the interpolation time.  Installing it in one second will work well only in the ideal case mentioned above, when exactly so much time will pass between the GPS samples.  If less time passes ‚Äî it doesn't matter, you can simply start moving from your current position to a new target.  But if more - the marker will have to stand still and wait for new coordinates from the sensor, although the user's car may well move at this time. <br><br>  There is a more serious problem.  At the moment of arrival of a new reference, the marker is at best located at the previous real point.  From the user's point of view, we introduce another positioning error, the value of which is not less than the distance traveled by the vehicle during the time between readings.  At a speed of 100 km / h, this value reaches almost 28 meters, which, coupled with the possible measurement error, makes the information provided to the user unreliable, to say the least. <br><br>  We could make a huge GPS marker and block a quarter of the screen with it, carefully masking the flaws of the described positioning method, but going to a direct forgery would be a disrespect to users and to ourselves.  Accuracy and timeliness of the displayed data is no less important criterion when developing a navigator than external beauty and smooth movement. <br><br>  3. Taking into account the positioning accuracy requirement that has appeared, it is worth noting that now we are required to locate the marker at a point as close as possible to this new countdown, shortly before the arrival of the new GPS readout.  That is, in fact, look into the future, albeit briefly.  Although humankind has a bad time with the invention of the time machine, things are still there for us.  The movement of the car is inert, so the speed and direction of its movement cannot change instantly, and if so, we can try with some accuracy to predict where the user will be in the interval between the last countdown of the position and the future.  If we manage to ensure that the prediction error in most cases will be less than the error of the second method, then we will greatly facilitate the life of the users of our navigator. <br><br>  This kind of prediction in the exact sciences is called extrapolation.  It is this way that we will go in an attempt to develop a third method of route guidance that satisfies all the criteria listed above.  Next, we will have to resort to a more formal language of presentation, as soon as we speak about mathematical models. <br><br><h3>  Route guidance with position extrapolation </h3><br>  It was mentioned earlier that due to the user‚Äôs geo-location draw to the navigation route, we can move from two-dimensional geographic coordinates to a one-dimensional coordinate - offset relative to the beginning of the route (for brevity, we will use the term ‚Äúoffset‚Äù without further specification). <br><br>  Let us recall the data arriving to us and enter notations for them: <br><br><img src="https://tex.s2cms.ru/svg/s_i%2C%20i%5Cin%20%5Cmathbb%7BN%7D" alt="s_i, i \ in \ mathbb {N}">  - real offset readings obtained by the draw of the GPS position to the route line; <br><img src="https://tex.s2cms.ru/svg/t_i%2C%20i%5Cin%20%5Cmathbb%7BN%7D" alt="t_i, i \ in \ mathbb {N}">  - the arrival time of the corresponding offset samples. <br>  This, in fact, the list of input data ends.  We'll have to squeeze the maximum useful information out of them. <br><br>  Ultimately, we need to build an offset extrapolation function <img src="https://tex.s2cms.ru/svg/s%3Ds(t)%2Ct%20%5Cin%20%5Bt_0%3B%20%2B%5Cinfty)" alt="s = s (t), t \ in [t_0;  + \ infty)">  , which will be close to the real dynamics of the car and at the same time ensure the smoothness of the GPS marker movement throughout our route (its length will not affect anything, since the completion of the route is processed separately, therefore we will conditionally consider the route to be infinite).  Smoothness is enough to ensure good visual smoothness. <img src="https://tex.s2cms.ru/svg/s(t)" alt="s (t)">  , that is, neither the position nor the speed of the marker should change abruptly.  In other words, the function <img src="https://tex.s2cms.ru/svg/s(t)" alt="s (t)">  must be continuous with its first derivative (hereinafter - in time) throughout the domain of definition. <br><br>  Note that each real offset reading carries substantially new motion information.  For example, if for a long time the car drove evenly and then began to accelerate, the navigator can ‚Äúfeel‚Äù the acceleration only with the arrival of the next countdown.  Since we cannot look into the future for an arbitrarily long period of time, all incoming new GPS readings will generally change the behavior of the desired function. <img src="https://tex.s2cms.ru/svg/s(t)" alt="s (t)">  That does not allow to set it with a single analytical expression.  Instead, try to define the function piecewise.  To do this, we solve the simpler problem first. <br><br><h4>  Immediate piecewise extrapolation </h4><br>  We construct such an extrapolation displacement function <img src="https://tex.s2cms.ru/svg/s_i%20(t)%2Ct%5Cin%5Bt_i%3B%2B%5Cinfty)" alt="s_i (t), t \ in [t_i;  + \ infty)">  so that after <img src="https://tex.s2cms.ru/svg/i" alt="i">  countdown, its values ‚Äã‚Äãpredicted the actual location of the user for a sufficient time before the arrival <img src="https://tex.s2cms.ru/svg/(i%2B1)" alt="(i + 1)">  th countdown.  All useful data we possess is a sequence of readings to <img src="https://tex.s2cms.ru/svg/i" alt="i">  together with the time of receipt of each of them. <br><br>  Remembering the finite differences, we note that we have the opportunity to estimate the speed of the vehicle in <img src="https://tex.s2cms.ru/svg/i" alt="i">  moment of time, dividing the length of the segment between the last and the penultimate offset by the corresponding time interval: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/v_i%5Capprox%20%5Cfrac%7Bs_i-s_%7Bi-1%7D%7D%7Bt_i-t_%7Bi-1%7D%7D%3Ds_i%7B%5E'%7D%20(t_i)" alt="v_i \ approx \ frac {s_i-s_ {i-1}} {t_i-t_ {i-1}} = s_i {^ '} (t_i)"></div><br>  where <img src="https://tex.s2cms.ru/svg/v_i" alt="v_i">  - an estimate of the speed of the readings, and <img src="https://tex.s2cms.ru/svg/s_i%7B%5E'%7D%20(t_i)" alt="s_i {^ '} (t_i)">  - derivative of extrapolation function <img src="https://tex.s2cms.ru/svg/s_i%20(t)" alt="s_i (t)">  that we are trying to build. <br><br>  Similarly for higher order derivatives - acceleration, jerk, etc .: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0A%5Cleft%5C%7B%5Cbegin%7Baligned%7D%0Aa_i%5Capprox%20%5Cfrac%7Bv_i-v_%7Bi-1%7D%7D%20%7Bt_i-t_%7Bi-1%7D%7D%20%3D%20s_i%5E%7B''%7D%20%5C%5C%0Aj_i%5Capprox%20%5Cfrac%7Ba_i-a_%7Bi-1%7D%7D%20%7Bt_i-t_%7Bi-1%7D%7D%20%3D%20s_i%5E%7B'''%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A%5Cright.%0A" alt="\ left \ {\ begin {aligned} a_i \ approx \ frac {v_i-v_ {i-1}} {t_i-t_ {i-1}} = s_i ^ {''} \\ j_i \ approx \ frac {a_i -a_ {i-1}} {t_i-t_ {i-1}} = s_i ^ {'' '} \\ \ end {aligned} \ right."></div><br>  As can be seen from these formulas, to obtain an estimate of higher and higher derivatives of the displacement, it is necessary to take into account more and more samples preceding the current one: to determine the speed two counts are needed, three are needed for acceleration, four are needed for a jerk, etc.  On the one hand, the more dynamic characteristics of the movement we take into account in our forecast, the greater the modeling capacity we will get;  on the other hand, the useful information contained in more and more ‚Äúold‚Äù readings dramatically loses its relevance.  For example, the fact that we were traveling at a speed of 30 km / h a minute ago would not help us at the current time: since then, it was possible to accelerate several times, slow down or stop altogether.  For this reason, the estimates of higher and higher displacement derivatives are getting farther from reality;  In addition, the contribution of the error in calculating a certain derivative to the general analytical model of bias also increases with an increase in the order of this derivative.  If this is the case, then, starting with a certain order, the dynamic characteristics, estimated using finite differences, instead of specifying, will only spoil our model. <br><br>  According to the results of checks on real data, it turned out that the assessment of a jerk <img src="https://tex.s2cms.ru/svg/j_i" alt="j_i">  , especially in cases of the ‚Äúaverage‚Äù quality of the GPS signal, is already bad enough for it to do more harm than good.  On the other hand, fortunately, the most frequent scenarios of car dynamics are rest, uniform and uniform motion, described by polynomial equations of the 0th, 1st, and 2nd degrees of time, respectively. <br><br>  It turns out that a quadratic model of uniformly alternating traffic will be quite enough for us to describe most of the road situations, and for it we just have more or less qualitative assessments of the dynamic characteristics - speed and acceleration.  Recalling the school course of physics, we can already in outline form an analytical expression for the desired extrapolation function: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/s_i%20(t)%3Ds_i%2Bv_i%20t%2B%5Cfrac12%20a_i%20t%5E2" alt="s_i (t) = s_i + v_i t + \ frac12 a_i t ^ 2"></div><br>  It remains to do just one step: the scope <img src="https://tex.s2cms.ru/svg/s_i%20(t)" alt="s_i (t)">  starts from the moment of time <img src="https://tex.s2cms.ru/svg/t_i" alt="t_i">  therefore, it is more convenient to calculate time in calculations from the same moment. <br><br>  As a result, the function will take the form: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/s_i%20(t)%3Ds_i%2Bv_i%20(t-t_i%20)%2B%5Cfrac12%20a_i%20(t-t_i%20)%5E2%2Ct%E2%88%88%5Bt_i%3B%2B%5Cinfty)" alt="s_i (t) = s_i + v_i (t-t_i) + \ frac12 a_i (t-t_i) ^ 2, t‚àà [t_i; + \ infty)"></div><br>  A remarkable feature of this function is its smoothness over the entire domain, which, as mentioned earlier, is included in the formulation of our problem. <br><br>  Now, take some real offsets from the device and try to extrapolate them at each interval (although <img src="https://tex.s2cms.ru/svg/s_i%20(t)" alt="s_i (t)">  defined to <img src="https://tex.s2cms.ru/svg/%2B%5Cinfty" alt="+ \ infty">  at the moment of arrival <img src="https://tex.s2cms.ru/svg/t_%7Bi%2B1%7D" alt="t_ {i + 1}">  We will immediately move on to the next function. <img src="https://tex.s2cms.ru/svg/s_%7Bi%2B1%7D%20(t)" alt="s_ {i + 1} (t)">  because it has more recent data): <br><br><img src="https://habrastorage.org/files/72f/314/9de/72f3149de7084fca9ae2f01d08d29d74.png"><br><br>  Let's make a reservation that for clarity, the data was taken with a relatively low quality of the GPS signal, however, the situation in the figure is very real and can arise for any user. <br><br>  The smoothness of each extrapolation polynomial <img src="https://tex.s2cms.ru/svg/s_i%20(t)" alt="s_i (t)">  perfectly visible at the corresponding time interval, but the trouble is that at the junctions of the intervals the common gray curve suffers gaps, sometimes quite noticeable. <br><br>  Let's call the gap in <img src="https://tex.s2cms.ru/svg/i" alt="i">  moment of time by extrapolation error <img src="https://tex.s2cms.ru/svg/e_i" alt="e_i">  .  Indeed, it is this value that shows how inaccuracy each of our forecasts has towards the end of its time interval.  You can calculate the error value using the following expression: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/e_i%3Ds_%7Bi-1%7D%20(t_i%20)-s_i" alt="e_i = s_ {i-1} (t_i) -s_i"></div><br>  Alas, reduce the error to zero by varying the functions themselves. <img src="https://tex.s2cms.ru/svg/s_i%20(t)" alt="s_i (t)">  , we can not, because it would be equivalent to one hundred percent accuracy of vision of the future.  So, to solve our original problem of constructing a single function <img src="https://tex.s2cms.ru/svg/s(t)" alt="s (t)">  you have to somehow ‚Äúglue‚Äù the piecewise extrapolation polynomials between each other, that is, correct the errors that occur at the joints. <br><br><h4>  Error Correction Approach </h4><br>  In accordance with the notation chosen above, one can informally say that by the time a new reference comes <img src="https://tex.s2cms.ru/svg/s_i" alt="s_i">  we are at a point <img src="https://tex.s2cms.ru/svg/(s_i%2Be_i)" alt="(s_i + e_i)">  i.e.  shifted relative to the real position by the amount of error <img src="https://tex.s2cms.ru/svg/e_i" alt="e_i">  accumulated by the time <img src="https://tex.s2cms.ru/svg/t_i" alt="t_i">  previous extrapolation polynomial <img src="https://tex.s2cms.ru/svg/s_%7Bi-1%7D%20(t)" alt="s_ {i-1} (t)">  . <br><br>  On the one hand, from the point of view of compliance with the data provided to the user of reality, the best way to correct the error <img src="https://tex.s2cms.ru/svg/e_i" alt="e_i">  there will be a function gap <img src="https://tex.s2cms.ru/svg/s(t)" alt="s (t)">  to the starting point of the next polynomial <img src="https://tex.s2cms.ru/svg/s_i" alt="s_i">  however, we cannot do this, because in this case we will again ‚Äúteleport‚Äù the marker on the map and disorient the driver. <br><br>  Obviously, if the instantaneous change in value <img src="https://tex.s2cms.ru/svg/s(t)" alt="s (t)">  Invalid, error correction will take some non-zero time.  It is also clear that it is desirable to complete the correction of the error before the next reading comes in order to prevent the accumulation of error. <br><br>  Due to the stochastic nature of the time intervals between offsets, it is not possible to reliably determine the exact time of the correction.  Therefore, in the first approximation, we fix the error correction time in the form of a certain constant value, the specific value of which <img src="https://tex.s2cms.ru/svg/T" alt="T">  we will select in the future by practical consideration. <br><br>  If you speak informally again, to correct the error is required from the point <img src="https://tex.s2cms.ru/svg/(t_i%3Bs_i%2Be_i)" alt="(t_i; s_i + e_i)">  during <img src="https://tex.s2cms.ru/svg/T" alt="T">  smoothly ‚Äúreturn‚Äù to the next extrapolation polynomial - curve <img src="https://tex.s2cms.ru/svg/s_i%20(t)" alt="s_i (t)">  . <br><br>  To describe the error correction process, it is convenient to introduce separate correction functions. <img src="https://tex.s2cms.ru/svg/e_i%20(t)" alt="e_i (t)">  so that at time <img src="https://tex.s2cms.ru/svg/t_i" alt="t_i">  the corresponding correction function has a value <img src="https://tex.s2cms.ru/svg/e_i" alt="e_i">  , and from the moment <img src="https://tex.s2cms.ru/svg/(t_i%2BT)" alt="(t_i + T)">  became zero: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0A%5Cleft%5C%7B%0A%5Cbegin%7Barray%7D%7Blcl%7D%0Ae_i%20(t_i%20)%3De_i%5C%5C%0Ae_i%20(t)%3D0%2Ct%5Cin%5Bt_i%2BT%2C%5Cinfty)%5C%5C%0A%5Cend%7Barray%7D%20%0A%5Cright.%0A" alt="\ left \ {\ begin {array} {lcl} e_i (t_i) = e_i \\ e_i (t) = 0, t \ in [t_i + T, \ infty) \\ \ end {array} \ right."></div><br>  If we add such a correction function with the corresponding interpolation polynomial, then at key points <img src="https://tex.s2cms.ru/svg/t_i" alt="t_i">  and <img src="https://tex.s2cms.ru/svg/(t_i%2BT)" alt="(t_i + T)">  we will provide offset error correction: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0A%5Cleft%5C%7B%0A%5Cbegin%7Barray%7D%7Blcl%7D%0As_%7Bi-1%7D%20(t_i)%2B%20e_i(t_i)%3Ds_i(t_i)%5C%5C%0As_i(t_i%2BT)%20%2B%20e_i(t_i%2BT)%3Ds_i(t_i%2BT)%5C%5C%0A%5Cend%7Barray%7D%20%0A%5Cright.%0A" alt="\ left \ {\ begin {array} {lcl} s_ {i-1} (t_i) + e_i (t_i) = s_i (t_i) \\ s_i (t_i + T) + e_i (t_i + T) = s_i (t_i + T) \\ \ end {array} \ right."></div><br>  Let's call the corrected offset function <img src="https://tex.s2cms.ru/svg/r_i%20(t)" alt="r_i (t)">  the sum of the extrapolation polynomial and the corresponding correction function: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/r_i%20(t)%3Ds_i%20(t)%2Be_i%20(t)" alt="r_i (t) = s_i (t) + e_i (t)"></div><br>  Note that due to the properties of the correction functions described above, we obtained a very important property of the functions <img src="https://tex.s2cms.ru/svg/r_i%20(t)" alt="r_i (t)">  - they are already ‚Äústitched by offset‚Äù, i.e.  do not tolerate gaps in the points <img src="https://tex.s2cms.ru/svg/t_i" alt="t_i">  : <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/r_i%20(t_i%20)%3Dr_%7Bi-1%7D%20(t_i%20)" alt="r_i (t_i) = r_ {i-1} (t_i)"></div><br>  The set of adjusted functions <img src="https://tex.s2cms.ru/svg/r_i%20(t)" alt="r_i (t)">  could claim to be the desired displacement model <img src="https://tex.s2cms.ru/svg/s(t)" alt="s (t)">  , defined at all times, if not for one circumstance: despite the absence of discontinuities at the points <img src="https://tex.s2cms.ru/svg/t_i" alt="t_i">  , the derivatives of this set of functions are generally still broken. <br><br>  Specifically, we are interested in breaking the first derivative - the speed, because the initial requirements contain a condition for ubiquitous smoothness <img src="https://tex.s2cms.ru/svg/s(t)" alt="s (t)">  i.e.  condition of ubiquitous speed continuity.  With this in mind, it is necessary to expand the requirements for correction functions. <img src="https://tex.s2cms.ru/svg/e_i%20(t)" alt="e_i (t)">  , to "sew" more and derivatives of the corrected functions <img src="https://tex.s2cms.ru/svg/r_i%20(t)" alt="r_i (t)">  : <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/r_i%5E%7B'%7D%20(t_i%20)%3Dr_%7Bi-1%7D%5E%7B'%7D%20(t_i%20)" alt="r_i ^ {'} (t_i) = r_ {i-1} ^ {'} (t_i)"></div><br>  This equation is a condition for the smoothness of the set of corrected functions.  Substituting the definition of the adjusted functions in both sides of the equation, we obtain <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/s_i%5E%7B'%7D%20(t_i)%2Be_i%5E%7B'%7D%20(t_i%20)%3Ds_%7Bi-1%7D%5E%7B'%7D%20(t_i%20)%2Be_%7Bi-1%7D%5E%7B'%7D%20(t_i%20)" alt="s_i ^ {'} (t_i) + e_i ^ {'} (t_i) = s_ {i-1} ^ {'} (t_i) + e_ {i-1} ^ {'} (t_i)"></div><br>  Earlier we mentioned that after the expiration of the correction time <img src="https://tex.s2cms.ru/svg/T" alt="T">  the correction function takes on zero values.  Add one more requirement to the correction function - let its derivative after zero of the correction time also take zero values: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/e_i%5E%7B'%7D%20(t)%3D0%2Ct%5Cin%5Bt_i%2BT%2C%5Cinfty)" alt="e_i ^ {'} (t) = 0, t \ in [t_i + T, \ infty)"></div><br>  Then, assuming that the correction time is always less than the interval between samples, we can assume that the derivative <img src="https://tex.s2cms.ru/svg/i" alt="i">  correction function by the time of the next count <img src="https://tex.s2cms.ru/svg/t_%7Bi%2B1%7D" alt="t_ {i + 1}">  already go to zero.  Then, returning to the condition of smoothness, we get: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/s_i%5E%7B'%7D%20(t_i%20)%2Be_i%5E%7B'%7D%20(t_i%20)%3Ds_%7Bi-1%7D%5E%7B'%7D%20(t_i%20)%2B0" alt="s_i ^ {'} (t_i) + e_i ^ {'} (t_i) = s_ {i-1} ^ {'} (t_i) +0"></div><br>  Express from here <img src="https://tex.s2cms.ru/svg/e_i%5E%7B'%7D%20(t_i%20)" alt="e_i ^ {'} (t_i)">  : <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/e_i%5E%7B'%7D%20(t_i%20)%3Ds_%7Bi-1%7D%5E%7B'%7D%20(t_i%20)-s_i%5E%7B'%7D%20(t_i%20)" alt="e_i ^ {'} (t_i) = s_ {i-1} ^ {'} (t_i) -s_i ^ {'} (t_i)"></div><br><br>  notice, that <img src="https://tex.s2cms.ru/svg/s_i%5E%7B'%7D%20(t_i%20)" alt="s_i ^ {'} (t_i)">  is an estimate of speed, made with the help of finite differences, we substitute it: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/e_i%5E%7B'%7D%20(t_i%20)%3Ds_%7Bi-1%7D%5E%7B'%7D%20(t_i%20)-v_i" alt="e_i ^ {'} (t_i) = s_ {i-1} ^ {'} (t_i) -v_i"></div><br>  The right-hand side is an extrapolation error of speed ‚Äî the difference between the speed obtained from the previous extrapolation polynomial and the ‚Äúreal‚Äù speed reference.  Now we can put together the boundary conditions for the correction functions: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0A%5Cleft%5C%7B%0A%5Cbegin%7Barray%7D%7Blcl%7D%0Ae_i(t_i)%20%3D%20e_i%5C%5C%0Ae_i%5E%7B'%7D(t_i)%20%3D%20s_%7Bi-1%7D%5E%7B'%7D(t_i)-v_i%5C%5C%0Ae_i(t_i)%20%3D%200%2C%20t%5Cin%5Bt_i%2BT%2C%2B%5Cinfty%5D%20%5C%5C%0Ae_i%5E%7B'%7D(t_i)%20%3D%200%2C%20t%5Cin%5Bt_i%2BT%2C%2B%5Cinfty%5D%20%5C%5C%0A%5Cend%7Barray%7D%20%0A%5Cright.%0A" alt="\ left \ {\ begin {array} {lcl} e_i (t_i) = e_i \\ e_i ^ {'} (t_i) = s_ {i-1} ^ {'} (t_i) -v_i \\ e_i (t_i) = 0, t \ in [t_i + T, + \ infty] \\ e_i ^ {'} (t_i) = 0, t \ in [t_i + T, + \ infty] \\ end {array} \ right."></div><br>  Words can describe them like this - it is necessary to find the correction function in order to: <br><ul><li>  at the beginning of the correction interval, its value coincided with the bias extrapolation error; </li><li>  at the beginning of the correction interval, the value of its derivative coincided with the velocity extrapolation error; </li><li>  at the end of the correction interval and further, the value of the function itself and its derivative was zero. </li></ul><br><br><h4>  Selection of error correction function </h4><br>  It should be noted that to obtain a single analytical expression for the correction functions <img src="https://tex.s2cms.ru/svg/e_i%20(t)" alt="e_i (t)">  , exactly satisfying the above four conditions is very difficult.  The problem lies in the part of the domain that goes after the correction time expires. <img src="https://tex.s2cms.ru/svg/T" alt="T">  , - it is necessary to achieve zero values ‚Äã‚Äãof the function and its derivative on the entire remainder of the numerical axis.  To simplify the task, we reduce the domain of definition of the desired analytical expression of the correction function to the correction interval. <img src="https://tex.s2cms.ru/svg/%5Bt_i%2Ct_i%2BT)" alt="[t_i, t_i + T)">  , and after its upper boundary we will consider the value of the function and its derivative to be trivially zero (good, at the level of the program code we have this possibility due to the presence of branching). <br><br>  Formally, taking this technique into account, the correction function is piecewise ‚Äî some expression for the correction interval and a constant 0 further, however, subject to the boundary conditions at the point <img src="https://tex.s2cms.ru/svg/(t%E3%80%97_i%2BT)" alt="(t„Äó _i + T)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neither the correction function itself nor its first derivative will break. </font><font style="vertical-align: inherit;">Since the discontinuities of the higher derivatives do not interest us (they do not spoil the smoothness of the desired function </font></font><img src="https://tex.s2cms.ru/svg/s(t)" alt="s(t)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), we will not mention the zero ‚Äútail‚Äù of the correction function in the future, and reformulate the boundary conditions in a more convenient form:</font></font><br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0A%5Cleft%5C%7B%0A%5Cbegin%7Barray%7D%7Blcl%7D%0Ae_i(t_i)%20%3D%20e_i%5C%5C%0Ae_i%5E%7B'%7D(t_i)%20%3D%20s_%7Bi-1%7D%5E%7B'%7D(t_i)-v_i%5C%5C%0Ae_i(t_i%2BT)%20%3D%200%5C%5C%0Ae_i%5E%7B'%7D(t_i%2BT)%20%3D%200%5C%5C%0A%5Cend%7Barray%7D%20%0A%5Cright.%0A" alt="\left\{
\begin{array}{lcl}
e_i(t_i) = e_i\\
e_i^{'}(t_i) = s_{i-1}^{'}(t_i)-v_i\\
e_i(t_i+T) = 0\\
e_i^{'}(t_i+T) = 0\\
\end{array} 
\right."></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Denote the error of the extrapolation of speed through </font></font><img src="https://tex.s2cms.ru/svg/%CE%B5_i%3Ds_%7Bi-1%7D%5E%7B'%7D(t_i)-v_i" alt="Œµ_i=s_{i-1}^{'}(t_i)-v_i">  : <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0A%5Cleft%5C%7B%0A%5Cbegin%7Barray%7D%7Blcl%7D%0Ae_i(t_i)%20%3D%20e_i%5C%5C%0Ae_i%5E%7B'%7D(t_i)%20%3D%20%5Cvarepsilon_i%5C%5C%0Ae_i(t_i%2BT)%20%3D%200%5C%5C%0Ae_i%5E%7B'%7D(t_i%2BT)%20%3D%200%5C%5C%0A%5Cend%7Barray%7D%20%0A%5Cright.%0A" alt="\left\{
\begin{array}{lcl}
e_i(t_i) = e_i\\
e_i^{'}(t_i) = \varepsilon_i\\
e_i(t_i+T) = 0\\
e_i^{'}(t_i+T) = 0\\
\end{array} 
\right."></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now you need to define an analytical expression for </font></font><img src="https://tex.s2cms.ru/svg/e_i%20(t)" alt="e_i (t)">  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Due to ergonomic program requirements, in addition to the boundary conditions, it is necessary that the correction function has as few extremes and excesses as possible in the correction interval - so that the GPS marker ‚Äúdoes not twitch‚Äù. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The simplest function suitable for these requirements is again a polynomial - a polynomial of the smallest possible degree of time </font></font><img src="https://tex.s2cms.ru/svg/t" alt="t"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(theoretically, the sine also has similar characteristics among the elementary functions, but it is more expensive to calculate its value in terms of CPU time). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the boundary conditions are a system of four non-trivial equations, the minimum degree of the polynomial that provides sufficient parametrization of the correction function is the third. Considering that when constructing an analytical expression for</font></font><img src="https://tex.s2cms.ru/svg/e_i%20(t)" alt="e_i (t)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it is more convenient to count the time from the moment of the </font></font><img src="https://tex.s2cms.ru/svg/i" alt="i"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ith reference (exactly the same as in the definition </font></font><img src="https://tex.s2cms.ru/svg/s_i%20(t))" alt="s_i (t))"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the desired polynomial takes the following form:</font></font><br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/e_i%20(t)%3DC_3%20%E3%80%96(t-t_i)%E3%80%97%5E3%2BC_2%20%E3%80%96(t-t_i)%E3%80%97%5E2%2BC_1%20(t-t_i%20)%2BC_0" alt="e_i (t)=C_3 „Äñ(t-t_i)„Äó^3+C_2 „Äñ(t-t_i)„Äó^2+C_1 (t-t_i )+C_0"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Substituting this expression into the system of boundary conditions and solving it with respect to constants </font></font><img src="https://tex.s2cms.ru/svg/C_3%2CC_2%2CC_1" alt="C_3,C_2,C_1">  and <img src="https://tex.s2cms.ru/svg/C_0" alt="C_0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we get the following values: </font></font><br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0A%5Cleft%5C%7B%0A%5Cbegin%7Barray%7D%7Blcl%7D%0AC_3%20%3D%20%5Cfrac%20%7B%5Cvarepsilon_iT%20%2B%202e_i%7D%20%7BT%5E3%7D%20%5C%5C%0AC_2%20%3D%20-%20%5Cfrac%20%7B2%5Cvarepsilon_iT%20%2B%202e_i%7D%20%7BT%5E3%7D%20%5C%5C%0AC_1%20%3D%20%5Cvarepsilon_i%20%5C%5C%0AC_0%20%3D%20e_i%20%5C%5C%0A%5Cend%7Barray%7D%20%0A%5Cright.%0A" alt="\left\{
\begin{array}{lcl}
C_3 = \frac {\varepsilon_iT + 2e_i} {T^3} \\
C_2 = - \frac {2\varepsilon_iT + 2e_i} {T^3} \\
C_1 = \varepsilon_i \\
C_0 = e_i \\
\end{array} 
\right."></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, if the correction functions are determined in </font></font><img src="https://tex.s2cms.ru/svg/e_i%20(t)" alt="e_i (t)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the manner described, the corrected functions are </font></font><img src="https://tex.s2cms.ru/svg/r_i%20(t)" alt="r_i (t)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">merged into a single extrapolation function </font></font><img src="https://tex.s2cms.ru/svg/s(t)" alt="s(t)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, smooth at all points in time. </font></font><img src="https://tex.s2cms.ru/svg/s(t)" alt="s(t)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will not give the </font><font style="vertical-align: inherit;">full expression for </font><font style="vertical-align: inherit;">its cumbersomeness. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note: the last inaccuracy remained in the assumption when choosing the correction time </font></font><img src="https://tex.s2cms.ru/svg/T" alt="T"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- our reasoning was built in light of the condition that </font></font><img src="https://tex.s2cms.ru/svg/T" alt="T"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">there will always be less than the interval between readings:</font></font><br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/(%5Cforall%20i%20%5Cin%20%5Cmathbb%7BN%7D)(T%3Ct_i-t_%7Bi-1%7D)" alt="(\forall i \in \mathbb{N})(T&amp;lt;t_i-t_{i-1})"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A nice feature of the constructed model </font></font><img src="https://tex.s2cms.ru/svg/s(t)" alt="s(t)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is that it is enough for us to choose </font></font><img src="https://tex.s2cms.ru/svg/T" alt="T"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in such a way that it does not exceed the average time between samples: if the individual intervals </font></font><img src="https://tex.s2cms.ru/svg/(t_i-t_%7Bi-1%7D)" alt="(t_i-t_{i-1})"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are smaller </font></font><img src="https://tex.s2cms.ru/svg/T" alt="T"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then the part of the error that we did not have time to correct for too short an interval will be corrected on one of the following. To do this, it will suffice to calculate the extrapolation error not by the usual extrapolation function </font></font><img src="https://tex.s2cms.ru/svg/s_i%20(t)" alt="s_i (t)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but by the corrected</font></font><img src="https://tex.s2cms.ru/svg/r_i%20(t)" alt="r_i (t)">  : <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/e_i%3Dr_%7Bi-1%7D%20(t_i%20)-s_i" alt="e_i=r_{i-1} (t_i )-s_i"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The figure below shows an example of a graph of the final extrapolation function </font></font><img src="https://tex.s2cms.ru/svg/s(t)" alt="s(t)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, built on real data: The </font></font><br><br><img src="https://habrastorage.org/files/6f3/d31/28f/6f3d3128f83a472ab04c2ede409ac097.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">formal problem is solved, the resulting curve satisfies all the specified conditions, and it looks quite nice. </font><font style="vertical-align: inherit;">It would be possible to relax on this, but the features of the real world present certain difficulties for the constructed idealized system. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let us consider some of them in more detail, making a reservation that all the decisions made later are implemented directly in the program code outside of the mathematical model.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adaptation of the mathematical model to real conditions </font></font></h3><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The prohibition of movement of the marker in the opposite direction </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the last graph, you can see that in some cases, the function </font></font><img src="https://tex.s2cms.ru/svg/s(t)" alt="s(t)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">starts to decrease, even when the user is driving only forward along the route based on real counts. This happens when our forecast strongly overestimates the speed of movement. On the other hand, in reality, the car moves in the opposite direction only for two reasons: the driver actually turned on the rear gear and went back (a very rare case), or performed a U-turn. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the case of a turn, the road situation changes significantly, which requires rebuilding the navigation route; This is a separate topic and does not fit into the framework of this article. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we use the results of position extrapolation by</font></font><img src="https://tex.s2cms.ru/svg/s(t)" alt="s(t)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">directly, then from all movements of the marker in the direction of the beginning of the route, the disappearing minority will correspond to the real movement of the car in the same direction. In light of this, it was decided to ban the marker from moving back without rebuilding the route, so as not to mislead users. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such a rigid condition is difficult to describe in the language of mathematics, but it is relatively easy to implement in the program code. To begin with, we will take into account the discrete nature of model time </font></font><img src="https://tex.s2cms.ru/svg/t" alt="t"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äî due to the peculiarities of the functioning of computers, we will in any case obtain extrapolation results at some selected points in time.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If this is the case, it will not be difficult to ensure that the extrapolated offset does not decrease: it is enough to compare the new value obtained with the previous one, and if the current value is less, then replace it with the previous one. </font><font style="vertical-align: inherit;">Despite the apparent rudeness of this technique, we will not break the smoothness of the extrapolation function, because in order to start moving back along the smooth function, you must first stop completely. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the future, the mode of operation, when we replace the mathematically correct values </font></font><img src="https://tex.s2cms.ru/svg/s(t)" alt="s(t)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with older ones in order to prevent movement backwards, will be called the forced stop mode.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Too big extrapolation errors and too long intervals between readings. </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despite the fact that we have built a quality function in a certain sense </font></font><img src="https://tex.s2cms.ru/svg/s(t)" alt="s(t)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sometimes extrapolation errors can reach unacceptable values. </font><font style="vertical-align: inherit;">In these cases, the program should stop trying to correct errors by regular means. </font><font style="vertical-align: inherit;">Another situation, when extrapolated data loses relevance, occurs if a new offset reading for some reason does not arrive for too long - the modeling ability </font></font><img src="https://tex.s2cms.ru/svg/s(t)" alt="s(t)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drops dramatically from the moment of receiving the last readout. </font><font style="vertical-align: inherit;">In order not to cross the line between prediction attempts and shameless lies, relying on a model usually takes no longer than three seconds. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For simplicity, we call the first negative situation an uncorrected bias error, and the second an uncorrectable time error.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We can work with each of these types of errors in two ways: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enter the above forced stop mode. </font><font style="vertical-align: inherit;">The advantage of this approach is in preserving the smoothness of movement of a geo-position marker on a terrain map. </font><font style="vertical-align: inherit;">However, the longer we are in the forced stop mode, the worse we inform the user about its real location;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instantly teleport the GPS marker to the place of the last reading. </font><font style="vertical-align: inherit;">Here, on the contrary, we sacrifice ergonomics for the sake of reliability of the information provided to the user.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For our application, the first method was chosen, as smooth attention is paid to especially close attention. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prolonged forced stop mode </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Any entry into the forced stop mode is associated with the issuance of less accurate location data in order to prevent the reverse movement of the GPS marker. In order not to misinform the user in particularly unfavorable cases, our model is additionally endowed with the ability to interrupt the forced stop mode by ‚Äúteleportation‚Äù the marker to the last real position after a specified period of time, regardless of the reason for entering the mode (mathematical result of extrapolation or uncorrectable offset / time errors) . At this point, even the smoothness of the movements has to be sacrificed for the sake of the "remnants" of accuracy.</font></font><br><br><h3>  findings </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result of the work done, we were able to improve the route guidance so as to ensure a good balance between the accuracy of the output data and the visual ergonomics of their display. The user will feel quite comfortable, especially when quality data is received from the GPS sensor due to a good signal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The described extrapolation system can be used in other applications using geolocation. Where the concepts of a route, and therefore displacement relative to its beginning, do not exist, a mathematical model from a one-dimensional scalar can be generalized to a multidimensional vector. The implementation of the model itself in the code is not a problem in any of the popular programming languages ‚Äã‚Äã- this requires only simple arithmetic operations.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As for further development paths, you should pay attention to the measurement error mentioned in the beginning of the article in the ‚Äúraw‚Äù position data from the sensor. </font><font style="vertical-align: inherit;">If we are already trying to correct the errors of our forecasting, then the struggle with measurement errors is a separate layer of work for the future, difficult, but no less interesting. </font><font style="vertical-align: inherit;">The benefits of potential success in this field for the accuracy of the displayed information can not be overestimated.</font></font></div><p>Source: <a href="https://habr.com/ru/post/308500/">https://habr.com/ru/post/308500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308486/index.html">From the experience of using SObjectizer: are the actors in the form of finite automata - is it bad or good?</a></li>
<li><a href="../308488/index.html">Using trigrams for correcting recognition results</a></li>
<li><a href="../308490/index.html">Unexpected behavior of the WinAPI function IsWow64Process ()</a></li>
<li><a href="../308494/index.html">How to give an adequate estimate of the time when uncertainty hits the head</a></li>
<li><a href="../308498/index.html">Air Berlin: Progressive Web App Implementation</a></li>
<li><a href="../308504/index.html">Over 9000: unobvious difficulties of working with counters of social buttons (+ task)</a></li>
<li><a href="../308506/index.html">Building complex SCADA (bad example)</a></li>
<li><a href="../308508/index.html">Modern art on the screen of a hardware company engineer</a></li>
<li><a href="../308510/index.html">Microsoft offers free Windows Server 2016 Datacenter licenses for customers who refuse VMware</a></li>
<li><a href="../308512/index.html">Attackers use Twitter to manage malware for Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>