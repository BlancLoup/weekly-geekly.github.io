<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>2D magic in detail. Part two. Structure</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Remember the famous meme about "korovovany"? Probably, everyone who develops games (or would like to do this) is thinking about a certain ‚Äúdream proje...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>2D magic in detail. Part two. Structure</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/324/c6f/ba9/324c6fba96224374a998f621e8b7b6c6.png"><br><p><br>  Remember the famous meme about "korovovany"?  Probably, everyone who develops games (or would like to do this) is thinking about a certain ‚Äúdream project‚Äù, where it will be possible to ‚Äúrob korovanov‚Äù and ‚Äúfill in‚Äù.  And also, so that the weather changed dynamically, and the traces of boots on the dirt remained, and the trees grew in real time.  And also to ... </p><br><p>  It is clear that in a real game project such a pursuit of Wishlocks - death is similar.  But in the techno-demo - the very thing. </p><a name="habracut"></a><br><h2 id="predyduschie-stati">  Previous articles </h2><br><p>  <a href="https://habrahabr.ru/post/305252">Part one.</a>  <a href="https://habrahabr.ru/post/305252">Shine.</a> <br>  <b>Part two.</b>  <b>Structure.</b> <br>  <a href="https://habrahabr.ru/post/313776/">Part Three</a>  <a href="https://habrahabr.ru/post/313776/">Global coverage.</a> </p><br><h2 id="oglavlenie">  Table of contents </h2><br><ol><li>  Introduction </li><li>  Sprites </li><li>  Polygons </li><li>  Pixel perfect and integer geometry </li><li>  Old project structure </li><li>  Region tree </li><li>  Managers </li><li>  Post effects </li><li>  Thoughts about the future </li></ol><br><h2 id="vstuplenie">  Introduction </h2><br><p>  Let me remind you that in the last part there was a survey: on what topic to write the next article.  And the dynamic water seemed to the community the most interesting.  But it‚Äôs a long story and you‚Äôll have to start with the project structure and the algorithms that are used under the hood, and then talk about the lighting improvements and post-effects.  The text will be big, so the water moves on to one of the nearest articles.  By the way, this article contains fewer beautiful renders, but much more technical hints.  Do not be bored. </p><br><p>  Much has been done since the writing of the previous article.  The entire project code was rewritten completely, algorithms were optimized, new light sources were added, background lighting was implemented, water with highlights, waves, boiling and freezing was implemented.  As you can see - not a word about the characters or the gameplay component, it is still ahead.  I will not get ahead of myself and tell you everything in order. </p><br><h2 id="sprayty">  Sprites </h2><br><p>  Our project is about magicians, which means that we cannot do without old stone castles.  That's just to draw each from scratch - more expensive.  Let's try to collect them from small pieces, for example, like this: </p><br><img src="https://habrastorage.org/files/e48/16a/380/e4816a3807984008a975f931a3d0b222.png"><br><p>  <em>Neat pieces from which you can make everything.</em> </p><br><p>  In order for these pieces to have a common outline, we will write some kind of shader, and the static batching in Unity3d optimizes the number of draw calls.  That's just to get a common contour, you have to use a two-pass shader with stencil buffer: the first part will draw the contours, and the second - the fill.  And any elements that use materials with multipass shaders are <a href="https://docs.unity3d.com/Manual/DrawCallBatching.html">not involved</a> in batching <a href="https://docs.unity3d.com/Manual/DrawCallBatching.html">.</a>  It is better to draw each sprite twice, but with different materials.  The number of vertices will increase, but there will be only two draw calls. </p><br><img src="https://habrastorage.org/files/49b/77d/32e/49b77d32e5094ffcb9d8a6fb10e633b1.png"><br><p>  <em>Render a solid outline.</em> </p><br><img src="https://habrastorage.org/files/8fc/f4a/701/8fcf4a70103f4f82871590f8939ce20e.png"><br><p>  <em>Add texture.</em> </p><br><p>  In such a simple way we can create such a castle: </p><br><img src="https://habrastorage.org/files/fb3/51f/e97/fb351fe97c87447abd9f3a00f626eb72.png"><br><p>  <em>Walls in the editor.</em>  <em>The texture and color of the contour can be configured separately.</em> </p><br><div class="spoiler">  <b class="spoiler_title">Hints and pitfalls</b> <div class="spoiler_text"><ol><li>  <strong>We remove copy-paste.</strong>  Of course, you should not copy the sprites with your hands.  I have a <em>Contour</em> class that contains all the necessary settings for the sprite and 2 materials.  When appearing on the scene, this class creates two heirs with a <em>SpriteRenderer</em> (for the contour and background). </li></ol><br><img src="https://habrastorage.org/files/3f6/b65/828/3f6b65828a6c4ddda85217d731f6fb47.png"><br><p><br></p><br><ol><li><p>  <strong>We automate the transfer.</strong>  Initially, I already had prefabs sprites that were used on the stage (several hundred elements).  When I decided to wrap them in <em>Contour</em> , for some reason, the changes to the prefabs were not applied to the objects created.  Fortunately, you can easily write a script that for each existing element will find the corresponding prefab (by name) and create an element from this prefab in the desired position.  Key Methods - <a href="https://docs.unity3d.com/ScriptReference/AssetDatabase.LoadAssetAtPath.html">UnityEditor.AssetDatabase.LoadAssetAtPath</a> and <a href="https://docs.unity3d.com/ScriptReference/PrefabUtility.ConnectGameObjectToPrefab.html">UnityEditor.PrefabUtility.ConnectGameObjectToPrefab</a> </p><br></li><li><p>  <strong>Proper drag'n'drop.</strong>  Minus the division into sprites - now, by default, one of the heirs sprites is selected and used in drag'n'drop on the stage.  The problem is solved by adding the attribute <a href="https://docs.unity3d.com/ScriptReference/SelectionBaseAttribute.html">[SelectionBase]</a> before the class <em>Contour</em> . </p><br></li><li><p>  <strong>Display prefabs.</strong>  In the project menu, prefabs with contours are no longer displayed as sprites, and, honestly, I have not found a way to generate the icon myself.  Therefore, I added <em>SpriteRenderer to the prefabs</em> , the sprite to which my <em>Contour</em> asks.  When adding to the scene, I <em>remove the SpriteRenderer</em> not needed in the gameplay from the object. </p><br></li><li><p>  <strong>Uninstall from OnValidate</strong> .  When adding an object to the scene, <em>OnValidate</em> is <em>called</em> and it is there that I delete the <em>SpriteRenderer</em> .  However, neither <em>Destroy</em> nor <em>DestroyImmediate works</em> in this method (without witchcraft with its own class editor), so I use this crutch: </p><br><pre><code class="hljs kotlin">#<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR void OnValidate() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UnityEditor.PrefabUtility.GetPrefabParent(gameObject) == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; UnityEditor.PrefabUtility.GetPrefabObject(gameObject) != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> renderer = GetComponent&lt;SpriteRenderer&gt;(); renderer.sprite = sprite; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> renderer = GetComponent&lt;SpriteRenderer&gt;(); UnityEditor.EditorApplication.delayCall+=()=&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (renderer == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; DestroyImmediate(renderer); }; } } #endif</code> </pre> <br></li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Share code: Contour class</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> NewEngine.Core.Components; namespace NewEngine.Core.Static { [SelectionBase] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Contour : MonoBehaviour { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> interface SpriteSettings { Color Color { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-type"><span class="hljs-type">int</span></span> SortingLayerId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } string SortingLayerName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-type"><span class="hljs-type">int</span></span> SortingOrder { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } Material Material { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } [<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> SpriteSettingsImpl : SpriteSettings { [SerializeField] Material material; [SerializeField] SortingLayer sortingLayer; [SerializeField] <span class="hljs-type"><span class="hljs-type">int</span></span> sortingOrder; [SerializeField] Color color = Color.white; SpriteRenderer spriteRenderer; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Color Color { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { color = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color; } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> SortingLayerId { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { // TODO       ? <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (var layer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> SortingLayer.layers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (layer.id != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; sortingLayer = layer; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spriteRenderer != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) spriteRenderer.sortingLayerID = sortingLayer.id; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } sortingLayer = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> SortingLayer(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spriteRenderer != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) spriteRenderer.sortingLayerID = sortingLayer.id; } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sortingLayer.id; } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> string SortingLayerName { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { // TODO       ? <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (var layer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> SortingLayer.layers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (layer.name != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; sortingLayer = layer; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spriteRenderer != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) spriteRenderer.sortingLayerID = sortingLayer.id; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } sortingLayer = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> SortingLayer(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spriteRenderer != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) spriteRenderer.sortingLayerID = sortingLayer.id; } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sortingLayer.name; } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> SortingOrder { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { sortingOrder = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spriteRenderer != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) spriteRenderer.sortingOrder = sortingOrder; } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sortingOrder; } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Material Material { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { material = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spriteRenderer != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) spriteRenderer.sharedMaterial = material; } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> material; } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> SpriteRenderer SpriteRenderer { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { spriteRenderer = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spriteRenderer == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; spriteRenderer.color = color; spriteRenderer.sortingOrder = sortingOrder; spriteRenderer.sortingLayerID = sortingLayer.id; spriteRenderer.material = material; } } } [SerializeField] SpriteSettingsImpl fillSettings; [SerializeField] SpriteSettingsImpl contourSettings; [SerializeField] Sprite sprite; [SerializeField] <span class="hljs-type"><span class="hljs-type">bool</span></span> flipX; [SerializeField] <span class="hljs-type"><span class="hljs-type">bool</span></span> flipY; SpriteRenderer fillSprite; SpriteRenderer contourSprite; <span class="hljs-type"><span class="hljs-type">void</span></span> OnValidate() { #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsPrefab) { var renderer = this.GetRequiredComponent&lt;SpriteRenderer&gt;(); renderer.sprite = sprite; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { var renderer = this.GetRequiredComponent&lt;SpriteRenderer&gt;(); UnityEditor.EditorApplication.delayCall+=()=&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (renderer == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; DestroyImmediate(renderer); }; } #endif var tmpFill = FillSprite; var tmpContour = ContourSprite; ApplySettings(fillSprite, fillSettings); ApplySettings(contourSprite, contourSettings); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> SpriteRenderer FillSprite { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsPrefab) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fillSprite == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) fillSprite = <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(fillSettings, "fill"); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fillSprite; } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> SpriteRenderer ContourSprite { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsPrefab) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (contourSprite == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) contourSprite = <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(contourSettings, "contour"); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contourSprite; } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> SpriteSettings FillSettings { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fillSettings; } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> SpriteSettings ContourSettings { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contourSettings; } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span> FlipX { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> flipX; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { flipX = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; FillSprite.flipX = flipX; ContourSprite.flipX = flipX; } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span> FlipY { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> flipY; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { flipY = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; FillSprite.flipY = flipY; ContourSprite.flipY = flipY; } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Sprite Sprite { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sprite; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { sprite = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; FillSprite.sprite = sprite; ContourSprite.sprite = sprite; } } SpriteRenderer <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(SpriteSettingsImpl settings, string spriteName) { var child = <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>.FindChild(spriteName); var obj = child == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> : child.gameObject; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { obj = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> GameObject(); obj.name = spriteName; obj.<span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>.parent = <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>; } var sprite = obj.GetRequiredComponent&lt;SpriteRenderer&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sprite == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { sprite = obj.AddComponent&lt;SpriteRenderer&gt;(); sprite.receiveShadows = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; sprite.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.<span class="hljs-keyword"><span class="hljs-keyword">Off</span></span>; sprite.useLightProbes = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } ApplySettings(sprite, settings); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sprite; } <span class="hljs-type"><span class="hljs-type">void</span></span> ApplySettings(SpriteRenderer spriteRenderer, SpriteSettingsImpl settings) { spriteRenderer.flipX = flipX; spriteRenderer.flipY = flipY; spriteRenderer.sprite = sprite; settings.SpriteRenderer = spriteRenderer; spriteRenderer.<span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>.localPosition = Vector3.zero; spriteRenderer.<span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>.localScale = Vector3.one; spriteRenderer.<span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>.localRotation = Quaternion.<span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>; } <span class="hljs-type"><span class="hljs-type">bool</span></span> IsPrefab { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UnityEditor.PrefabUtility.GetPrefabParent(gameObject) == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; UnityEditor.PrefabUtility.GetPrefabObject(gameObject) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; #endif } } } } #endif</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Shader for fill</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">Shader "NewEngine/Game/Foreground/Contour" { Properties { _MainTex ("MainTex", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} [MaterialToggle] PixelSnap ("Pixel snap", <span class="hljs-type"><span class="hljs-type">Float</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span> } SubShader { Tags { "Queue"="Transparent" "IgnoreProjector"="True" "RenderType"="Transparent" "PreviewType"="Plane" "CanUseSpriteAtlas"="True" } Cull <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> Lighting <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> ZWrite <span class="hljs-keyword"><span class="hljs-keyword">On</span></span> ZTest <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> Fog { Mode <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> } Blend One OneMinusSrcAlpha Pass { //    Stencil { WriteMask <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Ref</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> Pass Replace } CGPROGRAM #pragma vertex vert #pragma fragment frag #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "UnityCG.cginc" struct appdata { <span class="hljs-type"><span class="hljs-type">float4</span></span> vertex : POSITION; float2 uv : TEXCOORD0; <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; }; struct v2f { float2 uv : TEXCOORD0; <span class="hljs-type"><span class="hljs-type">float4</span></span> vertex : SV_POSITION; <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; }; sampler2D _MainTex; v2f vert (appdata v) { v2f o; o.vertex = mul(UNITY_MATRIX_MVP, v.vertex); #ifdef PIXELSNAP_ON v.vertex = UnityPixelSnap (v.vertex); #endif o.uv = v.uv; o.color = v.color; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o; } fixed4 frag (v2f i) : SV_Target0 { fixed4 color = tex2D(_MainTex, i.uv) * i.color; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (color.a == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">discard</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i.color * color.a; } ENDCG } } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Shader for the contour.</b>  <b class="spoiler_title">Magic numbers and strange conditions are attached.</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">Shader "NewEngine/Game/Foreground/Fill" { Properties { _MainTex ("MainTex", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _BackgroundTex ("BackgroundTex", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _MaskColor ("MaskColor", Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) [MaterialToggle] PixelSnap ("Pixel snap", <span class="hljs-type"><span class="hljs-type">Float</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span> } SubShader { Tags { "Queue"="Transparent" "IgnoreProjector"="True" "RenderType"="Transparent" "PreviewType"="Plane" "CanUseSpriteAtlas"="True" } Cull <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> Lighting <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> ZWrite <span class="hljs-keyword"><span class="hljs-keyword">On</span></span> ZTest <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> Fog { Mode <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> } Blend One OneMinusSrcAlpha Pass { Stencil { WriteMask <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Ref</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> Pass Replace } CGPROGRAM #pragma vertex vert #pragma fragment frag #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "UnityCG.cginc" struct appdata { <span class="hljs-type"><span class="hljs-type">float4</span></span> vertex : POSITION; <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; float2 uv : TEXCOORD0; }; struct v2f { <span class="hljs-type"><span class="hljs-type">float4</span></span> uv : TEXCOORD0; <span class="hljs-type"><span class="hljs-type">float4</span></span> vertex : SV_POSITION; <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; }; sampler2D _BackgroundTex; sampler2D _MainTex; <span class="hljs-type"><span class="hljs-type">float4</span></span> _BackgroundTex_ST; <span class="hljs-type"><span class="hljs-type">float4</span></span> _BackgroundTex_TexelSize; fixed4 _MaskColor; v2f vert (appdata v) { v2f o; o.vertex = mul(UNITY_MATRIX_MVP, v.vertex); o.uv.xy = v.uv; o.uv.zw = mul(_Object2World, v.vertex) * fixed4(<span class="hljs-number"><span class="hljs-number">1</span></span> / _BackgroundTex_TexelSize.zw * <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); o.color = v.color; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o; } fixed4 frag (v2f i) : SV_Target { fixed4 backgroundColor = tex2D(_BackgroundTex, i.uv.zw) * i.color; fixed4 mask = tex2D(_MainTex, i.uv.xy); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mask.a == <span class="hljs-number"><span class="hljs-number">0</span></span> || backgroundColor.a == <span class="hljs-number"><span class="hljs-number">0</span></span> || length(mask - _MaskColor) &gt; <span class="hljs-number"><span class="hljs-number">0.00001</span></span> <span class="hljs-comment"><span class="hljs-comment">/* threshold */</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">discard</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> backgroundColor * backgroundColor.a; } ENDCG } } }</code> </pre> </div></div><br><h2 id="poligony">  Polygons </h2><br><p>  However, sometimes you have to make a jumble of sprites: if we want to get a large and complex object, like the surface of the earth with holes and caves.  Instead, we will generate such elements on the fly, in the editor (as in <em>PolygonCollider2D</em> ).  We render polygons through a standard <em>MeshRenderer</em> with two materials (submeshes are used to separate the contour and fill). </p><br><blockquote>  I will not argue that it is easy to write a neat editor for polygons.  But all information is available on the Internet, and AssetStore has ready-made solutions. </blockquote><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JMkJr4uhqew" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>An editor that is indistinguishable from an editor in PolygonCollider2D.</em> </p><br><p>  For maximum flexibility, polygon classes are built like this: </p><br><ul><li>  <strong>Core.Shapes.Shape</strong> is the main class that contains the points of the polygon and the necessary math.  Not <em>MonoBehaviour</em> ; </li><li>  <strong>Core.Shapes.EditableShape</strong> - <strong>MonoBehaviour</strong> 's successor for storing and editing <em>Shape</em> ; </li><li>  <strong>Core.Shapes.ShapeRenderer</strong> ‚Äî Displays a polygon from an <em>EditableShape</em> using a <em>MeshRenderer</em> ; </li><li>  <strong>Core.Shapes.ShapeCollider2D</strong> - creates a physical polygon from <em>EditableShape</em> using <em>PolygonCollider2D</em> . </li></ul><br><div class="spoiler">  <b class="spoiler_title">Another hint</b> <div class="spoiler_text"><p>  For some reason, I missed the <a href="https://docs.unity3d.com/ScriptReference/RequireComponent.html">RequireComponent</a> attribute for a very long time.  This is a very convenient mechanism for automatically adding the necessary components.  For example, <em>ShapeRenderer</em> requires <em>EditableShape</em> and <em>MeshRenderer</em> , when adding it to <em>GameObject</em> all dependencies are automatically created. </p></div></div><br><h2 id="pixel-perfect-i-celochislennaya-geometriya">  Pixel perfect and integer geometry </h2><br><p>  Using large pixels, we kill a whole flock of hares: </p><br><ul><li>  We can render a small image (pixel to pixel) and stretch it under the screen; </li><li>  We can use complex post-effects (small textures will increase productivity); </li><li>  We can work with integer arithmetic (faster and more enjoyable); </li><li>  We can mask flaws or bugs :) </li></ul><br><p>  The truth for these hares will have to pay by implementing the support of "integer geometry", namely: </p><br><ul><li>  Basic things such as: <br><ul><li>  <strong>IntVector2</strong> is essentially a copy of <em>UnityEngine.Vector2</em> , but with integer coordinates.  Sometimes you need to convert data from the usual <em>UnityEngine.Vector2</em> , taking into account the scale or not (32 pixels in one unit, just do not need to use magic numbers!), So we add the following functions: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToPixels</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToUnits</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IntVector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromPixels</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 v</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IntVector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromUnits</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 v</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IntVector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromUnitsRound</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 v</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IntVector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromUnitsCeil</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 v</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> </li><li>  <strong>Intract.</strong>  No different in functionality from <em>UnityEngine.Rect</em> .  The <em>LineCollision</em> method is <em>available</em> to search for intersections with straight line segments ( <a href="https://gist.github.com/ChickenProp/3194723">Liang-Barsky</a> algorithm); </li><li>  <strong>IntLine.</strong>  Line segment with integer beginning and end.  Used in some algorithms; </li><li>  <strong>IntMatrix.</strong>  The matrix for two-dimensional transformations, where the turns are multiples of 90 ¬∞, and the displacement and scale are integer; </li><li>  <strong>Intangle.</strong>  Small class for rounding degrees to 90 ¬∞, the choice of direction.  Can you imagine what a beautiful cosine table is there? </li><li>  <strong>Poser.</strong>  The element positioning the <em>GameObject is</em> multiple to the game "pixel", prohibiting turns, not multiple to the right angle and scaling to a fractional value (taking into account that <em>SpriteRender</em> may be in the element and then you have to take into account the sprite's pivot).  This class works in the editor thanks to the <a href="https://docs.unity3d.com/ScriptReference/ExecuteInEditMode.html">[ExecuteInEditMode]</a> attribute.  Important point: when the state changes (position, rotation, scale, sprite, etc.), <em>Poser</em> notifies the <em>PoserListener</em> class about this, which is able to track changes in the editor of all <em>Poser</em> elements with a specific tag.  This will be needed in the future; </li><li>  <strong>CameraManager.</strong>  A camera controller that can align the current camera and position cameras for post-effects. </li></ul></li></ul><br><div class="spoiler">  <b class="spoiler_title">As usual, a few different things.</b> <div class="spoiler_text"><ol><li>  Add gizmo drawing for geometry.  For example, the <em>OnDrawGizmos</em> method has been added to <em>IntVector2</em> , <em>IntRect</em> and <em>IntLine</em> .  This is very useful when debugging. </li><li>  To align the cameras is terrible.  I positioned them on the lower left corner, while the coordinates of the camera are the coordinates of its center.  And when changing the renderTarget of the camera, the angles obviously leave as the screen size changes in pixels.  So what matters is not only <em>how to</em> align the cameras, but also <em>when</em> . </li></ol></div></div><br><h2 id="staraya-struktura-proekta">  Old project structure </h2><br><p>  Remember, in the last article there was a section about shadow building?  And most of it was devoted to the union of sprites in some groups to optimize the final mesh?  So, forget, it's all not true.  :) </p><br><p>  Initially, all modules were written independently, in the prototyping mode.  And for everyone the algorithms, structures and data types were thought out.  As a result, two major problems arose (besides <del>  legacy code </del>  we will be honest): </p><br><ol><li>  Duplication code.  Only classes for integer coordinates were 3‚Äì4 pieces and all were nested in other classes (normal point, point with normal, point with some kind of meta-information). </li><li>  Not optimal solutions.  Each module needed the same data on the sprites, but a little bit differently processed.  And this data was copied back and forth with all sorts of transformations, which did not add either speed or code grace. </li></ol><br><p>  These modules require some information about the "solid" sprites of the locks: </p><br><ul><li>  Shadows; </li><li>  Wind; </li><li>  Ambient lighting; </li><li>  Grass; </li><li>  Particles; </li><li>  Physics; </li><li>  Water; </li><li>  Others (strands of cobwebs and lighting chains) </li></ul><br><div class="spoiler">  <b class="spoiler_title">And the structures were used such.</b> <div class="spoiler_text"><ul><li>  <strong>UnityEngine.Sprite.</strong>  Graphic sprites.  Base for everything else; </li><li>  <strong>Contour</strong>  The contour of the object (or group of objects).  It is an array of vertical and horizontal lines with normals; <br><ul><li>  <em>UnityEngine.Sprite [] ‚Üí Contour</em> : convert each sprite into contours, for a list of external parties. </li></ul></li><li>  <strong>Rects</strong>  A set of rectangles; <br><ul><li>  <em>UnityEngine.Sprite [] ‚Üí Rects</em> : fill the sprite with rectangles so that you can use them to combine all the objects into one. </li></ul></li><li>  <strong>Shape.</strong>  A class containing Contour and Rects; </li><li>  <strong>Shapes.</strong>  Set Shape and aabb for quick search; </li><li>  <strong>Batch.</strong>  Shape set and access functions to shared Contour; <br><ul><li>  To build meshes; </li><li>  To test points for hardness; </li><li>  For reykast. </li></ul></li><li>  <strong>Windgrid</strong>  The collision cache for the wind from <em>Batch ‚Üí Shapes</em> ; </li><li>  <strong>QuadTree.</strong>  Basic (and cross-sectional) implementation of a quadrant tree for a quick search for empty volumes; </li><li>  <strong>WaterVolumes.</strong>  Rectangles of water from <em>Batch ‚Üí Contour</em> . </li></ul><br><p>  All this madness is used like this: </p><br><ul><li>  <strong>Shadows.</strong>  <em>Batch ‚Üí General Contour:</em> for building a shadow mesh; </li><li>  <strong>Wind.</strong>  <em>WindGrid ‚Üí Batch ‚Üí Shapes:</em> for calculating wind (collision search); </li><li>  <strong>Scattered lighting.</strong> <br><ul><li>  <em>Batch ‚Üí Shapes:</em> </li><li>  For raycast (search for direct illumination); </li><li>  For testPoint (search for solid objects). </li><li>  <em>QuadTree ‚Üí Batch ‚Üí Shapes</em> : </li><li>  To search for empty volumes. </li></ul></li><li>  <strong>Grass.</strong> <br><ul><li>  <em>Batch ‚Üí Shapes:</em> <em>CircleQuery</em> method for finding nearby surfaces; </li><li>  <em>Batch ‚Üí General Contour:</em> for planting grass; </li></ul></li><li>  <strong>Particles</strong>  <em>Batch ‚Üí Shapes:</em> <em>PopPoint</em> method (finding the nearest open space) to push particles out of walls; </li><li>  <strong>Physics.</strong>  <em>Batch ‚Üí General Contour:</em> for building colliders; </li><li>  <strong>Water.</strong>  <em>WaterVolumes ‚Üí Batch ‚Üí General Circuit:</em> Search for places where water can be created; </li><li>  <strong>Other</strong>  <em>Batch ‚Üí Shapes:</em> raycast to search for fixing points for lamps and cobwebs. </li></ul></div></div><br><h2 id="region-tree">  Region tree </h2><br><p>  After some analysis and long googling, we find a solution - Region tree, sometimes called the Volume tree. </p><br><p>  We divide the two-dimensional space into 4 parts until each sheet is either completely empty or completely filled.  We expose the sheet bits of fullness (or in any other way distinguish empty nodes from filled). </p><br><p>  The possibilities that this tree provides cover all our needs: </p><br><ul><li>  <em>Building a tree.</em>  You can fill a tree, indicating solid points, rectangles, or even other trees with a certain offset.  Therefore, sprites pre-calculated their own Region Tree, and then, when added to the scene, a common tree is built. </li><li>  <em>Check point hardness.</em>  Recursively descend through the tree while the node has descendants (in my version of the tree the node is empty if Node = null, full - if Node.children == null, otherwise Node.children - an array of descendants); </li><li>  <em>Raycast</em> .  Recursively check the intersection of the beam with the squares of the nodes. </li><li>  <em>Search the shortest path to empty space</em> .  We find a leaf at a given point, we go up the tree, checking the neighbors' nodes (if the node is empty, we immediately count the distance to it, if there are descendants, we go down recursively and again look for the nearest empty one). </li><li>  <em>Search for segments lying on the border</em> .  It is more difficult here, if briefly - we get all the filled squares from the tree, remove the sides belonging to several squares, optimize the result. </li></ul><br><p>  Visually, it looks like this (hooray, pictures!): </p><br><img src="https://habrastorage.org/files/06f/048/b2e/06f048b2e4d543828327b5e424982807.png"><br><p>  <em>The visual part.</em>  <em>The walls of the sprites, the ground - the polygons.</em> </p><br><img src="https://habrastorage.org/files/255/11c/3e4/25511c3e4391406499b4b86d3fa0c093.png"><br><p>  <em>Estimated region tree.</em> </p><br><img src="https://habrastorage.org/files/3e3/5e4/f95/3e35e4f9548640f99b6e7423b588e67a.png"><br><p>  <em>Pre-calculated surfaces.</em> </p><br><h2 id="menedzhery">  Managers </h2><br><p>  As it turned out, this quadrant tree realizes almost all the features that modules need.  Now you need to connect these modules with each other. </p><br><div class="spoiler">  <b class="spoiler_title">Minute pain</b> <div class="spoiler_text"><p>  In the "prototype" version, all controllers / managers themselves implemented the corresponding functionality (calculation of lighting, processing of particle physics, etc.) and inherited from <em>MonoBehaviour</em> .  There were several problems: complex and overgrown code, the strong dependence of managers on each other, the absence of some kind of general data flow between controllers. </p><br><p>  For example, when I moved an element in the editor, managers did not automatically pick up these changes.  It was necessary to first poke a check in the tree manager, then in the light manager, then in the water manager, etc.  And all in order to see if the new castle looks good.  So so, right? </p></div></div><br><p>  First, get rid of <em>MonoBehaviour</em> to the maximum.  All objects whenever possible are represented with the usual # classes. </p><br><p>  Secondly, we will spread the code across different namespaces, one name - one functional. <br>  And, thirdly, for each functional, we implement one <em>MonoBehaviour</em> manager who will store the necessary settings, manage the generation of content, etc. </p><br><img src="https://habrastorage.org/files/556/37c/20d/55637c20d44c4a708d9771a1b7199f8f.png"><br><p>  <em>Managers.</em>  <em>Combed and in ties.</em> </p><br><p>  So, there are controllers on the scene, each has one sphere of influence, the code is neatly packed into the <em>NewEngine.Core</em> namespace ( <em>Core.Geom</em> , <em>Core.Illumination</em> , <em>Core.Rendering</em> , etc.).  Move the sprite in the editor and ... no reaction.  Remember, the <em>PoserListener</em> class was described <em>above</em> ?  He is able to listen to changes in position, sprite, size in objects like <em>Poser</em> .  All managers that depend on the relevant <em>GameObjects are</em> inherited from this class. </p><br><p>  Now, when we move a piece of the wall (with the " <em>foreground</em> " tag), <em>Core.Quad.QuadManager is</em> notified, and when we change the reference points for water (the " <em>waterLayer</em> " tag) <em>Core.Water.WaterManager will</em> immediately know about the changes. </p><br><p>  It remains to link the controllers to each other, because the above-described <em>WaterManager</em> needs to know when the quad tree will be rebuilt in <em>QuadManager</em> , and it is important for ShadowMeshManager to pick up changes in SurfaceManager.  To do this, we use a very convenient <a href="https://docs.unity3d.com/ScriptReference/Events.UnityEvent.html">UnityEvent</a> .  Its only drawback is by default, if we create a generic event with some of its arguments, Unity3D does not display it in the editor.  This is corrected elementarily: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TreeManager</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ [<span class="hljs-type"><span class="hljs-type">System</span></span>.<span class="hljs-type"><span class="hljs-type">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UpdateTreeEvent</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnityEvent</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TreeManager</span></span></span><span class="hljs-class">&gt; </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-type"><span class="hljs-type">UpdateTreeEvent</span></span> onUpdateTree; ... }</code> </pre> <br><p>  And now we can connect managers directly in the editor, without contaminating the code with strange dependencies: </p><br><img src="https://habrastorage.org/files/f41/7d0/954/f417d0954d324ab8a04be1c685ec3e34.png"><br><p>  <em>If necessary, dependencies are executed in the editor.</em> </p><br><h2 id="posteffekty">  Post effects </h2><br><p>  So, at the start, all modules generate the necessary content, update it, but are not able to render.  Time to fix it! </p><br><p>  In fact, the rendering in this project is very different from what is shown on youtube in the commercials with the saying names "Let's beat down my mega-cool game on Unity3D from three boxes, one sprite and RigidBody2D component".  In fact, you just need to draw the sprites of the walls and the background themselves.  But the light, water, etc. will have to do through post-effects. </p><br><p>  What does this mean?  With the rendering of elements, we will be doing not on the screen, but in buffers, then using different shaders to reduce these all one picture.  And that's all. </p><br><p>  There are a lot of effects.  At the moment it is: </p><br><ul><li>  <em>Rendering the scene.</em>  Not really a post effect, just drawing the main geometry of the scene. </li><li>  <em>Global coverage.</em>  It is calculated once, at the start of the level; </li><li>  <em>Normal lighting.</em>  Includes light sources, shadows, caustics in water; </li><li>  <em>Light decals.</em>  Small sprites that create a luminescence effect. </li><li>  <em>Post Effect Information.</em>  Combines the results of all previous post-effects into one picture (for example, it applies lighting effects to the rendered scene). </li><li>  And finally <em>rendering to the screen.</em>  Which simply displays the resulting texture, taking into account the pixel perfect and the difference in screen size and texture. </li></ul><br><p>  In general, the post-effect is a kind of script that can generate some kind of texture / textures and, possibly, additional data (for example, shader parameters).  Sometimes the posteffect works only with modules, sometimes it has to trigger the rendering of a scene with certain camera settings. </p><br><p>  The important point: post effects may depend on each other.  Therefore, firstly, it is important to cause effects in the correct order, and secondly, you need to be able to store and transmit to the effects disparate data about each other. </p><br><p>  Make the base class for the effect.  Something like this: </p><br><pre> <code class="hljs pgsql">namespace NewEngine.Core.Render { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> abstract <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PostEffect { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> OrderId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } //    . <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> abstract <span class="hljs-type"><span class="hljs-type">void</span></span> Apply(PipelineContext context); //  .        PipelineContext,    . <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> abstract <span class="hljs-type"><span class="hljs-type">void</span></span> Clear(); //   .  ,   GC,   . protected Camera CreateCamera(); //     . ,    . <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> List&lt;Camera&gt; Cameras { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } } }</code> </pre> <br><p>  And we also make a context class for binding data from post-effects. </p><br><pre> <code class="hljs pgsql">namespace NewEngine.Core.Render { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PipelineContext { <span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>, PostEffectContext&gt;; Camera camera; Geom.IntRect viewRect; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> PipelineContext(CameraManager cameraManager); <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;Context&gt;(Context <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> Context : PostEffectContext; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Context <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>&lt;Context&gt;() <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> Context : PostEffectContext; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Camera Camera { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Geom.IntRect ViewRect { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } } }</code> </pre> <br><p>  In fact, now in the rendering manager we need to go through the correct order for all the active effects, calling them <em>Apply</em> and collecting data in the <em>PipelineContext</em> .  As a result, we will draw a beautiful frame.  The effects get into the manager through the analogue <em>Poser</em> , which informs the listener about adding / removing effects from the scene.  It remains only to sort them correctly. </p><br><p>       ,           , - : </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">RequiredPostEffect(typeof(WaterPostEffect))</span></span>] [RequiredPostEffect(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IlluminationPostEffect))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MergerPostEffect</span></span> : <span class="hljs-title"><span class="hljs-title">PostEffect</span></span> { }</code> </pre> <br><blockquote> ,   ,          PropertyDrawer: </blockquote><br><iframe width="560" height="315" src="https://www.youtube.com/embed/t0xkDP0NvFg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> <em>      .         .</em> </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><ul><li> <strong>.</strong>   ,    ‚Äî  .        ; </li><li> <strong> .</strong>   - .  Unity3D    ‚Äî  <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnPostRender.html">OnPostRender</a> ; </li><li> <strong>GetTemporary.</strong>  ,  <em>RenderTexture</em>        ‚Äî  . ,   .      <a href="https://docs.unity3d.com/ScriptReference/RenderTexture.GetTemporary.html">RenderTexture.GetTemporary</a> ,      <a href="https://docs.unity3d.com/ScriptReference/RenderTexture.ReleaseTemporary.html">RenderTexture.ReleaseTemporary</a> , fps   (   ). Unity3D          .  ,          ‚Äî  . </li><li> <strong> .</strong> E         ‚Äî  ,  Unity3D   (,   : Unity3D    ).            "Show texture leaks",             ,     (  <em>System.Diagnostics.StackTrace()</em> ).       <em>#ifdef</em>     . </li><li> <strong>  .</strong>       <em>TextureFormat</em>    , <em>RenderTextureFormat</em> .  <a href="https://docs.unity3d.com/ScriptReference/SystemInfo.SupportsTextureFormat.html">SystemInfo.SupportsTextureFormat</a>  <a href="https://docs.unity3d.com/ScriptReference/SystemInfo-supportsRenderTextures.html">SystemInfo.supportsRenderTextures</a>   (     )     . </li><li> <strong>Blit.</strong>             .      <em>Camera</em> (   ).  Unity3D    <a href="https://docs.unity3d.com/ScriptReference/Graphics.Blit.html">Graphics.Blit</a> . </li><li> <strong>  Blit.</strong>  _Graphics.Blit_ ,        ,  depth buffer  stencil buffer   .        . </li></ul><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Blit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RenderBuffer colorBuffer, RenderBuffer depthBuffer, Material material</span></span></span><span class="hljs-function">)</span></span> { Blit(colorBuffer, depthBuffer, material, material.passCount); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Blit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RenderBuffer colorBuffer, RenderBuffer depthBuffer, Material material, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> passCount</span></span></span><span class="hljs-function">)</span></span> { Graphics.SetRenderTarget(colorBuffer, depthBuffer); GL.PushMatrix(); GL.LoadOrtho(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; passCount; ++i) { material.SetPass(i); GL.Begin(GL.QUADS); GL.TexCoord(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.TexCoord(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.TexCoord(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.TexCoord(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); GL.Vertex3(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GL.End(); } GL.PopMatrix(); Graphics.SetRenderTarget(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); }</code> </pre> </div></div><br><h4 id="mysli-o-buduschem">    </h4><br><p>       ,   ,     ,  ‚Äî  . ,    .   ,       ! ,       .      : </p><br><blockquote> ‚Ä¶      .     ,   .       ‚Äî          . </blockquote><br><blockquote> ‚Ä¶       ,    ,      . ¬´        ¬ª ‚Äî  . </blockquote><p>          ,  ,  ,    .    . </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XPdhSoub0wU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> <em>        :)</em> </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><img src="https://habrastorage.org/files/d9a/432/9b8/d9a4329b82af44cbb1ec43a41d745a0b.png"><br><p> <em>   .</em> </p><br><img src="https://habrastorage.org/files/fa6/1f0/754/fa61f0754e2548f19f14f3cd49fcc234.png"><br><p> <em>     ,  Unity3D  ? 0</em> </p><br><img src="https://habrastorage.org/files/c4a/cd2/391/c4acd2391a514e73980e0a346b52c7c4.png"><br><p> <em>,      .</em> </p><br><img src="https://habrastorage.org/files/a67/63a/828/a6763a8281ce43ed9c6408aae9e0a2c5.png"><br><p> <em>   ,     .</em> </p></div></div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/312046/">https://habr.com/ru/post/312046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../312036/index.html">Protection from sharks, ultralight drones and teleportation of photons: The present and the future of information ‚Äúdelivery‚Äù technologies</a></li>
<li><a href="../312038/index.html">Little about optimizing data transfer latency</a></li>
<li><a href="../312040/index.html">IaaS and GaaS: The Cloudy Future of Video Games</a></li>
<li><a href="../312042/index.html">‚ÄúWhat is the benefit?‚Äù: Feasibility study of using IaaS</a></li>
<li><a href="../312044/index.html">IaaS Digest: Introducing Virtual Infrastructure</a></li>
<li><a href="../312048/index.html">Possible innovations of C #</a></li>
<li><a href="../312052/index.html">Pro security in phpBB</a></li>
<li><a href="../312054/index.html">Immersion in the blockchain technology: Combating counterfeit goods</a></li>
<li><a href="../312056/index.html">Finding Java bytecode vulnerabilities: what to do with the results?</a></li>
<li><a href="../312058/index.html">How we helped conduct a medical census in the Republic of Bangladesh</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>