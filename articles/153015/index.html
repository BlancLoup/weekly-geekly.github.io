<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ARM NEON skinning</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is it? 
 What is ARM NEON? - ARM¬Æ NEON ‚Ñ¢ is a SIMD engine ... - in other words, it is an extended set of instructions like x86 CPU SSE / SSE2 but...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ARM NEON skinning</h1><div class="post__text post__text-html js-mediator-article"><h4>  What is it? </h4><br>  What is ARM NEON?  - <a href="http://www.arm.com/products/processors/technologies/neon.php">ARM¬Æ NEON ‚Ñ¢ is a SIMD engine</a> ... - in other words, it is an extended set of instructions like x86 CPU SSE / SSE2 but for processors with an ARM architecture. <br><br><h4>  What for? </h4><br>  Everything was fine until I added support for the FSAA.  After that, the FPS sank lower than 15. <br>  After optimization, I again had about 25 FPS.  But in memory, one function sat down that consumed 10% of the time per frame in which I did not already know what could be optimized. <br><br>  Thanks to one friend of mine, who from time to time asked a question like ‚ÄúWould you like to use NEON in your engine‚Äù, I decided (with his support) to rewrite this function on NEON. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Original C code for skinning ( <a href="http://en.wikipedia.org/wiki/Skeletal_animation">Matrix palette skinnig</a> ). </h4><br><a name="habracut"></a><br><h5>  Structures: </h5><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ready to use with glSubData for vertex buffer struct PN { Math::Vec3f p; Math::Vec3f n; };</span></span></code> </pre> <br><br><h5>  Transformation of one weight: </h5><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transformPointNormal4x3Weight_NoW</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Matrix44f&amp; mat,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f&amp; inV, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f&amp; inN, BaseRenderScene::PN&amp; outPN)</span></span></span><span class="hljs-function"> </span></span>{ outPN.p.vec[<span class="hljs-number"><span class="hljs-number">0</span></span>] = (inV.vec[<span class="hljs-number"><span class="hljs-number">0</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + inV.vec[<span class="hljs-number"><span class="hljs-number">1</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + inV.vec[<span class="hljs-number"><span class="hljs-number">2</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + mat.mat[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]); outPN.n.vec[<span class="hljs-number"><span class="hljs-number">0</span></span>] = (inN.vec[<span class="hljs-number"><span class="hljs-number">0</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + inN.vec[<span class="hljs-number"><span class="hljs-number">1</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + inN.vec[<span class="hljs-number"><span class="hljs-number">2</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]); outPN.p.vec[<span class="hljs-number"><span class="hljs-number">1</span></span>] = (inV.vec[<span class="hljs-number"><span class="hljs-number">0</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + inV.vec[<span class="hljs-number"><span class="hljs-number">1</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + inV.vec[<span class="hljs-number"><span class="hljs-number">2</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + mat.mat[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>]); outPN.n.vec[<span class="hljs-number"><span class="hljs-number">1</span></span>] = (inN.vec[<span class="hljs-number"><span class="hljs-number">0</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + inN.vec[<span class="hljs-number"><span class="hljs-number">1</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + inN.vec[<span class="hljs-number"><span class="hljs-number">2</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>]); outPN.p.vec[<span class="hljs-number"><span class="hljs-number">2</span></span>] = (inV.vec[<span class="hljs-number"><span class="hljs-number">0</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + inV.vec[<span class="hljs-number"><span class="hljs-number">1</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + inV.vec[<span class="hljs-number"><span class="hljs-number">2</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + mat.mat[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>]); outPN.n.vec[<span class="hljs-number"><span class="hljs-number">2</span></span>] = (inN.vec[<span class="hljs-number"><span class="hljs-number">0</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + inN.vec[<span class="hljs-number"><span class="hljs-number">1</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + inN.vec[<span class="hljs-number"><span class="hljs-number">2</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>]); } <span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transformPointNormal4x3Weight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Matrix44f&amp; mat,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f&amp; inV, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f&amp; inN, BaseRenderScene::PN&amp; outPN,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> w )</span></span></span><span class="hljs-function"> </span></span>{ outPN.p.vec[<span class="hljs-number"><span class="hljs-number">0</span></span>] = (inV.vec[<span class="hljs-number"><span class="hljs-number">0</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + inV.vec[<span class="hljs-number"><span class="hljs-number">1</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + inV.vec[<span class="hljs-number"><span class="hljs-number">2</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + mat.mat[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>])*w; outPN.n.vec[<span class="hljs-number"><span class="hljs-number">0</span></span>] = (inN.vec[<span class="hljs-number"><span class="hljs-number">0</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + inN.vec[<span class="hljs-number"><span class="hljs-number">1</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + inN.vec[<span class="hljs-number"><span class="hljs-number">2</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>])*w; outPN.p.vec[<span class="hljs-number"><span class="hljs-number">1</span></span>] = (inV.vec[<span class="hljs-number"><span class="hljs-number">0</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + inV.vec[<span class="hljs-number"><span class="hljs-number">1</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + inV.vec[<span class="hljs-number"><span class="hljs-number">2</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + mat.mat[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>])*w; outPN.n.vec[<span class="hljs-number"><span class="hljs-number">1</span></span>] = (inN.vec[<span class="hljs-number"><span class="hljs-number">0</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + inN.vec[<span class="hljs-number"><span class="hljs-number">1</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + inN.vec[<span class="hljs-number"><span class="hljs-number">2</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>])*w; outPN.p.vec[<span class="hljs-number"><span class="hljs-number">2</span></span>] = (inV.vec[<span class="hljs-number"><span class="hljs-number">0</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + inV.vec[<span class="hljs-number"><span class="hljs-number">1</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + inV.vec[<span class="hljs-number"><span class="hljs-number">2</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + mat.mat[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>])*w; outPN.n.vec[<span class="hljs-number"><span class="hljs-number">2</span></span>] = (inN.vec[<span class="hljs-number"><span class="hljs-number">0</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + inN.vec[<span class="hljs-number"><span class="hljs-number">1</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + inN.vec[<span class="hljs-number"><span class="hljs-number">2</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>])*w; } <span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transformPointNormal4x3AddWeighted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Matrix44f&amp; mat,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f&amp; inV, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f&amp; inN, BaseRenderScene::PN&amp; outPN,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> w )</span></span></span><span class="hljs-function"> </span></span>{ outPN.p.vec[<span class="hljs-number"><span class="hljs-number">0</span></span>] += (inV.vec[<span class="hljs-number"><span class="hljs-number">0</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + inV.vec[<span class="hljs-number"><span class="hljs-number">1</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + inV.vec[<span class="hljs-number"><span class="hljs-number">2</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + mat.mat[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>])*w; outPN.n.vec[<span class="hljs-number"><span class="hljs-number">0</span></span>] += (inN.vec[<span class="hljs-number"><span class="hljs-number">0</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + inN.vec[<span class="hljs-number"><span class="hljs-number">1</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + inN.vec[<span class="hljs-number"><span class="hljs-number">2</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>])*w; outPN.p.vec[<span class="hljs-number"><span class="hljs-number">1</span></span>] += (inV.vec[<span class="hljs-number"><span class="hljs-number">0</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + inV.vec[<span class="hljs-number"><span class="hljs-number">1</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + inV.vec[<span class="hljs-number"><span class="hljs-number">2</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + mat.mat[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>])*w; outPN.n.vec[<span class="hljs-number"><span class="hljs-number">1</span></span>] += (inN.vec[<span class="hljs-number"><span class="hljs-number">0</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + inN.vec[<span class="hljs-number"><span class="hljs-number">1</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + inN.vec[<span class="hljs-number"><span class="hljs-number">2</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>])*w; outPN.p.vec[<span class="hljs-number"><span class="hljs-number">2</span></span>] += (inV.vec[<span class="hljs-number"><span class="hljs-number">0</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + inV.vec[<span class="hljs-number"><span class="hljs-number">1</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + inV.vec[<span class="hljs-number"><span class="hljs-number">2</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + mat.mat[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>])*w; outPN.n.vec[<span class="hljs-number"><span class="hljs-number">2</span></span>] += (inN.vec[<span class="hljs-number"><span class="hljs-number">0</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + inN.vec[<span class="hljs-number"><span class="hljs-number">1</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + inN.vec[<span class="hljs-number"><span class="hljs-number">2</span></span>]*mat.mat[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>])*w; }</code> </pre><br><br><h5>  Transformation of one vertex: </h5><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f&amp; vx = pVerticies[v]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f&amp; vxN = pNormals[v]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> w = pVertexWeight[v].vec[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> boneIndex = pVertexBones[v].vec[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Matrix44f&amp; boneTM = pBoneTMList[boneIndex]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( wCount==<span class="hljs-number"><span class="hljs-number">1</span></span> ) { transformPointNormal4x3Weight_NoW(boneTM,vx,vxN,skinTempPN[v]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1st vertex without add transformPointNormal4x3Weight_N(boneTM,vx,vxN,skinTempPN[v],w); for(size_t i=1;i&lt;wCount;i++) { // other verticies w = pVertexWeight[v].vec[i]; boneIndex = pVertexBones[v].vec[i]; const Matrix44f&amp; boneTM = pBoneTMList[boneIndex]; transformPointNormal4x3AddWeighted_N(boneTM,vx,vxN,skinTempPN[v],w); } }</span></span></code> </pre><br>  A knowledgeable person will immediately notice that I store the number of non-zero weights for each vertex.  In my case, about 30% of the peaks were with the same weight, which allowed us to win a little time. <br><br><h4>  ASM with NEON (xCode style) </h4><br>  The code below is asm / C code optimized using ARM NEON. <br>  Some nuances: <br><ul><li>  For ARM NEON, all incoming data must be 16 bytes aligned.  Because of this requirement, I extended all my incoming positions and normals to Vec4f. <br></li><li>  Outgoing data can still be aligned by 4 bytes.  This allowed me to upload the result directly to the vertex buffer without unnecessary gestures.  For the version with aligned data of 16 bytes, we would have to drop the data with an extra 4 + 4 bytes and drive them to the vertex buffer (and this happens every frame). <br><br></li></ul><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(__ARM_NEON__) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USE_NEON #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(USE_NEON) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __thumb__ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"This file should be compiled in ARM mode only."</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Note in Xcode, right click file, Get Info-&gt;Build, Other compiler flags = "-marm" #endif #define OP "q0" #define OPS0 "s0" #define OPS1 "s1" #define OPS2 "s2" #define ON "q1" #define ONS0 "s4" #define ONS1 "s5" #define ONS2 "s6" #define IP "q2" #define IN "q3" #define IPX "d4[0]" #define IPY "d4[1]" #define IPZ "d5[0]" #define IPW "d5[1]" #define INX "d6[0]" #define INY "d6[1]" #define INZ "d7[0]" #define INW "d7[1]" #define WQ "q4" #define W0D "d8[0]" #define W1D "d8[1]" #define W2D "d9[0]" #define W3D "d9[1]" #define QM0 q8 #define QM1 q9 #define QM2 q10 #define QM3 q11 #define QT "q14" // outP = mt.row0*pos + mt.row1*pos + mt.row2*pos + mt.row3*pos #define mat_pos(_RES) \ "vmul.f32 " _RES ", q8, " IPX "\n\t" \ "vmla.f32 " _RES ", q9, " IPY "\n\t" \ "vmla.f32 " _RES ", q10, " IPZ "\n\t" \ "vmla.f32 " _RES ", q11, " IPW "\n\t" #define mat_pos_w_set(_RES,_QT,_WD) \ mat_pos(_QT) \ "vmul.f32 " _RES ", " _QT ", " _WD "\n\t" #define mat_pos_w_add(_RES,_QT,_WD) \ mat_pos(_QT) \ "vmla.f32 " _RES ", " _QT ", " _WD "\n\t" // outN = mt.row0*nor + mt.row1*nor + mt.row2*nor #define mat_nor(_RES) \ "vmul.f32 " _RES ", q8, " INX "\n\t" \ "vmla.f32 " _RES ", q9, " INY "\n\t" \ "vmla.f32 " _RES ", q10, " INZ "\n\t" #define mat_nor_w_set(_RES,_QT,_WD) \ mat_nor(_QT) \ "vmul.f32 " _RES ", " _QT ", " _WD "\n\t" #define mat_nor_w_add(_RES,_QT,_WD) \ mat_nor(_QT) \ "vmla.f32 " _RES ", " _QT ", " _WD "\n\t" #define STORE3_P3N3(_R) \ "fsts "OPS0",[" _R "] \n\t" \ "fsts "OPS1",[" _R ",#4] \n\t" \ "fsts "OPS2",[" _R ",#8] \n\t" \ "fsts "ONS0",[" _R ",#12] \n\t" \ "fsts "ONS1",[" _R ",#16] \n\t" \ "fsts "ONS2",[" _R ",#20] \n\t" #define mat_load(_R) \ "vldmia " _R ", { q8-q11 } \n\t" __attribute__((always_inline)) void clalcSkin1( const Matrix44f* mat0, const Vec4f* posnorm, Vec3f* outPN) { // asm volatile ( // q4-q7 need to be preserved "vldmia %1, { " IP " - " IN " } \n\t" // pos norm // OP p temp // ON n temp // // mat0 mat_load("%0") mat_pos(OP) mat_nor(ON) STORE3_P3N3("%2") : // no output : "r" (mat0), "r" (posnorm), "r" (outPN) : "memory", IP, IN, WQ, QT, OP, ON, "q8", "q9", "q10", "q11" //clobber ); } __attribute__((always_inline)) void clalcSkin2( const Matrix44f* mat0, const Matrix44f* mat1, const Vec4f* posnorm, const Vec4f* weight, Vec3f* outPN) { // asm volatile ( // q4-q7 need to be preserved "vmov q15," WQ "\n\t" // "vldmia %2, { " IP " - " IN " } \n\t" // pos norm "vldmia %3, { " WQ " } \n\t" // weights // QT intermediate temp // OP p temp // ON n temp // // mat0 mat_load("%0") mat_pos_w_set(OP,QT,W0D) mat_nor_w_set(ON,QT,W0D) // mat 1 mat_load("%1") mat_pos_w_add(OP,QT,W1D) mat_nor_w_add(ON,QT,W1D) // output pos3f,norm3f STORE3_P3N3("%4") // restore q4 (WQ) "vmov " WQ ", q15 \n\t" : // no output : "r" (mat0), "r" (mat1), "r" (posnorm), "r" (weight), "r" (outPN) : "memory", IP, IN, WQ, QT , OP, ON, "q8", "q9", "q10", "q11", "q15" //clobber ); } __attribute__((always_inline)) void clalcSkin3( const Matrix44f* mat0, const Matrix44f* mat1, const Matrix44f* mat2, const Vec4f* posnorm, const Vec4f* weight, Vec3f* outPN) { // asm volatile ( // q4-q7 need to be preserved "vmov q15," WQ "\n\t" // "vldmia %3, { " IP " - " IN " } \n\t" // pos norm "vldmia %4, { " WQ " } \n\t" // weights // QT intermediate temp // OP p temp // ON n temp // // mat0 mat_load("%0") mat_pos_w_set(OP,QT,W0D) mat_nor_w_set(ON,QT,W0D) // mat 1 mat_load("%1") mat_pos_w_add(OP,QT,W1D) mat_nor_w_add(ON,QT,W1D) // mat 2 mat_load("%2") mat_pos_w_add(OP,QT,W2D) mat_nor_w_add(ON,QT,W2D) // output pos,normal STORE3_P3N3("%5") // restore q4 (WQ) "vmov " WQ ", q15 \n\t" : // no output : "r" (mat0), "r" (mat1), "r" (mat2),"r" (posnorm), "r" (weight), "r" (outPN) : "memory", IP, IN, WQ, QT, OP, ON, "q8", "q9", "q10", "q11", "q15" //clobber ); } __attribute__((always_inline)) void clalcSkin4( const Matrix44f* mat0, const Matrix44f* mat1, const Matrix44f* mat2, const Matrix44f* mat3, const Vec4f* posnorm, const Vec4f* weight, Vec3f* outPN) { // asm volatile ( // q4-q7 need to be preserved "vmov q15," WQ "\n\t" // "vldmia %4, { " IP " - " IN " } \n\t" // pos norm "vldmia %5, { " WQ " } \n\t" // weights // QT intermediate temp // OP p temp // ON n temp // // mat0 mat_load("%0") mat_pos_w_set(OP,QT,W0D) mat_nor_w_set(ON,QT,W0D) // mat 1 mat_load("%1") mat_pos_w_add(OP,QT,W1D) mat_nor_w_add(ON,QT,W1D) // mat 2 mat_load("%2") mat_pos_w_add(OP,QT,W2D) mat_nor_w_add(ON,QT,W2D) // mat 3 mat_load("%3") mat_pos_w_add(OP,QT,W3D) mat_nor_w_add(ON,QT,W3D) // output pos,normal STORE3_P3N3("%6") // restore q4 (WQ) "vmov " WQ ", q15\n\t" : // no output : "r" (mat0), "r" (mat1), "r" (mat2), "r" (mat3), "r" (posnorm), "r" (weight), "r" (outPN) : "memory", IP, IN, WQ, QT, OP, ON, "q8", "q9", "q10", "q11", "q15" //clobber ); }</span></span></span></span></code> </pre><br><br><h4>  results </h4><br>  I did not do any synthetic tests - I checked everything on the working draft. <br><br>  502ms (c ++) versus 307ms (arm neon) at ~ 10 second interval for iPhone 4 (39% faster than C). <br><br><h4>  Questions and Answers </h4><br>  Try to answer a few questions at once? <br><br>  Q: Why isn't it described how ARM NEON works and what is it? <br>  A: There is no sense to retell specs. <br><br>  Q: Why not use a shader? <br>  A: OpenGL 1.1 <br><br>  Q: Why not use OpenGL 2.0+? <br>  A: Only after porting to Windows Phone 8 (there is no FF there and at that very moment I will add ‚Äúshader‚Äù to the engine and then already on GL 2.0). <br><br>  Q: Why not use GL_OES_matrix_palette for FF? <br>  A: It is necessary to beat the model into groups of 11 (for iphone) matrices and there is no time for this - perhaps in the future. <br><br>  Q: And where can I find out more and preferably with examples? <br>  A: I advise you to look here <a href="http://code.google.com/p/math-neon/">.</a>  Watch out there LGPL. <br><br>  Q: And how much did it take? <br>  A: A week is exactly the reason for writing the article (if someone saves time, I will be happy). <br><br>  Q: I did not understand anything, but can I read more? <br>  A: You can (depending on the comments), but I tried to write very clear code. <br><br>  Ps.  Errors in lichku. </div><p>Source: <a href="https://habr.com/ru/post/153015/">https://habr.com/ru/post/153015/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../153005/index.html">Evernote data protection: how we get rid of broken disks</a></li>
<li><a href="../153007/index.html">‚ÄúRunet today‚Äù, October 1, 2012. Experts of the issue: Sergey Mitrofanov, Dmitry Torshin</a></li>
<li><a href="../153009/index.html">Writing the first simple telit firmware</a></li>
<li><a href="../153011/index.html">Russian Design Cup: results, reviews, impressions</a></li>
<li><a href="../153013/index.html">Node.js + Chromium = AppJS: one of the promising options for the second step of the web developer development</a></li>
<li><a href="../153017/index.html">Simple wifi bot for monitoring premises or "kitchen" robotics</a></li>
<li><a href="../153021/index.html">ObjectScript API, integration with C ++. Part 3: Connecting a Module with C ++ Functions</a></li>
<li><a href="../153023/index.html">Veeam virtualization video report</a></li>
<li><a href="../153025/index.html">"Interests" on "Mamba": girls love cats, men - movies</a></li>
<li><a href="../153029/index.html">Captain Kirk calls Enterprise! Or Zefram Cochrane of our day</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>