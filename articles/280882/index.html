<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rust through its founding principles</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I have a few thoughts about learning programming languages. 

 First, we approach this incorrectly. I am sure that you felt the same way. You are tryi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rust through its founding principles</h1><div class="post__text post__text-html js-mediator-article"><p>  I have a few thoughts about learning programming languages. <br><br>  First, we approach this incorrectly.  I am sure that you felt the same way.  You are trying to learn a new language and do not quite understand how everything is arranged in it.  Why in one place one syntax is used, and in another another?  All these oddities are annoying, and as a result we return to the usual language. <br><br>  I believe that our perception of languages ‚Äã‚Äãplays a cruel joke with us.  Remember the last time you discussed a new language.  Someone mentioned it, and someone else inquired about its speed, syntax or existing web framework. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This is very similar to the discussion of cars.  Have you heard of the new Ford Bratwurst?  How fast is he?  Can I drive it across the lake? <br><br>  When we talk about languages ‚Äã‚Äãin a similar way, we mean that they are interchangeable.  Like cars.  If I know how to drive a Toyota Hamhock, then I can drive a Ford Bratwurst without any problems.  The difference is only in speed and dashboard, is not it? <br><br>  But imagine what a PHP car will look like.  Now imagine how much a Lisp car will be.  To change from one to another will require much more than to learn which button controls the heating. <br><br>  The car is easy to change, because they all solve one problem, and we already have an idea of ‚Äã‚Äãwhat this solution should be.  Programming languages, on the contrary, solve different problems, and each of them expresses its own philosophy regarding the approach to their elimination. <br><br>  The syntax and speed of a language express its key characteristics.  For example, Ruby is known for having the ‚Äúdeveloper comfort‚Äù most of all, and this has influenced all its features.  Java attaches great importance to backward compatibility, which is also reflected in the language. <br><br>  Thus, my next idea is this: it is better to learn a language through its key features.  If we understand <em>why</em> certain decisions were made in the language, it will be easier to understand <em>exactly how it</em> works. <br><br></p><a name="habracut"></a><br><p>  Let's look at the key values ‚Äã‚Äãof Rust: </p><br><ul><li>  Speed </li><li>  Safety of work with memory (memory safety) </li><li>  Concurrency </li></ul><br><p>  Let's postpone parallelism for a while and focus on the other two goals of Rust: speed and security of working with memory. <br><br>  It should be clarified: in Rust, "memory security" means that it will not allow a segmentation fault (segmentation fault), which you know firsthand if you have worked with C or C ++.  If you (like me) avoided these languages, then it may be unusual.  Imagine the following situations: </p><br><ul><li>  referring to the fifth element of an array of two elements </li><li>  null method call </li><li>  simultaneous change of one variable by two functions, leaving its value undefined </li><li>  unallocated memory </li></ul><br><p>  In Ruby, you can get an exception, but in languages ‚Äã‚Äãlike C, something worse will happen.  Your program may end abnormally.  Or maybe it will execute some arbitrary code, and your small C program will lead to a huge vulnerability.  Oops. <br><br>  By "memory security" in Rust is meant that such a problem does not arise. <br>  <em>Translator's note: Rust resolves memory leaks in safe code and cannot guarantee their absence in general.</em>  <em>Since it is impossible to guarantee the absence of circular references for Rc / Arc (an index with a reference count), the forget function is not unsafe.</em>  <em>The logic is clear, although I don‚Äôt like it very much - I would prefer this function to be unsafe to emphasize that it should be handled with care.</em> <br><br>  Ruby also protects you from segmentation errors, but uses a garbage collector for this.  It's great, but it has a negative effect on performance. <br><br>  But after all, Rust attaches great importance to speed!  Following this goal, Rust abandons the garbage collector.  Memory management is a programmer's task.  Wait, what about all these horrific bugs that I mentioned ?!  Since Rust appreciates speed, he makes me manage my memory.  But if the second key value of this language is the safety of working with memory, then why does it force me to work with it manually ?! <br><br>  There is a clear contradiction between these two goals.  With this in mind, let's try to figure out Rust! </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, x); }</code> </pre> <br><p>  <a href="http://is.gd/90pGJ1">[Run]</a> <br><br>  This is one of the easiest programs to write on Rust. <br><br>  In an effort to ensure the safety of working with memory, as an option, you can prevent data changes. <br><br>  Thus, in Rust, everything defaults to immutable. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; x = x + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// error: re-assignment of immutable variable `x` [E0384] println!("{}", x); }</span></span></code> </pre> <br><p>  <a href="http://is.gd/jsRBH2">[Run]</a> <br><br>  Of course, the creators of Rust want people to use their language.  So we can declare variables to be mutable, if it‚Äôs really necessary. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; x = x + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, x); <span class="hljs-comment"><span class="hljs-comment">// 2 }</span></span></code> </pre> <br><p>  <a href="http://is.gd/ulaZkZ">[Run]</a> <br><br>  Using the keyword <code>mut</code> you can explicitly indicate that the value is subject to change.  Implicitness is the fourth of the main features of Rust.  It's funny, but I did not see that it was generally explicitly mentioned among the goals of the language, although if there is a choice between explicit and implicit, Rust usually chooses the first. <br><br>  Whether here only will create problems an opportunity to change the data?  One of the goals of the language is the safety of working with memory.  Data variability and memory security seem to be mutually exclusive. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ,      println!("{}", x); //        }</span></span></code> </pre> <br><p>  <a href="http://is.gd/GjwrUO">[Run]</a> <br><br>  Staying true to its core values, Rust introduces a new idea - ownership.  In Rust, each value must have one owner.  And the part of the memory belonging to the owner is released when it goes out of scope. <br><br>  Let's see how it works: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> original_owner = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> new_owner = original_owner; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, original_owner); <span class="hljs-comment"><span class="hljs-comment">// error: use of moved value: `original_owner` [E0382] }</span></span></code> </pre> <br><p>  <a href="http://is.gd/4artUl">[Run]</a> <br><br>  The verbose syntax <code>String::from</code> creates a string that we really own.  Then we transfer ownership, and at that moment the <code>original_owner</code> owns ... nothing.  Our line can have only one owner. <br><br>  Through the system of ownership Rust ensures the safety of working with memory.  If data can have only one owner, then the possibility to change them by different control flows is simultaneously excluded.  For the same reasons, it is impossible to access data that has been destroyed. <br><br>  Earlier, I said that values ‚Äã‚Äãare destroyed when they go out of scope.  So far, we have dealt with only one scope, our <code>main</code> function.  Most programs have more than one scope.  In Rust, scope is limited to curly braces. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> first_scope = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>); { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> second_scope = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"Goodbye"</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, second_scope); <span class="hljs-comment"><span class="hljs-comment">// error: unresolved name `second_scope` [E0425] }</span></span></code> </pre> <br><p>  <a href="http://is.gd/RM9Wtg">[Run]</a> <br><br>  When the internal scope ends, the <code>second_scope</code> destroyed and we can no longer refer to this variable. <br><br>  This is another key component of the security of working with memory.  If we are unable to access variables that are out of scope, then we are sure that no one can use the deleted data.  The compiler simply won't allow it. <br><br>  Now we understand a little more about how Rust works: </p><br><ul><li>  Data can have only one owner. </li><li>  Variables are destroyed when leaving the scope. </li></ul><br><p>  Let's try to do something useful on Rust.  At least as useful as it fits into this article.  Suppose we want to write a function that will determine whether two strings are equal. <br><br>  To begin with about functions.  We declare them in the same way as our <code>main</code> function: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">same_length</span></span></span></span>() { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { same_length(); }</code> </pre> <br><p>  <a href="http://is.gd/ApdEdY">[Run]</a> <br><br>  Our <code>same_length</code> function should take two parameters: the source string and the string for comparison. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">same_length</span></span></span></span>(s1, s2) { <span class="hljs-comment"><span class="hljs-comment">// error: expected one of `:` or `@`, found `,` } fn main() { let source = String::from("Hello"); let other = String::from("Hi"); println!("{}", same_length(source, other)); }</span></span></code> </pre> <br><p>  <a href="http://is.gd/is1zml">[Run]</a> <br><br>  Rust has a special love for being explicit, so we cannot declare a function without specifying which data will be passed to it.  Rust uses strong static typing in function signatures.  In this way, the compiler can make sure that we use our functions correctly, preventing errors.  Explicit typing also makes it easy to see what the function takes.  Our function accepts only strings, which we indicate: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">same_length</span></span></span></span>(s1: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, s2: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> source = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> other = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"Hi"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, same_length(source, other)); <span class="hljs-comment"><span class="hljs-comment">// error: the trait `core::fmt::Display` is not implemented for the type `()` [E0277] }</span></span></code> </pre> <br><p>  <a href="http://is.gd/zydybU">[Run]</a> <br><br>  Most compiler messages are useful, although this may not be so.  It tells us that our function returns an empty value <code>()</code> that cannot be displayed.  Thus, our function should return something.  A boolean value seems appropriate.  For now let's just return <code>false</code> . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">same_length</span></span></span></span>(s1: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, s2: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// error: mismatched types: expected `()`, found `bool` false } fn main() { let source = String::from("Hello"); let other = String::from("Hi"); println!("{}", same_length(source, other)); }</span></span></code> </pre> <br><p>  <a href="http://is.gd/ckY6N1">[Run]</a> <br><br>  And again about the clearness.  Functions must declare not only what they accept, but also the type of the return value.  We return the <code>bool</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[allow(unused_variables)]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">same_length</span></span></span></span>(s1: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, s2: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> source = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> other = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"Hi"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, same_length(source, other)); <span class="hljs-comment"><span class="hljs-comment">// false }</span></span></code> </pre> <br><p>  <a href="http://is.gd/PrRDP2">[Run]</a> <br><br>  Cool.  This is compiled.  Let's try to implement a comparison.  Strings have a <code>len</code> function that returns their length: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">same_length</span></span></span></span>(s1: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, s2: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { s1.len() == s2.len() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> source = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> other = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"Hi"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, same_length(source, other)); <span class="hljs-comment"><span class="hljs-comment">// false }</span></span></code> </pre> <br><p>  <a href="http://is.gd/gyQRvP">[Run]</a> <br><br>  Great.  Now we make two comparisons! </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">same_length</span></span></span></span>(s1: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, s2: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { s1.len() == s2.len() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> source = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> other = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"Hi"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> other2 = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"Hola!"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, same_length(source, other)); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, same_length(source, other2)); <span class="hljs-comment"><span class="hljs-comment">// error: use of moved value: `source` [E0382] }</span></span></code> </pre> <br><p>  <a href="http://is.gd/E90RdF">[Run]</a> <br><br>  Remember the rules?  There can be only one owner, and the values ‚Äã‚Äãare destroyed after the closing brace.  When we call the <code>same_length</code> , we transfer to it ownership of our strings, and upon completion of this function, they are deleted.  Comments will make things easier for you. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">same_length</span></span></span></span>(s1: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, s2: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { s1.len() == s2.len() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> source = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// source  "Hello" let other = String::from("Hi"); // other  "Hi" let other2 = String::from("Hola!"); // other2  "Hola! println!("{}", same_length(source, other)); //   `same_length`  source  other, //         println!("{}", same_length(source, other2)); // error: use of moved value: `source` [E0382] // source     }</span></span></code> </pre> <br><p>  <a href="http://is.gd/Fw6ZUa">[Run]</a> <br><br>  This seems like a serious limitation.  Well, that Rust values ‚Äã‚Äãthe safety of working with memory so highly, but is it worth it? <br><br>  Rust ignores our discontent and adheres to its values, introducing the concept of borrowing.  The value can have only one owner, but any number of borrowers.  Borrowing in Rust is denoted by the symbol <code>&amp;</code> . </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[allow(unused_variables)]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> original_owner = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> new_borrower = &amp;original_owner; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, original_owner); }</code> </pre> <br><p>  <a href="http://is.gd/6fljjI">[Run]</a> <br><br>  Previously, we tried to implement this through the transfer of ownership and failed, but with a loan, everything worked out.  Let's try to use the same approach in our function: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">same_length</span></span></span></span>(s1: &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, s2: &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { s1.len() == s2.len() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> source = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// source  "Hello" let other = String::from("Hi"); // other  "Hi" let other2 = String::from("Hola!"); // other2  "Hola!" println!("{}", same_length(&amp;source, &amp;other)); // false //    source  other  same_length,       println!("{}", same_length(&amp;source, &amp;other2)); // true //    source ! }</span></span></code> </pre> <br><p>  <a href="http://is.gd/X1dZo3">[Run]</a> <br><br>  We obviously lent our data to a function, which clearly says that it only lends them, and does not take possession.  When the <code>same_length</code> completed, the borrowing is also completed, but the data is not destroyed. <br><br>  Wait, doesn‚Äôt this violate the safety of the memory we talked about so much?  Will this not lead to a catastrophe? </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"Hi!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = &amp;x; y.truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  ! truncate   ! }</span></span></code> </pre> <br><p>  <a href="http://is.gd/LVIJs5">[Run]</a> <br><br>  Hmm ... no.  The following rules follow from the memory security in Rust: </p><br><ul><li>  There can be only one owner. </li><li>  You can lend the data any number of times, but you cannot change it. </li></ul><br><p>  Run the above code and see the result. </p><br><pre> <code class="hljs css">&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">anon</span></span>&gt;<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:4</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:3</span></span>: 4<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">error</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">cannot</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">borrow</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">immutable</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">borrowed</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">content</span></span> `*<span class="hljs-selector-tag"><span class="hljs-selector-tag">y</span></span>` <span class="hljs-selector-tag"><span class="hljs-selector-tag">as</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mutable</span></span></code> </pre> <br><p>  Thanks to these two rules, the safety of working with memory is observed, and this happens without sacrificing speed.  All these rules are checked at compile time, without affecting the speed of execution. <br><br>  This is a very superficial introduction to the concept of borrowing and memory.  Rust offers many interesting tools, but they are not always easy to describe.  Once you understand the key features of the language, comes an understanding of why it works that way. <br><br>  If my theories mentioned at the beginning of the article are correct, this introduction to lending did not work so hard.  I hope this is clearer than if I said: "Rust allows you to lend data, just do not forget to use <code>&amp;</code> , and everything will be fine."  I hope. <br><br>  It is difficult to learn a new language: stupid syntax, a strange way of dealing with string delimiters, and so on.  However, it is powerful.  The study of the philosophy of language broadens the mind, but it works only if we consider languages ‚Äã‚Äãnot as an interchangeable jumble of syntax, but as an expression of their principles.  Learning a language through its key features not only facilitates the process, but also allows you to feel the language. </p></div><p>Source: <a href="https://habr.com/ru/post/280882/">https://habr.com/ru/post/280882/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../280870/index.html">Dokkur - the first PaaS from Russia</a></li>
<li><a href="../280872/index.html">Active / Passive PostgreSQL Cluster using Pacemaker, Corosync</a></li>
<li><a href="../280875/index.html">Look at the post: Satya Nadella opens the Microsoft Envision conference.</a></li>
<li><a href="../280878/index.html">Digital security certificate: what is it for?</a></li>
<li><a href="../280880/index.html">According to Rambler.iOS # 6</a></li>
<li><a href="../280884/index.html">4.04</a></li>
<li><a href="../280886/index.html">GSM-traps: another hello from Big Brother</a></li>
<li><a href="../280888/index.html">Overview of Local Binary Patterns (LBP) Image Descriptors and Their Variations</a></li>
<li><a href="../280890/index.html">Coding Dojo meeting in Artec 3D</a></li>
<li><a href="../280892/index.html">How we scored on asynchrony when hiking on backends</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>