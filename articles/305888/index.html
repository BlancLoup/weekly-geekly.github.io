<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Agile API - is it possible?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many articles and books are devoted to how to design an API correctly, but hardly anyone touched upon the topic of the ever-changing (flexible) API. A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Agile API - is it possible?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/509/5df/5b1/5095df5b129848efa0d3b843be564d71.png" align="left">  Many articles and books are devoted to how to design an API correctly, but hardly anyone touched upon the topic of the ever-changing (flexible) API.  A dynamic company often releases several releases a week, and sometimes a day.  At the same time to add new features, you must constantly make changes to the existing API.  In this article we will talk about how we in Badoo solve this problem, what approaches and ideas we use in our work. <br><br>  First of all, I have to tell a little more about Badoo so that you understand who works with our API and why it changes so often. <br><br><a name="habracut"></a><br><h3>  Our internal API and its use </h3><br>  Our Badoo API (messaging protocol) is a set of data structures (messages) and values ‚Äã‚Äã(enums) that clients and server exchange.  The structure of the protocol is set on the basis of the <a href="https://developers.google.com/protocol-buffers">Google protobuf definitions</a> and is stored in a separate git repository.  Based on these definitions, model classes are generated for different platforms. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It is used for six server platforms and five clients: Android, iOS, Windows Phone, Mobile Web, and Desktop Web.  In addition, the same API is used in several stand-alone applications on each platform.  In order for all these applications and the server to share the required information, our API ‚Äúgrew‚Äù large enough.  Some numbers: <br><br><ul><li>  450 messages, 2665 fields. </li><li>  135 enum, 2096 values. </li><li>  125 feature flags that can be managed on the server side. </li><li>  165 flags of client behavior that tell the server how to behave the client and the protocol supported by the client. </li></ul><br><br><h3>  When should it be done?  Yesterday! </h3><br>  In Badoo, we try to implement new features as quickly as possible.  The logic is simple: the sooner a version with new features appears, the faster users will be able to use them.  In addition, we conduct parallel A / B testing, but in this article we will not dwell on it in detail. <br><br>  The implementation time of the feature - from idea to release - is sometimes only a week, including writing requirements, changing the API and technical documentation, implementing and releasing a new version.  On average, everything takes about a month.  However, this does not mean that we add one feature to the application per month.  We are working in parallel on many new features. <br><br>  In order to be capable of such exploits, we had to develop a process that allows us to move at the right speed. <br><br><h3>  Which way to go? </h3><br>  For example, a product owner offers a new idea and asks API developers to extend the protocol in order to implement new features on the client side. <br>  First of all, you need to understand that many people are working on the implementation of the new function: <br><br><ul><li>  Product Owner; </li><li>  designers; </li><li>  server solutions developers; </li><li>  API developers </li><li>  client application developers for different platforms; </li><li>  QA; </li><li>  data analytics. </li></ul><br><br>  How can you ensure that they all understand each other and speak the same language?  We need a document with a description of the requirements for functionality ( <a href="https://en.wikipedia.org/wiki/Product_requirements_document">PRD</a> ). Usually such a document is prepared by the Product Owner.  He creates a wiki page with a list of requirements, use cases, flow description, design sketches, etc. <br><br>  Based on PRD, we can begin planning and implementing the necessary changes to the API. <br><br>  Here again, not so simple. <br><br><h3>  Protocol Design Approaches </h3><br>  There are many approaches to the ‚Äúdistribution of duties‚Äù between the server and the client.  Approaches range from "all logic is implemented on the server" to "all logic is implemented in the client."  Let's discuss the pros and cons of each approach: <br><br>  Option 1. All logic is implemented on the server (the client works as a View from the MVC template). <br><br>  Pros: <br><ul><li>  New functionality for all platforms is enough to implement only once - on the server. </li><li>  You can update only server logic and tokens, there is no need to make changes to client applications and prepare a new release (a very big plus when it comes to native applications). </li></ul><br><br>  Minuses: <br><ul><li>  A more complex protocol (often a feature requires several sequential actions that are easy to implement on the client, and adding these steps to the protocol makes everything very difficult). </li><li>  If something works differently on different client applications, it is necessary to have on the server a separate implementation of functionality for each client application and each supported version of the application. </li><li>  May adversely affect the usability of the application through a slow or unstable connection. </li><li>  If business logic is implemented on the server side, some functions will be very difficult or even impossible to implement without a connection to the server. </li></ul><br><br>  Option 2. All logic is implemented in the client - the client application contains all the logic and uses the server as a data source (typical of most public APIs). <br><br>  Pros: <br><ul><li>  The number of requests to the server is less, the user has to wait less for answers. </li><li>  It works better offline and through a slow or unstable network. </li><li>  Caching is greatly simplified. </li><li>  If necessary, it is much easier to implement different behaviors for different platforms and client versions. </li><li>  Easier interaction with the server - teams can work without looking at each other. </li></ul><br><br>  Minuses: <br><ul><li>  Takes more time.  All logic needs to be implemented on each of the clients, and not once on the server. </li><li>  To implement even the most minor changes, you must release each client application. </li><li>  The higher the probability of errors in the code, since each application has a separate implementation of logic. </li></ul><br><br>  On the one hand, the first approach allows you to implement business logic only once on the server, and then it will be used on all clients.  On the other hand, different platforms have their own characteristics, their structure of lexemes, a different set of features, and the features themselves are often implemented at different times.  In most cases, it is easier to make the protocol more data-oriented, so that client applications have some freedom and can work in their own way.  But, as always, there is no one right decision, therefore we constantly balance between these two approaches. <br><br><h3>  Technical documentation </h3><br>  A few years ago, when our company was smaller, only two clients (Android and iOS) used the protocol.  There were few developers, we discussed all the working points verbally, therefore the documentation on the protocol contained only a description of the general logic in the comments for the protobuf definitions.  Usually it looked like this: <br><br><img src="https://habrastorage.org/files/ee1/e6f/d21/ee1e6fd2145a4bfe8320de2c4a055c85.png" width="600" alt="Documentation in protocol specification"><br><br>  Then three more client platforms appeared: Windows Phone, Mobile Web and Desktop Web, and the number of developers in Android and iOS teams increased threefold.  Oral discussion was becoming more and more expensive, and we decided that it was time to document everything carefully.  Now this documentation includes much more than just comments about fields.  For example, we add a brief description of features, sequence diagrams, screenshots and sample messages.  In the simplest case, the documentation might look like this: <br><br><img src="https://habrastorage.org/files/1fb/127/85f/1fb12785f7a041f5bbf9c85e42ce4cb3.png" width="800" alt="detailed documentation"><br><br>  Application developers and QA for all six platforms use this documentation and PRD as their main sources of knowledge. <br><br>  This documentation helps not only to implement new functions, but also with significant redesign and refactoring of applications, when you need to know how the already implemented functionality works. <br><br>  Now we can easily tell the developers of "RTFM", which saves us a lot of time.  In addition, this approach helps beginners to understand how everything works, and quickly get involved in the development process. <br><br><h4>  We serve the documentation </h4><br>  We prepare technical documentation in the <a href="https://en.wikipedia.org/wiki/ReStructuredText">reStructuredText</a> format and store it in the git repository along with the protocol definitions, and with the help of <a href="http://www.sphinx-doc.org/">Sphinx</a> we generate the HTML version that is available on the company's internal network. <br><br>  The documentation is divided into a number of main sections devoted to various aspects of protocol implementation and other issues: <br><br><ul><li>  <b>Protocol</b> - documentation created based on comments for protobuf definitions.  Product functions - technical documentation on the implementation of functions.  (conveyor diagram, etc.). </li><li>  <b>General</b> - protocol and flow documents not related to specific product features. </li><li>  <b>Application Features</b> - since we have several different applications, this section describes the differences between them.  As mentioned above, the protocol is shared. </li><li>  <b>Statistics</b> ‚Äî A general description of the protocol and processes associated with collecting statistics and application performance information. </li><li>  <b>Notifications</b> - documentation of various types of notifications that can be sent to our users. </li><li>  <b>Architecture and infrastructure</b> - the structure of the lower level for the protocol, binary protocol formats, framework for A / B testing, etc. </li></ul><br><br><h3>  So we made changes to the API.  What's next? </h3><br>  After making changes to the protocol and documentation based on PRD, and PRD and API go through two stages of a review.  First, within the team responsible for the protocol, then among the application developers of those platforms where this feature will be implemented. <br><br>  At this stage, we get feedback on the following issues: <br><br><ul><li>  Sufficiency - whether these API changes are enough to implement features on each platform. </li><li>  Compatibility ‚Äî Whether changes are compatible with the application code on the platforms.  Maybe you can tweak the protocol a bit and save one or two platforms a lot of time and resources? </li><li>  Comprehensibility </li></ul><br><br>  After discussing and approving all the changes, the server and client commands can proceed to the implementation of the feature. <br><br>  To finish at this stage would be too good.  Often, ProductOwner has further plans to improve this feature, but he still wants to release the application now in its current form.  Or more interesting.  Sometimes we are asked to make changes for one platform, and for the rest to leave everything as it is. <br><br><h3>  Feature as a child, it grows and develops </h3><br>  Features develop.  We conduct A / B tests and (or) analyze feedback after the release of new features.  Sometimes analysis shows that the feature needs to be improved.  Then the product owners make changes to the PRD.  And here comes the ‚Äúproblem‚Äù.  Now PRD does not match the format of the protocol and documentation.  Moreover, it may happen that for one platform the changes have already been made, and the other team is just starting to work.  To prevent possible inconsistencies, we use versioning PRD.  For example, for one platform, a feature can be implemented in accordance with version R3.  After some time, the Product Owner decides to refine the new functionality and updates the PRD to version R5.  And we need to update the protocol and technical documentation to reflect the new version of PRD. <br><br>  To monitor PRD updates, we use the <a href="https://www.atlassian.com/software/confluence">Confluence</a> change history (wiki from Atlassian).  In the technical documentation for the protocol, we add links to a specific version of the PRD, simply by specifying? PageVersion = 3 in the address of the wiki page, or take a link from the change history.  Because of this, each developer always knows on the basis of which version or part of the PRD a particular function is implemented. <br><br>  All changes in PRD are considered as new functionality.  Product owners accumulate changes (R1, R2 ...) until they decide that it is time to send them to development.  They prepare an assignment for API developers with a description of the required changes in the protocol, and then all development teams responsible for different platforms receive the same assignments.  When the next set of changes is ready for the feature, another API ticket is created, then the changes are implemented for all platforms in the same way: <br><br><img src="https://habrastorage.org/files/0a6/cc1/fde/0a6cc1fde85c4bdaad125d9d0406f4ce.png" alt="API change steps"><br><br>  Having received the list of changes in the PRD, we return to the beginning of this process, that is, we make changes to the protocol and so on.  Of course, this makes life difficult for us, since no one has canceled the need to support previously implemented functions and client applications that were based on version R3.  To solve this problem, we use several protocol change management tools. <br><br><h3>  Protocol Change Management </h3><br>  In the previous section, we discussed PRD versioning.  To implement these changes in the API, we must consider the protocol version control options.  For simplicity, we can say that there are three options (levels) with their own advantages and disadvantages. <br><br><h4>  Protocol level </h4><br>  This approach is widely used for slowly changing public APIs.  When a new version of the protocol comes out, all clients should start using it instead of the old one.  We can not use this option, because we have a set of features and the time of their implementation are very different on different platforms.  For example, we have several versions of the protocol: <br><br><ul><li>  V1.  Supports A, B, C functions. </li><li>  V2.  It supports functions B ', C and D, where B' is the updated function B (requiring a different command sequence). </li></ul><br><br>  Therefore, if you need to implement feature D in the application, you will also need to update feature B to version B ', although perhaps this is not required now. <br><br>  We at Badoo have never used this approach to version control.  In our case, the following two options are more suitable. <br><br><h4>  Message Based Versioning </h4><br>  With this approach, after making changes to the function, a new message is created (data structure in protobuf) with a new set of fields.  This approach works well if requirements change significantly. <br><br>  For example, in the company Badoo each user has albums.  Previously, users could create their own albums and put photos into them: <br><br> <code>AddPhotoToAlbumV1 { <br> required string album_id = 1; <br> required string photo_id = 2; <br> } <br></code> <br><br>  Then the Product Owner decided that three predefined album types would be enough: my photos, other photos, and private photos.  In order for clients to distinguish between these three types, it was necessary to add an enum;  accordingly, the next version of the message will look like this: <br><br> <code>AddPhotoToAlbumV2 { <br> required AlbumType album_type = 1; <br> required string photo_id = 2; <br> } <br></code> <br><br>  This approach is sometimes quite justified, but care must be taken.  If the change is not quickly implemented on all platforms, you will have to maintain (by adding new changes) both old and new versions, that is, chaos will increase. <br><br><h4>  Field / Value Level </h4><br>  If possible, we use the same message or enumeration, deleting some fields / values ‚Äã‚Äãor adding new ones.  This is perhaps the most common approach in our practice. <br><br>  Example: <br><br> <code>AddPhotoToAlbum { <br> optional string album_id = 1 [deprecated=true]; <br> optional string photo_id = 2; <br> optional AlbumType album_type = 3; <br> } <br></code> <br><br>  In this case, client applications continue to use the old message, and new versions of applications can use album_type instead of album_id. <br><br>  By the way, we always use optional fields.  This allows you to delete fields if necessary (Google developers have come to <a href="https://developers.google.com/protocol-buffers/docs/proto">the same conclusion</a> ). <br><br><h3>  Protocol change support </h3><br>  As mentioned earlier, our API is used by the server and five client platforms.  New versions of our client applications are released every week (about 20 versions of applications per month, which can work differently and use different parts of the protocol), so we cannot simply create a new version of the protocol for each new version of the application.  This approach to protocol versioning will require the server to support thousands of different application combinations.  This solution is far from ideal. <br><br>  Therefore, we stopped at the option where each application immediately sends to the server information about which protocol versions it supports.  In this case, the server can interact with any client application, simply relying on the list of supported features provided by the application itself. <br><br>  For example, we recently implemented the ‚ÄúWhat's New‚Äù feature.  Thus, we inform our users about new features in the application.  Applications that support this feature send the SUPPORTS_WHATS_NEW flag to the server.  As a result, the server knows that it is possible to send messages to the client about new features and they will be displayed normally. <br><br><img src="https://habrastorage.org/files/1f2/64b/646/1f264b646d124de99caea43992db66f6.png" alt="image"><br><br><h3>  How to maintain order in the API? </h3><br>  If this is a public API, then a specific date is usually determined after the occurrence of which the old part stops working.  For Badoo, this is almost impossible, since it is more important for us to implement new functions than to remove support for old ones.  In this situation, we follow the procedure consisting of three stages. <br><br>  At the first stage, as soon as we finally decided that a part of the protocol should be removed, it is marked as ‚Äúoutdated‚Äù, and application developers for all client platforms receive the task of deleting the corresponding code. <br><br>  At the second stage, the outdated part of the protocol should be removed from the code of all clients, but on the server it is impossible to delete this code for quite a long time - not all users update their applications quickly. <br><br>  At the last stage, when outdated code is removed from all client applications, and none of the versions that use this part of the protocol is used anymore, it can be removed from the server code and from the API. <br><br><h3>  Communication </h3><br>  In this article, we described several technical and organizational approaches that we borrowed or created ourselves.  However, we did not address the issues of communication at all.  But communication is 80% of our work.  It is often necessary to discuss the feature itself and possible implementation paths with a large number of people before it can be understood how this feature can be implemented at the protocol level. <br><br>  The basis of any successful project is the hard work of a well-coordinated team.  Fortunately, most developers support us, because they are well aware of how difficult it is to work with solutions for various platforms without standardization. <br><br>  We realized that a well-documented API also helps people who are not developers to understand the API itself and its development process.  Testers turn to documentation during testing, and Product Owners use it to think through solutions to the tasks with minimal changes in the protocol (yes, we have such cool Product Owners!). <br><br><h3>  Conclusion </h3><br>  When developing flexible APIs and related processes, you must be patient and pragmatic.  The protocol and process should work with various combinations of commands, software versions and platforms, outdated versions of the application, and also take into account many other factors.  Nevertheless, this is a very interesting task, on which very little information is currently published.  Therefore, we were very happy to share our work in this direction.  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/305888/">https://habr.com/ru/post/305888/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../305876/index.html">Restrictions on the use of smart LEDs WS2812, WS2801 and similar in modern projects of decorative lighting</a></li>
<li><a href="../305878/index.html">How to choose a server for 1C, SQL and terminals</a></li>
<li><a href="../305880/index.html">What's new is expected in v4.8-rc1 core for Intel Edison. Digest</a></li>
<li><a href="../305882/index.html">Pass a technical interview (Level 4)</a></li>
<li><a href="../305886/index.html">VShBI Lectures: Game Design and Game Operations</a></li>
<li><a href="../305890/index.html">The digest of interesting events from the world of Java, and around it # 6 (07/04/2016 - 07/17/2016)</a></li>
<li><a href="../305892/index.html">Modal windows on Angular, Angular 2 and ReactJS</a></li>
<li><a href="../305894/index.html">JIT compiler optimizes not cool, but very cool</a></li>
<li><a href="../305898/index.html">Cache, Hash and Nyash Mesh</a></li>
<li><a href="../305900/index.html">ES6 humanly</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>