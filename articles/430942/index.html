<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Julia. Scripts and parsing command line arguments</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue to deal with the programming language Julia. Since it is just necessary to have a batch mode for an analysis-oriented data processing lang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Julia. Scripts and parsing command line arguments</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/pi/ts/0a/pits0aw00iivzdctpqqr82w5hww.png"><br>  We continue to deal with the programming language Julia.  Since it is just necessary to have a batch mode for an analysis-oriented data processing language, consider the implementation features of Julia scripts and passing arguments from the command line to them.  Someone, perhaps, this topic will seem commonplace, but given the novelty of the language, I hope that a small overview of the methods for parsing command line arguments and libraries for this, presented in Julia, will still be useful. </p><a name="habracut"></a><br><p>  First, a few words about how the script is made.  Any script starts with a special format string indicating the interpreter.  The line begins with a sequence known as shebang.  For Julia, this line is: </p><br><pre><code class="plaintext hljs">#!/usr/bin/env julia</code> </pre> <br><p>  Of course, you can not do this, but then you have to run the script with the command: </p><br><pre> <code class="plaintext hljs">julia .jl</code> </pre> <br><p>  Also, any script must end with a newline character.  This is a requirement of the POSIX standard, which follows from the definition of a string as a sequence of characters terminated by a newline character. </p><br><p>  In order for the script to be directly run, it must have an <code>executable</code> attribute.  You can add such an attribute in the terminal with the command: </p><br><pre> <code class="plaintext hljs">chmod +x .jl</code> </pre> <br><p>  These rules are valid for all modern operating systems, except, perhaps, MS Windows. </p><br><h2 id="massiv-args">  Args array </h2><br><p>  Let us turn to the first option of the transfer of parameters.  Command line arguments are available in the Julia script via the Base.ARGS constant array.  Let's prepare the simplest script: </p><br><pre> <code class="plaintext hljs">#!/usr/bin/env julia @show typeof(ARGS) @show ARGS</code> </pre> <br><p>  This script simply prints the type and contents of the ARGS array to the console. </p><br><p>  Very often, the file name is passed as command line arguments.  And here there is a feature of processing the file template passed in as an argument.  For example, run our script using the command <code>./args.jl *.jl</code> and get: </p><br><pre> <code class="plaintext hljs">&gt;./args.jl *.jl typeof(ARGS) = Array{String,1} ARGS = ["argparse.jl", "args.jl", "docopt.jl"]</code> </pre><br><p>  And now we‚Äôll slightly change the command line parameter, surrounding the mask with quotes: <br>  <code>./args.jl "*.jl"</code> .  As a result, we get: </p><br><pre> <code class="plaintext hljs">&gt;./args.jl "*.jl" typeof(ARGS) = Array{String,1} ARGS = ["*.jl"]</code> </pre> <br><p>  We see an obvious difference.  In the first case, we got an array with the names of all files that are in the same directory.  In the second case, this is just the same mask that was passed as a command line argument.  The reason for this different script behavior is that the bash interpreter (as well as those close to it), from which the script was run, recognizes the patterns of the file names.  More information can be found in the search engine for the request "Bash Pattern Matching" or "Bash Wildcards".  And all together it is called Globs. </p><br><p>  Among the templates, masking of several characters is possible - *, masking of one character is? .. Search by range [...], and even the ability to specify complex combinations: </p><br><pre> <code class="plaintext hljs">&gt;./args.jl {args,doc}* typeof(ARGS) = Array{String,1} ARGS = ["args.jl", "docopt.jl"]</code> </pre> <br><p>  For more information, see the GNU / Linux Command-Line Tools Summary documentation. </p><br><p>  If, for some reason, we do not want to use the globs mechanism provided by bash, then the mask can be found from the script using the Globs.jl package. <br>  The following code converts everything found in the argument string into a single array of file names.  That is, regardless of whether the user specified masks in quotes, without quotes, or simply listed the names of existing or non-existent files, only the names of actual files or directories will remain in the resulting <code>filelist</code> array. </p><br><pre> <code class="plaintext hljs">using Glob filelist = unique(collect(Iterators.flatten(map(arg -&gt; glob(arg), ARGS))))</code> </pre> <br><p>  These simple examples, in essence, are a demonstration of the use of an ARGS array, where the programmer implements the entire logic of parsing arguments.  This approach is often used when the argument set is extremely simple.  For example, a list of file names.  Or one or two options that can be processed by simple string operations.  Access to the elements of ARGS is the same as to the elements of any other array.  Just remember that the index of the first element in an array in Julia is 1. </p><br><h2 id="paket-argparsejl">  ArgParse.jl package </h2><br><p>  It is a flexible means of describing attributes and command line options without the need to implement parsing logic. <br>  Let's use a slightly modified example from the package documentation - <a href="http://carlobaldassi.github.io/ArgParse.jl/stable/">http://carlobaldassi.github.io/ArgParse.jl/stable/</a> : </p><br><pre> <code class="plaintext hljs">#!/usr/bin/env julia using ArgParse function parse_commandline() s = ArgParseSettings() @add_arg_table s begin "--opt1" help = "an option with an argument" "--opt2", "-o" help = "another option with an argument" arg_type = Int default = 0 "--flag1" help = "an option without argument, ie a flag" action = :store_true "arg1" help = "a positional argument" required = true end return parse_args(s) end function main() @show parsed_args = parse_commandline() println("Parsed args:") for (arg,val) in parsed_args print(" $arg =&gt; ") show(val) println() end end main()</code> </pre> <br><p>  If we run this script without arguments, we get the output of reference information on their composition: </p><br><pre> <code class="plaintext hljs">&gt;./argparse.jl required argument arg1 was not provided usage: argparse.jl [--opt1 OPT1] [-o OPT2] [--flag1] arg1</code> </pre> <br><p>  Moreover, in square brackets we see optional arguments.  At that time, the argument marked as <code>arg1</code> (that is, what we substitute in its place) is mandatory. </p><br><p>  Run again, but specify the required attribute <code>arg1</code> . </p><br><pre> <code class="plaintext hljs">&gt;./argparse.jl test parsed_args = parse_commandline() = Dict{String,Any}("flag1"=&gt;false,"arg1"=&gt;"test","opt1"=&gt;nothing,"opt2"=&gt;0) Parsed args: flag1 =&gt; false arg1 =&gt; "test" opt1 =&gt; nothing opt2 =&gt; 0</code> </pre> <br><p>  We can see that <code>parsed_args</code> is an associative array, where keys are attribute names according to the declaration made in the <code>parse_commandline</code> function, and their values ‚Äã‚Äãare what was substituted by default or passed as values ‚Äã‚Äãof command line arguments.  And values ‚Äã‚Äãhave that type which is explicitly specified at the declaration. </p><br><p>  Argument declaration is performed using the macro <code>@add_arg_table</code> .  It is possible to declare options: </p><br><pre> <code class="plaintext hljs"> "--opt2", "-o" help = "another option with an argument" arg_type = Int default = 0</code> </pre> <br><p>  Or arguments </p><br><pre> <code class="plaintext hljs"> "arg1" help = "a positional argument" required = true</code> </pre> <br><p>  Moreover, the options can be specified with the indication of the full and short forms (at the same time <code>--opt2</code> and <code>-o</code> ).  Or, only in the only form.  The type is specified in the <code>arg_type</code> field.  The default value can be set using <code>default = ...</code>  An alternative to the default value is to require an argument - <code>required = true</code> . <br>  It is possible to declare an automatic action, for example, to assign <code>true</code> or <code>false</code> depending on the presence or absence of an argument.  This is done using <code>action = :store_true</code> </p><br><pre> <code class="plaintext hljs"> "--flag1" help = "an option without argument, ie a flag" action = :store_true</code> </pre> <br><p>  The <code>help</code> field contains the text that will be displayed in the prompt on the command line. <br>  If at the start we specify all the attributes, we get: </p><br><pre> <code class="plaintext hljs">&gt;./argparse.jl --opt1 "2+2" --opt2 "4" somearg --flag parsed_args = parse_commandline() = Dict{String,Any}("flag1"=&gt;true,"arg1"=&gt;"somearg","opt1"=&gt;"2+2","opt2"=&gt;4) Parsed args: flag1 =&gt; true arg1 =&gt; "somearg" opt1 =&gt; "2+2" opt2 =&gt; 4</code> </pre> <br><p>  For debugging from the Atom / Juno IDE, you can add the following, somewhat dirty, but working ARGS array initialization code to the first lines of the script. </p><br><pre> <code class="plaintext hljs">if (Base.source_path() != Base.basename(@__FILE__)) vcat(Base.ARGS, ["--opt1", "2+2", "--opt2", "4", "somearg", "--flag"] ) end</code> </pre> <br><p>  The macro <code>@__FILE__</code> is the name of the file in which the macro is expanded.  And this name for the REPL is different from the name of the current program file obtained through <code>Base.source_path()</code> .  It is impossible to initialize the <code>Base.ARGS</code> array <code>Base.ARGS</code> another value, but, at the same time, you can add new lines, since the array itself is not a constant.  The array is a column for Julia, so we use <code>vcat</code> (vertical concatenate). </p><br><p>  However, in the settings of the Juno editor, you can set arguments to run the script.  But they will have to be changed every time for each script being debugged individually. </p><br><h2 id="paket-docoptjl">  Package DocOpt.jl </h2><br><p>  This option is an implementation of the docopt markup language approach - <a href="http://docopt.org/">http://docopt.org/</a> .  The main idea of ‚Äã‚Äãthis language is a declarative description of options and arguments in a form, which can also be an internal description of a script.  A special template language is used. </p><br><p>  Let's use an example from the documentation for this package <a href="">https://github.com/docopt/DocOpt.jl</a> </p><br><pre> <code class="plaintext hljs">#!/usr/bin/env julia doc = """Naval Fate. Usage: naval_fate.jl ship new &lt;name&gt;... naval_fate.jl ship &lt;name&gt; move &lt;x&gt; &lt;y&gt; [--speed=&lt;kn&gt;] naval_fate.jl ship shoot &lt;x&gt; &lt;y&gt; naval_fate.jl mine (set|remove) &lt;x&gt; &lt;y&gt; [--moored|--drifting] naval_fate.jl -h | --help naval_fate.jl --version Options: -h --help Show this screen. --version Show version. --speed=&lt;kn&gt; Speed in knots [default: 10]. --moored Moored (anchored) mine. --drifting Drifting mine. """ using DocOpt # import docopt function args = docopt(doc, version=v"2.0.0") @show args</code> </pre> <br><p>  The <code>doc = ...</code> entry is the creation of the <code>doc</code> Julia string, which contains the entire declaration for the docopt.  The result of running on the command line with no arguments will be: </p><br><pre> <code class="plaintext hljs">&gt;./docopt.jl Usage: naval_fate.jl ship new &lt;name&gt;... naval_fate.jl ship &lt;name&gt; move &lt;x&gt; &lt;y&gt; [--speed=&lt;kn&gt;] naval_fate.jl ship shoot &lt;x&gt; &lt;y&gt; naval_fate.jl mine (set|remove) &lt;x&gt; &lt;y&gt; [--moored|--drifting] naval_fate.jl -h | --help naval_fate.jl --version</code> </pre><br><p>  If we use the hint and try to ‚Äúcreate a new ship‚Äù, we get a printout of the associative array <code>args</code> , which was formed by the result of the command line parsing. </p><br><pre> <code class="plaintext hljs">&gt;./docopt.jl ship new Bystriy args = Dict{String,Any}( "remove"=&gt;false, "--help"=&gt;false, "&lt;name&gt;"=&gt;["Bystriy"], "--drifting"=&gt;false, "mine"=&gt;false, "move"=&gt;false, "--version"=&gt;false, "--moored"=&gt;false, "&lt;x&gt;"=&gt;nothing, "ship"=&gt;true, "new"=&gt;true, "shoot"=&gt;false, "set"=&gt;false, "&lt;y&gt;"=&gt;nothing, "--speed"=&gt;"10")</code> </pre> <br><p>  The <code>docopt</code> function <code>docopt</code> declared as: </p><br><pre> <code class="plaintext hljs">docopt(doc::AbstractString, argv=ARGS; help=true, version=nothing, options_first=false, exit_on_error=true)</code> </pre> <br><p>  Named arguments <code>help</code> , <code>version</code> , <code>oprtions_first</code> , <code>exit_on_error</code> set the behavior of the argument parser with the default command line.  For example, in case of errors - to complete execution, to issue a <code>version=‚Ä¶</code> here for a request, and to issue a certificate for a request for <code>-h</code> .  <code>options_first</code> used to indicate that options should be before positional arguments. </p><br><p>  And now let's take a closer look at this declarative language and the reaction of the argument parser to the entered values. </p><br><p>  The declaration begins with an arbitrary text, which, in addition to the text for the command line, may be part of the documentation of the script itself.  The service word "Usage:" declares the use case templates for this script. </p><br><pre> <code class="plaintext hljs">Usage: naval_fate.jl ship new &lt;name&gt;... naval_fate.jl ship &lt;name&gt; move &lt;x&gt; &lt;y&gt; [--speed=&lt;kn&gt;]</code> </pre> <br><p>  Arguments are declared in the form <code>&lt;name&gt;</code> , <code>&lt;x&gt;</code> , <code>&lt;y&gt;</code> .  Notice that in the associative array <code>args</code> , which was obtained earlier, these arguments act as keys.  We used the startup form <code>./docopt.jl ship new Bystriy</code> , so we got the following explicitly initialized values: </p><br><pre> <code class="plaintext hljs"> "&lt;name&gt;"=&gt;["Bystriy"], "ship"=&gt;true, "new"=&gt;true,</code> </pre> <br><p>  In accordance with the docopt language, optional elements are specified in square brackets.  For example, <code>[--speed=&lt;kn&gt;]</code> .  In parentheses, the required elements are specified, but with a certain condition.  For example <code>(set|remove)</code> sets the requirement to have one of them.  If the element is specified without parentheses, for example, <code>naval_fate.jl --version</code> , it says that in this particular launch option, <code>--version</code> is a required option. </p><br><p>  The next section is the option description section.  It begins with the word "Options:" <br>  Options are declared each on a separate line.  Indents to the left of the beginning of the line are important.  For each option, you can specify the full and short form.  And also the description of the option given in the hint.  At the same time, the options <code>-h | --help, --version</code>  <code>-h | --help, --version</code> automatically recognized.  The reaction to them is given by the arguments of the <code>docopt</code> function.  Interesting to consider is the declaration: </p><br><pre> <code class="plaintext hljs"> --speed=&lt;kn&gt; Speed in knots [default: 10].</code> </pre> <br><p>  Here the form <code>...=&lt;kn&gt;</code> specifies the presence of some value, and <code>[default: 10]</code> defines the default value.  Turn again to the values ‚Äã‚Äãobtained in <code>args</code> : </p><br><pre> <code class="plaintext hljs">"--speed"=&gt;"10"</code> </pre> <br><p>  The principal difference, for example, from the ArgParse package, is that the values ‚Äã‚Äãare not typed.  That is, the <code>default: 10</code> value <code>default: 10</code> set as the string "10". <br>  In relation to other arguments that are presented in <code>args</code> as a result of parsing the arguments, you should pay attention to their values: </p><br><pre> <code class="plaintext hljs"> "remove"=&gt;false, "--help"=&gt;false, "--drifting"=&gt;false, "mine"=&gt;false, "move"=&gt;false, "--version"=&gt;false, "--moored"=&gt;false, "&lt;x&gt;"=&gt;nothing, "shoot"=&gt;false, "set"=&gt;false, "&lt;y&gt;"=&gt;nothing,</code> </pre> <br><p>  That is, absolutely all template elements specified in the docopt declaration for all use cases are represented as a result of parsing with the original names.  All optional arguments that were not present on the command line are false here.  The arguments <code>&lt;x&gt;</code> , <code>&lt;y&gt;</code> also missing in the start line and are set to nothing.  Other arguments, for which the parse pattern coincided, were true: </p><br><pre> <code class="plaintext hljs"> "ship"=&gt;true, "new"=&gt;true,</code> </pre> <br><p>  And we have already received specific values ‚Äã‚Äãfor the following template elements: </p><br><pre> <code class="plaintext hljs"> "&lt;name&gt;"=&gt;["Bystriy"], "--speed"=&gt;"10"</code> </pre> <br><p>  The first value was set explicitly on the command line as argument substitution, and the second was an option with a default value. <br></p><p>  Also note that the name of the current script can be calculated automatically. <br>  For example, we can enter: </p><br><pre> <code class="plaintext hljs">doc = """Naval Fate. Usage: $(Base.basename(@__FILE__)) ship new &lt;name&gt;‚Ä¶ """</code> </pre> <br><p>  An additional recommendation for placing a command line argument parser is to place it at the very beginning of the file.  An unpleasant feature of Julia at the moment is quite a long connection of modules.  For example <code>using Plots; using DataFrames</code>  <code>using Plots; using DataFrames</code> can send a script to wait for a few seconds.  This is not a problem for server-side, once loaded scripts, but it will annoy users who just want to see a hint on the command line arguments.  That is why, you first need to issue help and check the command line arguments, and only then proceed to download the necessary libraries. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  The article does not pretend to the completeness of the consideration of all methods of analysis of the arguments in Julia.  However, the options considered, in fact, cover 3 possible options.  Fully manual parsing of the <code>ARGS</code> array.  Strongly declared but automatically parsed arguments in ArgParse.  And a fully declarative, though not a strict form of docopt.  The choice of use case depends entirely on the complexity of the arguments being parsed.  The docopt variant seems to be the easiest to use, although it requires an explicit type conversion for the values ‚Äã‚Äãof the arguments received.  However, if the script does not accept anything other than the file name, then it is quite possible to use the output of the help on it using the usual <code>println("Run me with file name")</code> function, and disassemble the file names directly from <code>ARGS</code> as it was demonstrated in the first section. </p><br><h2 id="ssylki">  Links </h2><br><ul><li>  <a href="">https://github.com/vtjnash/Glob.jl</a> </li><li>  <a href="https://argparsejl.readthedocs.io/en/latest/argparse.html">https://argparsejl.readthedocs.io/en/latest/argparse.html</a> </li><li>  <a href="https://github.com/carlobaldassi/ArgParse.jl/">https://github.com/carlobaldassi/ArgParse.jl/</a> </li><li>  <a href="http://docopt.org/">http://docopt.org/</a> </li><li>  <a href="">https://github.com/docopt/DocOpt.jl</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/430942/">https://habr.com/ru/post/430942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430932/index.html">Hackers stole more than 21 million rubles from a Russian bank</a></li>
<li><a href="../430934/index.html">Asterisk Dialplan Extension Mask Generator</a></li>
<li><a href="../430936/index.html">Conference DEFCON 21. DNS can be dangerous for your health. Part 2</a></li>
<li><a href="../430938/index.html">How to get the first orders in design, when there is no portfolio and experience</a></li>
<li><a href="../430940/index.html">SDK to you, SDK to me, SDK to everyone! How to do the SDK and why it is needed</a></li>
<li><a href="../430944/index.html">NASA has decided on the participants for its mini-lunar competition.</a></li>
<li><a href="../430948/index.html">Ministry of Communications proposes to tighten control over personal data</a></li>
<li><a href="../430950/index.html">Make Modern Build</a></li>
<li><a href="../430952/index.html">Electric cars and hybrid cars will have to make additional sounds: why is it necessary?</a></li>
<li><a href="../430954/index.html">Qt Everywhere: WebAssembly and WebGL streaming</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>