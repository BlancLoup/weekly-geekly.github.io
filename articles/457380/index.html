<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Super modern OpenGL. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All good mood and the temperature outside the window below. As promised, I publish the continuation of the article on the super-duper modern OpenGL. W...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Super modern OpenGL. Part 2</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/ui/wu/2k/uiwu2kjzkvznzwubjaqnk7lkoz0.jpeg"><br><br>  All good mood and the temperature outside the window below.  As promised, I publish the continuation of the article on the super-duper modern OpenGL.  Who has not read the first part - <a href="https://habr.com/ru/post/456932/">Supermodern OpenGL.</a>  <a href="https://habr.com/ru/post/456932/">Part 1</a> . <br><br>  Maybe I'll get lucky and I can shove the rest of the material into this article, this is not exactly ... <br><a name="habracut"></a><br><h3>  <font color="#4682B4">Array Texture</font> </h3><br>  Texture arrays were added back in OpenGL 3.0, but for some reason very few people write about them (the information is safely hidden by masons).  All of you are familiar with programming and know what an <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D1%2581%25D1%2581%25D0%25B8%25D0%25B2_(%25D1%2582%25D0%25B8%25D0%25BF_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">array is</a> , although I'd rather ‚Äúfit‚Äù the other side. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To reduce the number of switching between textures, and as a result, and reduce the switching operations of states, people use <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BA%25D1%2581%25D1%2582%25D1%2583%25D1%2580%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D1%2582%25D0%25BB%25D0%25B0%25D1%2581">texture atlases</a> (a texture that stores data for several objects).  But the smart guys from Khronos have developed an alternative for us - Array texture.  Now we can store textures as layers in this array, that is, it is an alternative to atlases.  The OpenGL Wiki has a slightly different description, about mipmaps, etc., but it seems too complicated to me ( <a href="https://www.khronos.org/opengl/wiki/Array_Texture">link</a> ). <br><br>  The advantages of using this approach compared to atlases are that each layer is treated as a separate texture in terms of wrapping and mipmapping. <br><br>  But back to our sheep ... The textural array has three types of target: <br><br><ul><li>  GL_TEXTURE_1D_ARRAY </li><li>  GL_TEXTURE_2D_ARRAY </li><li>  GL_TEXTURE_CUBE_MAP_ARRAY </li></ul><br>  Texture array creation code: <br><br><pre><code class="cpp hljs">GLsizei width = <span class="hljs-number"><span class="hljs-number">512</span></span>; GLsizei height = <span class="hljs-number"><span class="hljs-number">512</span></span>; GLsizei layers = <span class="hljs-number"><span class="hljs-number">3</span></span>; glCreateTextures(GL_TEXTURE_2D_ARRAY, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;texture_array); glTextureStorage3D(texture_array, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGBA8, width, height, layers);</code> </pre> <br>  The most attentive noticed that we create a storage for 2D textures, but for some reason we use a 3D array, there is no error or typo.  We store 2D textures, but since they are arranged in ‚Äúlayers‚Äù we get a 3D array (in fact, pixel data is stored, not textures. The 3D array has 2D layers with pixel data). <br><br>  It is easy to understand by the example of 1D texture.  Each line in the 2D pixel array is a separate 1D layer.  Mipmap textures can also be created automatically. <br><br>  This completes all the difficulties and adding an image to a specific layer is quite simple: <br><br><pre> <code class="cpp hljs">glTextureSubImage3D(texarray, mipmap_level, offset.x, offset.y, layer, width, height, <span class="hljs-number"><span class="hljs-number">1</span></span>, GL_RGBA, GL_UNSIGNED_BYTE, pixels);</code> </pre> <br>  When using arrays we need to change the shader a bit <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core layout (location = 0) out vec4 color; layout (location = 0) in vec2 texture_0; uniform sampler2DArray texture_array; uniform uint diffuse_layer; float getCoord(uint capacity, uint layer) { return max(0, min(float(capacity - 1), floor(float(layer) + 0.5))); } void main() { color = texture(texture_array, vec3(texture_0, getCoord(3, diffuse_layer))); }</span></span></code> </pre> <br>  The best option is to calculate the desired layer outside the shader, for this we can use <a href="https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object">UBO</a> / <a href="https://www.khronos.org/opengl/wiki/Shader_Storage_Buffer_Object">SSBO</a> (it is also used to transfer matrices, and many other data, but this is some other time).  If anyone can not wait <a href="">tyk_1</a> and <a href="https://pdfs.semanticscholar.org/dced/183da56e381975911176033dd2eac0f5638c.pdf">tyk_2</a> , you can read. <br><br>  As for the size, that is GL_MAX_ARRAY_TEXTURE_LAYERS which is 256 in OpenGL 3.3 and 2048 in OpenGL 4.5. <br><br>  It is worth telling about the Sampler Object (not to refer to the Array texture, but a useful thing) - this is the object that is used to set up the states of the texture unit, no matter which object is currently attached to the unit.  It helps to isolate the state of the sampler from a specific texture object, which improves the abstraction. <br><br><pre> <code class="cpp hljs">GLuint sampler_state = <span class="hljs-number"><span class="hljs-number">0</span></span>; glGenSamplers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;sampler_state); glSamplerParameteri(sampler_state, GL_TEXTURE_WRAP_S, GL_REPEAT); glSamplerParameteri(sampler_state, GL_TEXTURE_WRAP_T, GL_REPEAT); glSamplerParameteri(sampler_state, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glSamplerParameteri(sampler_state, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glSamplerParameterf(sampler_state, GL_TEXTURE_MAX_ANISOTROPY_EXT, <span class="hljs-number"><span class="hljs-number">16.0f</span></span>);</code> </pre> <br>  I just created a sampler object, turned on linear filtering and 16x anisotropic filtering for any texture unit. <br><br><pre> <code class="cpp hljs">GLuint texture_unit = <span class="hljs-number"><span class="hljs-number">0</span></span>; glBindSampler(texture_unit, sampler_state);</code> </pre> <br>  Here we simply bind the sampler to the desired texture unit, and when it ceases to be necessary, we bind the 0 to the given unit. <br><br><pre> <code class="cpp hljs">glBindSampler(texture_unit, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  When we tied the sampler its settings take precedence over the texture unit settings.  Result: there is no need to change the existing code base to add sampler objects.  You can leave texture creation as it is (with its own sampler states) and simply add code to control and use the sampler objects. <br><br>  When it is time to delete an object, simply call this function: <br><br><pre> <code class="cpp hljs">glDeleteSamplers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;sampler_state);</code> </pre> <br><h3>  <font color="#4682B4">Texture view</font> </h3><br>  I will translate this as a ‚Äútexture index (maybe more correct links, I xs),‚Äù because I don‚Äôt know a better translation. <br><br>  What are pointers in the OpenGL perspective? <br><br>  Everything is very simple, this is a pointer to the immutable (variable) texture data, as we can see in the picture below. <br><br><img src="https://habrastorage.org/webt/ul/r0/sy/ulr0syubsujlqfshyemnh6sqdoq.jpeg"><br><br>  In fact, this is an object that shares the data of texels of a certain texture object, for analogy, you can use <a href="https://ru.cppreference.com/w/cpp/memory/shared_ptr">std :: shared_ptr from C ++</a> .  As long as there is at least one pointer to the texture, the original texture will not be deleted by the driver. <br><br>  In the <a href="https://www.khronos.org/opengl/wiki/Texture_Storage">wiki</a> described in more detail, as well as it is worth reading about the types of texture and target (they do not have to be the same) <br><br>  To create a pointer, we need to get a texture handle by calling <a href="http://docs.gl/gl4/glGenTextures">glGenTexture</a> (no initialization is needed) and then <a href="http://docs.gl/gl4/glTextureView">glTextureView</a> . <br><br><pre> <code class="cpp hljs">glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;texture_view); glTextureView(texture_view, GL_TEXTURE_2D, source_name, internal_format, min_level, level_count, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Texture pointers can point to the N-th level of the mipmap, quite useful and convenient.  Pointers can be like texture arrays, parts of arrays, a specific layer in this array, and can be a 3D texture slice as a 2D texture. <br><br><h3>  <font color="#4682B4">Single buffer for index and vertex</font> </h3><br>  Well, everything will be quick and easy.  Previously, the OpenGL specification for <a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_vertex_buffer_object.txt">Vertex Buffer Object</a> recommended that the developer split the vertex and index data into different buffers, but now this is not necessary (long story why not necessarily). <br>  All we need is to keep the indices in front of the vertices and tell where the vertices start (more precisely, the offset), for this there is the command <a href="http://docs.gl/gl4/glBindVertexBuffer">glVertexArrayVertexBuffer</a> <br><br>  Here's how we would do it: <br><br><pre> <code class="cpp hljs">GLint alignment = GL_NONE; glGetIntegerv(GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT, &amp;alignment); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLsizei ind_len = GLsizei(ind_buffer.size() * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">element_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLsizei vrt_len = GLsizei(vrt_buffer.size() * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">vertex_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLuint ind_len_aligned = align(ind_len, alignment); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLuint vrt_len_aligned = align(vrt_len, alignment); GLuint buffer = GL_NONE; glCreateBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;buffer); glNamedBufferStorage(buffer, ind_len_aligned + vrt_len_aligned, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, GL_DYNAMIC_STORAGE_BIT); glNamedBufferSubData(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, ind_len, ind_buffer.data()); glNamedBufferSubData(buffer, ind_len_aligned, vrt_len, vrt_buffer.data()); GLuint vao = GL_NONE; glCreateVertexArrays(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;vao); glVertexArrayVertexBuffer(vao, <span class="hljs-number"><span class="hljs-number">0</span></span>, buffer, ind_len_aligned, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">vertex_t</span></span>)); glVertexArrayElementBuffer(vao, buffer);</code> </pre> <br><br><h3>  <font color="#4682B4">Tessellation and compute shading</font> </h3><br>  I will not tell you about the tessellation shader, as there is a lot of material in Google about this (in Russian), here are a couple of lessons: <a href="https://triplepointfive.github.io/ogltutor/tutorials/tutorial30.html">1</a> , <a href="https://triplepointfive.github.io/ogltutor/tutorials/tutorial31.html">2</a> , <a href="https://habr.com/ru/post/314532/">3</a> .  Let us proceed to the consideration of the shader for calculations (bliiin, also a lot of material, I will tell in brief). <br><br>  The advantage of video cards in a very large number of cores, video cards are designed for a huge number of small tasks that can be performed in parallel.  The calculation shader, as the name implies, makes it possible to solve problems that are not related to graphics (optional). <br><br>  The picture, I do not know what to call it (such as streams are grouped). <br><br><img src="https://habrastorage.org/webt/tw/3a/x_/tw3ax_rzsrwx5look90ggm5xehw.jpeg"><br><br>  What can we use? <br><br><ul><li>  Image processing <ol><li>  Blour </li><li>  Algorithms based on tiles (delayed shading) </li></ol></li><li>  Simulations <br><ol><li>  Particles </li><li>  Water </li></ol></li></ul><br>  Then I see no reason to write, there is also a lot of information in Google, here is a simple example of use: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     glUseProgramStages( pipeline, GL_COMPUTE_SHADER_BIT, cs); // ,    / glBindImageTexture( 0, tex, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA8); // 80x45   (  1280720) glDispatchCompute( 80, 45, 1);</span></span></code> </pre> <br><br>  Here is an example of an empty compute shader: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 430 layout(local_size_x = 1, local_size_y = 1) in; layout(rgba32f, binding = 0) uniform image2D img_output; void main() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// base pixel color for image vec4 pixel = vec4(0.0, 0.0, 0.0, 1.0); // get index in global work group ie x,y position ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy); // // interesting stuff happens here later // // output to a specific pixel in the image imageStore(img_output, pixel_coords, pixel); }</span></span></span></span></code> </pre> <br><br>  Here are a few links for more in depth acquaintance <a href="https://www.khronos.org/assets/uploads/developers/library/2014-siggraph-bof/KITE-BOF_Aug14.pdf">1</a> , <a href="https://developer.arm.com/docs/100587/latest/compute-shaders/compute-shaders-example">2</a> , <a href="https://habr.com/ru/post/346268/">3</a> , <a href="http://antongerdelan.net/opengl/compute.html">4</a> . <br><br><h3>  <font color="#4682B4">Path rendering</font> </h3><br>  This is a new (not new) extension from <a href="http://developer.download.nvidia.com/assets/gamedev/files/Getting_Started_with_NV_path_rendering.pdf">NVidia</a> , its main goal is vector 2D rendering.  We can use it for texts or UI, and since the vector graphics, it does not depend on the resolution, which is undoubtedly a big plus and our UI will look great. <br><br>  The basic concept is a stencil, then a cover (cover in the original).  Set the stencil path, then visualize the pixels. <br><br>  For management, the standard GLuint is used, and the create and delete functions have standard naming. <br><br><pre> <code class="cpp hljs">glGenPathsNV <span class="hljs-comment"><span class="hljs-comment">//  glDeletePathsNV // </span></span></code> </pre> <br><br>  Here is a little about how we can get the path: <br><ul><li>  SVG or PostScript in string <pre> <code class="cpp hljs">glPathStringNV</code> </pre> </li><li>  array of commands with the corresponding coordinates <pre> <code class="cpp hljs">glPathCommandsNV</code> </pre>  and to update the data <pre> <code class="cpp hljs">glPathSubCommands, glPathCoords, glPathSubCoords</code> </pre> </li><li>  fonts <pre> <code class="cpp hljs">glPathGlyphsNV, glPathGlyphRangeNV</code> </pre> </li><li>  linear combinations of existing paths (interpolating one, two or more paths) <pre> <code class="cpp hljs">glCopyPathNV, glInterpolatePathsNV, glCombinePathsNV</code> </pre> </li><li>  linear transformation of the existing path <pre> <code class="cpp hljs">glTransformPathNV</code> </pre> </li></ul><br>  List of standard commands: <br><br><ul><li>  move-to (x, y) </li><li>  close-path </li><li>  line-to (x, y) </li><li>  quadratic-curve (x1, y1, x2, y2) </li><li>  cubic-curve (x1, y1, x2, y2, x3, y3) </li><li>  smooth-quadratic-curve (x, y) </li><li>  smooth-cubic-curve (x1, y1, x2, y2) </li><li>  elliptical-arc (rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y) </li></ul><br>  Here is the path string in PostScript: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"100 180 moveto 40 10 lineto 190 120 lineto 10 120 lineto 160 10 lineto closepath‚Äù // "</span></span><span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span> moveto <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> curveto <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span> curveto closepath‚Äù <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre> <br>  But in SVG: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"M100,180 L40,10 L190,120 L10,120 L160,10 z‚Äù // "</span></span>M300 <span class="hljs-number"><span class="hljs-number">300</span></span> C <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span>,<span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span>,<span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span>Z‚Äù <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre> <br>  There are still all sorts of buns with types of fillings, edges, curves: <br><br><img src="https://habrastorage.org/webt/wx/uy/wv/wxuywvdg2rfuxlrrasn_hh9yzkm.jpeg"><br><br>  I will not describe everything here, since there is a lot of material and it will take a whole article (if it is interesting, I will write sometime). <br><br>  Here is a list of drawing primitives. <br><br><ul><li>  Cubic curves </li><li>  Quadratic curves </li><li>  Lines </li><li>  Font glyphs </li><li>  Arcs </li><li>  Dash &amp; Endcap Style </li></ul><br>  Here is a bit of code, and there is a lot of text: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// SVG  glPathStringNV( pathObj, GL_PATH_FORMAT_SVG_NV, strlen(svgPathString), svgPathString); //  glStencilFillPathNV( pathObj, GL_COUNT_UP_NV, 0x1F); // //  ( ) glCoverFillPathNV( pathObj, GL_BOUNDING_BOX_NV);</span></span></code> </pre> <br>  That's all. <br><br>  It seems to me that this article came out less interesting and informative, it was difficult to identify the main thing in the material.  If anyone is interested in learning more, I can throw off some NVidia materials and links to specifications (if I remember where I saved them).  Also happy for any help in editing the article. <br><br>  As promised, I will write the following article about optimizing and reducing draw calls.  I would like to ask to write in the comments, what else would you like to read and what you are interested in: <br><ul><li>  Writing a game on cocos2d-x (Practice only, no water) </li><li>  Translation of a series of articles on Vulkan </li><li>  Any themes on OpenGL (quaternions, new functionality) </li><li>  Computer graphics algorithms (lighting, space screen ambient occlusion, space screen reflection) </li><li>  Your options </li></ul><br><br>  Thank you all for your attention. </div><p>Source: <a href="https://habr.com/ru/post/457380/">https://habr.com/ru/post/457380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45737/index.html">Mumbai terrorists and new US IT policy</a></li>
<li><a href="../457370/index.html">Creating a 3-level menu using the Htmlix framework</a></li>
<li><a href="../457374/index.html">Reduce the build time of your Android projects</a></li>
<li><a href="../457378/index.html">How id Software created Wolfenstein 3D based technologies from Commander Keen</a></li>
<li><a href="../45738/index.html">Bored, my friends ...</a></li>
<li><a href="../457382/index.html">7 habits of highly efficient programmers</a></li>
<li><a href="../457386/index.html">Understanding Linux Virtual Interfaces: Tunnels</a></li>
<li><a href="../45739/index.html">Openit.com.ua [Not] v_kkrita kraina</a></li>
<li><a href="../457392/index.html">Saving on mobile cross-platform development: Skyeng case</a></li>
<li><a href="../457396/index.html">Automatic unlocking of the root LUKS container after a hot reboot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>