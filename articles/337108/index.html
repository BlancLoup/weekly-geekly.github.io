<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Test asynchronous code with PyTest (translation)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When preparing the material for the course , we occasionally come across interesting articles that I would like to share with you! 

 By Stefan Scherf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Test asynchronous code with PyTest (translation)</h1><div class="post__text post__text-html js-mediator-article">  When preparing the material for the <a href="http://otus.ru/lessons/python-dlja-web-razrabotki/%3Futm_source%3Dhabr%26utm_medium%3Daffilate%26utm_campaign%3Dwebdev%26utm_term%3Dprofi04.09">course</a> , we occasionally come across interesting articles that I would like to share with you! <br><br>  By Stefan Scherfke <a href="https://stefan.sofa-rockers.org/2015/04/22/testing-coroutines/">‚ÄúTesting (asyncio) coroutines with pytest‚Äù</a> <br><br><img src="https://habrastorage.org/web/1a8/064/bed/1a8064beddc2428ea3a95d8f32390d86.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      PyTest is an excellent package for testing in Python, and for a long time one of my favorite packages in general.  It greatly facilitates the writing of tests and has ample opportunities to compile reports on unsuccessful tests. <br><br>  However, at the time of version 2.7, it is less effective in testing (asyncio) routines.  Therefore, do not try to test them in this way: <br><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># tests/test_coros.py import asyncio def test_coro(): loop = asyncio.get_event_loop() @asyncio.coroutine def do_test(): yield from asyncio.sleep(0.1, loop=loop) assert 0 # onoes! loop.run_until_complete(do_test())</span></span></code> </pre> <br>  In this method, many shortcomings and excesses.  The only interesting lines are those containing the statements yield from and assert. <br><a name="habracut"></a><br>  Each test case must have its own event cycle, which is completed correctly, regardless of the success of the test. <br><br>  Applying yield in the manner described above will not work, pytest will decide that our test returns new test cases. <br><br>  Therefore, it is necessary to create a separate subroutine in which the actual test is contained, and for its execution an event loop is started. <br>  Tests will be cleaner if done like this: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># tests/test_coros.py @asyncio.coroutine def test_coro(loop): yield from asyncio.sleep(0.1, loop=loop) assert 0</span></span></code> </pre><br>  Pytest has a flexible plugin system, which makes implementation of this behavior possible.  But, unfortunately, most of the necessary hooks are documented poorly or not at all, therefore, finding out how to perform them is problematic. <br><br>  A local pop-up plugin is created simply because it is a bit simpler than creating a ‚Äúreal‚Äù external plugin.  Pytest finds in each test directory a file called conftest.py and applies fixtures and hooks, implemented in it, to all the tests in this directory. <br><br>  Let's start by writing a fixture that creates a new event loop for each test case and closes it correctly at the end of the test: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># tests/conftest.py import asyncio import pytest @pytest.yield_fixture def loop(): #  loop = asyncio.new_event_loop() asyncio.set_event_loop(loop) yield loop #  loop.close() # tests/test_coros.py def test_coro(loop): @asyncio.coroutine def do_test(): yield from asyncio.sleep(0.1, loop=loop) assert 0 # onoes! loop.run_until_complete(do_test())</span></span></code> </pre><br>  Before each test, pytest executes a fixture loop to the first yield statement.  What returns returns is passed as an argument to the loop (that is, the loop) of our test case.  When the test is completed (successfully or not), pytest terminates the loop fixture, closing it correctly.  In the same way, you can write a test fixture that creates a socket and closes it after each test (the fixture of the socket may depend on the cycle fixture in the same way as in our example. Cool, isn't it?) <br><br>  But the end is still far away.  We need to teach pytest to execute our test routines.  To do this, change how the asyncio subroutines are assembled (they should be assembled as normal test functions, and not as test generators) and how they are executed (using loop.run_until_complete ()): <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># tests/conftest.py def pytest_pycollect_makeitem(collector, name, obj): """ asyncio    ,   .‚Äù if collector.funcnamefilter(name) and asyncio.iscoroutinefunction(obj): #       #    ,         # ,    "pytest.mark.parametrize()". return list(collector._genfunctions(name, obj)) # else: #   None,    pytest'   ‚Äúobj‚Äù def pytest_pyfunc_call(pyfuncitem): """ ``pyfuncitem.obj`` -  asyncio ,         """ testfunction = pyfuncitem.obj if not asyncio.iscoroutinefunction(testfunction): #  None,    . Pytest   #      return #       : funcargs = pyfuncitem.funcargs #     argnames = pyfuncitem._fixtureinfo.argnames #     testargs = {arg: funcargs[arg] for arg in argnames} #  -    (   !) coro = testfunction(**testargs) #         loop = testargs['loop'] if loop in testargs else asyncio.get_event_loop() loop.run_until_complete(coro) return True #  pytest',    </span></span></code> </pre><br>  This plugin works in pytest version 2.4 and higher.  I checked its performance with versions 2.6 and 2.7. <br><br>  And everything would be fine, but soon after the publication of this solution in Stack Overflow, the plugin PyTest-Asyncio appeared, but Stefan was not upset at all, but did a detailed analysis of this plugin. <br><br><h3>  Advanced <a href="https://stefan.sofa-rockers.org/2016/03/10/advanced-asyncio-testing/">asynchronous</a> testing </h3><br>  In my first article, I showed how pytest helps write quality tests.  Fixtures allow you to create a clean event loop for each test case, and thanks to the plugin system you can write test functions, which are actually asyncio coroutines. <br><br>  But while work was being done on this material, Tin Tvrtkowitz created the pytest-asyncio plugin. <br><br>  In short, it allows you to do this: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest @pytest.mark.asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_coro</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event_loop)</span></span></span><span class="hljs-function">:</span></span> before = time.monotonic() <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0.1</span></span>, loop=event_loop) after = time.monotonic() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> after - before &gt;= <span class="hljs-number"><span class="hljs-number">0.1</span></span></code> </pre><br>  Instead: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_coro</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> loop = asyncio.new_event_loop() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: asyncio.set_event_loop(loop) before = time.monotonic() loop.run_until_complete(asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0.1</span></span>, loop=loop)) after = time.monotonic() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> after - before &gt;= <span class="hljs-number"><span class="hljs-number">0.1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: loop.close()</code> </pre><br>  Using pytest-asyncio visually improves the test (and this is not the limit of the plugin‚Äôs possibilities!). <br><br>  When I was working on aiomas, I encountered additional requirements that were not so easy to accomplish. <br><br>  A little bit about what is aiomas itself.  He adds three layers of abstraction asyncio transports: <br><br><ul><li>  The channel layer allows you to send messages in JSON or MsgPack format using the ‚Äúrequest-response‚Äù scheme.  It uses a custom protocol that works with different types of transports: TCP sockets, Unix domain sockets and custom transport - local queue. </li><li>  The RPC layer creates a Remote Procedure Call system above the channel layer. </li><li>  The agent layer (for multi-agent systems) contains even more details related to the network, and allows you to write classes that call methods of other classes through a network connection. </li></ul><br>  The simplest example of how the channel layer works: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiomas <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_client</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(channel)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" """</span></span> req = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> channel.recv() print(req.content) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> req.reply(<span class="hljs-string"><span class="hljs-string">'cya'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> channel.close() <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">client</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" :      """</span></span> channel = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> aiomas.channel.open_connection((<span class="hljs-string"><span class="hljs-string">'localhost'</span></span>, <span class="hljs-number"><span class="hljs-number">5555</span></span>)) rep = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> channel.send(<span class="hljs-string"><span class="hljs-string">'ohai'</span></span>) print(rep) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> channel.close() server = aiomas.run(aiomas.channel.start_server( (<span class="hljs-string"><span class="hljs-string">'localhost'</span></span>, <span class="hljs-number"><span class="hljs-number">5555</span></span>), handle_client)) aiomas.run(client()) server.close() aiomas.run(server.wait_closed())</code> </pre><br><h3>  Test requirements </h3><br>  Need a clean event loop for each test. <br><br>  This can be done using the event_loop fixture, which is in pytest-asyncio. <br>  Each test must be run with every possible transport (TCP socket, Unix domain socket, ...). <br><br>  Theoretically, this can be solved with the help of the pytest.mark.parametrize () decorator (but not in our case, how further it will become clear). <br><br>  Each test needs a client coroutine.  Ideally, the test itself. <br><br>  The pytest.mark.asyncio decorator in pytest-asyncio does the job. <br><br>  Each test requires a server with a custom callback for client connections.  At the end of the test, the servers should be turned off regardless of the test result. <br><br>  It seems that the coroutine can solve this problem, but each server needs a specific callback to manage client connections.  Which complicates problem solving.  I do not want to receive the ‚ÄúAddress already in use‚Äù error if one of the tests fails.  The fixture unused_tcp_port in pytest-asyncio to the rescue. <br><br>  I do not want to constantly use loop.run_until_complete (). <br><br>  And the pytest.mark.asyncio decorator solves the problem. <br><br>  To summarize what remains to be solved: each test needs two fixtures (one for the event loop and one more for the address type), but I want to combine them into one.  You need to create a fixture to configure the server, but how to do it? <br><br><h4>  First approach </h4><br>  You can wrap the loop and the type of address in the fixture.  Let's call it ctx (abbreviated from test context).  Due to the fixture parameters, it is easy to create a separate address for each type. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> tempfile <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> py <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Context</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, loop, addr)</span></span></span><span class="hljs-function">:</span></span> self.loop = loop self.addr = addr @pytest.fixture(params=[<span class="hljs-string"><span class="hljs-string">'tcp'</span></span>, <span class="hljs-string"><span class="hljs-string">'unix'</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ctx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request, event_loop, unused_tcp_port, short_tmpdir)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""   TCP     Unix."""</span></span> addr_type = request.param <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> addr_type == <span class="hljs-string"><span class="hljs-string">'tcp'</span></span>: addr = (<span class="hljs-string"><span class="hljs-string">'127.0.0.1'</span></span>, unused_tcp_port) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> addr_type == <span class="hljs-string"><span class="hljs-string">'unix'</span></span>: addr = short_tmpdir.join(<span class="hljs-string"><span class="hljs-string">'sock'</span></span>).strpath <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> RuntimeError(<span class="hljs-string"><span class="hljs-string">'Unknown addr type: %s'</span></span> % addr_type) ctx = Context(event_loop, addr) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ctx @pytest.yield_fixture() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">short_tmpdir</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""      Unix. ,   pytest' tmpdir,     """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> tempfile.TemporaryDirectory() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tdir: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> py.path.local(tdir)</code> </pre><br>  This allows you to write tests like this: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiomas @pytest.mark.asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_channel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx)</span></span></span><span class="hljs-function">:</span></span> results = [] <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_client</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(channel)</span></span></span><span class="hljs-function">:</span></span> req = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> channel.recv() results.append(req.content) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> req.reply(<span class="hljs-string"><span class="hljs-string">'cya'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> channel.close() server = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> aiomas.channel.start_server(ctx.addr, handle_client) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: channel = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> aiomas.channel.open_connection(ctx.addr) rep = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> channel.send(<span class="hljs-string"><span class="hljs-string">'ohai'</span></span>) results.append(rep) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> channel.close() <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: server.close() <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> server.wait_closed() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> results == [<span class="hljs-string"><span class="hljs-string">'ohai'</span></span>, <span class="hljs-string"><span class="hljs-string">'cya'</span></span>]</code> </pre><br>  It is already working well, and each test using fixture ctx, runs once for each type of address. <br><br>  However, two problems remain: <br><br><ol><li>  Fixture always requires an unused TCP port + temporary directory - despite the fact that we need only one of the two. </li><li>  Setting up a server (and closing it) includes a certain amount of code that will be identical for all tests, and therefore should be included in the fixture.  But it will not work directly, because each server needs a test-dependent callback (this can be seen in the line where we create the server server = await ...).  But without a server fixture, there is no teardown for it ... </li></ol><br>  Let's see how you can solve these problems. <br><br><h4>  Second approach </h4><br>  The first problem is solved by using the getfuncargvalue () method belonging to the request object, which our fixture receives.  This method can manually call its function: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@pytest.fixture(params=['tcp', 'unix']) def ctx(request, event_loop): """   TCP     Unix.""" addr_type = request.param if addr_type == 'tcp': port = request.getfuncargvalue('unused_tcp_port') addr = ('127.0.0.1', port) elif addr_type == 'unix': tmpdir = request.getfuncargvalue('short_tmpdir') addr = tmpdir.join('sock').strpath else: raise RuntimeError('Unknown addr type: %s' % addr_type) ctx = Context(event_loop, addr) return ctx</span></span></code> </pre><br>  To solve the second problem, you can extend the Context class, which is passed to each test.  Add the Context.start_server (client_handler) method, which can be called directly from the tests.  And also add the final teardown to our ctx fixture, which will close the server after the end.  In addition, you can create several functions for shortcuts. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> tempfile <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> py <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Context</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, loop, addr)</span></span></span><span class="hljs-function">:</span></span> self.loop = loop self.addr = addr self.server = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, **kwargs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""    "self.addr"."""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> aiomas.channel.open_connection( self.addr, loop=self.loop, **kwargs)) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start_server</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, handle_client, **kwargs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""    *handle_client*,  "self.addr"."""</span></span> self.server = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> aiomas.channel.start_server( self.addr, handle_client, loop=self.loop, **kwargs) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start_server_and_connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, handle_client, server_kwargs=None, client_kwargs=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" :: await ctx.start_server(...) channel = await ctx.connect()" """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> server_kwargs <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: server_kwargs = {} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> client_kwargs <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: client_kwargs = {} <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self.start_server(handle_client, **server_kwargs) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self.connect(**client_kwargs)) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close_server</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" ."""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.server <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: server, self.server = self.server, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> server.close() <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> server.wait_closed() @pytest.yield_fixture(params=[<span class="hljs-string"><span class="hljs-string">'tcp'</span></span>, <span class="hljs-string"><span class="hljs-string">'unix'</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ctx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request, event_loop)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""   TCP     Unix."""</span></span> addr_type = request.param <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> addr_type == <span class="hljs-string"><span class="hljs-string">'tcp'</span></span>: port = request.getfuncargvalue(<span class="hljs-string"><span class="hljs-string">'unused_tcp_port'</span></span>) addr = (<span class="hljs-string"><span class="hljs-string">'127.0.0.1'</span></span>, port) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> addr_type == <span class="hljs-string"><span class="hljs-string">'unix'</span></span>: tmpdir = request.getfuncargvalue(<span class="hljs-string"><span class="hljs-string">'short_tmpdir'</span></span>) addr = tmpdir.join(<span class="hljs-string"><span class="hljs-string">'sock'</span></span>).strpath <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> RuntimeError(<span class="hljs-string"><span class="hljs-string">'Unknown addr type: %s'</span></span> % addr_type) ctx = Context(event_loop, addr) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> ctx <span class="hljs-comment"><span class="hljs-comment">#        : aiomas.run(ctx.close_server()) aiomas.run(asyncio.gather(*asyncio.Task.all_tasks(event_loop), return_exceptions=True))</span></span></code> </pre><br>  The test case becomes noticeably shorter, easier to read and more reliable thanks to this additional functionality: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiomas @pytest.mark.asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_channel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx)</span></span></span><span class="hljs-function">:</span></span> results = [] <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_client</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(channel)</span></span></span><span class="hljs-function">:</span></span> req = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> channel.recv() results.append(req.content) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> req.reply(<span class="hljs-string"><span class="hljs-string">'cya'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> channel.close() channel = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ctx.start_server_and_connect(handle_client) rep = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> channel.send(<span class="hljs-string"><span class="hljs-string">'ohai'</span></span>) results.append(rep) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> channel.close() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> results == [<span class="hljs-string"><span class="hljs-string">'ohai'</span></span>, <span class="hljs-string"><span class="hljs-string">'cya'</span></span>]</code> </pre><br>  The ctx fixture (and Context class) is certainly not the shortest thing I ever wrote, but it helped rid my tests of about 200 lines of sample code. <br><br><h3>  The end </h3><br>  Elegant solutions and reliable code! </div><p>Source: <a href="https://habr.com/ru/post/337108/">https://habr.com/ru/post/337108/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337096/index.html">Sending an e-mail message in the 3CX Call Flow Designer development environment</a></li>
<li><a href="../337098/index.html">Creator of Node.js: ‚ÄúFor servers, I can‚Äôt imagine another language other than Go‚Äù</a></li>
<li><a href="../337100/index.html">Be careful with what you measure - MJIT vs TruffleRuby: 2.1 times slower or 4.2 times faster</a></li>
<li><a href="../337102/index.html">BFQ I / O scheduler better</a></li>
<li><a href="../337106/index.html">Meeting in St. Petersburg "The role of the analyst in making important product decisions"</a></li>
<li><a href="../337110/index.html">Getting rid of the RecyclerView.Adapter routine with DataBinding</a></li>
<li><a href="../337112/index.html">We broadcast WebRTC, RTSP and RTMP streams to Media Source Extensions via Websocket protocol</a></li>
<li><a href="../337114/index.html">We embed WebRTC player for live broadcasts from webcams and IP cameras</a></li>
<li><a href="../337116/index.html">Overview of all Chrome DevTools developer tools</a></li>
<li><a href="../337118/index.html">Avito Automation meetup - slides, video, reviews, photos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>