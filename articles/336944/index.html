<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Overview of one Russian RTOS, part 3. Structure of the simplest program</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I continue to publish a series of articles from the Book of Knowledge of the MAKS RTOS. This is an informal programmer‚Äôs guide for those who prefer a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Overview of one Russian RTOS, part 3. Structure of the simplest program</h1><div class="post__text post__text-html js-mediator-article">  I continue to publish a series of articles from the Book of Knowledge of the MAKS RTOS.  This is an informal programmer‚Äôs guide for those who prefer a living language to a dry language of documentation. <br><br>  In this part it is time to put the theory on the real code.  Let us consider how everything said earlier is written in C ++ (it is he who is the main one for developing programs for the MAKS RTOS).  Here we will talk only about the minimum necessary things, without which no program is possible. <br><br>  Content (published and unpublished articles): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="https://habrahabr.ru/post/336308/">Part 1. General information</a> <br>  <a href="https://habrahabr.ru/post/336696/">Part 2. Core MAX MAX</a> <br>  Part 3. The structure of the simplest program (this article) <br>  <a href="https://habrahabr.ru/post/337476/">Part 4. Useful theory</a> <br>  <a href="https://habrahabr.ru/post/337974/">Part 5. The first application</a> <br>  <a href="https://habrahabr.ru/post/338682/">Part 6. Thread synchronization tools</a> <br>  <a href="https://habrahabr.ru/post/339498/">Part 7. Means of data exchange between tasks</a> <br>  <a href="https://habrahabr.ru/post/340032/">Part 8. Work with interruptions</a> <br><br><h2>  Code </h2><br>  Since the RTOS MAX has an object-oriented model, the program must also contain classes.  In this case, the base classes are already included in the OS, the application programmer only has to create heirs from them and add the required functionality. <a name="habracut"></a><br><br>  To implement an application, you should make an inheritor from the Application class (be sure to overlap the virtual function Initialize () in it) and one or several heirs of the Task class (necessarily overlap in it the virtual function Execute ()).  And all this will be managed by the scheduler implemented in the Scheduler class. <br><br><img src="https://habrastorage.org/web/d1b/159/aee/d1b159aee9484680b519adfafc29d0f5.png" alt="image"><br><br>  <b>Fig.</b>  <b>1. Minimum classes required for work (gray - already available, white - should be added)</b> <br><br><h3>  Application class </h3><br>  At first glance, the class seems completely unnecessary layer.  It is necessary to override the Initialize () method, in which the application is initialized.  It is convenient to create tasks inside this function (although this is not a dogma, tasks can be created anywhere, just inside this function is most convenient). <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> VPortUSBApp::Initialize() { Task::Add(vport = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VPortUSBTask, Task::PriorityNormal, Task::ModeUnprivileged, <span class="hljs-number"><span class="hljs-number">400</span></span>); Task::Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HelloTask, Task::PriorityNormal, Task::ModeUnprivileged, <span class="hljs-number"><span class="hljs-number">400</span></span>); }</code> </pre> <br>  It would seem, why it is impossible to initialize the application in the function main (), and this class to throw out, as extra?  But let's not rush.  Firstly, this function is always called in the privileged mode, so it can be configured hardware, including programming NVIC, which can not be done in normal mode.  In addition, this class performs much more functions than just initializing an application. <br><br>  First of all, it is through the object of this class that the OS finds the application.  I wanted to write that ‚Äúit finds an application without global variables‚Äù, but if you go into the chicking, then the static variable member of the Application class <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Application * m_app;</code> </pre> <br>  still is global.  But how is it in the classics: "Samos is a son of a bitch, but this is our son of a bitch."  The variable is global, but it is well structured and belongs to the application class.  Accordingly, her name is isolated from all other classes.  There is a function to access it. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Application &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">App</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> * Application::m_app; }</code> </pre> <br>  which can be overridden to return not the original, but the inherited class type.  For example, one of the tests describes a class with the following overlap: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AlarmMngApp</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Application { ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> AlarmMngApp &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">App</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> * (AlarmMngApp *) m_app; }</code> </pre> <br>  Thus, this class contains the functionality by which the application can always find the thread pulling which it will come to the desired part.  This can be useful, for example, in interrupt handlers. <br><br>  The next obvious thing when using the Application class is its constructor.  In the constructor type of multitasking is transferred. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/// @brief   /// @param use_preemption   /// (true - , false - ). Application(bool use_preemption = true);</span></span></code> </pre><br>  The Application class contains the OnAlarm () virtual function.  It will be called to report exceptions.  Their list is quite large: <br><br><pre> <code class="cpp hljs">AR_NMI_RAISED, <span class="hljs-comment"><span class="hljs-comment">///&lt;    (Non Maskable Interrupt, NMI) AR_HARD_FAULT, ///&lt;   (  Hard Fault) AR_MEMORY_FAULT, ///&lt;      (MemManage interrupt) AR_NOT_IN_PRIVILEGED, ///&lt;        ...</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Expand</b> <div class="spoiler_text"><pre> <code class="cpp hljs">AR_NMI_RAISED, <span class="hljs-comment"><span class="hljs-comment">///&lt;    (Non Maskable Interrupt, NMI) AR_HARD_FAULT, ///&lt;   (  Hard Fault) AR_MEMORY_FAULT, ///&lt;      (MemManage interrupt) AR_NOT_IN_PRIVILEGED, ///&lt;         AR_BAD_SVC_NUMBER, ///&lt;    SVC     AR_COUNTER_OVERFLOW, ///&lt;    AR_STACK_CORRUPTED, ///&lt;       AR_STACK_OVERFLOW, ///&lt;     AR_STACK_UNDERFLOW, ///&lt;       AR_SCHED_NOT_ON_PAUSE, ///&lt;          AR_MEM_LOCKED, ///&lt;    AR_USER_REQUEST, ///&lt;   AR_ASSERT_FAILED, ///&lt;   ASSERT   AR_STACK_ENLARGED, ///&lt;       AR_OUT_OF_MEMORY, ///&lt;  ""  AR_SPRINTF_TRUNC, ///&lt;   sprintf   -     AR_DOUBLE_PRN_FMT, ///&lt;     PrnFmt       AR_NESTED_MUTEX_LOCK, ///&lt;            AR_OWNED_MUTEX_DESTR, ///&lt; ,    ,  AR_BLOCKING_MUTEX_DESTR, ///&lt; ,     ,  AR_NO_GRAPH_GUARD, ///&lt;       GraphGuard AR_UNKNOWN ///&lt;  </span></span></code> </pre><br></div></div><br>  Having blocked the function, it is possible to provide error handling (or emergency shutdown of the equipment so that it does not fail).  The following values ‚Äã‚Äãare defined for the result of the function: <br><br><pre> <code class="cpp hljs">AA_CONTINUE, <span class="hljs-comment"><span class="hljs-comment">///&lt;    AA_RESTART_TASK, ///&lt;     AA_KILL_TASK, ///&lt;    ,   AA_CRASH ///&lt;  </span></span></code> </pre><br>  Next, consider the <b>Run ()</b> method.  It should be called in order for the OS to start the application.  Actually, the typical function main () should look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"DefaultApp.h"</span></span></span><span class="hljs-meta"> int main() { MaksInit(); static DefaultApp app; app.Run(); return 0; }</span></span></code> </pre><br>  <font color="#cc0000"><b>The MAX RTOS supports only one application.</b></font>  <font color="#cc0000"><b>Therefore, you should declare only one instance of the class inherited from Application.</b></font> <br><br><h3>  Task class </h3><br>  Directly task code.  A class in its pure form is never used; for work, a successor from it should be created (or use ready-made successors, which will be discussed at the end of the section). <br><br><h4>  Execute () function </h4><br>  The most important function in the task is, of course, the virtual function Execute (). In a classic procedural-oriented OS, the programmer must implement the thread function and then pass it as an argument to the CreateThread () function.  With the object-oriented approach, the algorithm is simpler: <br><br><ol><li>  Create an inheritor from the Task class, </li><li>  The thread function will be named Execute ().  Enough to block it.  Nothing more is required. </li></ol><br>  Those who are used to working with classic OSs will notice that the Execute () function has no arguments, and it‚Äôs customary to pass a single argument to the streaming function.  Most often it is a pointer to a whole structure containing certain parameters.  The object-oriented approach eliminates all the difficulties associated with such a mechanism.  A class is designed for the task.  It can contain an unlimited (within system resources) number of member variables.  You can place completely arbitrary parameters in them by any available means, for example, make public variables and fill them until the class is executed, or pass the parameters to the constructor, and he will fill in the fields, or make functions that fill the parameters (make initialization function or setter functions). <br><br>  Thus, instead of a single pointer, which is processed strictly in the stream function, we get the broadest possibilities for initializing the data, separating them from the working code itself.  The Execute () function itself, respectively, was left without parameters. <br><br>  <font color="#cc0000"><b>So.</b></font>  <font color="#cc0000"><b>The first rule of development of any task class is to create a successor class from Task and block the Execute () function in it.</b></font> <br><br>  When exiting the Execute () function, the task is deleted from the scheduler, but not deleted from memory, since it can be on the heap as well as on the stack, and the delete statement applied to the stack object will cause an error.  Thus, deleting the object of the task at the end of working with it is an application programmer. <br><br><h4>  Class constructor </h4><br>  Now let's talk about the class constructor.  All constructors of the Task class are in the protected section, so they cannot be called directly.  To do this, in the heir class, implement its own constructor, which will call one or another constructor of the Task class. <br>  Examples of such heir constructors: <br><br> <code>class TaskYieldBeforeTestTask_1: public Task <br> { <br> public: <br> <font color="#ffffff">000000</font> explicit TaskYieldBeforeTestTask_1(): <br> <font color="#ffffff">000000</font> <font color="#ffffff">000000</font> <font color="#cc0000">Task()</font> <br> <font color="#ffffff">000000</font> { <br> <font color="#ffffff">000000</font> }</code> <br> <br>  The option is a bit more complicated: <br><br> <code><font color="#ffffff">000000</font> explicit MessageQueuePeekTestTask_1(const char* name): <br> <font color="#ffffff">000000</font> <font color="#ffffff">000000</font> <font color="#cc0000">Task(name)</font> <br> <font color="#ffffff">000000</font> { <br> <font color="#ffffff">000000</font> } <br></code> <br>  It is worth paying attention to such a parameter as ‚Äútask name‚Äù.  This parameter is optional, but sometimes very useful.  Moreover, there are two alternative methods for its storage.  The easiest method is to declare a constant in the file maksconfig.h <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAKS_TASK_NAME_LENGTH 0</span></span></code> </pre> <br>  and ignore the name (by default, nullptr pointer is used).  Very often this option is the most convenient. <br><br>  The second option: do not override the <b>MAKS_TASK_NAME_LENGTH</b> constant; in this case, when creating a task, memory for storing the name of the task will be allocated on the heap.  The name itself can be used, for example, to be recorded in the event log.  What threatens the use of dynamic memory - described in one of the following sections (although this does not apply to the case of adding tasks at the initialization stage). <br><br>  Finally, the third option: override the constant <b>MAKS_TASK_NAME_LENGTH with a</b> positive number.  In this case, the task name will be stored in a member variable of the Task class.  This saves you from working with a bunch, but if for the sake of one task about 20 characters are reserved, then all tasks will spend as much, even if their names are shorter.  For the "big" machines crazy statement, there developers think megabytes (having available gigabytes or even tens of gigabytes).  But for weak controllers saving every byte is still relevant. <br><br>  Now it's time to figure out what constructors are in the Task class.  There are only two of them.  The first is as follows: <br><br>  <b>Task (const char * name = nullptr)</b> <br><br>  The task created through this constructor will receive the stack allocated by the operating system from the heap. <br><br>  However, it is not always necessary to allocate the task stack from the main heap.  The fact is that the microcontroller can work with two or more physical RAM devices.  The simplest case is the internal static RAM of the controller for tens or hundreds of kilobytes and external dynamic RAM for units or tens of megabytes.  Internal RAM will run faster than external.  However, depending on the situation, the programmer can place the heap in the external or internal memory, because it is wonderful when the heap has a size of several megabytes!  The stack is best placed in the internal memory of the controller.  Accordingly, sometimes it is better not to trust the allocation on the heap, but specify the location of the task stack on your own, being sure that it is located in fast RAM.  And the designer of the second type will help in this: <br><br>  <b>Task (size_t stack_len, uint32_t * stack_mem, const char * name = nullptr)</b> <br><br>  According to his arguments, it is clear that in addition to the name of the task, it also passes a pointer to the RAM, where the task stack will be placed, and the stack size is clearly indicated in <u>32-bit words</u> <b>( <font color="#cc0000">not</font> in bytes)</b> <br><br>  Usage example: <br><br><pre> <code class="cpp hljs">Class MyTask : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Task { Private: <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> m_stack[<span class="hljs-number"><span class="hljs-number">100</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)]; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MyTask() : Task(m_stack) {} };</code> </pre><br>  It is quite simple to tell the compiler in which memory to place variables declared in a particular function, but the description of this will take several sheets, and it will greatly confuse the reader.  Therefore, we will bring this information to the level of a video lesson / webinar. <br><br>  <font color="#cc0000"><b>Thus, the second thing that should be implemented in the successor class from Task is the constructor.</b></font>  <font color="#cc0000"><b>You can even have a dummy constructor that simply calls the constructor of the ancestor class.</b></font> <br><br><h4>  Add () function </h4><br>  The minimum necessary part of the class code that implements the task is written.  You can add it to the scheduler.  For this, the Add () family of functions is used.  Consider them in more detail. <br><br>  Here is the option with the smallest number of arguments, where the programmer trusts the operating system to deal with all the parameters on his own: <br><br>  <b>static Result Add (Task * task, size_t stack_size = Task :: ENOUGH_STACK_SIZE)</b> <br><br>  Adds a task with the ability to specify the required stack size (in 32-bit words). <br><br>  Call example: <br><br><pre> <code class="cpp hljs">Task::Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MessageQueueDebugTestTask_1(<span class="hljs-string"><span class="hljs-string">"MessageQueueDebugTestTask_1"</span></span>));</code> </pre> <br>  If you need to explicitly set the task operation mode (privileged or non-privileged), you can use the following option of the Add function: <br><br>  <b>static Result Add (Task * task, Task :: Mode mode, size_t stack_size = Task :: ENOUGH_STACK_SIZE)</b> <br><br>  Call example: <br><br><pre> <code class="cpp hljs">Task::Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RF_SendTask, Task::ModePrivileged);</code> </pre> <br>  For example, another option with an explicit indication of the size of the stack: <br><br><pre> <code class="cpp hljs">Task::Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MutexIsLockedTestTask_1(<span class="hljs-string"><span class="hljs-string">"MutexIsLockedTestTask "</span></span>), Task::ModePrivileged, <span class="hljs-number"><span class="hljs-number">0x200</span></span>);</code> </pre> <br>  There is also the option of adding a task with priority: <br><br>  static Result Add (Task * task, Task :: Mode mode, Task :: Priority priority, size_t stack_size = Task :: ENOUGH_STACK_SIZE) <br><br>  Call example: <br><br><pre> <code class="cpp hljs">Task::Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventBasicTestManagementTask(), Task::PriorityRealtime);</code> </pre> <br>  The most complete option: and indicating the priority, and indicating the mode of operation: <br><br>  <b>static Result Add (Task * task, Task :: Priority priority, Task :: Mode mode, size_t stack_size = Task :: ENOUGH_STACK_SIZE);</b> <br><br>  Call example: <br><br><pre> <code class="cpp hljs">Task::Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NeigbourDetectionService(), Task::PriorityAboveNormal, Task::ModePrivileged);</code> </pre> <br>  Recall that the most convenient place to call the Add () function in a typical case is the Initialize () function of the task class. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RFApplication::Initialize() { button.rise(&amp;button_pressed); button.fall(&amp;button_released); Task::Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SenderTask(), Task::PriorityNormal, Task::ModePrivileged, <span class="hljs-number"><span class="hljs-number">0x100</span></span>); Task::Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReceiverTask(), Task::PriorityNormal, Task::ModePrivileged, <span class="hljs-number"><span class="hljs-number">0x100</span></span>); }</code> </pre><br>  However, this function can be called at any place in the code.  In the OS testing classes, you can find similar constructions: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> EventIntTestMain::RunStep(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> step_num) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> ( step_num ) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> : _ASSERT(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> : Task::Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventBasicTestManagementTask(), Task::PriorityRealtime); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> : Task::Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventUnblockOrderTestManagementTask(), Task::PriorityRealtime); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> : Task::Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventTypeTestManagementTask(), Task::PriorityRealtime); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> : Task::Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventProcessingTestManagementTask(), Task::PriorityRealtime); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre><br>  And they are quite acceptable. <br><br>  <font color="#cc0000"><b>Thus, after the class derived from the Task class is created, the constructor is redefined (you can use the dummy constructor, the calling constructor of the Task class) and the Execute function, this class should be connected to the scheduler using the Add () function.</b></font>  <font color="#cc0000"><b>If the scheduler is running, the task will start running.</b></font>  <font color="#cc0000"><b>Or it will start to be executed from the moment the scheduler starts.</b></font> <br><br><h4>  Functions that are conveniently called from the task class </h4><br>  There are a number of functions that the class derived from the Task class can call to ensure its own functioning within the OS.  Let us briefly review their list: <br><br><table><tbody><tr><td width="140">  Delay () </td><td>  Blocks a task for a specified time, specified in milliseconds. </td></tr><tr><td width="140">  CpuDelay () </td><td>  Performs a delay in milliseconds without blocking the task.  Accordingly, the control of other tasks for the delay time is not forcibly transferred (the task can be taken away control when switching on the system timer).  But with cooperative multitasking, only this function is possible. </td></tr><tr><td width="140">  Yield () </td><td>  Forcibly gives control to the scheduler so that he starts the next task.  With cooperative multitasking, task switching is performed by this very function.  With displacing, a function can be called if the task sees that it has nothing more to do and can give the rest of the time quantum to other tasks. </td></tr><tr><td width="140">  GetPriority () </td><td>  Returns the current priority of the task. </td></tr><tr><td width="140">  SetPriority () </td><td>  Sets the current priority of the task.  If a task lowers its priority, then with preemptive multitasking, it may well be pushed out without waiting for the completion of the time slice. </td></tr></tbody></table><br><h4>  Functions usually called externally </h4><br>  Some functions, on the contrary, are intended to be called from outside.  For example, a function that allows you to find out the status of the task: if the task calls it, it will always receive ‚ÄúActive‚Äù.  Finding the status of the task makes sense from somewhere outside.  Similarly, the other functions of this group. <br><br><table><tbody><tr><td width="140">  GetState () </td><td>  Returns the status of the task (active, blocked, etc. </td></tr><tr><td width="140">  GetName () </td><td>  Returns the name of the task. </td></tr><tr><td width="140">  Remove () </td><td>  Removes a task.  It can also be called from the task itself, then it will forcefully trigger a context switch.  The task object remains in memory. </td></tr><tr><td width="140">  Delete () </td><td>  Same as Remove (), but with the removal of the object.  Accordingly, the object must be created using the operator new, and not on the stack. </td></tr><tr><td width="140">  Getcurrent () </td><td>  Returns a pointer to the current task. </td></tr></tbody></table><br><br><h3>  Class Scheduler </h3><br>  Once this class is mentioned as a minimally necessary component, we will consider its interface functions, although it simply does its work hidden from the application programmer.  Nevertheless, it still contains some useful functions. <br><br><table><tbody><tr><td width="140">  GetInstance () </td><td>  A static function with which you can get a reference to the scheduler object in order to access it in the future. </td></tr><tr><td width="140">  GetTickCount () </td><td>  Returns the number of system ticks that have passed since the scheduler started. </td></tr><tr><td width="140">  Pause () </td><td>  Suspends switching tasks by the scheduler, or includes working again (a specific action is passed in the function argument). </td></tr><tr><td width="140">  Proceedirq </td><td>  The function will be discussed in the section on interrupts. </td></tr></tbody></table><br>  Ask questions and leave comments - this is what inspires writing and publishing articles. <br><br>  Here we will stop, as the big block of the useful theory <a href="https://habrahabr.ru/post/337476/">further</a> follows. </div><p>Source: <a href="https://habr.com/ru/post/336944/">https://habr.com/ru/post/336944/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336934/index.html">Immersion in pricing Magento 2, we remove pennies after discounts</a></li>
<li><a href="../336936/index.html">IoT and 5G</a></li>
<li><a href="../336938/index.html">As a star of Brazilian TV shows, she accidentally helped open an IT company in Russia</a></li>
<li><a href="../336940/index.html">Transition to date-oriented design</a></li>
<li><a href="../336942/index.html">Vertex Wireless VW210: a rare router and its inner world</a></li>
<li><a href="../336946/index.html">Simple models of economic dynamics in Python</a></li>
<li><a href="../336948/index.html">Deploy a .NET Core project to the Azure Web App for Linux</a></li>
<li><a href="../336950/index.html">The practice of forming requirements in IT projects from A to Z. Part 3. System Functions and Project Boundaries</a></li>
<li><a href="../336952/index.html">Lecture of Vitaly Kharisov "10k"</a></li>
<li><a href="../336954/index.html">Do not want to work after the holidays?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>