<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>User Timing API</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article was written on January 21, 2014 by a member of the HTML5Rocks project, Alex Danilo. I want to note that this is my first translation in H...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>User Timing API</h1><div class="post__text post__text-html js-mediator-article">  <i>This article was written on January 21, 2014 by a member of the <a href="http://www.html5rocks.com/en/">HTML5Rocks</a> project, Alex Danilo.</i>  <i>I want to note that this is my first translation in Habr√©, so I'm ready for the minuses, even more to criticism.</i>  <i>For all the problems and shortcomings try to write to me personally, I will promptly correct.</i>  <i><a href="http://www.html5rocks.com/en/tutorials/webperformance/usertiming/">Original in English</a> .</i> <br><br>  High-performance web applications are key to the end user.  As web applications become more and more complex, understanding performance management is a persuasive programming skill.  Over the past couple of years, a lot of new APIs have appeared in the browser that allow you to monitor network performance, download time, etc.  but none of them allows you to define quite flexibly and in detail what exactly ‚Äúslows down‚Äù your application.  That's what the <a href="http://www.w3.org/TR/user-timing/">User Timing API is for</a> , which provides a mechanism for your application to determine what and when it takes time. <br><a name="habracut"></a><br><br><h4>  You can not optimize that can not be measured </h4><br>  First of all, in speeding up a slow web application, we need to figure out the places that take the most time to complete.  Measuring the runtime of individual sections of Javascript code is an ideal way to identify hot spots.  This is the first step in finding ways to improve performance.  Fortunately, the <a href="http://www.w3.org/TR/user-timing/">User Timing API</a> provides a solution with which you can call the API at various places in your code to get detailed time data to help you optimize. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  High Resolution Time and now () method </h4><br>  The fundamental part of time measurement is accuracy.  Previously, we managed with a measurement error of 1 millisecond, but jank-free sites appeared, in which each frame should be drawn within 16 ms.  Therefore, for a good analysis of the millisecond error is not enough.  But now <a href="http://www.w3.org/TR/hr-time/">High Resolution Time has appeared</a> , a new type of synchronization built into modern browsers.  <a href="http://www.w3.org/TR/hr-time/">High Resolution Time</a> provides us with floating-point timestamps within microseconds, which is a thousand times better than it was before. <br><br>  To get the current time in the application, you must call the now () method, which is an extension of the Performance interface. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myTime = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.performance.now();</code> </pre> <br>  There is another interface called <a href="http://www.w3.org/TR/navigation-timing/">PerformanceTiming</a> , which provides a set of time points related to how a web application is loaded.  The now () method returns the time elapsed since the navigationStart of <a href="http://www.w3.org/TR/navigation-timing/">PerformanceTiming</a> . <br><br><h4>  Type DOMHighResTimeStamp </h4><br>  Previously, to get the current application time, we used the Date.now () function, which returned <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html">DOMTimeStamp</a> .  DOMTimeStamp returned an integer number of milliseconds.  To provide higher accuracy for <a href="http://www.w3.org/TR/hr-time/">High Resolution Time</a> , a new type called DOMHighResTimeStamp was introduced.  This type already has a floating point, although it also returns the time in milliseconds.  But, due to the non-integer value, time contains fractional milliseconds and gives an accuracy of up to one thousandth of a millisecond. <br><br><h4>  User Timing Interface </h4><br>  Since we now have high-precision time, we can start using User Timing to get time information. <br><br>  The User Timing interface provides us with functions that can be called in different places of the application to identify weaknesses. <br><br><h4>  Using mark () </h4><br>  This method is fundamental to our time analysis toolkit.  What does mark () do?  This method saves time for future use.  But the most useful thing about it is that we can give names to our marks.  In this case, the API saves the name-time relationship as a separate element. <br><br>  Using mark () in various places, you can determine how much time has passed between calls. <br><br>  The specification provided standard mark names that are fairly understandable, for example: 'mark_fully_loaded', 'mark_fully_visible', 'mark_above_the_fold', etc. <br><br>  For example, we could make a mark when the application is fully loaded: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.performance.mark(<span class="hljs-string"><span class="hljs-string">'mark_fully_loaded'</span></span>);</code> </pre><br>  By setting named tags across the entire application, we can collect a huge amount of data and analyze it at our leisure to figure out when and what to spend time on the application. <br><br><h4>  Measurements and measure () method </h4><br>  After you set the timestamps, you need to calculate the time between them.  This is what the measure () method is for.  It defines the time that occurred between the marks.  It can also determine the time between a user mark and one of the standard ones listed in the <a href="http://www.w3.org/TR/navigation-timing/">Performance Timing</a> interface.  For example, to calculate the time from the moment the DOM is loaded until the application is fully loaded, the following code is used: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.performance.measure(<span class="hljs-string"><span class="hljs-string">'measure_load_from_dom'</span></span>, <span class="hljs-string"><span class="hljs-string">'domComplete'</span></span>, <span class="hljs-string"><span class="hljs-string">'mark_fully_loaded'</span></span>);</code> </pre><br>  Note: in this example we are passing the reserved name 'domComplete' from the <a href="http://www.w3.org/TR/navigation-timing/">Performance Timing</a> interface. <br><br>  When the measure () method is called, it saves the result regardless of the labels, so you can get this value later.  By keeping separate data about the time when the application is running, it remains responsive and efficient, and you can upload data for analysis after the application does some work. <br><br><h4>  Reset marks with clearMarks () </h4><br>  Sometimes it is useful to get rid of a heap of saved marks.  For example, you can run an application from the command line, so it will be logical to reset all accumulated marks before launch. <br><br>  It's easy enough to get rid of the set marks by calling clearMarks (). <br><br>  Thus, the following code example will reset all existing marks, so that you can re-configure this if you want. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.performance.clearMarks();</code> </pre><br>  Of course, there are some situations in which you would not want to clear all the marks.  If you want to delete specific, then you can just pass the name of the mark to be deleted.  For example, as follows: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.peformance.clearMarks(<span class="hljs-string"><span class="hljs-string">'mark_fully_loaded'</span></span>);</code> </pre><br>  This code gets rid of the mark saved above.  But all the other marks will not disappear anywhere. <br><br>  You may also want to delete the measurements you made.  For this there is a corresponding method clearMeasures ().  It works just like clearMarks ().  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.performance.clearMeasures(<span class="hljs-string"><span class="hljs-string">'measure_load_from_dom'</span></span>);</code> </pre><br>  will delete the dimension that we saved in the example above.  To delete all dimensions, you must call the same method with no arguments, as in clearMarks (). <br><br><h4>  Saving time data </h4><br>  It's all good to set marks and measure time, but at some point you will want to get this data for analysis.  And it's also very simple, all you need is to use the <a href="http://www.w3.org/TR/performance-timeline/">PerformanceTimeline</a> interface. <br><br>  For example, the getEntriesByType () method allows us to get all the marks or all of our measurements in the form of a list so that we can go through it and process the data.  What is convenient is that the list is returned in chronological order, and you can follow the marks as they are called in the application. <br><br>  The following code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.performance.getEntriesByType(<span class="hljs-string"><span class="hljs-string">'mark'</span></span>);</code> </pre><br>  returns all the marks that were marked in the application, while this code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.performance.getEntriesByType(<span class="hljs-string"><span class="hljs-string">'measure'</span></span>);</code> </pre><br>  returns all measurements that were taken. <br><br>  You can also get a list of records by the name you assigned to them: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.performance.getEntriesByName(<span class="hljs-string"><span class="hljs-string">'mark_fully_loaded'</span></span>);</code> </pre><br>  returns a list with one element containing the timestamp 'mark_fully_loaded' in the <a href="http://www.w3.org/TR/performance-timeline/">startTime</a> property. <br><br><h4>  XHR Request Time Calculation Example </h4><br>  Now that we have a complete picture of the User Timing API, let's determine how long all our XHR requests are executed in the application. <br><br>  First, we need to change all send () requests to set marks in them, as well as change our callback functions that will set other marks.  And also measure the time between them to determine the duration of the request. <br><br>  Usually, a simple XHR request looks like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myReq = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); myReq.open(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, url, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); myReq.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ do_something(e.responseText); } myReq.send();</code> </pre><br>  For example, we will add a global counter to keep track of the number of queries and also to use it in saving measurements for each query.  The code for this will look like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> reqCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myReq = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); myReq.open(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, url, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); myReq.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.performance.mark(<span class="hljs-string"><span class="hljs-string">'mark_end_xhr'</span></span>); reqCnt++; <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.performance.measure(<span class="hljs-string"><span class="hljs-string">'measure_xhr_'</span></span> + reqCnt, <span class="hljs-string"><span class="hljs-string">'mark_start_xhr'</span></span>, <span class="hljs-string"><span class="hljs-string">'mark_end_xhr'</span></span>); do_something(e.responseText); } <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.performance.mark(<span class="hljs-string"><span class="hljs-string">'mark_start_xhr'</span></span>); myReq.send();</code> </pre><br>  This code generates a dimension with a unique name for each XHR request that we send.  We assume that all requests are executed sequentially, for parallel requests the code needs to be slightly modified.  Therefore, we leave it as a home exercise for readers. <br><br>  After the web application has made many requests, we can output data to the console with the following code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.performance.getEntriesByType(<span class="hljs-string"><span class="hljs-string">'measure'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; items.length(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> req = items[i]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'XHR '</span></span> + req.name + <span class="hljs-string"><span class="hljs-string">' took '</span></span> + req.duration + <span class="hljs-string"><span class="hljs-string">'ms'</span></span>); }</code> </pre><br><h4>  Conclusion </h4><br>  The User Timing API gives you many great tools, ready to use in different parts of your application.  Reducing the number of weak points can be easily achieved by placing API calls throughout the application, and post-analyzing the data.  But what if your browser doesn't support this API?  No problem, you can find a <a href="https://gist.github.com/pmeenan/5902672">great polyfill here</a> that emulates the API really well and <a href="http://www.webpagetest.org/">doesn't load the</a> system.  What are you waiting for?  Try the User Timing API in your applications now to speed them up and users will appreciate it. </div><p>Source: <a href="https://habr.com/ru/post/210748/">https://habr.com/ru/post/210748/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../210738/index.html">Facebook will create an energy-efficient data storage of 10,000 Blu-ray discs</a></li>
<li><a href="../210740/index.html">Analysis of popular game addiction theories</a></li>
<li><a href="../210742/index.html">How does chromecast work?</a></li>
<li><a href="../210744/index.html">Secure backup using public services</a></li>
<li><a href="../210746/index.html">Unification of associative STL-containers by a template parameter - comparator</a></li>
<li><a href="../210750/index.html">2.4GHz USB "whistle" with your own hands</a></li>
<li><a href="../210754/index.html">We pump Google Tasks using a third-party service: repetitive tasks, sharing, notifications about deadlines and other features</a></li>
<li><a href="../210760/index.html">How to hash passwords and how not to</a></li>
<li><a href="../210762/index.html">As we were in Canadian accelerators filed and interviews were held</a></li>
<li><a href="../210764/index.html">Phpbrew PHP Version Manager. (+ install and use in Ubuntu 13.10)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>