<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cooking rutracker for spring and kotlin</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In anticipation of the first release of the kotlin language, I would like to share with you the experience of creating a small project on it. This wil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cooking rutracker for spring and kotlin</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/ea2/0a4/eaa/ea20a4eaae8e41f39ea7cf168d19d709.png" alt="tutracker, kotlin, spring boot"><br><br>  In anticipation of the first release of the kotlin language, I would like to share with you the experience of creating a small project on it.  This will be a service application to search for torrents in the rutracker database.  All code + bonus browser client can be found <a href="https://github.com/fogone/rutracker-spring-kotlin-rest">here</a> .  So, let's see what happened. <a name="habracut"></a><br><br><h2>  Task </h2><br>  <a href="http://rutracker.org/forum/viewtopic.php%3Ft%3D4824458">The torrent database</a> is distributed as a set of csv files and is periodically updated by adding a new version of the entire database dump to the directory with the name corresponding to the date of the dump.  In this regard, our small project will monitor the emergence of new versions (already downloaded, and the client, who will download the database himself, we may do another time), disassemble, add to the database and provide json rest api for searching by name. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Facilities </h2><br>  For a quick start, take the spring boot.  Spring boot has many features that can seriously complicate life in large projects, but for small applications like ours, boot is an excellent solution for creating a configuration for a typical set of technologies.  The main way for a boot-up to understand for which technologies it is to create bins is the presence in the classpath of key classes for a given technology.  We add them via connection dependencies to maven.  In our case, boot will automatically configure us to connect to the base (h2) + pool (tomcat-jdbc) and the json (gson) provider.  When connecting dependencies, we do not specify the versions of the libraries, we take a set from the pre-defined boot-ohm - for this we specify the parent project spring-boot-starter-parent in the mavena.  We also connect spring-boot-starter-web and spring-boot-starter-tomcat so that boot will configure us web mvc for our future rest and tomcat as a container.  Now let's look at the main. <br><pre><code class="hljs pgsql">// main.kt fun main(args: <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>&lt;String&gt;) { SpringApplication .run(MainConfiguration::<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.java, *args) }</code> </pre> <br>  And to the main configuration of MainConfiguration, which we pass to SpringApplication as the source for the beans. <br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@Import(JdbcRepositoriesConfiguration::class, ImportConfiguration::class, RestConfiguration::class)</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableAutoConfiguration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainConfiguration</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SpringBootServletInitializer</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(builder: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SpringApplicationBuilder</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: SpringApplicationBuilder { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> builder.sources(MainConfiguration::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) } }</span></span></code> </pre><br>  It should be noted that the boot allows you to deploy the resulting application as a web module, and not just run through the main method.  In order for this approach to work, we override the configure method of the SpringBootServletInitializer, which will be called by the container when the application is deployed.  Also, note that we do not use the @SpringBootApplication annotation on MainConfiguration, but we enable autoconfiguration directly with the @EnableAutoConfiguration annotation.  I did this in order not to use the search for components annotated with @Component ‚Äî all the bins that we will create will be explicitly created by kotlin configurations.  It is also worth noting a feature of kotlin configurations - we have to mark configuration classes as open (as well as methods that create bins), because in kotlin all classes and methods are by default final, which will not allow spring to be created for them wrapper. <br><br><h2>  Model </h2><br>  The model of our application is very simple and consists of two entities.  This is the category to which the torrent belongs (it has a parent field, but in fact the torrent is always in a category with only one parent), and the torrent itself. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Category</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id:<span class="hljs-built_in"><span class="hljs-built_in">Long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name:String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parent:Category?) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Torrent</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id:<span class="hljs-built_in"><span class="hljs-built_in">Long</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> categoryId:<span class="hljs-built_in"><span class="hljs-built_in">Long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hash:String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name:String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size:<span class="hljs-built_in"><span class="hljs-built_in">Long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> created:Date)</code> </pre><br><br>  Our model classes, I described simply as immutable data classes.  This project does not use jpa for ethical reasons and as a consequence of the principle of Occam's razor.  In addition, the orm would require the use of extra technology and an obvious sinking of performance.  For mapping data from a database to objects, I will simply use jdbc and jdbctemplate, as a tool sufficient for our task. <br><br>  So, we have defined our model, in which, besides quite ordinary fields, attention should be paid to the hash field, which is actually an identifier of a torrent in the world of communication between torrent clients and which is enough to find (for example, through dht) happy owners distributing this torrent and get the missing information from them (like file names), which distinguishes the torrent file from the magnet link. <br><br><h2>  Repositories </h2><br>  For data access, we use a small abstraction that will allow us to separate the data storage from its consumer.  For example, due to the specifics of the data, we could easily use storage and parsing of the csv-database at the start, also this abstraction would be suitable for those who especially keenly want to use jpa, which we talked about a little higher.  So, for each entity we create our own repository, plus one repository to access the current version of the database. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CategoryRepository</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>:<span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Category? <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>:<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">batcher</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(size:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>:Batcher&lt;Category&gt; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TorrentRepository</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>:List&lt;Torrent&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">batcher</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(size:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>:Batcher&lt;Torrent&gt; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VersionRepository</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCurrentVersion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>:<span class="hljs-built_in"><span class="hljs-built_in">Long</span></span>? <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateCurrentVersion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(version:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> }</code> </pre><br>  I would like to remind you if someone has forgotten or did not know that the question after the type name means that there may be no meaning, i.e.  it may be null.  If there is no question, then most often the attempt to push through null fails at the compilation stage.  From the lyrical digression go to our <s>ram</s> interfaces.  Interfaces are specially made minimalist, so as not to distract from the main thing.  And in general, their meaning is clear, except for the batchers of the first two.  Again, because of the specifics, we need to write a lot of data once, and then they do not change.  Because of this, there is only one method to change, which provides the ability to batch add.  Let's take a closer look at it. <br><br><h3>  Batcher </h3><br>  A very simple interface that allows you to add entities of a specific type: <br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Batcher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Closeable { fun add</span></span></span></span>(value:T) }</code> </pre><br>  Also, Batcher is inherited from Closable, so that you can send the started incomplete pack for adding when there is no more data in the source.  They work according to the following logic: when creating a batcher, the pack size is specified, adding an entity accumulates in the buffer until the pack grows to the specified size, then a group add operation is performed, which is generally faster than a set of single additions.  Moreover, the Batcher categories will have the functionality of adding only unique values, for torrents, a simple implementation using JdbcTemplate.updateBatch ().  There is no perfect size for a pack, so I made these parameters in the application configuration (see application.yaml) <br><br><h3>  clear () </h3><br>  When I talked about a single method that modifies data, I was a little impulsive, because all repositories have a clear () method that simply deletes all old data before processing the new version of the dump.  In fact, we use truncate table ..., because delete from ... without where, works much slower, and for our situation the action is similar, if the base does not support the truncate operation, you can simply re-create the table, which is also much faster in speed than delete all rows. <br><br><h3>  Reading interface </h3><br>  There will be only the necessary methods, such as search () for torrents, which we will use to search, or findById () from categories to collect a full result when searching.  we only need count () to log the data we need, it is not needed for the case.  The jdbc implementation simply uses the JdbcTemplate for fetching and mapping, for example: <br><pre> <code class="hljs kotlin"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rowMapper = RowMapper { rs: ResultSet, rowNum: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> -&gt; Torrent( rs.getLong(<span class="hljs-string"><span class="hljs-string">"id"</span></span>), rs.getLong(<span class="hljs-string"><span class="hljs-string">"category_id"</span></span>), rs.getString(<span class="hljs-string"><span class="hljs-string">"hash"</span></span>), rs.getString(<span class="hljs-string"><span class="hljs-string">"name"</span></span>), rs.getLong(<span class="hljs-string"><span class="hljs-string">"size"</span></span>), rs.getDate(<span class="hljs-string"><span class="hljs-string">"created"</span></span>) ) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: List&lt;Torrent&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(name.isEmpty()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> emptyList() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parts = name.split(<span class="hljs-string"><span class="hljs-string">" "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> whereSql = parts.map { <span class="hljs-string"><span class="hljs-string">"UPPER(name) like UPPER(?)"</span></span> }.joinToString(<span class="hljs-string"><span class="hljs-string">" AND "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parameters = parts.map { it.trim() }.map { <span class="hljs-string"><span class="hljs-string">"%</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$it</span></span></span><span class="hljs-string">%"</span></span> }.toTypedArray() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jdbcTemplate.query(<span class="hljs-string"><span class="hljs-string">"SELECT id, category_id, hash, name, size, created FROM torrent WHERE </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$whereSql</span></span></span><span class="hljs-string">"</span></span>, rowMapper, *parameters) }</code> </pre><br>  In such a simple way we implement a search that finds a name containing all the words of the query.  We do not use the limit on the number of records given at once, like splitting into pages, which would certainly be worth doing in a real project, but for our small experiment, we can do without it.  I think here it is worth noting that such a decision on the forehead would require a complete crawl of the table each time to find all the results, which may be too much for a relatively small base of rutracker, but of course it would not be suitable for public production.  To speed up the search, you need an additional solution in the form of an index, maybe a native full-text search or a third-party solution like <a href="https://lucene.apache.org/">apache lucene</a> , <a href="https://www.elastic.co/products/elasticsearch">elasticsearch</a> or many others.  The creation of such an index, of course, will increase both the time to create the base and its size.  But in our application, we will focus on a simple sample with a detour, since our system is rather an educational one. <br><br><h2>  Import </h2><br>  Most of our system is importing data from csv files into our storage.  There are several aspects to which it would be worth paying attention.  First of all, our initial base, although not very large, is nevertheless already of such a property, when it is necessary to carefully treat its size - i.e.  you need to think about how to reduce data transfer time, probably copying data to the forehead may be long.  And second, the csv-base is denormalized, and we want to get the division into categories and torrents.  So, we need to decide how we will make this separation. <br><br><h3>  Performance </h3><br>  Let's start with reading.  In my implementation, a self-written csv parser on kotlin is used, taken from my other project, which is slightly faster and a little more attentive to the type of exceptions that are made than the existing open source market, but in fact does not change the order of parsing speed, i.e.  it would be possible with the same success to take almost any parser that can work in a stream, for example, <a href="https://commons.apache.org/proper/commons-csv/">commons-csv</a> . <br><br>  Now record.  As we have seen before, I added the batchers to reduce the overhead of adding a large number of entries.  For categories, the problem is not so much in quantity, but in the fact that they are repeated many times.  A number of tests have shown that it is faster to check availability before adding to a pack than to create huge packs from queries of type MERGE INTO.  This is understandable, given that the first step is to check the existing bundle directly in the memory, then a special batcher appeared that checks the uniqueness. <br><br>  And of course, it was worth thinking about parallelizing this process.  Making sure that different files contain data independent of each other, I selected each such file as an object of work for a worker working in his own stream. <br><br><pre> <code class="hljs kotlin"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">importCategoriesAndTorrents</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(directory:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Path</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = withExecutor { executor -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> topCategories = importTopCategories(directory) executor .invokeAll(topCategories.map { createImportFileWorker(directory, it) }) .map { it.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createImportFileWorker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(directory: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Path</span></span></span></span><span class="hljs-function"><span class="hljs-params">, topCategory: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CategoryAndFile</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>:Callable&lt;<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt; = Callable { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> categoryBatcher = categoryRepository.batcher(importProperties.categoryBatchSize) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> torrentBatcher = torrentRepository.batcher(importProperties.torrentBatchSize) (categoryBatcher and torrentBatcher).use { parser(directory, topCategory.file).use { it .map { createCategoryAndTorrent(topCategory.category, it) } .forEach { categoryBatcher.add(it.category) torrentBatcher.add(it.torrent) } } } }</code> </pre><br>  For such work, a pool with a fixed number of threads is well suited.  We give the executor all the tasks at once, but at the same time it will perform as many tasks as there are threads in the pool, and in the performance of one task the flow will be given to another.  The required number of threads can not be guessed, but you can choose experimentally.  By default, the number of threads equals the number of cores, which is often not the worst strategy.  Since we only need the pool at the time of import, we create it, work it out and close it.  To do this, we do a small utility inline-function withExecutor (), which we have already used above: <br><br><pre> <code class="hljs kotlin"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withExecutor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block:(</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ExecutorService</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>-&gt;R):R { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> executor = createExecutor() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> block(executor) } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { executor.shutdown() } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createExecutor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ExecutorService = Executors.newFixedThreadPool(importProperties.threads)</code> </pre><br>  Inline-function is good because it exists only at compilation and helps to streamline the code, put it in order and reuse functions with lambda parameters, while not having any overhead.  After all, the code that we write in such a function will be embedded by the compiler at the place of use.  This is convenient, for example, in cases when we need to close something in the finally block, and we do not want this to distract from the general logic of the program. <br><br><h3>  Separation </h3><br>  After making sure that entities could not depend on each other during the import, I decided to collect all entities (categories and torrents) in one pass, having previously created only top-level categories (at the same time having received information about files with torrents), selecting them for the parallelization unit . <br><br><h2>  Rest </h2><br>  Now we have almost everything to add a controller for retrieving torrent search data in the form of json.  At the exit, I would like to have grouped torrents.  We define a special bin that defines the appropriate structure of the response: <br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> class </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CategoryAndTorrents</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">category</span></span></span><span class="hljs-class">:</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Category</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">torrents</span></span></span><span class="hljs-class">:</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Torrent</span></span></span><span class="hljs-class">&gt;)</span></span></code> </pre><br>  Done, it remains only to request the torrets, group and sort them: <br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@RequestMapping(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/api/torrents"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TorrentsController</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> torrentRepository: TorrentRepository, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> categoryRepository: CategoryRepository) { <span class="hljs-meta"><span class="hljs-meta">@ResponseBody</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequestMapping(method = arrayOf(RequestMethod.GET)</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestParam</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>:List&lt;CategoryAndTorrents&gt; = torrentRepository .search(name) .asSequence() .groupBy { it.categoryId } .map { CategoryAndTorrents(categoryRepository.findById(it.key)!!, it.value.sortedBy { it.name }) } .sortedBy { it.category.name } .toList() }</code> </pre><br>  By annotating the @RequestParam parameter with the name parameter, we expect that the spring will write the value of the ‚Äúname‚Äù request parameter in the parameter of our function.  Having marked the method with the @ResponseBody annotation, we ask the spring to convert the bean returned from the method to json. <br><br><h3>  A bit about DI </h3><br>  Also in the previous code, you can see that the repositories come to the controller in the constructor.  The rest of this application is done in the same way: the bins themselves created by the spring do not know about di, but accept all their dependencies in the constructor, even without any annotations.  The real connection occurs at the level of the spring configuration: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RestConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">torrentsController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(torrentRepository: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TorrentRepository</span></span></span></span><span class="hljs-function"><span class="hljs-params">, categoryRepository: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CategoryRepository</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>:TorrentsController = TorrentsController(torrentRepository, categoryRepository) }</code> </pre><br>  Spring transfers the dependencies created by a different configuration to the parameters of the method that creates the controller ‚Äî the dependencies are passed to the controller. <br><br><h2>  Total </h2><br>  Done!  We start, check (as part of the address <a href="http://localhost/">localhost</a> : 8080 / there is a javascript client for our service, the description of which is beyond the scope of this article) - it works!  On my machine, the import takes about 80 seconds, quite well.  And the search request takes another 5 seconds - not so good, but it also works. <br><br><h3>  About goals </h3><br>  When I was a novice programmer, I really wanted to find out how other more experienced developers write programs, how they think and reason, I wanted them to share their experience.  In this article I wanted to show how I argued while working on this task, to show some real solutions to some completely mundane and not-so-difficult problems, the use of technologies and their aspects that I had to face.  Perhaps even someone wants to make a more successful implementation of the repositories, or even the whole task, and talk about it.  Or just offer it in the comments, all of this, we only increase our knowledge and experience. </div><p>Source: <a href="https://habr.com/ru/post/274713/">https://habr.com/ru/post/274713/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274697/index.html">Results of the contest on programming on JS: Mail filters</a></li>
<li><a href="../274703/index.html">Security Week 01: Javascript Ransommer, $ 100k for a bug in Adobe Flash, an encrypted bright future</a></li>
<li><a href="../274705/index.html">Spark local mode: handling large files on a regular laptop</a></li>
<li><a href="../274707/index.html">The total capacity of LeaseWeb networks reached 5 Tbit / s: instant dedicated servers in the Netherlands from $ 39 only a week</a></li>
<li><a href="../274709/index.html">Trouble for server farms from Vodafone and Interxion</a></li>
<li><a href="../274717/index.html">Gospel Information Architecture Site</a></li>
<li><a href="../274719/index.html">Parametric design. Next half step after Design in browser</a></li>
<li><a href="../274721/index.html">BEM obsession. Consequence of parametric design</a></li>
<li><a href="../274723/index.html">[Translation] Associative arrays in the D language</a></li>
<li><a href="../274725/index.html">Setting the problem of computer vision</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>