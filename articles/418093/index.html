<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MIT course "Computer Systems Security". Lecture 3: "Buffer overflow: exploits and protection", part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Lecture course # 6.858. "Security of computer systems". Nikolai Zeldovich, James Mykens. year 2014 
 Computer S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MIT course "Computer Systems Security". Lecture 3: "Buffer overflow: exploits and protection", part 2</h1><div class="post__text post__text-html js-mediator-article"><h3>  Massachusetts Institute of Technology.  Lecture course # 6.858.  "Security of computer systems".  Nikolai Zeldovich, James Mykens.  year 2014 </h3><br>  Computer Systems Security is a course on the development and implementation of secure computer systems.  Lectures cover threat models, attacks that compromise security, and security methods based on the latest scientific work.  Topics include operating system (OS) security, capabilities, information flow control, language security, network protocols, hardware protection and security in web applications. <br><br>  Lecture 1: "Introduction: threat models" <a href="https://habr.com/company/ua-hosting/blog/354874/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/354894/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/354896/">Part 3</a> <br>  Lecture 2: "Control of hacker attacks" <a href="https://habr.com/company/ua-hosting/blog/414505/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/416047/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/416727/">Part 3</a> <br>  Lecture 3: "Buffer overflow: exploits and protection" <a href="https://habr.com/company/ua-hosting/blog/416839/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418093/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418099/">Part 3</a> <a name="habracut"></a><br><br>  It is interesting that the attacker can not jump to a specific address, despite the fact that we mainly use hard-coded addresses.  What he does is called ‚Äúheap attack‚Äù, and if you are a bad person, then it will be quite fun for you.  With such an attack, the hacker begins to dynamically allocate tons of shell code and simply enter it randomly into memory.  This is especially effective if you use dynamically high-level languages ‚Äã‚Äãsuch as JavaScript.  Thus, the tag reader is in a narrow loop and simply generates a large number of lines of shell code and then fills them with a bunch. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The attacker cannot determine the exact location of the lines, he simply allocates 10 MB of lines of shell code and makes a random jump.  And if he can somehow control one of the <b>ret</b> pointers, there is a possibility that he will "land" in the shell code. <br><br><img src="https://habrastorage.org/webt/jl/7-/8x/jl7-8xckq3eq6z_wf2_m2alslzg.jpeg"><br><br>  You can use one trick called <b>NOP slide</b> , <b>NOP sled</b> or <b>NOP ramp</b> , where <b>NOP</b> is <b>no-operation instructions</b> , or empty, idle commands.  This means that the processor's instruction flow ‚Äúslips‚Äù to its final, desired destination whenever the program goes to the memory address anywhere on the slide. <br><br>  Imagine that if you have a line of shell code and you move to a random place in this line, it may not work, because it does not allow you to deploy the attack in the right way. <br><br>  But maybe this stuff you put on the pile is basically just a ton of <b>NOP</b> , and at the very end you have the shell code.  This is actually quite clever, because it means that now you can actually get to the right place to jump.  Because if you jump into another of these <b>NOPs</b> , it‚Äôs just ‚Äúboom, boom, boom, boom, boom, boom, boom‚Äù, and then you get into the shell code. <br><br>  It seems that this is coming up with the people you probably see in our team.  They invent something like that, and that's the problem.  So this is another way to get around some random things, just making the randomization of your codes sustainable, if that makes sense. <br><br>  So, we have discussed some types of accidents that you can use.  There are some stupid ideas that people also had.  So now you know that when you want to make a system call, for example, you use the <b>syscall libc</b> function, you basically pass on any unique number representing the system call you want to make.  So maybe the <b>fork</b> function is 7, <b>sleep</b> is 8, or something like that. <br><br>  This means that if an attacker can figure out the address of this <b>syscall</b> instruction and go to him in some way, he or she can actually just substitute the number of the system call that they want to use directly.  You can imagine that every time the program is running, you actually create a dynamic assignment of <b>syscall</b> numbers <b>to</b> actual <b>syscalls</b> , in order to make it more difficult for an attacker to capture. <br><br><img src="https://habrastorage.org/webt/nq/l6/ob/nql6obzl82-6vvdgdkt6iuhzs8g.jpeg"><br><br>  There are even some avant-garde offers to change the hardware so that the equipment contains the <b>xor</b> encryption key, which is used for the dynamic functions <b>xor</b> .  Imagine that every time you compile a program, all instruction codes get a certain key <b>xor</b> .  This key is stored in the hardware register when you initially load the program, and after that, whenever you execute an instruction, the equipment automatically performs an <b>xor</b> operation with it, before continuing with this instruction.  In this approach, it is good that now, even if the attacker can generate shell code, he does not recognize this key.  So it will be very difficult for him to figure out exactly what needs to be put into memory. <br><br>  <b>Audience:</b> but if he can get the code, he can also use <b>xor</b> to turn the code back into instruction. <br><br>  <b>Professor:</b> yes, that is the canonical problem, right.  This is somewhat similar to what happens during the <b>BROP</b> attacks, when we seem to have randomized the location of the code, but the attacker can ‚Äúfind‚Äù him and find out what is happening.  One can imagine that, for example, if an attacker knows some sub-sequence of code that he expects to find in a binary file, then he will try to use the <b>xor</b> operation for this file in order to extract the key. <br><br>  In essence, we discussed all types of randomization attacks that I wanted to tell you about today.  Before we proceed to programming, it is worth discussing the question of which of these methods of protection are used in practice.  It turns out that both <b>GCC</b> and Visual Studio by default include the <b>stack canaries</b> approach.  This is a very popular and very famous community.  If you look at Linux and Windows, they also use such things as memory non-executable and address space randomization.  True, the <b>baggy bounds</b> system is not so popular with them, probably because of the cost of memory, processor, false alarms, and so on, which we have already spoken about.  So basically, we examined how things are going with preventing the buffer overflow problem. <br><br>  Now we will talk about <b>ROP</b> , backward-oriented programming.  Today I have already told you that it is in terms of randomizing the address space and preventing data from being executed - it is read, write and execute.  In fact, these are very powerful things.  Because randomization prevents the possibility that the attacker will understand where our hard-coded addresses are located.  And the ability to prevent data from being executed ensures that even if you put the shell code on the stack, the attacker will not be able to just jump to it and execute it. <br><br>  All this looks quite progressive, but hackers are constantly developing methods of attacks against such progressive defense solutions. <br><br>  So what is the essence of reverse-oriented programming? <br><br>  What if, instead of just creating a new code during an attack, an attacker could merge the existing pieces of code together and then merge them together in an abnormal order?  After all, we know that the program contains tons of such code. <br><br><img src="https://habrastorage.org/webt/fd/76/08/fd7608uferkfub0zyknpa6w1vfk.jpeg"><br><br>  So, fortunately, or unfortunately, it all depends on which side you are on.  If you can find enough interesting code snippets and merge them together, then you can get something like the <b>Turing</b> language, where the attacker can essentially do whatever he wants. <br><br>  Let's look at a very simple example, which at first will seem familiar to you, but then quickly turn into something crazy. <br><br>  Suppose we have the following program.  So, let us have some kind of function and, which is convenient for an attacker, there is this nice feature of the <b>run shell</b> .  So this is just a call to the system, it will execute the <b>bin / bash</b> command and this will end.  Next we have a canonical buffer overflow process, or, sorry, a function that will announce the creation of a buffer, and then use one of these unsafe functions to fill the buffer with bytes. <br><br><img src="https://habrastorage.org/webt/7r/os/et/7rosetpoais8blpdvc_-7mfkg7u.jpeg"><br><br>  So, we know that there is a buffer overflow without any problems.  But the interesting thing is that we have this <b>run shell</b> function, but it is difficult to get to it using methods based on buffer overflow.  So how can an attacker invoke this <b>run shell</b> command? <br><br>  First of all, an attacker can disassemble a program, run <b>GDB</b> , and find out the address of this item in the executable file.  You are probably familiar with these methods from lab work.  Then, during a buffer overflow, an attacker can take this address, place it in the generated buffer overflow, and make sure that the function returns to the <b>run shell</b> . <br><br>  To be clear, I'll draw it.  So, you have a stack that looks like this: below there is an overflowed buffer, above it is a saved break pointer, above it is the return address for <b>prosess_msg</b> .  From the bottom left we have a new stack pointer, which initiates the execution of the function, above it a new break pointer, then the stack pointer to be used, and even higher is the break pointer of the previous frame.  It all looks pretty familiar. <br><br><img src="https://habrastorage.org/webt/qf/ee/vg/qfeevg9_wr3ctwybpgx8acjcpeq.jpeg"><br><br>  As I said before, <b>GDB was</b> used during the attack to find out what the address of the <b>run shell was</b> .  Thus, in case of a buffer overflow, we can simply put the address of the <b>run shell</b> right here, to the right.  In fact, this is a fairly simple extension of what we already know how to do.  In essence, this means that if we have a command that starts the shell, and if we can disassemble the binary file to find out where this address is, we can simply place it in this flooded array located at the bottom of the stack.  It is quite simple. <br><br>  So, this was an extremely frivolous example, because the programmer, for some crazy reason, put this function here, thus presenting the attacker with a real gift. <br>  Now suppose that instead of calling this thing <b>run_shell</b> , we will call it <b>run_boring</b> , and then it will simply execute the <b>/ bin / ls command</b> .  However, we did not lose anything, because at the top we will have the string <b>char * bash_path</b> , which will show us the path to this <b>bin / bash</b> . <br><br><img src="https://habrastorage.org/webt/1d/u1/a2/1du1a2wtfwbzgtyul4bknzikpti.jpeg"><br><br>  So the most interesting thing about this is that an attacker who wants to run <b>ls</b> can ‚Äúparse‚Äù the program and find the location of <b>run_boring</b> , and this is not at all fun.  But in fact, we have a line in memory that indicates the path of the shell, in addition, we know something else interesting.  This is the fact that even if the program does not call the system with the argument <b>/ bin / ls</b> , it still makes some kind of call. <br><br>  So, we know that the system should be somehow connected with this program - <b>system (‚Äú/ bin / ls‚Äù)</b> .  Therefore, we can use these two <b>void</b> operations to actually associate the system with this argument <b>char * bash_path</b> .  The first thing we do is go to <b>GDB</b> and find out where this <b>system (‚Äú/ bin / ls‚Äù)</b> is in the image of the binary process.  So, you just go to <b>GDB</b> , just type <b>print_system</b> and get information about its offset.  It's pretty simple, and you can do the same for <b>bash_path</b> .  So you simply use <b>GDB</b> to find out where this thing lives. <br><br>  Once you are done, you need to do something else.  Because now we really have to somehow figure out how to call the system using the argument we chose.  And the way we do this is essentially to falsify the calling frame for the system.  If you remember, a frame is something that both the compiler and hardware use to implement the stack call. <br><br>  We want to organize in the stack something like what I depicted in this drawing.  In fact, we're going to fake a system that should have been on the stack, but right before it actually executes its code. <br><br>  So, here we have the system argument, this is the string we want to execute.  At the bottom we have a line where the system should return to when the mentioned line with the argument is executed.  The system expects the stack to look just like that just before the execution begins. <br><br><img src="https://habrastorage.org/webt/7r/ik/vp/7rikvpe59gsq0xdlubuhbew1juu.jpeg"><br><br>  We used to assume that there are no arguments when you pass a function, but now it looks a little different.  We just have to make sure the <b>argument</b> is in the overflow code that we create.  We just have to make sure that this fake <b>calling frame</b> is in this array.  Thus, our work will be as follows.  Recall that the stack overflow goes from bottom to top. <br><br><img src="https://habrastorage.org/webt/kh/by/g7/khbyg7us4ir4ydv6ossc2-bbnd0.jpeg"><br><br>  First, we are going to put the system address here.  And on top we will post some <b>reject return address junk return address</b> .  This is the place where the system will return after it is finished.  This address will be a random set of bytes.  Above it, we place the address <b>bash_path</b> .  What happens when the buffer overflows now? <br><br>  After <b>prosess_msg</b> reaches the finish line, he will say: ‚ÄúOK, here is the place where I should return‚Äù!  The system code continues to execute, it moves higher and sees the fake call frame we created.  For the system, nothing amazing will happen, she will say: ‚ÄúYeah, here it is, the argument I want to perform is <b>bin / bash</b> ‚Äù, it executes it, and the attacker has captured the shell! <br><br>  What have we done now?  We have used the knowledge of the calling agreement, the <b>calling convention</b> , as a platform for creating fake stack frames, or fake frame names, I would say.  Using this fake <b>calling frame</b> , we can perform any function that is referenced and which is already defined by the application. <br><br>  The next question we have to ask is: what if the program does not have this line <b>char * bash_path at all</b> ?  I note that this line is almost always present in the program.  However, suppose that we live in an inverted world, and it is still not there.  So what could we do to put this line into a program? <br><br>  The first thing to do is to specify the correct address for <b>bash_path</b> , placing it higher, in this compartment of our stack, inserting three elements, each of which is 4 bytes in size: <br><br>  <b>/ 0</b> <b><br></b>  <b>/ pat</b> <b><br></b>  <b>/ bin</b> <br><br><img src="https://habrastorage.org/webt/7y/ko/bo/7ykobou1yi5jzfppu2w0ok6b0zs.jpeg"><br><br>  But in any case, our pointer comes here and - boom!  - It is done.  So you can now invoke the arguments by simply placing them in the shell code.  Awful, isn't it?  And all this is built up before the full <b>BROP</b> attack.  But before you point out a full <b>BROP</b> attack, you need to understand how you simply hook together things that already exist inside the code.  When I place this waste return address here, we just want to access the shell.  But if you are an attacker, you could send this return address, or return address, to something that could really be used.  And if you did this, you could string several functions in a row in a row, several features of the function in a row.  This is really a very powerful option. <br><br>  Because if we just set the return address for the jump, then after that the program usually crashes, which we maybe don‚Äôt want.  Therefore it is worth linking together some of these things in order to do more interesting things with the program. <br><br>  Suppose our goal is that we want to call the system an arbitrary number of times.  We don't just want to do it once, we will do it any number of times.  So how can this be done? <br><br>  For this, we use two pieces of information that we already know how to get.  We know how to get the address of the system - you just need to look at <b>GDB</b> and find it there.  We also know how to find the address of this line, <b>bin / bash</b> .  Now, in order to initiate this attack using several calls to the system, we need to use gadgets.  This brings us closer to what is happening in <b>BROP</b> . <br><br>  So what we need now is to find the address of these two code operations: <b>pop% eax</b> and <b>ret</b> .  The first removes the top of the stack and places it in the <b>eax</b> register, and the second places it in the <b>eip</b> instruction <b>pointer</b> .  This is what we call a gadget.  It looks like a small set of assembly instructions that an attacker can use to build more ambitious attacks. <br><br><img src="https://habrastorage.org/webt/r4/nw/c6/r4nwc61pbprp8gv2gof8kxdj0uw.jpeg"><br><br>  Such gadgets are standard tools that hackers use to find things like binary files.  It‚Äôs also easy to find one of these gadgets, assuming you have a copy of the binary, and we didn‚Äôt bother with randomization.  These things are very easy to find, as well as very easy to find the address of the system and so on. <br><br>  So, if we have one of these gadgets, why can we use it?  Of course, to cause evil!  To do this, you can do the following. <br><br>  Suppose we change our stack so that it will look like this, the exploit, as before, is directed from the bottom up.  The first thing we do is locate the system address here, and above it put the address of the gadget <b>pop / ret</b> .  Even higher, we‚Äôll put the <b>bash_path</b> address, and then we‚Äôll repeat: we‚Äôll put the system‚Äôs address, the <b>pop / ret</b> gadget‚Äôs address, and the <b>bash_path</b> address <b>again</b> . <br><br><img src="https://habrastorage.org/webt/f6/ti/zh/f6tizhirkpxkzrwjeavzjc6uulc.jpeg"><br><br>  What will happen here now?  It will be a little difficult, so the notes of this lecture are available on the Internet, but for now you can just listen to what is happening here, but when I first understood this, it was like understanding that Santa Claus does not exist! <br><br>  We will start this place where the entry is located, go back to the system, where the <b>ret</b> instruction is going to remove the item from the stack with the <b>pop</b> command, so now the top of the stack pointer is here.  So, we remove the element with <b>pop</b> , then <b>ret</b> returns the <b>ret</b> procedure, which transfers control to the return address selected from the stack, and this return address is placed there with the <b>call</b> command.  So, we again make a call to the system, and this process can be repeated again and again. <br><br><img src="https://habrastorage.org/webt/js/mz/oz/jsmzoz4p8_mrqlskie75rmdgcnu.jpeg"><br><br>  It is clear that we can link this sequence to perform an arbitrary number of things.  In essence, the kernel gets what is called reverse-oriented programming.  Notice that we didn‚Äôt do anything in this stack.  We did what allowed us to prevent the execution of the data without destroying anything.  We just made some sort of unexpected jumps to do what we want.  In fact, it is very, very, very, smart. <br><br>  And what is interesting is that at a high level we have defined this new model for calculations.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In a traditional, non-malicious program, you have an instruction pointer that points to some linear sequence of instructions. </font><font style="vertical-align: inherit;">And you increase the instruction pointer to figure out what should be done next. </font><font style="vertical-align: inherit;">Essentially, reverse-oriented programming uses the stack pointer as an instruction pointer. </font><font style="vertical-align: inherit;">When we move the stack pointer, we point it to other blocks of code that we are going to execute. </font><font style="vertical-align: inherit;">But then at the end of the gadget, we return again to the stack pointer, which shows the next block of code to execute. </font><font style="vertical-align: inherit;">This way you can prevent things that are undesirable for us. </font><font style="vertical-align: inherit;">This shows how to get around this non-executable bit on the pages. </font><font style="vertical-align: inherit;">So the next thing we want to do may be a victory over </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stack canaries.</font></font></b> <br><br>   ,  ¬´¬ª  ,      .  ,  ,  ¬´¬ª    <b>ret address</b>   <b>saved %ebp</b> ,    -   ,   ¬´¬ª.  ,        <b>ret</b> ,   ,       ¬´¬ª,  ,    - .    <b>stack canaries</b> . <br><br>  ,    ¬´¬ª.         ,   . ,     ¬´¬ª? <br><br> ,    ,  ,      . <br> ,   ,  ,   ¬´¬ª  ,    ¬´¬ª  ¬´¬ª. <br><br>  ,    ,  ,    ¬´¬ª     ,   ,    . <br>   ,    -  ,     ¬´¬ª         ,         .    ,   ?           ? <br>   ,       <b>fork</b>    .   , <b>fork</b>     .    ,   ,    ,      <b>fork</b> ,      ,  ,       ,       ¬´¬ª   .     ,       <b>stack canaries</b> . <br><br>       ¬´¬ª?      .  ,    ,     ,   ¬´¬ª.  ¬´¬ª    .                . <br><br><img src="https://habrastorage.org/webt/ql/h1/ol/qlh1olpcbsug9nbtozpjevlll7u.jpeg"><br><br> ,    ,     ‚Äì    ,      ¬´¬ª.         , ,      0.    ,  ¬´¬ª,      .    ,  : <br><br> ¬´,      ¬´¬ª!     ,      0.  ¬´¬ª!  1 ‚Äì  ¬´¬ª,  2 ‚Äì   . ,    2- .  ,     ,  ¬´¬ª. <br><br><img src="https://habrastorage.org/webt/tx/xp/rc/txxprcve2i3lgkwslbdrluiv-sk.jpeg"><br><br>    ,   ,      ,     . <br><br>      ¬´¬ª,   ,    ,     .     ,          ,      ¬´¬ª. <br><br> 57:10  <br><br>  Continued: <br><br>  <a href="https://habr.com/company/ua-hosting/blog/416047/">MIT course "Computer Systems Security".</a> <a href="https://habr.com/company/ua-hosting/blog/416047/"> 3: ¬´ :   ¬ª,  3</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xSQxaie_h1o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Full version of the course is available <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-858-computer-systems-security-fall-2014/">here</a> . <br><br>  Thank you for staying with us.  Do you like our articles?  Want to see more interesting materials?  Support us by placing an order or recommending to friends, <b>30% discount for Habr users on a unique analogue of the entry-level servers that we invented for you:</b> <a href="https://habr.com/company/ua-hosting/blog/347386/">The whole truth about VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps from $ 20 or how to share the server?</a>  (Options are available with RAID1 and RAID10, up to 24 cores and up to 40GB DDR4). <br><br>  <b>Dell R730xd 2 times cheaper?</b>  Only we have <b><a href="https://ua-hosting.company/serversnl">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV from $ 249</a> in the Netherlands and the USA!</b>  Read about <a href="https://habr.com/company/ua-hosting/blog/329618/">How to build an infrastructure building.</a>  <a href="https://habr.com/company/ua-hosting/blog/329618/">class c using servers Dell R730xd E5-2650 v4 worth 9000 euros for a penny?</a> </div><p>Source: <a href="https://habr.com/ru/post/418093/">https://habr.com/ru/post/418093/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418083/index.html">Simple server with GraphQL instead of REST, java implementation</a></li>
<li><a href="../418085/index.html">Use of promises in javascript</a></li>
<li><a href="../418087/index.html">80% of self-checkout counters are at risk</a></li>
<li><a href="../418089/index.html">Overview of SolidCraft CNC Milling Machines</a></li>
<li><a href="../418091/index.html">List of articles and literature about NAS</a></li>
<li><a href="../418095/index.html">About the device built-in testing functionality in Rust (translation)</a></li>
<li><a href="../418099/index.html">MIT course "Computer Systems Security". Lecture 3: "Buffer overflow: exploits and protection", part 3</a></li>
<li><a href="../418101/index.html">Etymology of IT terms</a></li>
<li><a href="../418103/index.html">The head of Roscosmos remembered his first rocket and shared his plans for the future</a></li>
<li><a href="../418105/index.html">Why opening YouTube in Firefox or Edge can take 5 times longer than Google Chrome</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>