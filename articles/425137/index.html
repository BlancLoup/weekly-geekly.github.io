<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We work in the console quickly and efficiently</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the network you can find a lot of tips on how to work effectively in the console. In most of these articles, the authors talk about the banality of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We work in the console quickly and efficiently</h1><div class="post__text post__text-html js-mediator-article"><p> In the network you can find a lot of tips on how to work effectively in the console.  In most of these articles, the authors talk about the banality of the type "learn hot keys" or " <code>sudo !!</code> run the last command under sudo".  I will tell you what to do when you have already learned the hot keys and know about <code>sudo !!</code>  . </p><a name="habracut"></a><br><h3 id="terminal-dolzhen-zapuskatsya-mgnovenno">  The terminal should start instantly. </h3><br><p>  How much time do you need to start the terminal?  And one more?  For a long time, my terminal was launched using the Ctrl + Alt + T combination and I thought it was fast.  But when I moved from Openbox to i3, I started to run the terminal through Win + Enter, this combination was in the default config.  And you know what?  I no longer believe that Ctrl + Alt + T is fast. </p><br><p>  Of course, the joke is not in winnings of milliseconds, but in the fact that you open the terminal at the level of reflexes, completely ignoring this. </p><br><p>  If you often work in the terminal, but to launch it, reach for the mouse, then try setting up a convenient hot key.  I am sure you will like it. </p><br><h3 id="zsh-vmesto-bash">  Zsh instead of bash </h3><br><p>  This is a holivar topic, I know.  Zsh should be set up for at least three features: advanced autocomplete, typo correction, and multiple pathname completition: when a Tab turns <code>/u/s/d</code> into <code>/usr/share/doc</code> .  Arch Linux has long been migrated to zsh on its installation disc.  I hope that one day zsh will become the default shell in Ubuntu.  It will be a historic moment. </p><br><p>  Starting to use zsh is generally not difficult.  Install it through the package manager and take some ready-made config.  I recommend the config used in Arch Linux: </p><br><pre> <code class="plaintext hljs">wget -O ~/.zshrc https://git.grml.org/f/grml-etc-core/etc/zsh/zshrc</code> </pre> <br><p>  It remains only to change the default shell on zsh and relogin. </p><br><pre> <code class="plaintext hljs">chsh -s $(which zsh)</code> </pre> <br><p>  Everything, continue to work as if nothing happened. </p><br><h3 id="kakim-dolzhen-byt-shell-prompt">  What should be the shell prompt </h3><br><p>  Shell prompt (command line prompt) - this is the little text that is displayed in the terminal in front of your command.  It needs to be customized to your character work.  Think of it as a car dashboard.  Put there useful information, let it help you navigate.  Make it comfortable, especially if you see it every day! </p><br><p>  Shell prompt should display the current shell directory.  If the current directory is not displayed in the shell prompt, you will have to keep it in your head and periodically check with the command <code>pwd</code> .  Do not do it this way.  Keep more important things in your head and do not waste time on the <code>pwd</code> . </p><br><p>  If you periodically switch from your user to root, you need an indication of the current user.  Often it is important not a specific user name, but its status (normal or root).  The easiest way to do this is with color: a red shell prompt at the root, green in its user.  So you would not confuse the ruety shell with the usual one. </p><br><p>  If you connect to servers via ssh, then you need to somehow distinguish your local shell from the server shell.  For this, the shell prompt should contain the host name, and even better - the ssh connection indicator. </p><br><p>  Shell prompt can show the return code of the last command.  Let me remind you that the zero return code means that the command completed successfully, non-zero - the command ended unsuccessfully.  The return code of the last command can be found with the <code>echo $?</code> command <code>echo $?</code>  , but typing it all on the keyboard is too long.  Let the shell prompt be better if the command failed. </p><br><p>  If you are working with git-repositories, it will be useful to display the status of the repository in the shell prompt: the current branch and the status of the working directory.  So you will save time on the <code>git status</code> and <code>git branch</code> commands and can‚Äôt go wrong with the commit branch. </p><br><p>  Someone adds a clock or virtual terminal name (tty), or some arbitrary squiggles to their shell prompt.  This is all superfluous.  It is better to leave more space for teams. </p><br><p>  My shell prompt under different conditions looks like this: </p><br><p><img src="https://habrastorage.org/webt/ka/q3/gf/kaq3gfz9idb6pkxdglx44qyuxlq.png"></p><br><p>  The screenshot shows that the title bar of the terminal window performs a similar task.  This is also a dashboard piece and can also be customized. </p><br><p>  How to implement all this in your <code>.zshrc</code> ?  The <code>PROMPT</code> variable is responsible for the left prompt, <code>RPROMPT</code> is for the right <code>RPROMPT</code> .  The <code>EUID</code> variable will help determine the status of a user (normal or <code>EUID</code> , and the presence of an ssh connection can be <code>SSH_CLIENT</code> or <code>SSH2_CLIENT</code> .  We get this workpiece: </p><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ -n <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$SSH_CLIENT</span></span></span><span class="hljs-string">"</span></span> || -n <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$SSH2_CLIENT</span></span></span><span class="hljs-string">"</span></span> ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$EUID</span></span> == 0 ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> PROMPT=... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> PROMPT=... <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment"># not SSH if [[ $EUID == 0 ]]; then PROMPT=... else PROMPT=... fi fi</span></span></code> </pre> <br><p>  I deliberately do not indicate the code ready for copy-paste, because the concrete implementation is a matter of taste.  If you do not want to bother and my screenshot does not cause you disgust, you can take the config from the <a href="">githaba</a> . </p><br><p>  Summary: </p><br><ul><li>  The required minimum is the current directory. </li><li>  Route shell should be clearly visible. </li><li>  The username does not carry a payload if you always sit under one user. </li><li>  Hostname is useful if you connect to servers over SSH.  Not required if you always work on the same machine. </li><li>  Unsuccessful completion of the last command is useful to see immediately. </li><li>  The status of the git repository saves time on the <code>git status</code> and <code>git branch</code> commands and is an additional protection against a fool. </li></ul><br><h3 id="aktivnoe-ispolzovanie-istorii-komand">  Active use of command history </h3><br><p>  You enter most of the commands in your life more than once, which means it would be convenient to pull them out of history instead of typing again.  All modern shells can memorize command history and provide several ways to search through this history. </p><br><p>  Perhaps you already know how to delve into the history of the combination of Ctrl + R.  He has two significant drawbacks: </p><br><ol><li>  To start a search, the input field must be empty.  Those.  in the case of "I started typing a command - I remembered about the search" I‚Äôd have to erase what I‚Äôve started, press Ctrl + R and repeat the input.  It is too long. </li><li>  Search "forward" by default does not work, t. To.  Ctrl + S stops the terminal. </li></ol><br><p>  How the fastest and most convenient search works: </p><br><ol><li>  you start typing a command, </li><li>  you remember the search, </li><li>  you press the hotkey and the shell offers commands from the history that started in the same way. </li></ol><br><p>  For example, you want to synchronize a local directory with a remote one using <code>rsync</code> .  You already did this a couple of hours ago and want to get the team out of the story.  You type <code>rsync</code> , press a combination once or twice, and now the cherished team is ready to launch.  You do not need to first enable the history search mode, the shell prompt does not change to <code>(reverse-i-search)':</code> nothing jumps anywhere.  You just go through the commands from the story.  Just as with the arrows ‚Üë ‚Üì, you go through the previously entered commands, only with a filter at the beginning of the command.  It is damn convenient and saves a lot of time. </p><br><p>  In fish and ipython shells such a search is already assigned to arrows.  I think that many people switched to fish just for the sake of this behavior of arrows. </p><br><p>  In bash and zsh, by default, this search does not work, it must be turned on by hand.  I configured PgUp to search backwards and PgDown to search forward.  Far to reach them, but I'm used to it.  Perhaps in the future I will reassign to something closer, for example, Ctrl + P and Ctrl + N. </p><br><p>  For bash, add a couple of lines to <code>/etc/inputrc</code> or <code>~/.inputrc</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-string"><span class="hljs-string">"\e[5~"</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-backward <span class="hljs-string"><span class="hljs-string">"\e[6~"</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-forward</code> </pre> <br><p>  If you took a ready <code>zshrc</code> , then there the search is most likely already assigned to PgUp and PgDown.  If not, add to <code>~/.zshrc</code> </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">bindkey</span></span> <span class="hljs-string"><span class="hljs-string">"^[[5~"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-beginning-search-backward <span class="hljs-comment"><span class="hljs-comment"># pg up bindkey "^[[6~" history-beginning-search-forward # pg down</span></span></code> </pre> <br><p>  Curiously, over time, I began to write commands at the rate that I would later raise them from history.  Here are a few tricks: </p><br><p>  <strong>Combining commands that</strong> are always executed one after another </p><br><pre> <code class="plaintext hljs">ip link set eth1 up &amp;&amp; dhclient eth1 mkdir /tmp/t &amp;&amp; mount /dev/sdb1 /tmp/t</code> </pre> <br><p>  <strong>Absolute paths instead of relative ones</strong> allow you to run the command from any directory: <br>  <code>vim ~/.ssh/config</code> instead of <code>vim .ssh/config</code> , <code>systemd-nspawn /home/chroot/stretch</code> instead of <code>systemd-nspawn stretch</code> , etc. </p><br><p>  <strong>Wildcard substitution</strong> makes teams more versatile.  I usually use it with <code>chmod</code> and <code>chown</code> . </p><br><pre> <code class="plaintext hljs">chown root:root /var/www/*.sq &amp;&amp; chmod 644 /var/www/*.sq</code> </pre> <br><h3 id="goryachie-klavishi">  Hotkeys </h3><br><p>  I will list the required minimum. </p><br><p>  Alt +.  - substitutes the last argument of the previous command.  You can also type a sequence <code>!$</code> . <br>  Ctrl + A, Ctrl + E - go to the beginning and end of the edited command, respectively. <br>  Ctrl + U, Ctrl + Y - cut everything to the clipboard, paste from the buffer.  Rescues when you type a complex command, and then you realize that you have to execute another one in front of it.  Hmmm, where would you hide the current input?  Here and hide. <br>  Ctrl + W - erases one word to the left of the cursor.  If you hold and hold, quickly clears the command line.  By default, the text is not deleted, but placed in the buffer (which for Ctrl + Y). <br>  Ctrl + K - deletes from the cursor to the end of the line.  Ctrl + A, Ctrl + K quickly clears the command line. <br>  PgUp, PgDown, Ctrl + R - search by history. <br>  Ctrl + L - clear the terminal. </p><br><h3 id="otzyvchivost-klaviatury">  Keyboard responsiveness </h3><br><p>  I'll tell you about a small setting that allows you to scroll faster, move through the text or erase.  What do we do when we want to erase something long?  Hold Backspace and watch the cursor run backward, taking away the extra letters.  What happens when this happens?  When you press Backspace, one character is erased, then there is a slight delay, then auto-repeat is triggered: Backspace removes the characters one by one, as if they are constantly knocking on it. </p><br><p>  I recommend adjusting the delay and frequency of auto-repeat to the speed of your fingers.  The delay before the auto-repeat is triggered is needed when you want to delete only one character - it gives you time to release the key.  Too long delay makes auto-wait waiting.  Not long enough to annoy, but enough to slow down the transfer of thoughts from the head to the computer.  The higher the repetition rate, the faster the text is erased, and the more difficult it is to stop this process in time.  The essence of the setting is to find the golden mean. </p><br><p>  So, the magic command: </p><br><pre> <code class="plaintext hljs">xset r rate 190 20</code> </pre> <br><p>  190 - delay duration in milliseconds, <br>  20 - frequency in number of repetitions per second. </p><br><p>  I recommend starting with these values ‚Äã‚Äãand gradually reducing the delay until the occurrence of false positives, then slightly back.  If you set a very short delay, then the keyboard will become impossible to use.  You have to restart the X server or the entire computer.  So be careful. </p><br><p>  To save the settings, add this command somewhere in the X autostart. </p><br><h3 id="indikator-zaversheniya-processa">  Process completion indicator </h3><br><p>  I often have to run long processes: some fat backup, copying over the network, unpacking / packing archives, building packages, etc.  Usually, I start such a process, switch to another task and periodically glance whether my long process has completed.  It happens that I greatly immerse myself in work and forget about it.  The solution is to add a process completion notification that will lead me out of a trance. </p><br><p>  You can use different tools for this: notify-send, dzen2, beep, aplay.  All of them are good in their own way, but do not work on ssh.  Therefore, I use the terminal beep: </p><br><pre> <code class="plaintext hljs">long-running-command; echo $'\a'</code> </pre> <br><p>  In ASCII, there is a 0x7 character called <a href="https://en.wikipedia.org/wiki/Bell_character">bell</a> .  It is designed to beep PC-speaker.  The PC speaker is incompatible, it is not everywhere, and yet it is not audible in headphones.  Therefore, some terminals use the so-called visual bell.  I use urxvt, and it does the visual bell by turning on the urgency flag.  This is when the window informs you that it needs attention. </p><br><p>  You can check right now how your terminal responds to the bell symbol: </p><br><pre> <code class="plaintext hljs">sleep 3; echo $'\a'</code> </pre> <br><p>  Three seconds is given so that you can switch to another window, otherwise it may not work. </p><br><p>  Unfortunately, visual bell through urgency is not in all terminals.  I checked the most popular. </p><br><table><thead><tr><th>  terminal </th><th>  visual bell via urgency </th></tr></thead><tbody><tr><td>  konsole </td><td>  included in the settings </td></tr><tr><td>  urxvt </td><td>  there is </td></tr><tr><td>  xfce4-terminal </td><td>  included in the settings </td></tr><tr><td>  xterm </td><td>  not </td></tr><tr><td>  cool retro term </td><td>  not </td></tr><tr><td>  lxterminal </td><td>  not </td></tr><tr><td>  gnome-terminal </td><td>  not </td></tr></tbody></table><br><p>  Writing <code>echo $'\a'</code> too long, so I did an alias <code>wake</code> . </p><br><h3 id="aliasy">  Aliases </h3><br><p>  The <code>cp</code> , <code>scp</code> and <code>rm</code> commands must always work recursively.  The argument <code>-r</code> is just a bad legacy!  With <code>cp</code> , you can still find an excuse: </p><br><pre> <code class="plaintext hljs">cp * foodir</code> </pre> <br><p>  will copy only files to foodir, and with the <code>-r</code> switch it will think that you have decided to copy foodir into yourself.  But how often do you need this feature? </p><br><p>  <code>rm</code> and <code>scp</code> have no excuses at all, they are just boring!  The situation is similar with the <code>-p</code> of the <code>mkdir</code> command.  So feel free to add to <code>~/.zshrc</code> </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> cp=<span class="hljs-string"><span class="hljs-string">'cp -r'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> scp=<span class="hljs-string"><span class="hljs-string">'scp -r'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> rm=<span class="hljs-string"><span class="hljs-string">'rm -r'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> mkdir=<span class="hljs-string"><span class="hljs-string">'mkdir -p'</span></span></code> </pre> <br><p>  Wow, how I used to live without it!  You can go even further and add <code>-f</code> to <code>rm</code> , but at your own peril and risk.  I'm still holding back. </p><br><p>  You probably already use different variations of <code>ls</code> , because these are the most popular aliases. </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> ls=<span class="hljs-string"><span class="hljs-string">'ls -F --color=auto'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> la=<span class="hljs-string"><span class="hljs-string">'ls -A --color=auto'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> ll=<span class="hljs-string"><span class="hljs-string">'ls -l --color=auto -h'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> lla=<span class="hljs-string"><span class="hljs-string">'ll -A --color=auto -h'</span></span></code> </pre> <br><p>  Well, color grep is much more pleasant than colorless: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> grep=<span class="hljs-string"><span class="hljs-string">'grep --colour=auto'</span></span></code> </pre> <br><p>  Do not forget that aliases do not work in scripts!  There you must specify all the keys. </p><br><h3 id="slepoy-metod-pechati">  Blind printing method </h3><br><p>  No matter how trite it may be, but the blind ten-finger print method allows you to print faster.  It will be hard at first, but over time you will accelerate to unprecedented speeds. </p><br><p>  To master the blind printing method is best on vacation or on vacation, when no one is rushing you.  In the process of learning in no case be in a hurry.  Your task is to <em>remember</em> where the letter is located.  And not so much the brain as the muscles.  It is better to type slowly, but without errors, than quickly with errors.  Remember: the masters achieve high speeds not at the expense of fast fingers, but because they do not make mistakes. </p><br><p>  You should not at first get involved in clavogonki.  Psychologically difficult to stay cool during the competition.  Learn on simulators.  Well, when the simulator offers words that can be mentally uttered.  I studied on online simulators <a href="https://vse10.ru/">vse10</a> and <a href="https://www.typingstudy.com/ru/">typingstudy</a> .  The famous simulator "Solo on the keyboard" seemed to me stupid. </p><br><p>  It is worth starting with the central row of "fyvaprolge".  Only after you remember where the key is located, it is worth moving on.  Only after that. </p><br><p>  Take breaks.  Let's rest your mind and fingers.  You feel that mistakes have come down - it's time to take a break. </p><br><p>  At first, I mastered the blind method of printing in Russian and decided on acceleration.  Now I improve the skill in the English layout. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/425137/">https://habr.com/ru/post/425137/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425125/index.html">Selection @pythonetc, September 2018</a></li>
<li><a href="../425129/index.html">How to automate the creation of virtual machines? We tell in detail</a></li>
<li><a href="../425131/index.html">What to read about blockchain technologies: manuals, books and articles</a></li>
<li><a href="../425133/index.html">Problems of cross-border payments - why and how blockchains are used here</a></li>
<li><a href="../425135/index.html">Why VoIP was recognized as an information service in the USA, and what it means for the telecom industry and users</a></li>
<li><a href="../425139/index.html">Pop stars under the lens of artificial intelligence</a></li>
<li><a href="../425141/index.html">‚ÄúFacing Guido what you tell him‚Äù or Python dialogs with Bobuk</a></li>
<li><a href="../425143/index.html">Higher School of Economics refuses to lecture in favor of online courses</a></li>
<li><a href="../425145/index.html">Such an exceptional go</a></li>
<li><a href="../425149/index.html">Between heaven and earth</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>