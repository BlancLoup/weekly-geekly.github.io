<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchrony 2: teleport through portals</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Less than a year, as I got to continue the article about asynchrony. This article develops the ideas of the very first article about asynchrony [1] . ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchrony 2: teleport through portals</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/f0a/1c5/0ac/f0a1c50ac50944079d72728394c600f7.jpeg" width="640"></div><br><br>  Less than a year, as I got to continue the article about asynchrony.  This article develops the ideas of the very first article about asynchrony <a href="http://habrahabr.ru/post/201826/">[1]</a> .  It discusses a rather complicated task, by the example of which the power and flexibility of using coroutines in various nontrivial scenarios will be revealed.  In conclusion, we will consider two tasks on the race condition (race-condition), as well as a small but very nice bonus. <br><a name="habracut"></a><br>  For all this time, the <a href="http://habrahabr.ru/post/201826/">first</a> article has already hit the search top. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/64d/0c1/cce/64d0c1ccedc447b7bcdf413c873dd670.png" width="640"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f92/a97/512/f92a97512def46809eccd385bec4a996.png" width="640"></div><br><br>  So let's go! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/files/a85/726/2ff/a857262ff9144591bfebcc7b622932bb.jpeg" width="640"></div><br><br><h2>  Task </h2><br>  The original wording is straightforward and sounds like this: <br>  <b>Get a heavy object over the network and transfer it to the UI.</b> <br><br>  We will complicate the task by adding ‚Äúinteresting‚Äù requirements on the UI: <br><ol><li>  The action is generated from the UI stream through an event. </li><li>  The result must be returned back to the UI. </li><li>  We do not want to block the UI, so the operation must be done asynchronously. </li></ol><br>  Add "fun" conditions for obtaining the object: <br><ol><li>  Network operations are slow, so the object will be cached. </li><li>  I want to have a persistent cache so that after restart the objects are saved. </li><li>  The persistent device is slow, so for faster return of objects we will additionally cache them in memory. </li></ol><br>  Let's take a look at the performance aspects: <br><ol><li>  It would be desirable to have parallel, but not sequential record in caches (persistent storage and memory). </li><li>  Reading from caches should also be parallel, while if the value is found in one of the caches, then use it immediately, without waiting for a response from the other cache. </li><li>  Network operations should not in any way interfere with caches, that is, if, for example, caches are stupid, then this should not affect network interactions. </li><li>  I want to support a large number of connections in a limited number of threads, that is, I want asynchronous network interaction for a more careful attitude to resources. </li></ol><br>  Let us make logic worse: <br><ol><li>  We will need to cancel operations. </li><li>  Moreover, if we received our object through the network, then cancellation should not be further applied to subsequent cache update operations, that is, it is necessary to implement a ‚Äúcancellation cancellation‚Äù for some set of actions. </li></ol><br>  If it seemed to someone not hardcore enough, then we will add more requirements: <br><ol><li>  It is necessary to implement timeouts on operations.  And timeouts should be both for the whole operation, and for some parts.  For example: <br><ul><li>  timeout for all network interaction: connection, request, response; </li><li>  timeout for the entire operation, including network interaction and work with caches. </li></ul></li><li>  Operations schedulers can be either their own or foreign (for example, a scheduler in a UI thread). </li><li>  No operations should block threads.  This means that the use of mutexes and other synchronization tools is prohibited, as they will block our threads. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d5e/475/ed0/d5e475ed0f7e4dd09f1930742033b916.jpeg" width="640"></div><br><br>  Now that's enough.  If someone immediately had the answer, how to do it, then I will be happy to get acquainted with this decision.  Well, below I propose my solution: it is clear that it will focus not on implementation, for example, caches and persistence, but on concrete parallel and asynchronous interaction taking into account the requirements for locks and schedulers. <br><br><h2>  Decision </h2><br>  To solve, we will use the following model. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3c5/fce/32c/3c5fce32c9154c518f5bdf5a681da7b7.png"></div><br><br>  I will describe the essence of what is happening: <br><ol><li> <code>UI</code> , <code>Mem Cache</code> , <code>Disk Cache</code> , <code>Network</code> are the objects that perform the corresponding operations on our newly created <code>Handler</code> . </li><li>  <code>Handler</code> performs a simple sequence: <br><ul><li>  In parallel, it starts the operation of retrieving data from the caches of the objects <code>Mem Cache</code> and <code>Disk Cache</code> .  If successful, that is, when receiving a response with the result found from at least one cache, it returns the result immediately.  And in case of failure (as in the diagram), the execution continues. </li><li>  After waiting for a lack of result from both caches, <code>Handler</code> accesses the <code>Network</code> to retrieve the object over the network.  To do this, connect to the service ( <code>connect</code> ), send a request ( <code>send</code> ) and receive a response ( <code>receive</code> ).  Such operations are performed asynchronously and do not block other network interactions. </li><li>  The object received from the <code>Network</code> component is written in parallel to both caches. </li><li>  After waiting for the completion of writing to the cache, the value is returned to the UI stream. </li></ul></li><li>  The program contains the following schedulers and associated objects: <br><ul><li>  A UI thread that initiates an asynchronous <code>Handler</code> operation and to which the result should return; </li><li>  a common thread pool in which all the basic operations are performed, including <code>Mem Cache</code> and <code>Disk Cache</code> ; </li><li>  network thread pool for <code>Network</code> .  It is created separately from the main thread pool so that the load on the main pool does not affect the network thread pool. </li></ul></li></ol><br>  As I wrote earlier, the objects will be implemented in the simplest way, since for aspects of asynchrony this does not really matter: <br><br><pre> <code class="hljs lua">// stub:   struct DiskCache { boost::optional&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; get(const std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; key) { JLOG(<span class="hljs-string"><span class="hljs-string">"get: "</span></span> &lt;&lt; key); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> boost::optional&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); } void set(const std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; key, const std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; val) { JLOG(<span class="hljs-string"><span class="hljs-string">"set: "</span></span> &lt;&lt; key &lt;&lt; <span class="hljs-string"><span class="hljs-string">";"</span></span> &lt;&lt; val); } }; //   : - struct MemCache { boost::optional&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; get(const std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; key) { auto it = map.<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(key); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> it == map.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>() ? boost::optional&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;() : boost::optional&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(it-&gt;second); } void set(const std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; key, const std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; val) { map[key] = val; } private: std::unordered_map&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; map; }; struct Network { // ... //     std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> get(const std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; key) { net::Socket socket; JLOG(<span class="hljs-string"><span class="hljs-string">"connecting"</span></span>); socket.connect(address, port); //   -   Buffer sz(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(key.size())); socket.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(sz); //  -  socket.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(key); //    socket.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(sz); Buffer val(size_t(sz[<span class="hljs-number"><span class="hljs-number">0</span></span>]), <span class="hljs-number"><span class="hljs-number">0</span></span>); //    socket.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(val); JLOG(<span class="hljs-string"><span class="hljs-string">"val received"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } private: std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> address; int port; // ... }; // UI-:   UI struct UI : IScheduler { void schedule(Handler handler) { //    UI- // ... } void handleResult(const std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; key, const std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; val) { TLOG(<span class="hljs-string"><span class="hljs-string">"UI result inside UI thread: "</span></span> &lt;&lt; key &lt;&lt; <span class="hljs-string"><span class="hljs-string">";"</span></span> &lt;&lt; val); // TODO: add some actions } };</code> </pre><br>  As a rule, all UI frameworks contain a method that allows you to run necessary actions in a UI stream (for example, in Android: <code>Activity.runOnUiThread</code> , Ultimate ++: <code>PostCallback</code> , Qt: via the signal-slot mechanism).  These methods should be used in the implementation of the <code>UI::schedule</code> method. <br><br>  Initialization of the entire economy takes place in an imperative style: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/       ThreadPool cpu(3, "cpu"); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       ThreadPool net(2, "net"); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       Alone diskStorage(cpu, "disk storage"); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       Alone memStorage(cpu, "mem storage"); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     scheduler&lt;DefaultTag&gt;().attach(cpu); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       service&lt;NetworkTag&gt;().attach(net); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       service&lt;TimeoutTag&gt;().attach(cpu); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       portal&lt;DiskCache&gt;().attach(diskStorage); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       portal&lt;MemCache&gt;().attach(memStorage); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       portal&lt;Network&gt;().attach(net); UI&amp; ui = single&lt;UI&gt;(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  UI-  UI- portal&lt;UI&gt;().attach(ui);</span></span></code> </pre><br>  In the UI thread, for some user action we perform: <br><br><pre> <code class="hljs ruby">go([key] { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> timeout   : <span class="hljs-number"><span class="hljs-number">1</span></span>=<span class="hljs-number"><span class="hljs-number">1000</span></span>  Timeout t(<span class="hljs-number"><span class="hljs-number">1000</span></span>); std::string val; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      boost::optional&lt;std::string&gt; result = goAnyResult&lt;std::string&gt;({ [&amp;key] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> portal&lt;DiskCache&gt;()-&gt;get(key); }, [&amp;key] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> portal&lt;MemCache&gt;()-&gt;get(key); } }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   val = std::move(*result); JLOG(<span class="hljs-string"><span class="hljs-string">"cache val: "</span></span> &lt;&lt; val); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     /<span class="hljs-regexp"><span class="hljs-regexp">/     { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    : 0.5=500  Timeout tNet(500); val = portal&lt;Network&gt;()-&gt;get(key); } JLOG("net val: " &lt;&lt; val); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ( )  EventsGuard guard; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      goWait({ [&amp;key, &amp;val] { portal&lt;DiskCache&gt;()-&gt;set(key, val); }, [&amp;key, &amp;val] { portal&lt;MemCache&gt;()-&gt;set(key, val); } }); JLOG("cache updated"); } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   UI    portal&lt;UI&gt;()-&gt;handleResult(key, val); });</span></span></code> </pre><br><div style="text-align:center;"><img src="http://habrastorage.org/files/3d1/3b7/f4a/3d13b7f4aa4e4c5fa749c545b3b19934.jpeg" width="640"></div><br><br><h2>  Implementation of primitives used </h2><br>  As the attentive reader noted, I used a considerable number of primitives, the implementation of which can only be guessed.  Therefore, below is a description of the approach and classes used.  I think it will clarify what portals are, how to use them, and also answer the question about teleportation. <br><br><div style="text-align:center;"><img src="http://habrastorage.org/files/8af/b5b/745/8afb5b745a4c4f288f2882aab384370e.jpeg" width="640"></div><br><br><h2>  Waiting primitives </h2><br>  Let's start with the simplest - waiting for primitives. <br><br><h4>  goWait: starting an asynchronous operation and waiting for completion </h4><br>  So, for the seed, we will implement a function that will asynchronously start the operation and wait for it to complete: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goWait</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Handler</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  Of course, launching a handler in the current coroutine is quite suitable as an implementation.  But in more complex scenarios, this does not suit us, so we will create a new coroutine to implement this function: <br><br><pre> <code class="hljs markdown">void goWait(Handler handler) { deferProceed([<span class="hljs-string"><span class="hljs-string">&amp;handler</span></span>](<span class="hljs-link"><span class="hljs-link">Handler proceed</span></span>) { go([proceed, &amp;handler] { //    handler(); proceed(); //    }); }); }</code> </pre><br>  I will describe briefly what is happening here.  At the input of the goWait function, we get a handler, which should be run in a new coroutine.  To perform the necessary operations, we use the <code>deferProceed</code> function, which is implemented as follows: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(Handler)&gt; ProceedHandler; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deferProceed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProceedHandler proceed)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; coro = currentCoro(); defer([&amp;coro, proceed] { proceed([&amp;coro] { coro.resume(); }); }); }</code> </pre><br>  What does this feature do?  It actually wraps the defer call for more convenient use (what <code>defer</code> and why it should be used, described in my <a href="http://habrahabr.ru/post/201826/">previous article</a> ), namely: it accepts not <code>Handler</code> , but <code>ProceedHandler</code> , in which <code>Handler</code> is passed as an input parameter to continue execution of the coroutine.  Actually, <code>proceed</code> itself saves in its object a reference to the current coroutine and calls <code>coro.resume()</code> .  Thus, we encapsulate all the work with coroutines, and the user only needs to work with the <code>proceed</code> handler. <br><br>  Go back to the <code>goWait</code> function.  So, when we call <code>deferProceed</code> , we have <code>proceed</code> , which needs to be called at the end of the operation in the <code>handler</code> .  All we have to do is create a new coroutine, run our handler <code>handler</code> in it, and after it completes, immediately call proceed, which internally calls <code>coro.resume()</code> , thus continuing the execution of the original coroutine. <br><br>  This gives us a wait without blocking the thread: during a call to <code>goWait</code> we sort of pause our operations in the current coroutine, and when the transferred handler finishes, we continue execution as if nothing had happened. <br><br><h4>  goWait: start several asynchronous operations and wait for them to complete </h4><br>  Now we will implement a function that starts a whole batch of asynchronous operations and waits for them to complete: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goWait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">initializer_list</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Handler&gt; handlers)</span></span></span></span>;</code> </pre><br>  At the entrance we have a list of handlers that need to be run asynchronously, that is, each handler will start in its coroutine.  The essential difference from the previous function is that we need to continue the execution of the original coroutine only after all handlers are completed.  Some use for this purpose all sorts of mutexes and condition variables (and so some people actually do!), But we can't do that (see requirements), so we will look for other ways to implement. <br><br>  The idea is actually quite trivial: you need to create a counter that, when it reaches a certain value, will call <code>proceed</code> .  Each handler at its completion will update the counter, and thus the last of the handlers will continue the execution of the original coroutine.  However, there is one small difficulty: the counter must be divided between the running coroutines, and the last handler must not only call proceed, but also delete this counter from memory.  All this can be implemented as follows: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goWait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">initializer_list</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Handler&gt; handlers)</span></span></span><span class="hljs-function"> </span></span>{ deferProceed([&amp;handlers](Handler proceed) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; proceeder(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, [proceed](<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*) { proceed(); }); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; handler: handlers) { go([proceeder, &amp;handler] { handler(); }); } }); }</code> </pre><br>  At the very beginning, we run the good old <code>deferProceed</code> , but inside it is hidden a little magic.  Few people know that when constructing <code>shared_ptr</code> you can pass not only a pointer to the data, but also a <code>deleter</code> , which will delete the object, calling not the <code>delete ptr</code> , but the handler.  Actually, there we also will thrust a call proceed, in the end to continue the initial coroutine.  And there is no need to delete the object itself, since we put ‚Äúnothing‚Äù there - <code>nullptr</code> .  Then everything is simple: in the loop we go through all the handlers and run them in the generated coroutines.  Here, too, there is one nuance: we capture our <code>proceeder</code> by value, which will lead to its copying, which means an increase in our atomic reference counter inside <code>shared_ptr</code> .  After the <code>handler</code> is finished, our lambda with captured proceeder will be deleted, which will decrease the counter.  The one who last will reduce the counter to zero and delete the <code>proceeder</code> object will call <code>deleter</code> for the shared <code>shared_ptr</code> , that is, it will eventually <code>coro.proceed()</code> . <br><br><div style="text-align:center;"><img src="http://habrastorage.org/files/0f3/b52/9a6/0f3b529a67d147f28d063863cb2e45f0.jpeg" width="640"></div><br><br>  For greater clarity, the following is a sequence of operations on the example of running two handlers in different threads: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/files/a7d/edb/d20/a7dedbd20ef64713be7cca56c0f7924e.png"></div><br><br><h4>  Example: Recursively Parallel Fibonacci Numbers </h4><br>  To illustrate use, consider the following example.  Suppose we found a whim and we wanted to calculate the Fibonacci series recursively and in parallel.  No problems: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v1, v2; goWait({ [v, &amp;v1] { v1 = fibo(v<span class="hljs-number"><span class="hljs-number">-1</span></span>); }, [v, &amp;v2] { v2 = fibo(v<span class="hljs-number"><span class="hljs-number">-2</span></span>); } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1 + v2; }</code> </pre><br>  I note that there will never be a stack overflow: every call to the <code>fibo</code> function occurs in its own coroutine. <br><br><h4>  Waiter: start of several asynchronous operations and waiting for their completion </h4><br>  Often we need not just to wait for a fixed set of handlers, but in the meantime to do something useful and only then to wait.  Sometimes we don‚Äôt know how many handlers may be needed, that is, we create them as we perform our operations.  In fact, we need to operate with a group of handlers as a whole.  To do this, you can use the <code>Waiter</code> primitive with the following interface: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Waiter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-function">Waiter&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Handler)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; };</code> </pre><br>  There are only two methods: <br><ol><li>  go: run another handler; </li><li>  wait: wait for all running handlers. </li></ol><br>  You can run the above methods several times over the entire lifetime of the <code>Waiter</code> object. <br><br>  The idea of ‚Äã‚Äãimplementation is exactly the same: it is necessary to have a <code>proceeder</code> that continues the work of our coroutine.  However, a small subtlety is added: now <code>proceeder</code> is divided between the running coroutines and the <code>Waiter</code> object.  Accordingly, at the time the <code>wait</code> method is called, we need to get rid of the copy in the <code>Waiter</code> itself.  Here's how to do it: <br><br><pre> <code class="hljs ruby">void Waiter::wait() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (proceeder.unique()) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  Waiter  proceeder =&gt; JLOG(<span class="hljs-string"><span class="hljs-string">"everything done, nothing to do"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } defer([this] { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  proceeder     auto toDestroy = std::move(proceeder); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  proceeder   , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   -   }); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> proceeder     , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       init<span class="hljs-number"><span class="hljs-number">0</span></span>(); }</code> </pre><br>  And again nothing needs to be done!  Thanks for this <code>shared_ptr</code> .  Amen! <br><br><div style="text-align:center;"><img src="http://habrastorage.org/files/290/eeb/977/290eeb9774654cf4831a411a566219b2.jpeg" width="640"></div><br><br><h4>  Example: Recursively Parallel Fibonacci Numbers </h4><br>  To consolidate the material, we consider an alternative implementation of our whit using <code>Waiter</code> : <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v1; Waiter w; w.go([v, &amp;v1] { v1 = fibo(v<span class="hljs-number"><span class="hljs-number">-1</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v2 = fibo(v<span class="hljs-number"><span class="hljs-number">-2</span></span>); w.wait(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1 + v2; }</code> </pre><br>  Another option: <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fibo (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v1, v2; Waiter() .<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>([v, &amp;v1] { v1 = fibo (v<span class="hljs-number"><span class="hljs-number">-1</span></span>); }) .<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>([v, &amp;v2] { v2 = fibo (v<span class="hljs-number"><span class="hljs-number">-2</span></span>); }) .wait(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1 + v2; }</code> </pre><br>  I do not want to choose. <br><br><h4>  goAnyWait: start several asynchronous operations and wait for at least one to complete </h4><br>  We will still run several operations at the same time.  But we will wait exactly until at least one operation is completed: <br><br><pre> <code class="hljs lisp">size_t goAnyWait(<span class="hljs-name"><span class="hljs-name">std</span></span>:<span class="hljs-symbol"><span class="hljs-symbol">:initializer_list&lt;Handler&gt;</span></span> handlers)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  At the entrance we have a list of handlers, the output is the number of the handler, which ended first. <br><br>  To implement this primitive, we slightly modernize our approach.  Now we are going to separate not <code>void* ptr == nullptr</code> , but quite a specific atomic counter <code>counter</code> .  At the very beginning, it is initialized to <code>0</code> .  Each handler at the end of its work increases the counter.  And if it suddenly turned out that a change in the value from <code>0</code> to <code>1</code> occurred, then he and only he calls <code>proceed()</code> : <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> goAnyWait(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">initializer_list</span></span>&lt;Handler&gt; handlers) { VERIFY(handlers.size() &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"Handlers amount must be positive"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">-1</span></span>); deferProceed([&amp;handlers, &amp;index](Handler proceed) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; counter = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; handler: handlers) { go([counter, proceed, &amp;handler, i, &amp;index] { handler(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++ *counter == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// , ! index = i; proceed(); } }); ++ i; } }); VERIFY(index &lt; handlers.size(), "Incorrect index returned"); return index; }</span></span></code> </pre><br>  As you might guess, this trick can also be used for cases when you need to wait for two, three or more handlers. <br><br><h4>  goAnyResult: start several asynchronous operations and wait for at least one result to be received </h4><br>  We now turn to the most delicious, which, in fact, necessary for our task.  Namely: run a few operations and wait for the desired result.  In this case, any handler may not return the result.  That is, he will finish his work, but at the same time he will say: ‚ÄúWell, I didn‚Äôt hurt, I didn‚Äôt hush.‚Äù <br><br>  With this approach, additional complexity appears.  After all, all handlers can complete the work, but we will not get the result.  Therefore, it will be necessary, first, to somehow check at the end of all operations whether we have obtained the desired result, and second, to return an ‚Äúempty‚Äù result.  To signal emptiness, we will use <code>boost::optional&lt;T_result&gt;</code> , while <code>goAnyResult</code> obtained with this plain prototype: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_result&gt; boost::optional&lt;T_result&gt; goAnyResult( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">initializer_list</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt; boost::optional&lt;T_result&gt;() &gt; &gt; handlers)</code> </pre><br>  There is nothing terrible here: we simply pass a list of handlers that optionally return our <code>T_result</code> .  That is, handlers must have a signature: <br><br><pre> <code class="hljs swift">boost::<span class="hljs-keyword"><span class="hljs-keyword">optional</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T_result</span></span>&gt; handler();</code> </pre><br>  The situation in comparison with the previous primitive is only slightly modified.  The counter remains the same, only now when it is destroyed, it is necessary to check the <code>counter</code> , and if we get <code>1</code> when increasing it, then it is necessary to return the ‚Äúempty‚Äù value, since no one has been able to distort the counter and return the required result.  Thus, instead of a simple atomic value for <code>counter</code> we have a whole <code>Counter</code> object: <br><br><pre> <code class="hljs markdown">template<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T_result</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> boost::optional<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">T_result</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> goAnyResult( std::initializer<span class="hljs-emphasis"><span class="hljs-emphasis">_list&lt; std::function&lt; boost::optional&lt;T_</span></span>result&gt;() &gt; &gt; handlers) { typedef boost::optional<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">T_result</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> Result; typedef std::function<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">void(Result&amp;&amp;)</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ResultHandler; struct Counter { Counter(ResultHandler proceed<span class="hljs-emphasis"><span class="hljs-emphasis">_) : proceed(std::move(proceed_</span></span>)) {} ~Counter() { tryProceed(Result()); //    - } void tryProceed(Result&amp;&amp; result) { if (++ counter == 1) proceed(std::move(result)); } private: std::atomic<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">int</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> counter; ResultHandler proceed; }; Result result; deferProceed([<span class="hljs-string"><span class="hljs-string">&amp;handlers, &amp;result</span></span>](<span class="hljs-link"><span class="hljs-link">Handler proceed</span></span>) { std::shared<span class="hljs-emphasis"><span class="hljs-emphasis">_ptr&lt;Counter&gt; counter = std::make_</span></span>shared<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Counter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>( [<span class="hljs-string"><span class="hljs-string">&amp;result, proceed</span></span>](<span class="hljs-link"><span class="hljs-link">Result&amp;&amp; res</span></span>) { result = std::move(res); proceed(); } ); for (const auto&amp; handler: handlers) { go([counter, &amp;handler] { Result result = handler(); if (result) //       counter-&gt;tryProceed(std::move(result)); }); } }); return result; }</code> </pre><br>  The intrigue here is that <code>std::move</code> only moves the result when the condition inside <code>tryProceed</code> is satisfied.  And all because <code>std::move</code> does not perform the movement as such, no matter how someone would like it.  This is just a cast operation on links. <br><br>  With the expectations figured out, go to the schedulers and thread pools. <br><br><h2>  Scheduler, pools, sync </h2><br><h4>  Scheduler Interface </h4><br>  After reviewing the basic basics, so to speak, we proceed to the dessert. <br>  We introduce the scheduler interface: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IScheduler</span></span></span><span class="hljs-class"> :</span></span> IObject { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">schedule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Handler handler)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  Its task is to execute handlers.  Note that the scheduler interface has no undo, no timeout, or pending operations.  The scheduler interface should be crystal clear so that it can be easily docked with various frameworks (cf. <a href="http://doc.akka.io/docs/akka/2.1.4/scala/scheduler.html">[2]</a> : here you will find it very convenient to cross with the actors and delays, with UI schedulers). <br><br><div style="text-align:center;"><img src="http://habrastorage.org/files/353/403/d24/353403d2484f420a86459e652e7c096e.jpeg" width="640"></div><br><br><h4>  Thread pool </h4><br>  We need a thread pool to perform various actions that implements the scheduler interface: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::asio::io_service IoService; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IService</span></span></span><span class="hljs-class"> :</span></span> IObject { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> IoService&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ioService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThreadPool</span></span></span><span class="hljs-class"> :</span></span> IScheduler, IService { ThreadPool(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> threadCount); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">schedule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Handler handler)</span></span></span><span class="hljs-function"> </span></span>{ service.post(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(handler)); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-function">IoService&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ioService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;boost::asio::io_service::work&gt; work; boost::asio::io_service service; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread&gt; threads; };</code> </pre><br>  What do we have here? <br><ol><li>  The constructor in which we set the number of threads. </li><li>  Implementing the scheduler interface using <code>boost::asio::io_service::post</code> . </li><li>  A member of the <code>work</code> class that holds the <code>io_service</code> event <code>io_service</code> , otherwise, if there are no events, the cycle will complete its work and the threads will close. </li><li>  Array of threads. </li></ol><br>  In addition, our class implements (and privately) a certain muddy <code>IService</code> interface with the <code>ioService</code> method, which is returned by <code>IoService</code> , which is <code>boost::asio::io_service</code> .  All this looks strange, but now I will try to explain what the trick is. <br><br>  The fact is that to work with network sockets and timeouts we need an advanced scheduler interface.  This interface is actually hidden inside <code>boost::asio::io_service</code> .  The remaining components, which I will use in the future, should somehow get access to the instance <code>boost::asio::io_service</code> .  To prevent easy access to this class, I introduced the <code>IService</code> interface, which allows you to receive the coveted instance.  However, in the implementation of the method is made private.  This provides some level of protection against misuse, since in order to pull this object out, you first need to convert the <code>ThreadPool</code> to <code>IService</code> , and then call the desired method.  An alternative would be to use friendly classes.  But I didn‚Äôt want to spoil <code>ThreadPool</code> knowledge of possible uses, so I thought that the approach used was a reasonable price for encapsulation. <br><br><h4>  Coroutine class </h4><br>  After the introduction of the thread pool and the scheduler, it was the turn to introduce a class for coroutine manipulations.  It will be called, oddly enough, <code>Journey</code> (why it will be clear later): <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Journey</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proceed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Handler </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proceedHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">defer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Handler handler)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deferProceed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProceedHandler proceed)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Handler handler, mt::IScheduler&amp; s)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Journey(mt::IScheduler&amp; s); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoroGuard</span></span></span><span class="hljs-class"> {</span></span> CoroGuard(Journey&amp; j_) : j(j_) { j.onEnter0(); } ~CoroGuard() { j.onExit0(); } coro::Coro* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;j.coro; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Journey&amp; j; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Handler handler)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">schedule0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Handler handler)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">CoroGuard </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">guardedCoro0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proceed0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onEnter0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onExit0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; mt::IScheduler* sched; coro::Coro coro; Handler deferHandler; };</code> </pre><br>     ? <br><ul><li>  .      <code>create</code> . </li><li> <code>Journey</code>       <code>sched</code> ,   <code>coro</code>  <code>deferHandler</code> -,    <code>defer</code> . </li><li> <code>CoroGuard</code> ‚Äì -,          <code>onEnter0</code>      <code>onExit0</code>  . </li></ul><br>  ,   ,      : <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> Journey::schedule0(<span class="hljs-keyword"><span class="hljs-keyword">Handler</span></span> <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>) { VERIFY(sched != nullptr, "Scheduler must be set in journey"); sched-&gt;schedule(std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>)); } <span class="hljs-type"><span class="hljs-type">void</span></span> Journey::proceed0() { //      guardedCoro0()-&gt;resume(); } Journey::CoroGuard Journey::guardedCoro0() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CoroGuard(*this); } //          <span class="hljs-type"><span class="hljs-type">void</span></span> Journey::proceed() { schedule0([this] { proceed0(); }); } //   ,     <span class="hljs-keyword"><span class="hljs-keyword">Handler</span></span> Journey::proceedHandler() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [this] { proceed(); }; } //    // .   <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Journey::start0(<span class="hljs-keyword"><span class="hljs-keyword">Handler</span></span> <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>) { schedule0([<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>, this] { //    guardedCoro0()-&gt;<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>([<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>] { JLOG("started"); //     try { <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>(); } catch (std::<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span>&amp; e) { (<span class="hljs-type"><span class="hljs-type">void</span></span>) e; JLOG("exception in coro: " &lt;&lt; e.what()); } JLOG("ended"); }); }); }</code> </pre><br>     defer: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> Journey::defer(<span class="hljs-keyword"><span class="hljs-keyword">Handler</span></span> <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>) { //   deferHandler = <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>; //      coro::yield(); } // deferProceed,   <span class="hljs-type"><span class="hljs-type">void</span></span> Journey::deferProceed(ProceedHandler proceed) { defer([this, proceed] { proceed(proceedHandler()); }); }</code> </pre><br>  It's simple!  ,       <code>deferHandler</code> . <br><br><pre> <code class="hljs pgsql">TLS Journey* t_journey = nullptr; <span class="hljs-type"><span class="hljs-type">void</span></span> Journey::onEnter0() { t_journey = this; } // .   <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Journey::onExit0() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (deferHandler == nullptr) { //   =&gt;  ,   <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> this; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //       deferHandler(); deferHandler = nullptr; } //  ,       t_journey = nullptr; }</code> </pre><br>        <code>create</code> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> Journey::<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">Handler</span></span> <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>, mt::IScheduler&amp; s) { (<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Journey(s))-&gt;start0(std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>)); }</code> </pre><br>  ,         <code>Journey</code> ,        ,    .     ,  ‚Ä¶ <br><br><h4>  </h4><br>    ! ‚Ä¶    ,       .        ,        .    ! <br><br>      : <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> Journey::teleport(mt::IScheduler&amp; s) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (&amp;s == sched) { JLOG("the same destination, skipping teleport &lt;-&gt; " &lt;&lt; s.name()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } JLOG("teleport " &lt;&lt; sched-&gt;<span class="hljs-type"><span class="hljs-type">name</span></span>() &lt;&lt; " -&gt; " &lt;&lt; s.name()); sched = &amp;s; defer(proceedHandler()); }</code> </pre><br>    : <br><ol><li> ,       ,     .     ,     ,    . </li><li>  ,         : <code>defer</code>  ,             .       ,          . </li></ol><br><div style="text-align:center;"><img src="http://habrastorage.org/files/bc3/1c4/88a/bc31c488a5f947c9a5c1e2fc08044c79.jpeg" width="640"></div><br><br>         <code>Scheduler</code> / <code>Thread</code>  <code>Scheduler2</code> / <code>Thread2</code> : <br><br><div style="text-align:center;"><img src="http://habrastorage.org/files/3c6/1e4/d99/3c61e4d99f0640069ce25687bbce25d9.png"></div><br><br>    ?         ,  ,  ,  .  ,    UI-   ,  UI,  ,  : <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = someCalculations(); teleport(uiScheduler); showResult(result); teleport(calcScheduler); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> newResult = continueSmartCalculations(result); teleport(uiScheduler); updateResult(newResult); <span class="hljs-comment"><span class="hljs-comment">//‚Ä¶</span></span></code> </pre><br>  ,      UI,       ,          UI-.      ,    , ,          ‚Äì  ,   ,     . <br><br><h4>  </h4><br><br><div style="text-align:center;"><img src="http://habrastorage.org/files/965/61e/91c/96561e91cd824fc4aca362cf73d06230.jpeg" width="640"></div><br><br>     .    ,     .     ,    UI-       UI-,   .        ,  ,     ,     . <br><br><pre> <code class="hljs mel">struct Portal { Portal(mt::IScheduler&amp; destination) : <span class="hljs-keyword"><span class="hljs-keyword">source</span></span>(journey().scheduler()) { JLOG(<span class="hljs-string"><span class="hljs-string">"creating portal "</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">source</span></span>.name() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" &lt;=&gt; "</span></span> &lt;&lt; destination.name()); teleport(destination); } ~Portal() { teleport(<span class="hljs-keyword"><span class="hljs-keyword">source</span></span>); } private: mt::IScheduler&amp; <span class="hljs-keyword"><span class="hljs-keyword">source</span></span>; };</code> </pre><br>        (  ),       .       . <br><br>   RAII-     ,       ,   (,       UI-     ),    . <br><br>   : <br><br><pre> <code class="hljs java"><span class="hljs-function"><span class="hljs-function">ThreadPool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tp1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"tp1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ThreadPool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tp2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"tp2"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; go([&amp;tp2] { <span class="hljs-function"><span class="hljs-function">Portal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tp2)</span></span></span></span>; JLOG(<span class="hljs-string"><span class="hljs-string">"throwing exception"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> std::runtime_error(<span class="hljs-string"><span class="hljs-string">"exception occur"</span></span>); }, tp1);</code> </pre><br>    tp1,        tp2.      ,     ,   tp1   ,        .    ! <br><br><div style="text-align:center;"><img src="http://habrastorage.org/files/4a6/ed7/adf/4a6ed7adf9394d12a104f0eb740e36b7.gif" width="640"></div><br><br>         (,  ,  ), : <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scheduler</span></span></span><span class="hljs-class"> {</span></span> Scheduler(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mt::IScheduler&amp; s)</span></span></span><span class="hljs-function"> </span></span>{ scheduler = &amp;s; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ scheduler = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> mt::IScheduler&amp;() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { VERIFY(scheduler != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-string"><span class="hljs-string">"Scheduler is not attached"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *scheduler; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: mt::IScheduler* scheduler; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefaultTag</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_tag&gt; <span class="hljs-function"><span class="hljs-function">Scheduler&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scheduler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> single&lt;Scheduler, T_tag&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WithPortal</span></span></span><span class="hljs-class"> :</span></span> Scheduler { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Access</span></span></span><span class="hljs-class"> :</span></span> Portal { Access(Scheduler&amp; s) : Portal(s) {} T* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;single&lt;T&gt;(); } }; Access <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; WithPortal&lt;T&gt;&amp; portal() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> single&lt;WithPortal&lt;T&gt;&gt;(); }</code> </pre><br>       ,    : <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-function">ThreadPool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tp1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"tp1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ThreadPool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tp2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"tp2"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">op</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} }; portal&lt;X&gt;().attach(tp2); go([] { portal&lt;X&gt;()-&gt;op(); }, tp1);</code> </pre><br>       <code>X</code>    tp2.  ,        <code>X</code> (  return <code>&amp;single&lt;T&gt;()</code> )         . <b>   <code>Journey</code>   -,     !</b> <br><br><div style="text-align:center;"><img src="http://habrastorage.org/files/bc9/3ec/7ae/bc93ec7aeb214ce3a08912040cb1c0ba.jpeg" width="640"></div><br><br>        ,      .          .           .           ,   . <br><br><h4>   </h4><br>        .   :           . <br><br>     ,  -   ?          ,    .         . <br><br>     ?       ,        ,     . ¬´ ¬ª, ‚Äì     . <br><br>         .    ,          .     : <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Alone</span></span></span><span class="hljs-class"> :</span></span> mt::IScheduler { Alone(mt::IService&amp; service); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">schedule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Handler handler)</span></span></span><span class="hljs-function"> </span></span>{ strand.post(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(handler)); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: boost::asio::io_service::strand strand; };</code> </pre><br>    <code>Alone</code>       <code>IService</code> ,      <code>io_service::strand</code>  <code>boost.asio</code> .      <code>boost.asio</code> ,  ,             .         ,    (mutual exclusion). <br><br>    <code>Alone</code>   ,            ,     . <br><br>     : <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MemCache</span></span></span><span class="hljs-class"> {</span></span> boost::optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; get(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; key); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; val)</span></span></span></span>; }; <span class="hljs-comment"><span class="hljs-comment">//  ThreadPool common_pool(3); //    Alone mem_alone(common_pool); //     portal&lt;MemCache&gt;().Attach(mem_alone); //     //     auto value = portal&lt;MemCache&gt;()-&gt;get(key); //  portal&lt;MemCache&gt;()-&gt;set(anotherKey, anotherValue);</span></span></code> </pre><br>      ,            . ,   ! <br><br><div style="text-align:center;"><img src="http://habrastorage.org/files/cb8/3bb/64d/cb83bb64d941456c92354358e4456101.jpeg" width="640"></div><br><br><h4>   </h4><br> ,             .        ,  .      ,      ,      . <br><br><div style="text-align:center;"><img src="http://habrastorage.org/files/2cc/26b/701/2cc26b7015ee4bddbfd1ff39cd376ad9.jpeg" width="640"></div><br><br>       ?  ,   ,   ,          (. ¬´¬ª).            . <br><br>       :        ‚Äì   . , ,     ,      ,      .   !  ,     ,    ,      ? <br><br>         . ,  ,          ,  - , - ,  ,        .       . <br><br>         : <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EventStatus { ES_NORMAL, ES_CANCELLED, ES_TIMEDOUT, }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventException</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error { EventException(EventStatus s); <span class="hljs-function"><span class="hljs-function">EventStatus </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">status</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: EventStatus st; };</code> </pre><br>     (. )   ,      : <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Goer</span></span></span><span class="hljs-class"> {</span></span> Goer(); <span class="hljs-function"><span class="hljs-function">EventStatus </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timedout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> {</span></span> State() : status(ES_NORMAL) {} EventStatus status; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStatus0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EventStatus s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">State&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">state0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;State&gt; state; };</code> </pre><br>    :      ,      . <br><br>    - <code>Journey</code>   : <br><br><pre> <code class="hljs ruby">void Journey::handleEvents() { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!eventsAllowed <span class="hljs-params"><span class="hljs-params">||</span></span> std::uncaught_exception()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; auto s = gr.reset(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s == ES_NORMAL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   throw EventException(s); } void Journey::disableEvents() { handleEvents(); eventsAllowed = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } void Journey::enableEvents() { eventsAllowed = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; handleEvents(); }</code> </pre><br>       ,      .     -  ,        .    : <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventsGuard</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-type"><span class="hljs-type">EventsGuard</span></span>(); <span class="hljs-comment"><span class="hljs-comment">//  disableEvents() ~EventsGuard(); //  enableEvents() };</span></span></code> </pre><br>  ,       <code>handleEvents</code> ?   : <br><br><pre> <code class="hljs ruby">void Journey::defer(Handler handler) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      handleEvents(); deferHandler = handler; coro::<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     handleEvents(); }</code> </pre><br>        ,      .     -   ,               <code>handleEvents</code> .         . <br><br>    : <br><br><pre> <code class="hljs pgsql">Goer go(<span class="hljs-keyword"><span class="hljs-keyword">Handler</span></span> <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>, mt::IScheduler&amp; scheduler) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Journey::<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>), scheduler); }</code> </pre><br> <code>Journey::create</code>    <code>Goer</code>      : <br><br><pre> <code class="hljs pgsql">struct Journey { // ‚Ä¶ Goer goer() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gr; } // ‚Ä¶ private: // ‚Ä¶ Goer gr; }; Goer Journey::<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">Handler</span></span> <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>, mt::IScheduler&amp; s) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Journey(s))-&gt;start0(std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>)); } // .  <span class="hljs-number"><span class="hljs-number">1</span></span> Goer Journey::start0(<span class="hljs-keyword"><span class="hljs-keyword">Handler</span></span> <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>) { // ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> goer(); }   : Goer op = go(myMegaHandler); // ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> (weDontNeedMegaHandlerAnymore) op.cancel();</code> </pre><br>   <code>op.cancel()</code>   ,     <code>handleEvents()</code>       . <br><br><div style="text-align:center;"><img src="http://habrastorage.org/files/637/9cc/db9/6379ccdb991042b1ab6ccac5b73202aa.jpeg" width="640"></div><br><br>    , , ,   <code>Journey</code> ,    -,   ,     <code>go</code> .  ,    ,        .      : <code>go</code> , <code>defer</code> , <code>deferProceed</code>  . .,       <code>Journey</code> ,  TLS. <br><br><h4>   </h4><br>      : <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timeout</span></span></span><span class="hljs-class"> {</span></span> Timeout(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ms); ~Timeout(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: boost::asio::deadline_timer timer; };</code> </pre><br><br>     <code>boost::asio::deadline_timer</code> : <br><br><pre> <code class="hljs markdown">Timeout::Timeout(int ms) : timer(service<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">TimeoutTag</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>(), boost::posix<span class="hljs-emphasis"><span class="hljs-emphasis">_time::milliseconds(ms)) { //     Goer goer = journey().goer(); //    timer.async_</span></span>wait([<span class="hljs-string"><span class="hljs-string">goer</span></span>](<span class="hljs-link"><span class="hljs-link">const Error&amp; error</span></span>) mutable { // mutable,       goer if (!error) //     ,   goer.timedout(); }); } Timeout::~Timeout() { //    timer.cancel_one(); // ,    handleEvents(); }</code> </pre><br>  RAII-,          ,      . <br><br>   : <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//   Timeout t(100); // 100  for (auto element: container) { performOperation(element); handleEvents(); }</span></span></code> </pre><br>    100  ‚Äì  ! <br><br><div style="text-align:center;"><img src="http://habrastorage.org/files/bb8/074/9f8/bb80749f87c64667afdf0379354d2ef9.jpeg"></div><br><br>       : <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/   200     Timeout outer(200); portal&lt;MyObject&gt;()-&gt;performOp(); { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   100  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       Timeout inner(100); portal&lt;MyAnotherObject&gt;()-&gt;performAnotherOp(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       EventsGuard guard; performGuardedAction(); }</span></span></code> </pre><br><h2>  </h2><br>        . ,    ‚Äì  ¬´¬ª .       . <br><br>    ? : <br><ol><li>      ,   . </li><li>      .     ,      . </li><li>    ‚Äì   . ,     . </li></ol><br><h4>  1 </h4><br> ,    1. <br><br>    : <br><br><pre> <code class="hljs pgsql">Goer Journey::start0(<span class="hljs-keyword"><span class="hljs-keyword">Handler</span></span> <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>) { schedule0([<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>, this] { guardedCoro0()-&gt;<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>([<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>] { JLOG("started"); try { <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>(); } catch (std::<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span>&amp; e) { (<span class="hljs-type"><span class="hljs-type">void</span></span>) e; JLOG("exception in coro: " &lt;&lt; e.what()); } JLOG("ended"); }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> goer(); }</code> </pre><br>       .  Where?   ,     ? <br><br><div class="spoiler">  <b class="spoiler_title">Answer</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">Goer Journey::start0(<span class="hljs-keyword"><span class="hljs-keyword">Handler</span></span> <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>) { + Goer gr = goer(); schedule0([<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>, this] { guardedCoro0()-&gt;<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>([<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>] { JLOG("started"); @@ <span class="hljs-number"><span class="hljs-number">-121</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span> +<span class="hljs-number"><span class="hljs-number">122</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span> @@ JLOG("ended"); }); }); - <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> goer(); + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gr; }</code> </pre><br><br><div style="text-align:center;"><img src="http://habrastorage.org/files/f4d/c0a/9b2/f4dc0a9b2dce4736a1b9f034304cb7eb.png"></div><br></div></div><br><br><h4>  2 </h4><br>   .  : <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Journey::onExit0() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (deferHandler == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { deferHandler(); deferHandler = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } t_journey = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; }</code> </pre><br>        ? <br><br><div class="spoiler">  <b class="spoiler_title">Answer</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"> { @@ <span class="hljs-number"><span class="hljs-number">-153</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span> +<span class="hljs-number"><span class="hljs-number">154</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span> @@ - deferHandler(); - deferHandler = nullptr; + <span class="hljs-keyword"><span class="hljs-keyword">Handler</span></span> <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> = std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(deferHandler); + <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>(); }</code> </pre><br><br><div style="text-align:center;"><img src="http://habrastorage.org/files/74e/9b1/965/74e9b196567a4f89897bd0e2290cbed4.png" width="640"></div><br><br>     defer handler,      . <br></div></div><br><br><h2> :   (GC) </h2><br><br><div style="text-align:center;"><img src="http://habrastorage.org/files/d52/201/a0c/d52201a0cc7f4417824a3c3805b2fc28.jpeg" width="640"></div><br><br> , ,   GC   .    : <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ ~<span class="hljs-type"><span class="hljs-type">A</span></span>() { <span class="hljs-type"><span class="hljs-type">TLOG</span></span>(<span class="hljs-string"><span class="hljs-string">"~A"</span></span>); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ ~<span class="hljs-type"><span class="hljs-type">B</span></span>() { <span class="hljs-type"><span class="hljs-type">TLOG</span></span>(<span class="hljs-string"><span class="hljs-string">"~B"</span></span>); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{ ~<span class="hljs-type"><span class="hljs-type">C</span></span>() { <span class="hljs-type"><span class="hljs-type">TLOG</span></span>(<span class="hljs-string"><span class="hljs-string">"~C"</span></span>); } }; <span class="hljs-type"><span class="hljs-type">ThreadPool</span></span> tp(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"tp"</span></span>); go([] { <span class="hljs-type"><span class="hljs-type">A</span></span>* a = gcnew&lt;<span class="hljs-type"><span class="hljs-type">B</span></span>&gt;(); <span class="hljs-type"><span class="hljs-type">C</span></span>* <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = gcnew&lt;<span class="hljs-type"><span class="hljs-type">C</span></span>&gt;(); }, tp);</code> </pre><br>   : <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">tp</span></span><span class="hljs-selector-id"><span class="hljs-selector-id">#1</span></span>: ~<span class="hljs-selector-tag"><span class="hljs-selector-tag">C</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">tp</span></span><span class="hljs-selector-id"><span class="hljs-selector-id">#1</span></span>: ~<span class="hljs-selector-tag"><span class="hljs-selector-tag">B</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">tp</span></span><span class="hljs-selector-id"><span class="hljs-selector-id">#1</span></span>: ~<span class="hljs-selector-tag"><span class="hljs-selector-tag">A</span></span></code> </pre><br>         !  - ,        . <br><br>  ,  ,  : <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... V&gt; <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gcnew</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(V&amp;&amp;... v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gc().add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward(v)...)); } <span class="hljs-function"><span class="hljs-function">GC&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> journey().gc; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GC</span></span></span><span class="hljs-class"> {</span></span> ~GC() { <span class="hljs-comment"><span class="hljs-comment">//     for (auto&amp; deleter: boost::adaptors::reverse(deleters)) deleter(); } template&lt;typename T&gt; T* add(T* t) { //    T deleters.emplace_back([t] { delete t; }); return t; } private: std::vector&lt;Handler&gt; deleters; };</span></span></code> </pre><br>  <code>GC</code>    <code>Journey</code> ,      .    :      ,       . <br><br><h2>  findings </h2><br> ,           : <br><ol><li>     /. </li><li>    . </li><li>  . </li><li> ,      . </li><li>  ‚Äì         :  ,  ,      . . </li></ol><br>       ,     .     ,       .          ,   . <br><br>      ,     .       :  , , , UI,  ,   .       ,            . <br><br>          .    ! ,     . <br><br><div style="text-align:center;"><img src="http://habrastorage.org/files/535/5ac/710/5355ac710de64bd6a9d4dc2e7d1e71c6.jpeg" width="640"></div><br><br>  Code <br> <a href="https://github.com/gridem/Synca">github.com/gridem/Synca</a> <br> <a href="https://bitbucket.org/gridem/synca">bitbucket.org/gridem/synca</a> <br><br>  C++ Party, Yandex <br> <a href="https://tech.yandex.ru/events/cpp-party/march-msk/talks/1761/">tech.yandex.ru/events/cpp-party/march-msk/talks/1761</a> <br><br>  C++ User Group <br> <a href="http://youtu.be/uUQX5QS1CCg">youtu.be/uUQX5QS1CCg</a> <br> <a href="http://habrahabr.ru/post/212793/">habrahabr.ru/post/212793</a> <br><br>  Literature <br> [1] :    <a href="http://habrahabr.ru/post/201826/">habrahabr.ru/post/201826</a> <br> [2]  Akka- <a href="http://doc.akka.io/docs/akka/2.1.4/scala/scheduler.html">doc.akka.io/docs/akka/2.1.4/scala/scheduler.html</a> </div><p>Source: <a href="https://habr.com/ru/post/240525/">https://habr.com/ru/post/240525/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../240511/index.html">How to identify losses in sales</a></li>
<li><a href="../240517/index.html">Where is the minimum Hello World limit on AVR?</a></li>
<li><a href="../240519/index.html">Persistent Cartesian tree by implicit key</a></li>
<li><a href="../240521/index.html">Anxiety Symptoms Telegram</a></li>
<li><a href="../240523/index.html">How to Start a Startup - Business Course by Y Combinator</a></li>
<li><a href="../240531/index.html">Visual bookmarks in Opera 25 for computers</a></li>
<li><a href="../240533/index.html">SMS thermometer from a bunch of Google script, Google Doc, Wolfram-Alpha and Sms.ru</a></li>
<li><a href="../240535/index.html">Recording the first lecture of the Android Course from MasterUp</a></li>
<li><a href="../240537/index.html">Smart Listing Generator, EnumGenerator</a></li>
<li><a href="../240539/index.html">Duo.js is a new generation of frontend package manager.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>