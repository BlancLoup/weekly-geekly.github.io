<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hierarchical models in Qt</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I continue the theme of creating models using Qt MV. Last time there was a critical article on how to do it. Go to the positive part. 

 To create fla...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hierarchical models in Qt</h1><div class="post__text post__text-html js-mediator-article">  I continue the theme of creating models using Qt MV.  <a href="http://habrahabr.ru/post/171443/">Last time there</a> was a critical article on how to do it.  Go to the positive part. <br><br>  To create flat models of lists and tables, you can use <a href="http://qt-project.org/doc/qt-5.0/qtcore/qabstractlistmodel.html">QAbstractListModel</a> and <a href="http://qt-project.org/doc/qt-5.0/qtcore/qabstracttablemodel.html">QAbstractTableModel</a> blanks.  Bringing them to readiness is not a big deal, so there is no need to consider them in detail. <br><br>  Creating hierarchical models is a more difficult task.  About her and will be discussed in this article. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In general, Qt allows you to create not only tree models, but also models of more complex configurations and dimensions.  For example, a table in which each element is grouped for a subtable.  Despite this, in most cases, when people talk about hierarchical models, they mean trees.  It is the process of creating trees that I want to highlight. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/f27/8de/370/f278de370fdf230c79d8e8202aa132b2.png"></div><h6>  Figure: Table in the table </h6><br>  Another introductory note concerns the essence of the model, which I will create as an example.  I wanted to choose something specific and universal, so I decided to create a model for the example that maps the file system.  It does not suffer from completeness and completeness, so hardly anyone wants to use it seriously (especially since there is already a <a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qfilesystemmodel.html">QFileSystemModel</a> ), but for example it is quite suitable.  In the next article, if there is one, around this model I am going to build several proxies. <br><br><h4>  Design </h4><img src="https://habrastorage.org/storage2/d1a/ff1/082/d1aff1082aefa4f11793f4606010af45.png" align="right">  First of all, it is necessary to determine the <i>internal data structure</i> .  Here I would highlight 2 main areas: <br><ul><li> Models with well-defined structure or small nesting. <br>  An example would be the property editor in Qt Designer.  In this case, all the information about the position of a particular model element can be stored in the index itself ( <a href="http://qt-project.org/doc/qt-5.0/qtcore/qmodelindex.html">QModelIndex</a> ) using <code>internalId</code> .  In the case of a property editor, you can save the property group identifier in <code>internalId</code> . <br>  Another example is a notebook model.  Obviously, the entry ‚Äú <i>Lol4t0</i> ‚Äù belongs to the <i>Lo</i> subgroup, which, in turn, belongs to the group <i>L.</i>  And back - the <i>Lo</i> group includes those and only those records that begin with the prefix " <i>Lo</i> ".  This is what I call a well-defined structure. <br><br></li><li>  Models without a well-defined structure.  The file system model refers to just that.  Knowing only the name of the <i>Documents</i> folder, generally speaking, it is impossible to determine which folder it is in and which folders it contains. </li></ul><br>  Additional data on the organization of data can be used in the design, so the creation of models of the first type usually does not cause problems.  The article deals with models of the second type. <br><br>  All kinds of data that you have to deal with when developing tree models are actually similar.  Therefore, it is not difficult to isolate some general recommendations regarding the internal organization of the data: <br><ul><li>  You must store node data </li><li>  There must be a one-to-one relationship between the <code>QModelIndex</code> and the element of the internal data structure. </li><li>  Each node must contain references to the parent node and child nodes. </li></ul><br>  In the case of the file system model, I will use <a href="http://qt-project.org/doc/qt-5.0/qtcore/qfileinfo.html">QFileInfo</a> to store information about each node.  In addition, you will need to store information about the child nodes and the parent node.  Additionally, you will need information about whether a search for child nodes was performed or not. <br><br><h6>  Business data ( <code>QFileInfo</code> ) had to wrap service information.  In most cases, without this it is impossible to do.  If the domain data already supports the hierarchy, you can use it, but I have never met the case where the source data would contain all the necessary information. </h6><br>  We get the following internal data structure: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FilesystemModel</span></span></span><span class="hljs-class">:</span></span>:NodeInfo { QFileInfo fileInfo; <span class="hljs-comment"><span class="hljs-comment">//    QVector&lt;NodeInfo&gt; children; //    NodeInfo* parent; //     bool mapped; //     . };</span></span></code> </pre><br>  When creating a tree, I will construct a list of nodes corresponding to the root objects of file systems, and I will load their children as necessary: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> QVector&lt;NodeInfo&gt; NodeInfoList; NodeInfoList _nodes; <span class="hljs-comment"><span class="hljs-comment">//     </span></span></code> </pre><br>  There will be several columns in the tree: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Columns { RamificationColumn, <span class="hljs-comment"><span class="hljs-comment">// ,    ,  . //     QTreeView NameColumn = RamificationColumn, //     ModificationDateColumn, //      SizeColumn, //     ColumnCount //   };</span></span></code> </pre><br><br><h4>  Minimal implementation </h4>  Once you have decided on the structure of the data storage, you can begin to implement the model. <br>  If you need to implement a hierarchical model, then nothing remains but to inherit from <a href="http://qt-project.org/doc/qt-5.0/qtcore/qabstractitemmodel.html">QAbstractItemModel</a> .  In order to implement the simplest model, you need to write an implementation of all five functions: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> QModelIndex </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> row, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> column, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QModelIndex &amp;parent)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> QModelIndex </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QModelIndex &amp;child)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rowCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QModelIndex &amp;parent = QModelIndex())</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">columnCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QModelIndex &amp;parent = QModelIndex())</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> QVariant </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QModelIndex &amp;index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> role = Qt::DisplayRole)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>;</code> </pre><br>  However, the implementation of the first two usually accounts for 80% of the problems associated with the creation of hierarchical models.  The point is that they are called very often, so the use of algorithms in them is more complicated than O (1), generally speaking, it is not desirable. <br><br>  I suggest storing a pointer to <code>NodeInfo</code> in the <code>internalPointer</code> index.  In most cases, this is exactly what they do.  In the implementation of <code>index</code> in no case can not return non-existent indexes.  You do not need to rely on the fact that no one will request such an index.  To check the existence of an index there is a very convenient function <code>hasIndex</code> . <br><pre> <code class="cpp hljs">QModelIndex FilesystemModel::index(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> row, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> column, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QModelIndex &amp;parent) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasIndex(row, column, parent)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QModelIndex(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!parent.isValid()) { <span class="hljs-comment"><span class="hljs-comment">//     return createIndex(row, column, const_cast&lt;NodeInfo*&gt;(&amp;_nodes[row])); } NodeInfo* parentInfo = static_cast&lt;NodeInfo*&gt;(parent.internalPointer()); return createIndex(row, column, &amp;parentInfo-&gt;children[row]); }</span></span></code> </pre><br>  With <code>parent</code> things are a little more complicated.  Despite the fact that at a given index you can always find the <code>NodeInfo</code> parent element, to create an index of the parent element it is also necessary to know its position among the "brothers". <br><br>  There are two options - either to store information about its position with each node, or to determine this position again each time.  The trouble with the first is that when adding and removing nodes, all the underlying nodes will have to be updated.  What I really did not want.  Therefore, I chose the second option, despite its computational complexity.  In a real model, I would adhere to this choice until I could prove that it was a bottleneck. <br><pre> <code class="cpp hljs">QModelIndex FilesystemModel::parent(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QModelIndex &amp;child) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!child.isValid()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QModelIndex(); } NodeInfo* childInfo = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;NodeInfo*&gt;(child.internalPointer()); NodeInfo* parentInfo = childInfo-&gt;parent; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentInfo != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// parent      return createIndex(findRow(parentInfo), RamificationColumn, parentInfo); } else { return QModelIndex(); } } int FilesystemModel::findRow(const NodeInfo *nodeInfo) const { const NodeInfoList&amp; parentInfoChildren = nodeInfo-&gt;parent != 0 ? nodeInfo-&gt;parent-&gt;children: _nodes; NodeInfoList::const_iterator position = qFind(parentInfoChildren, *nodeInfo); return std::distance(parentInfoChildren.begin(), position); }</span></span></code> </pre><br>  The implementation of <code>rowCount</code> and <code>columnCount</code> trivial: in the first case, we can always determine the number of child nodes from <code>NodeInfo::children::size</code> , and the number of columns is fixed. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> FilesystemModel::rowCount(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QModelIndex &amp;parent) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!parent.isValid()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _nodes.size(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> NodeInfo* parentInfo = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> NodeInfo*&gt;(parent.internalPointer()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parentInfo-&gt;children.size(); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> FilesystemModel::columnCount(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QModelIndex &amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ColumnCount; }</code> </pre><br>  The implementation of <code>data</code> also not difficult, all the necessary information is obtained from <code>QFileInfo</code> .  At a minimum, you need to implement support for <code>Qt::DisplayRole</code> roles to display text in <code>view</code> and <code>Qt::EditRole</code> , if editing is provided.  Data received from the model with the role of <code>Qt::EditRole</code> will be loaded into the editor.  Moreover, the data that the model returns when queried with <code>Qt::DisplayRole</code> and <code>Qt::EditRole</code> may differ.  For example, we will display files without extensions, and edit - with the extension. <br><div class="spoiler">  <b class="spoiler_title">Data function code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">QVariant FilesystemModel::data(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QModelIndex &amp;index, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> role) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!index.isValid()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QVariant(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> NodeInfo* nodeInfo = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;NodeInfo*&gt;(index.internalPointer()); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QFileInfo&amp; fileInfo = nodeInfo-&gt;fileInfo; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (index.column()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NameColumn: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nameData(fileInfo, role); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ModificationDateColumn: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (role == Qt::DisplayRole) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fileInfo.lastModified(); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SizeColumn: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (role == Qt::DisplayRole) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fileInfo.isDir()? QVariant(): fileInfo.size(); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QVariant(); } QVariant FilesystemModel::nameData(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QFileInfo &amp;fileInfo, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> role) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (role) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Qt::EditRole: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fileInfo.fileName(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Qt::DisplayRole: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileInfo.isRoot()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fileInfo.absoluteFilePath(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileInfo.isDir()){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fileInfo.fileName(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fileInfo.completeBaseName(); } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QVariant(); } Q_UNREACHABLE(); }</code> </pre><br>  In order for the model to ‚Äúlive‚Äù, it remains to fill in the root nodes: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> FilesystemModel::fetchRootDirectory() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QFileInfoList drives = QDir::drives(); qCopy(drives.begin(), drives.end(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter(_nodes)); } FilesystemModel::FilesystemModel(QObject *parent) : QAbstractItemModel(parent) { fetchRootDirectory(); }</code> </pre><br></div></div><br>  Now you can display the model using <code>QTreeView</code> and see the result. <br><br>  However, what is it!  Root elements cannot be expanded. <br>  Indeed, the data for them has not yet been downloaded. <br><br><h4>  Dynamic data loading </h4>  To implement automatic loading of data as needed, Qt implements the following API: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canFetchMore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QModelIndex &amp;parent)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchMore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QModelIndex &amp;parent)</span></span></span></span>;</code> </pre><br>  The first function should return <code>true</code> , when data for a given parent element can be loaded, and the second one can actually load data. <br>  <code>NodeInfo::mapped</code> comes in handy <code>NodeInfo::mapped</code> .  Data can be loaded when <code>mapped == false</code> . <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> FilesystemModel::canFetchMore(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QModelIndex &amp;parent) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!parent.isValid()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> NodeInfo* parentInfo = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> NodeInfo*&gt;(parent.internalPointer()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !parentInfo-&gt;mapped; }</code> </pre><br>  For loading we will use the functions provided by <code>QDir</code> .  In this case, do not forget to use <code>beginInsertRows</code> and <code>endInsertRows</code> when changing the number of rows.  Unfortunately, <code>QTreeView</code> loads only when trying to expand a node, and does not try to load new data when scrolling through the list.  Therefore, nothing remains as to download the entire list of child nodes in its entirety.  You can correct this behavior, perhaps, by creating your own display component. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> FilesystemModel::fetchMore(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QModelIndex &amp;parent) { NodeInfo* parentInfo = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;NodeInfo*&gt;(parent.internalPointer()); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QFileInfo&amp; fileInfo = parentInfo-&gt;fileInfo; QDir dir = QDir(fileInfo.absoluteFilePath()); QFileInfoList children = dir.entryInfoList(QStringList(), QDir::AllEntries | QDir::NoDotAndDotDot, QDir::Name); beginInsertRows(parent, <span class="hljs-number"><span class="hljs-number">0</span></span>, children.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>); parentInfo-&gt;children.reserve(children.size()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QFileInfo&amp; entry: children) { <span class="hljs-function"><span class="hljs-function">NodeInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nodeInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(entry, parentInfo)</span></span></span></span>; nodeInfo.mapped = !entry.isDir(); parentInfo-&gt;children.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(nodeInfo)); } parentInfo-&gt;mapped = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; endInsertRows(); }</code> </pre><br>  We do the download, run the program, but the result is not.  Root nodes are still impossible to deploy.  The thing is, <code>QTreeView</code> uses the <code>hasChildren</code> function to check if a node has children, and assumes that only those nodes that have children can be expanded.  <code>hasChildren</code> , by default, returns <code>true</code> only when the number of rows and the number of columns for the parent node is greater than 0. <br><br>  In this case, this behavior does not fit.  Override the <code>hasChildren</code> function so that it returns <code>true</code> for the specified node, when it definitely has or can have (when <code>mapped ==false</code> ) child nodes. <br><br>  You can accurately determine if the directory is empty, but it is quite an expensive operation, whether to use it is up to you. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> FilesystemModel::hasChildren(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QModelIndex &amp;parent) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parent.isValid()) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> NodeInfo* parentInfo = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> NodeInfo*&gt;(parent.internalPointer()); Q_ASSERT(parentInfo != <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!parentInfo-&gt;mapped) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;<span class="hljs-comment"><span class="hljs-comment">//QDir(parentInfo-&gt;fileInfo.absoluteFilePath()).count() &gt; 0; --   ,     } } return QAbstractItemModel::hasChildren(parent); }</span></span></code> </pre><br>  Now the model works, you can view the folders. <br><br>  I think this can be finished, for completeness, one could add the function of renaming files and folders, creating directories and tracking file system changes.  But this is clearly beyond the allowed article on Habr.  I posted a slightly more advanced example on <a href="https://github.com/Lol4t0/tree-model-example">GitHub</a> . </div><p>Source: <a href="https://habr.com/ru/post/172187/">https://habr.com/ru/post/172187/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../172165/index.html">Reflected XSS on the Pentagon subdomain (and what it led to)</a></li>
<li><a href="../172167/index.html">Wheelbarrow Bond, or Virturilka taxis!</a></li>
<li><a href="../172177/index.html">Database architecture: unification (for example, ERP)</a></li>
<li><a href="../172183/index.html">Pirate Bay advertising on billboard in Serbia</a></li>
<li><a href="../172185/index.html">Where is my robot?</a></li>
<li><a href="../172193/index.html">Professional Doctorate in Engineering in the Netherlands</a></li>
<li><a href="../172197/index.html">Frontender Magazine: let's talk about the frontend</a></li>
<li><a href="../172199/index.html">Connect to the IT Camp ‚ÄúNew Private Cloud‚Äù online broadcast today at 10:15</a></li>
<li><a href="../172201/index.html">Kinect Fusion can help surgeons</a></li>
<li><a href="../172203/index.html">Lenovo ThinkPad Twist S230u Ultrabook Video Review</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>