<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>DynamicXml: a "dynamic" wrapper for working with XML data</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I once wrote that, in spite of my love for static typing, in some scenarios the advantages of the freedom that dynamic typing gives may outweigh the d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>DynamicXml: a "dynamic" wrapper for working with XML data</h1><div class="post__text post__text-html js-mediator-article">  I once wrote that, in spite of my love for static typing, in some scenarios the advantages of the freedom that dynamic typing gives may outweigh the disadvantages associated with it.  Last time there was a discussion about <a href="http://sergeyteplyakov.blogspot.com/2010/12/dynamic-linq.html">Dynamic LINQ</a> , and this time it will be about using the new C # 4.0 feature called <b>dynamic</b> to work with such initially weakly typed data like XML. <br><br>  NOTE <br>  The source code for the DynamicXml library discussed in this article is available on <a href="https://github.com/SergeyTeplyakov/DynamicXml">github</a> <br><br><h4>  Introduction </h4><br>  Starting from version 4.0, C # added support for dynamic programming, thanks to a new static type called <b>dynamic</b> .  Essentially, the use of this keyword tells the compiler to generate all the necessary code so that the binding process and dispatch operations are performed at runtime, instead of determining all these characteristics at compile time.  At the same time, the compiler generates all the necessary code using the DLR library - Dynamic Language Runtime (*), which was originally created when designing the Iron Python programming language and later became part of the .Net Framework 4.0, as the basis for implementing dynamic programming languages, as well as for interactions between them. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Despite the appearance of the <b>dynamic</b> keyword, the C # programming language remained basically statically typed;  you still need to explicitly indicate that the decision about what will happen to this code is delayed until runtime.  In addition, no one assumes that this opportunity will be used daily;  This function is primarily intended for interacting with other dynamically typed languages ‚Äã‚Äãsuch as Iron Python, Iron Ruby, as well as for interacting with a weakly typed environment such as VSTO (Visual Studio Tools for Office) and other COM APIs.  Another classic example of using dynamic is creating ‚Äúdynamic‚Äù wrappers above objects.  A very well-known example is the creation of a shell to access private or protected members of a class (**);  Another equally well-known example is the creation of a dynamic wrapper for accessing XML data.  That's it on the implementation of the second possibility, we will stop here. <br><br><h4>  A simple example of reading XML data </h4><br>  So let's assume that we have a line that contains the following data (***): <br><br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">&lt;</font> <font color="#800000">books</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">book</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">title</font> <font color="#0000ff">&gt;</font> Mortal Engines <font color="#0000ff">&lt;/</font> <font color="#800000">title</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">author</font> <font color="#ff0000">name</font> <font color="#0000ff">=""</font> <font color="#ff0000">Philip</font> <font color="#ff0000">Reeve</font> <font color="#0000ff">""</font> <font color="#0000ff">/&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">book</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">book</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">title</font> <font color="#0000ff">&gt;</font> The Talisman <font color="#0000ff">&lt;/</font> <font color="#800000">title</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">author</font> <font color="#ff0000">name</font> <font color="#0000ff">=""</font> <font color="#ff0000">Stephen</font> <font color="#ff0000">King</font> <font color="#0000ff">""</font> <font color="#0000ff">/&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">author</font> <font color="#ff0000">name</font> <font color="#0000ff">=""</font> <font color="#ff0000">Peter</font> <font color="#ff0000">Straub</font> <font color="#0000ff">""</font> <font color="#0000ff">/&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">book</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">books</font> <font color="#0000ff">&gt;</font></font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  And our task is to write a simple code that will read and process this data.  Of course, in some cases it is more reasonable to deserialize all this stuff into some business logic object (in this case, a list of entities such as <b>Book</b> ) using the <b>XmlSerializer</b> class and manipulate this business object, however, in many cases, a more lightweight solution will do for example, based on LINQ 2 XML. <br><br>  If we assume that the line above is contained in a variable named books, then you can use a very simple code to get the name to get some data: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">var</font> element = <font color="#2B91AF">XElement</font> .Parse(books); <br> <font color="#0000ff">string</font> firstBooksTitle = <br> element.Element( <font color="#A31515">"book"</font> ).Element( <font color="#A31515">"title"</font> ).Value; <br> Assert.That(firstBooksTitle, Is.EqualTo( <font color="#A31515">"Mortal Engines"</font> )); <br> <br> <font color="#0000ff">string</font> firstBooksAuthor = <br> element.Element( <font color="#A31515">"book"</font> ).Element( <font color="#A31515">"author"</font> ). <font color="#2B91AF">Attribute</font> ( <font color="#A31515">"name"</font> ).Value; <br> Assert.That(firstBooksAuthor, Is.EqualTo( <font color="#A31515">"Philip Reeve"</font> )); <br> <br> <font color="#0000ff">string</font> secondBooksTitle = <br> element.Elements().ElementAt(1).Element( <font color="#A31515">"title"</font> ).Value; <br> Assert.That(secondBooksTitle, Is.EqualTo( <font color="#A31515">"The Talisman"</font> ));</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  I have absolutely nothing against explicit use of <b>XElement</b> , moreover, this option is quite simple and elegant, but nevertheless this code is not without flaws.  Firstly, it‚Äôs quite verbose, and secondly, it‚Äôs not entirely honest about error handling: if the <b>books</b> variable doesn‚Äôt have an element named <b>book</b> or an element named <b>title,</b> we get a <b>NullReferenceException</b> .  So this code needs to be finalized with a file, which somewhat complicates its reading, understanding and maintenance. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">//  Dynamic Wrapper   XElement</font> <br> dynamic dynamicElement = <font color="#008000">// ...</font> <br> <br> <font color="#008000">//    </font> <br> <font color="#0000ff">string</font> firstBooksTitle = dynamicElement.book.title; <br> Assert.That(firstBooksTitle, Is.EqualTo( <font color="#A31515">"Mortal Engines"</font> )); <br> <br> <font color="#008000">//   ,  ,     </font> <br> <font color="#0000ff">string</font> firstBooksAuthor = dynamicElement.book.author[ <font color="#A31515">"name"</font> ]; <br> Assert.That(firstBooksAuthor, Is.EqualTo( <font color="#A31515">"Philip Reeve"</font> )); <br> <br> <font color="#008000">//   ,   ,     </font> <br> <font color="#0000ff">string</font> secondBooksTitle = dynamicElement.book[1].title; <br> Assert.That(secondBooksTitle, Is.EqualTo( <font color="#A31515">"The Talisman"</font> ));</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  We still need to use an indexer to access attribute values, since we have to separate access to an element from access to an attribute, but since, as we will see later, everything is completely in our hands, we can make another decision and implement access to the attribute using another syntax.  Nevertheless, the resulting syntax is simpler and more understandable than the code with direct use of LINQ 2 XML and we have to answer one simple question: what exactly should be hidden behind the comment ‚Äú <i>we get Dynamic Wrapper over the XElement object</i> ‚Äù in order for such street magic to be is possible. <br><br><h4>  Creating a "dynamic" shell for reading XML data </h4><br><br>  The easiest way to create a dynamic shell, which at the same time will have a fairly wide functionality, is to use the <b>DynamicObject</b> class from the <b>System.Dynamic</b> namespace.  This class contains several virtual functions of the <b>TryXXX</b> type that allow you to "intercept" all basic actions with your dynamic object that will occur with it at run time, including method calls, accessing properties, type conversion, and many others. <br><br>  Thus, all we need to do is create a class derived from <b>DynamicObject</b> , which would take an <b>XElement</b> object as a constructor parameter and override a number of helper methods: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">/// " "  XElement</font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">class</font> DynamicXElementReader : DynamicObject <br> { <br> <font color="#0000ff">private</font> <font color="#0000ff">readonly</font> <font color="#2B91AF">XElement</font> element; <br> <br> <font color="#0000ff">private</font> DynamicXElementReader( <font color="#2B91AF">XElement</font> element) <br> { <br> <font color="#0000ff">this</font> .element = element; <br> } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> dynamic CreateInstance( <font color="#2B91AF">XElement</font> element) <br> { <br> Contract.Requires(element != <font color="#0000ff">null</font> ); <br> Contract.Ensures(Contract.Result&lt; <font color="#0000ff">object</font> &gt;() != <font color="#0000ff">null</font> ); <br> <br> <font color="#0000ff">return</font> <font color="#0000ff">new</font> DynamicXElementReader(element); <br> } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  The use of the factory method in this case is due to the fact that it more clearly shows the context of the use of this class;  In addition to this method, the code of the DynamicXml library also contains a static class with extension methods that allow you to create instances of the dynamic shell more conveniently.  The use of contracts (Code Contracts library) in this case merely simplifies the creation of such library classes, simplifies testing and documentation, and the static analyzer allows you to find errors during compilation.  This is my personal preference, but if this approach seems unattractive to you (although it‚Äôs even in vain) using the magic search / replace tool, you can replace contracts with a convenient mechanism for checking input parameters. <br><br>  Now let's go back to the implementation of the <b>DynamicXElementReader</b> class.  First, a bit of theory: any reference to a property or a class method of a descendant from <b>DynamicObject</b> occurs in two steps: first, a search is made for the corresponding method or property with the same name in that same heir, and then the corresponding method is called, in which you can handle the absence of this member dynamically.  Since no wrapper will ever provide absolutely all conceivable and inconceivable functionality (and in most cases this is not necessary), it is necessary to ensure that the underlying <b>XElement is</b> obtained from the wrapper.  In addition, as we saw in the previous example, we need to make two indexers: one must take an <b>int</b> and return a sub-element, and the second must take a string (or, as we will see later on <b>XName</b> ) and return an attribute. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">public</font> <font color="#0000ff">class</font> DynamicXElementReader : DynamicObject <br> { <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///  true,      .</font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#008000">/// &lt;remarks&gt;</font> <br> <font color="#008000">///  Pure        </font> <br> <font color="#008000">/// &lt;/remarks&gt;</font> <br> [Pure] <br> <font color="#0000ff">public</font> <font color="#0000ff">bool</font> HasParent() <br> { <br> <font color="#0000ff">return</font> element.Parent != <font color="#0000ff">null</font> ; <br> } <br> <br> <font color="#0000ff">public</font> dynamic <font color="#0000ff">this</font> [XName name] <br> { <br> <font color="#0000ff">get</font> <br> { <br> Contract.Requires(name != <font color="#0000ff">null</font> ); <br> <br> <font color="#2B91AF">XAttribute</font> attribute = element. <font color="#2B91AF">Attribute</font> (name); <br> <br> <font color="#0000ff">if</font> (attribute == <font color="#0000ff">null</font> ) <br> <font color="#0000ff">throw</font> <font color="#0000ff">new</font> InvalidOperationException( <br> <font color="#A31515">"Attribute not found. Name: "</font> + name.LocalName); <br> <br> <font color="#0000ff">return</font> attribute.AsDynamic(); <br> } <br> } <br> <br> <font color="#0000ff">public</font> dynamic <font color="#0000ff">this</font> [ <font color="#0000ff">int</font> idx] <br> { <br> <font color="#0000ff">get</font> <br> { <br> <br> Contract.Requires(idx &gt;= 0, <font color="#A31515">"Index should be greater or equals to 0"</font> ); <br> Contract.Requires(idx == 0 || HasParent(), <br> <font color="#A31515">"For non-zero index we should have parent element"</font> ); <br> <br> <font color="#008000">//          </font> <br> <font color="#0000ff">if</font> (idx == 0) <br> <font color="#0000ff">return</font> <font color="#0000ff">this</font> ; <br> <br> <font color="#008000">//       ""  .</font> <br> <font color="#008000">//   ,      </font> <br> <font color="#0000ff">var</font> parent = element.Parent; <br> Contract.Assume(parent != <font color="#0000ff">null</font> ); <br> <br> <font color="#2B91AF">XElement</font> subElement = parent.Elements().ElementAt(idx); <br> <br> <font color="#008000">// subElement     null,   ElementAt </font> <br> <font color="#008000">// ,       .</font> <br> <font color="#008000">//       ,   </font> <br> <font color="#008000">//       Contract.Assume</font> <br> Contract.Assume(subElement != <font color="#0000ff">null</font> ); <br> <br> <font color="#0000ff">return</font> CreateInstance(subElement); <br> } <br> } <br> <br> <font color="#0000ff">public</font> <font color="#2B91AF">XElement</font> <font color="#2B91AF">XElement</font> { <font color="#0000ff">get</font> { <font color="#0000ff">return</font> element; } } <br> <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  The first indexer takes an <b>XName</b> as a parameter and is designed to get the attribute of the current element by its name.  The return type is also dynamic, and the actual return value is obtained by calling the <b>AsDynamic</b> extension method on the <b>XAttribute</b> object.  In principle, no one bothers to use the <b>XAttribute</b> type as the return type, but in this case, to obtain the immediate value of the attribute, you will have to additionally refer to the <b>Value</b> property, the resulting value, or use an explicit type conversion.  In general, the implementation of a dynamic shell for attributes is much simpler, and implemented in a similar way. <br><br>  Now let's move on to implementing the two main (for this class) virtual methods of the <b>DynamicObject</b> class: the <b>TryGetMember</b> method ‚Äî which is responsible for accessing a property or field of the type <b>dynamicObject.Member</b> , as well as the <b>TryConvert</b> method ‚Äî which is called during an implicit type conversion from a dynamic typed object to a static typed, <b>string value = dynamicObject</b> . <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">public</font> <font color="#0000ff">class</font> DynamicXElementReader : DynamicObject <br> { <br> <font color="#008000">// not used</font> <br> <font color="#0000ff">private</font> <font color="#2B91AF">XElement</font> element; <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> dynamic CreateInstance( <font color="#2B91AF">XElement</font> ) { <font color="#0000ff">return</font> <font color="#0000ff">null</font> ;} <br> <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///          :</font> <br> <font color="#008000">/// SomeType variable = dynamicElement;</font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">override</font> <font color="#0000ff">sealed</font> <font color="#0000ff">bool</font> TryConvert(ConvertBinder binder, <font color="#0000ff">out</font> <font color="#0000ff">object</font> result) <br> { <br> <font color="#008000">//      XElement </font> <br> <font color="#008000">//  xml-</font> <br> <font color="#0000ff">if</font> (binder.ReturnType == <font color="#0000ff">typeof</font> ( <font color="#2B91AF">XElement</font> )) <br> { <br> result = element; <br> <font color="#0000ff">return</font> <font color="#0000ff">true</font> ; <br> } <br> <br> <font color="#008000">//       </font> <br> <font color="#008000">//        </font> <br> <font color="#0000ff">string</font> underlyingValue = element.Value; <br> result = <font color="#2B91AF">Convert</font> .ChangeType(underlyingValue, binder.ReturnType, <br> CultureInfo.InvariantCulture); <br> <br> <font color="#0000ff">return</font> <font color="#0000ff">true</font> ; <br> } <br> <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///         </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">override</font> <font color="#0000ff">bool</font> TryGetMember(GetMemberBinder binder, <font color="#0000ff">out</font> <font color="#0000ff">object</font> result) <br> { <br> <font color="#0000ff">string</font> binderName = binder.Name; <br> Contract.Assume(binderName != <font color="#0000ff">null</font> ); <br> <br> <font color="#008000">//       ,</font> <br> <font color="#008000">//      </font> <br> <font color="#2B91AF">XElement</font> subelement = element.Element(binderName); <br> <font color="#0000ff">if</font> (subelement != <font color="#0000ff">null</font> ) <br> { <br> result = CreateInstance(subelement); <br> <font color="#0000ff">return</font> <font color="#0000ff">true</font> ; <br> } <br> <br> <font color="#008000">//       ,    </font> <br> <font color="#008000">//  </font> <br> <font color="#0000ff">return</font> <font color="#0000ff">base</font> .TryGetMember(binder, <font color="#0000ff">out</font> result); <br> } <br> <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  As mentioned above, the <b>TryConvert</b> method <b>is</b> called whenever any attempt is made to convert an xml element or one of its sub-elements to the specified type.  Since we can easily get the value of the current xml element, all that is needed to implement this method is to call the <b>ChangeType</b> of the <b>Convert</b> class;  the only exception is the <b>XElement</b> type, which is processed separately and allows you to get the underlying <b>XElement</b> directly. <br><br>  The <b>TryGetMember</b> method <b>is</b> also quite simple: first we get the name of the member that the user code is trying to access, and then we try to find an element with this name.  If the specified element is found, we create a dynamic shell and return it via the output parameter result.  Otherwise, we call the base version, which leads to the exception of the runtime, which will say that the requested member was not found. <br><br>  All this allows you to use the shell as follows: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">//        bookXElement</font> <br> <font color="#0000ff">string</font> firstBooksElement = dynamicElement.book; <br> <font color="#2B91AF">Console</font> .WriteLine( <font color="#A31515">"First books element: {0}"</font> , firstBooksElement); <br> <br> <font color="#008000">//         </font> <br> <font color="#0000ff">string</font> firstBooksTitle = dynamicElement.book.title; <br> <font color="#2B91AF">Console</font> .WriteLine( <font color="#A31515">"First books title: {0}"</font> , firstBooksTitle); <br> <br> <font color="#008000">//          int</font> <br> <font color="#0000ff">int</font> firstBooksPageCount = dynamicElement.book.pages; <br> <font color="#2B91AF">Console</font> .WriteLine( <font color="#A31515">"First books page count: {0}"</font> , firstBooksPageCount);</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  The result of the execution of this code: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">First books element: <font color="#0000ff">&lt;</font> <font color="#800000">book</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">title</font> <font color="#0000ff">&gt;</font> Mortal Engines <font color="#0000ff">&lt;/</font> <font color="#800000">title</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">author</font> <font color="#ff0000">name</font> <font color="#0000ff">="Philip Reeve"</font> <font color="#0000ff">/&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">pages</font> <font color="#0000ff">&gt;</font> 347 <font color="#0000ff">&lt;/</font> <font color="#800000">pages</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">book</font> <font color="#0000ff">&gt;</font> <br> <br> First books title: Mortal Engines <br> First books page count: 347 <br> First books author: Philip Reeve <br> Second books title: The Talisman</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br><h4>  Creating a "dynamic" shell to create / modify XML data </h4><br>  The reason for creating two classes, one responsible for reading the data, and the other for creating and modifying, is due to the fact that in the implementation of the <b>TryGetMember</b> method we cannot know in advance what the lower member is addressed to.  After all, if this access occurs to read the data, and the specified element is not in the original XML data, then the most logical behavior is to generate an exception, which says that the element with the specified name was not found.  This is exactly how the above implementation in the <b>DynamicXElementReader</b> class <b>behaves</b> .  However, we need a completely different behavior when creating / changing XML data: in this case, instead of generating an exception, we need to create an empty element with the specified name;  for it is quite logical to assume that there may not be (or rather, most likely there will not be) an element with the specified name in the created element. <br><br>  Thus, to the above read-only <b>DynamicXElementReader</b> class, we add another one, <b>DynamicXElementWriter</b> , whose task is to create and modify XML data.  However, since these two classes have a lot in common, for example, the implementation of the <b>TryConvert</b> method, as well as some auxiliary methods, such as HasParent, the actual code contains another auxiliary class <b>DynamixXElementBase</b> , which eliminates code duplication and simplifies the implementation of its descendants.  However, since it is somewhat more difficult to analyze code with an additional base class, I will not show it here. <br><br>  The main difference in the dynamic shell intended for creating / modifying XML data is the presence of setters for two indexers: one for changing the value of attributes, and the second for adding additional elements.  The second difference is the presence of two additional non-dynamic methods: <b>SetValue</b> and <b>SetAttributeValue</b> , which serve to change the value of the current element and its attributes. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">public</font> <font color="#0000ff">class</font> DynamicXElementWriter : DynamicObject <br> { <br> <font color="#008000">// ,     </font> <br> <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///    </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> SetValue( <font color="#0000ff">object</font> <font color="#0000ff">value</font> ) <br> { <br> Contract.Requires( <font color="#0000ff">value</font> != <font color="#0000ff">null</font> ); <br> <br> element.SetValue( <font color="#0000ff">value</font> ); <br> } <br> <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///    </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> SetAttributeValue(XName name, <font color="#0000ff">object</font> <font color="#0000ff">value</font> ) <br> { <br> Contract.Requires(name != <font color="#0000ff">null</font> ); <br> Contract.Requires( <font color="#0000ff">value</font> != <font color="#0000ff">null</font> ); <br> <br> element.SetAttributeValue(name, <font color="#0000ff">value</font> ); <br> } <br> <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///       </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#0000ff">public</font> dynamic <font color="#0000ff">this</font> [XName name] <br> { <br> <font color="#0000ff">get</font> <br> { <br> <font color="#008000">//    </font> <br> } <br> <br> <font color="#0000ff">set</font> <br> { <br> <font color="#008000">//         </font> <br> <font color="#008000">// XElement.SetAttributeValue,       </font> <br> element.SetAttributeValue(name, <font color="#0000ff">value</font> ); <br> } <br> <br> } <br> <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///     ""     </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#0000ff">public</font> dynamic <font color="#0000ff">this</font> [ <font color="#0000ff">int</font> idx] <br> { <br> <font color="#0000ff">get</font> <br> { <br> <font color="#008000">//    </font> <br> Contract.Requires(idx &gt;= 0, <font color="#A31515">"Index should be greater or equals to 0"</font> ); <br> Contract.Requires(idx == 0 || HasParent(), <br> <font color="#A31515">"For non-zero index we should have parent element"</font> ); <br> <br> <font color="#008000">//         </font> <br> <font color="#0000ff">if</font> (idx == 0) <br> <font color="#0000ff">return</font> <font color="#0000ff">this</font> ; <br> <br> <font color="#008000">//       ""  .</font> <br> <font color="#008000">//   ,      </font> <br> <font color="#0000ff">var</font> parent = element.Parent; <br> Contract.Assume(parent != <font color="#0000ff">null</font> ); <br> <br> <font color="#008000">//      ""   ,</font> <br> <font color="#008000">//   </font> <br> <font color="#2B91AF">XElement</font> subElement = parent.Elements(element.Name).ElementAtOrDefault(idx); <br> <font color="#0000ff">if</font> (subElement == <font color="#0000ff">null</font> ) <br> { <br> <font color="#2B91AF">XElement</font> sibling = parent.Elements(element.Name).First(); <br> subElement = <font color="#0000ff">new</font> <font color="#2B91AF">XElement</font> (sibling.Name); <br> parent.Add(subElement); <br> } <br> <br> <font color="#0000ff">return</font> CreateInstance(subElement); <br> } <br> <br> <font color="#0000ff">set</font> <br> { <br> Contract.Requires(idx &gt;= 0, <font color="#A31515">"Index should be greater or equals to 0"</font> ); <br> Contract.Requires(idx == 0 || HasParent(), <br> <font color="#A31515">"For non-zero index we should have parent element"</font> ); <br> <br> <font color="#008000">//        </font> <br> <font color="#008000">//    ,     </font> <br> <font color="#008000">//  </font> <br> dynamic d = <font color="#0000ff">this</font> [idx]; <br> d.SetValue( <font color="#0000ff">value</font> ); <br> <font color="#0000ff">return</font> ; <br> } <br> <br> } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  The implementation of getters is very similar to the previous implementation, especially for the indexer that accepts XName and is designed to work with attributes.  The implementation of an indexer that accepts an integer is somewhat more complicated, since even the getter contains additional logic for creating an additional ‚Äúbrother‚Äù if there is no such element yet.  The implementation of the setters in both cases is rather trivial. <br><br>  Another significant difference is the implementation of the <b>TryGetMember</b> method, as well as the presence of an additional TrySetMember method, which will be called if the xml value of the element is set: <b>dynamicElement.SubElement = value</b> . <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///       </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">override</font> <font color="#0000ff">bool</font> TryGetMember(GetMemberBinder binder, <font color="#0000ff">out</font> <font color="#0000ff">object</font> result) <br> { <br> <font color="#0000ff">string</font> binderName = binder.Name; <br> Contract.Assume(binderName != <font color="#0000ff">null</font> ); <br> <br> <font color="#008000">//     </font> <br> <font color="#2B91AF">XElement</font> subelement = element.Element(binderName); <br> <br> <font color="#008000">//     ,     </font> <br> <font color="#008000">//     </font> <br> <font color="#0000ff">if</font> (subelement == <font color="#0000ff">null</font> ) <br> { <br> subelement = <font color="#0000ff">new</font> <font color="#2B91AF">XElement</font> (binderName); <br> element.Add(subelement); <br> } <br> <br> result = CreateInstance(subelement); <br> <font color="#0000ff">return</font> <font color="#0000ff">true</font> ; <br> } <br> <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///       </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">override</font> <font color="#0000ff">bool</font> TrySetMember(SetMemberBinder binder, <font color="#0000ff">object</font> <font color="#0000ff">value</font> ) <br> { <br> Contract.Assume(binder != <font color="#0000ff">null</font> ); <br> Contract.Assume(! <font color="#0000ff">string</font> .IsNullOrEmpty(binder.Name)); <br> Contract.Assume( <font color="#0000ff">value</font> != <font color="#0000ff">null</font> ); <br> <br> <font color="#0000ff">string</font> binderName = binder.Name; <br> <br> <font color="#008000">//       , </font> <br> <font color="#008000">//   ,    ;</font> <br> <font color="#008000">//      XElement.SetElementValue, </font> <br> <font color="#008000">//     </font> <br> <font color="#0000ff">if</font> (binderName == element.Name) <br> element.SetValue( <font color="#0000ff">value</font> ); <br> <font color="#0000ff">else</font> <br> element.SetElementValue(binderName, <font color="#0000ff">value</font> ); <br> <font color="#0000ff">return</font> <font color="#0000ff">true</font> ; <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  The main difference with the implementation of the <b>TryGetValue</b> method is that when accessing a sub element that is not in the original xml tree, instead of generating an exception, an element with the specified name will be added.  The implementation of the <b>TrySetMember</b> method <b>is</b> also not too complicated due to the fact that the <b>XElement</b> method does for us all the wrong work. <b>SetElementValue</b> , which will be added by the element with the necessary name if necessary. <br><br><h4>  findings </h4><br>  I do not exclude at all that the above implementation contains errors or is not perfect in this or that matter.  However, the main task of the article is to show the principle of creating dynamic shells around statically typed objects, as well as to show the benefits of dynamic programming in an initially statically typed programming language like C #.  And although this implementation may be far from ideal, it is very well tested, and successfully participates in a couple of small projects.  In addition, it is freely available on <a href="https://github.com/SergeyTeplyakov/DynamicXml">github</a> , and each of you can be used by its ideas (as well as implementation) at its own discretion. <br><br>  <b>Once again, the source code of the DynamicXml library is available <a href="https://github.com/SergeyTeplyakov/DynamicXml">here</a> .</b> <br><br>  - (*) The most interesting thing is that the DLR - Dynamic Language Runtime has no relation to the execution time, but is only a ‚Äúnormal‚Äù library that cunningly manipulates expression trees. <br><br>  (**) There are several examples showing this feature, for example, <a href="http://bugsquash.blogspot.com/2009/05/testing-private-methods-with-c-40.html">here</a> and <a href="http://igoro.com/archive/use-c-dynamic-typing-to-conveniently-access-internals-of-an-object/">here</a> . <br><br>  (***) This is a slightly modified example that John Skeat used in one of the examples for his book ‚ÄúC # In Depth‚Äù, 2nd edition. </div><p>Source: <a href="https://habr.com/ru/post/119036/">https://habr.com/ru/post/119036/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../119029/index.html">Microsoft & Skype. Small FAQ</a></li>
<li><a href="../119030/index.html">Working with a GSM module using the example of SIM900D</a></li>
<li><a href="../119031/index.html">Saturday time is in full swing! Another Ciklum .NET Saturday - now in Kharkov</a></li>
<li><a href="../119033/index.html">Version 1.5.0 released, now with Go support</a></li>
<li><a href="../119035/index.html">Programmer's Spirits</a></li>
<li><a href="../119039/index.html">Features new version of the game framework Flixel 2.5</a></li>
<li><a href="../119040/index.html">Poll. Test automation tools</a></li>
<li><a href="../119041/index.html">Maybe investors are not enemies, just someone does not know how to prepare them?</a></li>
<li><a href="../119042/index.html">Photoshop companion software for iPad: Adobe Nav, Adobe Color Lava and Adobe Eazel</a></li>
<li><a href="../119046/index.html">Apple vs Microsoft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>