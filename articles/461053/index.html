<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We connect online maps to the navigator on the smartphone. Part 2 - vector cards</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We are writing a server application that will generate PNG raster tiles based on online vector maps. Use web scraping with Puppeteer to get map data. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We connect online maps to the navigator on the smartphone. Part 2 - vector cards</h1><div class="post__text post__text-html js-mediator-article"><p>  We are writing a server application that will generate PNG raster tiles based on online vector maps.  Use web scraping with Puppeteer to get map data. </p><a name="habracut"></a><br><h3 id="soderzhanie">  Content: </h3><br><p>  1 - <a href="https://habr.com/ru/post/461031/">Introduction.</a>  <a href="https://habr.com/ru/post/461031/">Standard raster maps</a> <br>  2 - Continuation.  Writing a simple rasterizer for vector maps <br>  3 - <a href="https://habr.com/ru/post/461073/">A special case.</a>  <a href="https://habr.com/ru/post/461073/">We connect the OverpassTurbo card</a> </p><br><h3 id="prodolzhenie">  Continuation </h3><br><p>  And so we got to the most interesting topic.  Imagine that we found a site with a map that we really want to add to our navigator.  We do everything in accordance with the instructions from the <a href="https://habr.com/ru/post/461031/">previous part</a> .  We open the viewing of the contents of the site, and there are no pictures!  Absolutely.  Well, a couple of icons and that's it.  And some other text file with a list of coordinates. </p><br><p>  Congratulations, we found a vector map.  Roughly speaking, it is rendered in real time by your browser.  So she doesn‚Äôt need any prepared tiles at all.  On the one hand, there are not so many vector maps so far.  But this technology is very promising and over time they can become many times more.  Well, we figured it out.  And yet, what do we do now? </p><br><p>  Firstly, you can try to download a browser of a very, very old version.  One that does not support the functions required to render the map.  It is possible that you will be shown a different version of the site.  With raster map.  Well, what you need to do with it you already know. </p><br><p>  However, if this trick did not work, but you still really want to get this card, and, moreover, not in the smartphone‚Äôs browser, namely in your navigator, then there is a way. </p><br><h3 id="osnovnaya-ideya">  main idea </h3><br><p>  We will proceed from the fact that we want to get a map that can be opened in any of the navigators.  Then we need an adapter - a kind of intermediary that will generate tiles for us in PNG format. </p><br><p>  It turns out that you need <del>  invent a bicycle </del>  develop another engine for visualizing vector data.  Well, or you can write a script that will go to the site, letting it draw its own vector map on its own.  And then it will wait for the download, take a screenshot, crop and return to the user.  Perhaps I will choose the second option. </p><br><p>  To take screenshots, I will use a ‚Äúremote-control browser‚Äù - Headless Chrome.  You can control it using the node js library <strong>Puppeteer</strong> .  You can learn about the basics of working with this library from <a href="https://habr.com/ru/company/ruvds/blog/341348/">this article</a> . </p><br><h3 id="hello-world-ili-sozdaem-i-nastraivaem-proekt">  Hello World!  Or create and customize a project </h3><br><p>  If you have not already installed Node.js then go to <a href="https://nodejs.org/en/download/">this</a> or <a href="https://nodejs.org/en/download/package-manager/">this</a> page, select your operating system and perform the installation according to the instructions. </p><br><p>  Create a new folder for the project and open it in the terminal. </p><br><pre><code class="plaintext hljs">$ cd /Mapshoter_habr</code> </pre> <br><p>  We start the manager of creating a new project </p><br><pre> <code class="plaintext hljs">$ npm init</code> </pre> <br><p>  Here you can specify the name of the project ( <strong>package name</strong> ), the name of the file for entering the application ( <strong>entry point</strong> ) and the name of the author ( <strong>author</strong> ).  For all other queries, we agree to the default parameters: do not enter anything and just press <strong>Enter</strong> .  At the end - press <strong>y</strong> and <strong>Enter</strong> . </p><br><p>  Next, install the necessary frameworks to work.  Express for creating a server and Puppeteer for working with a browser. </p><br><pre> <code class="plaintext hljs">$ npm install express $ npm i puppeteer</code> </pre> <br><p>  As a result, the project configuration file <strong>package.json</strong> appears in the project folder.  In my case, this: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"mapshoter_habr"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"router.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"nnngrach"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"ISC"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"dependencies"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"express"</span></span>: <span class="hljs-string"><span class="hljs-string">"^4.17.1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"puppeteer"</span></span>: <span class="hljs-string"><span class="hljs-string">"^1.18.1"</span></span> } }</code> </pre> <br><p>  I‚Äôll add a start line to the scripts section to launch our application more conveniently. </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"node router.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span> },</code> </pre> <br><p>  Now create two files with the implementation of the basic functionality.  The first file is the entry point to the application.  In my case, <strong>router.js</strong> .  He will create a server and do routing. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//        const express = require( 'express' ) const mapshoter = require( './mapshoter' ) //  ,       const PORT = process.env.PORT || 5000 //     const app = express() app.listen( PORT, () =&gt; { console.log( '    ', PORT ) }) //       // http://siteName.com/x/y/z app.get( '/:x/:y/:z', async ( req, res, next ) =&gt; { //      const x = req.params.x const y = req.params.y const z = req.params.z //      const screenshot = await mapshoter.makeTile( x, y, z ) //        const imageBuffer = Buffer.from( screenshot, 'base64' ) //    res.writeHead( 200, { 'Content-Type': 'image/png', 'Content-Length': imageBuffer.length }) //    res.end( imageBuffer ) })</span></span></code> </pre> <br><p>  Now create a second file.  He will control the browser and take screenshots.  I have it called <strong>mapshoter.js</strong> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   const browser = await puppeteer.launch() //       const page = await browser.newPage() await page.goto( 'https://www.google.ru/' ) //    const screenshot = await page.screenshot() //      await browser.close() return screenshot } module.exports.makeTile = makeTile</span></span></code> </pre> <br><p>  Run our script and check its performance.  To do this, type in the console: </p><br><p> <code>$ npm start</code> </p> <br><p>  A message appears that says ‚ÄúServer is created on port 5000‚Äù.  Now open a browser on your computer and go to the local address of our server.  Instead of the <strong>x, y, z</strong> coordinates <strong>,</strong> you can enter any numbers.  I entered 1, 2, 3. </p><br><p> <code>http://localhost:5000/1/2/3</code> </p> <br><p>  If everything is done correctly, a screenshot of the Google site will appear. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/66a/8db/ca5/66a8dbca5b15566f395ec6bf4163279c.png" alt="image"></p><br><p>  Press in the console Ctrl + C to stop our script. </p><br><p>  Congratulations, the basis of our application is ready!  We created a server that accepts our html requests, takes a screenshot and returns an image to us.  Now it's time to move on to the implementation of the details. </p><br><h3 id="rasschitaem-koordinaty">  Calculate the coordinates </h3><br><p>  The idea is that the browser will open a site with a map and enter the coordinates of the place that we need in the search bar.  After clicking the ‚ÄúFind‚Äù button, this place will be exactly in the center of the screen.  So it will be easy to cut out the area we need. </p><br><p>  But first, you need to calculate the coordinates of the center of the tile based on its serial number.  I will do this based on the <a href="https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames">formula</a> for finding the upper left corner.  I put it in the <strong>getCoordinates ()</strong> function. </p><br><p>  And since for some sites, in addition to the center of the tile, you also need to specify its borders, then I will look for them as well.  Well, let's create a separate module for these calculations under the name <strong>geoTools.js</strong> .  Here is his code: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   -   function getCoordinates( x, y, z ) { const n = Math.pow( 2, z ) const lon = x / n * 360.0 - 180.0 const lat = 180.0 * ( Math.atan( Math.sinh( Math.PI * ( 1 - 2 * y / n) ) ) ) / Math.PI return { lat: lat, lon: lon } } //          function getCenter( left, rigth, top, bottom ) { let lat = ( left + rigth ) / 2 let lon = ( top + bottom ) / 2 return { lat: lat, lon: lon } } //        function getAllCoordinates( stringX, stringY, stringZ ) { //      const x = Number( stringX ) const y = Number( stringY ) const z = Number( stringZ ) //     //    -  -  const topLeft = getCoordinates( x, y, z ) const bottomRight = getCoordinates( x+1, y+1, z ) //   const center = getCenter( topLeft.lat, bottomRight.lat, topLeft.lon, bottomRight.lon ) //   const bBox = { latMin: bottomRight.lat, lonMin: topLeft.lon, latMax: topLeft.lat, lonMax: bottomRight.lon } return { bBox: bBox, center: center } } module.exports.getAllCoordinates = getAllCoordinates</span></span></code> </pre> <br><p>  Now we are ready to start implementing the script for working with the browser.  Let's look at a few scenarios of how this can be done. </p><br><h3 id="scenariy-1--poisk-s-pomoschyu-api">  Scenario 1 - API Search </h3><br><p>  Let's start with the simplest case when you can simply enter the coordinates in the URL of the map page.  For example, like this: </p><br><p> <code>https://nakarte.me/#m=5/50.28144/89.30666&amp;l=O/Wp</code> </p> <br><p>  Let's look at the script.  Just replace, delete the entire contents of the <strong>mapshoter.js</strong> file and paste the code below. </p><br><p>  In this version, when the browser starts, we specify additional parameters that will allow it to start and work on Linux servers, such as Heroku.  Also now we will reduce the size of the window so that as few map tiles as possible fit on the screen.  Thus, we increase the page loading speed. </p><br><p>  Next, we calculate the coordinates of the center of the desired tile.  We paste them into the URL and click on it.  The tile appears exactly in the center of the screen.  Cut a piece of 256x256 pixels.  This will be the tile that we need.  It remains only to return it to the user. </p><br><p>  Before moving on to the code, I note that for clarity, all error handling has been removed from the script. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoTools = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./geoTools'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    ,    Heroku const herokuDeploymentParams = {'args' : ['--no-sandbox', '--disable-setuid-sandbox']} const browser = await puppeteer.launch( herokuDeploymentParams ) //        //       const page = await browser.newPage() await page.setViewport( { width: 660, height: 400 } ) //         URL const coordinates = geoTools.getAllCoordinates( x, y, z ) const centerCoordinates = `${z}/${coordinates.center.lat}/${coordinates.center.lon}&amp;l=` const pageUrl = 'https://nakarte.me/#m=' + centerCoordinates + "O/Wp" //    URL  ,    await page.goto( pageUrl, { waitUntil: 'networkidle0', timeout: 20000 } ) //    const cropOptions = { fullPage: false, clip: { x: 202, y: 67, width: 256, height: 256 } } const screenshot = await page.screenshot( cropOptions ) //      await browser.close() return screenshot } module.exports.makeTile = makeTile</span></span></code> </pre><br><p>  Now run our script and see the map for this section. </p><br><p> <code>http://localhost:5000/24/10/5</code> </p> <br><p>  If everything is done correctly, then the server should return such a tile: </p><br><p><img src="https://habrastorage.org/webt/gg/t5/gr/ggt5grzq5iuw26bjt2zdhckeoic.png"></p><br><p>  To make sure we don‚Äôt mix anything up when cropping, compare our tile with the original from OpenStreetMaps.org </p><br><p><img src="https://habrastorage.org/webt/32/kp/fs/32kpfsblzjzrx3c16ap3gjpfgx4.png"></p><br><h3 id="scenariy-2--poisk-s-pomoschyu-interfeysa">  Scenario 2 - Search Using the Interface </h3><br><p>  However, it is not always possible to control a card through a browser line.  Well, in such cases, our script will behave like a real living user.  He will print the coordinates in the search box and click on the Search button.  After that, he will remove the marker of the found point, which usually appears in the center of the screen.  And then he will click on the buttons to increase or decrease the scale until he reaches the desired one.  Then it will take a screenshot and return it to the user. </p><br><p>  I note that usually after the search the same scale is set.  15th, for example.  In our example, this does not always happen.  Therefore, we will learn the zoom level from the parameters of the html elements on the page. </p><br><p>  Also in this example, we will look for interface elements using XPath selectors.  But how do you recognize them? </p><br><p>  To do this, open the required page in the browser and open the developer toolbar ( <strong>Ctll + Alt + I</strong> for Google Chrome).  Press the button to select items.  We click on the element you are interested in (I clicked on the search field). </p><br><p><img src="https://habrastorage.org/webt/rb/wu/37/rbwu37fuodlucpg4q_xqfsfk-my.png"></p><br><p>  The list of items scrolls to the one you clicked on and it is highlighted in blue.  Click on the button with three dots to the left of the name. </p><br><p>  From the pop-up menu, select Copy.  Next, if you need a regular selector, then click <strong>Copy selector</strong> .  But for the same example we will use the <strong>Copy XPath</strong> item. </p><br><p><img src="https://habrastorage.org/webt/p9/wo/t-/p9wot-lbr6ho7ttgvmsb9yrfica.png"></p><br><p>  Now we will pass to the code in which selectors for all necessary interface elements are already collected. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoTools = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./geoTools'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      const searchFieldXPath = '//*[@id="map"]/div[2]/div[2]/div[1]/div/div/input' const zoomPlusXPath = '//*[@id="map"]/div[2]/div[2]/div[4]/div[1]/a[1]' const zoomMinusXPath = '//*[@id="map"]/div[2]/div[2]/div[4]/div[1]/a[2]' const directionButonSelector = '#gtm-poi-card-get-directions &gt; i' const deletePinButonSelector = '#map &gt; div.wm-cards &gt; div.wm-card.is-routing &gt; div &gt; div.wm-routing__top &gt; div.wm-routing__search &gt; div &gt; div.wm-route-search__to &gt; div &gt; div.wm-search__clear-icon &gt; div' //         () const coordinates = geoTools.getAllCoordinates( x, y, z ) const centerCoordinates = `lat=${coordinates.center.lat} lng=${coordinates.center.lon}` //      const herokuDeploymentParams = {'args' : ['--no-sandbox', '--disable-setuid-sandbox']} const browser = await puppeteer.launch( herokuDeploymentParams ) const page = await browser.newPage() await page.setViewport( { width: 1100, height: 450 } ) //         const pageUrl = 'https://www.waze.com/en/livemap?utm_campaign=waze_website' await page.goto( pageUrl, { waitUntil: 'networkidle2', timeout: 10000 } ) //    ,      await click( searchFieldXPath, page ) //        await page.keyboard.type( centerCoordinates ) //  Enter    page.keyboard.press( 'Enter' ); //  500     await page.waitFor( 500 ) //       //       await page.click ( directionButonSelector ) await page.waitFor( 100 ) await page.click ( deletePinButonSelector ) await page.waitFor( 100 ) //       //        while( z &gt; await fetchCurrentZoom( page )) { await click( zoomPlusXPath, page ) await page.waitFor( 300 ) } while( z &lt; await fetchCurrentZoom( page )) { await click( zoomMinusXPath, page ) await page.waitFor( 300 ) } //    const cropOptions = { fullPage: false, clip: { x: 422, y: 97, width: 256, height: 256 } } const screenshot = await page.screenshot( cropOptions ) //   await browser.close() return screenshot } //  : //        async function click( xPathSelector, page ) { await page.waitForXPath( xPathSelector ) const foundedElements = await page.$x( xPathSelector ) if ( foundedElements.length &gt; 0 ) { await foundedElements[0].click() } else { throw new Error( "XPath element not found: ", xPathSelector ) } } //         html  async function fetchCurrentZoom( page ) { const xPathSelector = '//*[@id="map"]/div[2]' await page.waitForXPath( xPathSelector ) const elems = await page.$x(xPathSelector) const elementParams = await page.evaluate((...elems) =&gt; { return elems.map(e =&gt; e.className); }, ...elems); const zoom = elementParams[0].split('--zoom-').pop() return zoom } module.exports.makeTile = makeTile</span></span></code> </pre><br><p>  Run our script and follow the link.  If everything is done correctly, then the script will return to us something like this tile. </p><br><p> <code>http://localhost:5000/1237/640/11</code> </p> <br><p><img src="https://habrastorage.org/webt/3c/oo/0l/3coo0lmxp12svhu_m16vecfbjsw.png"></p><br><h3 id="optimizaciya">  Optimization </h3><br><p>  In principle, the two methods described above are enough to connect to many sites with vector maps.  But if you suddenly need access to some new map, you will only need to slightly modify the script in the mapshoter.js file.  That is, this method makes it very easy to add new cards.  This is from its advantages. </p><br><p>  But there are also disadvantages.  And the main one is the speed of work.  Just compare.  On average, it takes about 0.5 seconds to download one regular raster tile.  At the same time, getting one tile from our script at the moment takes about 8 seconds. </p><br><p>  But that is not all!  We use single-threaded node js and our requests will be processed in a queue order.  And when we try to load a map for the whole screen (on which, for example, 24 tiles are placed), that is, there is a risk of encountering a problem.  Some navigators have a timeout: they will stop loading after 30 seconds.  And this means that only 3-4 tiles will have time to load.  Well, let's see what we can do about it. </p><br><p>  Probably the most obvious way is to simply increase the number of servers on which our script will run.  For example, if we have 10 servers, then they will have time to process the tiles for the entire screen in 30 seconds.  In this article, I (soon) will tell you how this can be implemented using free Heroku accounts. </p><br><p>  Secondly, it is still possible to implement multithreading on node js using the <a href="https://habr.com/ru/company/ruvds/blog/437984/">worker_threads</a> module.  According to my observations, on a server with a single-core processor on a free Heroku account, I can start three threads.  Three threads with a separate browser in each, which can work simultaneously without blocking each other.  In fairness, I note that as a result of the increased load on the processor, the download speed of one tile even increased slightly.  However, if you try to load the map for the entire screen, then after 30 seconds more than half the map will have time to load.  More than 12 tiles.  Already better. </p><br><p>  Thirdly.  In the current implementation of the script, with each request, we spend time downloading the Chrome browser, and then completing it.  Now we will create a browser in advance and will transfer a link to it in mapshoter.js.  As a result, the speed will not change for the first request.  But for all subsequent ones, the download speed of one tile is reduced to 4 seconds.  And after 30 seconds the whole map has time to load - all 24 tiles that are placed on my screen. </p><br><p>  Well, let's try to implement all this.  To work with multithreading, I will use the <a href="https://www.npmjs.com/package/node-worker-threads-pool">node-worker-threads-pool</a> module - a kind of wrapper over worker_threads.  Let's install it. </p><br><p> <code>$ npm install node-worker-threads-pool --save</code> </p> <br><p>  Correct the router.js file.  Add to it the creation of a thread pool.  Threads will be 3 pieces.  Their code will be described in the file <strong>worker.js</strong> , we will look at it later.  In the meantime, delete the launch of the screenshot module directly.  Instead, we will add a new task to the thread pool.  They will start processing it when any of the threads is freed. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'express'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PORT = process.env.PORT || <span class="hljs-number"><span class="hljs-number">5000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = express() app.listen( PORT, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( <span class="hljs-string"><span class="hljs-string">'    '</span></span>, PORT ) }) <span class="hljs-comment"><span class="hljs-comment">//   . const { StaticPool } = require( 'node-worker-threads-pool' ) const worker = "./worker.js" const workersPool = new StaticPool({ size: 3, task: worker, workerData: "no" }) app.get( '/:x/:y/:z', async ( req, res, next ) =&gt; { const x = req.params.x const y = req.params.y const z = req.params.z //       //       const screenshot = await workersPool.exec( { x, y, z } ) const imageBuffer = Buffer.from( screenshot, 'base64' ) res.writeHead( 200, { 'Content-Type': 'image/png', 'Content-Length': imageBuffer.length }) res.end( imageBuffer ) })</span></span></code> </pre> <br><p>  Now take a look at the <strong>worker.js</strong> file.  Each time a new task <strong>arrives, the parentPort.on ()</strong> method will be launched.  Unfortunately, it cannot handle async / await functions.  So we will use the adapter function in the form of the <strong>doMyAsyncCode ()</strong> method. </p><br><p>  In it in a conveniently readable format we will put the logic of the worker.  That is, launch the browser (if it is not already running) and activate the method for taking a screenshot.  At startup, we will pass into this method a link to the running browser. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { parentPort, workerData } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapshoter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./mapshoter'</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//     var browser = "empty" //         //    ,     parentPort.on( "message", ( params ) =&gt; { doMyAsyncCode( params ) .then( ( result) =&gt; { parentPort.postMessage( result ) }) }) //  ,    async/aswit //     async function doMyAsyncCode( params ) { //      await prepareEnviroment() //     const screenshot = await mapshoter.makeTile( params.x, params.y, params.z, browser ) return screenshot } //  .     ,    async function prepareEnviroment( ) { if ( browser === "empty" ) { const herokuDeploymentParams = {'args' : ['--no-sandbox', '--disable-setuid-sandbox']} browser = await puppeteer.launch( herokuDeploymentParams ) } }</span></span></code> </pre> <br><p>  For clarity, let us return to the first version of <strong>mapshoter.js</strong> .  It will not change much.  Now in the input parameters it will accept a link to the browser, and when the script ends, it will not turn off the browser, but simply close the created tab. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoTools = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./geoTools'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z, browserLink </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      const browser = await browserLink //      const page = await browser.newPage() await page.setViewport( { width: 660, height: 400 } ) const coordinates = geoTools.getAllCoordinates( x, y, z ) const centerCoordinates = `${z}/${coordinates.center.lat}/${coordinates.center.lon}&amp;l=` const pageUrl = 'https://nakarte.me/#m=' + centerCoordinates + "O/Wp" await page.goto( pageUrl, { waitUntil: 'networkidle0', timeout: 20000 } ) const cropOptions = { fullPage: false, clip: { x: 202, y: 67, width: 256, height: 256 } } const screenshot = await page.screenshot( cropOptions ) //   .   . await page.close() return screenshot } module.exports.makeTile = makeTile</span></span></code> </pre><br><p>  In principle, that's all.  Now you can upload the result to the server in any way convenient for you.  For example, through docker.  If you want to look at the finished result, you can click on <a href="https://nakarte.me/">this link</a> .  You can also find the full project code on my <a href="https://github.com/nnngrach/AnyGIS_Mapshoter">GitHub</a> . </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  Now let's evaluate the result.  On the one hand, even despite all the tricks done, the download speed is still very low.  Moreover, because of the brakes, such a card is simply unpleasant to scroll. </p><br><p>  On the other hand, this script nevertheless copes with cards that before that it was generally impossible to connect to the navigator on the smartphone.  It is unlikely that this solution will be applied as the main method of obtaining cartographic data.  But here as an additional one, with the help of which, if necessary, it will be possible to open some exotic card - it is likely. </p><br><p>  Also, the advantages of this script include the fact that it is easy to work with it.  It is easy to write.  And, most importantly, it can be extremely easily remade to connect any other online card. </p><br><p>  Well, <a href="https://habr.com/ru/post/461073/">in the next article</a> I will deal with just that.  I will transform the script into a kind of API for working with the OverpassTurbo interactive map. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/461053/">https://habr.com/ru/post/461053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461041/index.html">Rounded or acute-angled?</a></li>
<li><a href="../461043/index.html">Conflict management in a team - balancing act or a vital necessity?</a></li>
<li><a href="../461045/index.html">Extracts from Rosreestr through FSIS USRN and python. Part 1 - Sample</a></li>
<li><a href="../461047/index.html">To write or not to write. Letters to authorities during events</a></li>
<li><a href="../461049/index.html">ONYX BOOX Faust - He who seeks is not forced to wander</a></li>
<li><a href="../461055/index.html">Rekko Challenge 2019: how it was</a></li>
<li><a href="../461057/index.html">Telegram channels about game development</a></li>
<li><a href="../461059/index.html">Writing an Android App for Movie Fans - Part 1 (Prototyping)</a></li>
<li><a href="../46106/index.html">3G communicator in our opinion</a></li>
<li><a href="../461061/index.html">Magnesium alloys, twin boundaries and segregation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>