<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Developing a new application architecture for Uber passengers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- Hello. Tell me, how much does an Uber app cost? 

 The incoming call manager of our company receives calls with such content consistently once a wee...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Developing a new application architecture for Uber passengers</h1><div class="post__text post__text-html js-mediator-article">  - Hello.  Tell me, how much does an Uber app cost? <br><br>  The incoming call manager of <a href="http://livetyping.com/">our company</a> receives calls with such content consistently once a week.  Understanding it is usually the case: either the client wants just as successful an analogue of the application for communication between the passenger and the driver, or Uber for ______ (enter the desired industry). <br><br>  At such moments, we answer that Uber is a technically very difficult project with millions of investments and hundreds of thousands of man hours of development, and that making it a clone is not very useful. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now we have an argument in defense of our position.  Uber developers have published a note in the company's blog about the experience of transferring applications from one architecture to a new, own one.  This very large-scale event confirms that Uber is far from an elementary application.  We could not pass by this material and not translate it. <br><br>  The article can be useful not only for mobile developers, but also for managers facing the described situation. <br><br><img src="https://habrastorage.org/files/89f/825/d90/89f825d9072445d9b3559d74df1e108f.jpg"><br><a name="habracut"></a><br><h3>  Why we remade Uber </h3><br>  The idea of ‚Äã‚ÄãUber is simple: click on the button and you will be taken where you want.  Having started as a service for ordering premium black cars, today Uber provides a huge range of services, coordinating millions of trips in hundreds of cities every day.  To comply with the realities of 2017, we had to re-develop the entire application architecture. <br><br>  But where to start?  From the same thing we started in 2009: from scratch.  We decided to completely rewrite our application and redo its design.  The refusal of the accumulated software base and design decisions gave us freedom of action where otherwise we would have to look for compromises.  At the exit, we got a completely new application, licked to shine and giving all the advantages of its new architecture to both iOS users and Android users.  This article describes how we created a new architectural pattern called Riblets and how we achieved our goals with it. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/I1DdoN6NLDg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h3>  Motivation and goals </h3><br>  While the main idea of ‚Äã‚ÄãUber is still the provision of communication between drivers and passengers, our product has grown into something much larger, and the architecture of the former application was no longer able to cope with the increased requirements.  Adding new features to the application from year to year became harder.  Additions such as UberPOOL, scheduled trips and car photos only made it harder to work.  The risk that some part of the application would stop working after making the next change increased day by day along with its size, due to which any experiment could be the cause of a long debugging. <br><br>  At some point, further growth was simply impossible.  In order to maintain the high quality of customer service, we needed to re-examine the simplicity with which we once started, given current requests and the ability to easily evolve in the future. <br><br>  The new application should be simple both for passengers and for Uber developers, who are working every day to improve it and add new features.  To remake the application taking into account the interests of both the first and second, we set ourselves two tasks: the result should be as accessible as possible to passengers and allow radical experiments to be carried out within the product. <br><br><h3>  Reliability is what counts. </h3><br>  The task of the developers is to create an application, the reliability of which will be 99.99%.  This means that the application can be out of service for no more than one hour per year or 1 minute per week, and for 10,000 starts it is given no more than one failure. <br><br>  To achieve this, the structure of the new application was divided into primary and optional codes.  The main code - everything related to the entrance to the application, confirmation, completion and cancellation of the trip - should work like a clock.  Any changes made to the main code are rigorously tested.  Changes made to the optional code are less rigorous and can be disabled without the need to stop the entire application.  Thanks to this code isolation, we have the opportunity to add new features and in the case of incorrect work automatically disable them without delivering any inconvenience to the user. <br><br><h3>  Future plans </h3><br>  We need a platform for which hundreds of teams and thousands of engineers will be able to develop high-quality add-ons and embed them in the application, without causing any inconvenience to passengers.  Therefore, we have made our new architecture cross-platform, so that Android and iOS developers can work on an equal footing with it. <br><br>  Usually, in order to create the perfect application for Android and iOS, a separate approach is required to its architecture, libraries and analytics tools.  The new architecture should use the same patterns and practices for both platforms.  This will allow us to learn from our own mistakes with the maximum benefit, applying the solutions found on one platform, while working with another.  As a result, Android and iOS developers can work closely together to create new options and add-ons. <br><br>  Although in some cases, development takes place individually for each platform (for example, the implementation of the user interface), both platforms have a lot in common: <br><br><ul><li>  basic architecture; </li><li>  class names; </li><li>  the relationship between business logic modules; </li><li>  separation of business logic; </li><li>  Plugin points (names, existence, structure, etc.); </li><li>  reactive programming chains; </li><li>  unified components. </li></ul><br>  To make the most of these common features, our new architecture requires a clear organization and separation between business logic, presentation logic, data flows and routing.  This architecture helps to avoid intricacies, simplify testing and, consequently, increase the productivity of development and reliability of the final product. <br><br><h3>  From MVC to Riblets </h3><br>  Having defined the tasks, we decided to find out how to improve our old architecture and started exploring the possibilities.  The codebase we inherited from the old version of Uber was based on the MVC architectural pattern.  We studied other patterns, for example, VIPER, which we partially used to create Riblets.  The main innovation of Riblets is routing through business logic instead of presentation logic.  If you are not familiar with MVC and Riblets, read a few articles on modern architectural patterns for iOS (for example, <a href="https://habrahabr.ru/company/badoo/blog/281162/">this one</a> ). This will make it easier for you to understand the advantages and disadvantages of adapting these patterns to Uber. <br><br><h4>  What we started with: MVC (Model-View-Controller) </h4><br>  The first application for passengers was written by a small group of developers almost four years ago.  At that moment, using MVC seemed justified.  When the development team grew to a few hundred people, we were confronted with the fact that MVC cannot grow with us.  There were two main reasons: <br><br><ol><li>  The growing MVC architecture often faces a problem called the massive view controller.  For example, RequestViewController, which begins with 300 lines of code, contains more than 3000 lines in its current state due to the large number of responsibilities assigned to it: business logic, data manipulation, data validation, network logic, routing logic, etc.  It became very difficult to read and modify it; </li><li> MVC architecture provides a very fragile code update process and complicates testing.  In the process of developing new additions, we are experimenting a lot.  All our experiments are reduced to working with if-else statements.  Every time a class with a lot of functionality comes across, the if-else statements lean on each other, reducing the possibility of testing.  In addition, with the growth of internal pieces of code, such as RequestViewController and TripViewController, creating updates for an application has become a very fragile and sensitive process.  Imagine what it is - for every possible change to test all possible combinations of if-else statements nested into each other. </li></ol><br>  Since we wanted to continue to experiment with the goal of further developing the application and growing Uber's business, we had to admit that this architecture has exhausted itself. <br><br><h4>  On the way: VIPER </h4><br>  In the process of searching for an alternative to MVC, we found VIPER, which is an example of applying pure architecture in developing iOS applications.  VIPER has several key advantages over MVC: <br><br><ol><li>  he offers much more abstraction.  Presenter contains logic that connects business logic with presentation logic.  Interactor handles data manipulation and verification.  This includes requests to the backend to manipulate the state, for example, to enter or book a trip.  And finally, Router initializes transitions (one of them is like a transition from the home page to the order confirmation page); </li><li>  in the case of VIPER Presenter and Interactor are Plain Old Objects, so we can use regular unit testing. </li></ol><br>  But we also found a few shortcomings with VIPER: <br><ol><li>  its design, specialized for iOS, meant that we would have to look for compromises for Android; </li><li>  its view-driven logic means that applications are controlled by the components of the view, and the entire application is tied to the view tree; </li><li>  The business logic executed by an Interactor, which must control the state of the application, must always pass through the Presenter, in which it is lost; </li><li>  with view trees and logic closely related to each other, the implementation of an element that contains only one type of logic becomes very complex. </li></ol><br>  Being clearly better than MVC, VIPER cannot fully satisfy Uber‚Äôs need for an extensible platform with clear modularity.  Therefore, we returned to the drawing board to try to develop an architectural pattern with the advantages of VIPER and without its drawbacks.  The result was Riblets. <br><br><h3>  Riblets: Uber Passenger Application Architecture </h3><br>  In our new architectural pattern, logic is broken into small independently tested pieces.  Each of the pieces has a single purpose in accordance with the principle of sole responsibility.  We use Riblets in the form of these modular pieces, and the structure of the entire application is the Riblets tree. <br><br><h4>  Riblets and their components </h4><br>  With Riblets, we have divided responsibilities into six different components in order to abstract business logic from presentation logic even more: <br><br><img src="https://habrastorage.org/files/869/475/d64/869475d64bfb4fd88cdc60cc4bda002b.png"><br><br>  What makes Riblets different from VIPER and MVC?  The route is laid by business logic instead of presentation logic.  This means that the application is controlled by the flow of information and decisions made, and not by appearance.  Not every piece of business logic in Uber is related to something that the user sees.  Instead of using business logic in ViewController in MVC or manipulating application states via Presenter in VIPER, we can make a separate Riblet for each piece of business logic, creating local groups that are much easier to work with.  In addition, we developed the Riblet pattern in such a way that it does not depend on the platform.  The latter allows you to combine development for iOS and Android. <br><br>  Each Riblet includes <b>R</b> outer, Instructor and <b>B</b> uilder with its own Component (hence the name) and, if necessary, Presenters and Views.  Router and Interactor are engaged in business logic, while Presenter and View are engaged in presentation logic. <br><br>  Let's look at what each element of Riblet does, using Production Select Rible as an example. <br><br><img src="https://habrastorage.org/files/97a/8ac/df3/97a8acdf337d423c829e684d9d29560e.png"><br>  <i>Tariff selection in the new Uber application</i> <br><br>  <b>Builder</b> <br>  Builder installs all the primary elements of Riblet and the dependencies between them.  In Product Selection Riblet, this element sets the dependency of the data flow for the desired city. <br><br>  <b>Component</b> <br>  Component gets and installs Riblet dependencies.  This includes services, data streams, and everything else that is not the primary element of Riblet.  Product Selection Component receives and establishes a dependency on the city flow, attaches it to the corresponding network events and injects it into Interactor. <br><br>  <b>Routers</b> <br>  Routers form the application tree by attaching and undoing child Riblets.  These solutions are passed to them by the Interactor.  Routers also control the life cycle of Interactor, turning it on and off in certain application states. <br><br>  Routers contain two pieces of business logic: <br><br><ol><li>  Helper methods - to connect and disconnect Routers. </li><li>  State-switching is the logic for determining the state of the child modules. </li></ol><br>  Product Selection Riblet has no child Riblets.  Router of its parent Riblet, Confirmation Riblet, is responsible for attaching the Product Selection Router and adding its View to the Views hierarchy.  Then, when a product is selected, Product Selection Router deactivates its Interactor. <br><br>  <b>Interactors</b> <br>  Interactors perform business logic.  This includes: <br><br><ul><li>  sending service calls to launch an action, such as ordering a trip; </li><li>  sending service calls to receive data; </li><li>  state determination for switching.  For example, if the root Interactor sees that the user authorization token is missing, it sends its switching request to the Router to the Welcome state. </li></ul><br><br>  Product Selection Interactor takes a city stream containing data, including offers from the services of this city, pricing information, approximate travel times and photographs of cars, and transmits this information to Presenter.  If the user moves from uberPOOL to uberX, Interactor receives this information from Presenter, after which he collects all the relevant data and sends it back to View so that it displays the uberX cars and estimated time of arrival.  In short, Interactor executes all the business logic that the View then displays. <br><br>  <b>View (Controller)</b> <br>  Views configure and update the user interface, including the creation and location of individual elements, user interaction, and the filling of interface elements with data and animation.  View in Product Selection Riblet displays the objects that Presenter passes to it (trip configuration, prices, estimated time of arrival, car image on the map) and returns user actions (i.e., product selection). <br><br>  <b>Presenter</b> <br>  Presenter manages communication between Interactors and Views.  From Interactors to Views, the Presenter delivers the business models of the objects that the View displays.  In the case of Product Selection, the Riblet is pricing and vehicle image data.  Also, the task of Presenter is to convert user actions (such as clicking on the product select button) into commands, which are then passed to Interactor. <br><br><h3>  Putting it all together </h3><br>  Each Riblet contains only one pair of Router and Interactor, but it can have several parts of the presentation.  Riblet, which is solely responsible for business logic and has no user interface elements, does not contain a view part. <br><br>  Riblet can be: <br><br><ul><li>  single-view (one Presenter and one View); </li><li>  multi-view (either one Presenter and several View, or several Presenter and View); </li><li>  viewless (without Presenter and View). </li></ul><br>  This allows business logic trees to be deep and different from flatter view trees, making switching between screens easier. <br><br>  For example, Ride Riblet is viewless.  Its task is to check whether the user has an active trip.  If so, it connects Trip Riblet, which shows the trip route on the map.  If not, the Request Riblet is connected, showing a screen on which the user can book a trip.  The main task of Riblets that do not contain presentation logic (such as Ride Riblet) is to isolate the business logic that controls our applications, thereby preserving the modular structure of our new architecture. <br><br><h2>  How to create an application from Riblets </h2><br>  Riblets are combined into an application tree and they need to keep in touch with each other in order to update information or guide the user to the next step of the trip order.  Before we tell you how they communicate with each other, let's see how the data is transmitted within a single Riblet. <br><br><h4>  Data stream inside Riblet </h4><br>  Interactor stores the business logic that controls the application and is within the purview of this Interactor.  This element makes service requests to get the necessary data. <br><br>  Data in the new architecture is always transmitted in one direction only.  They move from Service to Model Stream, and then to Interactor.  Interactors, event planners, and push notifications from the Internet can query Services to make changes to the Model Stream. <br><br>  Model Stream creates immobile models.  This creates requirements according to which in order to change the state of an application, the Interactor classes must use the service layer. <br><br><img src="https://habrastorage.org/files/7d9/faa/ec3/7d9faaec31944c3eacf28470f5c800f7.png"><br><br>  Examples of threads: <br><br><ul><li>  from backend of service to View: request to services, for example, request of the status, data about which are taken from backend.  The data is placed in an immutable Model Stream.  Interactor, listening to this stream, notices the new data and sends it to the Presenter.  Presenter converts data and transfers it to View; </li><li>  from View to backend: the user presses a button, for example, ‚ÄúLogin‚Äù, and View transfers this action to the Presenter.  Presenter calls the sign-in method in Interactor, which creates a request for the services to enter the application.  The service sends the returned token to the stream, and the Interactor listening to this stream switches to Home Riblet. </li></ul><br><br><h4>  Interaction between Riblets </h4><br><br><img src="https://habrastorage.org/files/879/22d/c55/87922dc55c07477a97cb68266f91f9e2.png"><br><br>  When Interactor makes a decision, he may need to inform the other Riblet about it and send the data.  For this, Interactor invokes an interface that negotiates it with the Interactor of another Riblet. <br><br>  In case the connection goes up the tree to the Interactor of the parent Riblet, the interface is defined as a Listener.  The listener is almost always set by the Interactor of the parent Riblet.  If the connection goes down to the child Riblet, the interface must be defined as a delegate, and the Interactor of the child Riblet is set.  Delegates are used only for direct synchronous communication between elements, for example, a parent Interactor with a child. <br><br>  In the case of a downlink, the parent Riblet can direct the data stream to the Interactor child of the Riblet observable, the parent Interactor can then send data through this stream instead of the delegate interface.  In most cases of downlink communication, a similar method should be preferred. <br><br>  For example, when a hypothetical ProductSelectionInteractor understands that a product has been selected, it refers to its listener established by the ConfirmationInteractor and passes it the view identifier (ID) of the selected vehicle.  The ConfirmationInteractor saves this ID in order to send it in the request to the services and sends to its Router a request to ‚Äúdisable‚Äù the ProductSelection Riblet. <br><br>  By structuring in a similar way the flow of data within and between Riblets, we can be sure that the right data will be displayed at the right moment on the right screen.  Since the Riblets tree is based on business logic, we can communicate at the level of business logic instead of presentation logic.  This makes a lot more sense and helps to keep code isolation, protecting application development from unnecessary complications. <br><br><h3>  Back to the roots </h3><br>  When we decided to completely redo our application, we wanted to get closer to the user due to the increased reliability and create the right conditions for future developments.  To achieve these two goals, the creation of a new architecture was a vital step. <br><br><h4>  How we have achieved increased reliability and availability for the end user </h4><br>  Riblets have clearly defined responsibilities, so testing has become much easier.  Each Riblet can be tested independently.  With such features, we can be sure that our application will not get bugs after the next update.  Due to the fact that each Riblet bears one and only responsibility, we were able to easily separate Riblets into the main one (necessary for entering the application and ordering a trip to uberPOOL and uberX) and an optional code.  By making higher demands on checks of the main code, we can be sure that the main functions of the program will work with maximum reliability. <br><br>  We also made possible the global rollback of the main functionalities of the program to a guaranteed working state.  All optional code is marked with flags master feature, which can be turned off if parts of the code contain errors or are unstable.  In the worst case scenario, we can disable absolutely all optional code, leaving only the base.  Given our stringent requirements for the main code, we can be sure that it will always work. <br><br><h4>  How we created the right conditions for future development </h4><br>  Thanks to the narrow specialization of each Riblet, we were able to draw a clear line between business logic and presentation logic.  This can prevent the inordinate growth of the code base and preserve its simplicity.  Since the new architecture is cross-platform, iOS and Android developers can easily understand each other's work, learn from the mistakes of their comrades, and work together to further develop Uber.  Experiments will have less influence on the performance of the application core, since Riblets helps us to separate the optional code from the main one.  We will be able to test new add-ons created in the form of plug-ins, without fear that they may accidentally disable the entire application. <br><br>  Since the main feature of Riblets is the maximum abstraction and separation of responsibilities, as well as well-defined data streams and methods of communication, further development of the project becomes very simple, and this architecture will serve us faithfully for many years. <br><br><h3>  Willingness to go ahead </h3><br>  We have high hopes for our new architecture.  We completely rewrote the application code for passengers, re-adding everything that already existed previously, conducting user surveys, case studies, various tests and updating the options, among which there is now a news line.  We tried to do everything possible so that our users received the updated application as soon as possible, so we listen to feedback from around the globe regarding design, options, localizations, work on various devices and testing capabilities.  Despite the fact that the launch of the application is already behind, there is still a lot of work ahead. <br><br>  Thanks to the new architecture, we have a huge number of opportunities for further development.  To be honest, we spent a couple of months building prototypes to make sure that we did everything right.  Now we are fully confident that we have an architecture with which we can achieve a lot.  If you like this job, you can become part of our history and improve your view on Uber by participating in development as an iOS or Android developer. </div><p>Source: <a href="https://habr.com/ru/post/320452/">https://habr.com/ru/post/320452/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320436/index.html">10 questions for the informed choice of the SIEM system</a></li>
<li><a href="../320438/index.html">5 of the ‚Äúhottest‚Äù new books in January</a></li>
<li><a href="../320446/index.html">Mapping in C # on the example of the serializer for AMF</a></li>
<li><a href="../320448/index.html">User comfort in VR: player parameters</a></li>
<li><a href="../320450/index.html">A simple version of an indoor video surveillance system using a motion sensor and Python on the Raspberry platform</a></li>
<li><a href="../320454/index.html">ITSM educational program: How to meet customer expectations</a></li>
<li><a href="../320456/index.html">Uncomplicated SCRUM and Image Segmentation for Highlighting Post-it Stickers</a></li>
<li><a href="../320458/index.html">Arduino on car wash</a></li>
<li><a href="../320460/index.html">Exploit Exercises: Introducing binary vulnerabilities using the example of Protostar</a></li>
<li><a href="../320462/index.html">SystemJS 0.20 - Combining with browser modules</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>