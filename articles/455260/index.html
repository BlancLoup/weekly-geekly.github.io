<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Merkle Tree: rusty and fast</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! Recently discovered the language of Rust. He shared his first impressions in a previous article . Now I decided to dig a little deeper, this re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Merkle Tree: rusty and fast</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/02/we/l8/02wel89vk_uuxibqbvaiimofkkk.png" alt="image"></p><br><p>  Hello!  Recently discovered the language of Rust.  He shared his first impressions in a <a href="https://habr.com/ru/post/433302/">previous article</a> .  Now I decided to dig a little deeper, this requires something more serious than the list.  My choice fell on the tree Merkle.  In this article I want: </p><br><ul><li>  tell about this data structure </li><li>  look at what is already in Rust </li><li>  offer your implementation </li><li>  compare performance </li></ul><a name="habracut"></a><br><h1 id="derevo-merkla">  Merkle tree </h1><br><p>  This is a relatively simple data structure, and there is already a lot of information about it on the Internet, but I think my article will be incomplete without a description of the tree. </p><br><h2 id="v-chyom-problema">  What is the problem </h2><br><p>  The Merkle tree was invented back in 1979, but gained its popularity thanks to the blockchain.  The chain of blocks in the network has a very large size (for bitcoin it is more than 200 GB), and not all nodes can deflate it.  For example, telephones or cash registers.  However, they need to be aware of the fact that a transaction has been included in the block.  For this, the protocol <a href="https://en.bitcoinwiki.org/wiki/Simplified_Payment_Verification">SPV - Simplified Payment Verification</a> was invented. </p><br><h2 id="kak-ustroeno-derevo">  How the tree works </h2><br><p>  This is a binary tree whose leaves are the hashes of any objects.  To build the next level, the hashes of neighboring leaves are taken in pairs, concatenated, and the hash from the result of the concatenation is calculated, which is illustrated in the picture in the header.  Thus, the root of the tree is a hash of all leaves.  If you remove or add an element, the root will change. </p><br><h2 id="kak-rabotaet-derevo">  How the tree works </h2><br><p>  With the Merkle tree, you can build evidence that the transaction is included in the block as a path from the transaction hash to the root.  For example, we are interested in the Tx2 transaction, for which the proof will be (Hash3, Hash01).  This mechanism is used in SPV.  The client extorts only the block header with its hash.  Having a transaction of interest, he asks for proof from the node containing the entire chain.  Then does the check for Tx2 it will be: </p><br><pre><code class="plaintext hljs">hash(Hash01, hash(Hash2, Hash3)) = Root Hash</code> </pre> <br><p>  The result obtained is compared with the root of the block header.  This approach makes it impossible to fake evidence, since in this case the result of the test will not converge with the contents of the header. </p><br><h1 id="kakie-uzhe-est-realizacii">  What are already implemented </h1><br><p>  Rust is a young language, but many implementations of the Merkle tree are already written on it.  Judging by Github, at the moment 56, this is more than C and C ++ combined.  Although Go makes them stand up with 80 implementations. </p><br><h2 id="spinresearchmerklershttpsgithubcomspinresearchmerklers">  <a href="">SpinResearch / merkle.rs</a> </h2><br><p>  For my comparison, I chose this implementation by the number of stars in the repository. </p><br><p>  This tree is constructed in the most obvious way, that is, it is a graph of objects.  As I have already noted, this approach is not quite Rust-friendly.  For example, it is impossible to make bidirectional communication from children to parents. </p><br><p>  The construction of the proof occurs through the search in depth.  If the sheet with the desired hash is found, then the path to it will be the result. </p><br><h2 id="chto-mozhno-uluchshit">  What can be improved </h2><br><p>  It was just not interesting for me to do the (n + 1) th implementation, so I thought about optimization.  The code for my <em>vector-merkle-tree</em> is on <a href="https://github.com/zharkomi/vector-merkle-tree">Github</a> . </p><br><h3 id="hranenie-dannyh">  Data storage </h3><br><p>  The first thing that comes to mind is to shift the tree to an array.  This solution will be much better in terms of data locality: more cache hits and better preloading.  Traversing objects scattered in memory takes longer.  A convenient fact is that all hashes have the same length, since  calculated by one algorithm.  The Merkle tree in the array will look like this: <br><img src="https://habrastorage.org/webt/7_/in/4_/7_in4_ijawhhqj4f9pldunhl2mu.png" alt="image"></p><br><h3 id="dokazatelstvo">  Evidence </h3><br><p>  When initializing a tree, you can create a HashMap with indices of all leaves.  Thus, when there is no sheet, it is not necessary to bypass the whole tree, and if there is, then you can immediately go to it and rise to the root, building a proof.  In my implementation, I made HashMap optional. </p><br><h3 id="konkatenaciya-i-heshirovanie">  Concatenation and hashing </h3><br><p>  It would seem that there can be improved?  Everything is clear, we take two hashes, glue them together and calculate the new hash.  But the fact is that this function is non-commutative, i.e.  hash (H0, H1) ‚â† hash (H1, H0).  Because of this, when constructing evidence, it is necessary to memorize which side the adjacent node is located.  This makes the algorithm harder to implement, and adds the need to store extra data.  Everything is very easy to fix, just sort the two nodes before hashing.  For example, I cited Tx2, with regard to commutativity, the test will look like this: </p><br><pre> <code class="plaintext hljs">hash(hash(Hash2, Hash3), Hash01) = Root Hash</code> </pre> <br><p>  When you don‚Äôt need to take care of the order, the check algorithm looks like a simple convolution of an array: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, proof: &amp;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;&amp;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { proof[<span class="hljs-number"><span class="hljs-number">2</span></span>..].iter() .fold( get_pair_hash(proof[<span class="hljs-number"><span class="hljs-number">0</span></span>], proof[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.algo), |a, b| get_pair_hash(a.as_ref(), b, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.algo) ).as_ref() == <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.get_root() }</code> </pre> <br><p>  The zero element is the hash of the desired object, the first is its neighbor. </p><br><h1 id="pognali">  Let's go! </h1><br><p>  The story would be incomplete without a performance comparison, which took me several times longer than the implementation of the tree itself.  For these purposes, I used the <a href="https://docs.rs/criterion/0.2.11/criterion/">criterion</a> framework.  The sources of the tests themselves are <a href="https://github.com/zharkomi/merkle-tree-test-rs">here</a> .  All testing takes place through the <em>TreeWrapper</em> interface, which was implemented for both experimental: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TreeWrapper</span></span></span></span>&lt;V&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, c: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Criterion, counts: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;, data: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;V&gt;&gt;, title: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, c: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Criterion, counts: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;, data: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;V&gt;&gt;, title: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, c: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Criterion, counts: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;, data: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;V&gt;&gt;, title: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>); }</code> </pre> <br><p>  Both trees work with the same <a href="https://github.com/briansmith/ring"><em>ring</em></a> cryptography.  Here I am not going to compare different libraries.  Took the most common. </p><br><p>  Randomly generated strings are used as hashing objects.  Trees are compared on arrays of various lengths: (500, 1000, 1500, 2000, 2500 3000).  2500 - 3000 is the approximate number of transactions in the bitcoin block at the moment. </p><br><p>  On all graphs on the X axis - the number of elements of the array (or the number of transactions in the block), Y - the average time to perform the operation in microseconds.  That is, the more, the worse. </p><br><h2 id="sozdanie-dereva">  Tree creation </h2><br><p>  Storing all tree data in a single array greatly exceeds the performance of object graphs.  For an array with 500 elements 1.5 times, and for 3000 elements already 3.6 times.  The nonlinear nature of the dependence of complexity on the volume of input data in the standard implementation is clearly visible. </p><br><p>  Also in comparison, I added two variants of a vector tree: with and without <em>HashMap</em> .  Filling an additional data structure adds about 20%, but it allows you to search for objects much faster when constructing a proof. <br><img src="https://habrastorage.org/webt/xk/nf/kj/xknfkjl5aqy8oqagfzaj05p1qo4.png" alt="image"></p><br><h2 id="postroenie-dokazatelstva">  Building evidence </h2><br><p>  Here is the apparent inefficiency of the search in depth.  With the increase in input data, it only gets worse.  It is important to understand that the required objects are sheets, so the complexity of <em>log (n)</em> cannot be.  If the data is pre-hashed, the operation time is practically independent of the number of elements.  Without hashing, complexity grows linearly and consists in searching through brute force. <br><img src="https://habrastorage.org/webt/py/lc/20/pylc206tjr1oraib8eynbeeatym.png" alt="image"></p><br><h2 id="validaciya-dokazatelstva">  Validation of evidence </h2><br><p>  This is the last operation.  It does not depend on the structure of the tree, because  works with the result of constructing evidence.  I believe that the main difficulty here is the calculation of the hash. <br><img src="https://habrastorage.org/webt/2h/n6/hk/2hn6hkfzrbhxnejuihg2xx2hpoc.png" alt="image"></p><br><h1 id="itog">  Total </h1><br><ul><li>  The way data is stored greatly affects performance.  When everything is in one array, it is much faster.  And it will be very easy to serialize such a structure.  The total amount of code is also reduced. </li><li>  Concatenating nodes with sorting greatly simplifies the code, but does not make it faster. </li></ul><br><h1 id="nemnogo-o-rust">  A little about Rust </h1><br><ul><li>  Like the <em>criterion</em> framework.  Produces clear results with averages and deviations complete with graphs.  Able to compare different implementations of the same code. </li><li>  Lack of inheritance does not interfere with life. </li><li>  Macros - a powerful mechanism.  I used them in <a href="">tests of my tree</a> for parameterization.  I think if you use them badly, you can do this, that you will not be happy then. </li><li>  Mostly the compiler tired of its memory checks.  My initial assumption that starting so simply by writing on Rust did not work out was true. <br><img src="https://habrastorage.org/webt/1n/uw/mf/1nuwmfwfozbeosqyvhtmbybur7w.png" alt="image"></li></ul><br><h1 id="ssylki">  Links </h1><br><ul><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE_%25D1%2585%25D0%25B5%25D1%2588%25D0%25B5%25D0%25B9">A more complete description of the operation algorithm of the Merkle tree</a> </li><li>  <a href="https://docs.rs/criterion/0.2.11/criterion/">criterion - load testing framework</a> </li><li>  <a href="">merkle.rs - the most popular tree under Rust</a> </li><li>  <a href="https://github.com/zharkomi/vector-merkle-tree">vector-merkle-tree - my implementation of the tree</a> </li><li>  <a href="https://github.com/zharkomi/merkle-tree-test-rs">merkle-tree-test-rs - a project for comparing the performance of two libraries</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/455260/">https://habr.com/ru/post/455260/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455244/index.html">Comics "easy soldering" in the updated version (2019)</a></li>
<li><a href="../455246/index.html">Registration for the Customer Experience Day in St. Petersburg June 20</a></li>
<li><a href="../455248/index.html">Top errors from the development side when working with PostgreSQL</a></li>
<li><a href="../455256/index.html">Habr Weekly # 4 / Computex, like Apple‚Äôs Beta Apple, Durov is starving, BadComedian cat, why did the neural network look for pornacteres</a></li>
<li><a href="../455258/index.html">Voting began for the reports of the Backend section at the anniversary DevConfX, which will be held June 21-22 in Moscow</a></li>
<li><a href="../455268/index.html">How it all began: flexible and foldable displays - the story of the emergence and exit "in people"</a></li>
<li><a href="../455272/index.html">TheOutloud - voice and share your favorite articles and stories</a></li>
<li><a href="../455274/index.html">Microsoft launches large-scale educational initiative in Russian universities</a></li>
<li><a href="../455276/index.html">Cloud games: Google Stadia announced pricing for users.</a></li>
<li><a href="../45528/index.html">About Opera Workshop at KPI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>