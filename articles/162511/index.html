<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Framework in Marmalade (part 4)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the last article of the Marmalade Framework development cycle , we will add animated and composite sprites to the project, as well as build a small...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Framework in Marmalade (part 4)</h1><div class="post__text post__text-html js-mediator-article">  In the last article <a href="http://habrahabr.ru/post/161681/">of the</a> Marmalade Framework development <a href="http://habrahabr.ru/post/161681/">cycle</a> , we will add animated and composite sprites to the project, as well as build a small demo application illustrating how to use the library. <br><a name="habracut"></a><br>  Since we are developing an event-oriented Framework, the execution of any action (and animation including) will be performed as a result of processing any event.  The set of basic events will be defined in the Desktop module. <br><br><div class="spoiler">  <b class="spoiler_title">Desktop.h</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _DESKTOP_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _DESKTOP_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;set&gt; #include "s3eKeyboard.h" #include "Scene.h" using namespace std; enum EMessageType { emtNothing = 0x00, emtHide = 0x01, emtShadow = 0x02, emtShow = 0x03, emtSwitch = 0x04, emtInit = 0x05, emtFix = 0x08, emtStartAnimation = 0x06, emtStopAnimation = 0x07, emtActivate = 0x09, emtSystemMessage = 0x0F, emtTouchEvent = 0x10, emtTouchIdMask = 0x03, emtTouchMask = 0x78, emtMultiTouch = 0x14, emtTouchOut = 0x18, emtTouchDown = 0x30, emtTouchUp = 0x50, emtTouchOutUp = 0x58, emtTouchMove = 0x70, emtSingleTouchDown = 0x30, emtSingleTouchUp = 0x50, emtSingleTouchMove = 0x70, emtMultiTouchDown = 0x34, emtMultiTouchUp = 0x54, emtMultiTouchMove = 0x74, emtKeyEvent = 0x80, emtKeyAction = 0x82, emtKeyDown = 0x81, emtKeyPressed = 0x83, emtKeyReleased = 0x82 }; ...</span></span></span></span></code> </pre> <br></div></div><br>  As we will see later, we can easily define new events without modifying the Desktop module.  Listing EMessageType is nothing more than a convenient way to put all the basic event codes together  The task of the animated sprite is to encapsulate the processing of basic events.  The animated sprite interface contains only two methods: <br><br><div class="spoiler">  <b class="spoiler_title">IAnimatedSprite.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _IANIMATEDSPRITE_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IANIMATEDSPRITE_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include "Desktop.h" using namespace std; class IAnimatedSprite { public: virtual bool isValidMessage(int msg) = 0; virtual void doMessage(int msg, void* data = NULL, uint64 timestamp = 0) = 0; }; #endif // _IANIMATEDSPRITE_H_</span></span></span></span></code> </pre><br></div></div><br>  The isValidMessage method checks whether a sprite can process an event of a specified type (if an event cannot be processed by a sprite, it is passed to its containing container ‚Äî a composite sprite or scene), and the doMessage method performs processing.  In addition to the event code, msg, you can pass a pointer to arbitrary data, data, and a timestamp, which is calculated at each loop iteration in Main.cpp, to the handler. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The implementation of AnimatedSprite will look like this: <br><br><div class="spoiler">  <b class="spoiler_title">AnimatedSprite.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _ANIMATEDSPRITE_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _ANIMATEDSPRITE_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;map&gt; #include &lt;vector&gt; #include "Sprite.h" #include "IAnimatedSprite.h" #include "AnimateMessage.h" #include "ResourceManager.h" #define REFRESH_CNT 2 using namespace std; class AnimatedSprite: public Sprite, public IAnimatedSprite { protected: struct Message { Message(int id, uint64 timestamp, void* data = NULL): id(id), timestamp(timestamp), data(data) {} Message(const Message&amp; m): id(m.id), timestamp(m.timestamp), data(m.data) {} int id; void* data; uint64 timestamp; }; struct CurrentMessage { CurrentMessage(AnimateMessage* message, uint64 timestamp): message(message), timestamp(timestamp), lastTimeDelta(0), isEmpty(false) {} CurrentMessage(const CurrentMessage&amp; m): message(m.message), timestamp(m.timestamp), lastTimeDelta(m.lastTimeDelta), isEmpty(m.isEmpty) {} AnimateMessage* message; uint64 timestamp; uint64 lastTimeDelta; bool isEmpty; }; int state; map&lt;int, ResourceHolder*&gt; images; map&lt;int, AnimateMessage*&gt; rules; uint64 lastTimestamp; vector&lt;Message&gt; messages; vector&lt;CurrentMessage&gt; currentMessages; bool isAnimated; int refreshCnt; public: AnimatedSprite(ISpriteOwner* scene, int x, int y, int zOrder = 0); AnimatedSprite(ISpriteOwner* scene, const char* res, int x, int y, int zOrder = 0, int loc = elNothing); ~AnimatedSprite(); void clearMessageRules() {rules.clear();} void addMessageRule(int msg, AnimateMessage* rule); virtual void addImage(const char*res, int id = 0, int loc = 0); virtual CIw2DImage* getImage(int id = 0); virtual int getState(); virtual bool setState(int newState); virtual void update(uint64 timestamp); virtual void refresh(); virtual bool sendMessage(int msg, uint64 timestamp = 0, void* data = NULL); virtual bool isBuzy() {return false;} virtual bool isValidMessage(int msg) {return (msg &lt;= emtSystemMessage);} virtual void doMessage(int msg, void* data = NULL, uint64 timestamp = 0); virtual void unload(); typedef map&lt;int, ResourceHolder*&gt;::iterator IIter; typedef pair&lt;int, ResourceHolder*&gt; IPair; typedef map&lt;int, AnimateMessage*&gt;::iterator RIter; typedef pair&lt;int, AnimateMessage*&gt; RPair; typedef vector&lt;Message&gt;::iterator MIter; typedef vector&lt;CurrentMessage&gt;::iterator CIter; }; #endif // _ANIMATEDSPRITE_H_</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">AnimatedSprite.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"AnimatedSprite.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Desktop.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Locale.h"</span></span></span><span class="hljs-meta"> AnimatedSprite::AnimatedSprite(ISpriteOwner* scene, int x, int y, int zOrder): Sprite(scene, x, y, zOrder) , state(0) , images() , lastTimestamp(0) , messages() , currentMessages() , isAnimated(false) , refreshCnt(REFRESH_CNT) , rules() {} AnimatedSprite::AnimatedSprite(ISpriteOwner* scene, const char* res, int x, int y, int zOrder, int loc): Sprite(scene, x, y, zOrder) , state(0) , images() , lastTimestamp(0) , messages() , currentMessages() , isAnimated(false) , refreshCnt(REFRESH_CNT) , rules() { AnimatedSprite::addImage(res, 0, loc); } AnimatedSprite::~AnimatedSprite() { for (RIter p = rules.begin(); p != rules.end(); ++p) { delete p-&gt;second; } } void AnimatedSprite::unload() { for (IIter p = images.begin(); p != images.end(); ++p) { p-&gt;second-&gt;unload(); } } void AnimatedSprite::addMessageRule(int msg, AnimateMessage* rule) { RIter p = rules.find(msg); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (p != rules.end()) { return; } rules.insert(RPair(msg, rule)); } void AnimatedSprite::addImage(const char*res, int id, int loc) { ResourceHolder* img = rm.load(res, loc); images.insert(IPair(id, img)); } bool AnimatedSprite::setState(int newState) { IIter p = images.find(newState); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (p == images.end()) { return false; } state = newState; return true; } CIw2DImage* AnimatedSprite::getImage(int id) { IIter p = images.find(id); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (p == images.end()) { return NULL; } return p-&gt;second-&gt;getData(); } int AnimatedSprite::getState() { return state; } void AnimatedSprite::doMessage(int msg, void* data, uint64 timestamp) { init(); int s = getState(); switch (msg) { case emtStartAnimation: isAnimated = true; break; case emtStopAnimation: isAnimated = false; break; case emtSwitch: s++; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (getImage(s) == NULL) { s = 0; } setState(s); return; case emtHide: isVisible = false; return; case emtShadow: isVisible = true; alpha = IW_2D_ALPHA_HALF; return; case emtShow: isVisible = true; alpha = IW_2D_ALPHA_NONE; return; }; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (timestamp == 0) { timestamp = s3eTimerGetMs(); } RIter p = rules.find(msg); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (p != rules.end()) { for (CIter q = currentMessages.begin(); q != currentMessages.end(); ++q) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (q-&gt;isEmpty) { q-&gt;isEmpty = false; q-&gt;message = p-&gt;second; q-&gt;timestamp = timestamp; q-&gt;lastTimeDelta = 0; return; } } currentMessages.push_back(CurrentMessage(p-&gt;second, timestamp)); } } bool AnimatedSprite::sendMessage(int msg, uint64 timestamp, void* data) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!isValidMessage(msg)) { return false; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (timestamp </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;= lastTimestamp) { doMessage(msg, data); return true; } messages.push_back(Message(msg, timestamp, data)); return true; } void AnimatedSprite::update(uint64 timestamp) { bool isEmpty = true; for (MIter p = messages.begin(); p != messages.end(); ++p) { if (p-&gt;timestamp &lt;= lastTimestamp) continue; if (p-&gt;timestamp &lt;= timestamp) { doMessage(p-&gt;id, p-&gt;data, p-&gt;timestamp); continue; } isEmpty = false; } if (isEmpty) { messages.clear(); } isEmpty = true; for (CIter p = currentMessages.begin(); p != currentMessages.end(); ++p) { if (p-&gt;isEmpty) continue; uint64 timeDelta = timestamp - p-&gt;timestamp; if (!p-&gt;message-&gt;update(timeDelta, p-&gt;lastTimeDelta)) { p-&gt;isEmpty = true; continue; } p-&gt;lastTimeDelta = timeDelta; isEmpty = false; } if (isEmpty) { currentMessages.clear(); } lastTimestamp = timestamp; } void AnimatedSprite::refresh() { if (isAnimated) { if (--refreshCnt &lt;= 0) { refreshCnt = REFRESH_CNT; doMessage(emtSwitch); } } Sprite::refresh(); }</span></span></span></span></code> </pre><br></div></div><br>  Unlike a regular sprite, an animated one can load multiple images by associating them with some numeric values.  These values ‚Äã‚Äãwill be referred to as sprite states.  Event handling will be done in doMessage. <br><br>  Another important component of our library will be a composite sprite, allowing you to manipulate a set of sprites (including composite and animated) as a single entity.  The implementation of this class is very primitive: <br><br><div class="spoiler">  <b class="spoiler_title">CompositeSprite.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _COMPOSITESPRITE_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _COMPOSITESPRITE_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"AnimatedSprite.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"AbstractSpriteOwner.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Scene.h"</span></span></span><span class="hljs-meta"> class CompositeSprite: public AnimatedSprite , public AbstractSpriteOwner { protected: ISpriteOwner* owner; public: CompositeSprite(ISpriteOwner* scene, int x, int y, int zOrder); virtual int getXSize(int xSize); virtual int getYSize(int ySize); virtual int getXPos(int x); virtual int getYPos(int y); virtual bool setState(int newState); virtual void refresh(); virtual void update(uint64 timestamp); virtual bool isBuzy(); virtual bool sendMessage(int msg, uint64 timestamp = 0, void* data = NULL); virtual bool sendMessage(int msg, int x, int y); virtual void unload(); }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// _COMPOSITESPRITE_H_</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">CompositeSprite.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CompositeSprite.h"</span></span></span><span class="hljs-meta"> CompositeSprite::CompositeSprite(ISpriteOwner* scene, int x, int y, int zOrder): AnimatedSprite(scene, x, y, zOrder), owner(scene), AbstractSpriteOwner() {} int CompositeSprite::getXSize(int xSize) { return owner-&gt;getXSize(xSize); } int CompositeSprite::getYSize(int ySize) { return owner-&gt;getYSize(ySize); } int CompositeSprite::getXPos(int x) { return AbstractScreenObject::getXPos() + owner-&gt;getXPos(x); } int CompositeSprite::getYPos(int y) { return AbstractScreenObject::getYPos() + owner-&gt;getYPos(y); } void CompositeSprite::refresh() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (isVisible) { init(); AbstractSpriteOwner::refresh(); } } void CompositeSprite::update(uint64 timestamp) { AnimatedSprite::update(timestamp); AbstractSpriteOwner::update(timestamp); } bool CompositeSprite::isBuzy() { return AnimatedSprite::isBuzy(); } bool CompositeSprite::sendMessage(int msg, uint64 timestamp, void* data) { return AnimatedSprite::sendMessage(msg, timestamp, data) || owner-&gt;sendMessage(msg, timestamp, data); } bool CompositeSprite::sendMessage(int msg, int x, int y) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!isVisible) return false; return AbstractSpriteOwner::sendMessage(msg, x, y); } bool CompositeSprite::setState(int newState) { state = newState; return true; } void CompositeSprite::unload() { AbstractSpriteOwner::unload(); }</span></span></code> </pre><br></div></div><br>  In order to be able to define a fairly complex animation, we define the rules of animation, in accordance with the following scheme: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/461/65c/ff3/46165cff37462353e4d375190d2b3aa2.png" alt="image"><br><br>  Several collections are added to AnimatedSprite.  The rules will contain the correspondence of the numeric codes of the messages to some of the more detailed AnimateMessage animation rules.  The currentMessages list will contain the list of rules that are used for the animation at the present time (several rules can be processed at the same time), the messages will contain the messages to be processed. <br><br>  In turn, AnimateMessage will contain a list of basic AnimateAction actions, for each of which the start and end time of the action will be specified, relative to the start time of the animation (these values ‚Äã‚Äãwill be the same for actions performed one time). <br><br><div class="spoiler">  <b class="spoiler_title">AnimateMessage.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _ANIMATEMESSAGE_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _ANIMATEMESSAGE_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;set&gt; #include "s3eTypes.h" #include "AnimateAction.h" using namespace std; class AnimateMessage { private: set&lt;AnimateAction*&gt; actions; public: AnimateMessage(); ~AnimateMessage(); bool update(uint64 newDelta, uint64 oldDelta); void addAction(AnimateAction* action) {actions.insert(action);} typedef set&lt;AnimateAction*&gt;::iterator AIter; }; #endif // _ANIMATEMESSAGE_H_</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">AnimateMessage.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"AnimateMessage.h"</span></span></span><span class="hljs-meta"> AnimateMessage::AnimateMessage(): actions() {} AnimateMessage::~AnimateMessage() { for (AIter p = actions.begin(); p != actions.end(); ++p) { delete *p; } } bool AnimateMessage::update(uint64 newDelta, uint64 oldDelta) { bool r = false; for (AIter p = actions.begin(); p != actions.end(); ++p) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((*p)-&gt;isSheduled(oldDelta)) { r = true; (*p)-&gt;update(newDelta); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { (*p)-&gt;clear(); } } return r; }</span></span></code> </pre><br></div></div><br>  The update method takes two timestamps: the current and the previous values.  Its implementation is trivial.  All AnimateAction is iterated and, in case its animation is not completed, the update method is called.  Otherwise, the AnimateAction state is reset to its original state.  If at least one element is found, the animation of which is not completed, the update method returns true. <br><br><div class="spoiler">  <b class="spoiler_title">AnimateAction.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _ANIMATEACTION_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _ANIMATEACTION_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"s3eTypes.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"AbstractScreenObject.h"</span></span></span><span class="hljs-meta"> class AnimateAction { private: uint64 startDelta; uint64 stopDelta; protected: AbstractScreenObject* sprite; virtual void doAction(int timeDelta) = 0; virtual int getTimeInterval() {return (int)(stopDelta - startDelta);} public: AnimateAction(AbstractScreenObject* sprite, uint64 startDelta, uint64 stopDelta); virtual ~AnimateAction() {} virtual bool isSheduled(uint64 timeDelta); virtual void update(uint64 timeDelta); virtual void clear() {} }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// _ANIMATEACTION_H_</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">AnimateAction.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"AnimateAction.h"</span></span></span><span class="hljs-meta"> AnimateAction::AnimateAction(AbstractScreenObject* sprite, uint64 startDelta, uint64 stopDelta): sprite(sprite) , startDelta(startDelta) , stopDelta(stopDelta) { } bool AnimateAction::isSheduled(uint64 timeDelta) { return timeDelta </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; stopDelta; } void AnimateAction::update(uint64 timeDelta) { if (timeDelta &gt;= startDelta) { uint64 delta = timeDelta - startDelta; if (timeDelta &gt; stopDelta) { delta = stopDelta - startDelta; } doAction((int)delta); } }</span></span></span></span></code> </pre><br></div></div><br>  The isSheduled method returns true if the received timestamp is less than the completion time of the action.  If the received timestamp is greater than or equal to the start time of the action, the value of the time elapsed since the start of the action (but no longer than the total duration of the execution of the action) is passed to the doAction method.  Since the previous timestamp value is passed to the isSheduled method, at least one doAction is guaranteed to be executed. <br><br>  Inheriting from AnimateAction, we can expand the list of basic animation effects.  As examples of the heirs of AnimateAction, consider the MoveAction ‚Äî which performs the rectilinear movement of an object and the SoundAction, which plays the sound effect, after a set time. <br><br><div class="spoiler">  <b class="spoiler_title">MoveAction.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _MOVEACTION_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MOVEACTION_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"AnimateAction.h"</span></span></span><span class="hljs-meta"> class MoveAction: public AnimateAction { private: int x, y; int startX, startY; bool isCleared; protected: virtual void doAction(int timeDelta); virtual void clear() {isCleared = true;} public: MoveAction(AbstractScreenObject* sprite, uint64 startDelta, uint64 stopDelta, int x, int y); MoveAction(AbstractScreenObject* sprite, uint64 delta, int x, int y); }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// _MOVEACTION_H_</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">MoveAction.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"MoveAction.h"</span></span></span><span class="hljs-meta"> MoveAction::MoveAction(AbstractScreenObject* sprite, uint64 startDelta, uint64 stopDelta, int x, int y): AnimateAction(sprite, startDelta, stopDelta) , x(x), y(y), isCleared(true) {} MoveAction::MoveAction(AbstractScreenObject* sprite, uint64 delta, int x, int y): AnimateAction(sprite, delta, delta) , x(x), y(y), isCleared(true) {} void MoveAction::doAction(int timeDelta) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (isCleared) { startX = sprite-&gt;getXDelta(); startY = sprite-&gt;getYDelta(); isCleared = false; } int timeInterval = getTimeInterval(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (timeInterval </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;= 0) { sprite-&gt;setDeltaXY(x, y); } else if (timeDelta &gt; timeInterval) { sprite-&gt;setDeltaXY(x, y); } else { int xInterval = x - startX; int yInterval = y - startY; int xDelta = (xInterval * timeDelta) / timeInterval; int yDelta = (yInterval * timeDelta) / timeInterval; sprite-&gt;setDeltaXY(startX + xDelta, startY + yDelta); } }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">SoundAction.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _SOUNDACTION_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SOUNDACTION_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include "IwSound.h" #include "AnimateAction.h" #include "Locale.h" using namespace std; class SoundAction: public AnimateAction { private: string res; int loc; bool checkSound(); protected: virtual void doAction(int timeDelta); public: SoundAction(AbstractScreenObject* sprite, uint64 timeDelta, const char* r, int loc = elSound); }; #endif // _SOUNDACTION_H_</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">SoundAction.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SoundAction.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Desktop.h"</span></span></span><span class="hljs-meta"> SoundAction::SoundAction(AbstractScreenObject* sprite, uint64 timeDelta, const char* r, int loc): AnimateAction(sprite, timeDelta, timeDelta) , res(r), loc(loc) { } void SoundAction::doAction(int timeDelta) { CIwResGroup* resGroup; const char* groupName = Locale::getGroupName(loc); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (checkSound() &amp;&amp;(groupName != NULL)) { resGroup = IwGetResManager()-&gt;GetGroupNamed(groupName); CIwSoundSpec* SoundSpec = (CIwSoundSpec*)resGroup-&gt;GetResNamed(res.c_str(), IW_SOUND_RESTYPE_SPEC); CIwSoundInst* SoundInstance = SoundSpec-&gt;Play(); } } bool SoundAction::checkSound() { IObject* o = (IObject*)desktop.getName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"soundon"</span></span></span><span class="hljs-meta">); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (o != NULL) { return (o-&gt;getState() != 0); } return false; }</span></span></code> </pre><br></div></div><br>  As we can see, the AnimateAction kit can easily be expanded. <br><br>  Using the animation mechanisms described above, we will create a small user interface to control the settings of a typical Android application.  For a start, we need buttons.  The buttons should respond to pressing by performing a simple animation: <br><br><div class="spoiler">  <b class="spoiler_title">Button.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _BUTTON_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _BUTTON_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"AnimatedSprite.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"AbstractSpriteOwner.h"</span></span></span><span class="hljs-meta"> enum EButtonMessage { ebmDown = 0x0100, ebmUp = 0x0101, ebmOutUp = 0x0111, ebmPressed = 0x0102 }; class Button: public AnimatedSprite { protected: AnimateMessage* msgDown; AnimateMessage* msgUp; int message; AbstractSpriteOwner* receiver; void configure(); public: Button(ISpriteOwner* scene, const char* res, int x, int y, int zOrder = 0, int loc = elNothing); Button(ISpriteOwner* scene, int x, int y, int zOrder = 0); virtual bool isValidMessage(int msg); virtual bool sendMessage(int msg, uint64 timestamp = 0, void* data = NULL); virtual void doMessage(int msg, void* data = NULL, uint64 timestamp = 0); virtual bool isPausable() const {return false;} void addReceiver(int m, AbstractSpriteOwner* r); }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// _BUTTON_H_</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Button.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Button.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Desktop.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"MoveAction.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SendMessageAction.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SoundAction.h"</span></span></span><span class="hljs-meta"> Button::Button(ISpriteOwner* scene, const char* res, int x, int y, int zOrder, int loc): AnimatedSprite(scene, res, x, y, zOrder, loc), receiver(NULL) { Button::configure(); } Button::Button(ISpriteOwner* scene, int x, int y, int zOrder): AnimatedSprite(scene, x, y, zOrder), receiver(NULL) { Button::configure(); } void Button::configure() { msgDown = new AnimateMessage(); msgDown-&gt;addAction(new MoveAction(this, 0, 50, 10, 10)); msgDown-&gt;addAction(new SoundAction(this, 50, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"menubutton"</span></span></span><span class="hljs-meta">)); addMessageRule(ebmDown, msgDown); msgUp = new AnimateMessage(); msgUp-&gt;addAction(new MoveAction(this, 100, 150, 0, 0)); addMessageRule(ebmOutUp, msgUp); msgUp = new AnimateMessage(); msgUp-&gt;addAction(new MoveAction(this, 100, 150, 0, 0)); msgUp-&gt;addAction(new SendMessageAction(this, 100, ebmPressed)); msgUp-&gt;addAction(new SendMessageAction(this, 110, emtInit)); addMessageRule(ebmUp, msgUp); } bool Button::isValidMessage(int msg) { switch (msg) { case emtTouchDown: case emtTouchUp: case ebmDown: case ebmUp: case ebmOutUp: case ebmPressed: return true; default: return AnimatedSprite::isValidMessage(msg); } } void Button::doMessage(int msg, void* data, uint64 timestamp) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (msg == ebmPressed) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (receiver != NULL) { receiver-&gt;sendMessage(message, 0, (IObject*)this); } return; } AnimatedSprite::doMessage(msg, data, timestamp); } bool Button::sendMessage(int msg, uint64 timestamp, void* data) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((msg &amp; emtTouchEvent) != 0) { switch (msg &amp; emtTouchMask) { case emtTouchDown: sendMessage(ebmDown, desktop.getCurrentTimestamp()); break; case emtTouchUp: sendMessage(ebmUp, desktop.getCurrentTimestamp()); break; case emtTouchOutUp: sendMessage(ebmOutUp, desktop.getCurrentTimestamp()); break; } return true; } return AnimatedSprite::sendMessage(msg, timestamp, data); } void Button::addReceiver(int m, AbstractSpriteOwner* r) { message = m; receiver = r; }</span></span></code> </pre><br></div></div><br>  In the sendMessage method, we process Touchpad event codes to form internal events that the button works with.  In configure, animation is associated with these events; when clicked, the button moves 10 units down and to the right, when released, returns to its place.  In the event that, when released, the touch point has not left the button, an ebmPressed event is generated, with which we can associate an arbitrary handler. <br><br>  In addition to the usual buttons, we need buttons, switches, with a variable picture.  Since this button should also be animated when pressed, we inherit it from Button: <br><br><div class="spoiler">  <b class="spoiler_title">SwitchButton.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _SWITCHBUTTON_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SWITCHBUTTON_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Button.h"</span></span></span><span class="hljs-meta"> class SwitchButton: public Button { protected: void configure(); public: SwitchButton(ISpriteOwner* scene, int x, int y, int zOrder = 0); virtual bool sendMessage(int msg, uint64 timestamp = 0, void* data = NULL); }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// _SWITCHBUTTON_H_</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">SwitchButton.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SwitchButton.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Desktop.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"MoveAction.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SendMessageAction.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SoundAction.h"</span></span></span><span class="hljs-meta"> SwitchButton::SwitchButton(ISpriteOwner* scene, int x, int y, int zOrder): Button(scene, x, y, zOrder) { SwitchButton::configure(); } void SwitchButton::configure() { msgUp-&gt;addAction(new SendMessageAction(this, 50, emtSwitch)); } bool SwitchButton::sendMessage(int msg, uint64 timestamp, void* data) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (msg == emtSwitch) { doMessage(msg, 0, timestamp); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (receiver != NULL) { receiver-&gt;sendMessage(message, 0, (IObject*)this); } return true; } return Button::sendMessage(msg, timestamp, data); }</span></span></code> </pre><br></div></div><br>  We simply add emtSwitch event firing buttons to the animation, which switches the image for any AnimatedSprite. <br><br>  Now everything is ready for the development of the user interface.  The Intro class will contain two screens - the start screen and the settings screen. <br><br><div class="spoiler">  <b class="spoiler_title">Intro.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _INTRO_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _INTRO_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Scene.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CompositeSprite.h"</span></span></span><span class="hljs-meta"> enum EIntroMessage { eimPlay = 0x100, eimSettings = 0x101, eimBack = 0x102, eimCheckMusic = 0x103 }; enum EIntroStatus { eisMain = 0, eisSettings = 1 }; class Intro: public Scene { private: Sprite* background; CompositeSprite* title; CompositeSprite* menu; CompositeSprite* settings; int state; void checkMusic(); protected: virtual bool doKeyMessage(int msg, s3eKey key); virtual int getState() {return state;} void setState(int s) {state = s;} public: Intro(); virtual bool init(); virtual bool sendMessage(int msg, uint64 timestamp = 0, void* data = NULL); }; extern Intro* introScene; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// _INTRO_H_</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Intro.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Intro.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Background.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"IntroTitle.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"IntroMenu.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"IntroSound.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Desktop.h"</span></span></span><span class="hljs-meta"> Intro* introScene = NULL; Intro::Intro(): state(eisMain) { introScene = this; } bool Intro::init() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!Scene::init()) return false; regKey(s3eKeyBack); regKey(s3eKeyAbsBSK); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined IW_DEBUG regKey(s3eKeyLSK); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> background = new Background(this, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"background.png"</span></span></span><span class="hljs-meta">, 1); title = new IntroTitle(this, 2); menu = new IntroMenu(this, 3); settings = new IntroSound(this, 4); settings-&gt;doMessage(emtHide); checkMusic(); return true; } bool Intro::doKeyMessage(int msg, s3eKey key) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (msg == emtKeyPressed) { switch (state) { case eisSettings: sendMessage(eimBack); return true; } } return false; } bool Intro::sendMessage(int msg, uint64 timestamp, void* data) { switch (msg) { case eimPlay: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// </span></span><span class="hljs-doctag"><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span></span><span class="hljs-meta"><span class="hljs-comment"> return true; case eimSettings: background-&gt;setAlpha(IW_2D_ALPHA_HALF); title-&gt;doMessage(emtHide); menu-&gt;doMessage(emtHide); settings-&gt;doMessage(emtShow); setState(eisSettings); return true; case eimBack: background-&gt;setAlpha(IW_2D_ALPHA_NONE); title-&gt;doMessage(emtShow); menu-&gt;doMessage(emtShow); settings-&gt;doMessage(emtHide); setState(eisMain); return true; case emtInit: case eimCheckMusic: checkMusic(); return true; } return false; } void Intro::checkMusic() { bool f = false; IObject* o = (IObject*)desktop.getName("musicon"); if (o == NULL) { desktop.stopMusic(); return; } f = (o-&gt;getState() != 0); if (f) { desktop.startMusic("music.mp3"); } else { desktop.stopMusic(); } }</span></span></span></span></code> </pre><br></div></div><br>  The Intro class represents the only scene in our application that loads multiple CompositeSprite.  SendMessage defines event handlers.  Next, we define several composite sprites whose task will be to display the name of the program, as well as the menu, implemented as a set of buttons. <br><br><div class="spoiler">  <b class="spoiler_title">IntroTitle.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _INTROTITLE_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _INTROTITLE_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string.h&gt; #include "CompositeSprite.h" class IntroTitle: public CompositeSprite { public: IntroTitle(Scene* scene, int zOrder): CompositeSprite(scene, 0, 0, zOrder) {} virtual bool init(); virtual void refresh(); }; #endif // _INTROTITLE_H_</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">IntroTitle.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"IntroTitle.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Sprite.h"</span></span></span><span class="hljs-meta"> bool IntroTitle::init() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!AbstractScreenObject::init()) return false; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Sprite settings setXY(122, 100); // Sprite components new Sprite(this, "sprite.png", 0, 0, 1); return true; } void IntroTitle::refresh() { CompositeSprite::refresh(); }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">IntroMenu.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _INTROMENU_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _INTROMENU_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CompositeSprite.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Button.h"</span></span></span><span class="hljs-meta"> class IntroMenu: public CompositeSprite { private: Scene* scene; Button* firstButton; Button* secondButton; public: IntroMenu(Scene* scene, int zOrder): CompositeSprite(scene, 0, 0, zOrder), scene(scene) {} virtual bool init(); }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// _INTROMENU_H_</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">IntroMenu.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"IntroMenu.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Locale.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Intro.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Desktop.h"</span></span></span><span class="hljs-meta"> bool IntroMenu::init() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!AbstractScreenObject::init()) return false; setXY(297, 384); firstButton = new Button(this, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"play"</span></span></span><span class="hljs-meta">, 0, 0, 1, Locale::getCurrentImageLocale()); firstButton-&gt;addReceiver(eimPlay, scene); secondButton = new Button(this, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"setup"</span></span></span><span class="hljs-meta">, 0, 157, 2, Locale::getCurrentImageLocale()); secondButton-&gt;addReceiver(eimSettings, scene); return true; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">IntroSound.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _INTROSOUND_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _INTROSOUND_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CompositeSprite.h"</span></span></span><span class="hljs-meta"> class IntroSound: public CompositeSprite { private: Scene* scene; public: IntroSound(Scene* scene, int zOrder): CompositeSprite(scene, 0, 0, zOrder), scene(scene) {} virtual bool init(); }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// _INTROSOUND_H_</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">IntroSound.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"IntroSound.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SwitchButton.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Button.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Intro.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Locale.h"</span></span></span><span class="hljs-meta"> bool IntroSound::init() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!AbstractScreenObject::init()) return false; setXY(346, 227); SwitchButton* s = new SwitchButton(this, 0, 0, 1); s-&gt;addImage(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"musicoff"</span></span></span><span class="hljs-meta">, 0, Locale::getCurrentImageLocale()); s-&gt;addImage(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"musicon"</span></span></span><span class="hljs-meta">, 1, Locale::getCurrentImageLocale()); s-&gt;setName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"musicon"</span></span></span><span class="hljs-meta">); s-&gt;setState(1); s-&gt;addReceiver(eimCheckMusic, scene); s = new SwitchButton(this, 0, 157, 2); s-&gt;addImage(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"soundoff"</span></span></span><span class="hljs-meta">, 0, Locale::getCurrentImageLocale()); s-&gt;addImage(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"soundon"</span></span></span><span class="hljs-meta">, 1, Locale::getCurrentImageLocale()); s-&gt;setName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"soundon"</span></span></span><span class="hljs-meta">); s-&gt;setState(1); Button* b = new Button(this, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"back.png"</span></span></span><span class="hljs-meta">, -300, 350, 3, Locale::getCommonImageLocale()); b-&gt;addReceiver(eimBack, scene); return true; }</span></span></code> </pre><br></div></div><br>  By running the application, you can make sure that the buttons react to pressing, and also perform the specified switching between screens. <br><br>  So, we managed to develop the simplest Framework, at the same time having studied some of the features of the Marmalade API for developing cross-platform mobile applications.  Of course, the developed library lacks very much to be considered a full-fledged gaming Framework (for example, it does not support the implementation of physics), but its underlying flexible architecture makes it easy to add any necessary extensions. <br><br>  The source code of the project is located at the following <a href="https://github.com/GlukKazan/mf">link</a> . <br><br>  In developing the Marmalade Framework, the following <a href="http://www.drmop.com/index.php/marmalade-sdk-tutorials/">materials were used</a> . <br></div><p>Source: <a href="https://habr.com/ru/post/162511/">https://habr.com/ru/post/162511/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../162501/index.html">Measuring the performance of "cloud" drives - saving MySQL</a></li>
<li><a href="../162503/index.html">Sony VAIO Duo 11 Ultrabook (tablet) video review (SVD-1121QR)</a></li>
<li><a href="../162505/index.html">Russian AI Cup: results</a></li>
<li><a href="../162507/index.html">Linux is growing! New Mint 14 for OEM; lightweight DSL, Core and Puppy, and more and more Linux jobs in the new State of Linux infographic</a></li>
<li><a href="../162509/index.html">NIC Teaming on Windows Server 2012</a></li>
<li><a href="../162515/index.html">What is better today for the Internet terminal script?</a></li>
<li><a href="../162521/index.html">7 Intel¬Æ VTune Amplifier XE New Features</a></li>
<li><a href="../162527/index.html">Year with Roomba</a></li>
<li><a href="../162529/index.html">Creating the perfect player</a></li>
<li><a href="../162531/index.html">Exporting polygons from Altium Designer to AutoCAD</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>